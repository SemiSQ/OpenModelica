(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 absyn.rml
 ** module:      Absyn
 ** description: Abstract syntax
 **
 ** RCS: $Id$
 **
 ** This file defines the abstract syntax for Modelica in RML.  It mainly
 ** contains datatypes for constructing the abstract syntax tree
 ** (AST), relations for building and altering RML datatypes and a few relations 
 ** for printing the AST.
 **  
 ** absyn.rml's constructors are primarily used by the walker 
 ** (Compiler/absyn_builder/walker.g) which takes an ANTLR internal syntax tree and
 ** converts it into an RML abstract syntax tree.
 **
 ** When the AST has been built, it is normaly used by explode.rml in order to
 ** build the scode (See explode.rml). It is also possile to send the AST do 
 ** the dumper (dump.rml) in order to print it.
 ** 
 ** For details regarding the abstract syntax tree, check out the grammar in 
 ** the Modelica language specification.
 **  
 **)

module Absyn:

  (** An identifier, for example a variable name *)
  type Ident = string

  (** - Programs, the top level construct *)
  (** A program is simply a list of class definitions declared at top
   ** level in the source file, combined with a within statement that
   ** indicates the hieractical position of the program. 
   **)
  datatype Program = PROGRAM of Class list (* classes ; List of classes *)
				* Within (* within ; Within statement *)
		   | BEGIN_DEFINITION   of Path  (* path ; For split definitions*)
				* Restriction (* restriction ; Class restriction *)
				* bool (* partial *)
				* bool (* encapsulated *)
   		   | END_DEFINITION of Ident (* name ; For split definitions *)
		   | COMP_DEFINITION of ElementSpec (* element ; For split definitions*)
					* Path option (* insertInto ;  
						       Default, NONE *)
		   | IMPORT_DEFINITION of ElementSpec(* importElementFor split definitions*)
					* Path option (* insertInto ;  
						       Default, NONE *)


  (** Within statements *)
  datatype Within = WITHIN of Path (* path *)
	| TOP


  (** adrpo added 2005-10-29, changed 2006-02-05 **)
  datatype Info = INFO of string (* fileName where the class is defined in *)
                        * bool   (* isReadOnly : (true|false). Should be true for libraries *)
                        * int    (* lineNumberStart   *)
                        * int    (* columnNumberStart *)
                        * int    (* lineNumberEnd   *)
                        * int    (* columnNumberEnd *)

  (** - Classes *)
  (** A class definition consists of a name, a flag to indicate if this *)
  (** class is declared as `partial', the declared class restriction, *)
  (** and the body of the declaration. *)
  datatype Class = CLASS of Ident		     (* name *)
			  * bool		     (* partial *)
			  * bool		     (* final *)
			  * bool		     (* encapsulated *)
			  * Restriction           (* restricion *)
			  * ClassDef	     (* body *)
			  * Info		     (* info ; FileName the class is defined in + 
			                               isReadOnly bool + 
			                               start line no + start column no +
			                               end line no + end column no *)

 
  (** The `ClassDef' type contains the definition part of a class *)
  (** declaration.  The definition is either explicit, with a list of *)
  (** parts (`public', `protected', `equationc' and `algorithm'), or it *)
  (** is a definition derived from another class or an enumeration type. *)
  (** For a derived type, the  type contains the name of the derived class and an optional *)
  (** array dimension and a list of modifications. An enumeration type contains a list of *)
  datatype ClassDef = PARTS of ClassPart list        (* classParts *)
			       * string option	     (* comment *)
		    | DERIVED of Path                (* path *)
			       * ArrayDim option     (* arrayDim*)
			       * ElementAttributes   (* attributes *)
			       * ElementArg list     (* arguments*)
			       * Comment option	     (* comment *)
		    | ENUMERATION of EnumDef         (* enumLiterals*)
				* Comment option     (* comment*)		
	            | OVERLOAD of Path list (* functionNames *)
				* Comment option (* comment *)
		    | CLASS_EXTENDS of Ident (* name ; class to extend *)
				* ElementArg list  (* arguments*)
				* string option (* comment *)
				* ClassPart list (* parts *)
		    | PDER of Path (* functionName *)
			 * Ident list (* vars ; derived variables *)
				

   (** The definition of an enumeration is either a list of literals
    ** or a colon, ':', which defines a supertype of all enumerations **)
  datatype EnumDef = ENUMLITERALS of EnumLiteral list (* enumLiterals *) 
 		   | ENUM_COLON

  (** EnumLiteral, which is a name in an enumeration and an optional
   Comment.*)
  datatype EnumLiteral = ENUMLITERAL of Ident	     (* literal *)
			 * Comment option	     (* comment *)

  (** A class definition contains several parts.  There are public and *)
  (** protected component declarations, type definitions and `extends' *)
  (** clauses, collectively called elements.  There are also equation *)
  (** sections and algorithm sections. The EXTERNAL part is used only by functions *)
  (** which can be declared as external C or FORTRAN functions. *)
  datatype ClassPart = PUBLIC of ElementItem list (* contents *)
		     | PROTECTED of ElementItem list (* contents *)
		     | EQUATIONS of EquationItem list (* contents *)
		     | INITIALEQUATIONS of EquationItem list (* contents *)	
		     | ALGORITHMS of AlgorithmItem list (* contents *)
		     | INITIALALGORITHMS of AlgorithmItem list (* contents *)
		     | EXTERNAL of ExternalDecl (* externalDecl *)
                                 * Annotation option (* annotation *)

  (** An element item is either an element or an annotation *)
  datatype ElementItem = ELEMENTITEM of Element (* element *)
		       | ANNOTATIONITEM of Annotation (* annotation *)

  (** - Elements *)
  (* The basic element type in Modelica *)
  datatype Element = ELEMENT of bool		      (* final *)
			        * RedeclareKeywords option (* redeclareKeywords ; replaceable, redeclare *)
			        * InnerOuter	      (* innerOuter ; inner/outer *)	     
			        * Ident                 (* name *)
			        * ElementSpec           (* specification ; Actual element specification*)
			        * Info	         (* info ; File name the class is defined in + line no + column no *)
			        * ConstrainClass option (* constrainClass ; only valid for classdef and component*)
			       | TEXT of Ident option (* optName : optional name of text, e.g. model with syntax error.
			                                 We need the name to be able to browse it...*)
                          *  string        (* text *)
                          *  Info          (* info : filename, readonly bool, start and stop position of text *)
			      

  
  (* Constraining type, must be extends *)
  datatype ConstrainClass = CONSTRAINCLASS of ElementSpec (* elementSpec ; must be extends*)
					    * Comment option (* comment *)

  (** An element is something that occurs in a public or protected
   ** section in a class definition.  There is one constructor in the
   ** `ElementSpec' type for each possible element type.  There are
   ** class definitions (`CLASSDEF'), `extends' clauses (`EXTENDS')
   ** and component declarations (`COMPONENTS').
   ** 
   ** As an example, if the element `extends TwoPin;' appears
   ** in the source, it is represented in the AST as
   ** `EXTENDS(IDENT("TwoPin"),[])'.
   **)
  datatype ElementSpec = CLASSDEF of bool	     (* replaceable *)
				   * Class           (* class *)
		       | EXTENDS of Path (* path *)
                                  * ElementArg list (* elementArg *)
		       | IMPORT of Import (* import *)
                                 * Comment option (* comment *)
		       | COMPONENTS of ElementAttributes (* attributes*)
				     * Path	     (* typeName *)
				     * ComponentItem list (* components *)

  (** One of the keyword inner and outer CAN be given to reference an inner or
      outer component. Thus there are three disjoint possibilities. **)		     
  datatype InnerOuter = INNER | OUTER | INNEROUTER | UNSPECIFIED

  (* Import statements, different kinds  *) 				     
  datatype Import = NAMED_IMPORT of Ident (* name *)
                                  * Path (* path *)
		  | QUAL_IMPORT of Path (* path *)
		  | UNQUAL_IMPORT of Path (* path *)

  (* Collection of component and an optional comment *)
  datatype ComponentItem = COMPONENTITEM of Component (* component *)
					  * ComponentCondition option (* condition *)
					  * Comment option (* comment *)

(* A componentItem can have a condition that must be fulfilled if
 ** the component should be instantiated.
 **)
 type ComponentCondition = Exp

  (* Some kind of Modelica entity (object or variable) *)
  datatype Component = COMPONENT of Ident 	     (* name *)
				  * ArrayDim         (* arrayDim ; Array dimensions, if any *) 
				  * Modification option (* modification ; Optional modification *) 

  (** Several component declarations can be grouped together in one *)
  (** `ElementSpec' by writing them on the same line in the source. *)
  (** This type contains the information specific to one component. *)
  datatype EquationItem = EQUATIONITEM of Equation (* equation *)
                                        * Comment option (* comment *)
			| EQUATIONITEMANN of Annotation (* annotation *)

  (** Info specific for an algorithm item. *)
  datatype AlgorithmItem = ALGORITHMITEM of Algorithm (* algorithm *)
                                          * Comment option (* comment *)
			 |  ALGORITHMITEMANN of Annotation (* annotation *)

  (* Information on one (kind) of equation, different constructors for different
     kinds of equations *)
  datatype Equation = EQ_IF of Exp                     (* ifExp ; Conditional expression *)
			     * EquationItem list	     (* equationTrueItems ; true branch *)  
			     * (Exp * EquationItem list) list (* elseIfBranches *)
			     * EquationItem list	     (* equationElseItems *)
                    (* Standard 2-side eqn*)
		    | EQ_EQUALS of Exp (* leftSide *)
                                 * Exp (* rightSide *)          
                    (* Connect stmt *)
		    | EQ_CONNECT of ComponentRef (* connector1 *)
                                  * ComponentRef (* connector2 *)
		    | EQ_FOR of Ident (* forVariable *)
                              * Exp   (* forExp *)
                              * EquationItem list  (* forEquations *)
		    | EQ_WHEN_E of Exp  (* whenExp *)
				* EquationItem list (* whenEquations *)
				* (Exp * EquationItem list) list (* elseWhenEquations *)
		    | EQ_NORETCALL of Ident (* functionName *)
                                    * FunctionArgs (* functionArgs; fcalls without return value *)

  (** The `Algorithm' type describes one algorithm statement in an *)
  (** algorithm section.  It does not describe a whole algorithm.  The *)
  (** reason this type is named like this is that the name of the *)
  (** grammar rule for algorithm statements is `algorithm'. *)
  datatype Algorithm = ALG_ASSIGN of ComponentRef (* assignComponent *)
                                   * Exp (* value *)
		     | ALG_TUPLE_ASSIGN of Exp (* tuple *)  
					* Exp (* value *) 	
		     | ALG_IF of Exp (* ifExp *)
			       * AlgorithmItem list (* trueBranch *)  
			       * (Exp * AlgorithmItem list) list (* elseIfAlgorithmBranch *)
			       * AlgorithmItem list	     (* elseBranch *)
		     | ALG_FOR of Ident (* forVariable *)
                                * Exp (* forStmt *)
                                * AlgorithmItem list (* forBody *)
		     | ALG_WHILE of Exp (* whileStmt *)
                                  * AlgorithmItem list (* whileBody *)
		     | ALG_WHEN_A of Exp (* whenStmt *)
				   * AlgorithmItem list (* whenBody *)
				   * (Exp * AlgorithmItem list) list (* elseWhenAlgorithmBranch *)
		     | ALG_NORETCALL of ComponentRef (* functionCall *) 
                                      * FunctionArgs (* functionArgs; general fcalls without return value *)



  (** Modifications are described by the `Modification' type.  There *)
  (** are two forms of modifications: redeclarations and component *)
  (** modifications. *)
  (** - Modifications *)
  datatype Modification = CLASSMOD of ElementArg list * Exp option

  (* Wrapper for things that modify elements, modifications and redeclarations *)
  datatype ElementArg = MODIFICATION of bool (* finalItem *)
                                      * Each (* each *)
                                      * ComponentRef (* componentReg *)
                                      * Modification option (* modification *)
                                      * string option (* comment *)
		      | REDECLARATION of bool (* finalItem *)
				      * RedeclareKeywords  (* redeclareKeywords ; 'redeclare' 'replaceable' *)
				      * Each (* each *)
				      * ElementSpec (* elementSpec *)
                                      * ConstrainClass option (* constrainClass ; class definition or declaration *)

  (* The keywords 'redeclare' and 'replacable' can be given in three different kombinations, each one by themself or the both combined. *)
  datatype RedeclareKeywords = REDECLARE | REPLACEABLE | REDECLARE_REPLACEABLE 

  (** The each keyword can be present in both MODIFICATION's and REDECLARATION's. *)
  (** - Each attribute *)
  datatype Each = EACH | NON_EACH

  (** - Component attributes *)
  datatype ElementAttributes = ATTR of bool	(* flow *)
			     	     * Variability (* variability ; parameter, constant etc. *)
			     	     * Direction (* direction *)
				     * ArrayDim  (* arrayDim *)
     
  (* Variability *) 
  datatype Variability = VAR | DISCRETE | PARAM | CONST


  (* Direction *)
  datatype Direction = INPUT | OUTPUT | BIDIR

  (** Component attributes are *)
  (** properties of components which are applied by type prefixes. *)
  (** As an example, declaring a component as `input Real x;' will *)
  (** give the attributes `ATTR([],false,VAR,INPUT)'. *)
  (** Components in Modelica can be scalar or arrays with one or more *)
  (** dimensions. This datatype is used to indicate the dimensionality *)
  (** of a component or a type definition. *)
  (** - Array dimensions *)
  type ArrayDim = Subscript list


  (** The `Exp' datatype is the container of a Modelica expression. *)
  (** - Expressions *)
  datatype Exp = INTEGER of int (* value *)
	       | REAL of real (* value *)
	       | CREF of ComponentRef (* componentReg *)
	       | STRING of string (* value *)
	       | BOOL of bool (* value *)
               (* Binary operations, e.g. a*b *)
	       | BINARY of Exp (* exp1 *)
                         * Operator (* op *)
                         * Exp (* exp2 *)
               (* Unary operations, e.g. -(x) *)
	       | UNARY of Operator (* op *)
                        * Exp (* exp *)
               (* Logical binary operations: and, or *)
	       | LBINARY of Exp (* exp1 *)
                          * Operator (* op *)
                          * Exp (* exp2 *)
               (* Logical unary operations: not *)
	       | LUNARY of Operator (* op *)
                         * Exp (* exp *)
               (* Relations, e.g. a >= 0 *)	       
               | RELATION of Exp (* exp1 *)
                           * Operator (* op *)
                           * Exp (* exp2 *)
               (* If expressions *)
	       | IFEXP of Exp (* ifExp *)
                        * Exp (* trueBranch *)
                        * Exp (* elseBranch *) 
                        * (Exp * Exp) list (* elseIfBranch *)
               (* Function calls *)
	       | CALL of ComponentRef (* function *)
                       * FunctionArgs (* functionArgs *)
               (* Array construction using '{','}' or 'array' *)
	       | ARRAY of Exp list (* arrayExp *)
               (* Matrix construction using '[', ']' *)
	       | MATRIX of Exp list list (* matrix *)
               (* Range expressions, e.g. 1:10 or 1:0.5:10 *)
	       | RANGE of Exp (* start *)
                        * Exp option (* step *) 
                        * Exp (* stop *)
               (* Tuples used in function calls returning several values *)
	       | TUPLE of Exp list (* expressions *)
               (* array access operator for last element, e.g. a[end]:=1; *)
	       | END
	       | CODE of Code (* code ;  Modelica AST Code constructors  *)

  (** The 'Code' datatype is used for Meta-programming. It orgiginates from the Code quotation. *)
  datatype Code = C_TYPENAME of Path 
		| C_VARIABLENAME of ComponentRef 
		| C_EQUATIONSECTION of bool * EquationItem list 
		| C_ALGORITHMSECTION of bool * AlgorithmItem list 
		| C_ELEMENT of Element 
		| C_EXPRESSION of Exp 
		| C_MODIFICATION of Modification


  (** The `FunctionArgs' datatype consists of a list of positional arguments *)
  (** followed by a list of named arguments (Modelica v2.0) *)
  datatype FunctionArgs =  FUNCTIONARGS of Exp list (* args *)
                                         * NamedArg list (* argNames *)
			| FOR_ITER_FARG of Exp (* from *)
                                         * Ident (* var *)
                                         * Exp (* to *)

  (** The `NamedArg' datatype consist of an Identifier for the argument and an expression *)
  (** giving the value of the argument *)
  datatype NamedArg = NAMEDARG of Ident (* argName *)
                                * Exp (* argValue *)

  (* Expression operators *)
  datatype Operator = ADD   | SUB    | MUL     | DIV       | POW
		    | UPLUS | UMINUS
		    | AND   | OR
		    | NOT
		    | LESS  | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL


  (** The `Subscript' datatype is used both in array declarations and *)
  (** component references.  This might seem strange, but it is *)
  (** inherited from the grammar.  The `NOSUB' constructor means that *)
  (** the dimension size is undefined when used in a declaration, and *)
  (** when it is used in a component reference it means a slice of the *)
  (** whole dimension. *)  
  (** - Subscripts *)
  datatype Subscript = NOSUB
		     | SUBSCRIPT of Exp (* subScript *)


  (** A component reference is the fully or partially qualified name of *)
  (** a component.  It is represented as a list of *)
  (** identifier--subscript pairs.  *)
  (** - Component references and paths *)
  datatype ComponentRef = CREF_QUAL of Ident (* name *)
                                     * (Subscript list) (* subScripts *)
                                     * ComponentRef (* componentRef *)
		    	| CREF_IDENT of Ident (* name *)
                                      * (Subscript list) (* subscripts *)

  (** The type `Path', on the other hand, *)
  (** is used to store references to class names, or names inside *)
  (** class definitions. *)	      	
  datatype Path = QUALIFIED of Ident (* name *)
                             * Path (* path *)
	      	| IDENT of Ident (* name *)


  (** These constructors each correspond to a different kind of class *)
  (** declaration in Modelica, except the last four, which are used *)
  (** for the predefined types.  The parser assigns each class *)
  (** declaration one of the restrictions, and the actual class *)
  (** definition is checked for conformance during translation.  The *)
  (** predefined types are created in the `Builtin' module and are *)
  (** assigned special restrictions. *)
  (** - Restrictions *)
  datatype Restriction = R_CLASS
		       | R_MODEL
		       | R_RECORD
		       | R_BLOCK
		       | R_CONNECTOR
		       | R_EXP_CONNECTOR
		       | R_TYPE
		       | R_PACKAGE
		       | R_FUNCTION
		       | R_ENUMERATION	
		       | R_PREDEFINED_INT
		       | R_PREDEFINED_REAL
		       | R_PREDEFINED_STRING
		       | R_PREDEFINED_BOOL
		       | R_PREDEFINED_ENUM

  (** An Annotation is a class_modification. *)
  (** - Annotation *)
  datatype Annotation = ANNOTATION of ElementArg list (* elementArgs *)


  (** Comment *)	
  datatype Comment = COMMENT of Annotation option (* annotation *)	
				* string option (* comment *)

  (* Declaration of an external function call *)
  (* - ExternalDecl *)
  datatype ExternalDecl = EXTERNALDECL of    Ident option (* funcName ; The name of the external function *)
				* string option (* lang ; Lanugage of the external function *)
				* ComponentRef option (* output ; ouput parameter as return value*)
				* Exp list (* args ; only positional arguments, i.e. expression list*)
				* Annotation option (* annotation *)
				   		       


  relation element_spec_name : ElementSpec => Ident
  relation cref_to_path : ComponentRef => Path
  relation path_to_cref : Path => ComponentRef
  relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef
  relation path_string : Path => string
  relation opt_path_string: Path option => string
  relation path_string2 : (Path, string) => string
  relation path_last_ident : Path => Ident
  relation path_first_ident : Path => Ident
  relation get_cref_from_exp : ( Exp ) => ComponentRef list 
  relation cref_get_first : ComponentRef => ComponentRef 
  relation join_paths: (Path, Path) => Path
  relation path_append_list: (Path list) => (Path) 
  relation strip_last: (Path) => Path 
  relation print_restr : Restriction => ()
  relation restr_string : Restriction => string
  relation cref_equal: (ComponentRef, ComponentRef) =>  bool
  relation print_absyn_exp : Exp => ()  
  relation last_classname: Program => Path
  relation class_filename: Class => string
  relation set_class_filename: (Class,string) => Class
  relation is_package_restriction: Restriction => bool
end


(** From here down, only absyn helper functions should be present. 
 Thus,no actual absyn datatype definitions. *)
with "Debug.rml"
with "Dump.rml"
with "Util.rml"
with "Print.rml"


(** relation: element_spec_name
 **
 ** The `ElementSpec' type contans the name of the element, and this
 ** relation extracts this name.
 **)
relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,[COMPONENTITEM(COMPONENT(n,_,_),_,_)]) => n

  rule  Print.print_buf "# element_spec_name EXTENDS\n"
	-------------------------------------
	element_spec_name EXTENDS(_,_) => fail

end


(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)
relation path_string: Path => string =

  rule	path_string2 (path, ".") => s
	-----------------------------
	path_string path => s
end


(** relation: opt_path_string
 **
 ** Returns a path converted to string or an empty string if nothing exist
 **)
relation opt_path_string: Path option => string =

  axiom	opt_path_string(NONE) => ""

  rule	path_string(p) => str 
	-----------------
	opt_path_string(SOME(p)) => str
end


(** relation: 
 **
 ** Helper relation to path_string
 **)
relation path_string2: (Path, string) => string =

  axiom	path_string2(IDENT(s),_) => s
  
  rule	path_string2(n,str) => ns &
	string_append(s,str) => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string2(QUALIFIED(s,n), str) => ss
	
end


(** relation: path_last_ident
 **
 ** Returns the last ident (After last dot) in a paht
 **)
relation path_last_ident : Path => Ident =
	
  rule	path_last_ident(p) => res
	-------------------------
	path_last_ident(QUALIFIED(_,p)) => res
	
  axiom	path_last_ident(IDENT(n)) => n

end


(** relation: path_first_ident
 **
 ** Returns the last ident (After last dot) in a paht
 **)
relation path_first_ident : Path => Ident =

  axiom	path_first_ident(QUALIFIED(n,p)) => n
	
  axiom	path_first_ident(IDENT(n)) => n
end


(** relation: get_cref_from_exp
 **
 ** Returns a flattened list of the component references 
 ** in an expression
 **)
relation get_cref_from_exp: ( Exp ) => ComponentRef list =

  axiom	get_cref_from_exp(INTEGER(_)) => []
  axiom	get_cref_from_exp(REAL(_)) => []
  axiom	get_cref_from_exp(STRING(_)) => []
  axiom	get_cref_from_exp(BOOL(_)) => []
  axiom	get_cref_from_exp(CREF(cr)) => [cr]

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(BINARY(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => res
	----------------------------
	get_cref_from_exp(UNARY(op,e1)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(LBINARY(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => res
	----------------------------
	get_cref_from_exp(LUNARY(op,e1)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(RELATION(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res1 &
	get_cref_from_exp(e3) => l3 &
	list_append(res1,l3) => res
	(* TODO elseif's e4 *)
	---------------------------
	get_cref_from_exp(IFEXP(e1,e2,e3,e4)) => res
	
  rule	(*Util.list_map(expl,get_cref_from_exp) => res*)
	get_cref_from_farg(farg) => res
	--------------------------------------------
	get_cref_from_exp(CALL(_,farg)) => res


  rule	Util.list_map(expl,get_cref_from_exp) => res1 &
	Util.list_flatten(res1) => res
	--------------------------------------------
	get_cref_from_exp(ARRAY(expl)) => res

  rule	Util.list_list_map(expll,get_cref_from_exp) => res1 & 
	Util.list_flatten(res1) => res2 &
	Util.list_flatten(res2) => res
	----------------
	get_cref_from_exp(MATRIX(expll)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res1 &
	get_cref_from_exp(e3) => l3 &
	list_append(res1,l3) => res
	---------------------------
	get_cref_from_exp(RANGE(e1,SOME(e3),e2)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res 
	---------------------------
	get_cref_from_exp(RANGE(e1,NONE,e2)) => res
	    
  rule	(*Util.list_map(expl,get_cref_from_exp) => res*)
	Print.print_buf "Not implemented yet\n" 
	------------------
	get_cref_from_exp(TUPLE(expl)) => []

end


(** relation: get_cref_from_farg
 ** 
 ** Returns the flattened list of all component references 
 ** present in a list of function arguments.
 **)
relation get_cref_from_farg: (FunctionArgs) => ComponentRef list =
	
  rule	Util.list_map(expl, get_cref_from_exp) => l1 &
	Util.list_flatten(l1) => fl1 &
	Util.list_map(nargl,get_cref_from_narg) => l2 &
	Util.list_flatten(l2) => fl2 &
	list_append(fl1,fl2) => res
	--------------------------------------------
	get_cref_from_farg (FUNCTIONARGS(expl,nargl)) => res

end


(** relation: get_cref_from_narg
 ** 
 ** Returns the flattened list of all component references 
 ** present in a list of named function arguments.
 **)
relation get_cref_from_narg: (NamedArg) => ComponentRef list =
	
  rule	get_cref_from_exp(exp) => res
	-----------------------------
	get_cref_from_narg(NAMEDARG(_,exp)) => res
end


(** relation: join_paths
 **
 ** This relation joins two paths
 **)
relation join_paths: (Path, Path) => (Path) =

  axiom	join_paths(IDENT(str),p2) => QUALIFIED(str,p2) 
	
  rule	join_paths(p,p2) => p'
	-----------------------
	join_paths(QUALIFIED(str,p),p2) => QUALIFIED(str,p')
end


(** relation: path_append_list
 ** author Lucian
 ** This relation joins a path list
 **)
relation path_append_list: (Path list) => (Path) =

  axiom path_append_list([]) =>  IDENT("")

  axiom path_append_list(path::[]) => path
        
  rule  path_append_list(rest) => path &
        join_paths(first,path) => res_path 
        ---------------------------
        path_append_list(first::rest) => res_path

end
        

(** relation: strip_last
 **
 ** Returns the path given as argument to the relation
 ** minus the last ident.
 **)
relation strip_last: (Path) => Path =

  axiom	strip_last(IDENT(_)) => fail
	
  axiom	strip_last(QUALIFIED(str,IDENT(_))) => IDENT(str)

  rule	strip_last(p) => p'
	-------------------
	strip_last(QUALIFIED(str,p)) => QUALIFIED(str,p')	
end


(** relation: cref_to_path
 **
 ** This relation converts a `ComponentRef' to a `Path', if possible.
 ** If the component reference contains subscripts, it will silently
 ** fail.
 **)
relation cref_to_path : ComponentRef => Path =

  axiom	cref_to_path CREF_IDENT(i,[]) => IDENT(i)

  rule	cref_to_path c => p
	-------------------
	cref_to_path CREF_QUAL(i,[],c) => QUALIFIED(i,p)

end


(** relation: path_to_cref
 **
 ** This relation converts a Path to a ComponentRef.
 ** 
 **)
relation path_to_cref : Path => ComponentRef =

  axiom	path_to_cref IDENT(i) => CREF_IDENT(i,[])
  rule	path_to_cref p => c
	-------------------
	path_to_cref QUALIFIED(i,p) => CREF_QUAL(i,[],c)
end

(** relation: join_crefs
 **
 ** This relation joins two ComponentRefs.
 ** 
 **)
relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef =

  axiom	join_crefs ( CREF_IDENT(id,sub),cr2) => CREF_QUAL(id,sub,cr2)
	
  rule	join_crefs(cr,cr2) => cr'
	------------------------
	join_crefs (CREF_QUAL(id,sub,cr),cr2) => CREF_QUAL(id,sub,cr')
end 


(** relation: cref_get_first
 **
 ** Returns first ident from a ComponentRef
 **)
relation cref_get_first : ComponentRef => ComponentRef =

  axiom	cref_get_first(CREF_IDENT(i,_)) => CREF_IDENT(i,[])

  axiom	cref_get_first(CREF_QUAL(i,_,_)) => CREF_IDENT(i,[])

end


(** relation: restr_string
 ** 
 ** Maps a class restriction to the corresponding string for printing
 **)
relation restr_string : Restriction => string =

  axiom restr_string R_CLASS			=> "CLASS"
  axiom	restr_string R_MODEL			=> "MODEL"
  axiom	restr_string R_RECORD			=> "RECORD"
  axiom restr_string R_BLOCK			=> "BLOCK"
  axiom restr_string R_CONNECTOR		=> "CONNECTOR"
  axiom restr_string R_TYPE			=> "TYPE"
  axiom restr_string R_PACKAGE			=> "PACKAGE"
  axiom restr_string R_FUNCTION			=> "FUNCTION"
  axiom restr_string R_PREDEFINED_INT		=> "PREDEFINED_INT"
  axiom restr_string R_PREDEFINED_REAL		=> "PREDEFINED_REAL"
  axiom restr_string R_PREDEFINED_STRING	=> "PREDEFINED_STRING"
  axiom restr_string R_PREDEFINED_BOOL		=> "PREDEFINED_BOOL"

end


(** relation: print_restr
 **
 ** This is a utility relation for printing a `Restriction'.  The code
 ** is excluded for brevity.
 **)
relation print_restr : Restriction => () =

  rule	restr_string restr => str &
	Print.print_buf str
	----------------
	print_restr restr
end


(** relation: last_classname
 **
 ** Returns the path (=namse) of the last class in a program
 **)
relation last_classname: Program => Path =

  rule	Util.list_last(lst) => CLASS(id,_,_,_,_,_,_) 
	-------------------------
	last_classname(PROGRAM(lst,_)) => IDENT(id)
end


(** relation class_filename
 ** author: PA
 **
 ** Retrieves the filename where the class is stored.
 **)
relation class_filename: Class => string =

  axiom	class_filename (CLASS(_,_,_,_,_,_,INFO(filename,_,_,_,_,_))) => filename
end


(** relation set_class_filename
 ** author: PA
 **
 ** Sets the filename where the class is stored.
 **)
relation set_class_filename: (Class,string) => Class =


  axiom	set_class_filename(CLASS(n,p,f,e,r,body,_),filename)
	=> CLASS(n,p,f,e,r,body,INFO(filename,false,0,0,0,0))
end


(** relation: print_absyn_exp 
 **
 ** Prints an Exp
 **)
relation print_absyn_exp : Exp => () =
  rule	Debug.print "This is an array: " &
	Debug.print "[" &

	Debug.print "]"
	---------
	print_absyn_exp (ARRAY(es))

  rule	Debug.print "(" &
	Debug.print ")"
	---------
	print_absyn_exp (TUPLE(es))


  rule	Debug.print "\nNo tuple." 
	---------
	print_absyn_exp (_)
end


(** relation: cref_equal
 **
 ** Checks if the name of a ComponentRef is equal to the name of 
 ** another ComponentRef
 ** 
 **)
relation cref_equal: (ComponentRef, ComponentRef) =>  bool =

  rule	id = id2
	-----------------------
	cref_equal(CREF_IDENT(id,_),CREF_IDENT(id2,_)) => true

  rule	id = id2 &
	cref_equal(cr1,cr2) => true
	---------------------------
	cref_equal(CREF_QUAL(id,_,cr1),CREF_QUAL(id2,_,cr2)) => true

  axiom	cref_equal(_,_) => false
end


(** relation is_package_restriction
 ** checks if the provided parameter is a package or not
 **) 
relation is_package_restriction: Restriction => bool =
        
  axiom is_package_restriction(R_PACKAGE) => true
  axiom is_package_restriction(_) => false
        
end
