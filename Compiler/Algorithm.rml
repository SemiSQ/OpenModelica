(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Algorithm.rml
 ** module:      Algorithm
 ** description: Algorithm datatypes
 **
 ** RCS: $Id$
 **
 ** This file contains data types and relations for managing
 ** algorithm sections. The algorithms in the AST are analyzed by the `Inst'
 ** module (Inst.rml) which uses this module to represent the algorithms. No
 ** processing of any kind, except for building the datastructure is 
 ** done in this module.
 ** 
 ** It is used primarily by Inst.rml which both provides its input data
 ** and uses its "output" data.
 ** 
 **)

module Algorithm:

  with "Exp.rml"
  with "Types.rml"
  with "SCode.rml"

  type Ident = string

  (** The `Algorithm' type corresponds to a whole algorithm secion. *)
  (** It is simple a list of algorithm statements. *)
  datatype Algorithm = ALGORITHM of Statement list


  (** There are four kinds of statements.  Assignments (`a := b;'),
   ** if statements (`if A then B; elseif C; else D;'), for loops
   ** (`for i in 1:10 loop ...; end for;') and when statements
   ** (`when E do S; end when;'). *)
  datatype Statement = ASSIGN of Exp.Type * Exp.ComponentRef * Exp.Exp
		     | TUPLE_ASSIGN of Exp.Type * Exp.Exp list * Exp.Exp
		     | ASSIGN_ARR of Exp.Type * Exp.ComponentRef * Exp.Exp
		     | IF of Exp.Exp * Statement list * Else
		     | FOR of Exp.Type * bool * Ident * Exp.Exp * Statement list
		     | WHILE of Exp.Exp * Statement list
		     | WHEN of Exp.Exp * Statement list
		     | ASSERT of Exp.Exp * Exp.Exp

  (** An if statements can one or more `elseif' branches and an
   ** optional `else' branch. *)
  datatype Else = NOELSE
		| ELSEIF of Exp.Exp * Statement list * Else
		| ELSE of Statement list

  relation make_assignment : (Exp.Exp, Types.Properties,
			      Exp.Exp, Types.Properties,
			      SCode.Accessibility) => Statement

  relation make_tuple_assignment : (Exp.Exp list, Types.Properties list,
			    Exp.Exp, Types.Properties) => Statement 

  relation make_if : (Exp.Exp,
		      Types.Properties,
		      Statement list,
		      (Exp.Exp * Types.Properties * Statement list) list,
		      Statement list) => Statement

  relation make_for : (Ident, Exp.Exp, Types.Properties,
		       Statement list) => Statement

  relation make_while : (Exp.Exp, Types.Properties,
			 Statement list) => Statement
	
  relation make_when_a : (Exp.Exp, Types.Properties,
			Statement list) => Statement

  relation make_assert: (Exp.Exp, Exp.Exp, Types.Properties, Types.Properties) 
	  => Statement

  relation get_all_exps : Algorithm => Exp.Exp list

end

with "Util.rml"
with "Print.rml"
with "Dump.rml"
with "Debug.rml"
with "Error.rml"

(** relation: make_assignment
 **
 ** This relation creates an `ASSIGN' construct, and checks that the
 ** assignment is semantically valid, which means that the component
 ** being assigned is not constant, and that the types match.
 **
 ** LS: Added call to get_prop_type and is_prop_any_const instead of
 ** having PROP in the rules. Otherwise rules must be repeated because of
 ** combinations with PROP_TUPLE
 **)
relation make_assignment : (Exp.Exp, Types.Properties,
			    Exp.Exp, Types.Properties,
			    SCode.Accessibility) => Statement =

  rule	Types.prop_any_const (lprop) => Types.C_CONST &
	Exp.print_exp_str lhs => lhs_str &
 	Exp.print_exp_str rhs => rhs_str &
	Error.add_message(Error.ASSIGN_CONSTANT_ERROR,[lhs_str,rhs_str])
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Types.prop_any_const (lprop) => Types.C_PARAM &
	Exp.print_exp_str lhs => lhs_str &
 	Exp.print_exp_str rhs => rhs_str &
	Error.add_message(Error.ASSIGN_PARAM_ERROR,[lhs_str,rhs_str])
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Exp.print_exp_str lhs => lhs_str &
 	Exp.print_exp_str rhs => rhs_str &
	Error.add_message(Error.ASSIGN_READONLY_ERROR,[lhs_str,rhs_str])
	---------------------------------------------------------
	make_assignment(lhs,_,rhs,_, SCode.RO) => fail

  rule	Types.prop_any_const (lhprop) => Types.C_VAR &
	Types.match_prop(rhs, rhprop, lhprop) => rhs' &
	Types.is_prop_array lhprop => false &
	get_prop_exp_type lhprop => t
	----------------------------------------------
	make_assignment(Exp.CREF(c,crt), lhprop,
			rhs, rhprop, _) => ASSIGN(t,c,rhs')

  rule	Types.prop_any_const (lhprop) => Types.C_VAR &
	Types.match_prop(rhs, rhprop, lhprop) => rhs' &
	Types.is_prop_array lhprop => true &
	get_prop_exp_type lhprop => t
	----------------------------------------------
	make_assignment(Exp.CREF(c,crt), lhprop,
			rhs, rhprop, _) => ASSIGN_ARR(t,c,rhs')

  rule	Types.get_prop_type lprop => lt &
	Types.get_prop_type rprop => rt &
	Types.equivtypes (lt,rt) => false &
	Exp.print_exp_str lhs => lhs_str &
	Exp.print_exp_str rhs => rhs_str &
	Types.unparse_type lt => lt_str &
	Types.unparse_type rt => rt_str &
	Error.add_message(Error.ASSIGN_TYPE_MISMATCH_ERROR,
			  [lhs_str,rhs_str,lt_str,rt_str]) 
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Print.print_error_buf "- Algorithm.make_assignment failed\n" &
	Print.print_error_buf "    " & Exp.print_exp lhs &
 	Print.print_error_buf " := " & Exp.print_exp rhs & 
	Print.print_error_buf "\n" 
	---------------------------------------------
	make_assignment (lhs, lprop, rhs, rprop, _) => fail

end

(** relation: make_tuple_assignment
 **
 ** This relation creates an `TUPLE_ASSIGN' construct, and checks that the
 ** assignment is semantically valid, which means that the component
 ** being assigned is not constant, and that the types match.
 **)
relation make_tuple_assignment : (Exp.Exp list, Types.Properties list,
			    Exp.Exp, Types.Properties) => Statement =

  rule	Util.list_map(lprop, Types.prop_any_const) => bvals &
	Util.list_reduce(bvals,Types.const_or) => Types.C_CONST &
	Util.list_map(lhs,Exp.print_exp_str) => sl &
	Util.string_delimit_list(sl,", ") => s &
	Util.string_append_list(["(",s,")"]) => lhs_str &
	Exp.print_exp_str(rhs) => rhs_str &
	Error.add_message(Error.ASSIGN_CONSTANT_ERROR,[lhs_str,rhs_str])
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail

  rule	Util.list_map(lprop, Types.prop_any_const) => bvals &
	Util.list_reduce(bvals,Types.const_or) => Types.C_PARAM &
	Util.list_map(lhs,Exp.print_exp_str) => sl &
	Util.string_delimit_list(sl,", ") => s &
	Util.string_append_list(["(",s,")"]) => lhs_str &
	Exp.print_exp_str(rhs) => rhs_str &
	Error.add_message(Error.ASSIGN_PARAM_ERROR,[lhs_str,rhs_str])
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail


  rule	Util.list_map(lhprops, Types.prop_any_const) => bvals &
	Util.list_reduce(bvals,Types.const_or) => Types.C_VAR &
	Util.list_map(lhprops,Types.get_prop_type) => lhrtypes &
	Types.match_type_list(rhs,tpl,lhrtypes) => (rhs',_)
	(* Don't use the new rhs', since type conversions of several output args
	 are not clearly defined. *)
	----------------------------------------------
	make_tuple_assignment(expl, lhprops,
			rhs, Types.PROP_TUPLE((Types.T_TUPLE(tpl),_),Types.TUPLE_CONST(clist))) 
	  => TUPLE_ASSIGN(Exp.OTHER,expl,rhs)

  rule	Debug.fprint("failtrace", "- make_tuple_assignment failed\n")
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail

end


(** relation: get_prop_exp_type
 **
 ** Returns the expression type for a given Properties by calling
 ** get_type_exp_type. Used by make_assignment.
 **)
relation get_prop_exp_type : Types.Properties => Exp.Type =
	
  rule	Types.get_prop_type p => ty &
	get_type_exp_type ty => t
	--------------------------
	get_prop_exp_type p => t

end

(** relation: get_type_exp_type
 **
 ** Returns the expression type for a given Type module type. Used only by
 ** get_prop_exp_type. 
 **)
relation get_type_exp_type : Types.Type => Exp.Type =

  axiom	get_type_exp_type((Types.T_INTEGER(_),_)) => Exp.INT
  axiom	get_type_exp_type((Types.T_REAL(_),_)) => Exp.REAL
  axiom	get_type_exp_type((Types.T_STRING(_),_)) => Exp.STRING
  axiom	get_type_exp_type((Types.T_BOOL(_),_)) => Exp.BOOL

  rule	get_type_exp_type t => t'
	------------------------
	get_type_exp_type((Types.T_ARRAY(_,t),_)) => t'

  axiom	get_type_exp_type( (_,_) ) => Exp.OTHER (*was fail but records must be handled somehow *)

end

(** relation: make_if
 **
 ** This relation creates an `IF' construct, checking that the types
 ** of the parts are correct. Else part is generated using the make_else
 ** relation.
 **)
relation make_if : (Exp.Exp,
		    Types.Properties,
		    Statement list,
		    (Exp.Exp * Types.Properties * Statement list) list,
		    Statement list) => Statement =

  rule	make_else(eib,fb) => else
	-------------------------
	make_if(e,Types.PROP((Types.T_BOOL(_),_),_),tb,eib,fb) => IF(e,tb,else)

  rule	Exp.print_exp_str e => e_str & 
	Types.unparse_type t => t_str & 
	Error.add_message(Error.IF_CONDITION_TYPE_ERROR,[e_str,t_str])
	-------------------------------
	make_if(e,Types.PROP(t,_),_,_,_) => fail

end

(** relation: make_else
 **
 ** 
 **)
relation make_else : ((Exp.Exp * Types.Properties * Statement list) list,
		      Statement list) => Else =

	(** This removes empty else branches *)
  axiom	make_else ([],[]) => NOELSE

  axiom	make_else ([],fb) => ELSE(fb)

  rule	make_else (xs,fb) => else
	-------------------------
	make_else ((e,Types.PROP((Types.T_BOOL(_),_),_),b)::xs,fb)
	  => ELSEIF(e,b,else)
	
  rule	Exp.print_exp_str e => e_str & 
	Types.unparse_type t => t_str & 
	Error.add_message(Error.IF_CONDITION_TYPE_ERROR,[e_str,t_str])
	-------------------------------
	make_else((e,Types.PROP(t,_),_)::_,_) => fail

end

(** relation: make_for 
 **)
relation make_for : (Ident, Exp.Exp, Types.Properties,
		     Statement list) => Statement =

  rule	Types.is_array t => array &
	Types.elab_type t => et
	-----------------------
	make_for(i,e,Types.PROP((Types.T_ARRAY(_,t),_),_),stmts) => FOR(et,array,i,e,stmts)

  rule	Exp.print_exp_str(e) => e_str &
	Types.unparse_type t => t_str &
	Error.add_message(Error.FOR_EXPRESSION_TYPE_ERROR,[e_str,t_str])
	-------------------------------
	make_for(_,e,Types.PROP(t,_),_) => fail
end

(** relation: make_while 
 **)
relation make_while : (Exp.Exp, Types.Properties,
		       Statement list) => Statement =

  axiom	make_while(e,Types.PROP((Types.T_BOOL(_),_),_),stmts) => WHILE(e,stmts)

  rule	Exp.print_exp_str(e) => e_str &
	Types.unparse_type t => t_str &
	Error.add_message(Error.WHILE_CONDITION_TYPE_ERROR,[e_str,t_str])
	-------------------------------
	make_while(e,Types.PROP(t,_),_) => fail

end

(** relation: make_when_a
 **)
relation make_when_a : (Exp.Exp, Types.Properties,
		      Statement list) => Statement =

  axiom	make_when_a(e,Types.PROP((Types.T_BOOL(_),_),_),stmts) => WHEN(e,stmts)

  axiom	make_when_a(e,Types.PROP((Types.T_ARRAY(_,(Types.T_BOOL(_),_)),_),_),stmts) => WHEN(e,stmts)


  rule	Exp.print_exp_str e => e_str &
	Types.unparse_type t => t_str &
	Error.add_message(Error.WHEN_CONDITION_TYPE_ERROR,[e_str,t_str])
	-------------------------------
	make_when_a(e,Types.PROP(t,_),_) => fail
end

(** relation: make_assert
 **
 ** Creates an assert statenebt from two expressions.
 **)
relation make_assert: (Exp.Exp, (* condition *)
		       Exp.Exp, (* message *)
		       Types.Properties, 
		       Types.Properties) 
	  => Statement =

  axiom	make_assert(cond, msg, Types.PROP((Types.T_BOOL(_),_),_),Types.PROP((Types.T_STRING(_),_),_)) 
	  => ASSERT(cond,msg)

	  (* RML does not handle the pattern below T_BOOL(_), hence we need to
	     implement this differently. *) 
	(*  rule	not let T_BOOL(_) = condt &  
	 Print.print_buf "# Type error in assert condition.\n" &
	 Print.print_buf " Expected Boolean, got " &
	 Types.print_type condt & Print.print_buf "\n"
	 --------------------------------------------
	 make_assert(_,_,Types.PROP(condt,_),_) => fail 
	 *)
end 

(** relation: get_all_exps
 ** 
 ** This relation goes through the Algorithm structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps : Algorithm => Exp.Exp list =

  rule	get_all_exps_stmts stmts => exps
	-----------------------------------
	get_all_exps ALGORITHM(stmts) => exps

end

(** relation: get_all_exps_stmts
 ** 
 ** This relation takes a list of statements and returns all expressions
 ** in all statements.
 **)

relation get_all_exps_stmts : Statement list => Exp.Exp list=

  rule	Util.list_map(stmts, get_all_exps_stmt) => expslist &
	Util.list_flatten(expslist) => exps
	-----------------------------------
	get_all_exps_stmts stmts => exps
end


(** relation: get_all_exps_stmt
 **
 ** Returns all expressions in a statement.
 **)

relation get_all_exps_stmt : Statement => Exp.Exp list =

  rule	cref_to_exp cr => crexp
	-----------------------
	get_all_exps_stmt ASSIGN(expty, cr, exp) => [crexp,exp]

  rule	list_append(explist,[exp]) => exps
	---------------------------------
	get_all_exps_stmt TUPLE_ASSIGN(expty, explist, exp) => exps

  rule	cref_to_exp cr => crexp
	-----------------------
	get_all_exps_stmt ASSIGN_ARR(expty, cr, exp) => [crexp,exp]


  rule	get_all_exps_stmts stmts => exps1 &
	get_all_exps_else else => elseexps &
	list_append(exps1, elseexps) => exps
	------------------------------------
	get_all_exps_stmt IF(exp, stmts, else) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt FOR(expty, flag, id, exp, stmts) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt WHILE(exp, stmts) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt WHEN(exp, stmts) => exp::exps

  axiom	get_all_exps_stmt ASSERT(e1, e2) => [e1,e2]

  rule	Debug.fprintln("failtrace", "-- get_all_exps_stmt failed")
	----------------------------------------------------------
	get_all_exps_stmt _ => fail

end

(** relation: get_all_exps_else
 **
 ** Helper relation to get_all_exps_stmt.
 **)

relation get_all_exps_else : Else => Exp.Exp list =

  axiom	get_all_exps_else NOELSE => []

  rule	get_all_exps_stmts stmts => exps1 &
	get_all_exps_else else => elseexps &
	list_append (exps1,elseexps) => exps
	------------------------------------
	get_all_exps_else ELSEIF(exp,stmts,else) => exp::exps

  rule	get_all_exps_stmts stmts => exps	
	----------------------------------------
	get_all_exps_else ELSE(stmts) => exps

end

(** relation: cref_to_exp
 **
 ** Creates an expression from a componentref.
 ** The type of the expression will become Exp.OTHER.
 **)

relation cref_to_exp : Exp.ComponentRef => Exp.Exp =

  axiom	cref_to_exp cref => Exp.CREF(cref, Exp.OTHER)

end

