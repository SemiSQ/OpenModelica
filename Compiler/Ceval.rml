 (*
 Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
 Sweden, in the following denoted PELAB/LIU.
 
 
 This file is part of OpenModelica, in the following denoted OSM.
 
 
 The OSM License, Version 1.1, March 4, 2005.
 

 1 Preface

 The aim of this license is to lay down the conditions enabling you to use, 
 modify and circulate OSM. However, PELAB/LIU remain the authors of 
 OSM and so retain property rights and the use of all ancillary rights.

 2 Definitions

 OSM is defined as all successive versions of the OSM software and their 
 documentation that have been developed by PELAB/LIU and including
 accepted contributions from other contributors according to this license.

 OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
 modified and/or translated and/or adapted.


 3 Dual License

 OSM is made available under the OSM licensing scheme, which is a dual
 licensing scheme with two options, a) and b):

a) OSM OPEN SOURCE LICENSE:

If you wish to write Open Source software you can use the Open Source version 
of OSM, released under the OSM license which include GPL as its open source 
licensing option. If you use the OSM Open Source version you must release your 
Application using OSM including this Application's source code under the GPL as well.

This OSM license text, and Copyright (c) PELAB/Linkoping University, must
be present in your copy of OSM and in OSM DERIVED SOFTWARE.

You should have received a copy of the GPL - GNU General Public License
along with OpenModelica; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


b) OSM COMMERCIAL LICENSE

If you are using OSM commercially - that is, for commercial usage or
for creating proprietary software for sale or use in a commercial setting
- you must purchase a commercial license of OSM from PELAB/LIU, which allows
you to use OSM without releasing your Application under the GPL.

Comment: Payments for OSM are intended for OSM development and
integration of accepted contributions into OSM.


4 Priority

If there is any conflict between this OSM License text and the GNU GPL
license, this text has priority.


5 Contributions 

PELAB/LIU reserves the right to accept or turn down source code contributions
to OSM.


6 Limitation of the warranty

Except when mentioned otherwise in writing, OSM is supplied as is, with 
no explicit or implicit warranty, including warranties of commercialization or 
adaptation. You assume all risks concerning the quality or the effects of
OSM and its use. If OSM is defective, you will bear the costs of 
all required services, corrections or repairs.


7 Consent

When you access and use OSM, you are presumed to be aware of and to 
have accepted all the rights and obligations of the present OSM license.
This includes accepting that your open source code contributions to OSM, 
if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
copyright and ownership by PELAB/IDA.


8 Binding effect

This license has the binding value of a contract.
You are not responsible for respect of the license by a third party.


9 Applicable law

The present license and its effects are subject to Swedish law and  
Swedish courts.


10 Contact information

See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)

(**
 ** file:	 Ceval.rml
 ** module:      Ceval
 ** description: Constant propagation of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module handles constant propagation (or evaluation)
 ** When elaborating expressions, in the Static module, expressions are checked to 
 ** find out its type. It also checks whether the expressions are constant and the relation 
 ** ceval in this module will then evaluate the expression to a constant value, defined
 ** in the Values module.
 **
 ** Input: 
 **	Env: Environment with bindings
 **	Exp: Expression to check for constant evaluation
 **	Bool flag determines whether the current instantiation is implicit
 **	InteractiveSymbolTable is optional, and used in interactive mode,
 **	e.g. from mosh
 **	
 ** Output:
 **	Value: The evaluated value
 **     InteractiveSymbolTable: Modified symbol table
 **     Subscript list : Evaluates subscripts and generates constant expressions. 
 **)
											   
 module Ceval :
  with "Env.rml"
  with "Exp.rml"
  with "Interactive.rml"
  with "Values.rml"
			
  datatype Msg = MSG	(* Give error message *)
	     | NO_MSG   (* Do not give error message *)								   
                                                                                           (** Constant evaluation of expressions *)
  relation ceval : (Env.Env, Exp.Exp, bool (*implicit*) ,
		    Interactive.InteractiveSymbolTable option, 
		    int option, (* dimensions *) 
		    Msg)
	  => (Values.Value, Interactive.InteractiveSymbolTable option)
	    
  relation ceval_list : (Env.Env, Exp.Exp list, bool (*impl*),
			 Interactive.InteractiveSymbolTable option,
			 Msg) 
	  => Values.Value list
	    
  relation ceval_subscripts : (Env.Env, Exp.Subscript list, int list, 
			       bool, (*impl*) 
			       Msg)
	  => Exp.Subscript list
	    
  end

with "DAELow.rml"
with "SimCodegen.rml"
with "Static.rml"
with "Print.rml" 
with "Types.rml"
with "ModUtil.rml"
with "System.rml"
with "Absyn.rml"
with "SCode.rml"
with "Inst.rml"
with "Lookup.rml"
with "Dump.rml"
with "DAE.rml"
with "Debug.rml"
with "Util.rml"
with "ClassInf.rml"
with "RTOpts.rml"
with "Parser.rml"
with "Prefix.rml"
with "Codegen.rml"
with "ClassLoader.rml"
with "Derive.rml"



(** relation: ceval_builtin
 **
 ** Helper for ceval. Parts for builtin calls are moved here, for readability.
 ** See ceval for documentation.
 **
 **)
relation ceval_builtin : (Env.Env, Exp.Exp, bool (*impl*),
			  Interactive.InteractiveSymbolTable option, 
			  int option,
			  Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =

	  (* Handle size separately *)
	
  rule	ceval_builtin_size(env,exp,dim,impl,st,msg) => (v,st)
	-----------------------------------------
	ceval_builtin (env,Exp.SIZE(exp,SOME(dim)),impl,st,_,msg) => (v,st) 	

  rule	ceval_builtin_size_matrix(env,exp,impl,st,msg) => (v,st)
	-----------------------------------------
	ceval_builtin (env,Exp.SIZE(exp,NONE),impl,st,_,msg) => (v,st) 	

  rule	ceval_builtin_handler id => handler &
	handler(env,args,impl,st,msg) => (v,st)
	-----------------------------------------
	ceval_builtin (env,Exp.CALL(Absyn.IDENT(id),args,_,builtin (*as true*)),impl,st,_,msg) => (v,st)

  rule	ceval_list(env,expl,impl,st,msg) => vallst &
	ceval_call_function (env,e,vallst,msg) => newval
	-------------------------------------------------------
	ceval_builtin (env, e as Exp.CALL(funcpath,expl,_,builtin as true),impl,st as NONE,_,msg) => (newval,st)

        (* It's ok if ceval_builtin fails. Just means the call wasn't a builtin function *)
	
end

(** relation: ceval_builtin_handler
 **
 ** This relation dispatches builtin functions and operators to a dedicated
 ** relation that evaluates that particular relation.
 ** It takes an identifier as input and returns a relation that evaluates that
 ** function or operator.
 **)

 relation ceval_builtin_handler : Absyn.Ident  (* operator/function name *)
	  =>  ((Env.Env, 
		Exp.Exp list, 
		bool, 
		Interactive.InteractiveSymbolTable option,
		Msg)
	       
	       => (Values.Value, Interactive.InteractiveSymbolTable option)) =
           (* size handled specially. see ceval_builtin *)
        (* axiom	ceval_builtin_handler "size" => ceval_builtin_size *)

  axiom ceval_builtin_handler "floor" => ceval_builtin_floor
  axiom ceval_builtin_handler "ceil" => ceval_builtin_ceil
  axiom ceval_builtin_handler "abs" => ceval_builtin_abs
  axiom ceval_builtin_handler "sqrt" => ceval_builtin_sqrt
  axiom ceval_builtin_handler "div" => ceval_builtin_div
  axiom ceval_builtin_handler "sin" => ceval_builtin_sin
  axiom ceval_builtin_handler "cos" => ceval_builtin_cos
  axiom ceval_builtin_handler "asin" => ceval_builtin_asin
  axiom ceval_builtin_handler "acos" => ceval_builtin_acos
  axiom ceval_builtin_handler "atan" => ceval_builtin_atan
  axiom ceval_builtin_handler "tan" => ceval_builtin_tan
  axiom ceval_builtin_handler "integer" => ceval_builtin_integer
  axiom ceval_builtin_handler "mod" => ceval_builtin_mod
  axiom	ceval_builtin_handler "max" => ceval_builtin_max
  axiom ceval_builtin_handler "min" => ceval_builtin_min 
  axiom ceval_builtin_handler "rem" => ceval_builtin_rem
  axiom	ceval_builtin_handler "diagonal" => ceval_builtin_diagonal
  axiom	ceval_builtin_handler "differentiate" => ceval_builtin_differentiate
  axiom	ceval_builtin_handler "simplify" => ceval_builtin_simplify
  axiom ceval_builtin_handler "sign" => ceval_builtin_sign
  axiom	ceval_builtin_handler "exp" => ceval_builtin_exp 
  axiom	ceval_builtin_handler "noEvent" => ceval_builtin_noevent

  rule	Debug.fprint("ceval", "No ceval_builtin_handler found for: ") &
	Debug.fprintln("ceval", id)
	--------------------------
	ceval_builtin_handler id => fail

end


(** relation: ceval
 **
 ** This relation is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 **
 ** The third argument indicates whether the evaluation is performed in the
 ** interactive environment (implicit instantiation), in which case function
 ** calls are evaluated.
 **
 ** The last argument is an optional dimension.
 **)
 relation ceval : (Env.Env, Exp.Exp, bool (*impl*),
		   Interactive.InteractiveSymbolTable option, 
		   int option,
		   Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =

  axiom	ceval (_,Exp.ICONST(x),_,st,_,_) => (Values.INTEGER(x),st)
  axiom	ceval (_,Exp.RCONST(x),_,st,_,_) => (Values.REAL(x),st)
  axiom ceval (_,Exp.SCONST(x),_,st,_,_) => (Values.STRING(x),st)
  axiom ceval (_,Exp.BCONST(x),_,st,_,_) => (Values.BOOL(x),st)
  axiom ceval (_,Exp.END,_,st,SOME(dim),_)  => (Values.INTEGER(dim), st)

  rule	Print.print_error_buf "# 'end' cannot be used outside array subscript\n"
	 --------------------------------------
	 ceval (_,Exp.END,_,st,NONE,MSG) => fail

  axiom	ceval (_,Exp.END,_,st,NONE,NO_MSG) => fail
         
  rule	ceval_ast_exp(env,exp,impl,st,msg) => exp'
	 --------------------------------------
	 ceval (env,Exp.CODE(Absyn.C_EXPRESSION(exp),_),impl,st,_,msg) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp')),st)

  rule	ceval_ast_exp(env,exp,impl,st,msg) => exp'
	 --------------------------------------
	 ceval (env,Exp.CODE(Absyn.C_EXPRESSION(exp),_),impl,st,_,msg) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp')),st)

  rule	ceval_ast_elt(env,elt,impl,st,msg) => elt'
	 --------------------------------------
	 ceval (env,Exp.CODE(Absyn.C_ELEMENT(elt),_),impl,st,_,msg) 
	  => (Values.CODE(Absyn.C_ELEMENT(elt')),st)

  axiom	ceval(env, Exp.CODE(c,_),_,st,_,_) => (Values.CODE(c),st)

  rule	ceval_list (env,es,impl,st,msg) => es' &
	 list_length es' => l
	 ------------------------------
	 ceval (env,Exp.ARRAY(_,_,es),impl,st,_,msg) => (Values.ARRAY(es'),st)

  rule	ceval_matrixelt(env,expll,impl,msg) => elts
	 ------------------------------
	 ceval (env, Exp.MATRIX(_,_,expll),impl,st,_,msg) 
	  => (Values.ARRAY(elts),st)

  rule    (* When in interactive mode, always evalutate crefs, i.e non-implicit
	   * mode..*)
	 ceval_cref(env,c,false,msg) => v
	 ---------------------------
	 ceval (env,Exp.CREF(c,_),impl as false,SOME(st),_,msg) 
	  => (v,SOME(st)) 

  rule	ceval_cref (env,c,impl,msg) => v
	 ---------------------------
	 ceval (env,Exp.CREF(c,_),impl,st,_,msg) => (v,st) 


  rule	ceval_builtin (env, exp, impl, st, dim,msg) => (v, st')
	 ---------------------------------------------------
	 ceval (env,exp,impl,st,dim,msg) => (v,st') 	


  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') & 
         int_real(lhv) => lhvr &
         int_real(rhv) => rhvr &
         real_pow(lhvr,rhvr) => resr &
         real_int(resr) => res 
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.INT), rh),impl,st,dim,msg) 
	  => (Values.INTEGER(res),st'')

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') & 
         int_real(rhv) => rhvr &
         real_pow(lhv,rhvr) => resr
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(resr),st'')

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') & 
         int_real(lhv) => lhvr &
         real_pow(lhvr,rhv) => resr 
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(resr),st'')

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') & 
         real_pow(lhv,rhv) => resr 
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(resr),st'')


	   
	   (* FIXME: disabled calling of functions during ceval for now. Some
	    * functions call other functions, which must be generated together in
	    * order that compilation works  *)
	 (*
	  axiom	ceval (env, e as Exp.CALL(funcpath,expl,_,builtin as false),impl as false,st as NONE,_) => fail
	  *)
	 
	 (* Call functions in non-interactive mode. *) 
	 (* FIXME: functions are always generated. Put back the check
	  and write another rule for the false case that generates the function *)
  rule	ceval_list(env,expl,impl,st,msg) => vallst &
	 ceval_call_function (env,e,vallst,msg) => newval
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(funcpath,expl,_,builtin as false),impl as false,st as NONE,_,msg) => (newval,st)
	 
	 (*	ceval (env, e as Exp.CALL(funcpath,expl,_,_),false,st as SOME(Interactive.SYMBOLTABLE(_,_,_,_,cflist)),_) => (newval,st)
	  *)
	 
	 
	 (* FIXME: Fix this in order to allow calling of constant-marked function
	  * calls. One should call the function as if we were in interactive
	  * mode, and put the result instead of the function call *)
	 
	 (*	 

	  rule	Print.print_buf "# Can't call builtin functions at compile time\n" &
	  Print.print_buf "    expression: " & Exp.print_exp e & Print.print_buf "\n"
	  -------------------------------------------------------
	  ceval (env, e as Exp.CALL(_,_,_,builtin as true),impl as false,NONE,_) => fail
	  *)
	 
  rule	Print.print_buf "# Can't call functions at compile time\n" &
	Print.print_buf "    expression: " & Exp.print_exp e & Print.print_buf "\n"
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(_,_,_,_),impl as false,NONE,_,MSG) => fail
	 
  axiom	ceval (env, e as Exp.CALL(_,_,_,_),impl as false,NONE,_,NO_MSG) => fail
	 
  rule	(* Print.print_buf "implicit evaluation of function calls without symbol table, exp: " &
	 Exp.print_exp e & Print.print_buf "\n" *)
	 -------------------------------------------
	 ceval(env, e as Exp.CALL(_,_,_,_),impl as true,NONE,_,_) => fail
	 
  rule	ceval_interactive_functions(env,e,st,msg) => (value,st)
	 -------------------------------------
	 ceval (env, e as Exp.CALL(_,_,_,_),impl as true, SOME(st),_,msg) 
	  => (value,SOME(st))
	 
  rule	(* Call of record constructors, etc., i.e. functions that can be 
	 constant propagated. *)
	 ceval_list(env,expl,impl,st,msg) => vallst &
	 ceval_function(env,func,vallst,impl,msg) => newval
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(func,expl,_,_),impl as true,st as SOME(_),_,msg) 
	  => (newval,st)
	   
  rule	(* Call externally implemented functions. *) 
	 Static.is_function_in_cflist(cflist,func) => true &
	 ceval_list(env,expl,impl,st,msg) => vallst &
	 ModUtil.path_string2(func,"_") => funcstr &
	 string_append(funcstr,"_in.txt") => infilename &
	 string_append(funcstr,"_out.txt") => outfilename &
	 Values.write_to_file_as_args(vallst,infilename)  &
	 System.execute_function(funcstr) &
	 System.read_values_from_file(outfilename) => newval
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(func,expl,_,_),impl as true,st as SOME(Interactive.SYMBOLTABLE(p,_,_,_,cflist)),_,msg) => (newval,st)
	 
	 (** Strings **)
	 
  rule  ceval (env, lh, impl,st, NONE,msg) => (Values.STRING(lhv),_) &
	ceval (env, rh, impl,st,NONE,msg) => (Values.STRING(rhv),_) &
	 string_append(lhv,rhv) => str
	 -----------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.STRING), rh),impl,st,_,msg)
	  => (Values.STRING(str),st)
	   
	   (**  Numerical *)
	 
  rule	ceval (env, lh, impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env, rh, impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_add(lhv, rhv) => sum
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh),impl,st,dim,msg)
	  => (Values.REAL(sum),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.ARRAY(vlst1),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.ARRAY(vlst2),st'') &
	 Values.add_elementwise_arrayelt(vlst1, vlst2) => reslst
	 -------------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD_ARR(_),rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.ARRAY(vlst1),st') &
	ceval (env,rh,impl,st',dim,msg) => (Values.ARRAY(vlst2),st'') &
	 Values.sub_elementwise_arrayelt(vlst1, vlst2) => reslst
	 -------------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.SUB_ARR(_),rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	 
  rule	ceval (env,lh,impl,st,dim,msg) => (sval,st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.ARRAY(aval),st'') &
	 Values.mult_scalar_arrayelt(sval,aval) => reslst
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_ARRAY(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,rh,impl,st,dim,msg) => (sval,st') &
	 ceval (env,lh,impl,st',dim,msg) => (Values.ARRAY(aval),st'') &
	 Values.mult_scalar_arrayelt(sval,aval) => reslst
	 ------------------------------------------------
ceval (env, Exp.BINARY(lh, Exp.MUL_ARRAY_SCALAR(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,rh,impl,st,dim,msg) => (sval,st') &
	 ceval (env,lh,impl,st',dim,msg) => (Values.ARRAY(aval),st'') &
	 Values.div_arrayelt_scalar(sval,aval) => reslst
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.DIV_ARRAY_SCALAR(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,rh,impl,st,dim,msg) => (Values.ARRAY(rhvals),st') &
	 ceval (env,lh,impl,st',dim,msg) => (Values.ARRAY(lhvals),st'') &
	 Values.mult_scalar_product(rhvals,lhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (res,st'')
	 
  rule	(* {{..}..{..}} * {...} *)
	 ceval (env,lh,impl,st,dim,msg) 
	  => (Values.ARRAY(lhvals as (elt1::_)),st') &
	 ceval (env,rh,impl,st',dim,msg) 
	  => (Values.ARRAY(rhvals as (elt2::_)),st'') &
	 Values.is_array(elt1) => true &
	 Values.is_array(elt2) => false &
	 Values.mult_scalar_product(lhvals,rhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (res,st'')
	 
  rule	(* {...} * {{..}..{..}} *)
	 ceval (env,rh,impl,st,dim,msg) 
	  => (Values.ARRAY(rhvals as (elt1::_)),st') &
	 ceval (env,lh,impl,st',dim,msg) 
	  => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	 Values.is_array(elt1) => true &
	 Values.is_array(elt2) => false &
	 Values.mult_scalar_product(lhvals,rhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (res,st'')
	 
  rule	(* {{..}..{..}} * {{..}..{..}} *)
	 ceval (env,rh,impl,st,dim,msg) 
	  => (Values.ARRAY(rhvals as (elt1::_)),st') &
	   ceval (env,lh,impl,st',dim,msg) 
	  => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	 Values.is_array(elt1) => true &
	 Values.is_array(elt2) => true &
	 Values.mult_matrix(lhvals,rhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(res),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') &
	 int_add(lhv, rhv) => sum
	 ------------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh),impl,st,dim,msg) 
	  => (Values.INTEGER(sum),st'')
	   (**)
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_sub(lhv, rhv) => sum
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(sum),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') &
	 ceval (env, rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') &
	 int_sub(lhv, rhv) => sum
	 ------------------------
	 ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh),impl,st,dim,msg)
	  => (Values.INTEGER(sum),st'') 
	   (**)
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_mul(lhv, rhv) => sum
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(sum),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_div(lhv, rhv) => div
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.DIV(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(div),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 not real_div(lhv,rhv) => _ &
	 Print.print_error_buf "#Error, division by zero.\n" 
	 -------------------------
ceval (env, Exp.BINARY(lh, Exp.DIV(Exp.REAL), rh),impl,st,dim,msg) 
	  => fail
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') &
	 int_mul(lhv, rhv) => sum
	 ------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh),impl,st,dim,msg)
	  => (Values.INTEGER(sum),st'')
	  (**)
  rule	ceval (env,exp,impl,st,dim,msg) => (Values.REAL(x),st') &
	 real_neg (x) => x'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp),impl,st,dim,msg)
	  => (Values.REAL(x'),st')

	   (* unary minus of array*)
  rule	ceval (env,exp,impl,st,dim,msg) => (Values.ARRAY(arr),st') &
	Util.list_map(arr,Values.value_neg) => arr'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UMINUS_ARR(_), exp),impl,st,dim,msg)
	  => (Values.ARRAY(arr'),st')

	   
  rule	ceval (env,exp,impl,st,dim,msg) => (Values.INTEGER(x),st') &
	 int_neg (x) => x'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp),impl,st,dim,msg)
	  => (Values.INTEGER(x'),st')
	   (**)
  rule	ceval (env,exp,impl,st,dim,msg) => (Values.REAL(x),st') &
	 real_neg (x) => x'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp),impl,st,dim,msg)
	  => (Values.REAL(x'),st')
	   
  rule	ceval (env,exp,impl,st,dim,msg) => (Values.INTEGER(x),st') &
	 int_neg (x) => x'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp),impl,st,dim,msg)
	  => (Values.INTEGER(x'),st')
	   
	   (**  Logical *)
	 
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.BOOL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.BOOL(rhv),st'') &
	 bool_and(lhv, rhv) => x
	 ------------------------
	 ceval (env, Exp.LBINARY(lh, Exp.AND, rh),impl,st,dim,msg)
	  => (Values.BOOL(x),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.BOOL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.BOOL(rhv),st'') &
	 bool_or(lhv, rhv) => x
	 ------------------------
	 ceval (env, Exp.LBINARY(lh, Exp.OR, rh),impl,st,dim,msg)
	  => (Values.BOOL(x),st'')
	   
  rule	ceval (env,e,impl,st,dim,msg) => (Values.BOOL(b),st') &
	 bool_not(b) => b'
	 -----------------
	 ceval (env, Exp.LUNARY(Exp.NOT, e),impl,st,dim,msg) 
	  => (Values.BOOL(b'),st')
	 
	 (**  Relations *)
	 
  rule	ceval (env,lhs,impl,st,dim,msg) => (lhs',st') &
	 ceval (env,rhs,impl,st',dim,msg) => (rhs',st'') &
	 ceval_relation (lhs',relop,rhs') => v
	 -------------------------------------
	 ceval (env, Exp.RELATION(lhs,relop,rhs),impl,st,dim,msg) 
	  => (v, st'')
	 
	 (**)
	 
  rule	ceval (env,start,impl,st,dim,msg) => (Values.INTEGER(start'),st') &
	 ceval (env,stop,impl,st',dim,msg) => (Values.INTEGER(stop'),st'') &
	 ceval_range(start', 1, stop') => arr
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.INT,start, NONE, stop),impl,st,dim,msg) 
	  => (Values.ARRAY(arr),st')
	   
  rule	ceval (env,start,impl,st,dim,msg) => (Values.INTEGER(start'),st') &
	 ceval (env,step,impl,st',dim,msg) => (Values.INTEGER(step'),st'') &
	 ceval (env,stop,impl,st'',dim,msg) => (Values.INTEGER(stop'),st''') &
	 ceval_range(start', step', stop') => arr 
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.INT,start, SOME(step), stop),impl,st,dim,msg)
	  => (Values.ARRAY(arr),st''')
	   
  rule	ceval (env,start,impl,st,dim,msg) => (Values.REAL(start'),st') &
	 ceval (env,stop,impl,st',dim,msg) => (Values.REAL(stop'),st'') &
	 real_sub(stop',start') => diff &
	 int_real 1 => step & (* bug in rml, 1.0 => 0.0 in cygwin  *)
	 ceval_range_real(start', step, stop') => arr
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.REAL,start, NONE, stop),impl,st,dim,msg) 
	  => (Values.ARRAY(arr),st'')
	   
  rule	ceval (env,start,impl,st,dim,msg) => (Values.REAL(start'),st') &
	 ceval (env,step,impl,st',dim,msg) => (Values.REAL(step'),st'') &
	 ceval (env,stop,impl,st'',dim,msg) => (Values.REAL(stop'),st''') &
	 ceval_range_real(start', step', stop') => arr
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.REAL,start, SOME(step), stop),impl,st,dim,msg) 
	  => (Values.ARRAY(arr),st''')
	   
  rule	ceval (env,e,impl,st,dim,msg) => (Values.INTEGER(i),st') &
	 int_real i => r
	 ---------------
	 ceval (env, Exp.CAST(Exp.REAL,e),impl,st,dim,msg) 
	  => (Values.REAL(r),st')
	 
  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(ivals),st') &
	 Values.type_convert(Exp.INT,Exp.REAL,ivals) => rvals
	 ----------------------------------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e),impl,st,dim,msg) 
	  => (Values.ARRAY(rvals),st')
	 
  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vallst),st') &
	 Values.type_convert(Exp.INT, Exp.REAL, vallst) => vallst'
	 --------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e as Exp.ARRAY(Exp.INT,_,expl)),
		impl,st,dim,msg) 
	  => (Values.ARRAY(vallst'),st')

  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vallst),st') &
	 Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	 ---------------------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e as Exp.RANGE(Exp.INT,_,_,_)),
		impl,st,dim,msg) 
	  => (Values.ARRAY(vallst'),st')
	 
  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vallst),st') &
	 Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	 ---------------------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e as Exp.MATRIX(Exp.INT,_,_)),
		impl,st,dim,msg) 
	  => (Values.ARRAY(vallst'),st')
	 
  rule	(* Ifexp, true branch *)
	 ceval (env,b,impl,st,dim,msg) 
	  => (Values.BOOL(true),st') &
	 ceval (env,e1,impl,st',dim,msg) 
	  => (v,st'')
	 ------------------------------------
	 ceval (env, Exp.IFEXP(b,e1,e2),impl,st,dim,msg) 
	  => (v,st'')
  rule	(* Ifexp, false branch *)
	 ceval (env,b,impl,st,dim,msg) => (Values.BOOL(false),st') &
	 ceval (env,e2,impl,st',dim,msg) => (v,st'')
	 ------------------------------------
	 ceval (env, Exp.IFEXP(b,e1,e2),impl,st,dim,msg) 
	  => (v,st'')
	   
  rule	(* asub *)
	 ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vals),st') &
	 int_sub(indx,1) => indx' &
	 list_nth(vals,indx') => v
	 -----------------------
	 ceval (env, Exp.ASUB(e,indx),impl,st,dim,msg) => (v,st')
	 
  rule	Print.print_buf "#-- ceval reduction\n"
	 ---------------------------------------
	 ceval (env, Exp.REDUCTION(p,exp,iter,iterexp),impl,st,dim,MSG)
	  => fail (* (v,st) *)
	   
  axiom	ceval (env, Exp.REDUCTION(p,exp,iter,iterexp),impl,st,dim,NO_MSG)
	  => fail (* (v,st) *)

           (*   ceval can apparently fa-il and that is ok, catched by other rules...*)
  rule	Debug.fprint("failtrace", "- ceval failed: ")
	 & Exp.print_exp_str e => str 
	 & Debug.fprint("failtrace",str) 
	 & Debug.fprint("failtrace", "\n")
	 (*& Debug.fprint("failtrace", " Env:" )
	  & Debug.fcall("failtrace",Env.print_env, env) *)
	 -----------------------------------------------------
	 ceval (env,e,_,_,_,MSG) => fail
	 
end


(** relation: ceval_call_function
 **
 ** This relation evaluates CALL expressions, i.e. function calls.
 ** They are currently evaluated by generating code for the function and
 ** then write input to file and execute the generated code. Finally, the
 ** result is read back from file and returned.
 **)
 
relation ceval_call_function : (Env.Env, 
				Exp.Exp, (* the call expression*)
				Values.Value list, (* input parameter values*)
				Msg) (* Should error messages be printed. *)
				 => Values.Value (* resulting value *) =
	
        (* Call functions in non-interactive mode. *) 
	(* FIXME: functions are always generated. Put back the check
	 and write another rule for the false case that generates the function *)
  rule	(* Static.is_function_in_cflist(cflist,funcpath) => true & *)
	ceval_generate_function(env, funcpath) &
	ModUtil.path_string2(funcpath,"_") => funcstr &
	string_append(funcstr,"_in.txt") => infilename &
	string_append(funcstr,"_out.txt") => outfilename &
	Values.write_to_file_as_args(vallst,infilename)  &
	System.execute_function(funcstr) &
	System.read_values_from_file(outfilename) => newval
	-------------------------------------------------------
	ceval_call_function (env, e as Exp.CALL(funcpath,expl,_,builtin), 
			     vallst,msg) => newval
	
  rule	Debug.fprint("failtrace", "- ceval_call_function failed: ")
	& Exp.print_exp_str e => str 
	& Debug.fprintln("failtrace",str)
	-----------------------------------------------------
	ceval_call_function (env,e,_,_) => fail
	
end

(** relation: ceval_function 
 ** 
 ** For constant evaluation of functions returning a single value. For now only
 ** record constructors.
 **)
relation ceval_function: (Env.Env, Absyn.Path, Values.Value list, 
			  bool, (*impl*) Msg ) 
	  => Values.Value =

	  (* For record constructors *)
  rule	Lookup.lookup_record_constructor_class(env,funcname) => (_,_) &
	Lookup.lookup_class(env,funcname,false) => (c,env') &
	SCode.component_names(c) => compnames &
	Types.values_to_mods(vallst,compnames) => mod &
	Inst.inst_class(env',mod,Prefix.NOPRE,[],c,[],impl,Inst.TOP_CALL)
	  => (dae,_,_,_,_) &
	DAE.dae_to_record_value(funcname,dae,impl) => value  
	----------------------
	ceval_function(env,funcname,vallst,impl,msg) => value

  rule	Debug.fprint("failtrace", "ceval_function: Don't know what to do. impl was always false before:")
	& Absyn.path_string funcname => s
	& Debug.fprintln("failtrace", s)
	----------------------------------------------------------------------
	ceval_function(env,funcname,vallst,impl as true,msg) => fail
end


(** relaton: ceval_ast_exp
 **
 ** Part of meta-programming using CODE.
 **
 ** This relation evaluates a piece of Expression AST, replacing Eval(variable)
 ** with the value of the variable, given that it is of type "Expression".
 ** 
 ** Example: y = Code(1 + x)
 **          2 + 5 * ( x + Eval(y) )  =>   2 + 5 * ( x + 1 + x )
 **)
 relation ceval_ast_exp: (Env.Env, Absyn.Exp, 
			  bool (*impl*), 
			  Interactive.InteractiveSymbolTable option,
			  Msg)
	  => Absyn.Exp =

  axiom	ceval_ast_exp (_,e as Absyn.INTEGER(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.REAL(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.CREF(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.STRING(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.BOOL(_),_,_,_) => e

  rule	ceval_ast_exp (env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp (env,e2,impl,st,msg) => e2' 
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.BINARY(e1, op, e2),impl,st,msg) 
	  => Absyn.BINARY(e1',op,e2')

  rule	ceval_ast_exp (env,e,impl,st,msg) => e'
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.UNARY(op, e),impl,st,msg) 
	  => Absyn.UNARY(op,e')

  rule	ceval_ast_exp (env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp (env,e2,impl,st,msg) => e2' 
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.LBINARY(e1, op, e2),impl,st,msg) 
	  => Absyn.LBINARY(e1',op,e2')

  rule	ceval_ast_exp (env,e,impl,st,msg) => e'
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.LUNARY(op, e),impl,st,msg) 
	  => Absyn.LUNARY(op,e')

  rule	ceval_ast_exp (env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp (env,e2,impl,st,msg) => e2' 
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.RELATION(e1, op, e2),impl,st,msg) 
	  => Absyn.RELATION(e1',op,e2')

  rule	ceval_ast_exp(env,cond,impl,st,msg)=> cond' &
	 ceval_ast_exp(env,then,impl,st,msg)=> then' &
	 ceval_ast_exp(env,else,impl,st,msg)=> else' &
	 ceval_ast_expexp_list(env,nest,impl,st,msg) =>  nest'
	 -----------------------------------------------
	 ceval_ast_exp (env, Absyn.IFEXP(cond,then,else,nest),impl,st,msg)
	  => Absyn.IFEXP(cond',then',else',nest')

  rule	Static.elab_exp(env,e,impl,st) => (e',_,_) &
	 ceval(env,e',impl,st,NONE,msg) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp)),_) 
	 ----------------------------------
	 ceval_ast_exp (env, 
		        Absyn.CALL(Absyn.CREF_IDENT("Eval",[]),
				   Absyn.FUNCTIONARGS([e],[])),impl,st
			,msg)
	  => exp
  axiom	ceval_ast_exp(env,e as Absyn.CALL(cr,fa),_,_,msg) => e

  rule	ceval_ast_exp_list(env,expl,impl,st,msg) => expl'
	 ---------------------------------------------
	 ceval_ast_exp(env,Absyn.ARRAY(expl),impl,st,msg) 
	  => Absyn.ARRAY(expl')

  rule	ceval_ast_exp_list_list(env,expl,impl,st,msg) => expl'
	 --------------------------------------------------
	 ceval_ast_exp(env,Absyn.MATRIX(expl),impl,st,msg) 
	  => Absyn.MATRIX(expl')
	   
  rule	ceval_ast_exp(env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp(env,e2,impl,st,msg) => e2' &
	 ceval_ast_exp(env,e3,impl,st,msg) => e3' 
	 ------------------------------------
	 ceval_ast_exp(env,Absyn.RANGE(e1,SOME(e2),e3),impl,st,msg) 
	  => Absyn.RANGE(e1',SOME(e2'),e3')

  rule	ceval_ast_exp(env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp(env,e3,impl,st,msg) => e3'
	 ------------------------------------
	 ceval_ast_exp(env,Absyn.RANGE(e1,NONE,e3),impl,st,msg) 
	  => Absyn.RANGE(e1',NONE,e3')
           
  rule	ceval_ast_exp_list(env,expl,impl,st,msg) => expl'
	 ---------------------------------------------
	 ceval_ast_exp(env,Absyn.TUPLE(expl),impl,st,msg) 
	  => Absyn.TUPLE(expl')

  axiom	ceval_ast_exp(env,Absyn.END,_,_,msg) => Absyn.END

  axiom	ceval_ast_exp(env,e as Absyn.CODE(_),_,_,msg) => e
 end

(** relation: ceval_ast_exp_list
 ** 
 ** List version of ceval_ast_exp
 **)
relation ceval_ast_exp_list: (Env.Env, Absyn.Exp list, 
			      bool (*impl*) , Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Absyn.Exp list) =
  axiom	ceval_ast_exp_list (env, [],_,_,msg) => []

  rule	ceval_ast_exp(env,e,impl,st,msg) => e' &
	ceval_ast_exp_list(env,es,impl,st,msg) => res
	-----------------------------------------
	ceval_ast_exp_list(env,e::es,impl,st,msg) 
	  => e::res
end

(** relation: ceval_ast_exp_list_list
 ** 
 **)
relation ceval_ast_exp_list_list: (Env.Env, Absyn.Exp list list, 
			           bool (*impl*), 
				   Interactive.InteractiveSymbolTable option,
				   Msg)
	  => (Absyn.Exp list list) =

  axiom	ceval_ast_exp_list_list(env, [], _,_,msg) => []

  rule	ceval_ast_exp_list(env,e,impl,st,msg) => e' &
	ceval_ast_exp_list_list(env,es,impl,st,msg) => res
	----------------------------------------------
	ceval_ast_exp_list_list(env,e::es,impl,st,msg) 
	  => e::res
end

(** relation: ceval_ast_expexp_list
 **
 ** For IFEXP
 **)
relation ceval_ast_expexp_list: (Env.Env, (Absyn.Exp*Absyn.Exp) list, 
				 bool, 
				 Interactive.InteractiveSymbolTable option,
				 Msg) 
	  => (Absyn.Exp*Absyn.Exp) list =

  axiom	ceval_ast_expexp_list(_,[],_,_,msg) => []

  rule	ceval_ast_exp(env,e1,impl,st,msg)=> e1' &
	ceval_ast_exp(env,e2,impl,st,msg)=> e2' &
	ceval_ast_expexp_list(env,xs,impl,st,msg) => res
	-------------------------------------
	ceval_ast_expexp_list(env,(e1,e2)::xs,impl,st,msg) 
	  => ((e1',e2')::res)
end

(** relation: ceval_ast_elt
 **
 ** Evaluates an ast constructor for Element nodes, e.g. 
 ** Code(parameter Real x=1;)
 **)

relation ceval_ast_elt: (Env.Env, Absyn.Element, 
			 bool (*impl*), 
			 Interactive.InteractiveSymbolTable option,
			 Msg)
	  => (Absyn.Element) =

  rule	ceval_ast_citems(env,citems,impl,st,msg) => citems'
	-----------------------------------------------
	ceval_ast_elt (env, Absyn.ELEMENT(f,r,io,id,Absyn.COMPONENTS(attr,tp,citems),file,line,c),
		       impl,st,msg)
	  => (Absyn.ELEMENT(f,r,io,id,Absyn.COMPONENTS(attr,tp,citems'),file,line,c))
end

(** relation: ceval_ast_citems
 **
 ** Helper relation to ceval_ast_elt.
 **)
relation ceval_ast_citems: (Env.Env, Absyn.ComponentItem list, 
			    bool (*impl*), 
			    Interactive.InteractiveSymbolTable option,
			    Msg)
	  => Absyn.ComponentItem list =
  axiom	ceval_ast_citems(_,[],_,_,msg) => []

  rule	ceval_ast_citems(env,xs,impl,st,msg) => res &
	ceval_ast_modopt(env,modopt,impl,st,msg) => modopt' &
	ceval_ast_arraydim(env,ad,impl,st,msg) => ad' 
	------------------------------------------------
	ceval_ast_citems (env,Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad,modopt),cmt)::xs,
			  impl,st,msg)
	  => (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad',modopt'),cmt)::res)

  	  (* If one component fails, the rest should still succeed *)
  rule	ceval_ast_citems(env,xs,impl,st,msg) => res 
	----------------------------------
	ceval_ast_citems(env,x::xs,impl,st,msg) => x::res
end

(** relation: ceval_ast_modopt
 **
 **)
relation ceval_ast_modopt: (Env.Env, Absyn.Modification option,
			    bool (*impl*), Interactive.InteractiveSymbolTable option,
			    Msg)
	  => Absyn.Modification option	=

  rule	ceval_ast_modification(env,mod,st,impl,msg) => res
	----------------------------------------------
	ceval_ast_modopt(env,SOME(mod),st,impl,msg) => SOME(res)

  axiom	ceval_ast_modopt(env,NONE,_,_,msg) => NONE
	
end

(** relation: ceval_ast_modification
 **
 ** This relation evaluates Eval(variable) inside an AST Modification  and replaces 
 ** the Eval operator with the value of the variable if it has a type "Expression"
 **)
 relation ceval_ast_modification: (Env.Env, Absyn.Modification, 
				   bool (*impl*), 
				   Interactive.InteractiveSymbolTable option,
				   Msg)
	  => (Absyn.Modification) =

  rule	ceval_ast_exp(env,e,impl,st,msg) => e' &
	 ceval_ast_eltargs(env,eltargs,impl,st,msg) => eltargs'
	 --------------------------------------------------
	 ceval_ast_modification(env,Absyn.CLASSMOD(eltargs,SOME(e)),impl,st,msg)
	  => (Absyn.CLASSMOD(eltargs',SOME(e')))

  rule	ceval_ast_eltargs(env,eltargs,impl,st,msg) => eltargs'
	 --------------------------------------------------
	 ceval_ast_modification(env,Absyn.CLASSMOD(eltargs,NONE),impl,st,msg)
	  => (Absyn.CLASSMOD(eltargs',NONE))
 end

(** relation: ceval_ast_eltargs
 **
 ** Helper relation to ceval_ast_modification.
 **)

 relation ceval_ast_eltargs: (Env.Env, Absyn.ElementArg list,
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg)
	  => (Absyn.ElementArg list) =

  axiom	ceval_ast_eltargs(env,[],_,_,msg) => []

  rule	ceval_ast_modification(env,mod,impl,st,msg) => mod' &
	 ceval_ast_eltargs(env,args,impl,st,msg) => res 
	 -----------------------------------------------
	 ceval_ast_eltargs(env,Absyn.MODIFICATION(b,e,cr,SOME(mod),stropt)::args,
			   impl,st,msg) 
	  => Absyn.MODIFICATION(b,e,cr,SOME(mod'),stropt)::res

	   (**TODO: look through redeclarations for Eval(var) as well **)
  rule	ceval_ast_eltargs(env,args,impl,st,msg) => res
	 ------------------------------------------
	 ceval_ast_eltargs(env,m::args,
			   impl,st,msg) 
	  => m::res
 end

(** relation: ceval_ast_arraydim
 **
 ** Helper relation to ceva_ast_citems*)

 relation ceval_ast_arraydim: (Env.Env, Absyn.ArrayDim, 
			       bool (*impl*), 
			       Interactive.InteractiveSymbolTable option,
			       Msg)
	  => (Absyn.ArrayDim) =
  axiom	ceval_ast_arraydim (env,[],_,_,msg) => []

  rule	ceval_ast_arraydim(env,xs,impl,st,msg) => res
	 -----------------------------------------
	 ceval_ast_arraydim(env,Absyn.NOSUB::xs,impl,st,msg) 
	  => Absyn.NOSUB::res

  rule	ceval_ast_arraydim(env,xs,impl,st,msg) => res &
	 ceval_ast_exp(env,e,impl,st,msg) => e'
	 ----------------------------------
	 ceval_ast_arraydim(env,Absyn.SUBSCRIPT(e)::xs,impl,st,msg) 
	  => Absyn.SUBSCRIPT(e)::res
 end

(* relation ceval_interactive_functions
 **
 ** This relation evaluates the functions defined in the interactive 
 ** environment.
 *)
 relation ceval_interactive_functions: (Env.Env, 
					Exp.Exp, (* exp to evaluate *)
					Interactive.InteractiveSymbolTable,
					Msg)
	  => (Values.Value, Interactive.InteractiveSymbolTable) =


  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	 Lookup.lookup_class(env,path,true) => (c, env) &
	 Env.get_env_path(env) => SOME(p1) &
	 ModUtil.path_string(p1) => s1 &
	 Print.print_buf "Found class " &
	 Print.print_buf s1 & Print.print_buf "\n\n" &
	 Print.get_string() => str
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("lookupClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	Interactive.get_type_of_variable(varid, iv) => tp &
	 Types.unparse_type tp => str 
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("typeOf"),[Exp.CREF(Exp.CREF_IDENT(varid,_),_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	let newst = Interactive.SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[],[])
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clear"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,ic,[],cf)
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearVariables"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,[],iv,cf)
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearCache"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf),msg) => (Values.BOOL(true),newst)

  rule	Dump.unparse_str(p(*,false*)) => str
	 -------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(cr) => path &
	 Interactive.get_pathed_class_in_program(path,p) => class &
	 Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)(*,false*)) => str
	 -------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	 Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	 DAELow.lower(dae) => (daelow as DAELow.DAELOW(vars,_,eqnarr,_,_,_,_)) &
	 DAELow.incidence_matrix(daelow) => m &
	 DAELow.transpose_matrix(m) => mt &
	 DAELow.calculate_jacobian(vars,eqnarr,m,mt) => jac &
	 DAELow.dump_jacobian_str(jac) => res 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("jacobian"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(res),Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))

  rule  Static.component_ref_to_path(cr) => classname &
	 SCode.elaborate(p) => p' &
	 Inst.instantiate_class(p',classname) => (dae as DAE.DAE(dael),env) &
	 Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname,dael,env)) 
	  => ic' &
	   DAELow.lower(dae) => dlow &
	 DAELow.incidence_matrix(dlow) => m &
	 DAELow.transpose_matrix(m) => mT &
	 DAELow.matching_algorithm(dlow,m,mT,DAELow.INDEX_REDUCTION) 
	  => (ass1,ass2,dlow',m,mT) &
	 DAELow.strong_components(m,mT,ass1,ass2) => (comps) &
	 DAELow.translate_dae (dlow') => indexed_dlow &
	 DAELow.calculate_values(indexed_dlow) => indexed_dlow' &
	 Absyn.path_string(classname) => cname_str &
	 Util.string_append_list([cname_str,".cpp"]) => filename &
	 Util.string_append_list([cname_str,"_functions.cpp"]) => funcfilename &
	 Util.string_append_list([cname_str,".makefile"]) => makefilename &
	 SimCodegen.generate_functions(p',dae,indexed_dlow',classname,funcfilename) &
	 SimCodegen.generate_simulation_code(dae,indexed_dlow',ass1,ass2,m,mT,comps,classname,filename) &
	 SimCodegen.generate_makefile(makefilename,classname) 
         (*	Util.string_append_list(["make -f ",cname_str, ".makefile\n"]) => s_call &
          *)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (Values.STRING("The model have been translated"),st)
	 
  axiom
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("The environment variable OPENMODELICAHOME was not set"),st)
           
	   
	   (* FIXME: Should ceval be called with impl=true here? *)
  rule	(* Build and simulate model *)
	 ceval(env,starttime,true,SOME(st),NONE,msg) 
	  => (Values.REAL(starttime_r),SOME(st)) &
	   ceval(env,stoptime,true,SOME(st),NONE,msg) 
	  => (Values.REAL(stoptime_r),SOME(st)) &
	   ceval(env,interval,true,SOME(st),NONE,msg) 
	  => (Values.INTEGER(interval_i),SOME(st)) &
	   ceval(env,method,true,SOME(st),NONE,msg) 
	  => (Values.STRING(method_str),SOME(st)) &
	   real_sub(stoptime_r,starttime_r) => delta_time &
	 int_real(interval_i) => interval_r &
	 real_div(delta_time,interval_r) => stepsize_r &
	 Static.component_ref_to_path(cr) => classname &
	 SCode.elaborate(p) => p' &
	 Inst.instantiate_class(p',classname) => (dae as DAE.DAE(dael),env) &
	 Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname,dael,env)) 
	  => ic' &
	   DAELow.lower(dae) => dlow &
	 DAELow.incidence_matrix(dlow) => m &
	 DAELow.transpose_matrix(m) => mT &
	 DAELow.matching_algorithm(dlow,m,mT,DAELow.INDEX_REDUCTION) 
	  => (ass1,ass2,dlow',m,mT) &
	 DAELow.strong_components(m,mT,ass1,ass2) => (comps) &
	 DAELow.translate_dae (dlow') => indexed_dlow &
	 DAELow.calculate_values(indexed_dlow) => indexed_dlow' &
	 Absyn.path_string(classname) => cname_str &
	 Util.string_append_list([cname_str,".cpp"]) => filename &
	 Util.string_append_list([cname_str,"_functions.cpp"]) => funcfilename &
	 Util.string_append_list([cname_str,"_init.txt"]) => init_filename &
	 Util.string_append_list([cname_str,".makefile"]) => makefilename &
	 SimCodegen.generate_functions(p',dae,indexed_dlow',classname,funcfilename) &
	 SimCodegen.generate_simulation_code(dae,indexed_dlow',ass1,ass2,m,mT,comps,classname,filename) &
	 SimCodegen.generate_init_data(indexed_dlow',classname,init_filename,
				       starttime_r,stoptime_r,stepsize_r) &
	 SimCodegen.generate_makefile(makefilename,classname) &
         (*	Util.string_append_list(["make -f ",cname_str, ".makefile\n"]) => s_call &
          *)
	 System.path_delimiter => pd &
	 System.read_env("OPENMODELICAHOME") => omhome & 
	 win_citation() => cit &
	 Util.string_append_list([cit,omhome, pd, "Compiler", 
                                  pd, "scripts", pd, "Compile ", 
                                  makefilename," > output.log 2>&1",cit
                                  ]) => s_call &
         (*> output.log 2>&1 = redirect stderr to stdout and put it in output.log *)

	 System.system_call(s_call) => 0 &
	 Util.string_append_list([cit,".", pd, cname_str, " -m ",
                                  method_str," >> output.log 2>&1",
                                  cit]) => sim_call &
	 System.system_call(sim_call) => _ &
	 Util.string_append_list([cname_str,"_res.plt"]) => result_file &
	 let simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),[Values.STRING(result_file)],["resultFile"]) &
	 let simType = (Types.T_COMPLEX(ClassInf.RECORD("SimulationResult")
				        ,[Types.VAR("resultFile",
						    Types.ATTR(false, 
							       SCode.RO, 
							       SCode.VAR,
							       Absyn.BIDIR),
				                    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
					  ]
				        ),NONE) &
	 Interactive.add_var_to_symboltable("currentSimulationResult",simValue,simType,st) 
	  => newst &
	   Print.clear_error_buf()
	 ------------------------------------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval,method],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (simValue,newst)
	   
  rule	
	 (* simulation fail for som other reason than OPENMODELICAHOME not being set.*)
	 System.read_env("OPENMODELICAHOME") => omhome &
	 Print.get_error_string() => str &
	 Util.string_append_list(["Simulation failed.\n",str,"\n"]) => res &
	 let simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),[Values.STRING(res)],["resultFile"])
	 ------------------------------------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval,method],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (simValue,st)

  rule	let simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),[Values.STRING("Simulation Failed. Environment variable OPENMODELICAHOME not set.")],["resultFile"])
	 ------------------------------------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval,method],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (simValue,st)

  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	 Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	 DAE.dump_str (dae) => str 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("instantiateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))

  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 (* we do not want error msg twice.. *)
	 Print.get_error_string() => str &
	 not Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	 Print.clear_error_buf() &
	 Print.print_error_buf(str) &
	 Print.get_error_string() => str
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("instantiateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),Interactive.SYMBOLTABLE(p,sp,ic,iv,cf))

  rule	Util.list_map(vars,Exp.print_exp_str) => vars' &
	 System.pwd() => pwd &
	 System.path_delimiter => pd & 
	 Util.string_append_list([pwd,pd,filename]) => filename' &
	 System.read_ptolemyplot_dataset(filename',vars',size) => value
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResult"),[Exp.SCONST(filename),Exp.ARRAY(_,_,vars),Exp.ICONST(size)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (value,st)

  rule	Print.print_error_buf "#Error reading simulation result. Check that filename and variablenames are correct.\n" 
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResult"),[Exp.SCONST(filename),Exp.ARRAY(_,_,vars),Exp.ICONST(size)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => fail

  rule	(* plot *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 Util.list_union_elt("time",vars') => vars'' &
	 ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,msg) 
	  => (Values.RECORD(_,[Values.STRING(filename)],_),_) &
	   System.read_ptolemyplot_dataset(filename,vars'',0) => value &
	 System.pwd() => pwd &
	 System.read_env("OPENMODELICAHOME") => omhome &
	 System.path_delimiter => pd &
	 Util.string_append_list([omhome,pd,"Compiler",pd,"scripts",pd,"doPlot"]) => plotCmd &
	 Util.string_append_list([pwd,pd,"tmpPlot.plt"]) => tmpPlotFile &
	 Values.write_ptolemyplot_dataset(tmpPlotFile,value,vars'',"Plot by OpenModelica") 
	  => res &
	   Util.string_append_list([plotCmd, " \"", tmpPlotFile,"\""]) => call &			   
	 System.system_call(call) => _
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  rule	(* Catch error reading simulation file. *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 Util.list_union_elt("time",vars') => vars'' &
	 ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,msg) 
	  => (Values.RECORD(_,[Values.STRING(filename)],_),_) &
	   not System.read_ptolemyplot_dataset(filename,vars'',0) => _ 
	 ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("Error reading the simulation result."),st)
	   
  rule	(* Catch error reading simulation file. *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 Util.list_union_elt("time",vars') => vars'' &
	 not ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,NO_MSG) 
	  => (_,_)
	   ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("No simulation result to plot."),st)

  axiom ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
 	  => (Values.STRING("Unknown error while plotting"),st)
	   
  rule	System.time => t1 &
	 ceval(env,exp,true,SOME(st),NONE,msg) => (value,SOME(st')) &   
	 System.time => t2 &
	 real_sub(t2,t1) => time 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("timing"),[exp],_,_),st,msg) => (Values.REAL(time),st')

  rule	System.set_c_compiler(str)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompiler"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),st)

  rule	System.set_c_flags(str)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompilerFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),st)

  rule	string_append("+d=",str) => str' &
	 RTOpts.args [str'] => args 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setDebugFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),st)

  rule	System.cd(str) => res &
	 int_eq (res,0) => true &
	 System.pwd => str' 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str'),st)

  rule	System.pwd() => str'
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str'),st)

  rule	System.system_call(str) => res 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("system"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.INTEGER(res),st)


  rule	System.read_file(str) => str'
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readFile"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str'),st)

  rule	Print.get_error_string() => str &
	 Print.clear_error_buf()
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("getErrorString"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str),st)

  rule	System.read_file(str) => scriptstr &
	 Parser.parsestringexp(scriptstr) => (istmts,msg) &
	 msg = "Ok" &
	 Interactive.evaluate(istmts,st,true) => (res,newst) &
	 Util.string_append_list([res,"\ntrue"]) => res'
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(res'),newst)

  axiom	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st,msg) 
	  => (Values.BOOL(false),st)


  rule	(* SCode.elaborate(p) => p' & *)
	 Static.component_ref_to_path(fcr) => path &
	 ceval_generate_function(env, path)
         (*	& Inst.instantiate_implicit(p') => d & *)
	 --------------------------------------
	 ceval_interactive_functions (env,
				      Exp.CALL(Absyn.IDENT("generateCode"),[funcref as Exp.CREF(fcr,_)],_,_),
				      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true), st)
	 (* add path to symboltable for compiled functions
	  Interactive.SYMBOLTABLE(p,sp,ic,iv,(path,t)::cf),
	  but where to get t? *)

  rule	System.modelicapath => mp &
	 Static.component_ref_to_path(cr) => path &
	 ClassLoader.load_class(path, mp) => pnew &
	 Interactive.update_program(pnew,p) => p' &
	 Print.get_string => str &
	 let newst = Interactive.SYMBOLTABLE(p', sp, [], iv, cf)
	 ------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),newst)
	 
  rule	Static.component_ref_to_path(cr) => path &
	 ModUtil.path_string(path) => pathstr &
	 Util.string_append_list(["Class ",pathstr," not found in MODELICAPATH.\n"])=> str &
	 Print.print_error_buf str
	 ------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(false),st)


  rule  System.regular_file_exist(name) => 0 &
         Parser.parse(name) => p1 &
	 Interactive.update_program(p1,p) => newp
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg)
	  => (Values.BOOL(true),Interactive.SYMBOLTABLE(newp,sp,[],iv,cf))

       (** it the rule above have failed then check if file exists **)
        (* without this omc crashes *)
  rule  System.regular_file_exist(name) => rest &
         int_gt(rest,0) => true
         ---------------------------------------------------
         ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg)
	  => (Values.BOOL(false),st)
           
           
  rule	not Parser.parse(name) => _
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg)
	  => (Values.BOOL(false),st)
           
  rule	Static.component_ref_to_path(cr) => classpath &
	 Interactive.get_pathed_class_in_program(classpath,p) => class &
	 Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)(*,true*)) => str &
	 System.write_file(filename,str) 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(filename),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  rule	Static.component_ref_to_path(cr) => classpath &
	Interactive.get_contained_class_and_file(classpath,p) => (p',filename) &
	Dump.unparse_str(p'(*,true*)) => str &
	System.write_file(filename,str) 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("save"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  axiom	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("save"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(false),st)

  rule	Dump.unparse_str(p(*,true*)) => str &
	 System.write_file(filename,str) 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveAll"),[Exp.SCONST(filename)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  rule	(*Error writing to file *)
	 Static.component_ref_to_path(cr) => classpath &
	 Interactive.get_pathed_class_in_program(classpath,p) => class &
	 Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)(*,true*)) => str &
	 Print.print_error_buf "Error writing to file.\n" 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(false),st)

  rule	(*Error writing to file *)
	 Static.component_ref_to_path(cr) => classpath &
	 Print.print_error_buf "Error unknown class.\n" 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(false),st)

  rule	System.read_env("OPENMODELICAHOME") => omhome &
         System.path_delimiter => pd &
         Util.string_append_list([omhome,pd,"Compiler",pd,"helptext.txt"]) => filename &
	 print filename & 
	 System.read_file(filename) => str 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("help"),[],_,_),
				      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	get_builtin_attribute(classname,cref,"unit",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getUnit"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"quantity",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getQuantity"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"displayUnit",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getDisplayUnit"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"min",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMin"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"max",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMax"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"start",st) => (v, st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStart"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"fixed",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getFixed"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"nominal",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getNominal"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"stateSelect",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStateSelect"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')
 
           (* FIXME: test code: remove *)
  rule	Exp.exp_contains (exp1, exp2) => res
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("exp_contains"),
						   [exp1, exp2], _, _),
				     st,msg)
	  => (Values.BOOL(res), st)

  rule	Exp.solve (exp1, exp2, exp3) => res1 &
	 Exp.print_exp_str res1 => res
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("solve"),
						   [exp1, exp2, exp3], _, _),
				     st,msg)
	  => (Values.STRING(res), st)
           (* /FIXME: test code: remove *)

end

(** relation: win_citation
 ** author: PA
 **
 ** Returns a cition mark if platform is windows, otherwise empty string. Used
 ** by simulate to make whitespaces work in filepaths for WIN32
 **)
relation win_citation: () => string =


  rule	System.platform => "WIN32"
	-------------------
	win_citation () => "\""

  axiom	win_citation() => ""
end

	

(** relation: get_builtin_attribute
 **
 ** Retrieves a builtin attribute of a variable in a class by instantiating 
 ** the class and retrieving the attribute value from the flat variable.
 **)
 
relation get_builtin_attribute: (Exp.ComponentRef, Exp.ComponentRef, string,
				   Interactive.InteractiveSymbolTable) 
	  => (Values.Value, Interactive.InteractiveSymbolTable) =

  rule	(* Check cached instantiated class *)
	  Static.component_ref_to_path(classname) => classname' &
	  Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	  Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	  Lookup.lookup_var(env,cref') => (attr,ty,Types.EQBOUND(exp,_,_)) &
	  Exp.print_exp_str exp => str
	  --------------------------------
	  get_builtin_attribute(classname,cref,"stateSelect",
			        st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(classname) => classname' &
	  SCode.elaborate(p) => p' &
	  Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	  Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	    Env.open_scope(env',encflag,SOME(n)) => env3 &
	  ClassInf.start(r,n) => ci_state &
	  Inst.inst_class_in(env3, Types.NOMOD, Prefix.NOPRE, [], ci_state, 
			     c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys) &
	    Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	  Lookup.lookup_var(env4,cref') => (attr,ty,Types.EQBOUND(exp,_,_)) &
	  Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' &
	  Exp.print_exp_str exp => str
	  --------------------------------
	  get_builtin_attribute(classname,cref,"stateSelect",
			        Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str), Interactive.SYMBOLTABLE(p,sp,ic',vars,cf))

  rule	Static.component_ref_to_path(classname) => classname' &
	  Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	  Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	  Lookup.lookup_var(env,cref') => (attr,ty,Types.VALBOUND(v)) 
	  -----------------------------------------------
	  get_builtin_attribute(classname,cref,attribute,
			        st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, st)

  rule	Static.component_ref_to_path(classname) => classname' &
	  SCode.elaborate(p) => p' &
	  Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	  Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	    Env.open_scope(env',encflag,SOME(n)) => env3 &
	  ClassInf.start(r,n) => ci_state &
	  Inst.inst_class_in(env3, Types.NOMOD, Prefix.NOPRE, [], ci_state, 
			     c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys) &
	    Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	  Lookup.lookup_var(env4,cref') => (attr,ty,Types.VALBOUND(v)) &
	  Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' 
	  -----------------------------------------------
	  get_builtin_attribute(classname,cref,attribute,
			        st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, Interactive.SYMBOLTABLE(p,sp,ic',vars,cf)) 
  end 

(** relation: ceval_matrixelt
 **
 ** Evaluates the expression of a matrix constructor, e.g. [1,2;3,4]
 **)

relation ceval_matrixelt:(Env.Env,
			  (Exp.Exp*bool) list list, (* matrix constr. elts*)
			  bool, (*impl*) 
			  Msg) 
	  => Values.Value list =
	  
  rule	ceval_matrixeltrow(env,expl,impl,msg) => v &
	ceval_matrixelt(env,expll,impl,msg) => vl
	---------------------------
	ceval_matrixelt(env,expl::expll,impl,msg) => v::vl
	
  axiom	ceval_matrixelt(_,[],_,msg) => []
end

(** relation: ceval_matrixeltrow
 **
 ** Helper relation to ceval_matrixelt
**)

relation ceval_matrixeltrow:(Env.Env, (Exp.Exp*bool) list, bool, (*impl*) 
			     Msg) => Values.Value =
	
  rule	ceval (env,e,impl,NONE,NONE,msg) => (res,_) &
	ceval_matrixeltrow(env,rest,impl,msg) => Values.ARRAY(resl)
	-------------------
	ceval_matrixeltrow(env, (e,_)::rest,impl,msg) => Values.ARRAY(res::resl)
	
  axiom	ceval_matrixeltrow(env,[],_,msg) => Values.ARRAY([])
	
end

(** relation: ceval_builtin_size
 **
 ** Evaluates the size operator.
 **)

relation ceval_builtin_size : (Env.Env, Exp.Exp, Exp.Exp, bool, 
			       Interactive.InteractiveSymbolTable option,
			       Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	    

  rule	(* If dimensions known, always ceval *)
	  Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	  Types.dimensions_known(tp) => true &
	  Types.get_dimension_sizes(tp) => sizelst &
	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dim),st') &
	  int_sub(dim,1) => dim' &
	  list_nth(sizelst,dim') => v
	  ------------------------------------
	  ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl,st,msg) 
	  => (Values.INTEGER(v),st')

  rule	(* If component not instantiated yet, recursive definition.
	 For example,
	 Real x[:](min=fill(1.0,size(x,1))) = {1.0} 
	 *
	 * When size(x,1) should be determined, x must be instantiated, but
	 * that is not done yet. Solution: Examine Element to find modifier 
	 * which will determine dimension size.
	 *)
	Inst.elab_component_arraydim_from_env(env,cr) => dims &
	print "got dims\n" &
	ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dimv),st') &
	print "cevaled\n" &
	ceval_builtin_size_3(dims,dimv) => v2
	------------------------------------
	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as false,st,msg) 
	  => (v2,st')

  rule	(* If dimensions not known and impl=true, just silently fail *)
	  Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	  Types.dimensions_known(tp) => false
	  ------------------------------------
	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as true,st,msg) => fail

  rule	(* If dimensions not known and impl=false, error message *)
	  Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	  Types.dimensions_known(tp) => false &
	  Print.print_error_buf "# Dimensions must be known when instantiating models\n"
	  ------------------------------------
	  ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as false,st,MSG) => fail
  rule	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.dimensions_known(tp) => false 
	------------------------
  	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as false,st,NO_MSG) => fail

  rule	(*For crefs without value binding*) 
	  Lookup.lookup_var(env,cr) => (attr, tp, Types.UNBOUND) &
	  Print.print_error_buf "# Value of cref not known when instantiating: "  &
	  Exp.print_exp_str exp => expstr &
	  Print.print_error_buf expstr &
	  Print.print_error_buf "\n"
	  ------------------------------------
	  ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl as false,st,MSG) => fail

  rule	  Lookup.lookup_var(env,cr) => (attr, tp, Types.UNBOUND) 
	----------------------------------
	ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl as false,st,NO_MSG) => fail

  rule	(*For crefs without value binding. If impl=true just silently fail *) 
	  Lookup.lookup_var(env,cr) => (attr, tp, Types.UNBOUND)
	  ------------------------------------
	  ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl as true,st,msg) => fail

  rule	(*For crefs with value binding*) 
	  Lookup.lookup_var(env,cr) => (attr, tp, binding) &
	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dimv),st') &
	  ceval_cref_binding (env,cr,binding,impl,msg) => v &
	  ceval_builtin_size_2(v,dimv) => v2
	  ------------------------------------
	  ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl,st,msg) => (v2,st')

  rule	  (* Special case for array expressions with nonconstant values*)
	  (* For now: only arrays of scalar elements: TODO generalize to arbitrary
	   dimensions*)
	  Exp.typeof(e) => tp &
	  Exp.type_builtin(tp) => true &
 	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(1),st') &
	  list_length(e::es) => len
 	  ---------------------------------
 	  ceval_builtin_size(env,Exp.ARRAY(_,_,e::es),dim,impl,st,msg) => (Values.INTEGER(len),st')

  rule	(* try to ceval expression, for constant expressions *)
	  ceval(env,exp,impl,st,NONE,msg) => (v, st') &
	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dimv),st') &
	  ceval_builtin_size_2(v,dimv) => v2
	  ---------------------------------
	  ceval_builtin_size(env,exp,dim,impl,st,msg) => (v2,st')

  rule	Print.print_error_buf "#-- ceval_builtin_size failed: "  &
	  Exp.print_exp_str exp => expstr &
	  Print.print_error_buf expstr &
	  Print.print_error_buf "\n" 
	  ------------------------------------
	  ceval_builtin_size(env,exp,dim,impl,st,MSG) => fail
  end

(** relation: ceval_bultin_size_2
 ** 
 ** Helper relation to ceval_builtin_size
 **)

relation ceval_builtin_size_2 : (Values.Value, int) => (Values.Value) =
	
  rule	list_length(lst) => dim
	---------------------------------------
	ceval_builtin_size_2(Values.ARRAY(lst), 1) => Values.INTEGER(dim)
	
  rule	int_sub (ind, 1) => ind' &
	ceval_builtin_size_2 (l, ind') => dim
	--------------------------------------------------
	ceval_builtin_size_2 (Values.ARRAY(l::lst), ind) => dim
	
  rule	Debug.fprint("failtrace","- ceval_builtin_size_2 failed\n")
	-------------------------------------
	ceval_builtin_size_2(_,_) => fail
end


(** relation: ceval_builtin_size_3
 ** author: PA
 ** 
 ** Helper relation to ceval_builtin_size. Used when recursive definition
 ** (attribute modifiers using size) is used.
**)

relation ceval_builtin_size_3: (Inst.DimExp list, int ) => Values.Value =

  rule	n - 1 => n' &
	list_nth(dims,n') => Inst.DIMINT(v) 
	-------------------------
	ceval_builtin_size_3(dims,n) => Values.INTEGER(v)

  rule	n - 1 => n' &
	list_nth(dims,n') => Inst.DIMEXP(sub,eopt) &
	print "ceval_builtin_size_3 failed DIMEXP in dimesion\n"
	-------------------------
	ceval_builtin_size_3(dims,n) => fail

(*  rule	print "-ceval_builtin_size_3 failed\n"
	-------------------------
	ceval_builtin_size_3(dims,n) => fail*)
end

(** relation: ceval_builtin_abs
 ** author: LP
 ** 
 ** Evaluates the abs operator.
 **)

relation ceval_builtin_abs : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_abs(rv) => rv'
	--------------------------------------
	ceval_builtin_abs(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)

  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.INTEGER(iv),_) &
        int_abs(iv) => iv  
	--------------------------------------
	ceval_builtin_abs(env,[exp],impl,st,msg) => (Values.INTEGER(iv),st)
end

(** relation: ceval_builtin_sign
 ** author: PA
 ** 
 ** Evaluates the sign operator.
 **)

relation ceval_builtin_sign : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_gt(rv,0.0) => b1 &
	real_lt(rv,0.0) => b2 &
	real_eq(rv,0.0) => b3 &
	Util.list_select([(b1,1.0),(b2,-1.0),(b3,0.0)],Util.tuple2_1) 
	  => [(_,rv')]
	--------------------------------------
	ceval_builtin_sign(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)

  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.INTEGER(iv),_) &
        int_gt(iv,0) => b1 &
	int_lt(iv,0) => b2 &
	int_eq(iv,0) => b3 &
	Util.list_select([(b1,1),(b2,-1),(b3,0)],Util.tuple2_1) 
	  => [(_,iv')]
	--------------------------------------
	ceval_builtin_sign(env,[exp],impl,st,msg) => (Values.INTEGER(iv'),st)
end

(** relation: ceval_builtin_exp
 ** author: PA
 ** 
 ** Evaluates the exp function
 **)

relation ceval_builtin_exp : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
	real_exp(rv) => rv'
	--------------------------------------
	ceval_builtin_exp(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)

end

(** relation: ceval_builtin_noevent
 ** author: PA
 ** 
 ** Evaluates the noEvent operator. During constant evaluation events are not
 ** considered, so evaluation will simply remove the operator and evaluate the
 ** operand.
 **)

relation ceval_builtin_noevent : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (v,_) 
	--------------------------------------
	ceval_builtin_noevent(env,[exp],impl,st,msg) => (v,st)

end

(** relation: ceval_builtin_floor
 ** author: LP
 ** 
 ** evaluates the floor operator.
 **)

relation ceval_builtin_floor : (Env.Env, 
				Exp.Exp list, 
				bool, 
				Interactive.InteractiveSymbolTable option,
				Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_floor rv => rv' 
        --------------------------------------
        ceval_builtin_floor(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
end

(** relation ceval_builtin_ceil
 ** author: LP
 ** 
 ** evaluates the ceil operator.
 **)
relation ceval_builtin_ceil : (Env.Env, 
			       Exp.Exp list, 
			       bool, 
			       Interactive.InteractiveSymbolTable option,
			       Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_floor rv => rv' &
        real_int rv' => ri &
        int_real ri => rvt &
        real_eq(rvt,rv) => true 
        --------------------------------------
        ceval_builtin_ceil(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_floor rv => rv' &
        real_int rv' => ri &
        int_add(ri,1) => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_ceil(env,[exp],impl,st,msg) => (Values.REAL(rv''),st)
end

(** relation: ceval_builtin_sqrt
 ** author: LP
 ** 
 ** Evaluates the builtin sqrt operator.
 **)

relation ceval_builtin_sqrt : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option,Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_lt (rv,0.0) => true &
        Print.print_error_buf "# sqrt - the input is negative\n" 
        --------------------------------------
        ceval_builtin_sqrt(env,[exp],impl,st,msg) => fail
        
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_sqrt rv => rv' 
        --------------------------------------
        ceval_builtin_sqrt(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
end

(** relation ceval_builtin_sin
 ** author: LP
 **
 ** Evaluates the builtin sin function.
 **)

relation ceval_builtin_sin : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_sin rv => rv' 
	--------------------------------------
	ceval_builtin_sin(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
end

(** relation ceval_builtin_cos
 ** author: LP
 **
 ** Evaluates the builtin cos function.
 **)
	    
relation ceval_builtin_cos : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_cos rv => rv' 
	--------------------------------------
	ceval_builtin_cos(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
        
end

(** relation ceval_builtin_tan
 ** author: LP
 **
 ** Evaluates the builtin tan function.
 **)

relation ceval_builtin_tan : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
        
	  (** tan is not implemented in RML for some strange reason. *)
	
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_sin rv => sv &
	real_cos rv => cv &
	real_div(sv,cv) => rv' 
	--------------------------------------
	ceval_builtin_tan(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
end

(** relation ceval_builtin_asin
 ** author: PA
 **
 ** Evaluates the builtin asin function.
 **)

relation ceval_builtin_asin : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        System.asin rv => rv' 
	--------------------------------------
	ceval_builtin_asin(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
end

(** relation ceval_builtin_acos
 ** author: PA
 **
 ** Evaluates the builtin acos function.
 **)
	    
relation ceval_builtin_acos : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        System.acos rv => rv' 
	--------------------------------------
	ceval_builtin_acos(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
        
end

(** relation ceval_builtin_atan
 ** author: PA
 **
 ** Evaluates the builtin atan function.
 **)

relation ceval_builtin_atan : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
        
	  (** atan is not implemented in RML for some strange reason. *)
	
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
	System.atan(rv) => rv' 
	--------------------------------------
	ceval_builtin_atan(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
end


(** relation ceval_builtin_div
 ** author: LP
 **
 ** Evaluates the builtin div operator.
 **)

relation ceval_builtin_div : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rv' &
        real_int rv' => ri &
        int_real ri => rv''
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rv''),st)
        
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rv' &
        real_int rv' => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rv''),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	real_div(rv1,rv2) => rv' &
        real_int rv' => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rv''),st)
                 
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri2),_) &
	int_div(ri1,ri2) => ri' 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) 
	  => (Values.INTEGER(ri'),st)
        
  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
 	Print.print_error_buf "#Error, division by zero.\n" 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,MSG) => fail
	
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,NO_MSG) => fail

  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
 	Print.print_error_buf "#Error, division by zero.\n" 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,NO_MSG) => fail
end

(** relation ceval_builtin_mod
 ** author: LP
 **
 ** Evaluates the builtin mod operator.
 **)

relation ceval_builtin_mod : (Env.Env, Exp.Exp list, bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri2),_) &
        int_real ri1 => rv1 &
	int_real ri2 => rv2 &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd &
	real_int rvd => ri'
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.INTEGER(ri'),st)
        
  rule  ceval (env,exp2,impl,st,NONE,MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
 	Print.print_error_buf "#Second argument in mod should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule  ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,NO_MSG) => fail

  rule  ceval (env,exp2,impl,st,NONE,MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
 	Print.print_error_buf "#Second argument in mod should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule  ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,NO_MSG) => fail
end


(** relation ceval_builtin_max
 ** author: LP
 **
 ** Evaluates the builtin max function.
 **)

relation ceval_builtin_max : (Env.Env, Exp.Exp list, bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,arr,impl,st,NONE,msg) => (v,_) &
	ceval_builtin_max2(v) => (v')
        --------------------------------------
        ceval_builtin_max(env,[arr],impl,st,msg) => (v',st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.INTEGER(i1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.INTEGER(i2),_) &
	int_max(i1,i2) => i
        --------------------------------------
        ceval_builtin_max(env,[s1,s2],impl,st,msg) => (Values.INTEGER(i),st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.REAL(r1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.REAL(r2),_) &
	real_max(r1,r2) => r
        --------------------------------------
        ceval_builtin_max(env,[s1,s2],impl,st,msg) => (Values.REAL(r),st)
end


(** relation: ceval_builtin_max2
 **
 ** Helper relation to ceval_builtin_max.
 **)

relation ceval_builtin_max2 : (Values.Value) => (Values.Value) =

  rule	ceval_builtin_max2(v1)
	      => (Values.INTEGER(i1)) &
	ceval_builtin_max2(Values.ARRAY(vls)) 
	      => (Values.INTEGER(i2)) &
	int_max(i1,i2) => res
	---------------------
	ceval_builtin_max2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res))

  rule	ceval_builtin_max2(v1) => (Values.REAL(i1)) &
	ceval_builtin_max2(Values.ARRAY(vls)) => (Values.REAL(i2)) &
	real_max(i1,i2) => res
	---------------------
	ceval_builtin_max2(Values.ARRAY(v1::(vls as _::_)))
	  => (Values.REAL(res))

  rule	ceval_builtin_max2(vl) => (v)
	------------------
	ceval_builtin_max2(Values.ARRAY([vl]))
	  => (v)

  axiom	ceval_builtin_max2(Values.INTEGER(i))
	  => (Values.INTEGER(i))

  axiom	ceval_builtin_max2(Values.REAL(i))
	  => (Values.REAL(i))
end

(** relation: ceval_builtin_min
 ** author: PA
 **
 ** Constant evaluation of builtin min function.
 **)

relation ceval_builtin_min : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,arr,impl,st,NONE,msg) => (v,_) &
	ceval_builtin_min2(v) => (v')
        --------------------------------------
        ceval_builtin_min(env,[arr],impl,st,msg) => (v',st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.INTEGER(i1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.INTEGER(i2),_) &
	int_min(i1,i2) => i
        --------------------------------------
        ceval_builtin_min(env,[s1,s2],impl,st,msg) => (Values.INTEGER(i),st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.REAL(r1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.REAL(r2),_) &
	real_min(r1,r2) => r
        --------------------------------------
        ceval_builtin_min(env,[s1,s2],impl,st,msg) => (Values.REAL(r),st)
end

(** relation: ceval_builtin_min2
 **
 ** Helper relation to ceval_builtin_min.
 **)

relation ceval_builtin_min2 : (Values.Value) => (Values.Value) =

  rule	ceval_builtin_min2(v1) => (Values.INTEGER(i1)) &
	ceval_builtin_min2(Values.ARRAY(vls)) 
	  => (Values.INTEGER(i2)) &
	int_min(i1,i2) => res
	---------------------
	ceval_builtin_min2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res))

  rule	ceval_builtin_min2(v1) => (Values.REAL(i1)) &
	ceval_builtin_min2(Values.ARRAY(vls)) => (Values.REAL(i2)) &
	real_min(i1,i2) => res
	---------------------
	ceval_builtin_min2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.REAL(res))

  rule	ceval_builtin_min2(vl) => (v)
	------------------
	ceval_builtin_min2(Values.ARRAY([vl]))
	  => (v)

  axiom	ceval_builtin_min2(Values.INTEGER(i))
	  => (Values.INTEGER(i))

  axiom	ceval_builtin_min2(Values.REAL(i))
	  => (Values.REAL(i))
end

(** relation ceval_builtin_differentiate
 ** author: LP
 ** 
 ** This relation differentiates an equation: x^2 + x => 2x + 1
 **)
		 
 relation ceval_builtin_differentiate : (Env.Env, 
					 Exp.Exp list, 
					 bool, 
					 Interactive.InteractiveSymbolTable option,
					 Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
           
  rule   Derive.differentiate_exp(exp1,cr) => differentiated_exp &
         Exp.simplify(differentiated_exp) => differentiated_exp' &
         (* this is wrong... *)
          Exp.print_exp_str(differentiated_exp') => ret_val
         (* this should be used instead but unelab_exp must be able to unelaborate a complete exp 
           now it doesn't so the expression is returned as string*)
         (*Exp.unelab_exp(differentiated_exp') => absyn_exp *)
         ----------------------------------------------
         ceval_builtin_differentiate(env,[exp1,Exp.CREF(cr,_)],impl,st,msg) 
          => (Values.STRING(ret_val),st) 
           (*           =>  (Values.CODE(Absyn.C_EXPRESSION(absyn_exp)),st) *)

	 
  rule Print.print_buf "#Differentiation failed\n" 
	 ---------------------------------------------------------
	 ceval_builtin_differentiate (_,_,_,st,msg) => fail
 end

(* relation ceval_builtin_simplify
 ** author: LP
 **
 ** this relation simplifies an equation: x^2 + x => 2x + 1
 *)

 relation ceval_builtin_simplify : (Env.Env, 
				    Exp.Exp list, 
				    bool, 
				    Interactive.InteractiveSymbolTable option,
				    Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
           
         
           
  rule  Exp.simplify(exp1) => exp1' &
         Exp.print_exp_str(exp1') => ret_val
         (* this should be used instead but unelab_exp must be able to unelaborate a complete exp *)
         (*Exp.unelab_exp(simplifyd_exp') => absyn_exp *)
         ----------------------------------------------
         ceval_builtin_simplify(env,[exp1],impl,st,msg) 
          => (Values.STRING(ret_val),st) 
           (*           =>  (Values.CODE(Absyn.C_EXPRESSION(absyn_exp)),st) *)

	 
  rule Print.print_buf "#simplification failed\n" 
	 ---------------------------------------------------------
	 ceval_builtin_simplify (_,_,_,st,MSG) => fail
	 
         
 end

(** relation ceval_builtin_rem
 ** author: LP
 **
 ** Evaluates the builtin rem operator
 **)

relation ceval_builtin_rem : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_mul(rva,rv2) => rvb &
	real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_mul(rva,rv2) => rvb &
	real_sub(rv1,rvb) => rvd
         --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	real_div(rv1,rv2) => rva &
	real_mul(rva,rv2) => rvb &
	real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule	
	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri2),_) &
        int_real ri1 => rv1 &
	int_real ri2 => rv2 &
	real_div(rv1,rv2) => rva &
	real_mul(rva,rv2) => rvb &
	real_sub(rv1,rvb) => rvd &
	real_int rvd => ri'
         --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.INTEGER(ri'),st)
        
  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
 	Print.print_error_buf "#Second argument in rem should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,MSG) => fail
         
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,NO_MSG) => fail

  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
 	Print.print_error_buf "#Second argument in rem should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,NO_MSG) => fail
end


(** relation ceval_builtin_integer
 ** author: LP
 **
 ** Evaluates the builtin integer operator
 **)

relation ceval_builtin_integer : (Env.Env, Exp.Exp list, bool, 
				  Interactive.InteractiveSymbolTable option,
				  Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	   
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
         real_int rv => ri 
         --------------------------------------
         ceval_builtin_integer(env,[exp],impl,st,msg) 
	  => (Values.INTEGER(ri),st)
         
 end

(** relation: ceval_generate_function
 ** 
 **
 ** Generates code for a given function name.
 **)
	    
relation ceval_generate_function : (Env.Env, Absyn.Path) => () =
	
  rule	Debug.fprintln("ceval", "/*- ceval_generate_function starting*/") &
	ModUtil.path_string2 (path,"_") => pathstr &
	ceval_generate_function_str (path,env,[]) => (gencodestr,_) &
	string_append(pathstr,".c") => filename &
	Print.clear_buf &
        (*
	 string_append("CEVALGENFUNC_", pathstr) => defmacro &
	 Print.print_buf "#ifndef " & Print.print_buf defmacro & Print.print_buf "\n" &
	 Print.print_buf "#define " & Print.print_buf defmacro & Print.print_buf "\n" &
         *)
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf gencodestr &
	Print.print_buf "\nint main(int argc, char** argv)\n" &
	Print.print_buf "{\n\n  if (argc != 3)\n" &
	Print.print_buf "{\n      fprintf(stderr,\"# Incorrect number of arguments\\n\");\n" &
	Print.print_buf "return 1;\n    }\n" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
        (*
	 Print.print_buf "#endif /*" & Print.print_buf defmacro & Print.print_buf "*/\n" & 
         *)
	Print.write_buf(filename)&
	System.compile_c_file(filename) 
	--------------------------------------
	ceval_generate_function (env, path)
	
	
  rule	Debug.fprint("failtrace","/*- ceval_generate_function failed*/\n")
	-------------------------------------
	ceval_generate_function(_,_) => fail
end

(** relation: ceval_generate_function_str
 **
 ** Generates a function with the given path, and all functions that are called
 **  within that function. The string list contains names of functions already
 ** generated, which won't be generated again 
 **)

relation ceval_generate_function_str : (Absyn.Path, 
					Env.Env, 
					Absyn.Path list) 
	  => (string, Absyn.Path list) =

	(* If getmember succeeds, path is in generated functions list, so do nothing *) 
  rule	Util.list_getmember_p(path, gflist, ModUtil.path_equal) => gfmember 
	--------------------------------------------------------------------
	ceval_generate_function_str (path, env, gflist) => ("",gflist)

	(* If getmember fails, path is not in generated functions list, hence
	 * generate it *) 
  rule	not Util.list_getmember_p(path, gflist, ModUtil.path_equal) => _ &
	Debug.fprintln("ceval", "/*- ceval_generate_function_str starting*/") &
	Lookup.lookup_class(env, path, false) => (cls, env') &
	Debug.fprintln("ceval", "/*- ceval_generate_function_str instantiating*/") &
	Inst.implicit_function_instantiation(env', Types.NOMOD, Prefix.NOPRE, [], cls, [], false) => (env'',d) &
	Debug.fprint("ceval", "/*- ceval_generate_function_str getting functions: ") &
	SimCodegen.get_called_functions_in_function (path, DAE.DAE(d)) => calledfuncs &
	Util.list_map(calledfuncs, Absyn.path_string) => debugfuncs &
	Util.string_delimit_list(debugfuncs, ", ") => debugfuncsstr &
	Debug.fprint("ceval", debugfuncsstr) &
	Debug.fprintln("ceval", "*/") &
	ceval_generate_function_str_list (calledfuncs, env, gflist) => (calledfuncsstrs, gflist') &
	Debug.fprint("ceval", "/*- ceval_generate_function_str prefixing dae */") &
	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Print.clear_buf &
	Absyn.path_string path => funcname &
	Util.string_append_list(["/*---FUNC: ", funcname, " ---*/\n\n"]) => funccom &
	Print.print_buf funccom &
	Debug.fprintln("ceval", "/* - ceval_generate_function_str generating functions */") &
	Codegen.generate_functions(d') &
	Print.get_string => thisfuncstr &
	Util.list_append_elt(thisfuncstr, calledfuncsstrs) => calledfuncsstrs' &
	Util.string_delimit_list(calledfuncsstrs', "\n\n") => resstr
	---------------------------------------------------------------------------
	ceval_generate_function_str (path, env, gflist) => (resstr, path::gflist)


  rule	Debug.fprint("failtrace","/*- ceval_generate_function_str failed*/\n")
	-------------------------------------
	ceval_generate_function_str(_,_,_) => fail

end

(** relation: ceval_generate_function_str_list
 **
 ** Generates code for several functions.
 **)

relation ceval_generate_function_str_list : (Absyn.Path list, 
					     Env.Env, 
					     Absyn.Path list) 
	  => (string list, Absyn.Path list) =

  axiom	ceval_generate_function_str_list ([],env,gflist) => ([], gflist)

  rule	ceval_generate_function_str (first,env,gflist) => (firststr,gflist') &
	ceval_generate_function_str_list (rest,env,gflist') => (reststr,gflist'')
	-------------------------------------------------------------------------
	ceval_generate_function_str_list (first::rest, env, gflist) => (firststr::reststr, gflist'')
end



(** relation ceval_builtin_diagonal
 **
 ** This relation generates a matrix[n,n] (A) of the vector {a,b,...,n}
 ** where the diagonal of A is the vector {a,b,...,n}
 ** ie A[1,1] == a, A[2,2] == b ...
 *)

relation ceval_builtin_diagonal : (Env.Env, 
				   Exp.Exp list, 
				   bool, 
				   Interactive.InteractiveSymbolTable option,
				   Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	   
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.ARRAY(rv2),_) &
	 list_length(rv2) => dimension &
	 
	 int_add(dimension,1) => correctDimension &
	 ceval_builtin_diagonal2(env,exp,impl,st,correctDimension,1, [],msg) =>
         retExp &
	 
   	 int_string dimension => dimensionString &
   	 Debug.fcall("ceval", Print.print_buf, "== dimensionString ") & 
   	 Debug.fcall("ceval", Print.print_buf, dimensionString) & 
   	 Debug.fcall("ceval", Print.print_buf, "\n")    	
	 --------------------------------------
	 ceval_builtin_diagonal(env,[exp],impl,st,msg) 
	  => (Values.ARRAY(retExp),st)
	 
	 
  rule  Print.print_error_buf "#Error, could not evaulate diagonal.\n"
	 ---------------------------------------------------------
	 ceval_builtin_diagonal (_,_,_,_,MSG) => fail
         
 end

(** relation: ceval_builtin_diagonal2
 ** 
 **  This is a help relation that is calling itself recursively to 
 **  generate the a nxn matrix with some special diagonal elements. 
 ** see ceval_builtin_diagonal 
 **)

relation ceval_builtin_diagonal2 : (Env.Env, 
				    Exp.Exp, 
				    bool, 
				    Interactive.InteractiveSymbolTable option, 
				    int, (* matrix dimension *)
				    int,  (* row *)
				    Values.Value list,
				    Msg) 
	  =>  Values.Value list =

  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.REAL(rv2),_) &

	int_sub(matrixDimension , 1) => correctDim &
	Util.list_fill(Values.REAL(0.0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.REAL(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow,[Values.ARRAY(listWithElement)],msg ) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  [], msg ) 
	  =>  retExp

        
  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.REAL(rv2),_) &

	not matrixDimension = row &
	int_sub(matrixDimension, 1) => correctDim &
	Util.list_fill(Values.REAL(0.0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.REAL(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	list_append(listIN,[Values.ARRAY(listWithElement)]) => appendedList &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow, appendedList, msg) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  listIN, msg ) 
	  => retExp
	
  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.INTEGER(rv2),_) &

	int_sub(matrixDimension , 1) => correctDim &
	Util.list_fill(Values.INTEGER(0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.INTEGER(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow,[Values.ARRAY(listWithElement)] ,msg) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  [],msg ) =>  retExp

        
  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.INTEGER(rv2),_) &

	not matrixDimension = row &
	int_sub(matrixDimension, 1) => correctDim &
	Util.list_fill(Values.INTEGER(0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.INTEGER(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	list_append(listIN,[Values.ARRAY(listWithElement)]) => appendedList &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow, appendedList,msg ) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  listIN,msg ) => retExp

        
  rule	matrixDimension = row
        --------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row, listIN,msg) => listIN
	


  rule  print"#-- ceval_builtin_diagonal2: Couldn't elaborate ceval_builtin_diagonal2()\n" &
 	int_string row => RowString &
	int_string matrixDimension => matrixDimensionString
	---------------------------------------------------------
	ceval_builtin_diagonal2 (_,_,_,_,matrixDimension,row,list,MSG) => fail

end



(** relation: ceval_builtin_size_matrix
 **
 ** Helper relation for ceval_builtin_size, for size(A) where 
 ** A is a matrix.
 **)
relation ceval_builtin_size_matrix : (Env.Env, 
				      Exp.Exp, 
				      bool, 
				      Interactive.InteractiveSymbolTable option,
				      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =

  rule	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.get_dimension_sizes(tp) => sizelst &
	Values.intlist_to_value(sizelst) => v
	-------------------------------------
	ceval_builtin_size_matrix(env,Exp.CREF(cr,tp),impl,st,msg) 
	  => (v,st)

  rule	ceval(env,exp,impl,st,NONE,msg) => (v,st') &
	Types.type_of_value(v) => tp &
	Types.get_dimension_sizes(tp) => sizelst &
	Values.intlist_to_value(sizelst) => v
	-------------------------------------
	ceval_builtin_size_matrix(env,exp,impl,st,msg) 
	  => (v,st)
end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

 relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	 -----------------------------------------
	 ceval_relation (v1, Exp.GREATER(t), v2) => v

	 (**  Integers *)

  rule	int_lt (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.LESS(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b)
  rule	int_le (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.LESSEQ(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b) 
  rule	int_ge (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.GREATEREQ(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b) 

  rule	int_eq (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.EQUAL(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.NEQUAL(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b)

	 (**  Reals *)

  rule	real_lt (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.LESS(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_le (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.LESSEQ(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ge (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.GREATEREQ(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.EQUAL(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.NEQUAL(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

	 (* Booleans *)


  rule	(* b1 != b2  == (b1 and not b2) or (not b1 and b2) *)
	 bool_not b1 => nb1 &
	 bool_not b2 => nb2 &
	 bool_and(b1,nb2) => ba &
	 bool_and(nb1,b2) => bb &
	 bool_or(ba,bb) => b
	 -------------------------------------
	 ceval_relation (Values.BOOL(b1),
		 	 Exp.NEQUAL(Exp.BOOL),
			 Values.BOOL(b2)) => Values.BOOL(b)
       
  rule	(* b1 == b2  ==> b1 and b2 or (not b1 and not b2) *)
 	 bool_not b1 => nb1 &
	 bool_not b2 => nb2 &
	 bool_and(b1,b2) => ba &
	 bool_and(nb1,nb2) => bb &
	 bool_or(ba,bb) => b
	 -------------------------------------
	 ceval_relation (Values.BOOL(b1),
		 	 Exp.EQUAL(Exp.BOOL),
			 Values.BOOL(b2)) => Values.BOOL(b)

  axiom	ceval_relation (Values.BOOL(false),
		 	 Exp.LESS(Exp.BOOL),
			 Values.BOOL(true)) => Values.BOOL(true)

  axiom	ceval_relation (Values.BOOL(_),
		 	 Exp.LESS(Exp.BOOL),
			 Values.BOOL(_)) => Values.BOOL(false)

  rule	Debug.fprint("failtrace", "- ceval_relation failed\n")
	 & print "-ceval_relation failed\n" 
	 ---------------------------------
	 ceval_relation (_,_,_) => fail
	 
end

(** relation: ceval_range
 **
 ** This re-lation evaluates a range expression.  It only handles integers.
 **)
		 
relation ceval_range : (int, int, int) => Values.Value list =
	
  rule	int_eq(start,stop) => true (* e.g. 1:1 => {1} *)
	------------------
	ceval_range(start,_,stop) => [Values.INTEGER(start)]
	
  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	int_gt(j,k) => b1 &
	int_gt(d,0) => b2 &
	bool_and(b1,b2) => c1 &
	int_lt(j,k) => b3 &
	int_lt(d,0) => b4 &
	bool_and(b3,b4) => c2 &
	bool_or(c1,c1) => true
	-----------------------------
	ceval_range(j,d,k) => []
	
  rule	ceval_range2(start,step,stop) => res
	-----------------------------------
	ceval_range (start, step, stop) => res
	
end

(** relation: ceval_range2
 **
 ** Helper relation to ceval_range.
 **)

relation ceval_range2: (int,int,int) => Values.Value list =
	
  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range2 (start,_,stop) => []	
	
  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range2 (next, step, stop) => l
	-----------------------------------
	ceval_range2 (start, step, stop) => Values.INTEGER(start)::l
end



(** relation: ceval_range_real
 **
 ** This relation evaluates a range expression.  It only handles reals
 **)
		 
 relation ceval_range_real : (real, real, real) => Values.Value list =
	 
  rule	real_eq(start,stop) => true (* e.g. 1:1 => {1} *)
	 ------------------
	 ceval_range_real(start,_,stop) => [Values.REAL(start)]
	 
  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	 real_gt(j,k) => b1 &
	 real_gt(d,0.0) => b2 &
	 bool_and(b1,b2) => c1 &
	 real_lt(j,k) => b3 &
	 real_lt(d,0.0) => b4 &
	 bool_and(b3,b4) => c2 &
	 bool_or(c1,c1) => true
	 -----------------------------
	 ceval_range_real(j,d,k) => []
	 
  rule	ceval_range_real2(j,d,k)=> res
	 -----------------------------------
	 ceval_range_real (j,d,k) => res
  end

(** relation: ceval_range_real2
 **
 ** Helper relation to ceval_range_real.
 **)

relation ceval_range_real2 : (real, real, real) => Values.Value list =
	
  rule	real_gt(start,stop) => true
	  --------------------------
	  ceval_range_real2 (start,_,stop) => []

  rule	real_gt(start,stop) => false & (* redundant *)
	  real_add (start, step) => next &
	  ceval_range_real2 (next, step, stop) => l 	
	  -----------------------------------
	  ceval_range_real2 (start, step, stop) => Values.REAL(start)::l
  end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

 relation ceval_list : (Env.Env, 
			Exp.Exp list, 
			bool, 
			Interactive.InteractiveSymbolTable option,
			Msg) 
	  => Values.Value list =

  axiom	ceval_list (env, [], _, _,msg) => []

  rule	ceval (env, exp,impl,st,NONE,msg) => (v,_)
	 ----------------------------
	 ceval_list (env, [exp],impl,st,msg) => [v]

  rule	ceval (env,exp,impl,st,NONE,msg) => (v,_) &
	 ceval_list (env, exps,impl,st,msg) => vs
	 ------------------------------
	 ceval_list (env, exp::exps,impl,st,msg) => v::vs

 end

(** relation: ceval_cref
 **
 ** Evaluates ComponentRef, i.e. variables, by looking up variables in the
 ** environment.
 **)
relation ceval_cref : (Env.Env, Exp.ComponentRef, bool, (*impl*) Msg) 
	  => Values.Value =

	  (* Search in env for binding. *)
  rule	Lookup.lookup_var (env, c) => (attr,ty,binding) &
	ceval_cref_binding (env,c,binding,impl,msg) => v
	-------------------------------------
	ceval_cref (env,c,impl,msg) => v 

  rule	not Lookup.lookup_var (env, c) => (_,_,_) &
	Print.print_error_buf "# Variable  " &
	Exp.print_component_ref_str c => str &
	Print.print_error_buf str & 
	Print.print_error_buf " not found.\n" 
	-------------------------------------
	ceval_cref (env,c,impl as false ,MSG) => fail

  rule	not Lookup.lookup_var (env, c) => (_,_,_) 
	-------------------------------------
	ceval_cref (env,c,impl as false ,NO_MSG) => fail

	 (* No binding found. *)
  rule	Print.print_error_buf "# No constant binding for " &
	Exp.print_component_ref_str c => str &
	Print.print_error_buf str & Print.print_error_buf "\n" 
	-------------------------------------
	ceval_cref (env,c,impl as false, MSG) => fail
	
end 

(** relation: ceval_cref_binding
 **
 ** Helper relation to ceval_cref. Evaluates varaibles by evaluating 
 ** their bindings.
 **)

relation ceval_cref_binding : (Env.Env, Exp.ComponentRef,
			       Types.Binding, 
			       bool, (*impl*) 
			       Msg) 
	  => Values.Value =
	  
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[]))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,v, sizelst,impl,msg) => res
	-----------------------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.VALBOUND(v),impl,msg)
	  => res
	  
  rule	Print.print_buf "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND,impl as false,MSG) => fail
	
  rule	Debug.fprint("ceval", "#- ceval_cref__binding: Ignoring unbound when implicit")	
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND,impl as true,MSG) => fail
	
	(* REDUCTION bindings*)
  rule	let Exp.REDUCTION(Absyn.IDENT(rfn),elexp,iter,iterexp) = exp &
	rfn = "array" &
	Debug.fprintln("ceval", "#-- ceval_cref_binding Array evaluation")
	---------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,_,Types.C_CONST),impl,MSG)
	  => fail
	  
	  (* REDUCTION bindings*)
  rule	let Exp.REDUCTION(Absyn.IDENT(rfn),elexp,iter,iterexp) = exp &
	not rfn = "array" &
	(* lookup without subscripts, so dimension sizes can be determined.*)
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[]))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,impl,NONE,NONE,msg) => (v,_) &
	ceval_subscript_value (env,subsc,v,sizelst,impl,msg) => res
	---------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,_,Types.C_CONST),impl,msg)
	  => res

	(* arbitrary expressions, C_VAR, value exists. *)  
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[]))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,e_val,sizelst,impl,msg) => res 
	----------------------------------------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,SOME(e_val),Types.C_VAR),impl,msg) 
	  => res

	(* arbitrary expressions, C_PARAM, value exists. *)  
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[]))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,e_val,sizelst,impl,msg) => res 
	----------------------------------------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,SOME(e_val),Types.C_PARAM),impl,msg) 
	  => res

	  (* arbitrary expressions. When binding has optional value. *)
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[]))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,impl,NONE,NONE,msg) => (v,_) &
	ceval_subscript_value(env,subsc,v,sizelst,impl,msg) => res
	------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,_,Types.C_CONST),impl,msg) 
	  => res

	  (* arbitrary expressions. When binding has optional value. *)
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[]))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,impl,NONE,NONE,msg) => (v,_) &
	ceval_subscript_value(env,subsc,v,sizelst,impl,msg) => res
	------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,_,Types.C_PARAM),impl,msg) 
	  => res
	  
  rule	Debug.fprint("ceval", "#- ceval_cref__binding failed (nonconstant EQBOUND(") &
	Exp.print_exp_str exp => expstr &
	Debug.fprint("ceval", expstr) &
	Debug.fprintln("ceval", "))") 
	--------------------------------
	ceval_cref_binding (env,_,Types.EQBOUND(exp,_,Types.C_VAR),impl,MSG) => fail
end

(** relation: ceval_subscript_value
 **
 ** Helper relation to ceval_cref_binding, applies subscrupts to array values
 ** to extract array elements.
 **)

relation ceval_subscript_value: (Env.Env,
				 Exp.Subscript list, (* subscript to extract*)
				 Values.Value, 
				 int list, (* dimension sizes *)
				 bool, (*impl*)
				 Msg) 
	  => Values.Value =

  rule	ceval(env,exp,impl,NONE,SOME(dim),msg) => (Values.INTEGER(n),_) &
	int_sub(n,1) => n' &
	list_nth(lst,n') => subval &
	ceval_subscript_value(env,subs,subval,dims,impl,msg) => res
	---------------------------------------------
	ceval_subscript_value(env,Exp.INDEX(exp)::subs,Values.ARRAY(lst), dim::dims,impl,msg) 
	  => res
	  
  axiom	ceval_subscript_value(env,[],v,_,_,_) => v
	
  rule	Debug.fprint("failtrace","-ceval_subscript_value failed\n") 
	-----------------------
	ceval_subscript_value(_,_,_,_,_,_) => fail
end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list, int list, 
			     bool, (*impl*) 
			     Msg)
	  => Exp.Subscript list =
	  
  axiom	ceval_subscripts (_,[],_,_,_) => []
	
  rule	ceval_subscript (env,sub,dim,impl,msg) => sub' &
	ceval_subscripts (env,subs,dims,impl,msg) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs,dim::dims,impl,msg) => (sub'::subs')
	
end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript, int, 
			    bool, (*impl*) 
			    Msg) => Exp.Subscript =
	
  axiom	ceval_subscript (env, Exp.WHOLEDIM,_,_,_) => Exp.WHOLEDIM
	
  rule	
	ceval (env, e1,impl,NONE,SOME(dim),msg) => (v1,_) &
	Static.value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1),dim,impl,msg) => Exp.INDEX(e1')
	
  rule	ceval (env, e1,impl,NONE,SOME(dim),msg) => (v1,_) &
	Static.value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1),dim,impl,msg) => Exp.SLICE(e1')
 end

