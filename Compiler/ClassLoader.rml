(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 ClassLoader.rml
 ** module:      ClassLoader
 ** description: Loading of classes from $MODELICAPATH.
 **
 ** RCS: $Id$
 **
 ** This module loads classes from $MODELICAPATH. It exports only one
 ** relation: the load_class relation. It is currently (2004-09-27) 
 ** only used by Ceval.rml when using the "loadclass" function in 
 ** the interactive environment.
 ** 
 **)

module ClassLoader:
  with "Absyn.rml"

  relation load_class: (Absyn.Path, string) => (Absyn.Program) 

end

with "System.rml"
with "Lookup.rml"
with "Interactive.rml"
with "Util.rml"
with "Parser.rml"
with "Print.rml"
with "Env.rml"
with "Dump.rml"

(** relation: load_class
 ** This relation takes a 'Path' and the $MODELICAPATH as a string
 ** and tries to load the class from the path.
 ** If the classname is qualified, the complete package is loaded. 
 ** E.g. load_class(Modelica.SIunits.Voltage) -> whole Modelica package loaded.
 **)
relation load_class: (Absyn.Path, string) => (Absyn.Program) =

	(* Simple names: Just load the file if it can be found in $MODELICAPATH *)
  rule System.group_delimiter => gd &	
	System.strtok(mp,gd) => mps &
	load_class_from_mps(classname,mps) => p
	-------------------------------------
	load_class(Absyn.IDENT(classname),mp) => p

	(* Qualified names: First check if it is defined in a file pack.mo *)
  rule	System.group_delimiter => gd &	
	System.strtok(mp,gd) => mps &
	load_class_from_mps(pack,mps) => p
	-------------------------------------
	load_class(Absyn.QUALIFIED(pack,rest),mp) => p

	(* Qualified names: Else, load the complete package and then check that *)
	(* the package contains the file *) 
  rule	System.group_delimiter => gd &	
	System.strtok(mp,gd) => mps &
	load_complete_package_from_mps(pack,mps,Absyn.TOP,Absyn.PROGRAM([],Absyn.TOP)) => p &
	Interactive.get_pathed_class_in_program(path,p)=> _
	-------------------------------------
	load_class(path as Absyn.QUALIFIED(pack,rest),mp) => p

  rule	print "load_class failed\n"
	-------------------
	load_class(_,_) => fail
end

(** relation: exist_regular_file
 **
 ** Checks if a file exists
 **)
relation exist_regular_file: (string) => () =

  rule	System.regular_file_exist filename => 0 
	----------------------------
	exist_regular_file(filename) 
end

(** relation: exist_directory_file
 **
 ** Checks if a directory exist
 **)
relation exist_directory_file: (string) => () =

  rule	System.directory_exist filename => 0 
	----------------------------
	exist_directory_file(filename) 
end


(** relation: load_class_from_mps
 **
 ** Loads a class or classes from a set of paths in modelicapath
 **)
relation load_class_from_mps: (Absyn.Ident, string list) => Absyn.Program =
	
  rule	load_class_from_mp(class,mp) => p
	----------------------------------
	load_class_from_mps(class,mp::mps) => p

  rule	load_class_from_mps(class,mps) => p
	----------------------------------
	load_class_from_mps(class,_::mps) => p

end

(** relation: load_class_from_mp
 ** 
 ** This relation loads a modelica class "className" from the file path 
 ** "<mp>/className.mo" or it loads complete package from 
 ** "<mp>/className/package.mo"
 **)
relation load_class_from_mp: (Absyn.Ident, string) => Absyn.Program =
	
  rule	System.path_delimiter => pd &
	string_append(class,".mo") => classfile &
	Util.string_append_list([mp,pd,classfile])=> classfile' &
	exist_regular_file(classfile') &
	print "parsing " & print classfile' & print "\n" &
	Parser.parse(classfile') => p
	---------------------------
	load_class_from_mp(class,mp) => p

  rule	System.path_delimiter => pd &
	Util.string_append_list([mp,pd,class]) => dirfile &
	Util.string_append_list([dirfile, pd, "package.mo"]) => packfile &
	exist_directory_file dirfile &
	exist_regular_file packfile &
	Print.print_buf "Class is package stored in a directory, loading whole package(incl. subdir)\n" &
	load_complete_package_from_mp(class,mp,Absyn.TOP,
				      Absyn.PROGRAM([],Absyn.TOP)) => p 
	--------------------------------------
	load_class_from_mp(class,mp) => p
	
  rule	print "load_class_from_mp failed\n" 
	--------------------
	load_class_from_mp(_,_) => fail
end

(** relation: load_complete_package_from_mps
 **
 ** Loads a whole package from the ModelicaPaths defined in MODELICAPATH
 **)
relation load_complete_package_from_mps: (Absyn.Ident, string list, Absyn.Within, Absyn.Program) => Absyn.Program =

  rule	load_complete_package_from_mp(pack,mp,within ,oldp) => p
	-------------------------
	load_complete_package_from_mps(pack,mp::_,within,oldp) => p

  rule	load_complete_package_from_mps(pack,mps,within ,oldp) => p
	-------------------------
	load_complete_package_from_mps(pack,_::mps,within,oldp) => p

end

(** relation: load_complete_package_from_mp
 ** 
 ** Loads a whole package from the ModelicaPaths defined in MODELICAPATH
 **)
relation load_complete_package_from_mp: (Absyn.Ident, string, Absyn.Within, Absyn.Program) => Absyn.Program =
	
  rule System.path_delimiter => pd &	
	Util.string_append_list([mp,pd,pack]) => mp' &
	Util.string_append_list([mp', pd, "package.mo"]) => packagefile &
	exist_regular_file(packagefile) &
	print "parsing " & print packagefile & print "\n" &
	Parser.parse(packagefile) => Absyn.PROGRAM(p1,w1) &
	Print.print_buf("loading ") & Print.print_buf(packagefile) & Print.print_buf "\n" &
	Interactive.update_program(Absyn.PROGRAM(p1,w1),Absyn.PROGRAM(oldc,Absyn.TOP)) => p1' &
	System.sub_directories(mp') => subdirs &
	Util.string_delimit_list(subdirs, ", ") => subdirstr &
	print "subdirs =" & print subdirstr & print "\n" &
	load_complete_subdirs(subdirs,pack,mp',within,p1') => p2 &
	load_complete_subfiles(pack,mp',within,p2) => p 
	------------------------------
	load_complete_package_from_mp(pack,mp,within as Absyn.TOP,Absyn.PROGRAM(oldc,_)) => p

  rule	System.path_delimiter => pd &
	Util.string_append_list([mp,pd,pack]) => mp' &
	Util.string_append_list([mp',pd, "package.mo"]) => packagefile &
	exist_regular_file(packagefile) &
	print "parsing " & print packagefile & print "\n" &
	Parser.parse(packagefile) => Absyn.PROGRAM(p1,w1) &
	Print.print_buf("loading ") & Print.print_buf(packagefile) & Print.print_buf "\n" &
	Interactive.update_program(Absyn.PROGRAM(p1,Absyn.WITHIN(wpath)),Absyn.PROGRAM(oldc,Absyn.TOP)) => p1' &
	System.sub_directories(mp') => subdirs &
	Util.string_delimit_list(subdirs, ", ") => subdirstr &
	print "subdirs =" & print subdirstr & print "\n" &
	load_complete_subdirs(subdirs,pack,mp',within,p1') => p2 &
	Absyn.join_paths(wpath,Absyn.IDENT(pack))=> wpath' &
	load_complete_subfiles(pack,mp',within,p2) => p
	------------------------------
	load_complete_package_from_mp(pack,mp,within as Absyn.WITHIN(wpath),Absyn.PROGRAM(oldc,_)) => p

  axiom	load_complete_package_from_mp(_,_,_,_) => fail
end

(** relation: load_complete_subdirs
 ** 
 ** Loads all classes present in a subdirectory
 **)
relation load_complete_subdirs: (string list, Absyn.Ident, string, 
				 Absyn.Within, Absyn.Program) 
	  => Absyn.Program =
	  
  axiom	load_complete_subdirs([],_,_,w,Absyn.PROGRAM(oldcls,w2)) => Absyn.PROGRAM(oldcls,w2)
	
  rule	Absyn.join_paths(pack2,Absyn.IDENT(pack1)) => pack' &
	load_complete_package_from_mp(pack,mp,Absyn.WITHIN(pack'),oldp) => p &
	load_complete_subdirs(packs,pack1,mp,within,p) => p' 
	---------------------------------------------
 	load_complete_subdirs(pack::packs,pack1,mp,within as Absyn.WITHIN(pack2),oldp) => p'
 
  rule	Absyn.join_paths(Absyn.IDENT(pack1),Absyn.IDENT(pack)) => pack' &
	load_complete_package_from_mp(pack,mp,Absyn.WITHIN(Absyn.IDENT(pack1)),oldp) => p &
	load_complete_subdirs(packs,pack1,mp,within,p) => p' 
	---------------------------------------------
 	load_complete_subdirs(pack::packs,pack1,mp,within as Absyn.TOP,oldp) => p'

  rule	load_complete_subdirs(packs,pack1,mp,within,p) => p' 
	---------------------------------------------
 	load_complete_subdirs(pack::packs,pack1,mp,within,p) => p'


  rule	print "load_complete_subdirs failed\n"
	----------------
	load_complete_subdirs(_,_,_,_,_) => fail
end

(** relation: load_complete_subfiles
 ** 
 ** This relation loads all modelicafiles (.mo) from a subdir package.
 **)
relation load_complete_subfiles: (Absyn.Ident, string, Absyn.Within, Absyn.Program) 
	  => Absyn.Program =

  rule	(* Here *.mo files in same directory as package.mo should be loaded as sub-packages*)
	System.mo_files(mp)=> mofiles &
	Absyn.join_paths(within,Absyn.IDENT(pack)) => within' &
	load_subpackage_files(mofiles,mp,Absyn.WITHIN(within'),oldp) => p 
	------------------------------------------
	load_complete_subfiles(pack,mp,Absyn.WITHIN(within),oldp) => p

  rule	(* Here *.mo files in same directory as package.mo should be loaded as sub-packages*)
	System.mo_files(mp)=> mofiles &
	load_subpackage_files(mofiles,mp,Absyn.WITHIN(Absyn.IDENT(pack)),oldp) => p
	------------------------------------------
	load_complete_subfiles(pack,mp,Absyn.TOP,oldp) => p

  rule	print "load_complete_subfiles failed\n"
	------------------------------------------
	load_complete_subfiles(_,_,_,_) => fail

end

(** relation: load_subpackage_files
 **
 ** Loads all classes from a subpackage
 **)
relation load_subpackage_files: (string list, string, Absyn.Within, Absyn.Program) 
	  => Absyn.Program =

  axiom	load_subpackage_files([],mp,within,Absyn.PROGRAM(cls,w)) => Absyn.PROGRAM(cls,w)

  rule	System.path_delimiter => pd &
	Util.string_append_list([mp,pd,f]) => f' &
	print "parsing " & print f' & print "\n" &
	Parser.parse(f') => Absyn.PROGRAM(cls,_) &
	Print.print_buf("loading ") & Print.print_buf(f') & Print.print_buf "\n" &
	Interactive.update_program(Absyn.PROGRAM(cls,within),Absyn.PROGRAM(oldc,Absyn.TOP))=> p' &
	load_subpackage_files(fs, mp, within, p') => p''
	-------------------------------
	load_subpackage_files(f::fs,mp,within,Absyn.PROGRAM(oldc,_)) => p''

  rule	print "load_subpackage_files failed\n"
	---------------------
	load_subpackage_files(_,_,_,_) => fail
end


