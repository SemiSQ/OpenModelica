(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Codegen.rml
 ** module:      Codegen
 ** description: Generate C code from DAE (Flat Modelica) for Modelica 
 ** functions. This code is compiled and linked to the simulation code or when
 ** functions are called from the interactive environment.
 **
 ** Input: DAE
 ** Output: -   (generated code through Print module)
 ** Uses: Print Inst ModUtil Util
 **
 **
 ** RCS: $Id$
 **
 **)

(* ------------------------------------------------------------------------- *)

module Codegen :
						      
    with "DAE.rml"
    with "Print.rml"
							  
							  
    type Ident = string
							  
    type ReturnType          = string
    type FunctionName        = string
    type ArgumentDeclaration = string
    type VariableDeclaration = string
    type InitStatement       = string
    type Statement           = string
    type CleanupStatement    = string
    type ReturnTypeStruct    = string list
							  
    datatype CFunction = CFUNCTION of 
							  ReturnType *
							  FunctionName * 
							  ReturnTypeStruct *
							  (ArgumentDeclaration list) *
							  (VariableDeclaration list) *
							  (InitStatement       list) *
							  (Statement           list) *
							  (CleanupStatement    list)
		     | CEXTFUNCTION of
							  ReturnType *
							  FunctionName *
							  ReturnTypeStruct *
							  ArgumentDeclaration list							  
  relation generate_functions : DAE.DAElist => ()
  relation generate_function_bodies : DAE.DAElist => ()
  relation generate_function_headers : DAE.DAElist => ()
  relation generate_algorithm: (DAE.Element, int)
	  => (CFunction, int) 
	  
end


with "Dump.rml"
with "Debug.rml"

with "Absyn.rml"
with "Algorithm.rml"
with "ClassInf.rml"
with "Exp.rml"
with "ModUtil.rml"
with "Types.rml"
with "Util.rml"
with "Inst.rml"

(* ------------------------------------------------------------------------- *)


val c_empty_function = CFUNCTION("","",[],[],[],[],[],[])

(** relation: c_make_function
 **
 ** Helper relation to generate_function. Creates a C-function from a 
 ** ReturnType, FunctionName, ReturnTypeStruct and a list of 
 ** ArgumentDeclaration's
 **)

relation c_make_function : (ReturnType,
			    FunctionName,
			    ReturnTypeStruct,
			    ArgumentDeclaration list)
	  => CFunction =

  axiom	c_make_function (rt,fn,rts,ads) => CFUNCTION(rt,fn,rts,ads,[],[],[],[])

end

(** relation: c_make_function_decl
 **
 ** Helper relation to generate_function. Generates a C function declaration.
 ** I.e. without body of the function.
**)

relation c_make_function_decl: (ReturnType, 
				FunctionName, 
				ReturnTypeStruct, 
				ArgumentDeclaration list) => CFunction =

  axiom	c_make_function_decl(rt,fn,rts,ads) => CEXTFUNCTION(rt,fn,rts,ads)

end

(** relation: c_add_variables
 ** 
 ** Add local variable declarations  to a CFunction.
 **)
relation c_add_variables : (CFunction, VariableDeclaration list) 
	  => CFunction =

  rule	list_append(vd,nvd) => vd'
	--------------------------
	c_add_variables (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nvd)
			 => CFUNCTION(rt,fn,rts,ads,vd',is,st,cl)
end

(** relation: c_add_inits
 ** 
 ** Add initialization statements to a CFunction. They will be ommitted before
 ** the actual code of the function but after the local variable declarations.
 **)

relation c_add_inits : (CFunction, InitStatement list) => CFunction =

  rule	list_append(is,nis) => is'
	--------------------------
	c_add_inits (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nis)
			 => CFUNCTION(rt,fn,rts,ads,vd,is',st,cl)

end

(** relation: c_add_statements
 ** 
 ** Adds statements to a CFunction.
 **)
relation c_add_statements : (CFunction, Statement list) => CFunction =

  rule	list_append(st,nst) => st'
	--------------------------
	c_add_statements (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nst)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st',cl)

end

(** relation: c_add_cleanups
 ** 
 ** Add "cleanup" statements to a CFunction. They will be ommited last, before
 ** the return statement of the function.
 **)

relation c_add_cleanups : (CFunction, CleanupStatement list) => CFunction =

  rule	list_append(cl,ncl) => cl'
	--------------------------
	c_add_cleanups (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),ncl)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st,cl')

end


(** relation: c_merge_fns
 **
 ** Takes a list of functions and merges them together.
 ** The function name, returntype and argument lists are taken from the 
 ** first CFunction in the list.
**)

relation c_merge_fns : CFunction list => CFunction =
	
  axiom	c_merge_fns [] => c_empty_function

  rule	c_merge_fns r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	c_merge_fns cfn1::r => cfn

end

(** relation: c_merge_fn
 **
 ** Merges two functions into one. The function name, returntype and 
 ** argument lists are taken from the first CFunction.
 **)

relation c_merge_fn : (CFunction, CFunction) => CFunction =

  rule	list_append(vd1,vd2) => vd &
	list_append(is1,is2) => is &
	list_append(st1,st2) => st &
	list_append(cl1,cl2) => cl 	
	-----------------------------
	c_merge_fn (CFUNCTION(rt,fn,rts,ad,vd1,is1,st1,cl1),
		    CFUNCTION(_ , _, _ , _,vd2,is2,st2,cl2)) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)
			 
end

(** relation: c_move_statements_to_inits
 **
 ** Moves all statements of the body to initialization statements.
 **)

relation c_move_statements_to_inits : CFunction => CFunction =

  rule	list_append(is,st) => is'
	---------------------------
	c_move_statements_to_inits CFUNCTION(rt,fn,rts,ad,vd,is,st,cl) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is',[],cl)
end

(** relation: c_print_functions
 **
 ** Prints CFunction list to Print buffer.
 **)
 
 relation c_print_functions : CFunction list => () =
 
 axiom	c_print_functions []
 
 rule	c_print_function(f) &
	c_print_functions(r)
	---------------------
	c_print_functions f::r
end

(** relation: c_print_function
 **
 ** Prints a CFunction to Print buffer.
 **)
 
relation c_print_function : CFunction => () =
 
 rule	Util.string_delimit_list(ad,", ") => args_str &
	Util.string_append_list [rt," ",fn,"(",args_str,") {"] => stmt_str &
	
	let i0 = 0 &
(*	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" & *)
	c_print_indented (stmt_str,i0) => i2 & Print.print_buf "\n" &
	c_print_indented_list (vd,i2)  => i3 & Print.print_buf "\n" &
	c_print_indented_list (is,i3)  => i4 & Print.print_buf "\n" &
	c_print_indented_list (st,i4)  => i5 & Print.print_buf "\n" &
	c_print_indented_list (cl,i5)  => i6 & Print.print_buf "\n" &
	c_print_indented      ("}",i6) => i7 & Print.print_buf "\n"
	-----------------------------------------------------------
	c_print_function CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)

  rule	Util.string_delimit_list(ads,", ") => args_str &
	Util.string_append_list ["extern ", rt," ",fn,"(",args_str,");\n"] => stmt_str &
	let i0 = 0 &
(*	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" & *)
	c_print_indented (stmt_str,i0) => i2 & Print.print_buf "\n"
	-----------------------------------------------------------
	c_print_function CEXTFUNCTION(rt,fn,rts,ads)

  rule	Print.print_buf "# c_print_function_failed\n"
	-----------
	c_print_function _
end

(** relation: c_print_function_headers
 **
 ** Prints the function declaration, i.e. the header information
 ** of a CFunction list to the Print buffer.
 **)

relation c_print_function_headers : CFunction list => () =

  axiom	c_print_function_headers []

  rule	c_print_function_header(f) &
	c_print_function_headers(r)
	---------------------
	c_print_function_headers f::r
end

(** relation: c_print_function_headers
 **
 ** Prints the function declaration, i.e. the header information
 ** of a CFunction to the Print buffer.
 **)
 
 relation c_print_function_header : CFunction => () =
 
 rule	Util.string_delimit_list(ad,", ") => args_str &
	Util.string_append_list [rt," ",fn,"(",args_str,");"] => stmt_str &
	
	let i0 = 0 &
	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" &
	c_print_indented (stmt_str,i1) => i2 & Print.print_buf "\n"
	-----------------------------------------------------------
	c_print_function_header CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)

  rule	Util.string_delimit_list(ads,", ") => args_str &
	Util.string_append_list ["extern ", rt," ",fn,"(",args_str,");\n"] => stmt_str &
	let i0 = 0 &
	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" &
	c_print_indented (stmt_str,i1) => i2 & Print.print_buf "\n"
	---------------------------------------------------
	c_print_function_header CEXTFUNCTION(rt,fn,rts,ads)

  rule	Print.print_buf "# c_print_function_header failed\n"
	-----------
	c_print_function_header _
end

(** relation: c_print_indented_list
 **
 ** Helper relation. prints a list of strings indented with a number
 ** of indentation levels.
 **)
 
 relation c_print_indented_list : (string list, 
				   int) (* indentation level *)
	  => int = (* updated indentation level*)
	
  axiom c_print_indented_list ([],i) => i

  rule	c_print_indented(f,i) => i' & Print.print_buf "\n" &
	 c_print_indented_list(r,i') => i''
	 -----------------
	 c_print_indented_list(f::r,i) => i''
	 
end

(** relation: c_print_indented
 **
 ** Prints a string adding an indentation level. If the string
 ** contains C-code that opens or closes a  indentation level, 
 ** the indentation level is updated accordingly.
 **)

relation c_print_indented : (string, int) => int =

  rule	string_list str => strl &
	c_next_level(strl,i) => i' &
	c_this_level(strl,i) => it &
	c_print_indent it &
	Print.print_buf str 
	-----------
	c_print_indented (str,i) => i'
end 

(** relation c_next_level
 **
 ** Helper relation to c_print_indented. 
 **)

relation c_next_level : (char list, int) => int =

  axiom	c_next_level ([],i) => i

  rule	list_string [f] => "{" &
	int_add(i,2) => i' &
	c_next_level(r,i') => i''
	-----
	c_next_level (f::r,i) => i'' (* { *)

  rule	list_string [f] => "}" &
	int_sub(i,2) => i' &
	c_next_level(r,i') => i''
	-----
	c_next_level (f::r,i) => i'' (* } *)

  rule	c_next_level(r,i) => i'
	-----
	c_next_level (_::r,i) => i'

end

(** relation c_next_level
 **
 ** Helper relation to c_print_indented.
 **)

relation c_this_level : (char list, int) => int =


  rule	list_string [f] => "#"
	----
	c_this_level(f::_,_) => 0

rule	list_string [f] => "}" &
	int_sub(i,2) => i'
	----
	c_this_level(f::_,i) => i'

  axiom	c_this_level(_,i) => i

end

(** relation c_print_indent
 **
 ** Helper relation to c_print_indented. 
 **)
relation c_print_indent : int => () =

  axiom c_print_indent 0

  rule	Print.print_buf " " &
	int_sub(i,1) => i' &
	c_print_indent i'
	----------------
	c_print_indent i

end

(** relation: generate_functions
 **
 ** Generates code for all functions in a DAE and prints on
 ** Print buffer.
 **)

relation generate_functions : DAE.DAElist => () =

  rule	generate_function_headers dae &
	generate_function_bodies dae
	------------------------------
	generate_functions (dae as DAE.DAE(elist))

  rule	Print.print_buf "# generate_functions failed\n"
	--------------------------------------
	generate_functions _  => fail

end

(** relation: generate_function_bodies
 **
 ** Generates the function bodies of a DAE list.
 **)

relation generate_function_bodies : DAE.DAElist => () =

  rule	Debug.fprintln ("cgtr", "generate_function_bodies") &
	generate_functions_elist elist => cfns &
	Print.print_buf "\n/* body part */\n" &
	c_print_functions cfns &
	Print.print_buf "\n"
	------------------------------
	generate_function_bodies DAE.DAE(elist)

  rule	Print.print_buf "# generate_function_bodies failed\n"
	--------------------------------------
	generate_function_bodies _  => fail

end

(** relation: generate_function_headers
 **
 ** Generates the headers of the functions in a DAE list.
 **)

relation generate_function_headers : DAE.DAElist => () =

  rule	Debug.fprintln ("cgtr", "generate_function_headers") &
	generate_functions_elist elist => cfns &
	Print.print_buf "/* header part */\n" &
	Print.print_buf "#include \"modelica.h\"\n" & (* FIXME: needed? *)
	c_print_function_headers cfns &
	Print.print_buf "\n"
	------------------------------
	generate_function_headers DAE.DAE(elist)

  rule	Print.print_buf "# generate_function_headers failed\n"
	--------------------------------------
	generate_function_headers _  => fail

end


(** relation: generate_functions_elist
 **
 ** Helper relation. Generates code from the Elements of a DAE.
**)

relation generate_functions_elist : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") &
	Debug.fprintln ("cgtrdumpdae", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae", DAE.dump2, DAE.DAE(els)) &
	Util.list_matching(els,DAE.is_function) => fns &
	generate_functions_elist2 fns => cfns
	----------------------------
	generate_functions_elist els => cfns
	
end

(** relation: generate_functions_elist2
 ** 
 ** Helper relation to generate_functions_elist.
 **)

relation generate_functions_elist2 : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist2") 
	----------------------------------------------------
	generate_functions_elist2 [] => []

  rule	Debug.fprintln ("cgtr", "generate_functions_elist2") &
	generate_function f => cfns1 &
	generate_functions_elist2 rest => cfns2 &
	list_append(cfns1,cfns2) => cfns
	----------------------------
	generate_functions_elist2 f :: rest => cfns
	
end

(** relation: generate_function
 **
 ** Generates code for a DAE.FUNCTION. This results in two CFunctions, 
 **  one declaration and one definition. There are two rules of this relation, 
 ** one for normal Modelica functions and one for external Modelica functions.
 **)

relation generate_function : DAE.Element => CFunction list =

	(* Modelica functions *)
  rule	generate_function_name fpath => fn_name_str &
	string_append("_",fn_name_str) => fn_name_str &
	Debug.fprintl ("cgtr", ["generating function ", fn_name_str, "\n"]) &

	Debug.fprintln ("cgtrdumpdae3", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae3", DAE.dump2, DAE.DAE(dae)) &


	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath           => retstr &
	Util.list_map(args, generate_function_arg)  => arg_strs &

	c_make_function(retstr, fn_name_str, struct_strs,arg_strs)=> head_cfn &

	generate_function_body(fpath, dae, restype) => body_cfn &

	c_merge_fn(head_cfn,body_cfn) => cfn &
	
	generate_read_call_write(fn_name_str,outvars,retstr,invars) => rcw_fn
	---------------------------
	generate_function DAE.FUNCTION(fpath, 
				       DAE.DAE(dae), 
				       (Types.T_FUNCTION(args,restype),_)) 
	  => [cfn,rcw_fn]

	  (* External functions *)
  rule	generate_function_name fpath => fn_name_str &
	string_append("_",fn_name_str) => fn_name_str &
	Debug.fprintl ("cgtr", ["generating external function ", fn_name_str, "\n"]) &
	let  DAE.EXTERNALDECL(extfnname,extargs,extretarg,lang,ann) = extdecl &

	Debug.fprintln ("cgtrdumpdae1", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae1", DAE.dump2, DAE.DAE(orgdae)) &
	Inst.init_vars_modelica_output orgdae => dae &
	Debug.fprintln ("cgtrdumpdae2", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae2", DAE.dump2, DAE.DAE(dae)) &

	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	DAE.get_bidir_vars dae => bivars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath => retstructtype &
	generate_ext_return_type (extretarg) => retstr &
	generate_ext_function_name (extfnname, lang) => extfnname' &
	generate_ext_function_args (extargs, lang) => arg_strs &
        c_make_function_decl(retstr,extfnname',struct_strs,arg_strs) => func_decl &
	generate_read_call_write_external(fn_name_str,outvars,retstructtype,invars,extdecl,bivars) => rcw_fn &
	generate_external_wrapper_call(fn_name_str,outvars,retstructtype,invars,extdecl,bivars,tp) => ext_decl
	-----------------------------------------------------------------------
	generate_function DAE.EXTFUNCTION(fpath, 
				       DAE.DAE(orgdae), 
				       tp as (Types.T_FUNCTION(args,restype),_),
					  extdecl) 
	  => [func_decl,rcw_fn,ext_decl]

  rule	generate_functions_elist daelist => cfns
	----------------------
	generate_function DAE.COMP(n, DAE.DAE(daelist)) => cfns

  rule	Print.print_buf "# generate_function failed\n" &
	DAE.dump2 DAE.DAE([comp]) 
	------------------------------------
	generate_function comp => fail	
end


(** relation: generate_ext_function_name
 **
 ** Generates the function name for external functions. 
 ** Fortran functions have the underscore '_' suffix.
 **)

relation generate_ext_function_name : (string, string) => string =

  axiom	generate_ext_function_name (name, "C") => name

  rule	string_append (name, "_") => name'
	----------------------------------
	generate_ext_function_name (name, "FORTRAN 77") => name'

  rule	Print.print_error_buf "# Unknown language in external declaration\n"
	---------------------------------------------------------
	generate_ext_function_name (_,_) => fail

end	

(** relation generate_results_struct
 **
 ** All Modelica functions translates to a C function returning all 
 ** Modelica ouput parameters in a struct. This relation generates that struct.
**)

relation generate_result_struct : (DAE.Element list, Absyn.Path) 
	  => string list =

  rule	generate_return_type fpath => ptname &
	generate_return_decls outvars => (var_strs,var_names) &
	generate_return_defs (ptname,var_names,1) => defs &
	indent_strings var_strs => var_strs' &
	Util.string_append_list(["typedef struct ",ptname,"_s"]) => first_row &
	Util.string_append_list(["} ",ptname,";"]) => last_row &
	Util.list_flatten([defs,[first_row,"{"],var_strs',[last_row]]) => strs
	-----------------------------------------
	generate_result_struct (outvars, fpath) => strs

end
(** relation: generate_return_defs
 **
 ** Helper relation to generate_result_struct. Creates defines used
 ** in the declaration of the return struct.
 **)

relation generate_return_defs : (string, string list, int) => string list =

  axiom generate_return_defs (_,[],_) => []
	
  rule	int_string i => i_str &
	Util.string_append_list(["#define ",tn,"_",i_str," ",f]) => f' &
	int_add(i,1) => i' &
	generate_return_defs (tn,r,i') => r'
	----
	generate_return_defs (tn,f::r,i) => f'::r'

end

(** relation: generate_return_decls
 ** 
 ** Helper relation to generate_result_struct. 
**)

relation generate_return_decls : DAE.Element list => (string list, 
						      string list) =

  axiom	generate_return_decls [] => ([],[])

  rule	generate_return_decl first => ("",_) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (rs,rd)

  rule	generate_return_decl first => (fs,fd) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (fs::rs,fd::rd)

end

(** relation: tmpprintinit
 **
 ** Helper relation to generate_return_decl.
 **)

relation tmpprintinit : Exp.Exp option => string =

  axiom tmpprintinit NONE => ""

  rule	Exp.print_exp_str e => str &
	Util.string_append_list ([" /* ", str, " */"]) => str1
	--------------------------
	tmpprintinit SOME(e) => str1

end

(** relation: generate_return_decl
 **
 ** Helper relation to generate_return_decls
 **)

relation generate_return_decl: DAE.Element => (string, string) =

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([typ_str," ",id_str,";",
				 " /* [",dims_str,"] */"]) 
	  => decl_str' &
	tmpprintinit initopt => expstr &
	string_append(decl_str', expstr) => decl_str
	---------------------------------------------------
	generate_return_decl (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, 
					     typ, initopt, inst_dims,start,
					     flow,class,dae_var_attr,comment)) 
	  => (decl_str,id_str)

  axiom	generate_return_decl (_) => ("","")

end

(** relation: is_array
 ** 
 ** Returns true if variable is part of an array.
 **)

relation is_array : DAE.Element => bool =
	
(*
  axiom	is_array DAE.VAR(cr,vk,vd,ty,_,[],st,fl,cl) => false
  axiom	is_array DAE.VAR(cr,vk,vd,ty,_,_::_,st,fl,cl) => true
*)

  rule	Debug.fcall("isarrdb", DAE.dump2, DAE.DAE[el])
	-----------------------------------
	is_array (el as DAE.VAR(cr,vk,vd,ty,_,[],st,fl,cl,dae_var_attr,comment)) => false

  rule	Debug.fcall("isarrdb", DAE.dump2, DAE.DAE[el])
	-----------------------------------
	is_array (el as DAE.VAR(cr,vk,vd,ty,_,_::_,st,fl,cl,dae_var_attr,comment)) => true

  rule	Print.print_buf "#-- is_array failed\n" &
	Print.print_buf "#-- Not a var?" &
	DAE.dump2 DAE.DAE([el])
	--------------------------
	is_array el => fail

end

(** relation: dae_exp_type
 ** 
 ** Translates a DAE.Type to an Exp.Type.
 **)

relation dae_exp_type : DAE.Type => Exp.Type =

  axiom	dae_exp_type DAE.INT    => Exp.INT
  axiom	dae_exp_type DAE.REAL   => Exp.REAL
  axiom	dae_exp_type DAE.STRING => Exp.STRING
  axiom	dae_exp_type DAE.BOOL   => Exp.BOOL
  axiom	dae_exp_type DAE.ENUM   => Exp.ENUM
  axiom	dae_exp_type _		=> Exp.OTHER

end

(** relation: dae_type_str
 ** 
 ** Convert a DAE.Type to a string. The boolean indicates whether the type
 ** is an array or not.
 **)
relation dae_type_str : (DAE.Type, bool (* array*)) 
	  => string =

  rule	dae_exp_type t => t' &
	exp_type_str (t',a) => str
	--------------------------
	dae_type_str (t,a) => str

end

(* relation: exp_short_type_str
 **
 ** Translates and Exp.Type to a string, using a "short" typename.
 **)

relation exp_short_type_str : Exp.Type => string =

  axiom	exp_short_type_str Exp.INT    => "integer"
  axiom	exp_short_type_str Exp.REAL   => "real"
  axiom	exp_short_type_str Exp.STRING => "string"
  axiom	exp_short_type_str Exp.BOOL   => "boolean"
  axiom	exp_short_type_str Exp.OTHER  => "OTHER"
  axiom	exp_short_type_str Exp.ENUM  => "ENUM_NOT_IMPLEMENTED"

end

(* relation: exp_short_type_str
 **
 ** Translates and Exp.Type to a string.
 **)

relation exp_type_str : (Exp.Type, bool) => string =

  rule	exp_short_type_str t => tstr &
	string_append("modelica_",tstr) => str
	-----------
	exp_type_str (t, false) => str

  rule	exp_short_type_str t => tstr &
	string_append(tstr,"_array") => str
	-----------
	exp_type_str (t, true) => str

end

(** relation: generate_type
 **
 ** Generates code for a Type.
 **)

relation generate_type : Types.Type => string =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => ty_str 
	---------------------------
	generate_type((Types.T_TUPLE(tys),_)) => ty_str


  rule	Debug.fprintln ("cgtr", "generate_type") &
	Types.flatten_array_type tys => (arrayty, dims) &
	generate_array_type (arrayty, dims) => ty_str
	-----------------------------------
	generate_type (tys as (Types.T_ARRAY(_,_),_)) => ty_str


  axiom	generate_type((Types.T_INTEGER(_),_)) => "modelica_integer"
  axiom generate_type((Types.T_REAL(_),_)) => "modelica_real"
  axiom	generate_type((Types.T_STRING(_),_)) => "modelica_string"
  axiom	generate_type((Types.T_BOOL(_),_)) => "modelica_boolean"


  rule	Print.print_buf "#-- generate_type failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type ty => fail

end

(** relation: generate_type_external
 ** 
 ** Generates Code for an external type.
 **)
relation generate_type_external : Types.Type => string =

  axiom	generate_type_external((Types.T_INTEGER(_),_))  => "int"
  axiom generate_type_external((Types.T_REAL(_),_)) => "double"
  axiom	generate_type_external((Types.T_STRING(_),_)) => "const char*"
  axiom	generate_type_external((Types.T_BOOL(_),_)) => "int"

  rule	generate_type_external ty => str
	--------------------------------
	generate_type_external((Types.T_ARRAY(dim,ty),_)) => str

  rule	Print.print_buf "#-- generate_type_external failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type_external ty => fail

end

(** relation: generate_type_internal_namepart
 ** 
 ** Generates code for a Type only returning the typename of the basic types.
 **)
relation generate_type_internal_namepart : Types.Type => string =

  axiom	generate_type_internal_namepart((Types.T_INTEGER(_),_)) => "integer"
  axiom generate_type_internal_namepart((Types.T_REAL(_),_))	=> "real"
  axiom	generate_type_internal_namepart((Types.T_STRING(_),_))	=> "string"
  axiom	generate_type_internal_namepart((Types.T_BOOL(_),_))	=> "boolean"
  axiom	generate_type_internal_namepart((Types.T_ENUM,_))	=> "T_ENUM_NOT_IMPLEMENTED"

end


(** relation: generate_return_type
 **
 ** Generates the return type name of a function given the function name.
 **)

relation generate_return_type : Absyn.Path => string =

  rule	generate_function_name fpath => fstr &
	string_append (fstr, "_rettype" ) => res
	--------------------------
	generate_return_type fpath => res
end

(** relation: generate_array_type
 **
 ** Generates code for the array type given a  basic type and a list 
 ** of dimensions.
 **)

relation generate_array_type : (Types.Type, int list) => string =

  rule	array_type_string ty => str 
	--------------------------
	generate_array_type (ty, dims) => str
end

(** relation: generate_array_type
 **
 ** Generates code for an array type  as return type given a  basic 
 ** type and a list of dimensions.
 **)
relation generate_array_return_type : (Types.Type, int list) => string =

  rule	array_type_string ty => ty_str
	-------------------------------
	generate_array_return_type (ty, dims) => ty_str
end

(** relation: generate_tuple_type
 **
 ** Generate code for a tuple type.
 **)

relation generate_tuple_type : Types.Type list => string =


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_1") &
	generate_simple_type ty => str
	--------------------------------
	generate_tuple_type [ty] => str


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_2") &
	generate_simple_type ty => str &
	generate_tuple_type tys => str' &
	string_append (str, str') => str'' &
	string_append ("struct ", str'') => str'''
	----------------------------------
	generate_tuple_type (ty::tys) => str'''

end


(** relation: generate_simple_type
 ** 
 ** Helper relation to generate_tuple_type. Generates code for a non-tuple
 ** type as element of a tuple.
 **)
relation generate_simple_type : Types.Type => string =

  axiom	generate_simple_type((Types.T_INTEGER(_),_))=> "modelica_integer"
  axiom	generate_simple_type((Types.T_REAL(_),_)) => "modelica_real"
  axiom	generate_simple_type((Types.T_STRING(_),_)) => "modelica_string"
  axiom	generate_simple_type((Types.T_BOOL(_),_)) => "modelica_boolean"

  rule	string_append ("const ", n) => n' &
	string_append (n', "&") => n''
	------------------------------
	generate_simple_type((Types.T_COMPLEX (ClassInf.RECORD(n),_),_)) => n''

  rule	Types.array_element_type t => t' &
	array_type_string t' => t_str
	-----------------------
	generate_simple_type (t as (Types.T_ARRAY(_,_),_)) => t_str

  rule	Print.print_buf "#--generate_simple_type failed " &
	Types.print_type ty & 
	Print.print_buf "\n"
	--------------------------------------
	generate_simple_type ty => fail
end

(** relation: array_type_string
 **
 ** Returns the type string of an array of the basic type passed as 
 ** argument.
 **)

relation array_type_string : Types.Type => string =

  axiom	array_type_string((Types.T_INTEGER(_),_)) => "integer_array"
  axiom	array_type_string((Types.T_REAL(_),_)) => "real_array"
  axiom	array_type_string((Types.T_STRING(_),_)) => "string_array"
  axiom	array_type_string((Types.T_BOOL(_),_)) => "boolean_array"

end

(** relation: generate_function_name
 **
 ** Generates the name of a function by replacing dots with underscores.
 **)

relation generate_function_name : Absyn.Path => string =

  rule	ModUtil.path_string2 (fpath,"_") => fstr 
	----------------------------------
	generate_function_name fpath => fstr

end

(** relation: generate_ext_function_args
 ** 
 ** Generates Code for external function arguments.
 ** input string is language, e.g. "C" or "FORTRAN 77" 
 **)

relation generate_ext_function_args : (DAE.ExtArg list, string) => string list = 

  rule	Util.list_map(extargs,generate_ext_function_arg) => arg_strs
	------------------------------------------------------------
	generate_ext_function_args (extargs, "C") => arg_strs

  rule	Util.list_map(extargs,generate_ext_function_arg_f77) => arg_strs
	------------------------------------------------------------
	generate_ext_function_args (extargs, "FORTRAN 77") => arg_strs

  rule	Print.print_buf "#-- Unknown external language declaration\n" &
	Print.print_buf lang
	--------------------
	generate_ext_function_args (_,lang) => fail

end	

(** relation: generate_function_args
 **
 ** Generates code from a function argument.
 **)

relation generate_function_arg : Types.FuncArg => string =

  rule	generate_tuple_type [ty] => str &
	string_append (str, " ") => str' &
	string_append (str', name) => str''
	-----------------------------------
	generate_function_arg ((name, ty)) => str''

end

(** relation: generate_ext_arg_type
 **
 ** Helper relation to generate_ext_function_arg.
 ** Generates code for the type of an external function argument.
 **)

relation generate_ext_arg_type : (Types.Attributes, Types.Type) => string =

  rule	Types.is_array ty => false & 
	generate_type_external ty => str
	--------------------------------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.INPUT), ty) => str

  rule	Types.is_array ty => true & 
	generate_type_external ty => str &
	Util.string_append_list(["const ",str," *"]) => resstr
	----------------------------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.INPUT), ty) => resstr

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => str

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	generate_type_external ty => str
	--------------------------------------------------------
	generate_ext_arg_type (_, ty) => str

  rule	Print.print_buf "#-- generate_ext_arg_type failed\n"
	----------------------------------------------------
	generate_ext_arg_type (_,_) => fail

end	

(** relation: generate_ext_function_arg
 **
 ** Generates Code for the arguments of an external function.
 **)

relation generate_ext_function_arg : DAE.ExtArg => string =


  rule	generate_ext_arg_type (attr,ty) => tystr &
	comp_ref_cstr cref => (name,_) &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARG(cref, attr, ty) => res

  rule	generate_type_external ty => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARGEXP(exp, ty) => res
	
  rule  comp_ref_cstr cr => (name,_) &
	Exp.print_exp_str exp => e_str &
	Util.string_append_list(["size_t ",name,"_",e_str]) => res
	--------------------------------
	generate_ext_function_arg DAE.EXTARGSIZE(cr,_,_,exp) => res

  rule	Print.print_buf "#-- generate_ext_function_arg failed\n"
	----------------------------------------------------
	generate_ext_function_arg (_) => fail

end

(** relation: generate_ext_arg_type_f77
 **
 ** Helper relation to generate_ext_function_arg.
 ** Generates code for the type of an external function argument on fortran.
 ** format.
 **)

relation generate_ext_arg_type_f77 : (Types.Attributes, Types.Type) => string =

  rule	generate_type_external ty => str &
	Util.string_append_list(["const ", str, " *"]) => resstr
	----------------------------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.INPUT), ty) => resstr

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => str

  rule	generate_ext_arg_type (attr,ty) => str
	--------------------------------
	generate_ext_arg_type_f77 (attr as Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	generate_ext_arg_type (attr,ty) => str
	--------------------------------
	generate_ext_arg_type_f77 (attr as Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	generate_ext_arg_type (attr,ty) => str
	--------------------------------
	generate_ext_arg_type_f77 (attr, ty) => str

  rule	Print.print_buf "#-- generate_ext_arg_type_f77 failed\n"
	----------------------------------------------------
	generate_ext_arg_type_f77 (_,_) => fail

end	

(** relation: generate_ext_function_arg_f77
 **
 ** Generates Code for the arguments of an external function on fortran. 
 ** format.
 **)

relation generate_ext_function_arg_f77 : DAE.ExtArg => string =

  rule	generate_ext_arg_type_f77 (attr,ty) => tystr &
	comp_ref_cstr cref => (name,_) &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg_f77 DAE.EXTARG(cref, attr, ty) => res

  rule	generate_ext_function_arg arg => res
	------------------------------------
	generate_ext_function_arg_f77 (arg as DAE.EXTARGEXP (_,_)) => res

  axiom	generate_ext_function_arg_f77 DAE.EXTARGSIZE(_,_,_,_) => "int const *"

  rule	Print.print_buf "#-- generate_ext_function_arg failed\n"
	----------------------------------------------------
	generate_ext_function_arg_f77 (_) => fail

end

(** relation: generate_ext_return_type
 **
 ** Generates code for the return type of an external function.
 **)

relation generate_ext_return_type : DAE.ExtArg => string =

  rule	generate_type_external ty => res
	--------------------------------------------------
	generate_ext_return_type DAE.EXTARG(cref, attr, ty) => res

  axiom generate_ext_return_type DAE.NOEXTARG => "void"

  rule	Print.print_buf "#-- generate_ext_return_type failed\n" 
	--------------------------------------------------------
	generate_ext_return_type _ => fail
end

(** relation: generate_ext_return_type
 **
 ** Generates code for the return type of an external function.
 **)

relation generate_ext_return_type_f77 : DAE.ExtArg => string =

  rule	generate_ext_return_type arg => str
	-----------------------------------
	generate_ext_return_type_f77 arg => str

end	

(** relation: generate_function_body
 **
 ** Generates code for the body of a Modelica function.
 **)

relation generate_function_body : (Absyn.Path, (* func name *)
				   DAE.Element list, (* body elts *)
				   Types.Type) (* function type *)
	  => CFunction =
	  
  rule	Debug.fprintln ("cgtr", "generate_function_body") &
	
	let tnr = 1 &

	generate_return_type fpath => ret_type_str &
	generate_temp_decl(ret_type_str,tnr) => (ret_decl, ret_var, tnr_ret') &
	Util.string_append_list(["return ",ret_var,";"]) => ret_stmt &

	DAE.get_output_vars dae => outvars &
	generate_alloc_outvars(outvars,ret_decl,ret_var,tnr_ret')
	  => (out_fn,tnr_ret) &

	generate_temp_decl("state",tnr_ret) 
	      => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var," = get_memory_state();"]) 
	  => mem_stmt1 &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => mem_stmt2 &

	c_add_variables (out_fn, [mem_decl])  => mem_fn' &
	c_add_inits     (mem_fn',[mem_stmt1]) => mem_fn &

	generate_vars        (dae, is_var_q, tnr_mem)=> (var_fn,tnr_var) &
	generate_algorithms  (dae, tnr_var)          => (alg_fn,tnr_alg) &
	generate_result_vars (dae, ret_var, tnr_alg) => (res_var_fn,tnr_res) &
	
	c_merge_fn(mem_fn, var_fn)     => cfn' &
	c_merge_fn(cfn'  , alg_fn)     => cfn'' &
	c_merge_fn(cfn'' , res_var_fn) => cfn''' &

	c_add_cleanups(cfn''',[mem_stmt2,ret_stmt]) => cfn
	--------------
	generate_function_body (fpath, dae, restype) => cfn

end

(** relation: generate_alloc_outvars
 **
 ** Generates code for the allocation of output parameters of the function.
 **)

relation generate_alloc_outvars : (DAE.Element list, string, string, int) 
	  => (CFunction,int) =

  axiom	generate_alloc_outvars([],"",rv,tnr) => (c_empty_function,tnr)

  rule	c_add_variables(c_empty_function,[rd]) => cfn
	---------------------------------------------
	generate_alloc_outvars([],rd,rv,tnr) => (cfn,tnr)

  rule	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars(r,rd,rv,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars ((var as DAE.VAR(cr,vk,vd,t,e,id,start,flow,class,dae_var_attr,comment))::r,
				rd,rv,tnr)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars(r,rd,rv,tnr) => (cfn2,tnr2)
	--------------------------------------------------
	generate_alloc_outvars (_::r,rd,rv,tnr) => (cfn2,tnr2)

end

(** relation: generate_alloc_outvar
 **
 ** Helper relation to generate_alloc_outvars.
 **)
	
relation generate_alloc_outvar : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	Util.string_append_list([prefix,".",cref_str1]) => cref_str2 &
	Util.is_empty_string prefix => emptypre &
	Util.if (emptypre, cref_str1, cref_str2) => cref_str &
	generate_size_subscripts(cref_str,inst_dims,tnr) => (cfn1,dim_strs,tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	c_add_inits(cfn1',[alloc_str]) => cfn' &
	Util.if (is_a,cfn',cfn1') => cfn
	--------------------------------
	generate_alloc_outvar(var as DAE.VAR(id, vk, vd, typ, e, 
					     inst_dims,start,flow,class,dae_var_attr,comment),
			      prefix,
			      tnr) 
	  => (cfn,tnr1)

  rule	not DAE.is_var e
	----------------
	generate_alloc_outvar (e,_,tnr) => (c_empty_function,tnr)

end

(** relation: generate_alloc_outvar_ext
 **
 ** Helper relation to generate_alloc_outvars, for external functions.
 **)

relation generate_alloc_outvars_ext : (DAE.Element list, string,int, DAE.ExternalDecl) 
	  => (CFunction,int) =

	  
  axiom	generate_alloc_outvars_ext([],rv,tnr,extdecl) => (c_empty_function,tnr)


  rule	let DAE.EXTERNALDECL(_,_,_,"C",_) = extdecl &
	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars_ext(r,rv,tnr1,extdecl) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars_ext ((var as DAE.VAR(cr,vk,vd,t,e,
						    id,start,flow,class,dae_var_attr,comment))::r,
				rv,tnr,extdecl)
	  => (cfn,tnr2)

  rule	let DAE.EXTERNALDECL(_,_,_,"FORTRAN 77",_) = extdecl &
	generate_alloc_outvar_f77(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars_ext(r,rv,tnr1,extdecl) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars_ext ((var as DAE.VAR(cr,vk,vd,t,e,
						    id,start,flow,class,dae_var_attr,comment))::r,
				rv,tnr,extdecl)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars_ext(r,rv,tnr,extdecl) => (cfn2,tnr2)
	------------------------------------------------------
	generate_alloc_outvars_ext (_::r,rv,tnr,extdecl) => (cfn2,tnr2)

end

(** relation: generate_alloc_outvar_f77
 **
 ** Helper relation to generate_alloc_outvars, for fortran code.
 **)
relation generate_alloc_outvar_f77 : (DAE.Element,string,int) => (CFunction,int) =


  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	Util.string_equal (prefix, "") => emptypre &
	comp_ref_cstr id => (cref_str1,_) &
	Util.string_append_list ([prefix,".",cref_str1]) => cref_str2 &
	Util.if (emptypre, cref_str1, cref_str2) => cref_str &
(*	list_reverse inst_dims => inst_dims' & *)
	generate_size_subscripts(cref_str, inst_dims,tnr) => (cfn1,dim_strs,tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &

	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	c_add_inits(cfn1',[alloc_str]) => cfn' &
	Util.if (is_a,cfn',cfn1') => cfn
	--------------------------------
	generate_alloc_outvar_f77(var as DAE.VAR(id, vk, vd, typ, e, 
						 inst_dims,start,flow,class,dae_var_attr,comment),
				  prefix,
				  tnr) 
	  => (cfn,tnr1)

  rule	not DAE.is_var e
	-------------
	generate_alloc_outvar_f77 (e,_,tnr) => (c_empty_function,tnr)

end

(** relation: generate_size_subscripts
 **
 ** Generates code for calculating the subscripts of a variable.
 **)

relation generate_size_subscripts : (string, Exp.Subscript list,int)
	  => (CFunction,string list,int) =

  axiom	generate_size_subscripts (_,[],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (e,tnr) => (cfn1,var1,tnr1) &
	generate_size_subscripts (id, r, tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_size_subscripts (id, Exp.INDEX(e)::r, tnr)
	  => (cfn, var1::vars2, tnr2)

  rule	Print.print_buf "# generate_size_subscripts failed\n" & 
	Util.string_append_list ([" - ", id, "["]) => s &
	Print.print_buf s &
	Dump.print_list(subs,Exp.print_subscript,", ") & Print.print_buf "]\n"
	----------------------------------------------------------------------
	generate_size_subscripts(id,subs,_) => fail

end

(** relation: generate_alloc_array_f77
 **
 ** Generates code for allocating an array in fortran.
 **)

relation generate_alloc_array_f77 : (string , Types.Type) => CFunction =

  rule	Types.is_array ty => true &
	Types.flatten_array_type ty => (elty, dims) &
	Exp.int_subscripts dims => dimsubs &
	tick => tnr &
	generate_size_subscripts(crefstr, dimsubs, tnr) => (cfn1, dim_strs, tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &
	generate_type ty => typ_str &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,
			"(&",crefstr,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	  
	  c_add_inits(cfn1',[alloc_str]) => cfn
	---------------------------------------
	generate_alloc_array_f77 (crefstr, ty) => cfn


  rule	Print.print_buf "#-- generate_alloc_array_f77 failed\n"
	-------------------------------------------------------
	generate_alloc_array_f77 (_,_) => fail

end

(** relation: generate_algorithms
 **
 ** Generates code for all algorithms in the DAE.Element list
 **)

relation generate_algorithms: (DAE.Element list, int)
	  => (CFunction, int) =

  rule	Util.list_matching(els,DAE.is_algorithm) => algs &
	generate_algorithms2(algs,tnr) => (cfn,tnr') 
	------------------------
	generate_algorithms (els, tnr) => (cfn,tnr')

end

(** relation: generate_algorithms
 **
 ** Helper relation to generate_algorithms
 **)

relation generate_algorithms2: (DAE.Element list, int)
	  => (CFunction, int) =

  axiom	generate_algorithms2 ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm (first,tnr) => (cfn1,tnr1) &
	generate_algorithms2 (rest,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------
	generate_algorithms2 (first::rest, tnr) => (cfn,tnr2)

end


(** relation: generate_algorithm
 **
 ** Generates C-code for an DAE.Element that is ALGORTIHM
 ** The tab indent number is passed as argument.
 **)

relation generate_algorithm: (DAE.Element, int)
	  => (CFunction, int) =

  rule	generate_algorithm_statements (stmts,tnr) => (cfn,tnr') 
	----------------------------------------
	generate_algorithm (DAE.ALGORITHM(Algorithm.ALGORITHM(stmts)),tnr)
	  => (cfn,tnr')

  rule	Debug.fprint("failtrace","# generate_algorithm failed\n")
	------------------------------------
  	generate_algorithm (_,_) => fail

end

(** relation: generate_algorithm_statements
 **
 ** Generates code for a list of Algorithm.Statement.
 **)

relation generate_algorithm_statements : (Algorithm.Statement list, int)
	  => (CFunction, int) =

  axiom	generate_algorithm_statements ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm_statement (f,tnr) => (cfn1,tnr1) &
	generate_algorithm_statements(r,tnr1) =>(cfn2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn
	-----------
	generate_algorithm_statements (f::r, tnr) => (cfn,tnr2)
end


(** relation : generate_algorithm_statement
 **
 **  returns:
 **  CFunction | Code
 ** int       | next temporary number 
 *)

relation generate_algorithm_statement : (Algorithm.Statement, int)
	  => (CFunction, int) =
	  
  rule	Debug.fprintln("cgas","generate_algorithm_statement") &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_scalar_lhs_cref(typ,cref,tnr1)
	  => (cfn2,var2,tnr2) &
	Util.string_append_list([var2," = ",var1,";"]) => stmt &

	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	----------------
	generate_algorithm_statement (Algorithm.ASSIGN(typ,cref,exp),tnr)
	  => (cfn, tnr2)

  rule	comp_ref_cstr cref => (cref_str,[]) &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["copy_",type_str,"_data(&",
			var1,", &",cref_str,");"]) => stmt &
	  c_add_statements(cfn1,[stmt]) => cfn2
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn2,tnr1)

  rule	comp_ref_cstr cref => (cref_str,subs as _::_) &
	
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_index_spec(subs,tnr1) => (cfn2,var2,tnr2) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["indexed_assign_",type_str,"(&",
			var1,", &",cref_str,", &",var2,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn,tnr2)

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	
	Util.string_append_list(["if (",var1,") {"]) => if_begin &
	c_add_statements(cfn1,[if_begin]) => cfn1' &
	generate_algorithm_statements(then,tnr1) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	generate_else (else,tnr2) => (cfn3,tnr3) &
	c_merge_fns([cfn1',cfn2',cfn3]) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.IF(e,then,else),tnr) 
	  => (cfn,tnr3)

  rule	Exp.is_range e => true &
	generate_temp_decl("state",tnr) => (sdecl,svar,tnr') &
	generate_temp_decl("",tnr') => (_,dvar,tnr1) &
	exp_type_str (t,a) => ident_type_str &
	exp_short_type_str t => short_type &
	generate_temp_decl(ident_type_str,tnr1) => (rdecl1,rvar1,tnr2'') &
	generate_temp_decl(ident_type_str,tnr2'') => (rdecl2,rvar2,tnr2''') &
	generate_temp_decl(ident_type_str,tnr2''') => (rdecl3,rvar3,tnr2) &

	generate_range_expressions(e,tnr2) => (cfn3,e1var,e2var,e3var,tnr3) &
	Util.string_append_list([rvar1," = ",e1var,"; ",
				 rvar2," = ",e2var,"; ",
				 rvar3," = ",e3var,";"]) => r_stmt &
	Util.string_append_list(["for (",i," = ",rvar1,"; ",
			    "in_range_",short_type,"(",i,", ",rvar1,", ",rvar3,"); ",
			    i," += ",rvar2,") {"]) => for_begin &

	Util.string_append_list(["{\n  ",ident_type_str," ",i,";\n"]) => def_beg1 &

	Util.string_append_list([svar," = get_memory_state();"]) => mem_begin &

	generate_algorithm_statements(stmts,tnr3) => (cfn4,tnr4) &
	Util.string_append_list(["restore_memory_state(",svar,");"]) 
	  => mem_end &

	let for_end = "}" &
	let def_end1 = "} /* end for*/\n" &

	c_add_variables(cfn3,[sdecl,rdecl1,rdecl2,rdecl3]) => cfn3' &
	c_add_statements(cfn3',[r_stmt,
				def_beg1,
				for_begin,
				mem_begin]) => cfn3'' &
	
	c_add_statements(cfn4,[mem_end,
			       for_end,
			       def_end1]) => cfn4' &

	c_merge_fns([cfn3'',cfn4']) => cfn
	
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(t,a,i,e,stmts),tnr)
	  => (cfn,tnr4)

  rule	generate_temp_decl("state",tnr) => (sdecl,svar,tnr') &
	generate_temp_decl("",tnr') => (_,dvar,tnr'') &
	generate_temp_decl("int",tnr'') => (tdecl,tvar,tnr1) &
	exp_type_str (t,a) => ident_type_str &
	generate_temp_decl(ident_type_str,tnr1) => (idecl,ivar,tnr2) &
	exp_type_str (t,true) => array_type_str &
	generate_expression(e,tnr2) => (cfn3,evar,tnr3) &
	Util.string_append_list(["for (",tvar," = 0; ",
			    tvar," < size_of_dimension_",array_type_str,"(",evar,", 1); ",
			    "++",tvar,") {"]) => for_begin &
	Util.string_append_list(["{\n  ",ident_type_str," ",i,";\n"]) => def_beg1 &
	Util.string_append_list([svar," = get_memory_state();"]) => mem_begin &
	Util.string_append_list(["simple_index_alloc_",ident_type_str,
			    "1(&",evar,", ",tvar,", &",ivar,"));"]) 
	  => stmt_array &
	Util.string_append_list([i," = *(",array_type_str,"_element_addr1(&",
			    evar,", 1, ",tvar,"));"]) => stmt_scalar & (* Use fast implementation for 1 dim *)

	Util.if(a,stmt_array,stmt_scalar) => stmt &
	generate_algorithm_statements(stmts,tnr3) => (cfn4,tnr4) &
	Util.string_append_list(["restore_memory_state(",svar,");"]) 
	  => mem_end &
	let for_end = "}" &
	let def_end1 = "} /* end for*/\n" &
	c_add_variables(cfn3,[sdecl,tdecl,idecl]) => cfn3' &
	c_add_statements(cfn3',[def_beg1,
				for_begin,
				mem_begin,stmt]) => cfn3'' &
	
	c_add_statements(cfn4,[mem_end,
			       for_end,
			       def_end1]) => cfn4' &

	c_merge_fns([cfn3'',cfn4']) => cfn	
	
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(t,a,i,e,stmts),tnr)
	  => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["while (1) {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (!",var2,") break;"]) => crit_stmt &
	c_add_statements(cfn2,[crit_stmt]) => cfn2' &

	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1,cfn2',cfn3']) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.WHILE(e,stmts),tnr) 
	  => (cfn,tnr3)

  rule	Print.print_buf "# when statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.WHEN(_,_),_) => fail

  rule	Print.print_buf "# generate_algorithm_statement failed\n"
	-------------------------
	generate_algorithm_statement (_,_) => fail

end

(** relation: generate_range_expressions
 ** 
 ** Generates code for a range expression.
 **)

relation generate_range_expressions : (Exp.Exp, int)
	  => (CFunction, string, string, string, int) =


  rule	generate_expression (e1,tnr) => (cfn1,var1,tnr1) &
	let var2 = "(1)" &
	generate_expression (e3,tnr1) => (cfn3,var3,tnr3) &
	
	c_merge_fn(cfn1,cfn3) => cfn 
	-----------------------
	generate_range_expressions(Exp.RANGE(t,e1,NONE,e3),tnr) 
	  => (cfn,var1,var2,var3,tnr3)

  rule	generate_expression (e1,tnr)  => (cfn1,var1,tnr1) &
	generate_expression (e2,tnr1) => (cfn2,var2,tnr2) &
	generate_expression (e3,tnr2) => (cfn3,var3,tnr3) &
	
	c_merge_fns([cfn1,cfn2,cfn3]) => cfn 
	-----------------------
	generate_range_expressions(Exp.RANGE(t,e1,SOME(e2),e3),tnr) 
	  => (cfn,var1,var2,var3,tnr3)

  rule	Print.print_buf "# generate_range_expressions failed\n"
	-----------------------
	generate_range_expressions(_,_) => fail

end 
(** relation: generate_else
 ** 
 ** Generates code for an Else branch.
 **)

relation generate_else : (Algorithm.Else, int) => (CFunction, int) =

  axiom	generate_else (Algorithm.NOELSE,tnr) => (c_empty_function,tnr)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (",var2,") {"]) => if_begin &
	c_add_statements(cfn2,[if_begin]) => cfn2' &
	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &
	generate_else(else,tnr3) => (cfn4,tnr4) &
	c_add_statements(cfn4,["}"]) => cfn4' &
	c_merge_fns([cfn1,cfn2',cfn3',cfn4']) => cfn
	-------
	generate_else (Algorithm.ELSEIF(e,stmts,else),tnr) => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_algorithm_statements(stmts,tnr) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	--------
	generate_else (Algorithm.ELSE(stmts),tnr) => (cfn,tnr)

  rule	Print.print_buf "# generate_else failed\n"
	---------------
	generate_else (_,_) => fail
end

(** relation: generate_vars
 **
 ** Generates code for variables, given a list of elements and a relation
 ** over the elements. Code is only generated for elements for which the 
 ** relation succeeds.
 **)

relation generate_vars : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_vars ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var (first,tnr)  => (cfn1,tnr1) & 
	generate_vars (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_vars (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_vars failed\n"
	---------------------------------
	generate_vars (_,_,_) => fail
	
end


(** relation: generate_var_decls
 **
 ** Generates declaration code for variables given a DAE.Element list 
 ** and a relation over elements. Code is only generated for Elements for 
 ** which the relation succeeds.
 **)

relation generate_var_decls : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_var_decls ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var_decl (first,tnr)  => (cfn1,tnr1) & 
	generate_var_decls (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_var_decls (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_var_decls (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_var_decls (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_var_decls failed\n"
	---------------------------------
	generate_var_decls (_,_,_) => fail
	
end

(** relation: generate_var_inits
 **
 ** Generates initialization code for variables given a DAE.Element list 
 ** and a relation over elements. Code is only generated for Elements for 
 ** which the relation succeeds.
 **)

relation generate_var_inits : (DAE.Element list, (* elements*)
			       DAE.Element => (), int, (* verifying relation*)
			       string) (* variable prefix*) 
	  => (CFunction, int) =

  axiom	generate_var_inits ([],_,tnr,_) => (c_empty_function, tnr)

  rule	verify first &
	generate_var_init (first, tnr, pre) => (cfn1, tnr1) &
	generate_var_inits(rest, verify, tnr1, pre) => (cfn2, tnr2) &
	c_merge_fn(cfn1, cfn2) => cfn
	-----------------------------
	generate_var_inits (first::rest, verify, tnr, pre) => (cfn, tnr2)

  rule	not verify first &
	generate_var_inits (rest,verify,tnr,pre)  => (cfn,tnr2)
	--------------------
	generate_var_inits (first::rest,verify,tnr,pre)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_var_inits failed\n"
	---------------------------------
	generate_var_inits (_,_,_,_) => fail
	
end

(** relation: generate_var
 **
 ** Generates code for a variable.
 **)

relation generate_var : (DAE.Element,int) 
	  => (CFunction,int) =

	  (* variables without binding *)
  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(cref_str,inst_dims,tnr) => (cfn1',vars1,tnr1) &
	c_move_statements_to_inits cfn1' => cfn1 &
	Util.string_delimit_list(vars1,", ") => dimvars_str &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dimvars_str,");"]) => alloc_str &
	c_add_variables(cfn1,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn
	----------------------------------------------------
	generate_var(var as DAE.VAR(id, vk, vd, typ, NONE,inst_dims,start,flow,class,dae_var_attr,comment),tnr) => (cfn,tnr1)

	(* variables with binding *)
  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(cref_str,inst_dims,tnr) => (cfn1',vars1,tnr1) &
	c_move_statements_to_inits cfn1' => cfn1 &
	Util.string_delimit_list(vars1,", ") => dimvars_str &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])
	  => decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dimvars_str,");"]) => alloc_str &
	c_add_variables(cfn1,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var(var as DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims,start,flow,class,dae_var_attr,comment),tnr) 
	  => (cfn,tnr1)

  
  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.string_append_list([typ_str," ",cref_str,";"]) => decl_str &
	generate_expression(e,tnr) => (cfn,var,tnr1) &
	c_add_variables(cfn,[decl_str]) => cfn' &
	Util.string_append_list([cref_str," = ",var,";"]) => init_stmt &
	c_add_inits(cfn',[init_stmt]) => cfn'' &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var(var as DAE.VAR(id, vk, vd, typ, SOME(e),
				    inst_dims,start,flow,class,dae_var_attr,comment),tnr) 
	  => (cfn'',tnr1)
	
  rule	Print.print_buf "# generate_var failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var (e,_) => fail
end

(** relation: generate_var_decl
 **
 ** Generates code for a variable declaration.
 **)

relation generate_var_decl : (DAE.Element,int) => (CFunction,int) =

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	
	c_add_variables(c_empty_function,[decl_str]) => cfn
	----------------------------------------------------
	generate_var_decl(var as DAE.VAR(id, vk, vd, typ, NONE,
					 inst_dims,start,flow,class,dae_var_attr,comment),tnr) 
	  => (cfn,tnr)

  rule	generate_var_decl(DAE.VAR(id, vk, vd, typ, NONE, inst_dims, 
				  start, flow,class,dae_var_attr,comment), tnr)
	  => (cfn,tnr1)
	  --------------------------------------------------------------------
	generate_var_decl(var as DAE.VAR(id, vk, vd, typ, SOME(e), inst_dims,start,flow,class,dae_var_attr,comment),tnr) 
	  => (cfn,tnr1)

	
  rule	Print.print_buf "# generate_var_decl failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var_decl (e,_) => fail
end


(** relation: generate_var_init
 **
 ** Generates code for the initialization of a variable.
 **)

relation generate_var_init : (DAE.Element,int,string) => (CFunction,int) =

	(* No binding *)
  axiom	generate_var_init(var as DAE.VAR(id, vk, vd, typ, NONE,
					 inst_dims,start,flow,class,dae_var_attr,comment),tnr,pre)
	  => (c_empty_function, tnr)

	  (* Has binding *)
  rule	is_array var => is_a &
	Util.string_equal (pre, "") => emptyprep &
	Exp.prepend_string_cref ("out.", id) => id' &
	Util.if (emptyprep, id, id') => idstr &
	dae_exp_type typ => exptype &
	let scalarassign = Algorithm.ASSIGN(exptype, idstr, e) &
	let arrayassign = Algorithm.ASSIGN_ARR(exptype, idstr, e) &
	Util.if (is_a,arrayassign,scalarassign) => assign &
	generate_algorithm_statement (assign,tnr) => (cfn,tnr1)
	-------------------------------------------------------
	generate_var_init(var as DAE.VAR(id, vk, vd, typ, SOME(e),
					 inst_dims,start,flow,class,dae_var_attr,comment),tnr,pre)
	  => (cfn,tnr1)

	
  rule	Print.print_buf "# generate_var_init failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var_init (e,_,_) => fail
end


(** relation: dim_string
 **
 ** Returns a Exp.subscript as a string.
 **)

relation dim_string : Exp.Subscript => string =

  rule	int_string i => str
	---------------------
	dim_string Exp.INDEX(Exp.ICONST(i)) => str
	
  rule	Exp.print_subscript_str e => str 
	-------------------
	dim_string e => ":"

end

(** relation: is_var_q
 **
 ** Succeds if DAE.Element is a variable or constant that is not input.
 **)

relation is_var_q : DAE.Element => () =

  rule	generate_var_q(vk) &
	generate_var_q2(vd)
	---------------------
	is_var_q DAE.VAR(id,vk,vd,_,_,_,_,_,_,_,_)

end

(** relation: generate_var_q
 **
 ** Helper relation to is_var_q.
 **)

relation generate_var_q : DAE.VarKind => () =

  axiom	generate_var_q DAE.VARIABLE
(*  axiom	generate_var_q DAE.PARAM *)
  axiom	generate_var_q DAE.CONST 

end

(** relation: generate_var_q2
 **
 ** Helper relation to is_var_q.
 **)

relation generate_var_q2 : DAE.VarDirection => () =

  axiom	generate_var_q2 DAE.OUTPUT
  axiom	generate_var_q2 DAE.BIDIR

end

(** relation: generaet_result_vars
 **
 ** Generates code for output variables.
 **)

relation generate_result_vars : (DAE.Element list,string, int) 
	  => (CFunction, int) =

  axiom	generate_result_vars ([],_,tnr) => (c_empty_function,tnr)

  rule	generate_result_var (first,varname,tnr) => (cfn1,tnr1) &
	generate_result_vars (rest,varname,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------------------
	generate_result_vars (first :: rest,varname,tnr) => (cfn,tnr2)

end

(** relation: generate_result_var
 **
 ** Helper relation to generate_result_vars.
 **)

relation generate_result_var : (DAE.Element, 
				string, (* varname *)
				int) 
	  => (CFunction,int) =
	  (* non-arrays *)
  rule	is_array var => false &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list([varname,".",cref_str1," = ",cref_str2,";"])
	  =>stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	----------------------------------------------
	generate_result_var (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, 
					    _,_,_,_,_,_,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

	  (* arrays *)
  rule	is_array var => true &
	dae_type_str (typ, true) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list(["copy_",typ_str,"_data(&",
			cref_str1,", &",varname,".",cref_str2,");"]) 
	  => stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_,_,_,_,_,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  axiom	generate_result_var (_,_,tnr) => (c_empty_function,tnr)

end

(** relation: generate_expressions
 **
 ** Generates code for a list of expressions.
 **)

relation generate_expressions : (Exp.Exp list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_expressions ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (f,tnr) => (cfn1,var1,tnr1) &
	generate_expressions(r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn 
	----
	generate_expressions (f::r,tnr) => (cfn,var1::vars2,tnr2)

end

(** relation: generate_expression
 **
 ** Generates code for an expression.
 ** returns
 **  CFunction | the generated code
 **  string    | expression result variable name, or c expression
 **  int       | next temporary number 
 **)
 
relation generate_expression : (Exp.Exp, int) => (CFunction,string,int) =
	  
  rule	int_string i => istr
	-----------------------------------------------------
	generate_expression(Exp.ICONST(i),tnr) => (c_empty_function,istr,tnr)

  rule	real_string r => rstr
	------------------
	generate_expression(Exp.RCONST(r),tnr) => (c_empty_function,rstr,tnr)
	
  rule	Util.string_append_list(["\"",s,"\""]) => sstr
	---------------------------------------------
	generate_expression(Exp.SCONST(s),tnr) => (c_empty_function,sstr,tnr)

  rule	Util.if(b,"(1)","(0)") => var
	-------------------------
	generate_expression(Exp.BCONST(b),tnr) => (c_empty_function,var,tnr)

  rule	generate_rhs_cref(cref, t, tnr) => (cfn,var,tnr')
	-------------------------------------------------
	generate_expression(Exp.CREF(cref,t),tnr) => (cfn,var,tnr')

  rule	generate_binary(e1,op,e2,tnr) => (cfn, var, tnr')
	-------------------------------------------------
	generate_expression(Exp.BINARY(e1,op,e2),tnr) => (cfn, var, tnr')

  rule	generate_unary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.UNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_lbinary(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LBINARY(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_lunary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LUNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_relation(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.RELATION(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	generate_temp_decl("modelica_boolean",tnr1) => (decl,tvar,tnr1') &
	Util.string_append_list([tvar," = ",var1,";"]) => b_stmt &
	Util.string_append_list(["if (",tvar,") {"]) => if_begin &
	c_add_statements(cfn1,[b_stmt,if_begin]) => cfn1'' &
	c_add_variables(cfn1'',[decl]) => cfn1' &	

	generate_expression(then,tnr1') => (cfn2,var2,tnr2) &
	c_add_statements(cfn2,["}","else {"]) => cfn2' &

	generate_expression(else,tnr2) => (cfn3,var3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1',cfn2',cfn3']) => cfn &

	Util.string_append_list(["((",tvar,")?",var2,":",var3,")"]) => var
	-------------------------
	generate_expression(Exp.IFEXP(e,then,else),tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = _",fn_name,"(", args_str,");"])
	  => stmt &

	c_add_statements(cfn2,[stmt]) => cfn &

	Util.string_append_list([tvar,".",ret_type,"_1"]) => var_not_bi &
	Util.if(builtin,tvar,var_not_bi) => var
	-------------------------
	generate_expression(Exp.CALL(fn,args,false,builtin),tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = _",fn_name,"(", args_str,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn
	-------------------------
	generate_expression(Exp.CALL(fn,args,true,builtin),tnr) 
	  => (cfn,tvar,tnr2)

  rule	generate_expression (crexp,tnr) => (cfn1,var1,tnr1) &
	generate_temp_decl("size_t",tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
	exp_type_str (ty,true) => typestr &
	generate_expression (dim,tnr2) => (cfn3, var2, tnr3) & 
	Util.string_append_list([tvar," = size_of_dimension_", typestr,"(", var1, ",",var2,");"]) => stmt &
	c_merge_fn(cfn2,cfn3) => cfn4 &
	c_add_statements(cfn4,[stmt]) => cfn
	-------------------------
	generate_expression(Exp.SIZE(crexp as Exp.CREF(cr,ty), SOME(dim)), tnr)
	  => (cfn,tvar,tnr2)

  rule	Print.print_buf "#-- Codegen.generate_expression: size(X) not implemented"
	--------------------------------------------------------------------------
	generate_expression(Exp.SIZE(cr, NONE), tnr) => fail

  rule	generate_expressions(elist,tnr) => (cfn1,vars1,tnr1) &
	list_length vars1 => nvars &
	int_string nvars => nvars_str &
	exp_type_str (t,true) => array_type_str &
	exp_short_type_str t => short_type_str &
	generate_temp_decl(array_type_str,tnr1) => (tdecl,tvar,tnr2) &
	Util.if(a,"","scalar_") => scalar &
	Util.if(a,"&","") => scalar_ref &
	string_append(", ",scalar_ref) => scalar_delimit &
	Util.string_delimit_list (vars1, scalar_delimit) => args_str &
	Util.string_append_list ["array_",scalar,array_type_str,"(&",
				 tvar,", ",nvars_str,", ",
				 scalar_ref,args_str,");"
				 ] => stmt &
	c_add_variables(cfn1,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------
	generate_expression(Exp.ARRAY(t,a,elist),tnr) => (cfn,tvar,tnr2)

  rule	generate_matrix(t,maxn,ell,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.MATRIX(t,maxn,ell),tnr) => (cfn,var,tnr')

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	exp_type_str (t,true) => type_string &
	generate_temp_decl(type_string,tnr2) => (tdecl,tvar,tnr3) &
	Util.string_append_list(["range_alloc_",type_string,"(",
				 var1,", ",var2,", 1, &",tvar,");"]) => stmt &

	c_add_variables(cfn1,[tdecl]) => cfn1' &
	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fns([cfn1',cfn2']) => cfn
	-------------------------
	generate_expression(Exp.RANGE(t,e1,NONE,e2),tnr) => (cfn,tvar,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	generate_expression(e3,tnr1)=> (cfn3,var3,tnr3) &
	exp_type_str (t,true) => type_string &
	generate_temp_decl(type_string,tnr3) => (tdecl,tvar,tnr4) &
	Util.string_append_list(["range_alloc_",type_string,"(",
				 var1,", ",var3,", ",var2,", &",tvar,");"]) 
	  => stmt &

	c_add_variables(cfn1,[tdecl]) => cfn1' &
	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fns([cfn1',cfn2']) => cfn
	-------------------------
	generate_expression(Exp.RANGE(t,e1,SOME(e2),e3),tnr) => (cfn,tvar,tnr4)

  rule	Print.print_buf "# Codegen.generate_expression: tuple not implemented\n"
	-------------------------
	generate_expression(Exp.TUPLE(_),_) => fail

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_int)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.INT,e),tnr) => (cfn,var',tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_real)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.REAL,e),tnr) => (cfn,var',tnr')

  rule	Print.print_buf "# Codegen.generate_expression: asub not implemented\n"
	-------------------------
	generate_expression(Exp.ASUB(_,_),_) => fail

  
  rule	(*Debug.fprintln("failtrace","# generate_expression failed") &
	Debug.fcall("failtrace",Exp.print_exp,e) &
	Debug.fprintln("failtrace","")*)
	----------------
	generate_expression(e,_) => fail
end

(** relation: generate_unary
 ** 
 ** Helper relation to generate_expression.
 **)

relation generate_unary : (Exp.Operator, Exp.Exp, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS(Exp.REAL), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS(Exp.INT), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list ["(-",var,")"] => var'
	------------------------
	generate_unary (Exp.UMINUS(Exp.REAL), e, tnr) => (cfn, var', tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list ["(-",var,")"] => var'
	------------------------
	generate_unary (Exp.UMINUS(Exp.INT), e, tnr) => (cfn, var', tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS_ARR(Exp.REAL), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS_ARR(Exp.INT), e, tnr) => (cfn, var, tnr')

  rule	Print.print_buf "# unary minus for arrays not implemented\n"
	------------------------
	generate_unary (Exp.UMINUS_ARR(_), _, _) => fail
end

(** relation:  generate_binary
 **
 ** Helper relation to generate_expression.
 ** returns:
 ** CFunction | the generated code
 ** string    | expression result 
 ** int       | next temporary number 
 **)

relation generate_binary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =
	  
  rule	generate_expression(e1,tnr ) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) => (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," + ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.ADD(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," - ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.SUB(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," * ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.MUL(_),e2,tnr) => (cfn,var,tnr2)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," / ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.DIV(_),e2,tnr) => (cfn,var,tnr2)

	(* POW uses the math lib function with the same name. *)
  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["pow(",var1,", ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------------------------------
	generate_binary(e1,Exp.POW(_),e2,tnr) => (cfn,var,tnr2)

  rule	Print.print_buf "# Unary minus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UMINUS(_),_,_) => fail
	
  rule	Print.print_buf "# Unary plus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UPLUS(_),_,_) => fail
		
  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_real_array(&",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.REAL),e2, tnr) => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_real_array(&",var1,", &",
			var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.INT),e2, tnr)
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_real_array(",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_integer_array(",var1,
		       ", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_real_scalar_product(&",var1,
			", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.REAL),e2, tnr)
	  => (cfn,var,tnr2)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_integer_scalar_product(&",var1,
		       ", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_matrix_product_smart(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_matrix_product_smart(&",
				 var1,", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["div_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.DIV_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["div_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.DIV_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	Print.print_buf "# div_array_scalar FAILING BECAUSE IT SUX\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	Print.print_buf "# pow_array not implemented\n"
	-------------------------
	generate_binary(_,Exp.POW_ARR(_),_,_) => fail

  rule	Print.print_buf "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	Print.print_buf "# generate_binary failed\n"
	-------------------------
	generate_binary(_,_,_,_) => fail
end

(** relation: generate_temp_decl
 ** 
 ** Generates code for the declaration of a temporary variable.
 **)

relation generate_temp_decl : (string, int) => (string, string, int) =
	 
  rule	int_string(tnr) => tnr_str &
	int_add(tnr,1) => tnr' &
	string_append("tmp",tnr_str) => tmp_name &
	Util.string_append_list([t," ",tmp_name,";"]) => t' 
	------------------------------	
	generate_temp_decl(t, tnr) => (t', tmp_name, tnr')

end

(** relation: generate_scalar_lhs_cref
 **
 ** Helper relation to generate_algorithm_statement.
**)

relation generate_scalar_lhs_cref : (Exp.Type, Exp.ComponentRef, int)
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[])
	--------------------
	generate_scalar_lhs_cref(t,cref,tnr)
	  => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	generate_scalar_rhs_cref(cref_str,t,subs,tnr) => (cfn,var,tnr')
	--------------------
	generate_scalar_lhs_cref(t,cref,tnr)
	  => (cfn,var,tnr')

	    (* two special cases rules for 1 and 2 dimensions for faster code (no vararg) *)
  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 1 &  (* ndims == 1*)
	int_string 1 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr1(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
 
  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 2 & (* ndims == 2 *)
	int_string 2 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr2(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)


  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
  
  rule	Print.print_buf "# generate_scalar_lhs_cref failed\n"
	-----------------------------
	generate_scalar_lhs_cref(_,_,_) => fail

end

(** relation: generate_rhs_cref
 **
 ** Helper relation to generate_expression.
 **)

relation generate_rhs_cref : (Exp.ComponentRef, Exp.Type, int) 
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[]) 
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => true &
	generate_scalar_rhs_cref(cref_str,crt, subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')
	
	(* array expressions *)
  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => false &
	generate_array_rhs_cref(cref_str,crt,subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

end

(** relation: subs_to_scalar
 **
 ** Returns true if subscript results applied to variable or expression 
 ** results in scalar expression.
 **)
relation subs_to_scalar : Exp.Subscript list => bool =

  axiom subs_to_scalar [] => true
  axiom subs_to_scalar Exp.SLICE(_)::_ => false
  axiom	subs_to_scalar Exp.WHOLEDIM::_ => false

  rule	subs_to_scalar r => b
	---------------------
	subs_to_scalar Exp.INDEX(_)::r => b

end

(** relation: generate_scalar_rhs_cref
 **
 ** Helper relation to generate_algorithm_statement.
 **)

relation generate_scalar_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

	   (* Two special rules for faster code when ndims == 1 or 2 *)
	
  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 1 & (* ndims == 1*)
	int_string 1 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr1(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 2 & (* ndims == 2*)
	int_string 2 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr2(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)
end

(** relation: generate_array_rhs_cref
 **
 ** Helper relation to generate_rhs_cref.
 **)

relation generate_array_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_index_spec(subs,tnr) => (cfn1,spec1,tnr1) &
	exp_type_str(crt,true) => array_type_str &
	generate_temp_decl(array_type_str,tnr1) => (decl,temp,tnr2) &
	Util.string_append_list(["index_alloc_",array_type_str,"(&",cref_str,
				 ", &",spec1,", &",temp,");"]) => stmt &
	c_add_variables(cfn1,[decl]) => cfn'&
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------------------------
	generate_array_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn,temp,tnr2)
end

(** relation: generate_index_spec
 **
 ** Helper relation to generate_algorithm_statement.
 **)

relation generate_index_spec : (Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices_array(subs,tnr) => (cfn1,idxs1,idxsizes,tnr1) &
	generate_temp_decl("index_spec_t",tnr1) => (decl,spec,tnr2) &
	list_length idxs1 => nridx &
	int_string nridx => nridx_str &
	Util.list_thread(idxsizes,idxs1) => idxs' &
	Util.string_delimit_list(idxs',", ") => idxs_str &
	Util.string_append_list(["create_index_spec(&",
				 spec,", ",nridx_str,", ",idxs_str,");"]) 
	  => stmt &
  
	c_add_variables(cfn1,[decl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	
	---------------------------------------------
	generate_index_spec (subs, tnr) => (cfn,spec,tnr2)

  rule	Print.print_buf "# generate_index_spec failed\n"
	-----------------------------
	generate_index_spec(_,_) => fail

end

(** relation: generate_indices_array
 **
 ** Helper relation to generaet_indices_array
 **)

relation generate_indices_array : (Exp.Subscript list, int) 
	  => (CFunction, string list, string list, int) =

  axiom	generate_indices_array ([],tnr) => (c_empty_function,[],[],tnr)

  rule	generate_index_array(f,tnr) => (cfn1,idx1,idxsize1, tnr1) &
	generate_indices_array(r,tnr1)=>(cfn2,idxs2,idxsizes2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2 &
	let idxsizes = idxsize1::idxsizes2
	---------
	generate_indices_array (f::r, tnr) => (cfn,idxs,idxsizes,tnr2)

  rule	Print.print_buf "# generate_indices_array failed\n"
	-----------------------------
	generate_indices_array(_,_) => fail

end

(** relation: generate_indices
 **
 ** 
**)

relation generate_indices : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index(f,tnr) => (cfn1, idx1, tnr1) &
	generate_indices(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices (f::r, tnr) => (cfn,idxs,tnr2)

  rule	Print.print_buf "# generate_indices failed\n"
	-----------------------------
	generate_indices(_,_) => fail

end

(** relation: generate_index_array
 **
 ** Helper relatoin to generate_indices_array
 **)

relation generate_index_array : (Exp.Subscript, int)
	  => (CFunction, string, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1) &
	Util.string_append_list(["make_index_array(1, ",var1,")"]) => idx &
	let idxsize = "(0)"
	------------------------------------
	generate_index_array(Exp.INDEX(e), tnr) 
	  => (cfn,idx,idxsize,tnr1)

  rule	let idx = "(0)" &
	let idxsize = "(1)"
	------------------------------------
	generate_index_array(Exp.WHOLEDIM, tnr) 
	  => (c_empty_function,idx,idxsize,tnr)

	  
  rule	Print.print_buf "# generate_index_array failed\n"
	-----------------------------
	generate_index_array(_,_) => fail

end

(** relation: generate_index
 **
 ** Helper relation to generate_index_array.
 **)

relation generate_index : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1)	
	------------------------------------
	generate_index(Exp.INDEX(e), tnr) => (cfn,var1,tnr1)

  rule	Print.print_buf "# generate_index failed\n"
	-----------------------------
	generate_index(_,_) => fail

end

(** relation: indent_strings
 **
 ** Adds a two space indentation to each string in a string list.
 **)
	    
relation indent_strings : string list => string list =

  axiom	indent_strings [] => []

  rule	string_append("  ",f) => f' &
	indent_strings r => r'
	-----------------------------
	indent_strings f::r => f'::r'
	
end

(** relation: comp_ref_cstr
 **
 ** Returns the ComponentRef as a string and the complete Subscript list of
 ** the ComponentRef.
 **)

relation comp_ref_cstr : Exp.ComponentRef => (string, Exp.Subscript list) =

  axiom	comp_ref_cstr Exp.CREF_IDENT(id,subs) => (id,subs)

  rule	comp_ref_cstr cref => (cref_str,cref_subs) &
	Util.string_append_list([id,"__",cref_str]) => cref_str' &
	Util.list_flatten([subs,cref_subs]) => subs'
	------------------------------
	comp_ref_cstr Exp.CREF_QUAL(id,subs,cref) => (cref_str',subs')
end


(** relation: generate_lbinary
 ** 
 ** Generates code for logical binary expressions.
 ** returns:
 ** CFunction | the generated code
 ** string    | expression result 
 ** int       | next temporary number 
 **)
relation generate_lbinary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.AND,e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.OR,e2,tnr) => (cfn, var, tnr2)


  rule	Print.print_buf "# generate_lbinary failed\n"
	-----------------------------
	generate_lbinary (_,_,_,_) => fail

end

(** relation: generate_lunary
 ** 
 ** Generates code for logical unary expressions.
 ** returns:
 ** CFunction | the generated code
 ** string    | expression result 
 ** int       | next temporary number 
 **)

relation generate_lunary : (Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	Util.string_append_list(["(!",var1,")"]) => var
	-------
	generate_lunary (Exp.NOT,e,tnr) => (cfn1, var, tnr1)


  rule	Print.print_buf "# generate_lbinary failed\n"
	-----------------------------
	generate_lunary (_,_,_) => fail

end

(** relation: generate_relation
 ** 
 ** Generates code for relation expressions.
 ** returns:
 ** CFunction | the generated code
 ** string    | expression result 
 ** int       | next temporary number 
 **)

relation generate_relation : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESS(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATER(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && !",var2,") || (",
			var1," && ",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," == ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# Reals can't be compared with ==\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.REAL),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && ",var2,") || (",
			var1," && !",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," != ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# Reals can't be compared with <>\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.REAL),e2,tnr) => fail


  rule	Print.print_buf "# generate_relation failed\n"
	-----------------------------
	generate_relation (_,_,_,_) => fail

end

(** relation: generate_matrix
 **
 ** Generates code for matrix expressions.
 **)

relation generate_matrix : (Exp.Type, int, (Exp.Exp*bool) list list, int) 
	  => (CFunction, string, int) =


  rule	generate_matrix_expressions(typ,exps,maxn,tnr) => (cfn1,vars1,tnr1) &
	concatenate_matrix_rows(typ,vars1,tnr1) => (cfn2,vars2,tnr2) &
	
	exp_type_str(typ,true) => array_type_str &
	Util.string_delimit_list(vars2,", &") => args_str &
	list_length(vars2) => n &
	int_string n => n_str &
	generate_temp_decl(array_type_str,tnr2) => (tdecl,tvar,tnr3) &
	Util.string_append_list(["cat_alloc_",array_type_str,"(1, &",
				 tvar,", ",n_str,
				 ", &",args_str,");"]) => stmt &

	c_add_variables(cfn2,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn'' &
	c_merge_fn(cfn1,cfn'') => cfn
	
	(*

	 Generate code for every expression and
	 promote it to maxn dimensions
	 for every row create cat(2,rowvar1,....)
	 for every column create cat(1,row1,....)

	 *)
	---------------------
	generate_matrix(typ,maxn,exps,tnr) => (cfn,tvar,tnr3)

end

(** relation: contatenate_matrix_rows
 **
 ** Helper relation to generate_matrix.
 **)

relation concatenate_matrix_rows : (Exp.Type, string list list, int)
	=> (CFunction, string list, int) =

  axiom	concatenate_matrix_rows (_,[],tnr) => (c_empty_function, [], tnr)

  rule	concatenate_matrix_row(typ,f,tnr) => (cfn1,var1,tnr1) &
	concatenate_matrix_rows(typ,r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------
	concatenate_matrix_rows (typ,f::r,tnr) => (cfn,var1::vars2,tnr2)

end

(** relation: contatenate_matrix_row
 **
 ** Helper relation to concatenate_matrix_rows
 **)

relation concatenate_matrix_row : (Exp.Type, string list, int) 
	  => (CFunction, string, int) =

  rule	exp_type_str(typ,true) => array_type_str &
	Util.string_delimit_list(vars,", &") => args_str &
	list_length(vars) => n &
	int_string n => n_str &
	generate_temp_decl(array_type_str,tnr) => (tdecl,tvar,tnr1) &
	Util.string_append_list(["cat_alloc_",array_type_str,"(2, &",
				 tvar,", ",n_str,
				 ", &",args_str,");"]) => stmt &

	c_add_variables(c_empty_function,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	---------
	concatenate_matrix_row (typ,vars,tnr) => (cfn,tvar, tnr1)
end

(** relation: generate_matrix_expressions
 **
 ** Helper relation to generate_matrix.
 **)

relation generate_matrix_expressions : (Exp.Type,(Exp.Exp*bool) list list, int, int) =>
	(CFunction, string list list, int) =

  axiom	generate_matrix_expressions(_,[],_,tnr) => (c_empty_function,[],tnr)


  rule	generate_matrix_expr_row (typ,fr,maxn,tnr) => (cfn1,vars1,tnr1) &
	generate_matrix_expressions(typ,rr,maxn,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_matrix_expressions(typ,fr::rr,maxn,tnr) 
	  => (cfn,vars1::vars2,tnr2)


end

(** relation: generate_matrix_expr_row
 **
 ** Helper relation to generate_matrix_expressions.
 **)

relation generate_matrix_expr_row : (Exp.Type,(Exp.Exp*bool) list, int, int)
	  => (CFunction,string list, int) =

  axiom	generate_matrix_expr_row (_,[],_,tnr) => (c_empty_function,[],tnr)

  rule	generate_matrix_expression(t,f,maxn,tnr) => (cfn1,var1,tnr1) &
	generate_matrix_expr_row(t,r,maxn,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------
	generate_matrix_expr_row(t,f::r,maxn,tnr) => (cfn,var1::vars2,tnr2)


end

(** relation: generate_matrix_expressions.
 **
 ** Helper relation to generate_matrix_expressions.
 **)
	
relation generate_matrix_expression : (Exp.Type,(Exp.Exp*bool), int, int) 
	=> (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(t,true) => array_type_str &
	int_string maxn => maxn_str &
	generate_temp_decl(array_type_str,tnr1) => (tdecl,tvar,tnr2) &
	Util.if(b,"","scalar_") => scalar &
	Util.if(b,"&","") => sc_ref &
	Util.string_append_list(["promote_",scalar,array_type_str,"(",
				 sc_ref,var1,
				 ", ",maxn_str,", &",tvar,");"]) => stmt &
	c_add_variables(cfn1,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	---------------------------------
	generate_matrix_expression(t,(e,b),maxn,tnr) => (cfn,tvar,tnr2)

end

(** relation  generate_read_call_write
 ** 
 ** Generates code for reading input parameters from file, executing function
 ** and writing result to file.
 **)

relation generate_read_call_write : (string, (* external function name *)
				     DAE.Element list,
				     string, (* return type *)
				     DAE.Element list)
	=> CFunction =


  rule	Debug.fprintln ("cgtr", "generate_read_call_write") &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES",
			       out_decl]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)
	generate_var_decls(invars,is_rcw_input,1) => (cfn31,tnr21) &
	generate_var_inits(invars,is_rcw_input,tnr21,"") => (cfn32,tnr2) &
	c_merge_fns([cfn31,cfn32]) => cfn3 &
	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &
	invar_names invars => in_names &
	Util.string_delimit_list(in_names,", ") => in_args &
	
	generate_read(invars) => cfn4 &
	Util.string_append_list(["out = ",fnname,"(",in_args,");"]) => fn_call &
	c_add_statements(cfn4,["PRE_READ_DONE",
			       fn_call,
			       "PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE",
			       "return 0;"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',cfn4',cfn5']) => cfn 
	------------------------------------------------------
	generate_read_call_write(fnname,outvars,retstr,invars) => cfn

end

(** relation: generate_external_wrapper_call
 **
 ** This relation generates the wrapper function for external functions
 ** when used in e.g. simulation code.
 **)

 relation generate_external_wrapper_call:(string, (* function name *)
					  DAE.Element list, (* output variables *)
					  string, (* return type *)
					  DAE.Element list, (* input variables*)
					  DAE.ExternalDecl, (* external declaration*)
					  DAE.Element list, (* bidirectional vars *)
					  Types.Type) (* function type *)
	  => CFunction =
  rule	let tnr = 1 &
	 Util.list_map(args,generate_function_arg) => arg_strs &

	c_make_function(retstr,fnname,[],
			arg_strs) => cfn1 &
	 Util.string_append_list([retstr," out;"]) => out_decl &

	 c_add_variables(cfn1, [out_decl]) => cfn1' &
	 generate_var_decls(invars,is_rcw_input,tnr) 
	  => (cfn31,tnr_invars1) &
	 generate_var_inits(invars,is_rcw_input,tnr_invars1,"") 
	  => (cfn32,tnr_invars) &
	generate_var_decls(bivars,is_rcw_bidir,tnr_invars) 
	  => (cfn33, tnr_bivars1) &
	generate_var_inits(bivars,is_rcw_bidir,tnr_bivars1,"") 
	  => (cfn34, tnr_bivars) &
	
	c_merge_fns([cfn1',cfn31, cfn32, cfn33, cfn34]) => cfn3 &

	list_append (invars, outvars) => vars' &
	list_append (vars', bivars) => vars &

	generate_ext_call (vars, extdecl, tnr_bivars) => (extcall, tnr_extcall) &

	c_merge_fns([cfn1',extcall]) => cfn' &

	c_add_cleanups(cfn', ["return out;"]) => cfn
	------------------------------------------------------
	generate_external_wrapper_call(fnname,outvars,retstr,invars,
				       extdecl as DAE.EXTERNALDECL(extfnname,extargs,extretarg,lang,ann),bivars,(Types.T_FUNCTION(args,restype),_)) => cfn

  rule	Print.print_buf "#-- generate_external_wrapper_call failed\n"
	----------------------------------------------------------------
	generate_external_wrapper_call (_,_,_,_,_,_,_) => fail

end

(** relation: generate_read_call_write_external
 **
 ** Generates code for reading input parameters from file, executing function
 ** and writing result to file fo external functions.
 **)

relation generate_read_call_write_external : (string, (* function name *)
				     DAE.Element list, (* output variables *)
				     string, (* return type *)
				     DAE.Element list, (* input variables*)
				     DAE.ExternalDecl, (* external declaration*)
				     DAE.Element list) (* bidirectional vars *)
	=> CFunction =


  rule	Debug.fprintln ("cgtr", "generate_read_call_write_external") &
	let tnr = 1 &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES"]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)

	generate_alloc_outvars_ext(outvars, "out", tnr, extdecl) 
	  => (allocstmts', tnr_ret) &
	c_add_variables(allocstmts', [out_decl]) => allocstmts &
	generate_alloc_outvars_ext(bivars, "", tnr_ret, extdecl) 
	  => (biallocstmts, tnr_bialloc') &

	generate_var_inits(outvars,is_rcw_output,tnr_bialloc',"out") =>	(cfnoutinit,tnr_bialloc) &
	c_merge_fns([allocstmts,biallocstmts,cfnoutinit]) => cfnoutbialloc &

	generate_temp_decl("state",tnr_bialloc) => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var, " = get_memory_state();"])
	  => get_mem_stmt &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => rest_mem_stmt &
	
	c_add_variables(c_empty_function, [mem_decl]) => mem_fn' &
	c_add_inits(mem_fn', [get_mem_stmt]) => mem_fn'' &
	c_merge_fns([mem_fn'',cfnoutbialloc]) => mem_fn &
	

	generate_var_decls(invars,is_rcw_input,tnr_mem) => (cfn31,tnr_invars1) &
	generate_var_inits(invars,is_rcw_input,tnr_invars1,"") => (cfn32,tnr_invars) &

	generate_var_decls(bivars,is_rcw_bidir,tnr_invars) => (cfn33, tnr_bivars1) &
	generate_var_inits(bivars,is_rcw_bidir,tnr_bivars1,"") => (cfn34, tnr_bivars) &
	
	c_merge_fns([cfn31, cfn32, cfn33, cfn34]) => cfn3 &

	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &

	generate_read(invars) => readinvars & 
	c_add_inits(readinvars, ["PRE_READ_DONE"]) => readdone &

	list_append (invars, outvars) => vars' &
	list_append (vars', bivars) => vars &

	generate_ext_call (vars, extdecl, tnr_bivars) => (extcall, tnr_extcall) &
	c_add_statements(extcall,["PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',readdone,mem_fn,cfn4',cfn5']) => cfn' &

	c_add_cleanups(cfn', [rest_mem_stmt, "return 0;"]) => cfn
	------------------------------------------------------
	generate_read_call_write_external(fnname,outvars,retstr,invars,extdecl,bivars) => cfn

  rule	Print.print_buf "#-- generate_read_call_write_external failed\n"
	----------------------------------------------------------------
	generate_read_call_write_external (_,_,_,_,_,_) => fail

end

(** relation: generate_ext_call
 **
 ** Helper relation to generate_read_call_write_external. Generates the actual
 ** call to the external function.
 **)
 

relation generate_ext_call : (DAE.Element list, DAE.ExternalDecl, int) => (CFunction, int) =

  rule	Debug.fcall ("cgtrdumpdaeextcall", DAE.dump2, DAE.DAE(vars)) &
	DAE.dump_ext_decl_str extdecl => extdeclstr &
	Debug.fprintln ("cgtrdumpdaeextcall", extdeclstr) &
	generate_extcall_vardecls (vars, arglist, retarg, lang, tnr) => (argdecls,arglist',tnr') &
	generate_ext_call_fcall (n, arglist', retarg, lang) => fcall &
	Util.list_matching (arglist', is_extarg_output_or_bidir) => outbiarglist &
	generate_extcall_varcopy (outbiarglist, retarg, lang, tnr') => (argcopies,tnr'') &
	c_merge_fns([argdecls,fcall,argcopies]) => extcall
	-------------------------------------------------------------
	generate_ext_call (vars, extdecl as DAE.EXTERNALDECL(n,arglist,retarg,lang,ann), tnr) => (extcall,tnr'')

  rule	Print.print_buf "#-- generate_ext_call failed\n"
	------------------------------------------------
	generate_ext_call (_,_,_) => fail
end

(** relation: generate_extcall_vardecls
 **
 ** Helper relation to generate_ext_call.
 **)

relation generate_extcall_vardecls : (DAE.Element list, DAE.ExtArg list,
				      DAE.ExtArg, string, int) 
	  => (CFunction, DAE.ExtArg list, int) =

  rule	generate_extcall_vardecls2 (args, retarg) => (decls)
	----------------------------------------------------
	generate_extcall_vardecls (vars, args, retarg, "C", tnr) => (decls,args,tnr)

  rule	generate_extcall_copydecls_f77 (vars,tnr) => (copydecls,tnr') &
	generate_extcall_vardecls2_f77 (args, retarg, tnr') => (decls, args', tnr'') &
	c_merge_fn (copydecls, decls) => res
	-----------------------------------------------------------------
	generate_extcall_vardecls (vars, args, retarg, "FORTRAN 77",tnr) => (res, args', tnr'')

  rule	Print.print_buf "#-- generate_extcall_vardecls failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls (_,_,_,_,_) => fail

end

(** relation: generate_extcall_copydecls_f77
 **
 ** Helper relation to generate_extcall_vardecls
 **)
relation generate_extcall_copydecls_f77 : (DAE.Element list, int) => (CFunction, int) =

  axiom	generate_extcall_copydecls_f77 ([], tnr) => (c_empty_function, tnr)

  rule	let DAE.VAR(cref, vk, vd, ty, value, dims,start,_,_,_,_) = var &
	is_array var => true &
	var_name_external_cref cref => cref' &
	list_reverse dims => dims' &
	let extvar = DAE.VAR(cref', vk, vd, ty, value, dims',NONE,DAE.NON_FLOW,[],NONE,NONE) &
	generate_var_decl (extvar, tnr) => (fn, tnr') &
	generate_extcall_copydecls_f77 (rest, tnr') => (restfn, tnr''') &
	c_merge_fn (fn, restfn) => resfn
	--------------------------------
	generate_extcall_copydecls_f77 (var::rest, tnr) => (resfn,tnr''')

  rule	Debug.fprint("cgtr", "#--Ignoring: ") &
	Debug.fcall("cgtr", DAE.dump2, DAE.DAE([var])) &
	Debug.fprintln("cgtr", "") &
	generate_extcall_copydecls_f77 (rest, tnr) => (fn,tnr')
	-------------------------------------------------------
	generate_extcall_copydecls_f77 (var::rest, tnr) => (fn, tnr')

end

(** relation: generate_extcall_vardecls2
 **
 ** Helper relation to generate_extcall_vardecls
 **)

relation generate_extcall_vardecls2 : (DAE.ExtArg list, DAE.ExtArg) => CFunction =

  axiom	generate_extcall_vardecls2 ([],DAE.NOEXTARG) => c_empty_function

  rule	generate_extcall_vardecl retarg => retdecl
	-----------------------------------------
	generate_extcall_vardecls2 ([],retarg) => retdecl

  rule	generate_extcall_vardecl var => decl &
	generate_extcall_vardecls2 (rest, retarg) => decls &
	c_merge_fn(decl, decls) => res
	---------------------------------------------
	generate_extcall_vardecls2 (var::rest, retarg) => res

  rule	Print.print_buf "#-- generate_extcall_vardecls2 failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls2 (_,_) => fail

end

(** relation: generate_vardecl_func
 **
 ** Helper relation to generate_extcall_vardecl.
 **)

relation generate_vardecl_func : (string, string, string option) => CFunction =

  rule	Util.string_append_list ([tystr, " ", name, ";"]) => str &
	c_add_variables(c_empty_function, [str]) => f1 &
	Util.string_append_list ([name, " = (", tystr, ")", expr, ";"]) => str3 &
	c_add_statements(f1, [str3]) => res
	-----------------------------------------------
	generate_vardecl_func (tystr, name, SOME(expr)) => res

  rule	Util.string_append_list ([tystr, " ", name, ";"]) => str &
	c_add_variables(c_empty_function, [str]) => res
	-----------------------------------------------
	generate_vardecl_func (tystr, name, NONE) => res

end

(** relation: generate_extcall_vardecl
 **
 ** Helper relation to generate_extcall_vardecls.
 **)

relation generate_extcall_vardecl : DAE.ExtArg => CFunction =

	(* INPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) = arg &
	Types.is_array ty => false &
	Types.is_string ty => false &
	generate_type_external ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_vardecl_func (tystr, name, SOME(orgname)) => res
	--------------------------------------------------------
	generate_extcall_vardecl arg => res

	(* INPUT NON-ARRAY STRING *)
	(* do nothing *)

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) = arg &
	Types.is_array ty => true
	--------------------------------------------------------
	generate_extcall_vardecl arg => c_empty_function

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.OUTPUT), ty) = arg &
	Types.is_array ty => false &
	generate_type_external ty => tystr &
	var_name_external cref => name &
	generate_vardecl_func (tystr, name, NONE) => res
	--------------------------------------------------------
	generate_extcall_vardecl arg => res

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.OUTPUT), ty) = arg &
	Types.is_array ty => true
	---------------------------
	generate_extcall_vardecl arg => c_empty_function

(*
	(* INPUT/OUTPUT ARRAY/NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	generate_type_external ty => tystr &
	comp_ref_cstr cref => (name,_) &
	generate_vardecl_func (tystr, name, NONE) => res
	---------------------------
	generate_extcall_vardecl arg => res
*)

  axiom	generate_extcall_vardecl DAE.EXTARG(cr, attr, ty) => c_empty_function
  axiom	generate_extcall_vardecl DAE.EXTARGEXP(exp, ty) => c_empty_function

	(* SIZE *)
  axiom	generate_extcall_vardecl DAE.EXTARGSIZE(_,_,_,_) => c_empty_function


  rule	Print.print_buf "#-- generate_extcall_vardecl failed\n"
	-------------------------------------------------------
	generate_extcall_vardecl _ => fail

end


(** relation: generate_extcall_vardecls2_f77
 **
 ** Helper relation to generate_extcall_vardecls
 **)

relation generate_extcall_vardecls2_f77 : (DAE.ExtArg list, DAE.ExtArg, int)
	  => (CFunction, DAE.ExtArg list, int) =

  axiom	generate_extcall_vardecls2_f77 ([],DAE.NOEXTARG,tnr) => (c_empty_function,[],tnr)

  rule	generate_extcall_vardecl_f77 (retarg,tnr) => (retdecl,_,tnr')
	-------------------------------------------------
	generate_extcall_vardecls2_f77 ([],retarg,tnr) => (retdecl,[],tnr')

  rule	generate_extcall_vardecl_f77 (var,tnr) => (decl,var',tnr') &
	generate_extcall_vardecls2_f77 (rest, retarg, tnr') => (decls,varr, tnr'') &
	c_merge_fn(decl,decls) => res
	---------------------------------------------
	generate_extcall_vardecls2_f77 (var::rest, retarg, tnr) => (res, var'::varr, tnr'')

  rule	Print.print_buf "#-- generate_extcall_vardecls2_f77 failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls2_f77 (_,_,_) => fail

end

(** relation: generate_c_to_f77_converter
 **
 ** 
 **)

relation generate_c_to_f77_converter : Types.Type => string =

  rule	Types.array_element_type ty => elty &
	generate_type_internal_namepart elty => eltystr &
	Util.string_append_list (["convert_alloc_",eltystr,"_array_to_f77"]) => str
	---------------------------------------------------------------------
	generate_c_to_f77_converter (ty as (Types.T_ARRAY(_,_),_)) => str

  rule	Print.print_buf "#-- generate_c_to_f77_converter failed\n" &
	Print.print_buf "#-- Not an array?\n" &
	Types.print_type ty
	---------------------------------------------
	generate_c_to_f77_converter ty => fail

end

(** relation: generate_c_to_f77_converter
 **
 ** 
 **)

relation generate_f77_to_c_converter : Types.Type => string =

  rule	Types.array_element_type ty => elty &
	generate_type_internal_namepart elty => eltystr &
	Util.string_append_list (["convert_alloc_",eltystr,"_array_from_f77"]) => str
	---------------------------------------------------------------------
	generate_f77_to_c_converter (ty as (Types.T_ARRAY(_,_),_)) => str

  rule	Print.print_buf "#-- generate_f77_to_c_converter failed\n" &
	Print.print_buf "#-- Not an array?\n"
	---------------------------------------------
	generate_f77_to_c_converter _ => fail

end

(** relation: is_output_or_bidir
 **
 ** Returns true if attributes indicates an output or bidirectional variable.
 **)

relation is_output_or_bidir : Types.Attributes => bool =

  rule	Types.is_output_attr attr => outvar &
	Types.is_bidir_attr attr => bivar &
	bool_or (outvar, bivar) => res
	---------------------------------
	is_output_or_bidir attr => res
end

(** relation: generate_extcall_vardecl_f77
 **
 ** 
 **)

relation generate_extcall_vardecl_f77 : (DAE.ExtArg,int) => (CFunction, DAE.ExtArg, int) =

	(* INPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_1") &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77 (arg,tnr) => (res, arg, tnr)

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_2") &
	Types.is_input_attr attr => true &
	Types.is_array ty => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	----------------------------------------------------------------
	generate_extcall_vardecl_f77 (extarg, tnr) => (res, extarg, tnr)

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_3") &
	Types.is_output_attr attr => true &
	Types.is_array ty => false &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res,arg, tnr)

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_4") &
	Types.is_array ty => true &
	Types.is_output_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&out.", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	---------------------------
	generate_extcall_vardecl_f77 (extarg, tnr) => (res, extarg, tnr)

	(* INPUT/OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => true &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_41") &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res, arg, tnr)

	(* INPUT/OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_41") &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res, arg, tnr)


  rule	let DAE.EXTARGEXP(exp, ty) = arg &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res, arg, tnr)


	(* SIZE *)
  rule	let DAE.EXTARGSIZE(cr, attr, ty, dim) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_5") &
	var_name_array (cr,attr) => tmpname' &
	int_string tnr => tnrstr &
	int_add(tnr,1) => tnr' &
	Util.string_append_list([tmpname',"_size_",tnrstr]) => tmpstr &
	let tmpcref = Exp.CREF_IDENT(tmpstr,[]) &
	generate_ext_array_size_call arg => callstr &
	Util.string_append_list(["int ",tmpstr,";"]) => declstr &
	c_add_variables(c_empty_function, [declstr]) => decl &
	Util.string_append_list([tmpstr," = ",callstr,";"]) => callstr &
	c_add_statements(decl, [callstr]) => res &
	let newarg = DAE.EXTARGSIZE(tmpcref, attr, ty, dim)
	-----------------------------------------------------------------
	generate_extcall_vardecl_f77 (arg, tnr)  => (res, newarg, tnr')


  rule	Print.print_buf "#-- generate_extcall_vardecl_f77 failed\n#-- " &
	DAE.dump_ext_arg_str arg => argstr &
	Print.print_buf argstr & Print.print_buf "\n"
	-------------------------------------------------------
	generate_extcall_vardecl_f77 (arg,_) => fail

end

(** relation: generate_ext_call_fcall
 ** 
 **  
 **)
relation generate_ext_call_fcall : (Ident, DAE.ExtArg list, 
				    DAE.ExtArg, 
				    string)  (* language *)
	  => CFunction =

	(* call without return value *)
  rule	generate_ext_call_fcall2 (fnname,args,lang) => fcall2 &
	string_append(fcall2, ";") => str &
	c_add_statements(c_empty_function, [str]) => res
	---------------------------------------------
	generate_ext_call_fcall (fnname, args, DAE.NOEXTARG, lang) => res

	(* return value assignment, shouldn't happen for arrays *)
  rule	Types.is_array ty => false &
	generate_ext_call_fcall2 (fnname,args,lang) => fcall2 &
	var_name_external cr => crstr &
	Util.string_append_list([crstr," = ", fcall2, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	---------------------------------------------
	generate_ext_call_fcall (fnname, args, DAE.EXTARG(cr,_,ty), lang) => res

  rule	Print.print_buf "#-- generate_ext_call_fcall failed\n"
	------------------------------------------------------
	generate_ext_call_fcall (_,_,_,_) => fail

end	

(** relation: generate_ext_call_fcall2
 **
 ** Helper relation to generate_ext_call_fcall
 **)

relation generate_ext_call_fcall2 : (Ident, DAE.ExtArg list, string) => string =

  rule	Util.list_map (args, generate_ext_call_fcall_arg) => strlist &
	Util.string_delimit_list (strlist, ", ") => str &
	Util.string_append_list([n,"(",str,")"]) => res
	-----------------------------------------------
	generate_ext_call_fcall2 (n, args, "C") => res

  rule	Util.list_map (args, generate_ext_call_fcall_arg_f77) => strlist &
	Util.string_delimit_list (strlist, ", ") => str &
	Util.string_append_list([n,"_(",str,")"]) => res
	-----------------------------------------------
	generate_ext_call_fcall2 (n, args, "FORTRAN 77") => res

  rule	Print.print_buf "#-- generate_ext_call_fcall2 failed\n"
	------------------------------------------------------
	generate_ext_call_fcall2 (_,_,_) => fail

end

(** relation: generate_ext_call_fcall_arg
 **
 ** LS: is_array AND is_string, string has also .data
 **)
	    
relation generate_ext_call_fcall_arg : DAE.ExtArg => string =

	(* INPUT NON-ARRAY NON-STRING *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	Types.is_string ty => false &
	var_name_external cref => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* INPUT/OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => true &
	var_name_array (cref,attr) => name &
	string_append(name,".data") => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* INPUT/OUTPUT STRING *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_string ty => true &
	comp_ref_cstr cref => (name,_) &
	string_append(name, ".data") => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* INPUT/OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

  rule	let DAE.EXTARGEXP(exp, ty) = arg &
	generate_expression (exp,1) => (_, res, _)
	------------------------------------------
	generate_ext_call_fcall_arg arg => res

	(* SIZE *)
  rule	generate_array_size_call arg => str
	-----------------------------
	generate_ext_call_fcall_arg (arg as DAE.EXTARGSIZE(_,_,_,_)) => str


  rule	Print.print_buf "#-- generate_ext_call_fcall_arg failed\n" &
	DAE.dump_ext_arg_str arg => str &
	Print.print_buf str & Print.print_buf "\n"
	----------------------------------------------------------
	generate_ext_call_fcall_arg arg => fail

end

(** relation: generate_ext_call_fcall_arg_f77
 **
 ** 
**)

relation generate_ext_call_fcall_arg_f77 : DAE.ExtArg => string =

	(* INPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_output_attr attr => true &
	Types.is_array ty => false &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_input_attr attr => true &
	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name,".data") => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_output_attr attr => true &
	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name,".data") => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* INPUT/OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name, ".data") => res
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* INPUT/OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res


  rule	let DAE.EXTARGEXP(exp, ty) = arg &
	generate_ext_call_fcall_arg arg => res
	--------------------------------------
	generate_ext_call_fcall_arg_f77 arg => res


	(* SIZE *)
  rule	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 DAE.EXTARGSIZE(cref, attr, ty, dim) => res


  rule	Print.print_buf "#-- generate_ext_call_fcall_arg_f77 failed\n#-- " &
	DAE.dump_ext_arg_str arg => str &
	Print.print_buf str &
	Print.print_buf "\n"
	----------------------------------------------------------
	generate_ext_call_fcall_arg_f77 arg => fail

end

(** relation: generate_array_size_call
 **
 ** 
 **)

relation generate_array_size_call : DAE.ExtArg => string = 

  rule	Types.array_element_type ty => ((Types.T_INTEGER(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_integer_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Types.array_element_type ty => ((Types.T_REAL(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_real_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Print.print_buf "#-- generate_array_size_call failed\n#-- Not a DAE.EXTARGSIZE?\n"
	----------------------------------------------------------------------------------
	generate_array_size_call _ => fail
	
end

(** relation: generate_ext_array_size_call
 **
 **
 **)

relation generate_ext_array_size_call : DAE.ExtArg => string = 

  rule	Types.array_element_type ty => ((Types.T_INTEGER(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_integer_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_ext_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Types.array_element_type ty => ((Types.T_REAL(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_real_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_ext_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Print.print_buf "#-- generate_array_size_call failed\n#-- Not a DAE.EXTARGSIZE?\n"
	----------------------------------------------------------------------------------
	generate_ext_array_size_call _ => fail
	
end

(** relation:  is_extarg_output
 **
 ** Succeeds if variable is external argument and output.
 **)

relation is_extarg_output : DAE.ExtArg => () =

  axiom	is_extarg_output DAE.EXTARG(_,Types.ATTR(_,_,_,Absyn.OUTPUT),_)

end

(** relation:  is_extarg_output
 **
 ** Succeeds if variable is external argument and bidirectional.
 **)

relation is_extarg_bidir : DAE.ExtArg => () =

  axiom	is_extarg_bidir DAE.EXTARG(_,Types.ATTR(_,_,_,Absyn.BIDIR),_)

end

(** relation:  is_extarg_output_or_bidir
 **
 ** Succeeds if variable is external argument and output or bidirectional.
 **)

relation is_extarg_output_or_bidir : DAE.ExtArg => () =

  rule	is_extarg_output arg
	--------------------
	is_extarg_output_or_bidir arg

  rule	is_extarg_bidir arg
	--------------------
	is_extarg_output_or_bidir arg

end

(** relation: generate_extcall_varcopy
 **
 **
 **)

relation generate_extcall_varcopy : (DAE.ExtArg list, 
				     DAE.ExtArg, 
				     string, (* language *)
				     int) => (CFunction, int) =

  axiom	generate_extcall_varcopy ([],DAE.NOEXTARG,_,tnr) => (c_empty_function,tnr)

  rule	is_extarg_output retarg & 
	generate_extcall_varcopy_single retarg => retcopy
	--------------------------------------------------------------
	generate_extcall_varcopy ([],retarg,lang,tnr) => (retcopy,tnr)

  rule	not is_extarg_output retarg
	-----------------------------------------
	generate_extcall_varcopy ([],retarg,lang,tnr) => (c_empty_function,tnr)

	(* extarg list is already filtered and contains only outputs *)
  rule	generate_extcall_varcopy_single var => vc &
	generate_extcall_varcopy (rest, retarg, lang,tnr) => (vcr,tnr') &
	c_merge_fn(vc, vcr) => res
	--------------------------------------------------
	generate_extcall_varcopy (var::rest, retarg, lang as "C", tnr) => (res,tnr')

  rule	generate_extcall_varcopy_single_f77 var => vc &
	generate_extcall_varcopy (rest, retarg, lang, tnr) => (vcr,tnr') &
	c_merge_fn(vc, vcr) => res
	--------------------------------------------------
	generate_extcall_varcopy (var::rest, retarg, lang as "FORTRAN 77", tnr) => (res,tnr')

  rule	Print.print_buf "#-- generate_extcall_varcopy failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy (_,_,_,_) => fail

end

(** relation: generate_extcall_varcopy_single
 **
 ** Helper relation to generate_extcall_varcopy
 **)

relation generate_extcall_varcopy_single : DAE.ExtArg => CFunction =

  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) => res

  rule	Types.is_array ty => true &
	Types.is_output_attr attr => true
	---------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) 
	  => c_empty_function

  axiom	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) => c_empty_function

  rule	Print.print_buf "#-- generate_extcall_varcopy_single failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy_single _ => fail

end

(** relation: generate_extcall_varcopy_single_f77
 **
 ** Helper relation to generate_extcall_varcopy
 **)

relation generate_extcall_varcopy_single_f77 : DAE.ExtArg => CFunction =

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_input_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res 
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res

	(* OUTPUT NON-ARRAY *)
  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, attr, ty) => res

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_output_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &out.", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res


	(* BIDIR ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_bidir_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res

  axiom	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, attr, ty) => c_empty_function

  rule	Print.print_buf "#-- generate_extcall_varcopy_single_f77 failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy_single_f77 _ => fail

end

(** relation: invar_names
 **
 ** Returns a string list of all input parameter names.
 **)

relation invar_names : DAE.Element list => string list =

  axiom	invar_names [] => []


  rule	comp_ref_cstr id => (cref_str,_) &
	invar_names r => r'
	----------
	invar_names DAE.VAR(id,vk,DAE.INPUT,t,_,_,_,_,_,_,_)::r => cref_str::r'

  rule	invar_names r => cfn
	-------
	invar_names _::r => cfn

end

(** relation: var_name_external
 **
 ** Returns the variable name of a variable used in an external function.
 **)

relation var_name_external : Exp.ComponentRef => string =

  rule	var_name_external_cref cref => cref' &
	comp_ref_cstr cref' => (str, _)
	---------------------------------------
	var_name_external cref => str

end

(** relation: var_name_external_cref
 **
 ** Helper relation to var_name_external.
 **)

relation var_name_external_cref : Exp.ComponentRef => Exp.ComponentRef =

  rule	suffix_cref (cref,"_ext") => cref'
	---------------------------------------
	var_name_external_cref cref => cref'
end


(** relation: suffix_cref
 **
 ** Prepends a string, suffix, to a ComponentRef.
 **)

relation suffix_cref : (Exp.ComponentRef, string) => Exp.ComponentRef =

  rule	string_append(id, str) => id'
	--------------------------------
	suffix_cref (Exp.CREF_IDENT(id,subs), str) => Exp.CREF_IDENT(id',subs)

  rule	suffix_cref (cref,str) => cref'
	---------------------------------------
	suffix_cref (Exp.CREF_QUAL(id,subs,cref), str) => Exp.CREF_QUAL(id,subs,cref')
end

(** relation: var_name_array
 **
 ** 
 **)

relation var_name_array : (Exp.ComponentRef, Types.Attributes) => string =

	(* INPUT *)
  rule	comp_ref_cstr cref => (str, _) &
	Types.is_input_attr attr => true
	---------------------------------------
	var_name_array (cref,attr) => str

	(* OUTPUT *)
  rule	comp_ref_cstr cref => (cref_str, _) &
	Types.is_output_attr attr => true &
	string_append ("out.", cref_str) => str
	---------------------------------------
	var_name_array (cref,attr) => str

	(* INPUT/OUTPUT *)
  rule	comp_ref_cstr cref => (str, _)
	---------------------------------------
	var_name_array (cref,attr) => str

end

(** relation: var_arg_names_external
 **
 **
 **)

relation var_arg_names_external : DAE.Element list => string list =

  axiom	var_arg_names_external [] => []


  rule	var_name_external id => cref_str &
	var_arg_names_external r => r'
	----------------------------
	var_arg_names_external DAE.VAR(id,vk,DAE.INPUT,t,_,_,_,_,_,_,_)::r => cref_str::r'

  rule	var_name_external id => cref_str &
	string_append("&", cref_str) => cref_str2 &
	var_arg_names_external r => r'
	----------------------------
	var_arg_names_external DAE.VAR(id,vk,DAE.OUTPUT,t,_,_,_,_,_,_,_)::r => cref_str2::r'

  rule	var_arg_names_external r => cfn
	-----------------------------
	var_arg_names_external _::r => cfn

end

(** relation: generate_read
 **
 **
 **)

relation generate_read : DAE.Element list => CFunction =

  axiom	generate_read [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["if(read_",type_string,"(in_file, &",cref_str,")) return 1;"])
	  => stmt &
	  
	c_add_inits(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,[],_,_,_,_,_)::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["if(read_",type_string,"(in_file, &",cref_str,")) return 1;"])
	  => stmt &
	  
	c_add_inits(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,_::_,_,_,_,_,_)::r => cfn

	
  rule	generate_read r => cfn
	-------
	generate_read _::r => cfn


end

(** relation: generate_write
 **
 **
**)

relation generate_write : DAE.Element list => CFunction =

  axiom	generate_write [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,[],_,_,_,_,_)::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,_::_,_,_,_,_,_)::r => cfn

	
  rule	generate_write r => cfn
	-------
	generate_write _::r => cfn


end

(** relation: is_rcw_output
 **
 **
 **)

relation is_rcw_output : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_output_var e
	--------------------
	is_rcw_output e 

end

(** relation: is_rcw_input
 **
 **
 **)

relation is_rcw_input : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_input_var e
	--------------------
	is_rcw_input e 

end

(** relation: is_rcw_bidir
 **
 **
 **)
relation is_rcw_bidir : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_bidir_var e
	--------------------
	is_rcw_bidir e 

end


