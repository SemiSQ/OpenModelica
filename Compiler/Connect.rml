(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Connect.rml
 ** module:      Connect
 ** description: Connection set management
 **
 ** RCS: $Id$
 **
 ** Connections generate connection sets (datatype SET is described below)
 ** which are constructed during instantiation.  When a connection 
 ** set is generated, it is used to create a number of equations. 
 ** The kind of equations created depends on the type of the set. 
 ** 
 ** Connect.rml is called from Inst.rml and is responsible for 
 ** creation of all connect-equations later passed to the DAE module 
 ** in DAE.rml.
 ** 
 **)

module Connect :

  with "Exp.rml"
  with "Static.rml"
  with "DAE.rml"
  with "Env.rml"

  datatype Face = INNER | OUTER
  (** This type indicates whether a connector is an inner or an outer
   ** connector.  *)

  datatype Set = EQU of Exp.ComponentRef list
	       | FLOW of (Exp.ComponentRef * Face) list

  (** A connection set is represented using the `Set' type. *)

  datatype Sets = SETS of Set list * (* connection_set *)
		      Exp.ComponentRef list (* connect_refs - list of 
					     * crefs in connect statements.*)

(* The connection 'Sets' contains the connection set and a list of 
 * component references occuring in connect statemens. The latter is 
 * used only when evaluating the cardinality operator. It is passed -into-
 * classes to be instantiated, while the 'Set list' is returned -from-
 * instantiated classes. 
 *)

val empty_set : Sets

relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets
relation add_array_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef, int) => Sets
relation add_flow : (Sets,
		     Exp.ComponentRef, Face,
		     Exp.ComponentRef, Face) => Sets
relation print_sets : Sets => ()
relation print_sets_str : Sets => string
relation equations : (Sets) => DAE.Element list
relation unconnected_flow_equations : (Sets, DAE.Element list, Env.Env,bool (* CallingScope*)) 
	  => DAE.Element list
end

val empty_set = SETS([],[])

(**
 ** - Adding
 **
 ** The two relations `add_eq' and `add_flow' addes a variable to a
 ** connection set.  The first relation is used to add a non-flow
 ** variable, and the second is used to add a flow variable.  When
 ** two component are to be added to a collection of connection sets,
 ** the connections sets containg the components have to be located.
 ** If no such set exists, a new set containing only the new component
 ** is created.
 **
 ** If the connection sets containing the two components are not the
 ** same, they are merged.
 **)

(** relation: add_equ
 **
 ** Adds an equal equation, see explaining text above.
 **)

relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets =

  rule	find_equ_set(ss,r1) => s1 &
	find_equ_set(ss,r2) => s2 &
	merge(ss,s1,s2) => ss'
	----------------------
	add_equ(ss,r1,r2) => ss'
	
end

(** relation: add_flow
 ** 
 ** Adds an flow equation, see add_equ above.
 **)

relation add_flow : (Sets, Exp.ComponentRef, Face, Exp.ComponentRef, Face)
	  => Sets =

  rule	find_flow_set(ss,r1,d1) => s1 &
	find_flow_set(ss,r2,d2) => s2 &
	merge(ss,s1,s2) => ss'
	----------------------
	add_flow(ss,r1,d1,r2,d2) => ss'
	
end


(** relation: add_array_equ
 **
 ** For connecting two arrays, an equal equation for each index should 
 ** be generated.
 **)

relation add_array_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef, int) => Sets =

  axiom	add_array_equ(s,_,_,0) => s

  rule	Exp.subscript_cref(r1,[Exp.INDEX(Exp.ICONST(i))]) => r1' &
	Exp.subscript_cref(r2,[Exp.INDEX(Exp.ICONST(i))]) => r2' &
	int_sub(i,1) => i' &
	find_equ_set(ss,r1') => s1 &
	find_equ_set(ss,r2') => s2 &
	merge(ss,s1,s2) => ss' &
	add_array_equ(ss',r1,r2,i') => ss''	
	----------------------
	add_array_equ(ss,r1,r2,i) => ss''
end


(**
 ** - Equation generation
 **)

(** relation: equations
 **
 ** From a number of connection sets, this relation generates a list
 ** of equations.
 **)

relation equations : (Sets)
	  => DAE.Element list =



  axiom	equations( SETS([],_)) => []

  rule	equ_equations cs => dae1 &
	equations(SETS(ss,crs)) => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations(SETS(EQU(cs)::ss,crs)) => dae

  rule	flow_equations cs => dae1 &
	equations(SETS(ss,crs)) => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations(SETS(FLOW(cs)::ss,crs)) => dae

end

(** relation: equ_equations
 ** 
 ** A non-flow connection set contains a number of components.
 ** Generating the equation from this set means equating all the
 ** components.  For n components, this will give n-1 equations.
 **
 ** For example, if the set contains the components `x', `y.a' and
 ** `z.b', the equations generated will me `x = y.a' and `y.a = z.b'.
 **)

relation equ_equations : Exp.ComponentRef list => DAE.Element list =

  axiom	equ_equations [_] => []

  rule	equ_equations (y::cs) => eq
	------------------------
	equ_equations x::y::cs
	  => DAE.EQUATION(Exp.CREF(x,Exp.OTHER), Exp.CREF(y,Exp.OTHER))::eq
end

(** relation: flow_equations
 ** 
 ** Generating equations from a flow connection set is a little
 ** trickier that from a non-flow set.  Only one equation is
 ** generated, but it has to consider whether the comoponents were
 ** inner or outer connectors.
 **
 ** This relation uses `flow_sum' to create the sum of all components
 ** (some of which will be negated), and the returns the equation
 ** where this sum is equal to 0.0.
 **)

relation flow_equations : (Exp.ComponentRef * Face) list => DAE.Element list =

  rule	flow_sum cs => sum
	------------------
	flow_equations cs => [DAE.EQUATION(sum, Exp.RCONST(0.0))]

end

(** relation: flow_sum
 ** 
 ** This relation creates an exression expressing the sum of all
 ** components in the given list.  Before adding the component to the
 ** sum, it is passed to `sign_flow' which will negate all outer
 ** connectors.
 **)

relation flow_sum : (Exp.ComponentRef * Face) list => Exp.Exp =

  rule	sign_flow(c,f) => exp
	-------------------
	flow_sum [(c,f)] => exp

  rule	sign_flow(c,f) => exp1 &
	flow_sum cs => exp2
	------------------
	flow_sum ((c,f)::cs) => Exp.BINARY(exp1, Exp.ADD(Exp.REAL), exp2)

end

(** relation: sign_flow
 **
 ** This relation takes a name of a component and a `Face', returns an
 ** expression.  If the face is `INNER' the expression simply contains
 ** the component reference, but if it is `OUTER', the expression is
 ** negated.
 **)

relation sign_flow : (Exp.ComponentRef, Face) => Exp.Exp =

  axiom	sign_flow (c,INNER) => Exp.CREF(c,Exp.OTHER)
  axiom	sign_flow (c,OUTER) => Exp.UNARY(Exp.UMINUS(Exp.REAL),Exp.CREF(c,Exp.OTHER))

end

(**
 ** - Lookup
 ** 
 ** These relations are used to find and create connection sets.
 **)

(** relation: find_equ_set
 **
 ** This relation finds a non-flow connection set that contains the
 ** component named by the second argument.  If no such set is found,
 ** a new set is created.
 **)

relation find_equ_set : (Sets, Exp.ComponentRef) => Set =

  rule	new_equ_set c => s
	------------------
	find_equ_set(SETS([],_),c) => s

  rule	find_in_set(s,c)
	----------------
	find_equ_set(SETS(s::_,_),c) => s

  rule	find_equ_set(SETS(ss,crs),c) => s
	-------------------
	find_equ_set(SETS(_::ss,crs),c) => s

end	

(** relation: find_flow_set
 **
 ** This relation finds a flow connection set that contains the
 ** component named by the second argument.  If no such set is found,
 ** a new set is created.
 **)

relation find_flow_set : (Sets, Exp.ComponentRef, Face) => Set =

  rule	new_flow_set(c,d) => s
	------------------
	find_flow_set(SETS([],_),c,d) => s

  rule	find_in_set(s,c)
	----------------
	find_flow_set(SETS(s::_,_),c,d) => s

  rule	find_flow_set(SETS(ss,crs),c,d) => s
	-------------------
	find_flow_set(SETS(_::ss,crs),c,d) => s

end	

(** relation: find_in_set
 ** 
 ** This relation checks if a componet already appears in a given
 ** connection set.
 **)

relation find_in_set : (Set, Exp.ComponentRef) => () =

  rule	find_in_set_equ(cs,c)
	---------------------
	find_in_set(EQU(cs), c)

  rule	find_in_set_flow(cs, c)
	-----------------------
	find_in_set(FLOW(cs), c)

end

(** relation: find_in_set_equ
 ** 
 ** This is a version of `find_in_set' which is specialized on
 ** non-flow connection sets
 **)

relation find_in_set_equ : (Exp.ComponentRef list, Exp.ComponentRef) => () =

  rule	Static.eq_cref(c1,c2)
	------------------
	find_in_set_equ(c1::_,c2)

  rule	find_in_set_equ(cs,c2)
	----------------------
	find_in_set_equ(_::cs,c2)

end

(** relation: find_in_set_flow
 ** 
 ** This is a version of `find_in_set' which is specialized on
 ** flow connection sets
 **)

relation find_in_set_flow : ((Exp.ComponentRef * Face) list, Exp.ComponentRef)
	  => () =

  rule	Static.eq_cref(c1,c2)
	------------------
	find_in_set_flow((c1,_)::_,c2)

  rule	find_in_set_flow(cs,c2)
	----------------------
	find_in_set_flow(_::cs,c2)

end

(** relation: new_equ_set
 **
 ** This relation creates a new non-flow connection set containing
 ** only the given component.
 **)

relation new_equ_set : Exp.ComponentRef => Set =

  axiom	new_equ_set c => EQU([c])

end

(** relation: new_flow_set
 **
 ** This relation creates a new-flow connection set containing only
 ** the given component.
 **)

relation new_flow_set : (Exp.ComponentRef, Face) => Set =

  axiom	new_flow_set(c,d) => FLOW([(c,d)])

end

(**
 ** - Merging
 ** 
 ** The result of merging two connection sets is the intersection of
 ** the two sets.
 **)

relation merge : (Sets, Set, Set) => Sets =

  rule	s1 = s2
	-------
	merge(SETS(ss,crs),s1,s2) => SETS(ss,crs)

  rule	list_append(cs1,cs2) => cs &
	remove_set2(SETS(ss,crs),s1,s2) => SETS(ss',_)
	----------------------------
	merge(SETS(ss,crs), s1 as EQU(cs1), s2 as EQU(cs2)) 
	  => SETS(EQU(cs)::ss',crs)

  rule	list_append(cs1,cs2) => cs &
	remove_set2(SETS(ss,crs),s1,s2) => SETS(ss',_)
	----------------------------
	merge(SETS(ss,crs), s1 as FLOW(cs1), s2 as FLOW(cs2)) 
	  => SETS(FLOW(cs)::ss',crs)

end

(** relation: remove_set2
 ** 
 ** This relation removes the two sets given in the second and third
 ** argument from the collection of sets given in the first argument.
 **)

relation remove_set2 : (Sets, Set, Set) => Sets =

  axiom	remove_set2(SETS([],crs),_,_) => SETS([],crs)

  rule	s = s1 &
	remove_set(SETS(ss,crs),s2) => ss'
	------------------------
	remove_set2(SETS(s::ss,crs), s1, s2) => ss'
	
  rule	s = s2 &
	remove_set(SETS(ss,crs),s1) => ss'
	------------------------
	remove_set2(SETS(s::ss,crs), s1, s2) => ss'
	
  rule	remove_set2(SETS(ss,crs),s1,s2) => SETS(ss',_)
	------------------------
	remove_set2(SETS(s::ss,crs), s1, s2) => SETS(s::ss',crs)

end

(** relation: remove_set
 **
 ** This relation removes one set from a list of sets.
 **)

relation remove_set : (Sets, Set) => Sets =

  axiom	remove_set(SETS([],crs),_) => SETS([],crs)

  rule	s = s1
      	------
      	remove_set(SETS(s::ss,crs), s1) => SETS(ss,crs)
      
  rule	remove_set(SETS(ss,crs),s1) => SETS(ss',_)
      	------------------------
      	remove_set(SETS(s::ss,crs), s1) => SETS(s::ss',crs)
	
end

(* Unconnected flow variables. *)

(** relation: unconnected_flow_equations 
 **
 ** This relation will generate set-to-zero equations for INNER flow variables.
 ** It can not generate for outer flow varaibles, since we do not yet know if 
 ** these are connected or not. This is only known in the preceding recursive 
 ** call. However, the top call must generate for both inner and outer 
 ** connectors, hence the last argument, true for top call*)

relation unconnected_flow_equations : (Sets, DAE.Element list, Env.Env,bool) => DAE.Element list =

  rule	(* if outermost call look at both inner and outer unconnected connectors *)
	Env.local_outside_connector_flowvars(env) => v1 &
	Env.local_inside_connector_flowvars(env) => v2 &
	list_append(v1,v2) => vars &
	get_all_flow_variables(csets) => vars2 &
	remove_variables(vars,vars2) => unconnectedvars &
	generate_zeroflow_equations(unconnectedvars) => dae'
	----------------------------------
	unconnected_flow_equations(csets,dae,env,true) => dae'

	(* If not outermost call, only look at unconnected inner connectors *)
  rule	Env.local_inside_connector_flowvars(env) => vars &
 	get_all_flow_variables(csets) => vars2 &
	remove_variables(vars,vars2) => unconnectedvars &
 	generate_zeroflow_equations(unconnectedvars) => dae'
	----------------------------------
	 unconnected_flow_equations(csets,dae,env,true) => dae'

  rule	(*Debug.fprint("failtrace","-unconnected_flow_equations failed\n") *)
	----------------------------------
	unconnected_flow_equations(csets,dae,env,_) => []
end

(** relation: remove_variables
 **
 ** Removes all the variables in the second list from the first list.
 **)

relation remove_variables: (Exp.ComponentRef list, (* vars*)
			    Exp.ComponentRef list) (* remove *)
	  => Exp.ComponentRef list =
  axiom	remove_variables(vars,[]) => vars 

  rule	remove_variable(r1,vars) => vars' &
	remove_variables(vars',removelist) => res
	-----------------------------------------
	remove_variables(vars,r1::removelist) => res
end

(** relation: remove_variable
 **
 ** Removes a variable from a list of variables.
 **)

relation remove_variable: (Exp.ComponentRef, Exp.ComponentRef list) 
	  => Exp.ComponentRef list =

  axiom	remove_variable(cr,[]) => [] 

  rule	Exp.cref_equal(cr,cr2) => true
	------------------------------
	remove_variable(cr,cr2::xs) => xs

  rule	remove_variable(cr,xs) => res
	------------------------------
	remove_variable(cr,cr2::xs) => cr2::res
end

(** relation: generate_zeroflow_equations
 **
 ** Unconnected flow variables should be set to zero. This relation 
 ** generates equations setting each variable in the list to zero.
**)

relation generate_zeroflow_equations: Exp.ComponentRef list 
	  => DAE.Element list =
  axiom	generate_zeroflow_equations ([]) => []

  rule	generate_zeroflow_equations(xs) => res 
	--------------------------------------
	generate_zeroflow_equations(cr::xs) 
	  => DAE.EQUATION(Exp.CREF(cr,Exp.REAL),Exp.RCONST(0.0))::res
end


(** relation: get_all_flow_variables
 ** 
 ** Return a list of all flow variables from the connection sets.
 **)

relation get_all_flow_variables: Sets => Exp.ComponentRef list =

  axiom	get_all_flow_variables SETS([],_) => []

  rule	Util.list_map(varlst,Util.tuple2_1) => res1 &
	get_all_flow_variables(SETS(xs,crs)) => res2 &
	list_append(res1,res2) => res
	---------------------------------- 
	get_all_flow_variables(SETS(FLOW(varlst)::xs,crs)) => res 

  rule	get_all_flow_variables(SETS(xs,crs)) => res 
	---------------------------------- 
	get_all_flow_variables(SETS(EQU(res1)::xs,crs)) => res 
end

(** relation: get_inner_flow_variables
 **
 ** Get all flow variables that are inner variables from the Sets.
 **)

relation get_inner_flow_variables: Sets => Exp.ComponentRef list =

  axiom	get_inner_flow_variables(SETS([],_)) => []

  rule	get_inner_flow_variables_2(vars) => res1 &
	get_inner_flow_variables(SETS(xs,crs)) => res2 &
	list_append(res1,res2) => res
	---------------------------------- 
	get_inner_flow_variables(SETS(FLOW(vars)::xs,crs)) => res 

  rule	get_inner_flow_variables(SETS(xs,crs)) => res
	---------------------------------- 
	get_inner_flow_variables(SETS(EQU(_)::xs,crs)) => res 

  rule	(*Debug.fprint("failtrace","-get_inner_flow_variables failed\n")*)
	----------------------------------
	get_inner_flow_variables(_) => fail 
end

(** relation: get_inner_flow_variables_2
 **
 ** Help relation to get_inner_flow_variables.
 **)

relation get_inner_flow_variables_2: (Exp.ComponentRef * Face) list 
	  => Exp.ComponentRef list =

  axiom	get_inner_flow_variables_2 ([]) => []

  rule	get_inner_flow_variables_2(xs) => res
	-------------------------------------
	get_inner_flow_variables_2( (cr,INNER)::xs) => cr::res

  rule	get_inner_flow_variables_2(xs) => res
	-------------------------------------
	get_inner_flow_variables_2( _::xs) => res

  rule	(*Debug.fprint("failtrace","-get_inner_flow_variables_2 failed\n")*)
	----------------------------------
	get_inner_flow_variables_2(_) => fail 
end


(**
 ** - Printing
 **
 ** These are a few relations used for printing a description of the
 ** connection sets.  The implementation is excluded from the report
 ** for brevity.
 **)

(*!ignorecode*)

with "Dump.rml"
with "Print.rml"
with "Util.rml"
with "Debug.rml"

(** relation: print_sets
 **
 ** Prints a description of a number of connection sets to the
 ** standard output.
 **)

relation print_sets : Sets => () =

  axiom	print_sets SETS([],_)

  rule	print_set x &
	print_sets SETS(xs,crs)
	------------
	print_sets SETS(x::xs,crs)

end
(**)
relation print_set : Set => () =

  rule	Print.print_buf " non-flow set: { " &
	Exp.print_list(cs, Exp.print_component_ref, ", ") &
	Print.print_buf " }\n"
	----------------------------------------------------
	print_set EQU(cs)

  rule	Print.print_buf " flow set: { " &
	Exp.print_list(cs, print_flow_ref, ", ") &
	Print.print_buf " }\n"
	----------------------------------------------------
	print_set FLOW(cs)

end
(**)
relation print_flow_ref : (Exp.ComponentRef * Face) => () =

  rule	Exp.print_component_ref c &
	Print.print_buf " INNER"
	-----------
	print_flow_ref((c,INNER))

  rule	Exp.print_component_ref c &
	Print.print_buf " OUTER"
	-----------
	print_flow_ref((c,OUTER))

end

(** relation: print_sets_str
 **
 ** Prints a description of a number of connection sets to a string
 **)

relation print_sets_str : Sets => string =



  rule	Util.list_map(sets,print_set_str) => s1 &
	Util.string_delimit_list(s1, ", ") => s1' &
	print_set_crs_str crs => s2 &
	Util.string_append_list(["SETS(\n  ",s1',",\n  ",s2,"\n)\n"]) => res
	------------
	print_sets_str SETS(sets,crs) => res
end


(**)
relation print_set_str : Set => string =

  rule	Util.list_map(cs, Exp.print_component_ref_str) => strs &
	Util.string_delimit_list(strs,", ") => s1 &
	Util.string_append_list([" non-flow set: { ",s1,"}"]) => res
	----------------------------------------------------
	print_set_str EQU(cs) => res

  rule  Util.list_map(cs, print_flow_ref_str) => strs &
	Util.string_delimit_list(strs,", ") => s1 &
	Util.string_append_list([" flow set: { ",s1,"}"]) => res
	----------------------------------------------------
	print_set_str FLOW(cs) => res
end
relation print_flow_ref_str : (Exp.ComponentRef * Face) => string =

  rule	Exp.print_component_ref_str c => s &
	string_append(s, " INNER") => res
	-----------
	print_flow_ref_str((c,INNER))=> res

  rule	Exp.print_component_ref_str c => s &
	string_append(s, " OUTER") => res
	-----------
	print_flow_ref_str((c,OUTER)) => res

end

relation print_set_crs_str : Exp.ComponentRef list => string =

  rule	Util.list_map(crs,Exp.print_component_ref_str) => c_strs &
	Util.string_delimit_list(c_strs, ", ") => s &
	Util.string_append_list([" connect crs: { ",s,"}"]) => res
	----------------------------------------------------
	print_set_crs_str crs => res
end
(**)

(*!includecode*)

