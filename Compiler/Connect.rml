(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 Connect.rml
 ** module:      Connect
 ** description: Connection set management
 **
 ** RCS: $Id$
 **
 ** Connections generate connection sets (datatype SET is described below)
 ** which are constructed during instantiation.  When a connection 
 ** set is generated, it is used to create a number of equations. 
 ** The kind of equations created depends on the type of the set. 
 ** 
 ** Connect.rml is called from Inst.rml and is responsible for 
 ** creation of all connect-equations later passed to the DAE module 
 ** in DAE.rml.
 ** 
 **)

module Connect :

  with "Exp.rml"
  with "Static.rml"
  with "DAE.rml"
  with "Env.rml"

  datatype Face = INNER | OUTER
  (** This type indicates whether a connector is an inner or an outer
   ** connector.  *)

  datatype Set = EQU of Exp.ComponentRef list
	       | FLOW of (Exp.ComponentRef * Face) list

  type Sets = Set list
  (** A connection set is represented using the `Set' type. *)

  relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets
  relation add_array_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef, int) => Sets
  relation add_flow : (Sets,
		       Exp.ComponentRef, Face,
		       Exp.ComponentRef, Face) => Sets
  relation print_sets : Sets => ()
  relation equations : Sets => DAE.Element list
  relation unconnected_flow_equations : (Sets, DAE.Element list, Env.Env,bool (* CallingScope*)) 
	  => DAE.Element list
end


(**
 ** - Adding
 **
 ** The two relations `add_eq' and `add_flow' addes a variable to a
 ** connection set.  The first relation is used to add a non-flow
 ** variable, and the second is used to add a flow variable.  When
 ** two component are to be added to a collection of connection sets,
 ** the connections sets containg the components have to be located.
 ** If no such set exists, a new set containing only the new component
 ** is created.
 **
 ** If the connection sets containing the two components are not the
 ** same, they are merged.
 **)

relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets =

  rule	find_equ_set(ss,r1) => s1 &
	find_equ_set(ss,r2) => s2 &
	merge(ss,s1,s2) => ss'
	----------------------
	add_equ(ss,r1,r2) => ss'
	
end

(**)

relation add_flow : (Sets, Exp.ComponentRef, Face, Exp.ComponentRef, Face)
	  => Sets =

  rule	find_flow_set(ss,r1,d1) => s1 &
	find_flow_set(ss,r2,d2) => s2 &
	merge(ss,s1,s2) => ss'
	----------------------
	add_flow(ss,r1,d1,r2,d2) => ss'
	
end


(* For connecting two arrays, an equal equation for each index should be generated.*)

relation add_array_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef, int) => Sets =

  axiom	add_array_equ(s,_,_,0) => s

  rule	Exp.subscript_cref(r1,[Exp.INDEX(Exp.ICONST(i))]) => r1' &
	Exp.subscript_cref(r2,[Exp.INDEX(Exp.ICONST(i))]) => r2' &
	int_sub(i,1) => i' &
	find_equ_set(ss,r1') => s1 &
	find_equ_set(ss,r2') => s2 &
	merge(ss,s1,s2) => ss' &
	add_array_equ(ss',r1,r2,i') => ss''	
	----------------------
	add_array_equ(ss,r1,r2,i) => ss''
end


(**
 ** - Equation generation
 **)

(** relation: equations
 **
 ** From a number of connection sets, this relation generates a list
 ** of equations.
 **)

relation equations : Sets => DAE.Element list =

  axiom	equations [] => []

  rule	equ_equations cs => dae1 &
	equations ss => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations EQU(cs)::ss => dae

  rule	flow_equations cs => dae1 &
	equations ss => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations FLOW(cs)::ss => dae

end

(** relation: equ_equations
 ** 
 ** A non-flow connection set contains a number of components.
 ** Generating the equation from this set means equating all the
 ** components.  For n components, this will give n-1 equations.
 **
 ** For example, if the set contains the components `x', `y.a' and
 ** `z.b', the equations generated will me `x = y.a' and `y.a = z.b'.
 **)

relation equ_equations : Exp.ComponentRef list => DAE.Element list =

  axiom	equ_equations [_] => []

  rule	equ_equations (y::cs) => eq
	------------------------
	equ_equations x::y::cs
	  => DAE.EQUATION(Exp.CREF(x,Exp.OTHER), Exp.CREF(y,Exp.OTHER))::eq
end

(** relation: flow_equations
 ** 
 ** Generating equations from a flow connection set is a little
 ** trickier that from a non-flow set.  Only one equation is
 ** generated, but it has to consider whether the comoponents were
 ** inner or outer connectors.
 **
 ** This relation uses `flow_sum' to create the sum of all components
 ** (some of which will be negated), and the returns the equation
 ** where this sum is equal to 0.0.
 **)

relation flow_equations : (Exp.ComponentRef * Face) list => DAE.Element list =

  rule	flow_sum cs => sum
	------------------
	flow_equations cs => [DAE.EQUATION(sum, Exp.RCONST(0.0))]

end

(** relation: flow_sum
 ** 
 ** This relation creates an exression expressing the sum of all
 ** components in the given list.  Before adding the component to the
 ** sum, it is passed to `sign_flow' which will negate all outer
 ** connectors.
 **)

relation flow_sum : (Exp.ComponentRef * Face) list => Exp.Exp =

  rule	sign_flow(c,f) => exp
	-------------------
	flow_sum [(c,f)] => exp

  rule	sign_flow(c,f) => exp1 &
	flow_sum cs => exp2
	------------------
	flow_sum ((c,f)::cs) => Exp.BINARY(exp1, Exp.ADD(Exp.REAL), exp2)

end

(** relation: sign_flow
 **
 ** This relation takes a name of a component and a `Face', returns an
 ** expression.  If the face is `INNER' the expression simply contains
 ** the component reference, but if it is `OUTER', the expression is
 ** negated.
 **)

relation sign_flow : (Exp.ComponentRef, Face) => Exp.Exp =

  axiom	sign_flow (c,INNER) => Exp.CREF(c,Exp.OTHER)
  axiom	sign_flow (c,OUTER) => Exp.UNARY(Exp.UMINUS(Exp.REAL),Exp.CREF(c,Exp.OTHER))

end

(**
 ** - Lookup
 ** 
 ** These relations are used to find and create connection sets.
 **)

(** relation: find_equ_set
 **
 ** This relation finds a non-flow connection set that contains the
 ** component named by the second argument.  If no such set is found,
 ** a new set is created.
 **)

relation find_equ_set : (Sets, Exp.ComponentRef) => Set =

  rule	new_equ_set c => s
	------------------
	find_equ_set([],c) => s

  rule	find_in_set(s,c)
	----------------
	find_equ_set(s::_,c) => s

  rule	find_equ_set(ss,c) => s
	-------------------
	find_equ_set(_::ss,c) => s

end	

(** relation: find_flow_set
 **
 ** This relation finds a flow connection set that contains the
 ** component named by the second argument.  If no such set is found,
 ** a new set is created.
 **)

relation find_flow_set : (Sets, Exp.ComponentRef, Face) => Set =

  rule	new_flow_set(c,d) => s
	------------------
	find_flow_set([],c,d) => s

  rule	find_in_set(s,c)
	----------------
	find_flow_set(s::_,c,d) => s

  rule	find_flow_set(ss,c,d) => s
	-------------------
	find_flow_set(_::ss,c,d) => s

end	

(** relation: find_in_set
 ** 
 ** This relation checks if a componet already appears in a given
 ** connection set.
 **)

relation find_in_set : (Set, Exp.ComponentRef) => () =

  rule	find_in_set_equ(cs,c)
	---------------------
	find_in_set(EQU(cs), c)

  rule	find_in_set_flow(cs, c)
	-----------------------
	find_in_set(FLOW(cs), c)

end

(** relation: find_in_set_equ
 ** 
 ** This is a version of `find_in_set' which is specialized on
 ** non-flow connection sets
 **)

relation find_in_set_equ : (Exp.ComponentRef list, Exp.ComponentRef) => () =

  rule	Static.eq_cref(c1,c2)
	------------------
	find_in_set_equ(c1::_,c2)

  rule	find_in_set_equ(cs,c2)
	----------------------
	find_in_set_equ(_::cs,c2)

end

(** relation: find_in_set_flow
 ** 
 ** This is a version of `find_in_set' which is specialized on
 ** flow connection sets
 **)

relation find_in_set_flow : ((Exp.ComponentRef * Face) list, Exp.ComponentRef)
	  => () =

  rule	Static.eq_cref(c1,c2)
	------------------
	find_in_set_flow((c1,_)::_,c2)

  rule	find_in_set_flow(cs,c2)
	----------------------
	find_in_set_flow(_::cs,c2)

end

(** relation: new_equ_set
 **
 ** This relation creates a new non-flow connection set containing
 ** only the given component.
 **)

relation new_equ_set : Exp.ComponentRef => Set =

  axiom	new_equ_set c => EQU([c])

end

(** relation: new_flow_set
 **
 ** This relation creates a new-flow connection set containing only
 ** the given component.
 **)

relation new_flow_set : (Exp.ComponentRef, Face) => Set =

  axiom	new_flow_set(c,d) => FLOW([(c,d)])

end

(**
 ** - Merging
 ** 
 ** The result of merging two connection sets is the intersection of
 ** the two sets.
 **)

relation merge : (Sets, Set, Set) => Sets =

  rule	s1 = s2
	-------
	merge(ss,s1,s2) => ss

  rule	list_append(cs1,cs2) => cs &
	remove_set2(ss,s1,s2) => ss'
	----------------------------
	merge(ss, s1 as EQU(cs1), s2 as EQU(cs2)) => EQU(cs)::ss'

  rule	list_append(cs1,cs2) => cs &
	remove_set2(ss,s1,s2) => ss'
	----------------------------
	merge(ss, s1 as FLOW(cs1), s2 as FLOW(cs2)) => FLOW(cs)::ss'

end

(** relation: remove_set2
 ** 
 ** This relation removes the two sets given in the second and third
 ** argument from the collection of sets given in the first argument.
 **)

relation remove_set2 : (Sets, Set, Set) => Sets =

  axiom	remove_set2([],_,_) => []

  rule	s = s1 &
	remove_set(ss,s2) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => ss'
	
  rule	s = s2 &
	remove_set(ss,s1) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => ss'
	
  rule	remove_set2(ss,s1,s2) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => s::ss'

end

(** relation: remove_set
 **
 ** This relation removes one set from a list of sets.
 **)

relation remove_set : (Sets, Set) => Sets =

  axiom	remove_set([],_) => []

  rule	s = s1
      	------
      	remove_set(s::ss, s1) => ss
      
  rule	remove_set(ss,s1) => ss'
      	------------------------
      	remove_set(s::ss, s1) => s::ss'
	
end

(* Unconnected flow variables. *)

(** relation: unconnected_flow_equations 
 **
 ** This relation will generate set-to-zero equations for INNER flow variables.
 ** It can not generate for outer flow varaibles, since we do not yet know if 
 ** these are connected or not. This is only known in the preceding recursive 
 ** call. However, the top call must generate for both inner and outer 
 ** connectors, hence the last argument, true for top call*)

relation unconnected_flow_equations : (Sets, DAE.Element list, Env.Env,bool) => DAE.Element list =

  rule	(* if outermost call look at both inner and outer unconnected connectors *)
	Env.local_outside_connector_flowvars(env) => v1 &
	Env.local_inside_connector_flowvars(env) => v2 &
	list_append(v1,v2) => vars &
	get_all_flow_variables(csets) => vars2 &
	remove_variables(vars,vars2) => unconnectedvars &
	generate_zeroflow_equations(unconnectedvars) => dae'
	----------------------------------
	unconnected_flow_equations(csets,dae,env,true) => dae'

	(* If not outermost call, only look at unconnected inner connectors *)
  rule	Env.local_inside_connector_flowvars(env) => vars &
 	get_all_flow_variables(csets) => vars2 &
	remove_variables(vars,vars2) => unconnectedvars &
 	generate_zeroflow_equations(unconnectedvars) => dae'
	----------------------------------
	 unconnected_flow_equations(csets,dae,env,true) => dae'

  rule	(*Debug.fprint("failtrace","-unconnected_flow_equations failed\n") *)
	----------------------------------
	unconnected_flow_equations(csets,dae,env,_) => []
end

relation remove_variables: (Exp.ComponentRef list, Exp.ComponentRef list) 
	  => Exp.ComponentRef list =
  axiom	remove_variables(vars,[]) => vars 

  rule	remove_variable(r1,vars) => vars' &
	remove_variables(vars',removelist) => res
	-----------------------------------------
	remove_variables(vars,r1::removelist) => res
end
relation remove_variable: (Exp.ComponentRef, Exp.ComponentRef list) 
	  => Exp.ComponentRef list =

  axiom	remove_variable(cr,[]) => [] 

  rule	Exp.cref_equal(cr,cr2) => true
	------------------------------
	remove_variable(cr,cr2::xs) => xs

  rule	remove_variable(cr,xs) => res
	------------------------------
	remove_variable(cr,cr2::xs) => cr2::res
end

relation generate_zeroflow_equations: Exp.ComponentRef list 
	  => DAE.Element list =
  axiom	generate_zeroflow_equations ([]) => []

  rule	generate_zeroflow_equations(xs) => res 
	--------------------------------------
	generate_zeroflow_equations(cr::xs) 
	  => DAE.EQUATION(Exp.CREF(cr,Exp.REAL),Exp.RCONST(0.0))::res
end


relation get_all_flow_variables: Sets => Exp.ComponentRef list =

  axiom	get_all_flow_variables [] => []

  rule	Util.list_map(varlst,Util.tuple2_1) => res1 &
	get_all_flow_variables(xs) => res2 &
	list_append(res1,res2) => res
	---------------------------------- 
	get_all_flow_variables(FLOW(varlst)::xs) => res 

  rule	get_all_flow_variables(xs) => res 
	---------------------------------- 
	get_all_flow_variables(EQU(res1)::xs) => res 
end

relation get_inner_flow_variables: Sets => Exp.ComponentRef list =

  axiom	get_inner_flow_variables([]) => []

  rule	get_inner_flow_variables_2(vars) => res1 &
	get_inner_flow_variables(xs) => res2 &
	list_append(res1,res2) => res
	---------------------------------- 
	get_inner_flow_variables(FLOW(vars)::xs) => res 

  rule	get_inner_flow_variables(xs) => res
	---------------------------------- 
	get_inner_flow_variables(EQU(_)::xs) => res 

  rule	(*Debug.fprint("failtrace","-get_inner_flow_variables failed\n")*)
	----------------------------------
	get_inner_flow_variables(_) => fail 
end

relation get_inner_flow_variables_2: (Exp.ComponentRef * Face) list 
	  => Exp.ComponentRef list =

  axiom	get_inner_flow_variables_2 ([]) => []

  rule	get_inner_flow_variables_2(xs) => res
	-------------------------------------
	get_inner_flow_variables_2( (cr,INNER)::xs) => cr::res

  rule	get_inner_flow_variables_2(xs) => res
	-------------------------------------
	get_inner_flow_variables_2( _::xs) => res

  rule	(*Debug.fprint("failtrace","-get_inner_flow_variables_2 failed\n")*)
	----------------------------------
	get_inner_flow_variables_2(_) => fail 
end


(**
 ** - Printing
 **
 ** These are a few relations used for printing a description of the
 ** connection sets.  The implementation is excluded from the report
 ** for brevity.
 **)

(*!ignorecode*)

with "Dump.rml"
with "Print.rml"
with "Util.rml"
with "Debug.rml"

(** relation: print_sets
 **
 ** Prints a description of a number of connection sets to the
 ** standard output.
 **)

relation print_sets : Sets => () =

  axiom	print_sets []

  rule	print_set x &
	print_sets xs
	------------
	print_sets x::xs

end
(**)
relation print_set : Set => () =

  rule	Print.print_buf " non-flow set: { " &
	Exp.print_list(cs, Exp.print_component_ref, ", ") &
	Print.print_buf " }\n"
	----------------------------------------------------
	print_set EQU(cs)

  rule	Print.print_buf " flow set: { " &
	Exp.print_list(cs, print_flow_ref, ", ") &
	Print.print_buf " }\n"
	----------------------------------------------------
	print_set FLOW(cs)

end
(**)
relation print_flow_ref : (Exp.ComponentRef * Face) => () =

  rule	Exp.print_component_ref c &
	Print.print_buf " INNER"
	-----------
	print_flow_ref((c,INNER))

  rule	Exp.print_component_ref c &
	Print.print_buf " OUTER"
	-----------
	print_flow_ref((c,OUTER))

end

(*!includecode*)

