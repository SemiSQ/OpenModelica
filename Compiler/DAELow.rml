(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 DAELow.rml
 ** module:      DAELow
 ** description: DAELow a lower form of DAE including sparse matrises for
 ** BLT decomposition, etc.
 **
 ** RCS: $Id$
 ** 
 **)

(** 
 ** This module is a lowered form of a DAE including equations 
 ** and simple equations in
 ** two separate lists. The variables are split into known variables
 ** parameters and constants, and unknown variables, 
 ** states and algebraic variables.
 ** The module includes the BLT sorting algorithm which sorts the
 ** equations into blocks, and the index reduction algorithm using
 ** dummy derivatives for solving higher index problems.
 ** It also includes the tarjan algorithm to detect strong components
 ** in the BLT sorting.
 **)
 module DAELow:
  
  with "DAE.rml"
  with "Exp.rml"
  with "Values.rml"
  with "Absyn.rml"
  with "Algorithm.rml"

(*  this is for the variables that have derivative (former "xd") *)
  val derivative_name_prefix :string

  (* - Variabile kind *)
  datatype VarKind = VARIABLE | STATE | DUMMY_DER | DUMMY_STATE | DISCRETE | PARAM | CONST

  (* - Variables *)
  datatype Var = VAR of Exp.ComponentRef              (* varName ; variable name *)
		*  VarKind                       (* varKind ; Kind of variable*)
		*  DAE.VarDirection              (* varDirection ; input, output or bidirectional*)
		*  DAE.Type                      (* builtinTypeOrEnum ; builtin type or enumeration *)
		*  Exp.Exp option                (* bindExp ; Binding expression e.g. for parameters*)
		*  Values.Value option           (* bindValue ; binding value for parameters*)
		*  DAE.InstDims                  (* arryDim ; array dimensions on nonexpanded var *)
		*  DAE.StartValue                (* startValue ; value of start attribute *)
		*  int                           (* index ; index in impl. vector *)
		*  string                        (* origVarName ; original variable name *)
		*  Absyn.Path list               (* className ; classname variable belongs to *)
		*  DAE.VariableAttributes option (* values ; values on builtin attributes *)
		*  Absyn.Comment option          (* comment ; this contains the comment and annotation from Absyn *)
		*  DAE.Flow                      (* flow ; if the var is a flow *) 

  (* - State Selection *)
  datatype StateSelect = NEVER | AVOID | DEFAULT | PREFER | ALWAYS
                                                       
  (* - Equation *)
  datatype Equation = EQUATION of Exp.Exp 
                               *  Exp.Exp (* scalar*)
		      | ARRAY_EQUATION of int  (* index ; index in arrayequations 0..n-1*) 
				  *  Exp.Exp list (* crefOrDerCref ; CREF or der(CREF) *)
		      | SOLVED_EQUATION of Exp.ComponentRef (* componentRef *)
                                              * Exp.Exp (* exp *)
		      | RESIDUAL_EQUATION of Exp.Exp (* exp ; not present from front end *)
		      | ALGORITHM of int (* index ; index in algorithms, 0..n-1*) 
			        * Exp.Exp list (* in ; inputs CREF or der(CREF)*)
			        * Exp.Exp list (* out ; outputs CREF or der(CREF)*)
		      | WHEN_EQUATION of WhenEquation (* whenEquation *)

  (* - When Equation *)
  datatype WhenEquation = WHEN_EQ of int               (* index ; index in when clauses *)
			   * Exp.ComponentRef  (* left ; Left hand side of equation *)
			   * Exp.Exp           (* right ; Right hand side of equation *)

  (* - Reinit Statement *)
  datatype ReinitStatement = REINIT of Exp.ComponentRef (* stateVar ; state variable to reinit *)
			     * Exp.Exp          (* value ; value after reinit *)
 
  (* - When Clause *)
  datatype WhenClause = WHEN_CLAUSE of Exp.Exp (* condition *)
			    *  ReinitStatement list (* reinitStmtLst *) 

  (* - Zero Crossing *)  
  datatype ZeroCrossing = ZERO_CROSSING of Exp.Exp  (* relation *)
			        *  int list (* occurEquLst ; list of equations where the relation occurs *)
			        *  int list (* occurWhenLst ; list of when clauses where the relation occurs *)

  (* - EventInfo *)
  datatype EventInfo = EVENT_INFO of WhenClause list   (* whenClauseLst ; List of when clauses. The WhenEquation datatype refer to this list by position *) 
			   * ZeroCrossing list (* zeroCrossingLst *)


(* THE LOWERED DAE consist of variables and equations. The variables are split into 
 * two lists, one for unknown variables states and algebraic and one for known variables
 * constants and parameters.
 * The equations are also split into two lists, one with simple equations, a=b, a-b=0, etc., that 
  * are removed from  the set of equations to speed up calculations.
 *)
 (* - DAELow *)
 datatype DAELow = DAELOW of Variables (* orderedVars ; ordered Variables, only states and alg. vars*)		    
		  * Variables     (* knownVars ; Known variables, i.e. constants and parameters*)
		  * EquationArray (* orderedEqs ; ordered Equations *)
		  * EquationArray (* removedEqs ; Removed equations a=b*)
		  * EquationArray (* initialEqs ; Initial equations *)
		  * MultiDimEquation array (* arrayEqs ; Array equations *)	       
		  * Algorithm.Algorithm array (* algorithms ; Algorithms *)
		  * EventInfo (* eventInfo *)

 (* - Variables *)
 datatype Variables = VARIABLES of CrefIndex list array   (* crefIdxLstArr ; HashTB, cref->indx *)
                                *  StringIndex list array (* strIdxLstArr ; HashTB, cref->indx for old names*)
			*  VariableArray          (* varArr ; Array of variables *)    
			*  int                    (* bucketSize ; bucket size *)
			*  int                    (* numberOfVars ; no. of vars *)

 (* - Multi Dimensional Equation *)
 datatype MultiDimEquation = MULTIDIM_EQUATION of int list (* dimSize ; dimension sizes*)
			                * Exp.Exp  (* left ; lhs  *) 
			                * Exp.Exp  (* right ; rhs *)			
 
 (* - Component Reference Index *)
 datatype CrefIndex = CREFINDEX of Exp.ComponentRef (* cref *) 
                                *  int (* index *)

 (* - String Index *)
 datatype StringIndex = STRINGINDEX of string (* str *)
                                     * int    (* index *)

 (** array of Equations are expandable, to amortize the cost of adding 
  ** equations in a more efficient manner
  *)
 (* - Variable Array *)
 datatype VariableArray = VARIABLE_ARRAY of int (* numberOfElements ; no. elements *)
			         *  int (* arrSize ; array size *)
			         *  Var option array (* varOptArr *)	

 (* - Equation Array *)
 datatype EquationArray = EQUATION_ARRAY of int (* numberOfElement ; no. elements *)
			         * int (* arrSize ; array size *)
			         * Equation option array (* equOptArr *)

 (** Assignments of variables to equations and vice versa are implemented by a
  ** expandable array to amortize addition of array elements more efficient *)
 (* - Assignments *)
 datatype Assignments = ASSIGNMENTS of int (* actualSize ; actual size *)
			     * int (* allocatedSize ; allocated size >= actual size *)
			     * int array (* arrOfIndices ; array of indices *)

 (** Generic Binary tree implementation *)
 (* - Binary Tree *)
 datatype BinTree = TREENODE of TreeValue option (* value ; Value *)
                              * BinTree option   (* leftSubTree ; left subtree *)
                              * BinTree option   (* rightSubTree ; right subtree *)

  (* Each node in the binary tree can have a value associated with it.*)
  (* - Tree Value *)
  datatype TreeValue = TREEVALUE of Key (* Key *)
			 *  Value (* Value *)

  (* A key is a Component Reference
   * - Key *)
  type Key = Exp.ComponentRef

  (* - Value *)
  type Value = int

  (* Incidence Matrix is an array of lists of variable indexes (1..n), 
     one for each equation. For state variables the index is negated, 
     since when sorting to retrieve underlying ODE, the states are considered
     known. The system is solved for the derivatives and the algebraic variables: \dot{x},y.
     But the states must be located when debugging and
     when a state is transformed to an algebraic variable
     in index reduction using dummy derivatives. *)
  (* - Incidence Matrix *)
  type IncidenceMatrix = int list array 


  (* IncidenceMatrixT : a list of equation indexes (1..n), 
     one for each variable*. Equations that -only- 
     contain the state variable and not the derivative
     has a negative index. *)
  (* - Incidence Matrix T *)
  type IncidenceMatrixT = IncidenceMatrix 

  (* - Jacobian Type *)
  datatype JacobianType = JAC_CONSTANT (* If jacobian has only constant values, for system
			        * of equations this means that it can be solved statically.*)
			| JAC_TIME_VARYING (* If jacobian has time varying parts, like parameters or
				         * algebraic variables *)
			| JAC_NONLINEAR (* If jacobian contains variables that are solved for,
				     * means that a nonlinear system of equations needs to be
				     * solved *)
			| JAC_NO_ANALYTIC (* No analytic jacobian available *)
 
  (* - Index Reduction *)
  datatype IndexReduction = INDEX_REDUCTION (* Use index reduction during matching*)
			| NO_INDEX_REDUCTION (* do not use index reduction during matching *)

  (* - Equation Constraints *)  
  datatype EquationConstraints = ALLOW_UNDERCONSTRAINED  (* for e.g. initial eqns.
						      where not all variables 
						      have a solution *)
			    |  EXACT		      (*exact as many equations
						       as variables *)

  (* - Matching Options *)
  type MatchingOptions = (IndexReduction*EquationConstraints)

 
  datatype Block = EQN_BLOCK of int list  (* normal block of one or more eqns*)
		| COND_EQN_BLOCK of 
		     int list   (* block of equations*)
		     * Exp.Exp  (* conditional block *)
		     * int      (* index 0..n-1 in assignment list*)
												     
  (* Exported relations *)
  relation dump: DAELow => ()
  relation dump_vars: Var list => ()
  relation dump_eqns: Equation list => () 
  relation equation_str: Equation => string

  relation dump_jacobian_str: ((int*int*Equation) list option) => string   
        
  relation lower: (DAE.DAElist,bool) => DAELow

  relation incidence_matrix: (DAELow) => IncidenceMatrix
 
  relation transpose_matrix: IncidenceMatrix => IncidenceMatrixT
	  
  relation abs_incidence_matrix: IncidenceMatrix => IncidenceMatrix
		  
  relation dump_incidence_matrix: IncidenceMatrix list => ()

  relation dump_incidence_matrix_t: IncidenceMatrixT list => ()

  relation dump_matching: (int vector list) => () 
	  
  relation matching_algorithm: (DAELow,IncidenceMatrix, IncidenceMatrixT,MatchingOptions) 
	  => (int vector list,(* var solved in eqn*) 
	      int vector list, (* eqn solves var *) 
	      Exp.ComponentRef list, 
	      DAELow,
	      IncidenceMatrix list, 
	      IncidenceMatrixT list)

  relation strong_components: (IncidenceMatrix list, IncidenceMatrixT list,
			       int vector list, int vector list,
			       Exp.ComponentRef list) => 
	  (Block list)

  relation generate_state_partition:(Block list,DAELow,
				     int vector list,int vector list,
				     IncidenceMatrix list,
				     IncidenceMatrixT list) 
	  => (Block list, Block list) 

  relation dump_components: (Block list) => ()

  relation translate_dae: DAELow => DAELow 
  relation calculate_values: DAELow => DAELow	  
	  
  relation calculate_sizes: DAELow => (int, (* nx *)
				       int, (* ny *)
				       int, (* np *)
				       int) (* ng *)

  relation calculate_jacobian: (Variables, 
				EquationArray, 
				MultiDimEquation array,
				IncidenceMatrix,
				IncidenceMatrixT) 
	  => ((int * int * Equation) list option)

  relation analyze_jacobian:(DAELow, (int * int * Equation) list option) => JacobianType
  relation jacobian_type_str: JacobianType => string

  relation states: (DAE.DAElist,BinTree) => BinTree

  relation make_all_states_algebraic: DAELow => DAELow 

  relation get_var: (Exp.ComponentRef, Variables) => (Var list, int list)
  relation get_var_using_name: (string, Variables) => (Var,int) 
  relation add_var: (Var, Variables) => Variables
  relation get_var_at:(Variables,int) => (Var)
  relation exists_var: (Exp.ComponentRef, Variables) => bool 
  relation set_var_kind: (Var, VarKind) => Var 
  relation var_fixed: (DAE.VariableAttributes option,VarKind) => bool
  relation var_list: (Variables) => Var list 
  relation list_var: (Var list ) => Variables

  relation var_cref: (Var) => Exp.ComponentRef 
  relation var_orig_name: (Var) => string 
  relation var_index: (Var) => int
  relation var_nominal: (Var) => real
  relation var_equal: (Var,Var) => bool

  relation vars_in_eqn: (IncidenceMatrix, int(* equation*)) 
	  => int list

  relation equation_add: (EquationArray,Equation) => EquationArray 
  relation equation_nth:(EquationArray,int) => Equation 
  relation equation_setnth: (EquationArray,int,Equation) => EquationArray
  relation equation_list:(EquationArray) => Equation list 
  relation equation_size:(EquationArray) => int 
  relation list_equation:(Equation list ) => EquationArray
  relation equation_to_residual_form:(Equation) => Equation 
  relation to_residual_form:(DAELow) => DAELow
  relation residual_exp: (Equation) => Exp.Exp

  relation get_eqnsys_rhs_exp: (Exp.Exp, Variables) => Exp.Exp 

  relation vararray_nth:(VariableArray, int) => Var 
  relation vararray_setnth:(VariableArray, int, Var) => VariableArray 
  relation vararray_add:(VariableArray,Var) => VariableArray 
  relation vararray_length: (VariableArray) => int
  relation vararray_list:(VariableArray) => Var list
  relation is_state_var: (Var) => bool
  relation is_non_state: VarKind => bool
  relation is_discrete: VarKind => ()
  relation is_var_known : (Var list, Exp.ComponentRef) => bool 
  relation is_param: (Var ) => bool 
  relation is_output: (Var) => bool 	  
  relation is_input: (Var) => bool
  relation is_var_on_top_level_and_output:(Var) => bool 
  relation is_var_on_top_level_and_input:(Var) => bool 
        
  relation get_all_exps : DAELow => Exp.Exp list
  relation get_when_equation_expr : WhenEquation => (Exp.ComponentRef, Exp.Exp) 
  relation get_zero_crossing_indices_from_when_clause: (DAELow, int) => (int list) 
  relation simple_equation: (Equation) => (Exp.ComponentRef, Exp.ComponentRef)
  relation evaluate_if_branch: (DAELow, Exp.ComponentRef, int list) => (DAELow,DAELow)
end (* End Module *)


(* Implementation *)
with "Util.rml" 
with "DAEEXT.rml"
with "Print.rml"
with "Derive.rml"
with "Debug.rml"
with "Env.rml" 
with "Builtin.rml"
with "Ceval.rml" 
with "Types.rml"
with "SCode.rml"
with "Dump.rml"
with "System.rml"
with "VarTransform.rml"
with "RTOpts.rml"
with "Error.rml"
with "SimCodegen.rml"

val empty_bintree = TREENODE(NONE,NONE,NONE)
val derivative_name_prefix = "$derivative"


(** relation: lower
 **
 ** This relation translates a DAE, which is the result from instantiating a 
 ** class, into a more precise form, called DAELow defined in this module.
 ** The DAELow representation splits the DAE into equations and variables
 ** and further divides variables into known and unknown variables and the 
 ** equations into simple and nonsimple equations.
 ** The variables are inserted into a hash table. This gives a lookup cost of 
 ** O(1) for finding a variable. The equations are put in an expandable
 ** array. Where adding a new equation can be done in O(1) time if space 
 ** is available.
 ** inputs:  daeList: DAE.DAElist, add_dummy_state: bool) 
 ** outputs: DAELow
 **)
relation lower: (DAE.DAElist, bool) => DAELow =

  rule	states(lst,empty_bintree) => s &
	lower2(lst,s,[]) => (vars,knvars,eqns,reqns,ieqns,
			     aeqns,algs,whenclauses)  &
	add_dummy_state(vars,eqns,add_dummy) => (vars,eqns) &
	list_reverse whenclauses => whenclauses' &
	lower_algorithms(vars,algs) => algeqns &
	lower_multidimeqns(vars,aeqns) => multidimeqns &
	list_append(algeqns,eqns) => eqns &
	list_append(multidimeqns,eqns) => eqns &
	remove_simple_equations(vars,knvars,eqns,reqns,s) 
	  => (vars,knvars,eqns,reqns) & 
	detect_implicit_discrete(vars, eqns) => vars' &
	sort_eqn(eqns) => eqns' &
	find_zero_crossings(vars',eqns',whenclauses') => (zero_crossings) &
	list_equation(eqns') => eqnarr &
	list_equation(reqns) => reqnarr &
	list_equation(ieqns) => ieqnarr &
	list_array(aeqns) => arr_md_eqns &
	list_array(algs) => algarr 
	--------------------
	lower(lst,add_dummy) 
	  => DAELOW(vars',knvars,eqnarr,reqnarr,ieqnarr,arr_md_eqns,algarr,EVENT_INFO(whenclauses',zero_crossings))
end


(** relation: add_dummy_state
 **
 ** In order for the solver to work correctly at least one state variable
 ** must exist in the equation system. This relation therefore adds a 
 ** dummy state variable and an equation for that variable.
 ** inputs:  (vars: Variables, eqns: Equation list, bool)
 ** outputs: (Variables, Equation list)
 **)
relation  add_dummy_state: (Variables, Equation list, bool) => (Variables, Equation list) =
 
  axiom	add_dummy_state(v,e,false) =>(v,e)


  rule	add_var(VAR(Exp.CREF_IDENT("$dummy",[]),STATE,DAE.BIDIR,DAE.REAL,
		    NONE,NONE,[],NONE,-1,"$dummy",[],NONE,NONE,
		    DAE.NON_CONNECTOR),vars) => vars' 
	
	-------------------
	add_dummy_state(vars,eqns,true) 
	  => (vars',
	      EQUATION(Exp.CALL(Absyn.IDENT("der"),
				[Exp.CREF(Exp.CREF_IDENT("$dummy",[]),Exp.REAL)],
				false,
				true),
		       Exp.RCONST(0.0))::eqns)
end


(** relation: dump_zc_str
 **
 ** Dumps a zerocrossing into a string, for debugging purposes.
 **)
relation dump_zc_str : (ZeroCrossing) => string =
  
  rule	Util.list_map(eq,int_string) => eq_s_list &
	Util.string_delimit_list(eq_s_list, ",") => eq_s &
	Util.list_map(wc,int_string) => wc_s_list &
	Util.string_delimit_list(wc_s_list, ",") => wc_s &
	Exp.print_exp_str(e) => str &
	Util.string_append_list([str, " in equations [", eq_s, "] and when conditions [", wc_s, "]\n"]) => str2
	----------------------------------------
	dump_zc_str ZERO_CROSSING(e,eq,wc) => str2

end


(** relation: merge_zero_crossings
 **
 ** Takes a list of zero crossings and if more than one have identical
 ** relation expressions they are merged into one zerocrossing.
 ** In the resulting list all zerocrossing have uniq relation expressions.
 **)
relation merge_zero_crossings : ZeroCrossing list => ZeroCrossing list =

  axiom	merge_zero_crossings [] => []

  axiom	merge_zero_crossings [zc] => [zc]

  rule	Util.list_select_1(xs,zc,same_zero_crossing) => samezc &
	Util.list_select_1(xs,zc,different_zero_crossing) => diff &
	merge_zero_crossings diff => diff' &
	Util.list_fold(samezc,merge_zero_crossing, zc) => same'
	----------------------------------------
	merge_zero_crossings zc::xs => same'::diff'

end


(** relation: merge_zero_crossing
 **
 ** Merges two zero crossings into one by makeing the union of the lists of 
 ** equaions and when clauses they appear in.
 **)
relation merge_zero_crossing : (ZeroCrossing, ZeroCrossing) => ZeroCrossing =

  rule	Util.list_union(eq1,eq2) => eq &
	Util.list_union(wc1,wc2) => zc 
	----------------------------------------
	merge_zero_crossing (ZERO_CROSSING(e1,eq1,wc1),ZERO_CROSSING(e2,eq2,wc2)) 
	  => ZERO_CROSSING(e1,eq,zc) 
end


(** relation: same_zero_crossing
 **
 ** Returns true if both zero crossings have the same relation expression
 **)
relation same_zero_crossing : (ZeroCrossing, ZeroCrossing) => bool =

  rule	Exp.exp_equal(e1,e2) => res
	----------------------------------------
	same_zero_crossing(ZERO_CROSSING(e1,_,_),ZERO_CROSSING(e2,_,_)) => res

end


(** relation: different_zero_crossing
 **
 ** Return true if the realation expressions differ.
 **)
relation different_zero_crossing : (ZeroCrossing, ZeroCrossing) => bool =

  rule	same_zero_crossing(zc1,zc2) => res &
	bool_not res => res'
	----------------------------------------
	different_zero_crossing(zc1,zc2) => res'

end


(** relation: find_zero_crossings
 **
 ** This relation finds all zerocrossings in the list ogf equations and
 ** the list of when clauses. Used in lower2.
 **)
relation find_zero_crossings : (Variables, Equation list, WhenClause list) 
	  => (ZeroCrossing list) =

  rule	find_zero_crossings2(vars,eq,1,wc,1) => res &
	merge_zero_crossings(res) => res'
	----------------------------------------
	find_zero_crossings(vars,eq,wc) => res'
end


(** relation: find_zero_crossings2
 **
 ** Helper function to find_zero_crossing.
 **)
relation find_zero_crossings2 : (Variables, Equation list, int, WhenClause list, int) 
	  => (ZeroCrossing list) =
       
  axiom	find_zero_crossings2 (v, [], _, [], _) => ([])

  rule	find_zero_crossings3(e1,v) => rellst1 &
	make_zero_crossings(rellst1, [eq_count], []) => zc1 &
	find_zero_crossings3(e2,v) => rellst2 &
	make_zero_crossings(rellst2, [eq_count], []) => zc2 &
	eq_count + 1 => eq_count' &
	find_zero_crossings2 (v,xs,eq_count',[],0) => zc3 &
	list_append(zc1,zc2) => zc4 &
	list_append(zc3,zc4) => res
	----------------------------------------
	find_zero_crossings2 (v,(e as EQUATION(e1,e2))::xs,eq_count,[],_) => (res)


  rule	eq_count + 1 => eq_count' &
	find_zero_crossings2 (v,xs,eq_count',[],0) => (res)
	----------------------------------------
	find_zero_crossings2 (v,e::xs,eq_count,[],_) => (res)

  rule	wc_count + 1 => wc_count' &
	find_zero_crossings2 (v,el,eq_count,xs,wc_count') => (res1) &
	find_zero_crossings3(e,v) => rel &
	make_zero_crossings(rel,[],[wc_count]) => res2 &
	list_append(res1,res2) => res
	----------------------------------------
	find_zero_crossings2 (v,el,eq_count,(wc as WHEN_CLAUSE(e,_))::xs,wc_count) => (res)
end


(** relation: collect_zero_crossings
 **
 ** Collects zero crossings 
 **)
relation collect_zero_crossings: ((Exp.Exp *  (Exp.Exp list * Variables))) 
	  => ((Exp.Exp *  (Exp.Exp list * Variables))) =

  axiom	collect_zero_crossings( ((e as Exp.CALL(Absyn.IDENT("noEvent"),_,_,_)),(_,vars)) ) => ((e,([],vars))) 

  axiom	collect_zero_crossings( ((e as Exp.CALL(Absyn.IDENT("sample"),_,_,_)),(zeroCrossings,vars)) ) => ((e,(e::zeroCrossings,vars)))

	(* relation with discrete expressions generate no zerocrossing*)
  rule	is_discrete_exp(e1,vars) => true &
	is_discrete_exp(e2,vars) => true 
	------------------
	collect_zero_crossings( ((e as Exp.RELATION(e1,op,e2)),(zeroCrossings,vars))  )
	  => ((e,(zeroCrossings,vars)))
		     
        (* All other relations generate zerocrossing.*)
axiom	collect_zero_crossings( ((e as Exp.RELATION(e1,op,e2)),(zeroCrossings,vars))  )=> 
			       ((e,(e::zeroCrossings,vars)))

  rule	--------------------------------------------------
	collect_zero_crossings( ((e as Exp.ARRAY(_,_,[])),(zeroCrossings,vars))) => ((e,(zeroCrossings,vars)))

  rule	Exp.traverse_exp(e, collect_zero_crossings,NONE, (zeroCrossings,vars)) => ((_,(zeroCrossings',vars))) &
        collect_zero_crossings( (Exp.ARRAY(tp,scalar,el),(zeroCrossings,vars)) ) => ((e',(zeroCrossings'',vars))) &
	list_append(zeroCrossings',zeroCrossings'') => zeroCrossings'''
	--------------------------------------------------
	collect_zero_crossings( ((Exp.ARRAY(tp,scalar,e::el)),(zeroCrossings,vars))) => ((e,(zeroCrossings''',vars)))

  axiom	collect_zero_crossings((e,(zeroCrossings,vars))) => ((e,(zeroCrossings,vars)))
end

(** relation: is_kind_discrete
 **
 ** Returns true if VarKind is discrete.
 **)

relation is_kind_discrete: VarKind => bool =

  axiom	is_kind_discrete(DISCRETE) => true 
  axiom	is_kind_discrete(PARAM) => true 
  axiom	is_kind_discrete(CONST) => true 

  axiom	is_kind_discrete(_) => false
end

(** relation: is_discrete_exp
 **
** Returns true if expression is a discrete expression.
 **)

relation is_discrete_exp: (Exp.Exp, Variables) => bool =

  axiom	is_discrete_exp(Exp.ICONST(_),vars) => true
  axiom	is_discrete_exp(Exp.RCONST(_),vars) => true
  axiom	is_discrete_exp(Exp.SCONST(_),vars) => true
  axiom	is_discrete_exp(Exp.BCONST(_),vars) => true


  rule	get_var(cr,vars) => (VAR(cr,kind,dir,vartype,bind,value,dims,start,ind,
			     orig,clname,attr,comment,flow)::_,_) &
	is_kind_discrete(kind) => res
	-----------------
	is_discrete_exp(Exp.CREF(cr,_),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	bool_or(b1,b2) => res
	-----------------------
	is_discrete_exp(Exp.BINARY(e1,op,e2),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	bool_or(b1,b2) => res
	-----------------------
	is_discrete_exp(Exp.LBINARY(e1,op,e2),vars) => res

  rule	is_discrete_exp(e,vars) => res
	-----------------------
	is_discrete_exp(Exp.UNARY(op,e),vars) => res

  rule	is_discrete_exp(e,vars) => res
	-----------------------
	is_discrete_exp(Exp.LUNARY(op,e),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	bool_or(b1,b2) => res
	-----------------------
	is_discrete_exp(Exp.RELATION(e1,op,e2),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	is_discrete_exp(e3,vars) => b3 &
	Util.bool_or_list([b1,b2,b3]) => res
	--------------------
	is_discrete_exp(Exp.IFEXP(e1,e2,e3),vars) => res

  axiom	is_discrete_exp(Exp.CALL(Absyn.IDENT("pre"),_,_,_),vars) => true 
	
  rule	Util.list_map_1(expl,is_discrete_exp,vars) => blst &
	Util.bool_or_list(blst) => res
	---------------------------
	is_discrete_exp(Exp.CALL(_,expl,_,_),vars) => res

  rule	Util.list_map_1(expl,is_discrete_exp,vars) => blst &
	Util.bool_or_list(blst) => res
	------------
	is_discrete_exp(Exp.ARRAY(tp,_,expl),vars) => res

  rule	Util.list_flatten(expl) => expl' &
	Util.list_map(expl',Util.tuple2_1) => expl'' &
	Util.list_map_1(expl'',is_discrete_exp,vars) => blst &
	Util.bool_or_list(blst) => res
	------------
	is_discrete_exp(Exp.MATRIX(tp,_,expl),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	is_discrete_exp(e3,vars) => b3 &
	Util.bool_or_list([b1,b2,b3]) => res
	--------------------
	is_discrete_exp(Exp.RANGE(tp,e1,SOME(e2),e3),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	bool_or(b1,b2) => res
	--------------------
	is_discrete_exp(Exp.RANGE(tp,e1,NONE,e2),vars) => res

  rule	Util.list_map_1(expl,is_discrete_exp,vars) => blst &
	Util.bool_or_list(blst) => res
	------------
	is_discrete_exp(Exp.TUPLE(expl),vars) => res

  rule	is_discrete_exp(e1,vars) => res
	------------
	is_discrete_exp(Exp.CAST(tp,e1),vars) => res

  rule	is_discrete_exp(e,vars) => res
	-------------------------
	is_discrete_exp(Exp.ASUB(e,_),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	bool_or(b1,b2) => res
	--------------------
	is_discrete_exp(Exp.SIZE(e1,SOME(e2)),vars) => res

  rule	is_discrete_exp(e1,vars) => res
	------------------
	is_discrete_exp(Exp.SIZE(e1,NONE),vars) => res

  rule	is_discrete_exp(e1,vars) => b1 &
	is_discrete_exp(e2,vars) => b2 &
	bool_or(b1,b2) => res
	--------------------------
	is_discrete_exp(Exp.REDUCTION(_,e1,_,e2),vars) => res

  axiom	is_discrete_exp(_,vars) => false

end


(** relation: find_zero_crossings3
 **
 ** Helper function to find_zero_crossing.
 **)
relation find_zero_crossings3: (Exp.Exp,Variables) => (Exp.Exp list) =
  
  rule	Exp.traverse_exp(e,collect_zero_crossings,NONE,([],vars)) 
	  => ((_,(zeroCrossings,_)))
	--------------------------------------------------
	find_zero_crossings3(e,vars) => zeroCrossings
end


(** relation: make_zero_crossing
 **
 ** Constructs a ZeroCrossing from an expression and lists of equation indices
 ** and when clause indices.
 **) 
relation make_zero_crossing : (Exp.Exp, int list, int list) => ZeroCrossing =

  axiom	make_zero_crossing(e,eq_ind,wc_ind) => ZERO_CROSSING(e,eq_ind,wc_ind)

end


(** relation: make_zero_crossings
 **
 ** Constructs a list of ZeroCrossings from a list expressions and lists of 
 ** equation indices and when clause indices.
 ** Each Zerocrossing gets the same lists of indicies.
 **) 
relation make_zero_crossings : (Exp.Exp list, int list, int list) => ZeroCrossing list =

  axiom	make_zero_crossings([],_,_) => []

  rule	make_zero_crossing(e,eq_ind,wc_ind) => res &
         make_zero_crossings(xs,eq_ind,wc_ind) => resx 
	----------------------------------------
	make_zero_crossings(e::xs, eq_ind, wc_ind) => res::resx
end


(** relation: detect_implicit_discrete
 **
 ** This relation updates the variable kind to discrete for variables set 
 ** in when equations.
 **)
relation detect_implicit_discrete : (Variables, Equation list) => Variables =

  axiom	detect_implicit_discrete(v,[]) => v

  rule	get_var(cr, v) => (VAR(cr,_,dir,vartype,bind,value,dims,start,ind,
			       orig,clname,attr,comment,flow)::_,_) &
	add_var(VAR(cr,DISCRETE,dir,vartype,bind,value,dims,start,ind,
		    orig,clname,attr,comment,flow),v) => v' &
	detect_implicit_discrete(v',xs) => v''
	----------------------------------------
	detect_implicit_discrete(v, WHEN_EQUATION(WHEN_EQ(_,cr,_))::xs) => v''
	
  rule	detect_implicit_discrete(v,xs) => v'
	----------------------------------------
	detect_implicit_discrete(v, _::xs) => v'

end


(** relation: sort_eqn 
 **
 ** This relation sorts the equation. It puts first the algebraic eqns
 ** and last the differentiated eqns
 **
 **)
relation sort_eqn :  Equation list => Equation list =

  rule  extract_algebraic_and_differential_eqn(eqns) => (algEqns,diffEqns) &
(*        print "ALGEBRAIC EQUATIONS\n" &
        dump_eqns(algEqns) &
        print "\n\nDIFFERENTIATED EQUATIONS\n" &
        dump_eqns(diffEqns) &*)
        list_append(algEqns,diffEqns) => res
        ---------------------------------------
        sort_eqn(eqns) 
          => res

  rule  print "sort_eqn failed \n"
        ---------------------------------------
        sort_eqn(eqns) => fail
end


(** relation: extract_algebraic_and_differential_eqn
 **
 ** Splits the equation list into two lists. One that only contain differential
 ** equations and one that only contain algebraic equations.
 **)
relation extract_algebraic_and_differential_eqn: (Equation list) 
	  => (Equation list, (* algebraic equations *)
	      Equation list) = (* differential equations*)

  axiom	extract_algebraic_and_differential_eqn([]) => ([],[]) 

	(* scalar equation *)
  rule  is_algebraic(exp1) => true &
        is_algebraic(exp2) => true &
        extract_algebraic_and_differential_eqn(rest) => (resAlgEqn,resDiffEqn)
        ---------------------------------------
        extract_algebraic_and_differential_eqn((eqn as EQUATION(exp1,exp2))::rest) 
          => (eqn::resAlgEqn,resDiffEqn)

	  (* array equation *)
  rule	Util.list_map(expl,is_algebraic) => bool_lst &
	Util.bool_and_list(bool_lst) => true &
        extract_algebraic_and_differential_eqn(rest) => (resAlgEqn,resDiffEqn)
        ---------------------------------------
        extract_algebraic_and_differential_eqn((eqn as ARRAY_EQUATION(indx,expl))::rest) 
          => (eqn::resAlgEqn,resDiffEqn)


  rule	extract_algebraic_and_differential_eqn(rest) => (resAlgEqn,resDiffEqn)
        ---------------------------------------
        extract_algebraic_and_differential_eqn((eqn as EQUATION(exp1,exp2))::rest)
          => (resAlgEqn,eqn::resDiffEqn)

  rule	extract_algebraic_and_differential_eqn(rest) => (resAlgEqn,resDiffEqn)
        ---------------------------------------
        extract_algebraic_and_differential_eqn((eqn as ARRAY_EQUATION(_,_))::rest)
          => (resAlgEqn,eqn::resDiffEqn)

  rule	(* Put algorithms in algebraic equations *)
	extract_algebraic_and_differential_eqn(rest) => (resAlgEqn,resDiffEqn)
        ---------------------------------------
        extract_algebraic_and_differential_eqn((alg)::rest) 
          => (alg::resAlgEqn,resDiffEqn)
end


(** relation:generate_state_partition
 **
 ** This relation traverses the equations to find out which blocks needs to
 ** be solved by the numerical solver (Dynamic Section) and which blocks only 
 ** needs to be solved for output to file ( Accepted Section).
 ** This is done by traversing the graph of strong components, where
 ** equations/variable pairs correspond to nodes of the graph. The edges of 
 ** this graph are the dependencies between blocks or components. 
 ** The traversal is made in the backward direction of this graph.
 ** The result is a split of the blocks into two lists.
 ** inputs: (blocks: int list list, 
             daeLow: DAELow, 
             assignments1: int vector list, 
             assignments2: int vector list,
             incidenceMatrix: IncidenceMatrix list, 
             incidenceMatrixT: IncidenceMatrixT list)
 ** outputs: (dynamicBlocks: Block list, outputBlocks: Block list)
 **) 
relation generate_state_partition:(Block list, 
                                   DAELow, 
                                   int vector list,
				   int vector list,
				   IncidenceMatrix list, 
				   IncidenceMatrixT list) 
	  =>  (Block list, Block list) =
        
  rule	(*equation_size(e) => size &*)
	Util.list_first(ass1) => ass1_first &
	vector_length(ass1_first) => size &
	array_create(size,0) => arr &
	mark_state_equations(dae,arr,m,mt,ass1,ass2) => arr' &
	split_blocks(blt,arr) => (blt_states,blt_no_states)
        -----------------------------------------
        generate_state_partition(blt,dae as DAELOW(v,kv,e,se,ie,ae,al,_),ass1,ass2,m,mt) => (blt_states,blt_no_states)
        
  rule  print "-generate_state_partition failed\n" 
        -----------------------------------------
        generate_state_partition(_,_,_,_,_,_) => fail
        
end


(** relation: split_blocks
 **
 ** Split the blocks into two parts, one dynamic and one output, depedning
 ** on if an equation in the block is marked or not.
 ** inputs:  (blocks: int list list, marks: int array) 
 ** outputs: (dynamic: int list list, output: int list list)
 **)
relation split_blocks:(Block list, int array) 
                   => (Block list, Block list) =

  axiom	split_blocks([],_) => ([], [])

  rule	(* block is dynamic, belong in dynamic section *)
	block_is_dynamic(block,arr) => true &
	split_blocks(blocks,arr) => (states,output) 
	---------------------------------------
	split_blocks(block::blocks,arr) => (block::states,output)

  rule	(* block is not dynamic, belong in output section *)
	split_blocks(blocks,arr) => (states,output) 
	---------------------------------------
	split_blocks(block::blocks,arr) => (states,block::output)
end


(* relation block_is_dynamic
 **
 ** Return true if the block contains a variable that is marked
 **)
relation block_is_dynamic: (Block, int array) => bool =

  axiom	block_is_dynamic(EQN_BLOCK([]),_) => false
	
  rule	int_sub(x,1) => x' &
	array_nth(arr,x') => 0 &
	block_is_dynamic(EQN_BLOCK(xs),arr) => res 
	---------------------
	block_is_dynamic(EQN_BLOCK(x::xs),arr) => res

  rule	int_sub(x,1) => x' &
	array_nth(arr,x') => mark_value &
	int_ne(mark_value,0) => true
	---------------------
	block_is_dynamic(EQN_BLOCK(x::xs),arr) => true

  rule	int_sub(x,1) => x' &
	array_nth(arr,x') => 0 &
	block_is_dynamic(EQN_BLOCK(xs),arr) => res 
	---------------------
	block_is_dynamic(COND_EQN_BLOCK(x::xs,_,_),arr) => res

  rule	int_sub(x,1) => x' &
	array_nth(arr,x') => mark_value &
	int_ne(mark_value,0) => true
	---------------------
	block_is_dynamic(COND_EQN_BLOCK(x::xs,_,_),arr) => true

end


(** relation: mark_state_equations
 **
 ** This relation goes through all equations and marks the ones that
 ** calculates a state, or is needed in order to calculate a state, 
 ** with a non-zero value in the array passed as argument.
 ** This is done by traversing the directed graph of nodes where
 ** a node is an equation/solved variable and following the edges in the 
 ** backward direction.
 ** inputs: (daeLow: DAELow, 
             marks: int array,
	  incidenceMatrix: IncidenceMatrix,
	  incidenceMatrixT: IncidenceMatrixT,
	  assignments1: int vector,
	  assignments2: int vector)
 ** outputs: marks: int array
 **)
relation mark_state_equations:(DAELow, 
                               int array,
                               IncidenceMatrix list,
                               IncidenceMatrixT list,
                               int vector list,
                               int vector list)
	  => int array = 

  rule	var_list(v) => v_lst &
	Util.list_select(v_lst,is_state_var) => statevar_lst &
	Util.list_fold(statevar_lst,mark_state_equation,(dae,arr,m,mt,a1,a2)) 
	  => ((dae,arr',m,mt,a1,a2))
	------------------------------------------------------------
	mark_state_equations(dae as DAELOW(v,kn,e,se,ie,ae,alg,_),arr,m,mt,a1,a2) => arr'

  rule	print "-mark_state_equations failed\n" 
	----------------
	mark_state_equations(_,_,_,_,_,_) => fail

end


(** relation: mark_state_equation
 **
 ** This relation is a helper relation to mark_state_equations
 ** It performs marking for one equation and its transitive closure by 
 ** following edges in backward direction.
 ** inputs and outputs are tuples so we can use Util.list_fold 
 **)
relation mark_state_equation: (Var, (DAELow * 
				     int array * 
				     IncidenceMatrix list * IncidenceMatrixT list *
				     int vector list * int vector list) 
			       ) => ((DAELow *
				     int array *
				     IncidenceMatrix  list*
				     IncidenceMatrixT list *
				     int vector list *
				     int vector list)) =
  rule	get_var(cr,vars) => (_,v_indxs) &
	Util.list_map_1(v_indxs,int_sub,1) => v_indxs' &
	mark_state_equation_find_eqns(v_indxs',a1) => eqns &
	mark_state_equation2(eqns,(arr,m,mt,a1,a2)) => ((arr',m,mt,a1,a2))
	--------------------
	mark_state_equation(VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,flow), 
			    (dae as DAELOW(vars,_,_,_,_,_,_,_),
			     arr,m,mt,a1,a2)
			    ) 
	  => ((dae,arr',m,mt,a1,a2))

  rule	not get_var(cr,vars) => (_,_) &
	print "mark_state_equation var " &
	Exp.print_component_ref_str cr => s &
	print s & print "not found\n" 
	-----------------------
	mark_state_equation(VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,flow),
			    (dae as DAELOW(vars,_,_,_,_,_,_,_),
			     arr,m,mt,a1,a2)) => fail

  rule	get_var(cr,vars) => (_,[v_indx]) &
	int_sub(v_indx,1) => v_indx' &
	print "mark_state_equation index ="  &
	int_string v_indx => str & print str & 
	print ", failed\n" 
	-----------------------
	mark_state_equation(VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,flow),
			    (dae as DAELOW(vars,_,_,_,_,_,_,_),
			     arr,m,mt,a1,a2)) => fail
end

(** relation: mark_state_equation_find_eqns
 ** author: PA
 **
 * Helper relation to mark_state_equation. Traverses all assignments and
 ** find equations that varaibles are defined in.
 **)
relation mark_state_equation_find_eqns: (int list,int vector list) 
	  => int list =

  axiom	mark_state_equation_find_eqns(_,[]) => []

  rule	Util.list_map_1r(v_indxs,vector_nth,a1) => eqns &
	mark_state_equation_find_eqns(v_indxs,a1_lst) => eqns2 &
	list_append(eqns,eqns2) => res
	---------------------
	mark_state_equation_find_eqns(v_indxs,a1::a1_lst) => res
end


(** relation: mark_state_equation2
 **
 ** Helper relation to mark_state_equation
 ** Does the job by looking at variable indexes and incidencematrices.
 ** inputs: (eqns: int list, 
             marks: (int array * IncidenceMatrix * IncidenceMatrixT * int vector * int vector)) 
 ** outputs: ((marks: int array * IncidenceMatrix * IncidenceMatrixT *
	      int vector * int vector))
 **)
relation mark_state_equation2: (int list, 
                                (int array * IncidenceMatrix list * 
                                 IncidenceMatrixT list * int vector list * int vector list)) 
	  => ((int array *  
	       IncidenceMatrix list * IncidenceMatrixT list *
	       int vector list * int vector list)) =
	
  axiom	mark_state_equation2([],(marks,m,mt,a1,a2)) => ((marks,m,mt,a1,a2))

  rule	(* Mark an unmarked node/equation *)
	int_sub(eqn,1) => eqn' &
	array_nth(marks,eqn') => 0 &
	array_setnth(marks,eqn',1) => marks' &
	inv_reachable_nodes(eqn,m,mt,a1,a2) => inv_reachable &
	remove_negative(inv_reachable) => inv_reachable' &
	Util.list_map(inv_reachable',Util.list_create) => inv_reachable'' &
	Util.list_fold(inv_reachable'',mark_state_equation2,(marks',m,mt,a1,a2)) 
	  => ((marks'',m,mt,a1,a2)) &
	mark_state_equation2(eqns,((marks'',m,mt,a1,a2))) 
	  => ((marks''',m',mt',a1',a2'))
	--------------------------
	mark_state_equation2(eqn::eqns,(marks,m,mt,a1,a2)) 
	  => ((marks''',m',mt',a1',a2'))

  rule	(* Node allready marked. *)
	int_sub(eqn,1) => eqn' &
	array_nth(marks,eqn') => mark_value &
	int_ne(mark_value,0) => true &
	mark_state_equation2(eqns,((marks,m,mt,a1,a2))) 
	  => ((marks',m',mt',a1',a2'))
	--------------------------
	mark_state_equation2(eqn::eqns,(marks,m,mt,a1,a2)) 
	  => ((marks',m',mt',a1',a2'))

  rule	print "mark_state_equation2 failed, eqn:" &
	int_string(eqn) => eqnstr &
	print eqnstr & print "array length =" &
	array_length(marks) => len & int_string(len) => lens &
	print lens & print "\n" &
	int_sub(eqn,1) => eqn' &
	array_nth(marks,eqn') => mark_value &
	int_string(mark_value) => ms & 
	print "mark_value:" & print ms &print "\n" 
	---------------------------
	mark_state_equation2(eqn::_,(marks,m,mt,a1,a2)) => fail
end


(** relation: inv_reachable_nodes
 **
 ** Similar to reachable_nodes, but follows edges in backward direction
 ** I.e. what equations/variables needs to be solved to solve this one.
 **)
relation inv_reachable_nodes:(int, IncidenceMatrix list, IncidenceMatrixT list, 
			      int vector list, int vector list) 
	  => int list =

  rule	int_sub(e,1) => eqn' &
	Util.list_map_1(m,array_nth,eqn') => var_llst &
	Util.list_list_union(var_llst) => var_lst &
	remove_negative(var_lst) => var_lst' &
	inv_reachable_nodes2(var_lst',a1) => lst
	---------------------
	inv_reachable_nodes(e,m,mt,a1,a2) => lst

  rule	print "-inv_reachable_nodes failed, eqn:"& 
	int_string(eqn) => eqn_str & print eqn_str & 
	print "\n" 
	--------------
	inv_reachable_nodes(eqn,_,_,_,_) => fail
end


(** relation: inv_reachable_nodes2
 **
 ** Helper relation to inv_reachable_nodes
 ** inputs:  (variables: int list, assignments1: int vector list)
 ** outputs: int list
 **)
relation inv_reachable_nodes2:(int list, int vector list) => int list  =

  axiom	inv_reachable_nodes2([],_) => []

  rule	inv_reachable_nodes2(vs,a1_lst) => eqns &
	int_sub(v,1) => v' &
	(* Which equation is variable solved in? *)
	Util.list_map_1(a1_lst,vector_nth,v') => eqn_lst &
	list_append(eqn_lst,eqns) => res
	----------------------
	inv_reachable_nodes2(v::vs,a1_lst) => res

  rule	print "-inv_reachable_nodes2 failed\n" 
	-------------------
	inv_reachable_nodes2(_,_) => fail
end
		  

(** relation: is_state_var
 **
 ** Returns true for state variables, false otherwise.
 **)
relation is_state_var: (Var) => bool =

  axiom	is_state_var (VAR(_,STATE,_,_,_,_,_,_,_,_,_,_,_,flow)) => true
  axiom	is_state_var(_) => false
end


(** relation: is_non_state 
 **
 ** this equation checks if the the varkind is state of variable
 ** used both in build_equation and generate_compute_state
 **)
relation is_non_state: VarKind => bool =
                                                 
  axiom	is_non_state (VARIABLE) => true
  axiom	is_non_state (PARAM) => true
  axiom	is_non_state (DUMMY_DER) => true
  axiom	is_non_state (DUMMY_STATE) => true
  axiom  is_non_state (DISCRETE) => true
  axiom  is_non_state (_) => false
end


(** relation: is_discrete
 **
 ** This equation checks if the the varkind is discrete,
 ** used both in build_equation and generate_compute_state
 **)
relation is_discrete: VarKind => () =
  axiom  is_discrete (DISCRETE) => ()
end


(** relation: dump
 **
 ** This relation dumps the DAELow representaton to stdout.
 **)
relation dump: DAELow => () =

  rule	print "Variables (" & 
	var_list(vars1) => vars &
	list_length(vars) => varlen &
	int_string(varlen) => varlen_str &
	print varlen_str & print ")\n" &
	print "=========\n" &

	dump_vars vars &
	print "\n" &
	print "Known Variables (constants) (" &
	var_list(vars2) => knvars &
	list_length(knvars) => varlen &
	int_string(varlen) => varlen_str &
	print varlen_str & print ")\n" &
	print "=============================\n" &
	dump_vars knvars &
	print "\nEquations (" &
	equation_list(eqns) => eqnsl &
	list_length(eqnsl) => eqnlen &
	int_string(eqnlen) => eqnlen_str &
	print eqnlen_str & print ")\n" &
	print "=========\n" &

	dump_eqns eqnsl &
	print "Simple Equations (" &
	equation_list(reqns) => reqnsl &
	list_length(reqnsl) => eqnlen &
	int_string(eqnlen) => eqnlen_str &
	print eqnlen_str & print ")\n" &
	print "=========\n" &
	dump_eqns reqnsl &
	print "Initial Equations (" &
	equation_list(ieqns) => ieqnsl &
	list_length(ieqnsl) => eqnlen &
	int_string(eqnlen) => eqnlen_str &
	print eqnlen_str & print ")\n" &
	print "=========\n" &
	dump_eqns ieqnsl  
	-----------------
	dump(DAELOW(vars1,vars2,eqns,reqns,ieqns,ae,algs,eventinfo))
end


(** relation: var_list
 **
 ** Takes Variables and returns a list of 'Var', useful for e.g. dumping.
 **)
relation var_list: (Variables) => Var list =

  rule	vararray_list(vararr) => varlst 
	--------------------------------------
	var_list(VARIABLES(_,_,vararr,_,_)) => varlst
end


(** relation: list_var
 ** author: PA
 **
 ** Takes Var list and creates a Variables structure, see also var_list.
 **)
relation list_var: (Var list ) => Variables =

  rule	empty_vars() => res
	-------------------
	list_var([]) => res

  rule	list_var(vs) => vars &
	add_var(v,vars) => vars' 
	--------------------------------------
	list_var(v::vs) => vars'
end


(** relation: var_cref
 ** author: PA
 **
 ** extracts the ComponentRef of a variable.
 **)
relation var_cref: (Var) => Exp.ComponentRef =

  axiom	var_cref(VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,flow)) => cr

end


(** relation: var_orig_name
 ** author: PA
 **
 ** extracts the original name of a variable.
 **)
relation var_orig_name: (Var) => string  =

  axiom	var_orig_name(VAR(_,_,_,_,_,_,_,_,_,s,_,_,_,_)) => s

end


(** relation: var_index
 ** author: PA
 **
 ** extracts the index in the implementation vector of a Var
 **)
relation var_index: (Var) => int =

  axiom	var_index(VAR(_,_,_,_,_,_,_,_,i,_,_,_,_,_)) => i

end


(** relation: var_nominal
 ** author: PA
 **
 ** Extacts the nominal attribute of a variable. If the variable has no 
 ** nominal value, the relation fails.
 **)
relation var_nominal: (Var) => real =

  axiom	var_nominal(VAR(_,_,_,_,_,_,_,_,_,_,_,SOME(DAE.VAR_ATTR_REAL(_,_,_,_,_,_,SOME(nominal),_)),_,flow))
	  => nominal
end


(** relation: vararray_list
 **
 ** Transforms a VariableArray to a Var list
 **)
relation vararray_list:(VariableArray) => Var list =

  axiom	vararray_list(VARIABLE_ARRAY(0,_,arr)) => []

  rule	array_nth(arr,0) => SOME(elt) 
	------------------
	vararray_list(VARIABLE_ARRAY(1,_,arr)) => [elt]

  rule	n  - 1 => lastpos &
	vararray_list2(arr,0,lastpos) => lst 
	---------------
	vararray_list(VARIABLE_ARRAY(n,size,arr)) => lst
end


(** relation: vararray_list2
 **
 ** Helper relation to vararray_list
**)
relation vararray_list2:(Var option array,int,int) => Var list =
	
  rule	int_eq (pos,lastpos) => true &
	array_nth(arr,pos) => SOME(v) 
	--------------------
	vararray_list2(arr,pos,lastpos) => [v]

  rule	pos + 1 => pos' &
	array_nth(arr,pos) => SOME(v) &
	vararray_list2(arr,pos',lastpos) => res
	---------------------------------------
	vararray_list2(arr,pos,lastpos) => v::res
end


(** relation: dump_jacobian_str
 **
 ** Dumps the sparse jacobian.
 ** Uses the variables to determine size of Jacobian matrix.
 **)
relation dump_jacobian_str: ((int*int*Equation) list option ) => string =

  rule	dump_jacobian_str2(eqns) => res &
	Util.string_delimit_list(res,", ") => res'
	------------------
	dump_jacobian_str(SOME(eqns)) => res'

  axiom	dump_jacobian_str(NONE) => "No analytic jacobian available\n"
end


(** relation: dump_jacobian_str2
 **
 ** Helper relation to dump_jacobian_str
**)
relation dump_jacobian_str2:((int*int*Equation) list) => string list =

  axiom	dump_jacobian_str2([]) => []

  rule	Exp.print_exp_str(e) => estr &
	int_string(row) => rowstr &
	int_string(col) => colstr &
	Util.string_append_list(["{",rowstr,",",colstr,"}:",estr]) => str &
	dump_jacobian_str2(eqns) => strs
	--------------------------------
	dump_jacobian_str2((row,col,RESIDUAL_EQUATION(e))::eqns) => str::strs
end


(** relation: dump_eqns
 **
 ** Helper relation to dump.
 **)
relation dump_eqns: Equation list => () =

  rule	dump_eqns2(eqns,1) 
	------------------
	dump_eqns(eqns)
end


(** relation: dump_eqns2
 **
 ** Helper relation to dump_eqns
 **)
relation dump_eqns2: (Equation list,int) => () =

  axiom	dump_eqns2([],_) => ()

  rule	equation_str eqn => es &
	int_string(index) => is &
	print is & print " : " & print es & print "\n" &
	index +1 => index' &
	dump_eqns2(eqns,index') 
	----------------
	dump_eqns2(eqn::eqns,index) => ()
end


(** relation: equation_str
 **
 ** Helper relation to e.g. dump.
 **)
relation equation_str: Equation => string =

  rule	Exp.print_exp_str e1 => s1 &
	Exp.print_exp_str e2 => s2 &
	Util.string_append_list([s1," = ",s2]) => res
	--------------------
	equation_str(EQUATION(e1,e2)) => res

  rule	int_string(indx) => indx_str &
	Util.string_append_list(["Array eqn no: ",indx_str,"\n"]) => res
	--------------------
	equation_str(ARRAY_EQUATION(indx,expl)) => res

  rule	Exp.print_component_ref_str cr => s1 &
	Exp.print_exp_str e2 => s2 &
	Util.string_append_list([s1," := ",s2]) => res
	--------------------
	equation_str(SOLVED_EQUATION(cr,e2)) => res

  rule	Exp.print_component_ref_str cr => s1 &
	Exp.print_exp_str e2 => s2 &
	int_string(i) => is &
	Util.string_append_list([s1," := ",s2 ,"when clause no:",is,"\n"]) => res
	----------------------------------------------------
	equation_str(WHEN_EQUATION(WHEN_EQ(i,cr,e2))) => res

  rule	Exp.print_exp_str e => s1 &
	Util.string_append_list([s1, "= 0"]) => res
	----------------------------------------------------------
	equation_str(RESIDUAL_EQUATION(e)) => res

  rule	int_string(i) => is &
	Util.string_append_list(["Algorithm no: ",is,"\n"]) => res
	----------------------------------------------------------
	equation_str(ALGORITHM(i,_,_)) => res
end


(** relation: remove_simple_equations
 **
 ** This relation moves simple equations on the form a=b from equations 2nd 
 ** in DAELow to simple equations 3rd in DAELow to speed up assignment alg.
 ** inputs:  (vars: Variables,
              knownVars: Variables,
              eqns: Equation list,
              simpleEqns: Equation list,
              binTree: BinTree) 
 ** outputs: (Variables, Variables, Equation list, Equation list)
 **)
relation remove_simple_equations: (Variables,
                                   Variables,
                                   Equation list,
                                   Equation list,
                                   BinTree) 
	=> (Variables, Variables, Equation list, Equation list) =

  rule	VarTransform.empty_replacements() => repl &
	remove_simple_equations2(eqns,vars,knvars,empty_bintree,states,repl) 
	  => (eqns',seqns,movedvars',vartransf) &
 	Debug.fcall("dumprepl",VarTransform.dump_replacements, vartransf) &
	VarTransform.replace_equations(eqns',vartransf) => eqns'' &
	VarTransform.replace_equations(seqns,vartransf) => seqns' &
	move_variables(vars,knvars,movedvars')=> (vars',knvars') 

	(*& print_vars_statistics(vars',knvars')*)
	-------------------------------------
	remove_simple_equations(vars,knvars,eqns,reqns,states) 
	  => (vars',knvars',eqns'',seqns')

  rule	print "-remove_simple_equations failed\n"  
	------------------------
	remove_simple_equations(_,_,_,_,_) => fail
end


(** relation: remove_simple_equations2
 **
 ** helper relation to remove_simple_equations
 ** inputs:  (allEqns: Equation list,
              variables: Variables,
              knownVars: Variables,
              movedVars: BinTree,
              states: BinTree,
              varReplacements: VarTransform.VariableReplacements)
 ** outputs:  (diffEqns: Equation list, /* diff equations and non-simple equations  */  
               simpleEqns: Equation list, /* simple equations*/ 
               movedVars: BinTree, /* moved variables */ 
               replacementsLst: VarTransform.VariableReplacements) /*  list of replacements */
 **)
relation remove_simple_equations2: (Equation list, 
                                    Variables,
                                    Variables,
                                    BinTree,
                                    BinTree,
                                    VarTransform.VariableReplacements)
	  => (Equation list,   
	      Equation list, 
	      BinTree, 
	      VarTransform.VariableReplacements) =

  axiom	remove_simple_equations2([],vars,knvars,mvars,states,repl)  
	  => ([],[],mvars,repl) 

  rule	(* Both are states, i.e. x1 = x2 can not be removed *)
	simple_equation(e) => (cr1,cr2) &
	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &
	tree_get(states,cr1) => _ &
	tree_get(states,cr2) => _ &
	remove_simple_equations2(eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',seqns',mvars',repl)
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (e::eqns',seqns',mvars',repl)
	  
  rule	(* cr1 is state and cr2 not, remove cr2*)
	simple_equation(e) => (cr1,cr2) &
        (* is the variable to be removed is output the do not remove it *)
        is_top_level_input_or_output(cr2,vars,knvars) => false &
	typeof_equation(e) => t &
	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &
	(* cr2 cannot be parameter or state*)
	is_variable(cr2,vars,knvars) & not tree_get(states,cr2) => _ &

	not VarTransform.get_replacement(repl,cr2) => _ &
	tree_get(states,cr1) => _ &
	VarTransform.add_replacement(repl,cr2,cr1) => repl' &
	tree_add(mvars,cr2,0) => mvars' &
	remove_simple_equations2(eqns,vars,knvars,mvars',states,repl') 
	  => (eqns',seqns',mvars'',repl'')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',SOLVED_EQUATION(cr2,Exp.CREF(cr1,t))::seqns',mvars'',repl'')

  rule	(* as above but swapped args: cr1 is state and cr2 not, remove cr2*)
	simple_equation(e) => (cr2,cr1) &
        (* is the variable to be removed is output the do not remove it *)
        is_top_level_input_or_output(cr2,vars,knvars) => false &
	typeof_equation(e) => t &
	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &

	(* cr2 cannot be parameter or state *)
	is_variable(cr2,vars,knvars) & not tree_get(states,cr2) => _ &
	not VarTransform.get_replacement(repl,cr2) => _ &
	tree_get(states,cr1) => _ &
	VarTransform.add_replacement(repl,cr2,cr1) => repl' &
	tree_add(mvars,cr2,0) => mvars' &
	remove_simple_equations2(eqns,vars,knvars,mvars',states,repl') 
	  => (eqns',seqns',mvars'',repl'')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',SOLVED_EQUATION(cr2,Exp.CREF(cr1,t))::seqns',mvars'',repl'')

  rule	(* cr1 variable, cr2 constant, remove cr1 *)
	simple_equation(e) => (cr1,cr2) &
	typeof_equation(e) => t &
        (* is the variable to be removed is output the do not remove it *)
        is_top_level_input_or_output(cr1,vars,knvars) => false &

	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &
	not VarTransform.get_replacement(repl,cr1) => _ &
	is_variable(cr1,vars,knvars) & not tree_get(states,cr1) => _ &
	not is_variable(cr2,vars,knvars) &
	VarTransform.add_replacement(repl,cr1,cr2) => repl' &
	tree_add(mvars,cr1,0) => mvars' &
	remove_simple_equations2(eqns,vars,knvars,mvars',states,repl') 
	  => (eqns',seqns',mvars'',repl'')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',SOLVED_EQUATION(cr1,Exp.CREF(cr2,t))::seqns',mvars'',repl'')

  rule	(* same as above but swapped args: remove cr1 *)
  	simple_equation(e) => (cr2,cr1) &
	typeof_equation(e) => t &
        (* is the variable to be removed is output the do not remove it *)
        is_top_level_input_or_output(cr1,vars,knvars) => false &

	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &
	not VarTransform.get_replacement(repl,cr1) => _ &
	is_variable(cr1,vars,knvars) & not tree_get(states,cr1) => _ &
	not is_variable(cr2,vars,knvars) &
	VarTransform.add_replacement(repl,cr1,cr2) => repl' &
	tree_add(mvars,cr1,0) => mvars' &
	remove_simple_equations2(eqns,vars,knvars,mvars',states,repl') 
	  => (eqns',seqns',mvars'',repl'')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',SOLVED_EQUATION(cr1,Exp.CREF(cr2,t))::seqns',mvars'',repl'')

  rule	(* None are states, but  variables, remove cr1 *)
	simple_equation(e) => (cr1,cr2) &
	typeof_equation(e) => t &
        (* is the variable to be removed is output the do not remove it *)
        is_top_level_input_or_output(cr1,vars,knvars) => false &

	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &
	not VarTransform.get_replacement(repl,cr1) => _ &
	not tree_get(states,cr1) => _ &
	not tree_get(states,cr2) => _ &
	is_variable(cr1,vars,knvars) &
	is_variable(cr2,vars,knvars) &
	VarTransform.add_replacement(repl,cr1,cr2) => repl' & 
	tree_add(mvars,cr1,0) => mvars' &
	remove_simple_equations2(eqns,vars,knvars,mvars',states,repl') 
	  => (eqns',seqns',mvars'',repl'')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',SOLVED_EQUATION(cr1,Exp.CREF(cr2,t))::seqns',mvars'',repl'')

  rule	(* same as above but swapped args, remove cr1 *)
  	simple_equation(e) => (cr1,cr2) &
	typeof_equation(e) => t &
        (* is the variable to be removed is output the do not remove it *)
        is_top_level_input_or_output(cr1,vars,knvars) => false &

	VarTransform.apply_replacements(repl,cr1,cr2) => (cr1,cr2) &
	not VarTransform.get_replacement(repl,cr1) => _ &
	not tree_get(states,cr1) => _ &
	not tree_get(states,cr2) => _ &
	is_variable(cr1,vars,knvars) &
	is_variable(cr2,vars,knvars) &
	VarTransform.add_replacement(repl,cr1,cr2) => repl' & 
	tree_add(mvars,cr1,0) => mvars' &
		remove_simple_equations2(eqns,vars,knvars,mvars',states,repl') 
	  => (eqns',seqns',mvars'',repl'')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',SOLVED_EQUATION(cr1,Exp.CREF(cr2,t))::seqns',mvars'',repl'')

  rule	(* Not a simple variable, check rest*)
	remove_simple_equations2(eqns,vars,knvars,mvars,states,repl) 
	  => (eqns',seqns',mvars',repl')
	--------------------------------------------------
	remove_simple_equations2(e::eqns,vars,knvars,mvars,states,repl) 
	  => (e::eqns',seqns',mvars',repl')
end 


(** relation is_top_level_input_or_output
 ** author: LP
 **
 ** This relation checks if the provided cr is from a var that is on top model
 ** and is an input or an output, and returns true for such variables.
 ** It also returns true for input/output connector variables, i.e. variables 
 ** instantiated from a  connector class, that are instantiated on the top level.
 ** The check for top-model is done by spliting the old name at '.' and 
 ** check if the list-lenght is 1.
 ** Note: The relation needs the known variables to search for input variables 
 ** on the top level.
 ** inputs:  (cref: Exp.ComponentRef, 
              vars: Variables, /* Variables */
              knownVars: Variables /* Known Variables */) 
 ** outputs: bool
 **) 
relation is_top_level_input_or_output:(Exp.ComponentRef, Variables, Variables) => bool =

  rule  get_var(cr,vars) => (VAR(cr,kind,DAE.OUTPUT,_,_,_,_,_,_,old_name,_,_,_,flow)::_,_) &
        Util.string_split_at_char(old_name, #".") => cr_str_lst &
        list_length(cr_str_lst) => 1
        ---------------------------------------------
        is_top_level_input_or_output(cr,vars,_) => true
   

  rule	(* input variables stored in known variables are input on top level *)
	get_var(cr,knvars) => (VAR(cr,kind,DAE.INPUT,_,_,_,_,_,_,_,_,_,_,flow)::_,_)
	--------------------------------------------------------------------
	is_top_level_input_or_output(cr,vars,knvars) => true

  axiom is_top_level_input_or_output(_,_,_) => false

end
                                  

(** relation is_var_on_top_level_and_output
 **
 ** this relation checks if the provided cr is from a var that is on top model
 ** and has the DAE.VarDirection = OUTPUT
 ** The check for top-model is done by spliting the old name at '.' and 
 ** check if the list-lenght is 1
 **) 
relation is_var_on_top_level_and_output:(Var) => bool =

  rule  top_level_output(cr,dir,flow) => ()
        ---------------------------------------------
        is_var_on_top_level_and_output(VAR(cr,kind,dir,_,_,_,_,_,_,old_name,_,_,_,flow)) => true
   
  axiom is_var_on_top_level_and_output(_) => false

end

                                  
(** relation is_var_on_top_level_and_input
 **
 ** this relation checks if the provided cr is from a var that is on top model
 ** and has the DAE.VarDirection = INPUT
 ** The check for top-model is done by spliting the old name at '.' and 
 ** check if the list-lenght is 1
 **) 
relation is_var_on_top_level_and_input:(Var) => bool =

  rule  top_level_input(Exp.CREF_IDENT(old_name,[]),dir,flow) => () 
        ---------------------------------------------
        is_var_on_top_level_and_input(VAR(cr,kind,dir,_,_,_,_,_,_,old_name,_,_,_,flow)) => true
   
  axiom is_var_on_top_level_and_input(_) => false

end

                                  
(** relation: typeof_equation
 **
 ** Returns the Exp.Type of an equation
**)
relation typeof_equation: (Equation) => Exp.Type =

  rule	Exp.typeof(e) => t
	-------------------
	typeof_equation(EQUATION(e,_)) => t
	
  rule	Exp.typeof(e) => t 
	-------------------
	typeof_equation(SOLVED_EQUATION(_,e)) => t

  rule	Exp.typeof(e) => t 
	-------------------
	typeof_equation(WHEN_EQUATION(WHEN_EQ(_,_,e))) => t
end


(** relation: move_variables
 **
 ** This relation takes the two variable lists of a dae (states+alg) and
 ** known vars and moves a set of variables from the first to the second set.
 ** This relation is needed to manage this in complexity O(n) by only 
 ** traversing the set once for all variables.
 ** inputs:  (algAndState: Variables, /* alg+state */
              known: Variables,       /* known */
              binTree: BinTree)       /* vars to move from first7 to second */
 ** outputs:  (Variables,	      /* updated alg+state vars */
               Variables)             /* updated known vars */
 **)
relation move_variables:(Variables, Variables, BinTree) => (Variables, Variables) =
	
  rule	var_list(vars1) => lst1 &
	var_list(vars2) => lst2 &
	move_variables2(lst1,lst2,mvars) => (lst1',lst2') &
	empty_vars() => v1 &
	empty_vars() => v2 &
	add_vars(lst1',v1) => vars &
	add_vars(lst2',v2) => knvars 
	--------------------------------------------------------
	move_variables(vars1, vars2, mvars)
	  => (vars,knvars)
end


(** relation: move_variables2
 **
 ** helper relation to move_variables.
 ** inputs:  (Var list,	/* alg+state vars as list */
              Var list,	/* known vars as list */
              BinTree)	/* move-variables as BinTree */
 ** outputs: (Var list,	/* updated alg+state vars as list */
              Var list)	/* update known vars as list */
 **)
relation move_variables2: (Var list, Var list, BinTree) => (Var list, Var list) =

  axiom	move_variables2([],knvars,_) => ([],knvars)

  rule	(* alg var moved to known vars*)
	tree_get(mvars,cr) => _ &
	move_variables2(vs,knvars,mvars) => (vs',knvars')
	--------------------------
	move_variables2((v as VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,flow))::vs,knvars,mvars)
	  => (vs',v::knvars')
	  
  rule	(* alg var not moved to known vars*)
	not tree_get(mvars,cr) => _ &
	move_variables2(vs,knvars,mvars) => (vs',knvars')
	--------------------------
	move_variables2((v as VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,flow))::vs,knvars,mvars)
	  => (v::vs',knvars')
end


(** relation: is_variable
 **
 ** This relation takes a Exp.ComponentRef and two Variables. It searches
 ** the two sets of variables and succeed if the variable is STATE or 
 ** VARIABLE. Otherwise it fails.
 ** Note: An array variable is currently assumed that each scalar element has
 ** the same type.
 ** inputs:  (Exp.ComponentRef, 
              Variables, /* vars */
              Variables) /* known vars */
 ** outputs: ()
 **)
relation is_variable: (Exp.ComponentRef, Variables, Variables) => () =

  rule	get_var(cr,vars) => (VAR(_,VARIABLE,_,_,_,_,_,_,_,_,_,_,_,flow)::_,_)
	---------------------------------------------------------
	is_variable(cr,vars,_) => ()

  rule	get_var(cr,vars) => (VAR(_,STATE,_,_,_,_,_,_,_,_,_,_,_,flow)::_,_)
	------------------------------------------------------
	is_variable(cr,vars,_) => ()

  rule	get_var(cr,knvars) => (VAR(_,VARIABLE,_,_,_,_,_,_,_,_,_,_,_,flow)::_,_)
	-----------------------------------------------------------
	is_variable(cr,_,knvars) => ()
end


(** relation: simple_equation
 **
 ** This relation investigates if an Equation is simple, i.e. on the form
 ** a = b or a-b=0 
 ** These relations can be removed from the set of equations.
 **) 
relation simple_equation: (Equation) => (Exp.ComponentRef, Exp.ComponentRef) =

  axiom	simple_equation EQUATION(Exp.CREF(cr1,_),Exp.CREF(cr2,_)) => (cr1,cr2)

  rule	Exp.is_zero(e) => true
	----------------------------------
	simple_equation(EQUATION(Exp.BINARY(Exp.CREF(cr1,_),Exp.SUB(_),Exp.CREF(cr2,_)),e))
	  => (cr1,cr2)

  rule	Exp.is_zero(e) => true
	----------------------------------
	simple_equation(EQUATION(e,Exp.BINARY(Exp.CREF(cr1,_),Exp.SUB(_),Exp.CREF(cr2,_))))
	  => (cr1,cr2)
end


(** relation: remove_variable_named
 **
 ** Removes a varaible from the 'Variables' set given a ComponentRef name.
 ** The removed variable is returned, such that is can be used elsewhere.
 **)
relation remove_variable_named: (Variables,  Exp.ComponentRef) => (Variables, Var) =

  rule	not get_var(cr,vars) => (_,_) &
	print "-remove_variable_named failed. variable " 
	& Exp.print_component_ref_str cr => str &
	print str & print " not found.\n" 
	---------------------
 	remove_variable_named(vars,cr)  => fail

  rule	get_var(cr,vars) => (vs,_) &
	Util.list_map(vs,var_cref) => crefs &
	Util.list_fold(crefs,delete_var,vars) => vars' &
	(* NOTE: returns first var even if array variable *)
	Util.list_first(vs) => var
	------------------------------
	remove_variable_named(vars,cr) => (vars',var)

  rule	print "-remove_variable_named failed\n" 
	--------------------
	remove_variable_named(_,_) => fail
end


(** relation: dump_vars
 **
 ** Helper relation to dump.
 **)
relation dump_vars: Var list => ()=

  rule	dump_vars2(vars,1) 
	----------------
	dump_vars(vars)
end


(** relation: dump_vars2
 **
 ** Helper relation to dump_vars.
 **)
relation dump_vars2: (Var list,int) => () =

  axiom	dump_vars2([],_) => ()

  rule	int_string (varno) => varnostr &
	print varnostr & print ": " &
	DAE.dump_direction_str dir => dirstr & print dirstr & print " " &
	Exp.print_component_ref_str(cr) => str &
	print str & print ":" & dump_kind kind &
	Util.list_map(paths,Absyn.path_string) => paths_lst &
	Util.string_delimit_list(paths_lst,", ") => path_str &
        Dump.unparse_comment_option(comment) => comment_str &
	print "= " & Exp.print_exp_str e => s & print s & print(" ") & print(path_str) & 
        (*print "  " & print comment_str &
        
        print " former: " & print old_name &
	int_string(indx) => indx_str & print " indx = " & print indx_str &*)
	int_add(varno,1) => varno' & 
	print "\n" &
    	(*DAE.dump_variable_attributes(dae_var_attr) &*)
        dump_vars2(xs,varno') 
	    -------------
	dump_vars2(VAR(cr,kind,dir,_,SOME(e),_,_,_,indx,old_name,paths,dae_var_attr,comment,flow)::xs,varno)

  rule  int_string (varno) => varnostr &
	print varnostr & print ": " &
	DAE.dump_direction_str dir => dirstr & print dirstr & print " " &
	Exp.print_component_ref_str(cr) => str &
	Util.list_map(paths,Absyn.path_string) => path_strs &
	Util.string_delimit_list(path_strs, ", ") => path_str &
        Dump.unparse_comment_option(comment) => comment_str &
	print str & print ":" & dump_kind kind & print(" ") & print(path_str) & 
        (*print " former: " & print old_name &
	int_string(indx) => indx_str & print " indx = " & print indx_str &
	DAE.dump_variable_attributes(dae_var_attr) &
        print "  " & print comment_str & 
        print ",\n" &*)
	print "\n" &
	int_add(varno,1) => varno' &
 	dump_vars2(xs,varno') 
	-------------
	dump_vars2(VAR(cr,kind,dir,_,NONE,_,_,_,indx,old_name,paths,dae_var_attr,comment,flow)::xs,varno)
end 


(** relation: dump_kind
 **
 ** Helper relation to dump.
 **)
relation dump_kind: VarKind => () =

  rule	print "VARIABLE" 
	--------------
	dump_kind VARIABLE

  rule	print "STATE" 
	--------------
	dump_kind STATE

  rule	print "DUMMY_DER" 
	--------------
	dump_kind DUMMY_DER

  rule	print "DUMMY_STATE" 
	--------------
	dump_kind DUMMY_STATE

  rule	print "DISCRETE" 
	--------------
	dump_kind DISCRETE

  rule	print "PARAM" 
	--------------
	dump_kind PARAM

  rule	print "CONST" 
	--------------
	dump_kind CONST
end


(** relation: states
 **
 ** Returns a BinTree of all states in the DAE.
 ** This relation is used by the lower relation.
 **)
relation states: (DAE.DAElist,BinTree) => BinTree =

  axiom states (DAE.DAE([]),bt) => bt

  rule	states(DAE.DAE(xs),bt) => bt &
	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------------
	states(DAE.DAE(DAE.EQUATION(e1,e2)::xs),bt)  => bt

  rule	states(DAE.DAE(xs),bt) => bt &
	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------------
	states(DAE.DAE(DAE.ARRAY_EQUATION(_,e1,e2)::xs),bt)  => bt

  rule	states(dae,bt) => bt &
	states(DAE.DAE(xs),bt) => bt 
	-------------------------
	states(DAE.DAE(DAE.COMP(_,dae)::xs),bt) => bt
	
  rule  states(DAE.DAE(xs),bt) => bt
	-----------------
	states(DAE.DAE(_::xs),bt) => bt
end


(** relation: states_exp
 **
 ** Helper relation to states.
 **)
relation states_exp: (Exp.Exp,BinTree) => BinTree =

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------
	states_exp(Exp.BINARY(e1,_,e2),bt) => bt

  rule	states_exp(e,bt) => bt
	-----------------------------
	states_exp(Exp.UNARY(_,e),bt) => bt

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------
	states_exp(Exp.LBINARY(e1,_,e2),bt) => bt
	
  rule	states_exp(e,bt) => bt
	----------------------
	states_exp(Exp.LUNARY(_,e),bt) => bt

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-------------------------
	states_exp(Exp.RELATION(e1,_,e2),bt) => bt
	
  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt &
	states_exp(e3,bt) => bt 
	-------------------------
	states_exp(Exp.IFEXP(e1,e2,e3),bt) => bt

  rule	(* value irrelevant, give zero *)
	Exp.stringify_component_ref(cr) => cr' &
	tree_add(bt,cr',0) => bt
	-----------------------
	states_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),bt) => bt

  rule	Util.list_fold(expl,states_exp,bt) => bt 
	----------------------------------------
	states_exp(Exp.CALL(_,expl,_,_),bt) => bt
	
  rule	Util.list_fold(expl,states_exp,bt) => bt 
	----------------------------------------
	states_exp(Exp.ARRAY(_,_,expl),bt) => bt

  rule	states_exp_matrix(m,bt) => bt
	---------------------------------------
	states_exp(Exp.MATRIX(_,_,m),bt) => bt
	
  rule	Util.list_fold(expl,states_exp,bt) => bt 
	----------------------------------------
	states_exp(Exp.TUPLE(expl),bt) => bt

  rule	states_exp(e,bt) => bt
	-----------------------
	states_exp(Exp.CAST(_,e),bt) => bt

  rule	states_exp(e,bt) => bt
	-----------------------
	states_exp(Exp.ASUB(e,_),bt) => bt

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------
	states_exp(Exp.REDUCTION(_,e1,_,e2),bt) => bt

  axiom	states_exp(_,bt) => bt
end

(** relation: states_exp_matrix
 ** author: PA
 ** 
 ** Helper relation to states_exp. Deals with matrix exp list.
 **)

relation states_exp_matrix: ((Exp.Exp * bool) list list, BinTree) => BinTree =

  rule	Util.list_list_map(expl,Util.tuple2_1) => expl' &
	Util.list_flatten(expl') => expl'' &
	Util.list_fold(expl'',states_exp,bt) => bt 
	---------------------
	states_exp_matrix(expl,bt) => bt

  rule	Debug.fprint("failtrace","-states_exp_matrix failed\n")
	-------------------------
	states_exp_matrix(_,_) => fail
end

(** relation: lower_when_eqn
 **
 ** This relation lowers a when clause. The condition expresion is put in the 
 ** WhenClause list and the equations inside are put in the equation list.
 ** For each equation in the clause a new entry in the WhenClause list is generated
 ** and one extra for all the reinit statements.
 ** inputs:  (DAE.Element, int /* when-clause index */, WhenClause list)  
 ** outputs: (Equation list, Variables, int /* when-clause index */, WhenClause list)
 **)
relation lower_when_eqn: (DAE.Element, int, WhenClause list)  
                     =>  (Equation list, Variables, int, WhenClause list) =

  rule	empty_vars() => vars &
	lower_when_eqn2(eqnl,i) => (res, reinit) &
         list_length(res) => equation_count &
	list_length(reinit) => reinit_count &
         reinit_count > 0 => hasReinit &
	Util.if(hasReinit,1,0) => extra &
	equation_count + extra => tot_count &
	i + tot_count => i' &
         make_WhenClauses(equation_count,cond,[]) => whenClauseList1 &
         make_WhenClauses(extra,cond,reinit) => whenClauseList2 &
	list_append(whenClauseList2,whenClauseList1) => whenClauseList3 &
	list_append(whenClauseList3,whenList) => whenClauseList4 
	--------------------------------------
	lower_when_eqn(DAE.WHEN_EQUATION(cond,eqnl,NONE(* No elsewhen yet *)),i,whenList)  
	  => (res,vars,i',whenClauseList4)
end


(** relation: make_WhenClauses
 ** Constructs a list of identical WhenClause elements
 ** Arg1: Number of elements to construct
 ** Arg2: condition expression of the when clause
 ** inputs:  (int, /* number of copies to make */
              Exp.Exp, 
              ReinitStatement list) 
 ** outputs: (WhenClause list)
 **)
relation make_WhenClauses: (int, Exp.Exp, ReinitStatement list) => (WhenClause list) =

  axiom make_WhenClauses(0,_,_) => []

  rule	i  - 1 => i' &
	make_WhenClauses(i',cond,reinit) => res
	--------------------------------------------------
	make_WhenClauses(i,cond,reinit) => WHEN_CLAUSE(cond,reinit)::res

end


(** relation: lower_when_eqn2
 **
 ** Helper relation to lower_when_eqn.
 **)
relation lower_when_eqn2: (DAE.Element list, int) => (Equation list, ReinitStatement list) = 
	
  axiom lower_when_eqn2([],_) => ([],[])

  rule	i + 1 => i' &
	lower_when_eqn2(xs,i') => (eqnl,reinit) &
	Exp.simplify(e) => e' &
	Exp.stringify_crefs(e') => e'' &
	Exp.stringify_component_ref(cr) => cr'
	------------------------------
	lower_when_eqn2(DAE.EQUATION(cre as Exp.CREF(cr,_) ,e)::xs, i) 
	  => (WHEN_EQUATION(WHEN_EQ(i,cr',e''))::eqnl,reinit)

  rule	lower_when_eqn2(xs,i) => (eqnl,reinit) &
	Exp.simplify(e) => e' &
	Exp.stringify_crefs(e') => e'' &
	Exp.stringify_component_ref(cr) => cr'
	------------------------------
	lower_when_eqn2(DAE.REINIT(cr,e)::xs, i) 
	  => (eqnl,REINIT(cr',e'')::reinit)

end


(** relation: lower2
 **
 ** Helper relation to lower.
 ** inputs:  (DAE.DAElist, 
              BinTree /* states */, 
              WhenClause list) 
 ** outputs: (Variables,
              Variables,
              Equation list,
              Equation list,
              Equation list,
              MultiDimEquation list,
              Algorithm.Algorithm list,
              WhenClause list)
 **)
relation lower2: (DAE.DAElist, BinTree, WhenClause list) 
	  => (Variables,
	      Variables,
	      Equation list,
	      Equation list,
	      Equation list,
	      MultiDimEquation list,
	      Algorithm.Algorithm list,
	      WhenClause list) =
	
  rule	empty_vars() => v1 &
	empty_vars() => v2
	------------------
	lower2 (DAE.DAE([]),_,whenclauses) => (v1,v2,[],[],[],[],[],whenclauses)
	
  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses') &
	lower_var (v,states) => v' &
	add_var(v',vars) => vars' 
	--------------------------------
	lower2 (DAE.DAE((v as DAE.VAR(_,_,_,_,_,_,_,_,_,_,_))::xs),states,whenclauses) 
	  => (vars',knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses')


  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses') &
	(* in previous rule, lower_var failed.  *)
	lower_known_var (v) => v' &
	add_var(v',knvars) => knvars'
	--------------------------------
	lower2 (DAE.DAE((v as DAE.VAR(_,_,_,_,_,_,_,_,_,_,_))::xs),states,whenclauses) 
	  => (vars,knvars',eqns,reqns,ieqns,aeqns,algs,whenclauses')
	  
	  (* scalar equations *)
  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses') &
	lower_eqn(e) => e' 
	--------------------------------
	lower2 (DAE.DAE((e as DAE.EQUATION(e1,e2))::xs),states,whenclauses) 
	  => (vars,knvars,e'::eqns,reqns,ieqns,aeqns,algs,whenclauses')

	  (* array equations *)
  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses') &
	lower_arr_eqn(e) => e' 
	--------------------------------
	lower2 (DAE.DAE((e as DAE.ARRAY_EQUATION(ds,e1,e2))::xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,e'::aeqns,algs,whenclauses')


  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars1,knvars,eqns1,reqns,ieqns,aeqns,algs,whenclauses') &
	list_length whenclauses' => count &
	lower_when_eqn(e,count,whenclauses') => (eqns2,vars2,count',whenclauses'') &
	merge_vars(vars1,vars2) => vars & 
	list_append(eqns1,eqns2) => eqns 
	--------------------------------
	lower2 (DAE.DAE((e as DAE.WHEN_EQUATION(c,eqns,NONE))::xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses'')


  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses') &
	lower_eqn(e) => e' 
	--------------------------------
	lower2 (DAE.DAE((e as DAE.INITIALEQUATION(e1,e2))::xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,e'::ieqns,aeqns,algs,whenclauses')

  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses') 
	--------------------------------
	lower2 (DAE.DAE((DAE.ALGORITHM(a))::xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,a::algs,whenclauses')

  rule	lower2(dae,states,whenclauses) 
	  => (vars1,knvars1,eqns1,reqns1,ieqns1,aeqns1,algs1,whenclauses') &
	lower2(DAE.DAE(xs),states,whenclauses') 
	  => (vars2,knvars2,eqns2,reqns2,ieqns2,aeqns2,algs2,whenclauses'') &
	merge_vars(vars1,vars2) => vars &
	list_append(eqns1,eqns2) => eqns &
	list_append(ieqns1,ieqns2) => ieqns &
	list_append(reqns1,reqns2) => reqns &
	list_append(aeqns1,aeqns2) => aeqns &
	merge_vars(knvars1,knvars2) => knvars &
	list_append(algs1,algs2) => algs 
	--------------------------------
	lower2(DAE.DAE(DAE.COMP(_,dae)::xs),states,whenclauses) 
	  => (vars,knvars,eqns,reqns,ieqns,aeqns,algs,whenclauses'')

  rule	Error.add_message(Error.UNSUPPORTED_LANGUAGE_FEATURE,["if-equations","rewrite equations using if-expressions"])
	---------------------
	lower2 (DAE.DAE(DAE.IF_EQUATION(_,_,_)::xs),states,whenclauses) => fail

  rule	Error.add_message(Error.UNSUPPORTED_LANGUAGE_FEATURE,["if-equations","rewrite equations using if-expressions"])
	---------------------------------
	lower2 (DAE.DAE(DAE.INITIAL_IF_EQUATION(_,_,_)::xs),states,whenclauses) => fail

  rule	(*Print.print_error_buf "#Warning, Asserts are not supported/checked for.\n" &*)
	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (v,kv,e,re,ie,ae,al,whenclauses')

	---------------------
	lower2 (DAE.DAE(DAE.ASSERT(_)::xs),states,whenclauses) 
	  => (v,kv,e,re,ie,ae,al,whenclauses')
	
  rule	lower2(DAE.DAE(xs),states,whenclauses) 
	  => (v,kv,e,re,ie,ae,al,whenclauses')
	---------------------
	lower2 (DAE.DAE(_::xs),states,whenclauses) 
	  => (v,kv,e,re,ie,ae,al,whenclauses')

  rule	print "-lower2 failed\n" 
	------------------------
	lower2 (_,_,_) => fail	
end


(** relation: lower_multidimeqns
 ** author: PA
 ** 
 ** Lowers MultiDimEquations by creating ARRAY_EQUATION nodes that points
 ** to the array equation, stored in a MultiDimEquation array.
 ** each MultiDimEquation has as many ARRAY_EQUATION nodes as it has array
 ** elements. This to ensure correct sorting using BLT.
 ** inputs:  (Variables, /* vars */
              MultiDimEquation list)
 ** outputs: Equation list
 **)
relation lower_multidimeqns: (Variables, MultiDimEquation list) => Equation list =

  rule	lower_multidimeqns2(vars,algs,0) => (eqns,_)
	---------------------
	lower_multidimeqns(vars,algs) => eqns
end


(** relation: lower_multidimeqns2
 **
 ** Helper relation to lower_multidimeqns. To handle indexes in Equation nodes
 ** for multidimensional equations to indentify the corresponding 
 ** MultiDimEquation
 ** inputs:  (Variables, /* vars */
              MultiDimEquation list, 
              int /* index */) 
 ** outputs: (Equation list,
	    int) /* updated index */
 **)
 relation lower_multidimeqns2: (Variables, MultiDimEquation list, int) => (Equation list, int) =
	
  axiom	lower_multidimeqns2(vars,[],aindx) => ([],aindx)
	
  rule	lower_multidimeqn(vars,a,aindx) => eqns & 
	int_add(aindx, 1) => aindx &
	lower_multidimeqns2(vars,algs,aindx) => (eqns2,aindx) &
	list_append(eqns,eqns2) => res
	------------------------
	lower_multidimeqns2 (vars,a::algs,aindx) => (res,aindx)
end


(** relation: lower_multidimeqn
 **
 ** Lowers a MultiDimEquation by creating an equation for each array
 ** index, such that BLT can be run correctly.
 ** inputs:  (Variables, /* vars */
              MultiDimEquation,
              int) /* indx */
 ** outputs:  Equation list 
 **)
relation lower_multidimeqn: (Variables, MultiDimEquation, int) => Equation list =

  rule	states_and_vars_exp(e1,vars) => expl1 &
	states_and_vars_exp(e2,vars) => expl2 &
	list_append(expl1,expl2) => expl &
	Util.list_reduce(ds,int_mul) => numnodes &
	lower_multidimeqn2(expl,numnodes,aindx) => lst
	-----------------------------------------------------
	lower_multidimeqn(vars,MULTIDIM_EQUATION(ds,e1,e2),aindx) => lst
end


(** relation: lower_multidimeqns2
 ** 
 ** Helper relation to lower_multidimeqns
 ** Creates numnodes Equation nodes so BLT can be run correctly.
 ** inputs:  (Exp.Exp list, int /* numnodes */, int /* indx */)
 ** outputs: Equation list = 
 **)
relation lower_multidimeqn2: (Exp.Exp list, int, int) => Equation list = 

  axiom	lower_multidimeqn2(expl,0,_) => []

  rule	int_sub(numnodes,1) => numnodes' &
	lower_multidimeqn2(expl,numnodes',indx) => res 
	-----------------------------------------------------
	lower_multidimeqn2(expl,numnodes,indx)
	  => ARRAY_EQUATION(indx,expl)::res
end


(** relation: lower_algorithms
 **
 ** This relation lowers algorithm sections by generating a list
 ** of ALGORITHMS nodes for the BLT sorting, which are put in 
 ** the equation list.
 ** An algorithm that calculates n variables will get n  ALGORITHM nodes
 ** such that the BLT sorting can be done correctly.
 ** inputs:  (Variables /* vars */, Algorithm.Algorithm list)
 ** outputs: Equation list 
 **)
relation lower_algorithms: (Variables, Algorithm.Algorithm list) => Equation list =

  rule	lower_algorithms2(vars,algs,0) => (eqns,_)
	---------------------
	lower_algorithms(vars,algs) => eqns
end


(** relation: lower_algorithms2
 **
 ** Helper relation to lower_algorithms. To handle indexes in Equation nodes
 ** for algorithms to indentify the corresponding algorithm.
 ** inputs:  (Variables /* vars */, Algorithm.Algorithm list, int /* algindex*/ ) 
 ** outputs: (Equation list, int /* updated algindex */ ) =
 **)
relation lower_algorithms2: (Variables, Algorithm.Algorithm list, int) 
                         => (Equation list, int) =
	
  axiom	lower_algorithms2(vars,[],aindx) => ([],aindx)
	
  rule	lower_algorithm(vars,a,aindx) => eqns & 
	int_add(aindx, 1) => aindx &
	lower_algorithms2(vars,algs,aindx) => (eqns2,aindx) &
	list_append(eqns,eqns2) => res
	------------------------
	lower_algorithms2 (vars,a::algs,aindx) => (res,aindx)
end


(** relation: lower_algorithm
 **
 ** Lowers a single algorithm. Creates n ALGORITHM nodes for blt sorting.
 ** inputs:  (Variables, /* vars */
              Algorithm.Algorithm, 
              int /* algindx */)
 ** outputs: Equation list
 **)
relation lower_algorithm: (Variables, Algorithm.Algorithm, int) => Equation list =

  rule	lower_algorithm_inputs_outputs(vars,a) 
	  => (inputs,outputs) &
	list_length(outputs) => numnodes &
        lower_algorithm2(inputs,outputs,numnodes,aindx) => lst
	-----------------------------------------------------
	lower_algorithm(vars,a,aindx) => lst
end


(** relation: lower_algorithm2
 **
 ** Helper relation to lower_algorithm
 ** inputs:  (Exp.Exp list /* inputs   */,
              Exp.Exp list /* outputs  */,
              int          /* numnodes */, 
              int          /* aindx    */)
 ** outputs:  (Equation list) 
 **)
relation lower_algorithm2:(Exp.Exp list, Exp.Exp list, int, int)
                       => (Equation list) =

  axiom	lower_algorithm2(_,_,0,_) => []

  rule	int_sub(numnodes,1) => numnodes' &
	lower_algorithm2(inputs,outputs,numnodes',aindx) => res 
	-----------------------------------------------------
	lower_algorithm2(inputs,outputs,numnodes,aindx)
	  => ALGORITHM(aindx,inputs,outputs)::res
end


(** relation: lower_algorithm_inputs_outputs
 **
 ** This relation finds the inputs and the outputs of an algorithm.
 ** An input is all values that are reffered on the right hand side of any 
 ** statement in the algorithm and an output is a variables belonging to the 
 ** variables that are assigned a value in the algorithm.
 **)
relation lower_algorithm_inputs_outputs: (Variables, 
					  Algorithm.Algorithm)
	=> (Exp.Exp list,
	    Exp.Exp list)  =

  axiom	lower_algorithm_inputs_outputs(_,Algorithm.ALGORITHM([])) => ([],[])

  rule	lower_statement_inputs_outputs(vars,s) => (inputs1,outputs1) &
	lower_algorithm_inputs_outputs(vars,Algorithm.ALGORITHM(ss))
	  =>(inputs2,outputs2) &
	Util.list_union_p(inputs1,inputs2,Exp.exp_equal) => inputs &
	Util.list_union_p(outputs1,outputs2,Exp.exp_equal) => outputs 
	---------------------------------------------------------
	lower_algorithm_inputs_outputs(vars,Algorithm.ALGORITHM(s::ss))
	  => (inputs,outputs)
end


(** relation: lower_statement_inputs_outputs
 **
 ** Helper relatoin to lower_algorithm_inputs_outputs
 ** Investigates single statements. Returns Exp.Exp list
 ** instead of Exp.ComponentRef list because derivatives must
 ** be handled as well.
 ** inputs:  (Variables, /* vars */
              Algorithm.Statement)
 ** outputs: (Exp.Exp list, /* inputs, CREF or der(CREF)  */
              Exp.Exp list  /* outputs, CREF or der(CREF) */) 
 **)
relation lower_statement_inputs_outputs: (Variables, Algorithm.Statement) => (Exp.Exp list, Exp.Exp list) =

  rule	states_and_vars_exp(e,vars) => inputs
	--------------------------------------------
	lower_statement_inputs_outputs(vars,Algorithm.ASSIGN(tp,cr,e))
	  =>(inputs ,[Exp.CREF(cr,tp)])

  rule	print "lower_statement_input_outputs finished yet\n" 
	--------------------------
	lower_statement_inputs_outputs(_,_) => fail
end


(** relation: states_and_vars_exp
 **
 ** This relation investigates an expression and returns as subexpressions
 ** that are variable names or derivatives of state names or states
 ** inputs:  (Exp.Exp, Variables /* vars */)
 ** outputs: Exp.Exp list
 **)
 relation states_and_vars_exp: (Exp.Exp, Variables) => Exp.Exp list =
	   
  rule	get_var(cr,vars) => (_,_)
 	 -----------------------------
	states_and_vars_exp(e as Exp.CREF(cr,tp),vars) => [e]

	
  rule	states_and_vars_exp(e1,vars) => s1 &
	states_and_vars_exp(e2,vars) => s2 &
	Util.list_union_p(s1,s2,Exp.exp_equal) => res
	-----------------------------
	states_and_vars_exp(Exp.BINARY(e1,_,e2),vars) => res

  rule	states_and_vars_exp(e,vars) => res
	-----------------------------
	states_and_vars_exp(Exp.UNARY(_,e),vars) => res

  rule	states_and_vars_exp(e1,vars) => s1 &
	states_and_vars_exp(e2,vars) => s2 &
	Util.list_union_p(s1,s2,Exp.exp_equal) => res
	-----------------------------
	states_and_vars_exp(Exp.LBINARY(e1,_,e2),vars) => res
	
  rule	states_and_vars_exp(e,vars) => res
	-----------------------------
	states_and_vars_exp(Exp.LUNARY(_,e),vars) => res

  rule	states_and_vars_exp(e1,vars) => s1 &
	states_and_vars_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-------------------------
	states_and_vars_exp(Exp.RELATION(e1,_,e2),vars) => res
	
  rule	states_and_vars_exp(e1,vars) => s1 &
	states_and_vars_exp(e2,vars) => s2 &
	states_and_vars_exp(e3,vars) => s3 &
	Util.list_list_union_p([s1,s2,s3],Exp.exp_equal) => res
	-------------------------
	states_and_vars_exp(Exp.IFEXP(e1,e2,e3),vars) => res

  rule  get_var(cr,vars) => (VAR(_,STATE,_,_,_, _,_,_,_,_,_,_,_,flow)::_,_)
	--------------------------------
	states_and_vars_exp(e as Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),vars) 
	  => [e]

  rule  get_var(cr,vars) => (_,p)
	--------------------------------
	states_and_vars_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),vars) 
	  => []

  rule	Util.list_map_1(expl,states_and_vars_exp,vars) => lst &
	Util.list_list_union_p(lst,Exp.exp_equal) => res
	-----------------------------------------------
	states_and_vars_exp(Exp.CALL(_,expl,_,_),vars) => res
	
  rule	Util.list_map_1(expl,states_and_vars_exp,vars) => lst &
	Util.list_list_union_p(lst,Exp.exp_equal) => res
	-----------------------
	states_and_vars_exp(Exp.ARRAY(_,_,expl),vars) => res

  rule	states_and_vars_matrix_exp(mexp,vars) => res
	---------------------------------------
	states_and_vars_exp(Exp.MATRIX(_,_,mexp),vars) => res
	
  rule	Util.list_map_1(expl,states_and_vars_exp,vars) => lst &
	Util.list_list_union_p(lst,Exp.exp_equal) => res
	-----------------------
	states_and_vars_exp(Exp.TUPLE(expl),vars) => res

  rule	states_and_vars_exp(e,vars) => res
	-----------------------
	states_and_vars_exp(Exp.CAST(_,e),vars) => res

  rule	states_and_vars_exp(e,vars) => res
	-----------------------
	states_and_vars_exp(Exp.ASUB(e,_),vars) => res

  rule	states_and_vars_exp(e1,vars) => s1 &
	states_and_vars_exp(e2,vars) => s2 &
	Util.list_union_p(s1,s2,Exp.exp_equal) => res
	--------------------
	states_and_vars_exp(Exp.REDUCTION(_,e1,_,e2),vars) => res

  axiom	states_and_vars_exp(_,_) => []
end


(** relation: states_and_vars_matrix_exp
 **
 **)
relation states_and_vars_matrix_exp:((Exp.Exp*bool) list list, Variables) => Exp.Exp list =

  axiom	states_and_vars_matrix_exp([],_) => []

  rule	Util.list_map(expl,Util.tuple2_1) => expl' &
	Util.list_map_1(expl',states_and_vars_exp,vars) => lst &
	states_and_vars_matrix_exp(ms,vars) => ms' &
	Util.list_list_union_p(ms'::lst,Exp.exp_equal) => res
	---------------------
	states_and_vars_matrix_exp(expl::ms,vars) => res
end


(** relation: lower_eqn
 **
 ** Helper relation to lower2.
 ** Transforma a DAE.Element to Equation.
 **)
relation lower_eqn: (DAE.Element) => Equation =

  rule	Exp.simplify(e1) => e1' &
	Exp.simplify(e2) => e2' &
	Exp.stringify_crefs(e1') => e1'' &
	Exp.stringify_crefs(e2') => e2'' 
	-----------------------
	lower_eqn(DAE.EQUATION(e1,e2)) => EQUATION(e1'',e2'')

  rule	Exp.simplify(e1) => e1' &
	Exp.simplify(e2) => e2' &
	Exp.stringify_crefs(e1') => e1'' &
	Exp.stringify_crefs(e2') => e2'' 
	-----------------------
	lower_eqn(DAE.INITIALEQUATION(e1,e2)) => EQUATION(e1'',e2'')

end


(** relation: lower_arr_eqn
 **
 ** Helper relation to lower2.
 ** Transforma a DAE.Element to MultiDimEquation.
 **)
relation lower_arr_eqn: (DAE.Element) => MultiDimEquation =
	
  rule	Exp.simplify(e1) => e1' &
	Exp.simplify(e2) => e2' &
	Exp.stringify_crefs(e1') => e1'' &
	Exp.stringify_crefs(e2') => e2'' 
	-----------------------
	lower_arr_eqn(DAE.ARRAY_EQUATION(ds,e1,e2)) 
	  => MULTIDIM_EQUATION(ds,e1'',e2'')
end


(** relation: lower_var
 **
 ** Transforms a DAE variable to DAELOW variable.
 ** Includes changing the ComponentRef name to a simpler form 
 ** 'a'.'b'.'c' becomes
 ** 'a.b.c' (as CREF_IDENT("a.b.c",[]) )
 ** inputs: (DAE.Element, BinTree /* states */) 
 ** outputs: Var
 **)
relation lower_var: (DAE.Element, BinTree) => Var =

  rule	Exp.print_component_ref_str name => origname &
	let newname = Exp.CREF_IDENT(origname,[]) &
	lower_varkind(kind,tp,newname,dir,flow,states) => kind' & 
	lower_binding(bind) => bind' &
	lower_binding(start) => start'
	----------------------------------------
	lower_var (DAE.VAR(name,kind,dir,tp,bind,dims,start,flow,class,dae_var_attr,comment),states)
	  => VAR(newname,kind',dir,tp,bind',NONE,dims,start',-1,origname,class,dae_var_attr,comment,flow)

(*  rule	print "-lower_var failed\n" 
	------------------------
	lower_var (_,_) => fail*)

end


(** relation: lower_binding
 **
 ** Helper relation to lower_var
 **)
relation lower_binding: Exp.Exp option => Exp.Exp option =
	
  axiom	 lower_binding NONE => NONE 

  rule	Exp.stringify_crefs(e) => e'
	----------------------------
	lower_binding(SOME(e)) =>  SOME(e)
end


(** relation: lower_known_var
 **
 ** Helper relation to lower2
 **)		   
relation lower_known_var: (DAE.Element) => Var =

  rule	Exp.print_component_ref_str name => origname &
	let newname = Exp.CREF_IDENT(origname,[]) &
	lower_known_varkind(kind,name,dir,flow) => kind' &
	lower_binding(bind) => bind' &
	lower_binding(start) => start'
	----------------------------------------
	lower_known_var (DAE.VAR(name,kind,dir,tp,bind,dims,start,flow,class,dae_var_attr,comment))
	  => VAR(newname,kind',dir,tp,bind',NONE,dims,start',-1,origname,class,dae_var_attr,comment,flow)

  rule	print "-lower_known_var failed\n" 
	-------------------
	lower_known_var(_) => fail
end


(** relation: lower_varkind
 **
 ** Helper relation to lower_var.
 ** inputs: (DAE.VarKind, 
             DAE.Type, 
             Exp.ComponentRef, 
             DAE.VarDirection, /* input/output/bidir */
             DAE.Flow,
             BinTree /* states */) 
 ** outputs VarKind 
 ** NOTE: Fails for not states that are not algebraic variables, e.g.
          parameters and constants
 **)
relation lower_varkind: (DAE.VarKind, DAE.Type, Exp.ComponentRef, DAE.VarDirection, DAE.Flow, BinTree) 
                      => VarKind =

  rule	tree_get(states,v) => _
	-----------------------------
	lower_varkind(DAE.VARIABLE,_,v,_,_,states) => STATE

  rule	not top_level_input(cr,dir,flow)
	-----------------
	lower_varkind(DAE.VARIABLE,DAE.BOOL,cr,dir,flow,_) => DISCRETE

  rule	not top_level_input(cr,dir,flow)
	--------------------------
	lower_varkind(DAE.DISCRETE,DAE.BOOL,cr,dir,flow,_) => DISCRETE

  rule	not top_level_input(cr,dir,flow)
	--------------------------
	lower_varkind(DAE.VARIABLE,DAE.INT,cr,dir,flow,_) => DISCRETE

  rule	not top_level_input(cr,dir,flow)
	--------------------------
	lower_varkind(DAE.DISCRETE,DAE.INT,cr,dir,flow,_) => DISCRETE

  rule	not top_level_input(cr,dir,flow)
	--------------------------
	lower_varkind(DAE.VARIABLE,_,cr,dir,flow,_) => VARIABLE

  rule	not top_level_input(cr,dir,flow)
	--------------------------
	lower_varkind(DAE.DISCRETE,_,cr,dir,flow,_) => DISCRETE
end


(** relation: top_level_input 
 ** author: PA
 **
 ** Succeds if variable is input declared at the top level of the model, 
 ** or if it is an input in a connector instance at top level.
 **)
relation top_level_input: (Exp.ComponentRef, 
			   DAE.VarDirection,
			   DAE.Flow) => () =
        

  rule	(* top level ident, no dots *)
	Util.string_split_at_char(name, #".") => [_]
	--------------------
	top_level_input(cr as Exp.CREF_IDENT(name,_), DAE.INPUT,_) => ()

	(* Connector input variables at top level for crefs that are stringified*)
  rule	Util.string_split_at_char(name, #".") => [_,_]
	----------------------
	top_level_input(Exp.CREF_IDENT(name,_), DAE.INPUT, DAE.NON_FLOW) =>()

  rule	Util.string_split_at_char(name, #".") => [_,_]
	----------------------
	top_level_input(Exp.CREF_IDENT(name,_), DAE.INPUT, DAE.FLOW) =>()

	(* For crefs that are not yet stringified, e.g. lower_known_var *)
  axiom	top_level_input(Exp.CREF_QUAL(name,_,Exp.CREF_IDENT(_,_)), DAE.INPUT, DAE.FLOW) =>()

  axiom	top_level_input(cr as Exp.CREF_QUAL(name,_,Exp.CREF_IDENT(_,_)), DAE.INPUT, DAE.NON_FLOW) =>()

end


(** relation: top_level_output 
 ** author: PA
 **
 ** Succeds if variable is output declared at the top level of the model, 
 ** or if it is an output in a connector instance at top level.
 **)
relation top_level_output: (Exp.ComponentRef, 
			   DAE.VarDirection,
			   DAE.Flow) => () =

  rule	(* top level ident, no dots *)
	Util.string_split_at_char(name, #".") => cr_str_lst &
        list_length(cr_str_lst) => 1
	--------------------
	top_level_output(cr as Exp.CREF_IDENT(name,_), DAE.OUTPUT,_) => ()

	(* Connector output variables at top level for crefs that are stringified*)
  rule	Util.string_split_at_char(name, #".") => cr_str_lst &
        list_length(cr_str_lst) => len &
	int_eq(len,2) => true 
	----------------------
	top_level_output(Exp.CREF_IDENT(name,_), DAE.OUTPUT, DAE.NON_FLOW) =>()

  rule	Util.string_split_at_char(name, #".") => cr_str_lst &
        list_length(cr_str_lst) => len &
	int_eq(len,2) => true
	----------------------
	top_level_output(Exp.CREF_IDENT(name,_), DAE.OUTPUT, DAE.FLOW) =>()

	(* For crefs that are not yet stringified, e.g. lower_known_var *)
  axiom	top_level_output(Exp.CREF_QUAL(name,_,Exp.CREF_IDENT(_,_)), DAE.OUTPUT, DAE.FLOW) =>()
  axiom	top_level_output(Exp.CREF_QUAL(name,_,Exp.CREF_IDENT(_,_)), DAE.OUTPUT, DAE.NON_FLOW) =>()

end


(** relation: lower_known_varkind
 **
 ** Helper relation to lower_known_var.
 ** NOTE: Fails for everything but parameters and constants and top level inputs
 **)
relation lower_known_varkind: (DAE.VarKind,
			       Exp.ComponentRef,
			       DAE.VarDirection,
			       DAE.Flow) => VarKind =

  axiom	lower_known_varkind(DAE.PARAM,_,_,_) => PARAM
  axiom	lower_known_varkind(DAE.CONST,_,_,_) => CONST

  rule	top_level_input(cr,dir,flow) 
	------------------------
	lower_known_varkind(DAE.VARIABLE,cr,dir,flow) => VARIABLE

  rule	print "lower_known_varkind failed\n" 
	----------------------
	lower_known_varkind(_,_,_,_) => fail
end


(** relation: incidence_matrix
 ** author: PA
 **
 ** Calculates the incidence matrix, i.e. which variables are present
 ** in each equation.
 **)
relation incidence_matrix: (DAELow)
	  => IncidenceMatrix =

  rule	equation_list(eqns) => eqnsl &
	incidence_matrix2(vars,eqnsl) => lstlst &
	list_array(lstlst) => arr
	-------------------
	incidence_matrix(DAELOW(vars,knvars,eqns,reqns,_,_,_,_)) => arr

  rule	print "incidence_matrix failed\n" 
	----------------------
	incidence_matrix(_) => fail
end


(** relation: incidence_matrix2
 ** author: PA
 **
 ** Helper relation to incidence_matrix
 ** Calculates the incidence matrix as a list of list of integers
 **)
relation incidence_matrix2:(Variables, Equation list) => int list list =
	  
  axiom	incidence_matrix2(_,[]) => [] 

  rule	incidence_matrix2(vars,eqns) => lst &
	incidence_row(vars,e) => row
	----------------------------
	incidence_matrix2(vars,e::eqns) => row::lst

  rule	print "incidence_matrix2 failed\n" 
	----------------------
	incidence_matrix2(_,_) => fail
end


(** relation: incidence_row
 ** author: PA
 **
 ** Helper relation to incidence_matrix. Calculates the indidence row
 ** in the matrix for one equation.
 **)
relation incidence_row: ( Variables, Equation) 
	  => int list =
	

  rule	(* EQUATION *)
	incidence_row_exp(e1,vars) => lst1 &
	incidence_row_exp(e2,vars) => lst2 &
	list_append(lst1,lst2) => res
	------------------------------------
	incidence_row(vars,EQUATION(e1,e2)) => res

	(* ARRAY_EQUATION *)
  rule	Util.list_map_1(expl,incidence_row_exp,vars) => lst3 &
	Util.list_flatten(lst3) => res
	------------------------------------
	incidence_row(vars,ARRAY_EQUATION(_,expl)) => res

	 (* SOLVED_EQUATION *)
  rule	incidence_row_exp(Exp.CREF(cr,Exp.REAL),vars) => lst1 &
	incidence_row_exp(e,vars) => lst2 &
	list_append(lst1,lst2) => res
	------------------------------------
	incidence_row(vars,SOLVED_EQUATION(cr,e)) => res

	 (* SOLVED_EQUATION *)
  rule	incidence_row_exp(Exp.CREF(cr,Exp.REAL),vars) => lst1 &
	incidence_row_exp(e,vars) => lst2 &
	list_append(lst1,lst2) => res
	------------------------------------
	incidence_row(vars,SOLVED_EQUATION(cr,e)) => res

	(* RESIDUAL_EQUATION *)
  rule	incidence_row_exp(e,vars) => res
	------------------------------------
	incidence_row(vars,RESIDUAL_EQUATION(e)) => res


	(* WHEN_EQUATION *)
  rule	get_when_equation_expr(we) => (cr, e2) &
	let e1 = Exp.CREF(cr,Exp.OTHER) &
	incidence_row_exp(e1,vars) => lst1 &
	incidence_row_exp(e2,vars) => lst2 &
	list_append(lst1,lst2) => res
	------------------------------------
	incidence_row(vars,WHEN_EQUATION(we)) => res
	
	(* ALGORITHM *)
	(** For now assume that algorithm will be solvable for correct
	 ** variables. I.e. find all variables in algorithm and add to lst.
	 ** If algorithm later on needs to be inverted, i.e. solved for 
	 ** different variables than calculated, a non linear solver or
	 ** analysis of algorithm itself needs to be implemented. 
	 **)
  rule	Util.list_map_1(inputs,incidence_row_exp,vars) => lst1 &
	Util.list_map_1(outputs,incidence_row_exp,vars) => lst2 &
	list_append(lst1,lst2) => res &
	Util.list_flatten(res) => res'
	------------------------------------
	incidence_row(vars,ALGORITHM(indx,inputs,outputs)) => res'

  rule	print "-incidence_row failed\n"
	------------------
	incidence_row(vars,_) => fail
end 


(** relation: incidence_row_stmts
 ** author: PA
 **
 ** Helper relation to incidence_row, investigates statements for
 ** variables, returning variable indexes.
 **)
relation incidence_row_stmts: (Algorithm.Statement list, Variables) 
	  => int list =

  axiom	incidence_row_stmts ([],_) => []

  rule	incidence_row_stmts(rest,vars) => lst1 &
	incidence_row_exp(e,vars) => lst2 &
	incidence_row_exp(Exp.CREF(cr,Exp.OTHER),vars) => lst3 &
	Util.list_flatten([lst1,lst2,lst3]) => res
	------------------------------------------
	incidence_row_stmts(Algorithm.ASSIGN(tp,cr,e)::rest,vars) => res

  rule	incidence_row_stmts(rest,vars) => lst1 &
	incidence_row_exp(e,vars) => lst2 &
	Util.list_map_1(expl,incidence_row_exp,vars) => lst3 &
	Util.list_flatten(lst3) => lst3' &
	Util.list_flatten([lst1,lst2,lst3']) => res
	-------------------------------------------
	incidence_row_stmts(Algorithm.TUPLE_ASSIGN(tp,expl,e)::rest,vars) 
	  => res

  rule	incidence_row_stmts(rest,vars) => lst1 &
	incidence_row_exp(e,vars) => lst2 &
	incidence_row_exp(Exp.CREF(cr,Exp.OTHER),vars) => lst3 &
	Util.list_flatten([lst1,lst2,lst3]) => res
	-------------------------------------------
	incidence_row_stmts(Algorithm.ASSIGN_ARR(tp,cr,e)::rest,vars) 
	  => res

  rule	print "incidence_row_stmts on IF not implemented\n"
	-------------------------------------------
	incidence_row_stmts(Algorithm.IF(e,stmts,else)::rest,vars) 
	  => []

  rule	print "incidence_row_stmts on FOR not implemented\n"
	-------------------------------------------
	incidence_row_stmts(Algorithm.FOR(_,_,_,_,_)::rest,vars) 
	  => []

  rule	print "incidence_row_stmts on WHILE not implemented\n"
	-------------------------------------------
	incidence_row_stmts(Algorithm.WHILE(_,_)::rest,vars) 
	  => []

  rule	print "incidence_row_stmts on WHEN not implemented\n"
	-------------------------------------------
	incidence_row_stmts(Algorithm.WHEN(e,_)::rest,vars) 
	  => []

  rule	print "incidence_row_stmts on ASSERT not implemented\n"
	-------------------------------------------
	incidence_row_stmts(Algorithm.ASSERT(_,_)::rest,vars) 
	  => []
end


(** relation: incidence_row_exp
 ** author: PA
 **
 ** Helper relation to incidence_row, investigates expressions for
 ** variables, returning variable indexes.
 **)
relation incidence_row_exp: (Exp.Exp, Variables ) 
	  => int list =

  rule	(* If variable x is a state, der(x) is a variable in incidence matrix,
	 x is inserted as negative value, since it is needed by debugging and index
	 reduction using dummy derivatives*)
	get_var(cr,vars) => (VAR(_,STATE,_,_,_ ,_,_,_,_,_,_,_,_,flow)::_,p) &
	Util.list_map_1r(p,int_sub,0) => p'
 	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => p'
	
  rule	get_var(cr,vars) => (VAR(_,VARIABLE,_,_,_, _,_,_,_,_,_,_,_,flow)::_,p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => p

  rule	get_var(cr,vars) => (VAR(_,DISCRETE,_,_,_, _,_,_,_,_,_,_,_,flow)::_,p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => p

  rule	get_var(cr,vars) => (VAR(_,DUMMY_DER,_,_,_ ,_,_,_,_,_,_,_,_,flow)::_,p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => p

  rule	get_var(cr,vars) => (VAR(_,DUMMY_STATE,_,_,_, _,_,_,_,_,_,_,_,flow)::_,p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => p

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-----------------------------
	incidence_row_exp(Exp.BINARY(e1,_,e2),vars) => res

  rule	incidence_row_exp(e,vars) => res
	-----------------------------
	incidence_row_exp(Exp.UNARY(_,e),vars) => res

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-----------------------------
	incidence_row_exp(Exp.LBINARY(e1,_,e2),vars) => res
	
  rule	incidence_row_exp(e,vars) => res
	-----------------------------
	incidence_row_exp(Exp.LUNARY(_,e),vars) => res

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-------------------------
	incidence_row_exp(Exp.RELATION(e1,_,e2),vars) => res
	
	(* if expressions. The conditional is not investigated since
	 * variables are not solved from within conditions*)
  rule	incidence_row_exp(e2,vars) => s2 &
 	incidence_row_exp(e3,vars) => s3 &
	list_append(s2,s3) => res
	-------------------------
	incidence_row_exp(Exp.IFEXP(e1,e2,e3),vars) => res

  rule  get_var(cr,vars) => (VAR(_,STATE,_,_,_, _,_,_,_,_,_,_,_,flow)::_,p)
	--------------------------------
	incidence_row_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),vars) 
	  => p

  rule  get_var(cr,vars) => (_,p)
	--------------------------------
	incidence_row_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),vars) 
	  => []

	  (* pre(v) is considered a known variable*)
  axiom	incidence_row_exp(Exp.CALL(Absyn.IDENT("pre"),[Exp.CREF(cr,_)],_,_),vars)
 	=> []

  rule	Util.list_map_1(expl,incidence_row_exp,vars) => lst &
	Util.list_flatten(lst) => res
	-----------------------------------------------
	incidence_row_exp(Exp.CALL(_,expl,_,_),vars) => res
	
  rule	Util.list_map_1(expl,incidence_row_exp,vars) => lst &
	Util.list_flatten(lst) => lst'
	-----------------------
	incidence_row_exp(Exp.ARRAY(_,_,expl),vars) => lst'

  rule	incidence_row_matrix_exp(expl,vars) => res
	---------------------------------------
	incidence_row_exp(Exp.MATRIX(_,_,expl),vars) => res
	
  rule	print "incidence_row_exp TUPLE not impl. yet." 
	-----------------------
	incidence_row_exp(Exp.TUPLE(expl),vars) => []

  rule	incidence_row_exp(e,vars) => res
	-----------------------
	incidence_row_exp(Exp.CAST(_,e),vars) => res

  rule	incidence_row_exp(e,vars) => res
	-----------------------
	incidence_row_exp(Exp.ASUB(e,_),vars) => res

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	--------------------
	incidence_row_exp(Exp.REDUCTION(_,e1,_,e2),vars) => res

  axiom	incidence_row_exp(_,_) => []
end


(** relation: incidence_row_matrix_exp
 ** author: PA
 **
 ** Traverses matrix expressions for building incidence matrix.
 **)
relation incidence_row_matrix_exp:((Exp.Exp*bool) list list,Variables) => int list =

  axiom	incidence_row_matrix_exp([],_) => []

  rule	Util.list_map(expl,Util.tuple2_1) => expl' &
	Util.list_map_1(expl',incidence_row_exp,vars) => res1 &
	incidence_row_matrix_exp(es,vars) => res2 &
	Util.list_flatten(res1) => res1' &
	list_append(res1',res2) => res
	-------------------------
	incidence_row_matrix_exp(expl::es,vars) => res
end


(** relation: empty_vars
 ** author: PA
 **
 ** Returns a Variable datastructure that is empty.
 ** Using the bucketsize 10000 and array size 1000.
 **)
relation empty_vars: () => Variables =

  rule	array_create(10000,[]) => arr &
	array_create(10000,[]) => arr2 &
	Util.list_fill(NONE,1000) => lst &
	list_array(lst) => emptyarr
	------------------------
	empty_vars() => VARIABLES(arr,arr2,VARIABLE_ARRAY(0,1000,emptyarr), 10000,0)
end


(** relation: merge_vars
 ** author: PA
 **
 ** Takes two sets of Variables and merges them. The variables of the 
 ** first argument takes precedence over the second set, i.e. if a 
 ** variable name exists in both sets, the variable definition from 
 ** the first set is used.
 **)
relation merge_vars: (Variables, Variables) => Variables =

rule	var_list(vars2) => varlst &
	Util.list_fold(varlst,add_var,vars1) => vars1' 
	------------------------------
	merge_vars(vars1,vars2) => vars1'

  rule	print "-merge_vars failed\n" 
	----------------------------
	merge_vars(_,_) => fail
end


(** relation: add_var
 ** author: PA
 **
 ** Add a variable to Variables.
 ** If the variable allready exists, the relation updates the variable.
 **)
relation add_var: (Var, Variables) => Variables =

  rule	(* adding when not existing previously *)
	not get_var(cr,vars) => (_,_) &
	hash_component_ref(cr) => hval &
	int_mod(hval,bsize) => indx & 
	vararray_length(varr) => newpos &
	vararray_add(varr,v) => varr' &
	array_nth(hashvec,indx)=> indexes &
	array_setnth(hashvec,indx,CREFINDEX(cr,newpos)::indexes) => hashvec' &
	vararray_length(varr') => n'
        &
	hash_string(name) => hvalold &
	int_mod(hvalold,bsize) => indxold & 
	array_nth(oldhashvec,indxold)=> indexexold &
	array_setnth(oldhashvec,indxold,STRINGINDEX(name,newpos)::indexexold) => oldhashvec' 

	-----------------------------
	add_var(v as VAR(cr,_,_,_,_,_,_,_,_,name,_,_,_,flow),
                vars as VARIABLES(hashvec,oldhashvec,varr,bsize,n)) 
	  => VARIABLES(hashvec',oldhashvec',varr',bsize,n')

  rule	(* adding when allready present => Updating value *) 
	get_var(cr,vars) => (_,[indx]) &
	int_sub(indx,1) => indx' &
	vararray_setnth(varr,indx',newv) => varr'
	-----------------------------------
	add_var( newv as VAR(cr,_,_,_,_,_,_,_,_,name,_,_,_,flow),
                vars as VARIABLES(hashvec,oldhashvec,varr,bsize,n))
	  => VARIABLES(hashvec,oldhashvec,varr',bsize,n)

  rule	print "-add_var failed\n"
	--------------------------
	add_var(_,_) => fail
end


(** relation: vararray_length
 ** author: PA
 **
 ** Returns the number of variable in the VariableArray
 **)
relation vararray_length: (VariableArray) => int =

  axiom	vararray_length(VARIABLE_ARRAY(n,_,_)) => n

end


(** relation: vararray_add
 ** author: PA
 **
 ** Adds a variable last to the VariableArray, increasing array size
 ** if no space left by factor 1.4
**)
relation vararray_add:(VariableArray,Var) => VariableArray =

  rule	(* Have space to add array elt. *)
	int_lt(n,size) => true &
	n +1 => n' &
	array_setnth(arr,n,SOME(v)) => arr' 
	-------------------------
	vararray_add(VARIABLE_ARRAY(n,size,arr),v) 
	  => VARIABLE_ARRAY(n',size,arr')

  rule	(* Do NOT have splace to add array elt. Expand with factor 1.4 *)
	int_lt(n,size) => false &
	int_real(size) => rsize &
	real_mul(rsize,0.4) => rexpandsize &
	real_int(rexpandsize) => expandsize &
	int_max(expandsize,1) => expandsize' &
	int_add(expandsize',size) => newsize &
	Util.array_expand(expandsize',arr,NONE) => arr' &
	n + 1 => n' &
	array_setnth(arr',n,SOME(v)) => arr''
	---------------------------------
	vararray_add(VARIABLE_ARRAY(n,size,arr),v)
	  => VARIABLE_ARRAY(n',newsize,arr'')

  rule	print "-vararray_add failed\n"
	--------------------
	vararray_add(_,_) => fail
end


(** relation: vararray_setnth
 ** author: PA
 **
 ** Set the n:th variable in the VariableArray to v.
 inputs:  (VariableArray, int /* n */, Var /* v */)
 outputs: VariableArray =
 **)
relation vararray_setnth:(VariableArray, int, Var) => VariableArray =

  rule	int_lt(pos,size) => true &
	array_setnth(arr,pos,SOME(v)) => arr'
	-------------------------
	vararray_setnth(VARIABLE_ARRAY(n,size,arr),pos,v)
	=> VARIABLE_ARRAY(n,size,arr')

  rule	print "-vararray_setnth failed\n"
	-------------------------
	vararray_setnth(_,_,_)
	=> fail
end


(** relation: vararray_nth
 ** author: PA
 **
 ** Retrieve the n:th Var from VariableArray, index from 0..n-1.
 inputs:  (VariableArray, int /* n */) 
 outputs: Var
**)
relation vararray_nth:(VariableArray, int) => Var =

  rule	int_lt(pos,n) => true &
	array_nth(arr,pos) => SOME(v)
	--------------
	vararray_nth(VARIABLE_ARRAY(n,_,arr),pos) => v

  rule	int_lt(pos,n) => true &
	array_nth(arr,pos) => NONE & 
	print "vararray_nth has NONE!!!\n" 
	--------------
	vararray_nth(VARIABLE_ARRAY(n,_,arr),pos) => fail

  rule	print "-vararray_nth , pos : " & int_string(pos) => ps & print ps &
	print "\n  array_length:" & vararray_length(arr) => len & 
	int_string(len) => lens & print lens & print "\n" &
	int_string(n) => ns &
	print "n :" & print ns & print "\n" 
	--------------
	vararray_nth(arr as VARIABLE_ARRAY(n,_,_),pos) => fail
end


(** relation: replace_var
 ** author: PA
 **
 ** Takes a 'Var' list and a 'Var' and replaces the var with the 
 ** same ComponentRef in Var list with Var
**)
relation replace_var: (Var list, Var) => Var list =

  axiom	 replace_var([],_) => []

  rule	Exp.cref_equal(cr1,cr2) => true
	---------------------
	replace_var(VAR(cr1,_,_,_,_,_,_,_,_,_,_,_,_,flow1)::vs,v as VAR(cr2,_,_,_,_,_,_,_,_,_,_,_,_,flow2)) => v::vs 
  rule	replace_var(vs,repl) => vs'
	---------------------
	replace_var(v::vs,repl as VAR(cr2,_,_,_,_,_,_,_,_,_,_,_,_,flow)) => v::vs' 
end


(** relation: hash_component_ref
 ** author: PA
 **
 ** Calculates a hash value for Exp.ComponentRef
 **)
relation hash_component_ref: (Exp.ComponentRef) => int =
	
  rule	Exp.print_component_ref_str(cr) => crstr &
	hash_string(crstr) => res
	--------------------
	hash_component_ref(cr) => res
end


(** relation: hash_string
 ** author: PA
 **
 ** Calculates a hash value of a string
 **)
relation hash_string:(string)  => int =

  rule	System.hash(str)=> res 
	(*string_list(str) => charlst &
	hash_chars(charlst) => res*)
	------------------------
	hash_string(str) => res
end


(** relation: hash_chars
 ** author: PA
 **
 ** Calculates a hash value for a list of chars
 **)
relation hash_chars:(char list) => int =

  axiom	hash_chars([]) => 0

  rule	char_int(c) => c2 &
	hash_chars(cs) => c1 &
	int_add(c1,c2) => res 
	----------------
	hash_chars(c::cs) => res
end


(** relation: get_var_at
 ** author: PA
 **
 ** Return variable at a given position, enumerated from 1..n
 **)
relation get_var_at:(Variables,int) => (Var) =

  rule	n - 1 => pos &
	vararray_nth(vararr,pos) => v
	---------------------
	get_var_at(VARIABLES(_,_,vararr,_,_),n) => v
end


(** relation: get_var
 ** author: PA
 **
 ** Return a variable(s) and its index(es) in the vector.
 ** The indexes is enumerated from 1..n 
 ** Normally a variable has only one index, but in case of an array variable
 ** it may have several indexes and several scalar variables,
 ** therefore a list of variables and a list of  indexes is returned.
 ** inputs:  (Exp.ComponentRef, Variables) 
 ** outputs: (Var list, int list /* indexes */)
 **)
relation get_var: (Exp.ComponentRef, Variables) => (Var list, int list) =

	
  rule	(* if scalar found, return it *)
	get_var2(cr,vars) => (v,indx)
	------------------
	get_var(cr,vars) => ( [v],[indx])

	(* check if array *)
  rule	get_array_var(cr,vars) => (v,indxs)
	-------------------------
	get_var(cr,vars) => (v,indxs)
end


(** relation: get_var2 
 ** author: PA
 **
 ** Helper relation to get_var, checks one scalar variable
**)
relation get_var2:( Exp.ComponentRef, Variables) => (Var, int) =
	
  rule	hash_component_ref(cr) => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(hashvec,hashindx) => indexes &
	get_var3(cr, indexes) => indx &
	vararray_nth(varr,indx) => (v  as VAR(cr2,_,_,_,_,_,_,_,_,_,_,_,_,flow)) &
	Exp.cref_equal(cr,cr2) => true &
	int_add(indx,1) => indx'
	-----------------------------
	get_var2(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) => (v,indx')

  rule	hash_component_ref(cr) => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(hashvec,hashindx) => indexes &
	get_var3(cr, indexes) => indx &
	not vararray_nth(varr,indx) => (_) &
	print "get var failed because vararray_nth failed, cr:" &
	Exp.print_component_ref_str cr => str &
	print str  & print "\n" 
	-----------------
	get_var2(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) => fail
end


(** relation: get_array_var
 ** author: PA
 **
 ** Helper relation to get_var, checks one array variable.
 ** I.e. get_array_var(v,<vars>) will for an array v[3] return
 ** [ v[1],v[2],v[3] ]
**)
relation get_array_var:( Exp.ComponentRef, Variables) => (Var list, int list) =
	
	
  rule	(* one dimensional arrays *)
	Exp.subscript_cref(cr,[Exp.INDEX(Exp.ICONST(1))]) => cr' &
	hash_component_ref(cr') => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(hashvec,hashindx) => indexes &
	get_var3(cr', indexes) => indx &
	vararray_nth(varr,indx) => (v  as VAR(cr2,_,_,_,_,_,instdims,_,_,_,_,_,_,flow)) &
	Exp.cref_equal(cr',cr2) => true &
	get_array_var2(instdims,cr,vars) => (vs,indxs)
	-----------------------------
	get_array_var(cr,vars as VARIABLES(hashvec,oldhashvec,varr,bsize,n)) 
	  => (vs,indxs)

	(* two dimensional arrays *)
  rule	Exp.subscript_cref(cr,[Exp.INDEX(Exp.ICONST(1)),Exp.INDEX(Exp.ICONST(1))]) => cr' &
	hash_component_ref(cr') => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(hashvec,hashindx) => indexes &
	get_var3(cr', indexes) => indx &
	vararray_nth(varr,indx) => (v  as VAR(cr2,_,_,_,_,_,instdims,_,_,_,_,_,_,flow)) &
	Exp.cref_equal(cr',cr2) => true &
	get_array_var2(instdims,cr,vars) => (vs,indxs)
	-----------------------------
	get_array_var(cr,vars as VARIABLES(hashvec,oldhashvec,varr,bsize,n)) 
	  => (vs,indxs)
end


(** relation: get_array_var2
 ** author: PA
 **
 ** Helper relation to get_array_var.
 ** Note: Only implemented for arrays of dimension 1 and 2.
 ** inputs:  (DAE.InstDims, /* array_inst_dims */
              Exp.ComponentRef, /* array_var_name */
              Variables) 
 ** outputs: (Var list /* arrays scalar vars */,
              int list /* arrays scalar indxs */)
 **)
relation get_array_var2: (DAE.InstDims, Exp.ComponentRef, Variables) => (Var list, int list) =

  rule	Util.list_int_range(i1) => indx_lst &
	Util.list_map(indx_lst,Util.list_create) => indx_lstlst &
	Util.list_map(indx_lstlst,Exp.int_subscripts) => subscripts_lstlst &
	Util.list_map_1r(subscripts_lstlst,Exp.subscript_cref,arr_cr) 
	  => scalar_crs &
	Util.list_map_1_2(scalar_crs,get_var,vars) => (vs,indxs)  &
	Util.list_flatten(vs) => vs' &
	Util.list_flatten(indxs) => indxs'
	--------------------------------
	get_array_var2([Exp.INDEX(Exp.ICONST(i1))],arr_cr,vars) 
	  => (vs',indxs')

  rule	Util.list_int_range(i1) => indx_lst1 &
	Util.list_map(indx_lst1,Util.list_create) => indx_lstlst1 &
	Util.list_map(indx_lstlst1,Exp.int_subscripts) => subscripts_lstlst1 &
	Util.list_int_range(i2) => indx_lst2 &
	Util.list_map(indx_lst2,Util.list_create) => indx_lstlst2 &
	Util.list_map(indx_lstlst2,Exp.int_subscripts) => subscripts_lstlst2 &
	
	(* make all possbible combinations to get all 2d indexes *)
	subscript_2d_combinations(subscripts_lstlst1,subscripts_lstlst2) 
	  => subscripts &
	  
	Util.list_map_1r(subscripts,Exp.subscript_cref,arr_cr) => scalar_crs &
	Util.list_map_1_2(scalar_crs,get_var,vars) => (vs,indxs) &
	Util.list_flatten(vs) => vs' &
	Util.list_flatten(indxs) => indxs'
	--------------------------------
	get_array_var2([Exp.INDEX(Exp.ICONST(i1)),
			Exp.INDEX(Exp.ICONST(i2))],arr_cr,vars) 
	  => (vs',indxs')

end


(** relation: susbscript_2d_combinations
 **
 ** This relation takes two lists of list of subscripts and combines them in 
 ** all possible combinations. This is used when finding all indexes of a 2d
 ** array.
 ** For instance, subscript_2d_combinations([[a],[b],[c]],[[x],[y],[z]])
 ** => [[a,x],[a,y],[a,z],[b,x],[b,y],[b,z],[c,x],[c,y],[c,z]]
 ** inputs:  (Exp.Subscript list list /* dim1 subs */,
              Exp.Subscript list list /* dim2 subs */)
 ** outputs: (Exp.Subscript list list) 
 **)
relation subscript_2d_combinations: (Exp.Subscript list list,
                                     Exp.Subscript list list)
	=> (Exp.Subscript list list) =

  axiom	subscript_2d_combinations([],_) => []

  rule	subscript_2d_combinations2(s1,ss2) => lst1 &
	subscript_2d_combinations(ss,ss2) => lst2 &
	list_append(lst1,lst2) => res
	----------------------------------
	subscript_2d_combinations(s1::ss,ss2) => res
end

relation subscript_2d_combinations2:(Exp.Subscript list, 
				     Exp.Subscript list list)
	=> (Exp.Subscript list list) =

  axiom	subscript_2d_combinations2(_,[]) => []
	
  rule	subscript_2d_combinations2(ss,ss2) => lst1 &
	list_append(ss,s2) => elt1
	---------------------------
	subscript_2d_combinations2(ss,s2::ss2) 
	  => elt1::lst1
end


(** relation: exists_var
 ** author: PA
 **
 ** Return true if a variable exists in th vector
 **)
relation exists_var: (Exp.ComponentRef, Variables) => bool =
	
  rule	hash_component_ref(cr) => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(hashvec,hashindx) => indexes &
	get_var3(cr, indexes) => indx &
	vararray_nth(varr,indx) => (v  as VAR(cr2,_,_,_,_,_,_,_,_,_,_,_,_,flow)) &
	Exp.cref_equal(cr,cr2) => true 
	-----------------------------
	exists_var(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) => true

  rule	hash_component_ref(cr) => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(hashvec,hashindx) => indexes &
	get_var3(cr, indexes) => indx &
	not vararray_nth(varr,indx) => (_) &
	print "could not found variable, cr:" &
	Exp.print_component_ref_str cr => str &
	print str  & print "\n" 
	-----------------
	exists_var(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) => false

  axiom	exists_var(_,_) => false
end


(** relation: get_var_using_name
 ** author: lucian
 **
 ** Return a variable and its index in the vector.
 ** The index is enumerated from 1..n 
 **)
relation get_var_using_name: (string, Variables) => (Var,int) =
	
  rule	hash_string(cr) => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(oldhashvec,hashindx) => indexes &
	get_var_using_name2(cr, indexes) => indx &
	vararray_nth(varr,indx) => (v  as VAR(cr2,_,_,_,_,_,_,_,_,name,_,_,_,flow)) &
        name = cr &
	int_add(indx,1) => indx'
	-----------------------------
	get_var_using_name(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) => (v,indx')

  rule	hash_string(cr) => hval &
	int_mod(hval,bsize) => hashindx &
	array_nth(oldhashvec,hashindx) => indexes &
	get_var_using_name2(cr, indexes) => indx &
	not vararray_nth(varr,indx) => (_) &
	print "get var using name failed because vararray_nth failed, name:" &
	print cr  & print "\n" 
	-----------------
	get_var_using_name(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) => fail
end


(** relation set_var_kind
 ** author: PA
 **
 ** Sets the VarKind of a variable
 **)	    
relation set_var_kind: (Var, VarKind) => Var =


  axiom	set_var_kind(VAR(cr,kind,dir,tp,bind,v,dim,st,i,origname,classes,attr,comment,flow),new_kind)
	  => VAR(cr,new_kind,dir,tp,bind,v,dim,st,i,origname,classes,attr,comment,flow)

end


(** relation: var_fixed
 **
 ** Returns the value of the fixed attribute. If not defined in attributes,
 ** inspect varkind to find default values.
 **)
relation var_fixed: (DAE.VariableAttributes option, VarKind) => bool =

  axiom	var_fixed(NONE,PARAM) => true 
  axiom	var_fixed(NONE,CONST) => true 
  axiom	var_fixed(NONE,_) => false

  axiom	var_fixed(SOME(DAE.VAR_ATTR_REAL(_,_,_,_,_,SOME(fixed),_,_)),_)
	  => fixed
  axiom	var_fixed(SOME(DAE.VAR_ATTR_REAL(_,_,_,_,_,NONE,_,_)),_)
	  => false

  axiom	var_fixed(SOME(DAE.VAR_ATTR_INT(_,_,_,SOME(fixed))),_)
	  => fixed

  axiom	var_fixed(SOME(DAE.VAR_ATTR_INT(_,_,_,NONE)),_)
	  => false

  axiom	var_fixed(SOME(DAE.VAR_ATTR_BOOL(_,_,SOME(fixed))),_)
	  => fixed

  axiom	var_fixed(SOME(DAE.VAR_ATTR_BOOL(_,_,NONE)),_)
	  => false

  axiom	var_fixed(SOME(DAE.VAR_ATTR_ENUMERATION(_,_,_,SOME(fixed))),_)
	  => fixed

  axiom	var_fixed(SOME(DAE.VAR_ATTR_ENUMERATION(_,_,_,NONE)),_)
	  => false
end


(** relation: get_var3
 ** author: PA
 **
 ** Helper relation to get_var
 **)
relation get_var3:(Exp.ComponentRef, CrefIndex list) => int =

  rule	Exp.cref_equal(cr,cr2) => true 
	------------------------------
	get_var3(cr,CREFINDEX(cr2,v)::_) => v

  rule	get_var3(cr,vs) => res
	----------------------
	get_var3(cr,v::vs) => res
end


(** relation: get_var_using_name2
 ** author: PA
 **
 ** Helper relation to get_var_using_name
 **)
relation get_var_using_name2:(string, StringIndex list) => int =

  rule	cr = cr2
	------------------------------
	get_var_using_name2(cr,STRINGINDEX(cr2,v)::_) => v

  rule	get_var_using_name2(cr,vs) => res
	----------------------
	get_var_using_name2(cr,v::vs) => res
end


(** relation: delete_var
 ** author: PA
 **
 ** Deletes a variable from 'Variables'. This is an expensive operation 
 ** since we need to create a new binary tree with new indexes as well 
 ** as a new compacted vector of variables.
 **)
relation delete_var: (Exp.ComponentRef,Variables) => Variables =

  rule	vararray_list(varr) => varlst &
	delete_var2(cr,varlst) => varlst' &
	empty_vars() => newvars &
	add_vars(varlst',newvars) => newvars'
	--------------------------------------------------
	delete_var(cr,VARIABLES(hashvec,oldhashvec,varr,bsize,n)) 
	  =>  newvars'
end


(** relation: delete_var2
 ** author: PA
 **
 ** Helper relation to delete_var.
 ** Deletes the var named 'Exp.ComponentRef' from the 'Var' list.
 **)
relation delete_var2: (Exp.ComponentRef,Var list) => Var list =

  axiom	delete_var2(_,[]) => []

  rule	Exp.cref_equal(cr1,cr2) => true
	--------------------------------
	delete_var2(cr1,VAR(cr2,_,_,_,_,_,_,_,_,_,_,_,_,flow)::vs) => vs
  
  rule	delete_var2(cr1,vs) => vs'
	--------------------------------
	delete_var2(cr1,v::vs) =>  v::vs'
end


(** relation: transpose_matrix
 ** author: PA
 **
 ** Calculates the transpose of the incidence matrix, i.e. which equations 
 ** each variable is present in.
 **)
relation transpose_matrix: IncidenceMatrix => IncidenceMatrixT =

  rule	array_list(m) => mlst &
	transpose_matrix2(mlst) => mtlst &
	list_array(mtlst) => mt 
	------------------
	transpose_matrix(m) => mt
end


(** relation: transpose_matrix2
 ** author: PA
 **
 ** Helper relation to transpose_matrix
 **)
relation transpose_matrix2: (int list list) => int list list =

  rule	list_length(m) => neq &
	transpose_matrix3(m,neq,0,[]) => mt
	----------------
	transpose_matrix2(m) => mt

  rule	print "#transpose_matrix2 failed\n" 
	---------------------
	transpose_matrix2(_) => fail
end


(** relation: transpose_matrix3
 ** author: PA
 **
 ** Helper relation to transpose_matrix2
 **)
relation transpose_matrix3: (int list list,int,int,int list list) 
	  => int list list =

  axiom	transpose_matrix3(_,0,_,_) => []

  rule	int_sub(neq,1) => neq' &
	int_add(eqno,1) => eqno' &
	transpose_matrix3(m,neq',eqno',mt) => mt'&
	transpose_row(m,eqno',1) => row
	-------------------------
	transpose_matrix3(m,neq,eqno,mt) => row::mt'
end


(** relation abs_incidence_matrix
 ** author: PA
 ** 
 ** Applies absolute value to all entries in the incidence matrix.
 ** This can be used when e.g. der(x) and x are considered the same variable.
 **)
relation abs_incidence_matrix: IncidenceMatrix => IncidenceMatrix =

  rule	array_list(m) => lst &
	Util.list_list_map(lst,int_abs) => lst' &
	list_array(lst') => res
	----------------------
	abs_incidence_matrix(m) => res
end


(* relation: transpose_row
 ** author: PA
 **
 ** Helper relation to transpose_matrix2.
 ** Input: IncidenceMatrix (eqn => var)
 ** Input: row number (variable)
 ** Input: iterator (start with one)
 **
 ** inputs:  (int list list, int /* row */,int /* iter */)
 ** outputs:  int list
**)
relation transpose_row: (int list list, int, int) => int list =

  axiom	transpose_row([],_,_) => []
	
  rule	list_member(varno,m) => true &
	int_add(eqn,1) => eqn' &
	transpose_row(ms,varno,eqn') => res
	---------------------------
	transpose_row(m::ms,varno,eqn) => eqn::res

  rule	(* Negative index present, state variable. *)
	(*list_member(varno,m) => false &*)
	int_sub(0,varno) => varno' &
	list_member(varno',m) => true &
	int_sub(0,eqn) => eqnneg &
	int_add(eqn,1) => eqn' &
	transpose_row(ms,varno,eqn') => res
	---------------------------
	transpose_row(m::ms,varno,eqn) => eqnneg::res

  rule	(* not present at all *)
	int_add(eqn,1) => eqn' &
	transpose_row(ms,varno,eqn') => res
	---------------------------
	transpose_row(m::ms,varno,eqn) => res

  rule	print "-transpose_row failed\n" 
	-------------------------------
	transpose_row(_,_,_) => fail
end


(** relation: dump_incidence_matrix
 ** author: PA
 **
 ** Prints the incidence matrix on stdout.
 **)
relation dump_incidence_matrix: IncidenceMatrix list => () =


  rule	Util.list_map_0(lst,dump_incidence_matrix1) => ()
	------------------------------
	dump_incidence_matrix(lst)
end

(** relation: dump_incidence_matrix1
 ** author: PA
 **
 ** Helper relation to dump_incidence_matrix 
 **)

relation dump_incidence_matrix1: IncidenceMatrix => () =

  rule	print "Incidence Matrix (row == equation)\n" &
	print "====================================\n" &
	array_length(m) => mlen &
	int_string(mlen) => mlen_str &
	print "number of rows: " & print mlen_str & print "\n" &
	array_list(m) => m' &
	dump_incidence_matrix2(m') 
	-------------------------
	dump_incidence_matrix1(m) => ()
end 


(** relation: dump_incidence_matrix_t
 ** author: PA
 **
 ** Prints the transposed incidence matrix on stdout.
 **)
relation dump_incidence_matrix_t: IncidenceMatrix list => () =

  rule	Util.list_map_0(lst,dump_incidence_matrix_t1) => ()
	----------------------------
	dump_incidence_matrix_t(lst)
end

(** relation: dump_incidence_matrix_t1
 ** author: PA
 **
 ** Helper relation to dump_incidence_matrix_t
 **)

relation dump_incidence_matrix_t1: IncidenceMatrix => () =

  rule	print "Transpose Incidence Matrix (row == var)\n" &
	print "=====================================\n" &
	array_length(m) => mlen &
	int_string(mlen) => mlen_str &
	print "number of rows: " & print mlen_str & print "\n" &
	array_list(m) => m' &
	dump_incidence_matrix2(m') 
	-------------------------
	dump_incidence_matrix_t1(m) => ()
end 

	
(** relation: dump_incidence_matrix2
 ** author: PA
 **
 ** Helper relation to dump_incidence_matrix (+_t).
 **)
relation dump_incidence_matrix2: int list list => () =

  axiom	dump_incidence_matrix2([]) => ()

  rule	dump_incidence_row(row) &
	dump_incidence_matrix2(rows)
	---------------------------
	dump_incidence_matrix2(row::rows)
end


(** relation: dump_incidence_row
 ** author: PA
 **
 ** Helper relation to dump_incidence_matrix2.
 **)
relation dump_incidence_row: int list => () =

  rule	print "\n"
	----------
	dump_incidence_row [] 

  rule	int_string(x) => s &
	print s & print " " &
	dump_incidence_row(xs) 
	----------------------
	dump_incidence_row (x::xs)
end


(** relation: dump_matching
 ** author: PA
 **
 ** prints the matching information on stdout.
 **)

relation dump_matching: (int vector list) => () =

  rule	Util.list_map_0(lst,dump_matching1) => ()
	-----------------
	dump_matching (lst) => ()
end

(** relation: dump_matching1
 ** author: PA
 **
 ** Helper relation to dump_matching.
 **)
	
relation dump_matching1: (int vector) => () =
  rule	print "Matching\n" &
	print "========\n" &
	vector_length(v) => len &
	int_string(len) => len_str &
	print len_str & print " variables and equations\n" &
	dump_matching2(v,0) 
	-------------------
	dump_matching1(v) 
end

(** relation: dump_matching2
 ** author: PA
 **
 ** Helper relation to dump_matching.
 **)
relation dump_matching2: (int vector, int) => () =

  rule	vector_length(v) => len &
	int_add(i,1) => i' &
	int_eq(len,i') => true &
	int_string i' => s & 
	vector_nth(v,i) => eqn &
	int_string eqn => s2 & 
	print "var " & print s & 
	print " is solved in eqn " &
	print s2 & print "\n" 
	---------------------
	dump_matching2(v,i) 

  rule	vector_length(v) => len &
	int_add(i,1) => i' &
	int_eq(len,i') => false &
	int_string i' => s & 
	vector_nth(v,i) => eqn &
	int_string eqn => s2 & 
	print "var " & print s & 
	print " is solved in eqn " &
	print s2  & print "\n" &
	dump_matching2(v,i') 
	---------------------
	dump_matching2(v,i) 
end


(** relation: matching_algorithm
 ** author: PA
 **
 ** This relation performs the matching algorithm, which is the first
 ** part of sorting the equations into BLT (Block Lower Triangular) form.
 ** The matching algorithm finds a variable that is solved in each equation.
 ** But to also find out which equations forms a block of equations, the 
 ** the second algorithm of the BLT sorting: strong components 
 ** algorithm is run. 
 ** This relation returns the updated DAE in case of index reduction has 
 ** added equations and variables, and the incidence matrix. The variable
 ** assignments is returned as a list of  vectors of variable indices, as 
 ** well as its  inverse, i.e. which equation a variable is solved in as 
 ** a vector of  equation indices. Normally the list has only one element, the 
 ** incidence matrix for the system. If structural if equations are present, 
 ** several incidence matrices can be returned. The number of matrices returned
 ** is as many as the number of assignments returned.
 **
 ** The assignments are returned in a list, which normally
 ** only has one element. But if if-expressions give different matching 
 ** depending on boolean variables, serveral matchings are returned, hence a 
 ** list. These boolean variables are returned as a list of ComponentRefs.
 ** MatchingOptions contain options given to the algorithm.
 **   - if index reduction should be used or not.
 **   - if the equation system is allowed to be under constrained or not 
 **     which is used when generating code for initial equations.
 **
 ** inputs:  (DAELow,IncidenceMatrix, IncidenceMatrixT, MatchingOptions) 
 ** outputs: (int vector list /* list of vector of equation indices */ , 
              int vector list /* list of vector of variable indices */,
	      Exp.ComponentRef list, /* list of if equation boolean vars*/
              DAELow,IncidenceMatrix list, IncidenceMatrixT list) 
 **)		 
relation matching_algorithm: (DAELow,IncidenceMatrix, IncidenceMatrixT,
			      MatchingOptions) 
	  => (int vector list,
	      int vector list,
	      Exp.ComponentRef list, 
	      DAELow,
	      IncidenceMatrix list, IncidenceMatrixT list) =

  rule	(* no structural if equations *)
	structural_if_equations(dae) => struct_if_eqns &
	structural_if_variables(struct_if_eqns) => (crefs as []) &
	check_matching(dae,match_opts) &  	
	array_length(m) => nvars &
	array_length(mt) => neqns &
	int_string(nvars) => ns &
	int_string(neqns) => ne &
	int_gt(nvars,0) => true &
	int_gt(neqns,0) => true &
	int_add(nvars,nvars) => memsize &
	assignments_create(nvars,memsize,0) => assign1 &
	assignments_create(nvars,memsize,0) => assign2 &
	matching_algorithm2(dae,m,mt,nvars,neqns,1,assign1,assign2,match_opts) 
	  => (ass1, ass2,dae,m,mt) &

	assignments_vector(ass1) => vec1 &
	assignments_vector(ass2) => vec2 
	--------------------------
	matching_algorithm(dae,m,mt,match_opts) 
	  => ([vec1],[vec2],crefs,dae,[m], [mt])

  rule	(* with structural if equations *)
	structural_if_equations(dae) => struct_if_eqns &
	structural_if_variables(struct_if_eqns) => crefs &
	structural_if_eqn_indices(struct_if_eqns) => if_eqns &
	matching_algorithm_structural_if(dae,crefs,if_eqns,m,mt,match_opts) => (vec1_lst,vec2_lst,dae,m_lst,mt_lst)

	--------------------------
	matching_algorithm(dae,m,mt,match_opts) 
	  => (vec1_lst,vec2_lst,crefs,dae,m_lst,mt_lst)

  rule	Debug.fprint("failtrace","-matching_algorithm failed\n")
	------------------------
	matching_algorithm(dae,m,mt,indx_red) => fail
	
end

(** relation: matching_algorithm_structural_if
 ** author: PA
 **
 ** This relation calls the matching algoritm with the dae simplified for 
 ** each boolean value given in the variable list. This means that structural
 ** if expressions are evaluated for all branches and the matching is performed
 ** for each branch.
 **)

relation matching_algorithm_structural_if:(DAELow, 
					   Exp.ComponentRef list,
					   int list list,
					   IncidenceMatrix, 
					  IncidenceMatrixT,
					  MatchingOptions)
	  => (int vector list,
	      int vector list,
	      DAELow,
	      IncidenceMatrix list, 
	      IncidenceMatrixT list) =

  axiom	matching_algorithm_structural_if(dae,[],_,m,mt,match_opts) 
	  => ([],[],dae,[],[])

  rule	evaluate_if_branch(dae,cref,e_indx) => (dae_true, dae_false) &
	
(*	print "evaluated if branch ,true_dae :" &
	dump dae_true &
	print "false dae:" &
	dump dae_false &*)


	(* we must clone incidence matrices since we use them in two places*)
	incidence_matrix_clone(m) => m2 &
	incidence_matrix_clone(mt) => mt2 &
	update_incidence_matrix(dae_true,m,mt,e_indx) => (true_m,true_mt) &
	update_incidence_matrix(dae_false,m2,mt2,e_indx) => (false_m,false_mt)&
	matching_algorithm_structural_if2(dae_true,true_m,true_mt,match_opts) 
	  => (vec11,vec21,dae_true',true_m,true_mt) &
	matching_algorithm_structural_if2(dae_false,false_m,false_mt,match_opts)
	  => (vec12,vec22,dae_false,false_m,false_mt) &
	matching_algorithm_structural_if(dae,crefs,e_indx_lst,m,mt,match_opts)
	  => (vec1_lst,vec2_lst,dae,m_lst,mt_lst)
	----------------------
	matching_algorithm_structural_if(dae,cref::crefs,e_indx::e_indx_lst,m,mt,match_opts) 
	  => (vec11   :: vec12    :: vec1_lst,
	      vec21   :: vec22    :: vec2_lst,
	      dae,
	      true_m  :: false_m  :: m_lst,
	      true_mt :: false_mt :: mt_lst)


  rule	Debug.fprint("failtrace","-matching_algorithm_structural_if failed\n")
	----------------------------
	matching_algorithm_structural_if(dae,crefs,e_indx_lst,m,mt,match_opts)
	  => fail
end

(** relation: matching_algorithm_structural_if2
 **
 ** Helper relation to matching_algorithm_structural_if
 **)

relation matching_algorithm_structural_if2: (DAELow, 
					     IncidenceMatrix, 
					     IncidenceMatrixT,
					     MatchingOptions)
	  => (int vector,
	      int vector,
	      DAELow,
	      IncidenceMatrix, 
	      IncidenceMatrixT) =


  rule	check_matching(dae,match_opts) &  	
	array_length(m) => nvars &
	array_length(mt) => neqns &
	int_string(nvars) => ns &
	int_string(neqns) => ne &
	int_gt(nvars,0) => true &
	int_gt(neqns,0) => true &
	int_add(nvars,nvars) => memsize &
	assignments_create(nvars,memsize,0) => assign1 &
	assignments_create(nvars,memsize,0) => assign2 &
	matching_algorithm2(dae,m,mt,nvars,neqns,1,assign1,assign2,match_opts) 
	  => (ass1, ass2,dae,m,mt) &

	assignments_vector(ass1) => vec1 &
	assignments_vector(ass2) => vec2 
	----------------------------------
	matching_algorithm_structural_if2(dae,m,mt,match_opts)
	  => (vec1,vec2,dae,m,mt)
end


(** relation: evaluate_if_branch:
 ** author: PA
 **
 ** This relation evaluates the boolean variable given as argument
 ** and returns two DAELows with evaluated equations. one for boolean = true
 ** and one for boolean = false.
 ** A list of affected equations are given so that the whole dae is not 
 ** required to traverse.
 **)

relation evaluate_if_branch: (DAELow, Exp.ComponentRef, int list) => (DAELow,DAELow) =

	(* a single equation index*)
  rule	int_sub(e,1) => e' &
	equation_nth(eqns,e') => eqn &
	equation_replace_exp(eqn,Exp.CREF(cr,Exp.OTHER),Exp.BCONST(true))  
	  => true_eqn &
	equation_replace_exp(eqn,Exp.CREF(cr,Exp.OTHER),Exp.BCONST(false))
	  => false_eqn &
	  equations_clone(eqns) => eqns1 &  
	equations_clone(eqns) => eqns2 &  
	equation_setnth(eqns1,e',true_eqn) => true_eqns &
	equation_setnth(eqns2,e',false_eqn) => false_eqns 
	--------------------------------
	evaluate_if_branch(DAELOW(v,kv,eqns,se,ie,ae,al,ei),cr,[e]) 
	  => (DAELOW(v,kv,true_eqns,se,ie,ae,al,ei), 
	      DAELOW(v,kv,false_eqns,se,ie,ae,al,ei))
	
	(* several equation indices *)
  rule	int_sub(e,1) => e' &
	equation_nth(eqns,e') => eqn &
	equation_replace_exp(eqn,Exp.CREF(cr,Exp.OTHER),Exp.BCONST(true))  
	  => true_eqn &

	equation_replace_exp(eqn,Exp.CREF(cr,Exp.OTHER),Exp.BCONST(false))
	  => false_eqn &
	evaluate_if_branch(DAELOW(v,kv,eqns,se,ie,ae,al,ei),cr,es) 
	  => (DAELOW(v1,kv1,true_eqns,se1,ie1,ae1,al1,ei1), 
	      DAELOW(v2,kv2,false_eqns,se2,ie2,ae2,al2,ei2)) &
	equation_setnth(true_eqns,e',true_eqn) => true_eqns' &
	equation_setnth(false_eqns,e',false_eqn) => false_eqns' 
	--------------------------------
	evaluate_if_branch(DAELOW(v,kv,eqns,se,ie,ae,al,ei),cr,e::es) 
	  => (DAELOW(v1,kv1,true_eqns',se1,ie1,ae1,al1,ei1), 
	      DAELOW(v2,kv2,false_eqns',se2,ie2,ae2,al2,ei2))

  rule	Debug.fprint("failtrace","-evaluate_if_branch failed\n")
	---------------------
	evaluate_if_branch(_,_,_) => fail
end

(** relation: incidence_matrix_clone
 **
 ** Clones an incidence matrix. This is required since IncidenceMatrix is an
 ** array and those can have destructive updates. So if you want to set
 ** an array element and at the same time keep the old array you will first
 ** have to clone the array.
 **)

relation incidence_matrix_clone: (IncidenceMatrix) => IncidenceMatrix =

  rule	array_list(m) => m_lst &
	list_array(m_lst) => m'
	------------------------
	incidence_matrix_clone(m)=> m'
end

(** relation: equations_clone
 **
 ** Clones an EquationArray  This is required since EquationAray is an
 ** array and those can have destructive updates. So if you want to set
 ** an array element and at the same time keep the old array you will first
 ** have to clone the array.
 **)

relation equations_clone:( EquationArray) => EquationArray =

  rule	equation_list(eqns) => eqn_lst &
	list_equation(eqn_lst) => res
	--------------------------
	equations_clone(eqns) => res
end


(** relation equation_replace_exp
 **
 ** Replaces expression in an Equation.
**)

relation equation_replace_exp:(Equation, Exp.Exp, Exp.Exp) => Equation =

  rule	Exp.replace_exp(e1,src,dst) => (e1',_) &
	Exp.replace_exp(e2,src,dst) => (e2',_) &
	Exp.simplify(e1') => e1'' &
	Exp.simplify(e2') => e2'' 
	---------------------------
	equation_replace_exp(EQUATION(e1,e2),src,dst) => EQUATION(e1'',e2'')

  rule	Exp.replace_exp(e1,src,dst) => (e1',_) &
	Exp.simplify(e1') => e1''
	---------------------------
	equation_replace_exp(RESIDUAL_EQUATION(e1),src,dst) 
	  => RESIDUAL_EQUATION(e1'')

  rule	Exp.replace_exp(e,src,dst) => (e',_) &
	Exp.simplify(e') => e'' &
	Exp.replace_exp(Exp.CREF(cr,Exp.OTHER),src,dst) => (Exp.CREF(cr',_),_) 
	---------------------------
	equation_replace_exp(SOLVED_EQUATION(cr,e),src,dst) 
	  => SOLVED_EQUATION(cr',e'')
end

(** relation: check_matching
 ** author: PA
 **
 ** Checks that the matching is correct, i.e. that the number of variables
 ** is the same as the number of equations. If not, the relation fails and
 ** prints an error message.
 ** If matching options indicate that underconstrained systems are ok, no 
 ** check is performed.
 **)
relation check_matching : (DAELow,MatchingOptions) => () =
  axiom	check_matching(_,(_,ALLOW_UNDERCONSTRAINED)) => ()
	
  rule	equation_size(eqns) => esize &
	int_eq(esize,vars_size) => true 
	------------------
	check_matching(DAELOW(VARIABLES(_,_,_,_,vars_size),_,eqns,_,_,_,_,_),_) 
	  => ()

  rule	equation_size(eqns) => esize &
	int_lt(esize,vars_size) => true &
	int_string(esize) => esize_str &
	int_string(vars_size) => vsize_str &
	Error.add_message(Error.UNDERDET_EQN_SYSTEM,[vsize_str,esize_str])
 	------------------
	check_matching(DAELOW(VARIABLES(_,_,_,_,vars_size),_,eqns,_,_,_,_,_),_) 
	  => fail

  rule	equation_size(eqns) => esize &
	int_gt(esize,vars_size) => true &
	int_string(esize) => esize_str &
	int_string(vars_size) => vsize_str &
	Error.add_message(Error.OVERDET_EQN_SYSTEM,[vsize_str,esize_str])
	------------------
	check_matching(DAELOW(VARIABLES(_,_,_,_,vars_size),_,eqns,_,_,_,_,_),_) => fail

  rule	Debug.fprint("failtrace", "-check_matching failed\n")
	--------------------
	check_matching(_,_) => fail
end


(** relation: assignments_vector
 ** author: PA
 **
 ** Converts Assignments to vector of int elements
 **)
relation assignments_vector: (Assignments) => int vector =

  rule	array_create(size,0) => newarr &
	Util.array_n_copy(arr,newarr,size) => newarr' &
	array_vector(newarr') => vec
	----------------------------
	assignments_vector(ASSIGNMENTS(size,_,arr)) => vec

  rule	print "-assignments_vector failed\n" 
	----------------------------
	assignments_vector(_) => fail
end


(** relation: assignments_create
 ** author: PA
 **
 ** Creates an assignment array of n elements, filled with value v
 **
 ** inputs:  (int /* size */, int /* memsize */, int) 	  
 ** outputs: => Assignments
 **)
relation assignments_create: (int, int, int) => Assignments =

  rule	Util.list_fill(0,memsize) => lst &
	list_array(lst) => arr 
(*	array_create(memsize,v) => arr &
	*)
	
	------------------------------
	assignments_create(n,memsize,v) => ASSIGNMENTS(n,memsize,arr)
end


(** relation: assignments_setnth
 ** author: PA
 **
 ** Sets the n:nt assignment value to 'value'.
 ** 
 ** inputs:  (Assignments, int /* n */, int /* value */) 
 ** outputs:  Assignments
 **)
relation assignments_setnth:(Assignments, int , int) => Assignments =
	  
  rule	array_setnth(arr,n,v) => arr
	-----------------------
	assignments_setnth(ASSIGNMENTS(s,ms,arr),n,v)
	  => ASSIGNMENTS(s,ms,arr)

  rule	print "-assignments_setnth failed\n" 
	-----------------------
	assignments_setnth(_,_,_) => fail	
end


(** relation: assignments_expand
 ** author: PA
 **
 ** Expands the assignments array with n values, initialized with zero.
 **
 ** inputs:  (Assignments, int /* n */) 
 ** outputs:  Assignments
 **)
relation assignments_expand: (Assignments, int) => Assignments =

  axiom	assignments_expand(ass,0) => ass

  rule	assignments_add(ass,0) => ass' &
	int_sub(n,1) => n' &
	assignments_expand(ass',n') => ass''
	------------------------------------
	assignments_expand(ass,n) => ass''
end


(** relation: assignments_add
 ** author: PA
 **
 ** Adds a value to the end of the assignments array. If memsize = actual size
 ** this means copying the whole array, expanding it size to fit the value 
 ** Expansion is made by a factor 1.4. Otherwise, the element is inserted taking O(1) in 
 ** insertion cost.
 **
 ** inputs:  (Assignments, int /* value */) 
 ** outputs:  Assignments
 **)
relation assignments_add:(Assignments, int) => Assignments =

  rule	(* Out of bounds, increase and copy. *)
	int_eq(s,ms) => true &
	int_real(ms) => msr &
	real_mul(msr,0.4) => msr' &
	real_int(msr') => ms' &
	int_add(s,1) => s' &
	int_add(ms',ms) => ms'' &
	Util.array_expand(ms',arr,0) => arr' &
	array_setnth(arr',s,v) => arr''
	-------------------------------
	assignments_add(ASSIGNMENTS(s,ms,arr),v)
	=> ASSIGNMENTS(s',ms'',arr'')

  rule	(* space available, increase size and insert element.*)
	array_setnth(arr,s,v) => arr' &
	int_add(s,1) => s' 	
	--------------------------
	assignments_add(ASSIGNMENTS(s,ms,arr),v)
	  => ASSIGNMENTS(s',ms,arr')

  rule  print "-assignments_add failed\n" 	
	--------------------------------------
	assignments_add(ASSIGNMENTS(s,ms,arr),v)
	=> fail
end


(** relation: matching_algorithm2
 ** author: PA
 **
 ** This is the outer loop of the matching algorithm
 ** The find_path algorithm is called for each equation/variable.
 **
 ** inputs:  (DAELow,IncidenceMatrix, IncidenceMatrixT
             ,int /* number of vars */
             ,int /* number of eqns */
             ,int /* current var */
             ,Assignments  /* assignments, array of eqn indices */
             ,Assignments /* assignments, array of var indices */
             ,MatchingOptions) /* options for matching alg. */
 ** outputs: (Assignments, /* assignments, array of equation indices */ 
              Assignments, /* assignments, list of variable indices */
              DAELow, IncidenceMatrix, IncidenceMatrixT)
 **)
relation matching_algorithm2: (DAELow,IncidenceMatrix, IncidenceMatrixT
			       ,int 
			       ,int 
			       ,int 
			       ,Assignments
			       ,Assignments
			       ,MatchingOptions)
	  =>  (Assignments, 
	       Assignments, 
	       DAELow,
	       IncidenceMatrix, 
	       IncidenceMatrixT) =
	  
  rule	int_eq(nv,i) => true &
	DAEEXT.init_marks(nv,nf) &(* eMark(i)=vMark(i)=false *)
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2')  (* exit loop *)
	---------------------------------------------
	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2,_) 
	  => (ass1',ass2',dae,m,mt)

  rule	int_add(i,1) => i' &
	DAEEXT.init_marks(nv,nf) &(* eMark(i)=vMark(i)=false *)
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2') & 
	matching_algorithm2(dae,m,mt,nv,nf,i',ass1',ass2',match_opts) 
	  => (ass1'',ass2'',dae,m,mt)
	----------------------------------------------------------------
	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2,match_opts) 
	  => (ass1'',ass2'',dae,m,mt) 

  rule	(* path_found failed, Try index reduction using dummy derivatives.
	 When a constraint exist between states and index reduction is needed
	 the dummy derivative will select one of the states as a dummy state
	 (and the derivative of that state as a dummy derivative).
	 For instance, u1=u2 is a constraint between states. Choose u1 as dummy state
	 and der(u1) as dummy derivative, named der_u1. The differentiated function 
	 then becomes: der_u1 = der(u2).
	 In the dummy derivative method this equation is added and the original equation
	 u1=u2 is kept. This is not the case for the original pantilides algorithm, where
	 the original equation is removed from the system.
	 *)
	reduce_index_dummy_der(dae,m,mt,nv,nf,i) 
	  => (dae as DAELOW(VARIABLES(_,_,_,_,nv'),
                            VARIABLES(_,_,_,_,nkv),eqns,_,_,_,_,_),m,mt) &

	  (* and try again, restarting. This could be optimized later. It should not
	   be necessary to restart the matching, according to Bernard Bachmann. Instead one 
	   could continue the matching as usual. This was tested (2004-11-22) and it does not 
	   work to continue without restarting.
	   For instance the Influenca model "../testsuite/mofiles/Influenca.mo" does not work if
	   not restarting.
	   2004-12-29 PA. This was a bug, assignment lists needed to be expanded with the size
	   of the system in order to work. SO: Matching is not needed to be restarted from 
	   scratch.
	   *)
 	equation_size(eqns) => nf' &
	int_sub(nv',nv) => nvd &
	assignments_expand(ass1,nvd) => ass1' &
	assignments_expand(ass2,nvd) => ass2' &
	matching_algorithm2(dae,m,mt,nv',nf',i,ass1',ass2',
			    (INDEX_REDUCTION,eq_cons))
	  => (ass1'',ass2'',dae,m,mt)
	------------------------
	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2,(INDEX_REDUCTION,eq_cons)) 
	  => (ass1'',ass2'',dae,m,mt)

  rule	(* When index reduction also fails, the model is structurally 
	 singular. **)
	DAEEXT.get_marked_eqns() => eqn_lst &
	DAEEXT.get_marked_variables() => var_lst &
	dump_marked_eqns(dae,eqn_lst) => eqn_str &
	dump_marked_vars(dae,var_lst) => var_str &
	Error.add_message(Error.STRUCT_SINGULAR_SYSTEM,[eqn_str,var_str])
	---------------------------------------------------------------
 	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2,_) => fail
end


(** relation: dump_marked_eqns
 ** author: PA
 ** 
 ** Dumps only the equations given as list of indexes to a string.
 **)
relation dump_marked_eqns: (DAELow, int list) => string =
	
	
  axiom	dump_marked_eqns(_,[]) => ""

  rule	dump_marked_eqns(dae,es) => s1 &
	int_sub(e,1) => e' &
	equation_nth(eqns,e') => eqn &
	equation_str(eqn) => s2 &
	Util.string_append_list([s2,";\n",s1]) => res
	--------------------
	dump_marked_eqns(dae as DAELOW(_,_,eqns,_,_,_,_,_),e::es) => res
end


(** relation: dump_marked_vars
 ** author: PA
 ** 
 ** Dumps only the variable names given as list of indexes to a string.
 **)
relation dump_marked_vars: (DAELow, int list) => string =
	
	
  axiom	dump_marked_vars(_,[]) => ""

  rule	dump_marked_vars(dae,vs) => s1 &
	int_sub(v,1) => v' &
	get_var_at(vars,v') => VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,_)  &
	Exp.print_component_ref_str(cr) => s2 &
	Util.string_append_list([s2,", ",s1]) => res
	--------------------
	dump_marked_vars(dae as DAELOW(vars,_,_,_,_,_,_,_),v::vs) => res
end


(** relation: reduce_index_dummy_der
 ** author: PA
 **
 ** When matching fails, this relation is called to try to 
 ** reduce the index by differentiating the marked equations and
 ** replacing one of the variable with a dummy derivative, i.e. making 
 ** it algebraic.
 ** The new DAELow is returned along with an updated incidence matrix.
 ** 
 ** inputs: (DAELow, IncidenceMatrix, IncidenceMatrixT,
             int /* number of vars */, int /* number of eqns */, int /* i */)
 ** outputs: (DAELow, IncidenceMatrix, IncidenceMatrixT)
 **)
relation reduce_index_dummy_der: (DAELow, 
				  IncidenceMatrix, 
				  IncidenceMatrixT,
				  int,
				  int,
				  int)
			    => (DAELow,
				IncidenceMatrix, 
				IncidenceMatrixT) =
	
  rule	DAEEXT.get_marked_eqns() => eqns &
	DAEEXT.get_differentiated_eqns => diff_eqns &
	Util.list_setdifference_p(eqns,diff_eqns,int_eq) => eqns' &

	(* Collect the states in the equations that are singular, i.e. composing
	 a constraint between states.*)
	states_in_eqns(eqns',dae,m,mt) => (states,stateindx) &
	differentiate_eqns(dae,m,mt,nv,nf,eqns') 
	  => (dae,m,mt,nv,nf,deqns) &	

	select_dummy_state(states,stateindx,dae,m,mt) => (state,stateno) & 
(*		Exp.print_component_ref_str state => statestr &
	 print "Choosen dummy state: " & print statestr & print "\n" &*)
	new_dummy_var(state,dae) => (dummy_der,dae) &
	eqns_for_var_with_states(mt,stateno) => reqns &
	Util.list_union_p(deqns,reqns,int_eq) => changedeqns &
	(* We need to change variables in the differentiated equations and in the 
	  equations having the dummy derivative *)
	replace_dummy_der(state,dummy_der,dae,m,mt,changedeqns) => (dae,m,mt) &
	make_algebraic(dae,state) => dae &
	update_incidence_matrix(dae,m,mt,changedeqns) => (m,mt)  
	---------------------------------------------
	reduce_index_dummy_der(dae,m,mt,nv,nf,i) 
	  => (dae,m,mt)

  rule	DAEEXT.get_marked_eqns() => eqns &
	Util.list_map(eqns,int_string) => es &
	Util.string_delimit_list(es,", ") => es' &
	states_in_eqns(eqns,dae,m,mt) => ([],_) &
	print_equations(eqns,dae) 
	---------------------------------------------
	reduce_index_dummy_der(dae,m,mt,nv,nf,i) 
	  => fail

  rule	print "-reduce_index_dummy_der failed\n"
	--------------------
	reduce_index_dummy_der(_,_,_,_,_,_) => fail
end


(** relation: update_incidence_matrix
 ** author: PA
 **
 ** Takes a daelow and the incidence matrix and its transposed represenation
 ** and a list of  equation indexes that needs to be updated.
 ** First the IncidenceMatrix is updated, i.e. the mapping from equations
 ** to variables. Then, by collecting all variables in the list of equations
 ** to update, a list of changed variables are retrieved. This is used to 
 ** update the IncidenceMatrixT (transpose) mapping from variables to 
 ** equations. The relation returns an updated incidence matrix.
 **
 ** inputs:  (DAELow,
              IncidenceMatrix, 
              IncidenceMatrixT,
              int list /* list of equations to update */)
 ** outputs: (IncidenceMatrix, IncidenceMatrixT) 
 **)
relation update_incidence_matrix:(DAELow,
				  IncidenceMatrix, 
				  IncidenceMatrixT,
				  int list)
	  => (IncidenceMatrix, 
	      IncidenceMatrixT) =
 
  rule	update_incidence_matrix2(dae,m,eqns) => (m',changedvars) &
	Util.list_flatten(changedvars) => changedvars' &
	update_transposed_matrix(changedvars',m',mt) => mt' 
	------------------------------
	update_incidence_matrix(dae,m,mt,eqns) => (m',mt')


  rule	print "update_incidence_matrix failed\n" 
	---------------------------------------
	update_incidence_matrix(dae,m,mt,eqns) => fail
end


(** relation: update_incidence_matrix2
 ** author: PA
 ** 
 ** Helper relation to update_incidence_matrix
 ** 
 ** inputs:  (DAELow,
              IncidenceMatrix,
              int list /* list of equations to update */)
 ** outputs: (IncidenceMatrix, int list list /* changed vars */)
 **)
relation update_incidence_matrix2: (DAELow,
				    IncidenceMatrix,
				    int list) 
	  => (IncidenceMatrix, 
	      int list list ) =

  axiom	update_incidence_matrix2(dae,m,[]) => (m,[[]])

  rule	int_sub(e,1) => e' &
	equation_nth(daeeqns,e') => eqn &
	incidence_row(vars,eqn) => row &
	Util.array_replaceat_with_fill(row,e',m,[]) => m' &
	vars_in_eqn(m',e) => changedvars1 &
	update_incidence_matrix2(dae,m',eqns) => (m'',changedvars2) 
	---------------------------------------------------
	update_incidence_matrix2(dae as DAELOW(vars,knvars,daeeqns,daeseqns,_,_,_,_),m,e::eqns) 
	  => (m'',changedvars1::changedvars2)

  rule	print "-update_incididence_matrix2 failed\n" 
	-------------------------------------------
	update_incidence_matrix2(_,_,_) => fail

end


(** relation: update_transposed_matrix
 ** author: PA
 **
 ** Takes a list of variables and the transposed IncidenceMatrix, and 
 ** updates the variable rows.
 **
 ** inputs:  (int list /* var list */, 
              IncidenceMatrix,
              IncidenceMatrixT) 
 ** outputs:  IncidenceMatrixT 
 **)
relation update_transposed_matrix: (int list, 
				    IncidenceMatrix,
				    IncidenceMatrixT) 
	  => IncidenceMatrixT =

  axiom	update_transposed_matrix([],m,mt) => mt

  rule	array_list(m) => mlst &
	transpose_row(mlst,v,1) => row' &
	int_sub(v,1) => v' &
	Util.array_replaceat_with_fill(row',v',mt,[]) => mt' &
	update_transposed_matrix(vars,m,mt') => mt''
	-------------------------
	update_transposed_matrix(v::vars,m,mt) => mt''

  rule	print "-update_transposed_matrix failed\n" 
	------------------
	update_transposed_matrix(_,_,_) => fail
end


(** relation: make_all_states_algebraic
 ** author: PA
 **
 ** This relation makes all states of a DAELow algebraic.
 ** Is used when solving an initial value problem, since states are just
 ** an algebraic variable in that case.
 **)
relation make_all_states_algebraic: DAELow => DAELow =

  rule	var_list(vars) => var_lst &
	make_all_states_algebraic2(var_lst) => var_lst' &
	list_var(var_lst') => vars' 
	-----------
	make_all_states_algebraic(DAELOW(vars,knvar,eqns,reqns,ieqns,ae,al,ev))
	  => DAELOW(vars',knvar,eqns,reqns,ieqns,ae,al,ev)
end


(** relation: make_all_states_algebraic2
 ** author: PA
 **
 ** Helper relation to make_all_states_algebraic
**)
relation make_all_states_algebraic2: Var list => Var list =

  axiom	make_all_states_algebraic2([]) => []

  rule	make_all_states_algebraic2(vs) => vs'
	-----------------------------
	make_all_states_algebraic2(VAR(cr,STATE,d,t,b,value,dim,start,idx,name,class,dae_var_attr,comment,flow)::vs)
	  => VAR(cr,VARIABLE,d,t,b,value,dim,start,idx,name,class,dae_var_attr,comment,flow)::vs'

  rule	make_all_states_algebraic2(vs) => vs'
	-----------------------------
	make_all_states_algebraic2(v::vs)
	  => v::vs'
end


(** relation: make_algebraic
 ** author: PA
 ** Make the variable a dummy derivative, i.e. change varkind from STATE 
 ** to DUMMY_STATE.
 ** 
 ** inputs:  (DAELow, Exp.ComponentRef /* state */)
 ** outputs: (DAELow) =
 **
 **)
relation make_algebraic: (DAELow, Exp.ComponentRef) => (DAELow) =
	  
  rule	get_var(cr,vars) => (VAR(cr,kind,d,t,b,value,dim,start,idx,name,class,dae_var_attr,comment,flow)::_ ,indx) &
	add_var(VAR(cr,DUMMY_STATE,d,t,b,value,dim,start,idx,name,class,dae_var_attr,comment,flow),vars) => vars'
	-------------------------------------------------------------------------
	make_algebraic(DAELOW(vars,kv,e,se,ie,ae,al,wc),cr) 
	  => DAELOW(vars',kv,e,se,ie,ae,al,wc)

  rule	print "-make_algebraic failed\n" 
	--------------------------------
	make_algebraic(_,_) => fail
end	  


(** relation: replace_dummy_der
 ** author: PA
 **
 ** Helper relation to reduce_index_dummy_der
 ** replaces der(state) with the variable dummy der.
 **
 ** inputs:   (Exp.ComponentRef, /* state */
               Exp.ComponentRef, /* dummy der name */
               DAELow, 
               IncidenceMatrix, 
               IncidenceMatrixT,
               int list /* equations */)
 ** outputs:  (DAELow, 
               IncidenceMatrix, 
               IncidenceMatrixT)
 **
 **)
relation replace_dummy_der: (Exp.ComponentRef, 
			     Exp.ComponentRef, 
			     DAELow, 
			     IncidenceMatrix, 
			     IncidenceMatrixT,
			     int list)		
	  => ( DAELow, 
	      IncidenceMatrix, 
	      IncidenceMatrixT) =
	
  axiom	replace_dummy_der(state,dummy,dae,m,mt,[]) => (dae,m,mt)
	
  rule	int_sub(e,1) => e' &
	equation_nth(eqns,e') => eqn &
	replace_dummy_der2(state,dummyder,eqn) => eqn' &
	replace_dummy_der_others(eqn',v) => (eqn',v') &
	(*incidence_row(v'',eqn') => row' &
	 Util.list_replaceat(row',e',m) => m' &
	 transpose_matrix(m') => mt' &*)
	equation_setnth(eqns,e',eqn') => eqns' &
	replace_dummy_der(state,dummyder,DAELOW(v',kv,eqns',seqns,ie,ae,al,wc),m,mt,rest) 
	  => (dae,m,mt) 
	  -------------------------------
	replace_dummy_der(state,dummyder,DAELOW(v,kv,eqns,seqns,ie,ae,al,wc),m,mt,e::rest)
	  => (dae,m,mt)
	  
  rule	print "-replace_dummy_der failed\n" 
	-------------------
	replace_dummy_der(_,_,_,_,_,_) => fail
end


(** relation: replace_dummy_der2
 ** author: PA
 **
 ** Helper relation to reduce_index_dummy_der
 ** replaces der(state) with dummy_der variable in equation 
 **)
relation replace_dummy_der2:(Exp.ComponentRef,
			     Exp.ComponentRef,
			     Equation) => Equation =
	
	
  rule	(* scalar equation *)
	let dercall = Exp.CALL(Absyn.IDENT("der"),
			       [Exp.CREF(st,Exp.REAL)],
			       false,
			       true) &
	Exp.replace_exp(e1,dercall, Exp.CREF(dummyder,Exp.REAL)) => (e1',_) &
	Exp.replace_exp(e2,dercall, Exp.CREF(dummyder,Exp.REAL)) => (e2',_)
	---------------------------------------------------------------
	replace_dummy_der2(st,dummyder,EQUATION(e1,e2)) => EQUATION(e1',e2')

	(* array equation *)
  rule	(* TODO: We need to go through MultiDimEquation array here..*)
	---------------------------------------------------------------
	replace_dummy_der2(st,dummyder,ARRAY_EQUATION(ds,expl)) 
	  => ARRAY_EQUATION(ds,expl)

	(* Algorithms *)
  rule	(* TODO: We need to go through Algorithm.Algorithm here..*)
	---------------------------------------------------------------
	replace_dummy_der2(st,dummyder,ALGORITHM(indx,in,out)) 
	  => ALGORITHM(indx,in,out)

  rule	let dercall = Exp.CALL(Absyn.IDENT("der"),
			       [Exp.CREF(st,Exp.REAL)],
			       false,
			       true) &
	Exp.replace_exp(e1,dercall, Exp.CREF(dummyder,Exp.REAL)) => (e1',_) &
	let res = WHEN_EQUATION(WHEN_EQ(i,cr,e1'))
	---------------------------------------------------------------
	replace_dummy_der2(st,dummyder,WHEN_EQUATION(WHEN_EQ(i,cr,e1))) => res
	
  rule	print "-replace_dummy_der2 failed\n" 
	---------------
	replace_dummy_der2(_,_,_) => fail
end


(** relation: replace_dummy_der_others
 ** author: PA
 **
 ** Helper relation to reduce_index_dummy_der.
 ** This relation replaces
 ** 1. der(der_s)  with der2_s (Where der_s is a dummy state)
 ** 2. der(der(v)) with der2_v (where v is a state)
 ** 3. der(v)  for alg. var v with der_v 
 ** in the 'Equation' given as arguments. To do this it needs the 'Variables' 
 ** also passed as argument to the relation to e.g. determine if a variable
 ** is a dummy variable, etc.
 **)
relation replace_dummy_der_others:(Equation, Variables) => (Equation, Variables) =

	
  rule	(* scalar equation *)
	replace_dummy_der_others_exp(e1,vars) => (e1',vars') &
	replace_dummy_der_others_exp(e2,vars') => (e2', vars'')
	---------------------------------------------------------------
	replace_dummy_der_others(EQUATION(e1,e2),vars)
	  => (EQUATION(e1',e2'),vars'')

	  (* array equation *)
  rule	(* TODO *)
	---------------------------------------------------------------
	replace_dummy_der_others(ARRAY_EQUATION(ds,expl),vars)
	  => (ARRAY_EQUATION(ds,expl),vars)

  rule	replace_dummy_der_others_exp(e2,vars) => (e2', vars')
	---------------------------------------------------------------
	replace_dummy_der_others(WHEN_EQUATION(WHEN_EQ(i,cr,e2)),vars)
	  => (WHEN_EQUATION(WHEN_EQ(i,cr,e2')),vars')


  rule	print "-replace_dummy_der_others failed\n" 
	---------------------
	replace_dummy_der_others(_,_) => fail 
end


(** relation: replace_dummy_der_others_exp
 ** author: PA
 **
 ** Helper relation for replace_dummy_der_others
 **)
relation replace_dummy_der_others_exp: (Exp.Exp, Variables) 
	  => (Exp.Exp,Variables) =
	
  axiom	replace_dummy_der_others_exp(e as Exp.ICONST(_),vars) => (e,vars)
  axiom	replace_dummy_der_others_exp(e as Exp.RCONST(_),vars) => (e,vars)
  axiom	replace_dummy_der_others_exp(e as Exp.SCONST(_),vars) => (e,vars)
  axiom	replace_dummy_der_others_exp(e as Exp.BCONST(_),vars) => (e,vars)	
  axiom	replace_dummy_der_others_exp(e as Exp.CREF(_,_),vars) => (e,vars)
	
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.BINARY(e1,op,e2),vars)
	  => (Exp.BINARY(e1',op,e2'),vars2)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.LBINARY(e1,op,e2),vars)
	  => (Exp.LBINARY(e1',op,e2'),vars2)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.UNARY(op,e1),vars)
	  => (Exp.UNARY(op,e1'),vars1)

  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.LUNARY(op,e1),vars)
	  => (Exp.LUNARY(op,e1'),vars1)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2) 
	--------------------------------------------
	replace_dummy_der_others_exp(Exp.RELATION(e1,op,e2),vars)
	  => (Exp.RELATION(e1',op,e2'), vars2)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2) &
	replace_dummy_der_others_exp(e3,vars2) => (e3',vars3) 
	--------------------------------------------
	replace_dummy_der_others_exp(Exp.IFEXP(e1,e2,e3),vars)
	  => (Exp.IFEXP(e1',e2',e3'),vars3)
	  
  rule	(* der(der(s)) s is state => der_der_s *)
	get_var(cr,vars) => (VAR(_,STATE,a,b,c ,d,e,f,g,h,i,dae_var_attr,comment,flow)::_,_) &
	create_dummy_var(cr) => dummyder & 
	create_dummy_var(dummyder) => dummyder' &
	add_var(VAR(dummyder',DUMMY_DER,a,b,NONE,NONE,e,NONE,0,"dummyder",i,dae_var_attr,comment,flow),vars) => vars'
	--------------------------------------------------------------------------------
	replace_dummy_der_others_exp(Exp.CALL(Absyn.IDENT("der"),
					      [Exp.CALL(Absyn.IDENT("der"),
							[Exp.CREF(cr,_)],
							_,
							 _)],
					       _,
					       _),vars)
	 => (Exp.CREF(dummyder',Exp.REAL),vars')

   rule  (* der(der_s)) der_s is dummy var => der_der_s *)
	get_var(cr,vars) => (VAR(_,DUMMY_DER,a,b,c,d,e,f,g,h,i,dae_var_attr,comment,flow)::_,_) &
	create_dummy_var(cr) => dummyder & 
	add_var(VAR(dummyder,DUMMY_DER,a,b,NONE,NONE,e,NONE,0,"dummyder",i,dae_var_attr,comment,flow),vars) => vars'
	-------------------------------------------------------
	replace_dummy_der_others_exp(Exp.CALL(Absyn.IDENT("der"),
					      [Exp.CREF(cr,_)],
					      _,
					      _),vars)
	  => (Exp.CREF(dummyder,Exp.REAL),vars')
	  
	  
  rule  (* der(v) v is alg var => der_v *)
	get_var(cr,vars) => (VAR(_,VARIABLE,a,b,c,d,e,f,g,h,i,dae_var_attr,comment,flow)::_,_) &
	create_dummy_var(cr) => dummyder & 
	add_var(VAR(dummyder,DUMMY_DER,a,b,NONE,NONE,e,NONE,0,"dummyder",i,dae_var_attr,comment,flow),vars) => vars'
	-------------------------------------------------------
	replace_dummy_der_others_exp(Exp.CALL(Absyn.IDENT("der"),
					      [Exp.CREF(cr,_)],
					      _,
					      _),vars)
	  => (Exp.CREF(dummyder,Exp.REAL),vars')
	  
  axiom	replace_dummy_der_others_exp(e,vars) => (e,vars)
end


(** relation: var_equal
 ** author: PA
 ** 
 ** Returns true if two Var's are equal.
 **)
relation var_equal: (Var,Var) => bool =
	
	
  rule	(* A Var is identified by its component reference *)
	Exp.cref_equal(cr1,cr2) => res 
	------------------------------
	var_equal(VAR(cr1,_,_,_,_ ,_,_,_,_,_,_,_,_,flow1),VAR(cr2,_,_,_,_ ,_,_,_,_,_,_,_,_,flow2)) => res
end


(** relation: new_dummy_var
 ** author: PA
 **
 ** This relation creates a new variable named "der_"+<varname> and 
 ** adds it to the dae.
 **) 
relation new_dummy_var:(Exp.ComponentRef,DAELow) => (Exp.ComponentRef,DAELow) =
	
  rule	get_var(var,vars) => (VAR(_,kind,dir,tp,bind,value,dim,start,idx,name,class,dae_var_attr,comment,flow)::_,_) &
	create_dummy_var(var) => dummyvar &
	add_var(VAR(dummyvar,DUMMY_DER,dir,tp,NONE,NONE,dim,NONE,0,"dummyvar",class,dae_var_attr,comment,flow),vars) 
	  => vars'
	-----------------------------------
	new_dummy_var(var,DAELOW(vars,kv,eqns,seqns,ie,ae,al,wc)) 
	  => (dummyvar, DAELOW(vars',kv,eqns,seqns,ie,ae,al,wc))

  rule	print "-new_dummy_var failed\n" 
	-------------------------
	new_dummy_var(_,_) => fail
end


(** relation: create_dummy_var
 ** author: PA
 **
 ** Creates a new variable name by adding "der_" before it.
 ** Helper relation to new_dummy_var.
 **)
relation create_dummy_var: (Exp.ComponentRef) => Exp.ComponentRef =
	  
  rule  string_append("der_",id) => id'
	-------------------------------
	create_dummy_var(Exp.CREF_IDENT(id,subs)) 
	  => Exp.CREF_IDENT(id',subs)

  rule	create_dummy_var(cr) => cr'
	------------------------
	create_dummy_var(Exp.CREF_QUAL(id,subs,cr)) 
	  => Exp.CREF_QUAL(id,subs,cr')
end


(** relation: select_dummy_state
 ** author: PA
 **
 ** This relation is the heuristic to select among the states which one
 ** will be transformed into  an algebraic variable, a so called dummy state
 **(dummy derivative). It should in the future consider initial values, etc.
 **
 ** inputs:  (Exp.ComponentRef list, /* variable names */
              int list, /* variable numbers */
              DAELow, 
              IncidenceMatrix,
              IncidenceMatrixT) 
 ** outputs: (Exp.ComponentRef, int)
 **)
relation select_dummy_state: (Exp.ComponentRef list, 
			      int list, 
			      DAELow, 
			      IncidenceMatrix,
			      IncidenceMatrixT) 
	  => (Exp.ComponentRef, int) =	  
	  

  axiom	(* for now, select the first one... *)
           select_dummy_state(s::_,sn::_,_,_,_) => (s,sn)
	
  rule	print "Error, no state to select\n" 
	------------------------------------
	select_dummy_state([],_,_,_,_) => fail
end


(** relation: states_in_eqns
 ** author: PA
 **
 ** Helper relation to reduce_index_dummy_der.
 ** Returns all states in the equations given as equation index list.
 **
 ** inputs:  (int list /* eqns */,
              DAELow, 
              IncidenceMatrix,
              IncidenceMatrixT) 
 ** outputs: (Exp.ComponentRef list, /* name for each state */
              int list)  /* number for each state */
 **)
relation states_in_eqns: (int list, 
			  DAELow, 
			  IncidenceMatrix,
			  IncidenceMatrixT) 
	  => (Exp.ComponentRef list,
	      int list) =
	
  axiom	states_in_eqns([],_,_,_) => ([],[])
	
  rule	states_in_eqns(rest,DAELOW(vars,kv,eqns,seqns,ie,ae,al,wc),m,mt) => (res1,res2) &
	int_sub(e,1) => e' &
	equation_nth(eqns,e') => eqn &
	states_in_eqn(eqn,vars) => vars2 &
	var_list(vars) => varlst &
	states_in_vars(varlst,vars2) => (res11,res22) &
	list_append(res11,res1) => res1' &
	list_append(res22,res2) => res2'
	--------------------------------
	states_in_eqns(e::rest,DAELOW(vars,kv,eqns,seqns,ie,ae,al,wc),m,mt) => (res1',res2')
	
  rule	print "-states_in_eqns failed\n"
	-------------------------
	states_in_eqns(_,_,_,_) => fail
	
end


(** relation: states_in_vars
 ** author: PA
 **
 ** Helper relation to states_in_eqns
 **
 ** inputs:  (Var list, int list)
 ** outputs: (Exp.ComponentRef list, /* names of the states */
              int list /* number for each state */)
 **)
relation states_in_vars: (Var list, int list) => (Exp.ComponentRef list, int list ) =
	
  axiom	states_in_vars (vars,[]) => ([],[])
	
  rule	int_sub(v,1) => v' &
	list_nth(vars,v') => VAR(cr,_,_,_,_,_, _,_,_,_,_,_,_,flow) &
	states_in_vars(vars,rest) => (res1,res2)  
	---------------------------------
	states_in_vars(vars,v::rest) => (cr::res1,v::res2)
	
  rule	states_in_vars(vars,rest) => (res1,res2)
	----------------------------------------
	states_in_vars(vars,v::rest) => (res1,res2)
end


(** relation: differentiate_eqns
 ** author: PA
 **
 ** This relation takes a dae, its incidence matrices and the number of 
 ** equations an variables and a list of equation indices to 
 ** differentiate. This is used in the index reduction algorithm
 ** using dummy derivatives, when all marked equations are differentiated.
 ** The relation updates the dae, the incidence matrix and returns 
 ** a list of indices of the differentiated equations, they are added last in
 ** the dae.
 **
 ** inputs:  (DAELow, 
              IncidenceMatrix, 
              IncidenceMatrixT,
              int, /* number of vars */
              int, /* number of eqns */
              int list) /* equations */
 ** outputs: (DAELow, 
              IncidenceMatrix, 
              IncidenceMatrixT,
              int, /* number of vars */
	      int, /* number of eqns */ 
	      int list /* differentiated equations */)
 **)
relation differentiate_eqns: (DAELow, 
			      IncidenceMatrix, 
			      IncidenceMatrixT,
			      int, 
			      int, 
			      int list) 
	  => (DAELow, 
	      IncidenceMatrix, 
	      IncidenceMatrixT,
	      int, 
	      int, 
	      int list) =

  axiom	differentiate_eqns(dae,m,mt,nv,nf,[]) => (dae,m,mt,nv,nf,[])
	
  rule	int_sub(e,1) => e' &
	equation_nth(eqns,e') => eqn &
	Derive.differentiate_equation_time(eqn,v) => eqn' &
	(* update equation row in IncidenceMatrix *)	
	Debug.fprint("bltdump", "High index problem, differentiated equation: " )&
(*	print "differentiated equation " &*)
	equation_str eqn => str & 
(*	print str & print "\n" &*)
	Debug.fprint("bltdump", str) &
	Debug.fprint("bltdump", " to ") & 
	equation_str eqn' => str &
(*	print " to " & print str &  print "\n" &*)
	Debug.fprint("bltdump",str) & 
	Debug.fprint("bltdump", "\n") &
	equation_add(eqns,eqn') => eqns' &
	equation_size(eqns') => leneqns & (* length gives index of new equation *)
	(* Mark equation as differentiated so it won't be differentiated again*)
	DAEEXT.mark_differentiated(e) &
	differentiate_eqns(DAELOW(v,kv,eqns',seqns,ie,ae,al,wc),m,mt,nv,nf,es) 
	  => (dae,m,mt,nv,nf,reqns)
	  ----------------------------
	differentiate_eqns(dae as DAELOW(v,kv,eqns,seqns,ie,ae,al,wc),m,mt,nv,nf,e::es) 
	  => (dae,m,mt,nv,nf,leneqns::e::reqns)
	  
  rule	print "-differentiate_eqns failed\n" 
	----------------------------
	differentiate_eqns(_,_,_,_,_,_) => fail
end


(** relation: equation_add
 ** author: PA
 **
 ** Adds an equation to an EquationArray.
 **)
relation equation_add: (EquationArray,Equation) => EquationArray =

	
  rule	(* Have space to add array elt. *)
	int_lt(n,size) => true &
	n + 1 => n' &
	array_setnth(arr,n,SOME(e)) => arr'
	-------------------------------
	equation_add(EQUATION_ARRAY(n,size,arr),e) 
	  =>  EQUATION_ARRAY(n',size,arr')

	  (* Do NOT Have space to add array elt. Expand array 1.4 times *)
  rule	int_lt(n,size) => false &
	int_real(size) => rsize &
	real_mul(rsize,0.4) => rexpandsize &
	real_int(rexpandsize) => expandsize &
	int_max(expandsize,1) => expandsize' &
	int_add(expandsize',size) => newsize &
	Util.array_expand(expandsize',arr,NONE) => arr' &
	n + 1 => n' &
	array_setnth(arr',n,SOME(e)) => arr''
	-------------------------------
	equation_add(EQUATION_ARRAY(n,size,arr),e) 
	  =>  EQUATION_ARRAY(n',newsize,arr'')

  rule	print "-equation_add failed\n" 
	---------------------
	equation_add(EQUATION_ARRAY(n,size,arr),e) => fail
end


(** relation: equation_list
 ** author: PA
 ** 
 ** Transform the expandable Equation array to a list of Equations.
 **)
relation equation_list:(EquationArray) => Equation list =

  axiom	equation_list(EQUATION_ARRAY(0,_,arr)) => []
  rule	array_nth(arr,0) => SOME(elt) 
	-----------------------------
	equation_list(EQUATION_ARRAY(1,_,arr)) => [elt]

  rule	n - 1 => lastpos &
	equation_list2(arr,0,lastpos) => lst 
	-----------------------
	equation_list(EQUATION_ARRAY(n,size,arr)) => lst

  rule	print "equation_list failed\n"
	----------------------
	equation_list(_) => fail
end


(** relation: list_equation
 ** author: PA
 **
 ** Transform the a list of Equations into an expandable Equation array.
 **)
relation list_equation:(Equation list ) => EquationArray =
	
  rule	list_length(lst) => len &
	int_real(len) => rlen &
	rlen *. 1.4 => rlen' &
	real_int(rlen') => size &
	array_create(size,NONE) => optarr &
	Util.list_map(lst,Util.make_option) => eqn_optlst &
	list_array(eqn_optlst) => eqnarr &
	Util.array_copy(eqnarr,optarr) => newarr
	----------------------------------
	list_equation(lst) => EQUATION_ARRAY(len,size,newarr)
end


(** relation: equation_list2
 ** author: PA
 **
 ** Helper relation to equation_list
 **
 ** inputs:  (Equation option array, int /* pos */, int /* lastpos */)
 ** outputs: Equation list
 **
 **)
relation equation_list2:(Equation option array, int, int) => Equation list =

  rule	int_eq(pos,lastpos) => true &
	array_nth(arr,pos) => SOME(e) 
	-----------------------------
	equation_list2(arr,pos,lastpos) => [e]

  rule	pos + 1 => pos' &
	array_nth(arr,pos) => SOME(e) &
	equation_list2(arr,pos',lastpos) => res
	---------------------------------------
	equation_list2(arr,pos,lastpos) => e::res
end


(** relation: equation_size
 ** author: PA
 **
 ** Returns the number of equations in an EquationArray.
 ** Note: This is not corresponding to the number of equations in a system,
 ** since both algorithms and array equations can count as more than one.
 ** For counting the number of equations in the system, use equation_size.
 **)
relation equation_size:(EquationArray) => int =

  axiom	equation_size(EQUATION_ARRAY(n,_,_)) => n
end


(** relation: variable_size
 ** author: PA
 **
 ** Returns the number of variables
 **)
relation variable_size:(Variables) => int =

  axiom	variable_size(VARIABLES(_,_,_,_,n)) => n 
end


(** relation: equation_nth
 ** author: PA
 **
 ** Return the n:th equation from the expandable equation array 
 ** indexed from 0..1.
 **
 ** inputs:  (EquationArray, int /* n */) 
 ** outputs:  Equation 
 **
 **)
relation equation_nth:(EquationArray, int) => Equation =

  rule	int_lt(pos,n) => true &
	array_nth(arr,pos) => SOME(e) 
	---------------------
	equation_nth(EQUATION_ARRAY(n,_,arr),pos) => e

  rule	print "equation_nth failed\n" 
	-----------------------------
	equation_nth(_,_) => fail
end


(** relation: equation_setnth
 ** author: PA
 ** 
 ** Sets the nth array element of an EquationArray.
 **)
relation equation_setnth: (EquationArray,int,Equation) => EquationArray =

  rule	array_setnth(arr,pos,SOME(eqn)) => arr'
	---------------------------------------
	equation_setnth(EQUATION_ARRAY(n,size,arr),pos,eqn) 
	  => EQUATION_ARRAY(n,size,arr')
end


(** relation: add_marked_vars
 ** author: PA
 **
 ** This relation is part of the matching algorithm.
 ** 
 ** inputs:  (DAELow, 
              IncidenceMatrix, 
              IncidenceMatrixT,
              int, /* number of vars */
              int, /* number of eqns */
              int list /* marked vars */)
 ** outputs: (DAELow, 
              IncidenceMatrix, 
              IncidenceMatrixT,
              int, /* number of vars */
              int  /* number of eqns */)
 **)
relation add_marked_vars:(DAELow, 
			  IncidenceMatrix, 
			  IncidenceMatrixT,
			  int, 
			  int, 
			  int list) 
	=> (DAELow, 
	    IncidenceMatrix, 
	    IncidenceMatrixT,
	    int, 
	    int) =

  axiom	add_marked_vars(dae,m,mt,nv,nf,[]) => (dae,m,mt,nv,nf)
	
  rule	(* TODO remove variable from dae and m,mt and add der{variable} instead*)
	int_add(nv,1) => nv' &
	DAEEXT.set_v(v,nv') &
	
	add_marked_vars(dae,m,nt,nv',nf,vs) => (dae,m,mt,nv,nf)
	-------------------------------------------------------
	add_marked_vars(dae,m,nt,nv,nf,v::vs) => (dae,m,mt,nv,nf)
end


(** relation: path_found
 ** author: PA
 **
 ** This relation is part of the matching algorithm.
 ** It tries to find a matching for the equation index given as 
 ** third argument, i.
 **
 ** inputs:  (IncidenceMatrix, IncidenceMatrixT, int /* equation */, 
               Assignments, Assignments) 
 ** outputs: (Assignments, Assignments)
 **)
relation path_found: (IncidenceMatrix, IncidenceMatrixT, int, Assignments, Assignments) 
                  => (Assignments, Assignments) =


  rule	DAEEXT.e_mark(i) (* Side effect *) &
	assign_one_in_eqn(m,mt,i,ass1,ass2) => (ass1',ass2')
	------------
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2')

  rule	forall_unmarked_vars_in_eqn(m,mt,i,ass1,ass2) => (ass1',ass2')
	-----------------------------------------------------------
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2')
end


(** relation: assign_one_in_eqn
 ** author: PA
 ** 
 ** Helper relation to path_found.
 **)
relation assign_one_in_eqn: (IncidenceMatrix, IncidenceMatrixT, int, 
		      Assignments, Assignments) => (Assignments, Assignments) =
	
  rule  vars_in_eqn(m,i) => vars &
	assign_first_unassigned(i,vars,ass1,ass2) => (ass1',ass2') 
	----------------------------------------------------------
	assign_one_in_eqn(m,mt,i,ass1,ass2) => (ass1',ass2')

	(*  rule	print "assign_one_in_eqn failed\n" 
	 ----------------------------------
	 assign_one_in_eqn(_,_,_,_,_) => fail*)
end 


(** relation: states_in_eqn
 ** author: PA
 ** Helper relation to states_in_eqns
 **)
relation states_in_eqn: (Equation, Variables) => int list =

  rule	states_as_algebraic_vars(vars) => vars' &
	incidence_row(vars',eqn) => res
	-----------------
	states_in_eqn(eqn,vars) => res
end


(** relation: states_as_algebraic_vars
 ** author: PA
 ** 
 ** Return the subset of variables consisting of all states, but changed 
 ** varkind to variable.
 **)
relation states_as_algebraic_vars:( Variables) => Variables =
	 
  rule	(* Creates a new set of Variables from a Var list *)
	var_list(vars) => varlst &
	states_as_algebraic_vars2(varlst) => varlst' &
	empty_vars() => v1 &
	add_vars(varlst',v1) => v1' 
	----------------------------------------------
	states_as_algebraic_vars(vars)  => v1'
end


(** relation: states_as_algebraic_vars2
 ** author: PA
 **
 ** helper relation to states_as_algebraic_vars
 **)
relation states_as_algebraic_vars2: (Var list ) => Var list =

  axiom	states_as_algebraic_vars2 [] => []

  rule	(* states treated as algebraic variables *)
	states_as_algebraic_vars2(vs) => res 
	------------------------------------
	states_as_algebraic_vars2(VAR(cr,STATE,a,b,c,d,e,f,g,h,i,dae_var_attr,comment,flow)::vs) 
	  => (VAR(cr,VARIABLE,a,b,c,d,e,f,g,h,i,dae_var_attr,comment,flow)::res)

  rule	(* other variables treated as known *)
	states_as_algebraic_vars2(vs) => res 
	------------------------------------
	states_as_algebraic_vars2(VAR(cr,_,a,b,c,d,e,f,g,h,i,dae_var_attr,comment,flow)::vs) 
	  => (VAR(cr,CONST,a,b,c,d,e,f,g,h,i,dae_var_attr,comment,flow)::res)

  rule	states_as_algebraic_vars2(vs) => res 
	----------------------
	states_as_algebraic_vars2(_::vs) 
	  => res
end


(** relation: vars_in_eqn
 ** author: PA
 **
 ** This relation returns all variable indices as a list for a given
 ** equation, given as an equation index. (1...n)
 ** Negative indexes are removed.
 **
 ** inputs:  (IncidenceMatrix, int /* equation */) 
 ** outputs:  int list /* variables */
 **)
relation vars_in_eqn: (IncidenceMatrix, int) => int list =

  rule	int_sub(n,1) => n' &
	array_nth(m,n') => res &
	remove_negative(res) => res'
	--------------------
	vars_in_eqn(m,n) => res' 

  rule	print "vars_in_eqn failed, indx="  &
	int_string indx => s & print s & print "\n"
	----------------------------
	vars_in_eqn(_,indx) => fail
end


(** relation: remove_negative
 ** author: PA
 **
 ** Removes all negative integers.
 **)
relation remove_negative:(int list) => int list =

  rule	Util.list_select(lst,Util.int_positive) => lst'
	----------------------
	remove_negative(lst) => lst'
end


(** relation: eqns_for_var
 ** author: PA
 **
 ** This relation returns all equations as a list of equation indices
 ** given a variable as a variable index.
 **
 ** inputs:  (IncidenceMatrixT, int /* variable */) 
 ** outputs:  int list /* equations */
 **)
relation eqns_for_var: (IncidenceMatrixT, int) => int list =

  rule	int_sub(n,1) => n' &
	array_nth(mt,n') => res &
	remove_negative(res) => res'
	--------------------
	eqns_for_var(mt,n) => res'

  rule	print "eqns_for_var failed, indx="  &
	int_string indx => s & print s & print "\n"
	----------------------------
	eqns_for_var(_,indx) => fail
end


(** relation: eqns_for_var_with_states
 ** author: PA
 **
 ** This relation returns all equations as a list of equation indices
 ** given a variable as a variable index, including the equations containing 
 ** the state variable but not its derivative. This must be used to update 
 ** equations when a state is changed to algebraic variable in index reduction 
 ** using dummy derivatives.
 ** These equation indices are represented with negative index, thus all 
 ** indices are mapped trough int_abs (absolute value).
 **
 ** inputs:  (IncidenceMatrixT, int /* variable */) 
 ** outputs:  int list /* equations */ 
 **)
relation eqns_for_var_with_states: (IncidenceMatrixT, int) => int list =

  rule	int_sub(n,1) => n' &
	array_nth(mt,n') => res &
	Util.list_map(res,int_abs) => res'
	----------------------------------
	eqns_for_var_with_states(mt,n) => res'

  rule	print "eqns_for_var failed, indx="  &
	int_string indx => s & print s & print "\n"
	----------------------------
	eqns_for_var_with_states(_,indx) => fail
end


(** relation: assign_first_unassigned
 ** author: PA
 **
 ** This relation assigns the first unassign variable to the equation
 ** given as first argument. It is part of the matching algorithm.
 **
 ** inputs:  (int /* equation */,
              int list /* variables */, 
              Assignments /* ass1 */, 
              Assignments /* ass2 */) 
 ** outputs: (Assignments,  /* ass1 */
              Assignments)  /* ass2 */
 **)
relation assign_first_unassigned: (int, int list, Assignments, Assignments) 
	  => (Assignments, Assignments)=

  rule	get_assigned(v,ass1,ass2) => 0 &
	assign(v,i,ass1,ass2) => (ass1',ass2')
	--------------------------------------
	assign_first_unassigned(i,v::vs,ass1,ass2) => (ass1',ass2')
 
  rule	assign_first_unassigned(i,vs,ass1,ass2) => (ass1',ass2')
	--------------------------------------------------------
	assign_first_unassigned(i,v::vs,ass1,ass2) => (ass1',ass2')
end


(** relation: get_assigned
 ** author: PA
 **
 ** returns the assigned equation for a variable.
 **
 ** inputs:  (int		/* variable */, 
              Assignments,	/* ass1 */ 
              Assignments)	/* ass2 */ 
 ** outputs:  int /* equation */
 **)
relation get_assigned: (int, Assignments, Assignments) => int =
	
  rule	int_sub(v,1) => v' &
	array_nth(m,v') => res
	-------------------
	get_assigned(v,ASSIGNMENTS(_,_,m),_) => res
end


(** relation: assign
 ** author: PA
 **
 ** Assign a variable to an equation, updating both assignment lists.
 **
 ** inputs: (int, /* variable */
             int, /* equation */
             Assignments, /* ass1 */
             Assignments) /* ass2 */
 ** outputs: (Assignments,	/* updated ass1 */
              Assignments)	/* updated ass2 */ 
 **)
relation assign: (int, int, Assignments, Assignments) 
	  => (Assignments, Assignments) =

  rule	(*print "assign " & int_string v => vs &
	int_string e => es & print vs & print " to eqn " &
	print es & print "\n" &*)
	int_sub(v,1) => v' &
	int_sub(e,1) => e' &
	assignments_setnth(ass1,v',e) => ass1' &
	assignments_setnth(ass2,e',v) => ass2'
	----------------------------------------
	assign(v,e,ass1,ass2) => (ass1',ass2')
end


(** relation: forall_unmarked_vars_in_eqn
 ** author: PA
 **
 ** This relation is part of the matching algorithm. It loops over all umarked
 ** variables in an equation.
 **
 ** inputs:  (IncidenceMatrix, 
              IncidenceMatrixT, 
              int, 
              Assignments /* ass1 */, 
              Assignments /* ass2 */) 
 ** outputs: (Assignments, Assignments)
 **)
relation forall_unmarked_vars_in_eqn: (IncidenceMatrix, IncidenceMatrixT, int, 
		      Assignments, Assignments) 
	  => (Assignments, Assignments)  =
	
  rule	vars_in_eqn(m,i) => vars &
	Util.list_matching(vars,is_not_v_marked) => vars' &
	forall_unmarked_vars_in_eqn_body(m,mt,i,vars',ass1,ass2) 
	  => (ass1',ass2')
	-------------------------
	forall_unmarked_vars_in_eqn (m,mt,i,ass1,ass2) => (ass1',ass2')
end


(** relation: is_not_v_marked
 ** author: PA
 **
 ** This relation succeds for variables that are not marked.
**)
relation is_not_v_marked: int => () =

  rule	DAEEXT.get_v_mark(i) => false
	------------------
	is_not_v_marked(i)
end


(** relation: forall_unmarked_vars_in_eqn_body
 ** author: PA
 **
 ** This relation is part of the matching algorithm.
 ** It is the body of the loop over all unmarked variables.
 **
 ** inputs:  (IncidenceMatrix, IncidenceMatrixT,
              int,
              int list /* var list */
              Assignments 
              Assignments)  
 ** outputs: (Assignments, Assignments) 
 **)
relation forall_unmarked_vars_in_eqn_body: (IncidenceMatrix, IncidenceMatrixT
					    , int
					    , int list
					    , Assignments 
					    , Assignments)  
	  => (Assignments, Assignments) =

  rule	DAEEXT.v_mark(v) &
	get_assigned(v,ass1,ass2) => assarg &
	path_found(m,mt,assarg,ass1,ass2) => (ass1',ass2') &
	assign(v,i,ass1',ass2') => (ass1'',ass2'')
	----------------------------
	forall_unmarked_vars_in_eqn_body(m,mt,i,vars as (v::vs),ass1,ass2) 
	  => (ass1'',ass2'')
	
  rule	DAEEXT.v_mark(v) &
	forall_unmarked_vars_in_eqn_body(m,mt,i,vs,ass1,ass2) => (ass1',ass2')
	--------------------------------------------------------------------
	forall_unmarked_vars_in_eqn_body(m,mt,i,vars as (v::vs),ass1,ass2)
	  => (ass1',ass2')
end


(** relation: strong_components
 ** author: PA
 **
 ** This is the second part of the BLT sorting. It takes the variable 
 ** assignments and the incidence matrix as input and identifies strong 
 ** components, i.e. subsystems of equations.
 **
 ** inputs:  (IncidenceMatrix, IncidenceMatrixT, int vector, int vector,
 ** 	      Exp.ComponentRef list /* ifconditions*/)
 ** outputs: (int list list /* list of components */ )
 **)
relation strong_components: (IncidenceMatrix list, IncidenceMatrixT list,
			     int vector list, int vector list,
			     Exp.ComponentRef list) => 
	(Block list) =

  rule	strong_components_lst(m_lst,mt_lst,ass1_lst,ass2_lst) => all_blocks &
	merge_blocks(all_blocks,ifconds,ass2_lst) => blocks &
	calculate_cond_blocks_indices(blocks) => blocks'
	-----------------------------
	strong_components(m_lst,mt_lst,ass1_lst,ass2_lst,ifconds) => blocks'

  rule	Debug.fprint("failtrace","-strong_components failed\n")
	---------------------------
	strong_components(m_lst,mt_lst,ass1_lst,ass2_lst,ifconds) => fail
end

(** relation: calculate_cond_blocks_indices
 ** author: PA
 **
 ** Calculates indices on conditional blocks, ranging from 0 to n-1.
 **)

relation calculate_cond_blocks_indices: (Block list) => Block list =

  rule	calculate_cond_blocks_indices2(blocks,0) => blocks'
	-------------------------
	calculate_cond_blocks_indices(blocks) => blocks'
end

(** relation: calculate_cond_blocks_indices2
 ** author: PA
 **
 ** Helper relation to calculate_cond_blocks_indices.
 **)

relation calculate_cond_blocks_indices2:(Block list, int) 
	  => Block list =

  axiom	calculate_cond_blocks_indices2([],_) => []

	(* TODO: Only works for one boolean variable. For more 
	 * booleans we need the list of boolean variables here..*)
  rule	indx + 1 => indx' &
	indx % 2 => indx1 &
	calculate_cond_blocks_indices2(blocks,indx') => blocks'
	----------------------------
	calculate_cond_blocks_indices2(COND_EQN_BLOCK(e,c,_)::blocks,indx)
	  => COND_EQN_BLOCK(e,c,indx1)::blocks'

  rule	calculate_cond_blocks_indices2(blocks,indx) => blocks'
	----------------------------
	calculate_cond_blocks_indices2(block::blocks,indx)
	  => block::blocks'
end

(** relation: merge_blocks
 ** author: PA
 **
 ** This relation merges several list of blocks
**)
relation merge_blocks: (Block list list,Exp.ComponentRef list, 
			int vector list (* assignments2*)) => Block list =

  axiom	merge_blocks([]::_,_,_) => []
	
  rule	merge_blocks_first(all_blocks,ifconds,ass2_lst) => (first,rest) &
	merge_blocks(rest,ifconds,ass2_lst) => rest' &
	list_append(first,rest') => res
	-----------------------------
	merge_blocks(all_blocks,ifconds,ass2_lst) => res
end

(** relation: merge_blocks_first
 ** author: PA
 **
 ** Helper relation to merge_blocks. Extracts the first block from all
 ** list elements and merges them.
 **)

relation merge_blocks_first: (Block list list, 
			      Exp.ComponentRef list,
			      int vector list (* assignments2*))
	  => (Block list,Block list list) =

  rule	Util.list_map(all_blocks,Util.list_first) => first_blocks &
	merge_blocks2(first_blocks,if_conds,ass2_lst) => block &
	Util.list_map(all_blocks,Util.list_rest) => rest 
	------------------------------------------------
	merge_blocks_first(all_blocks,if_conds,ass2_lst) => (block,rest)

  rule	Debug.fprint("failtrace","-merge_blocks_first failed\n")
	------------------------------------------------
	merge_blocks_first(all_blocks,if_conds,ass2_lst) => fail
end

(** relation: merge_blocks2
 ** author: PA
 **
 ** Helper relation to merge_blocks_first. Blocks that are identical are
 ** merged. Otherwise, conditional blocks are made.
 **)

relation merge_blocks2: (Block list, 
			 Exp.ComponentRef list,
			 int vector list (* assignments2*)) => Block list =

	(* all blocks identical, same variable solved in each block. *)
  rule	Util.list_reduce(blocks,block_equal) => block  &
	merge_blocks2_same_var_solved(blocks,ass2_lst) => true
	-------------------------
	merge_blocks2(blocks,if_conds,ass2_lst) => [block]
	
	(* blocks not identical, create conditional blocks*)
  rule	merge_blocks3(blocks,if_conds) => res
	-----------------------------
	merge_blocks2(blocks,if_conds,ass2_lst) => res

  rule	Debug.fprint("failtrace","-merge_blocks2 failed\n")
	-------------------
	merge_blocks2(_,_,_) => fail
end

(** relation: merge_blocks2_same_var_solved
 **
 **  This relation checks that the same variables are solved in all different
 ** equation blocks. If not the relation returns false.
 **)

relation merge_blocks2_same_var_solved: (Block list, int vector list)
	=> bool =

  rule	Util.list_thread_map(blocks,ass2_lst,block_get_solved_vars) => vars &
	Util.list_reduce(vars,vars_equal) => vars
	-----------------------
	merge_blocks2_same_var_solved(blocks,ass2_lst) => true 

  axiom	merge_blocks2_same_var_solved(_,_) => false
end

(** relation: vars_equal
 **
 ** Helper relation to e.g. merge_blocks2_same_var_solved
 ** Succeds if two variable lists are equal and returns the first
 ** of them if so. Otherwise it fails.
**)

relation vars_equal: (int list,int list) => int list =

  axiom	vars_equal([],[]) => [] 
     
  rule	int_eq(v1,v2) => true &
	vars_equal(vs1,vs2) => vs
	-------------------------
	vars_equal(v1::vs1,v2::vs2) => v1::vs
end


(** relation block_get_solved_vars
 ** author: PA
 ** 
 ** For a given block and assignments, find the variables solved in that block.
 **)

relation block_get_solved_vars: (Block, int vector  (*assignments2*)) 
	  => int list =

  axiom	block_get_solved_vars(EQN_BLOCK([]),_) => [] 
	
  rule	int_sub(e,1) => e' &
	vector_nth(ass2,e') => v &
	block_get_solved_vars(EQN_BLOCK(eqns),ass2) => v_lst 
	-------------------------------
	block_get_solved_vars(EQN_BLOCK(e::eqns),ass2) => v::v_lst
end

(** relation: merge_blocks3
 ** author: PA
 ** 
 ** Merges blocks that are not equal.
 **)

relation merge_blocks3: (Block list, Exp.ComponentRef list) => Block list =

  axiom	merge_blocks3([],[]) => []

	(* one boolean *)
  rule  Exp.print_component_ref_str cr => cr_str &
	Util.modelica_string_to_c_str cr_str => cr_str' &
	string_append("$",cr_str') => cr_str'' &
	let cr' = Exp.CREF_IDENT(cr_str'',[]) &
	let cond_b1 = COND_EQN_BLOCK(b1,Exp.CREF(cr',Exp.BOOL),0) &
	let cond_b2 = COND_EQN_BLOCK(b2,Exp.LUNARY(Exp.NOT,
						   Exp.CREF(cr',Exp.BOOL)),0)
	-------------------------------
	merge_blocks3([EQN_BLOCK(b1),EQN_BLOCK(b2)],[cr]) => [cond_b1,cond_b2]
	
	(* several booleans*)
  rule	Exp.print_component_ref_str cr => cr_str &
	Util.modelica_string_to_c_str cr_str => cr_str' &
	string_append("$",cr_str') => cr_str'' &
	let cr' = Exp.CREF_IDENT(cr_str'',[]) &
	let cond_b1 = COND_EQN_BLOCK(b1,Exp.CREF(cr',Exp.BOOL),0) &
	let cond_b2 = COND_EQN_BLOCK(b2,Exp.LUNARY(Exp.NOT,
						   Exp.CREF(cr',Exp.BOOL)),0) &
	merge_blocks3(blocks,crs) => rest
	-------------------------------
	merge_blocks3(EQN_BLOCK(b1)::EQN_BLOCK(b2)::blocks,cr::crs) 
	  => cond_b1::cond_b2::rest
end

(** relation: block_equal
 ** author: PA
 **
 ** Returns first block if two Block's are equal, otherwise fails
 **)

relation block_equal: (Block, Block) => Block =

	(* equation blocks *)
  rule	Util.list_thread_map(lst1,lst2,int_eq) => blst &
	Util.bool_and_list(blst) => true
	-------------------
	block_equal(EQN_BLOCK(lst1),EQN_BLOCK(lst2)) => EQN_BLOCK(lst1)

	(* conditional equation blocks*)
  rule	Util.list_thread_map(lst1,lst2,int_eq) => blst &
	Exp.exp_equal(e1,e2) => b &
	Util.bool_and_list(b::blst) => true
	-------------------
	block_equal(COND_EQN_BLOCK(lst1,e1,indx1),COND_EQN_BLOCK(lst2,e2,_)) 
	  => COND_EQN_BLOCK(lst1,e1,indx1)

end


(* relation: strong_components_lst
 **
 ** Helper relation to strong_components, traverses each list elements
 ** and calls strong components algorithm.
 ** Returns a list of list of blocks, one block list for each "system".
 **)

relation strong_components_lst:(IncidenceMatrix list, IncidenceMatrixT list,
				int vector list, int vector list) => 
	(Block list list) =

  axiom	strong_components_lst([],[],[],[]) =>([])

  rule	strong_components2(m,mt,ass1,ass2) => blocks &
	strong_components_lst(m_lst,mt_lst,ass1_lst,ass2_lst) => all_blocks
	---------------------------
	strong_components_lst(m::m_lst,mt::mt_lst,ass1::ass1_lst,ass2::ass2_lst)
	  => blocks::all_blocks
end

(** relation: strong_components2
 **
 ** Helper relation to strong_components_lst, Calls strong_connect, the actual
 **algorithm, for a  "system".
 **)

relation strong_components2: (IncidenceMatrix, IncidenceMatrixT,
			      int vector,
			      int vector) => (Block list) =

  rule	array_length(m) => n &
	DAEEXT.init_lowlink(n) &
	DAEEXT.init_number(n) &
	strong_connect_main(m,mt,ass1,ass2,n,0,1,[],[]) 
	  => (i,stack,comps) &
	to_eqn_blocks(comps) => comps'
	-----------------------------------
	strong_components2(m,mt,ass1,ass2) => (comps')

  rule	Debug.fprint("failtrace", "strong_components2 failed\n")
	----------------------------------
	strong_components2(_,_,_,_) => fail
end

(** relation: to_eqn_blocks
 ** author: PA
 **
 ** Convert a int list list to Block list.
 **)
relation to_eqn_blocks: int list list => Block list =

  axiom	to_eqn_blocks([]) => []

  rule	to_eqn_blocks(bs) => res
	-------------------
	to_eqn_blocks(b::bs) => EQN_BLOCK(b)::res
end


(** relation: strong_connect_main
 ** author: PA
 **
 ** Helper relation to strong_components
 **
 ** inputs:  (IncidenceMatrix,
              IncidenceMatrixT,
              int vector, /* Assignment */
              int vector, /* Assignment */
              int, /* n - number of equations */
              int, /* i */
              int, /* w */
              int list, /* stack */
              int list list /* components */)
 ** outputs: (int /* i */, int list /* stack */, int list list /* components */) 
 **)
relation strong_connect_main:(IncidenceMatrix,
			 IncidenceMatrixT,
			 int vector, 
			 int vector, 
			 int, 
			 int, 
			 int, 
			 int list, 
		         int list list) 
	  => (int, 
	      int list, 
	      int list list) =

  rule	int_gt(w,n) => true
	-------------------
	strong_connect_main(m,mt,a1,a2,n,i,w,stack,comp) 
	  => (i,stack,comp)
	
  rule	DAEEXT.get_number(w) => 0 &
	strong_connect(m,mt,a1,a2,i,w,stack,comps)
	  =>(i,stack',comps) &
	int_add(w,1) => w' &
	strong_connect_main(m,mt,a1,a2,n,i,w',stack',comps)
	  => (i,stack'',comps) 
	-----------------------------
	strong_connect_main(m,mt,a1,a2,n,i,w,stack,comps)
	  => (i,stack'',comps)

  rule	DAEEXT.get_number(w) => num &
	int_eq(num,0) => false &
	int_add(w,1) => w' &
	strong_connect_main(m,mt,a1,a2,n,i,w',stack,comps)
	  => (i,stack',comps)
	---------------------------------
	strong_connect_main(m,mt,a1,a2,n,i,w,stack,comps)
	  =>(i,stack',comps)
end


(** relation: strong_connect
 ** author: PA
 **
 ** Helper relation to strong_connect_main
 **
 ** inputs:  (IncidenceMatrix, IncidenceMatrixT, int vector, int vector,
              int /* i */, int /* v */, int list /* stack */, int list list /* components */)
 ** outputs: (int /* i */, int list /* stack */, int list list /* components */ )
 **)
relation strong_connect: (IncidenceMatrix,
			  IncidenceMatrixT,
			  int vector,
			  int vector,
			  int, 
			  int, 
			  int list, 
			  int list list) 
	  => (int, int list, int list list ) =

  rule	int_add(i,1) => i' &
(*	set_number(number,v,i') => number' &
	set_lowlink(lowlink,v,i') => lowlink' &*)
	DAEEXT.set_number(v,i') &
	DAEEXT.set_lowlink(v,i') &
	let stack' = v::stack & 
	reachable_nodes(v,m,mt,a1,a2) => eqns &
	iterate_reachable_nodes(eqns,m,mt,a1,a2,i',v,stack',comps)
	  => (i',stack'',comps') &
	check_root(m,mt,a1,a2,i',v,stack'') 
	  => (i',stack''',comp) &
	cons_if_nonempty(comp,comps') => comps''
	---------------------------------------------
	strong_connect(m,mt,a1,a2,i,v,stack,comps) 
	  => (i',stack''',comps'')

  rule	Debug.fprint("failtrace", "-strong_connect failed\n")
	--------------------
	strong_connect(_,_,_,_,_,_,_,_) => fail
end


(** relation: cons_if_nonempty
 ** author: PA
 **
 ** Small helper relation to avoid empty sublists.
 ** Consider moving to Util?
 **)
relation cons_if_nonempty: (int list, int list list) => int list list =
  axiom	cons_if_nonempty ([],lst) => lst 

  axiom	cons_if_nonempty (e,lst) => e::lst
end 


(** relation: reachable_nodes
 ** author: PA
 **
 ** Helper relation to strong_connect.
 ** Returns a list of reachable nodes (equations), corresponding
 ** to those equations that uses the solved variable of this equation.
 ** The edges of the graph that identifies strong components/blocks are
 ** dependencies between blocks. A directed edge e = (n1,n2) means 
 ** that n1 solves for a variable (e.g. 'a') that is used in the equation
 ** of n2, i.e. the equation of n1 must be solved before the equation of n2.
 **)
relation reachable_nodes: (int,
			   IncidenceMatrix,
			   IncidenceMatrixT,
			   int vector,
			   int vector) => int list =
	
  rule	int_sub(eqn,1) => eqn' &
	vector_nth(a2,eqn') => var &
	int_sub(var,1) => var' &
	(* Got the variable that is solved in the equation *)
	array_nth(mt,var') => reachable &
	(* in which other equations is this variable present ?*)
	remove_negative(reachable) => reachable' &
	Util.list_position(eqn,reachable') => pos 
	(* .. except this one *)&
	list_delete(reachable',pos) => reachable''
	----------------------------------------
	reachable_nodes(eqn,m,mt,a1,a2) => reachable''

  rule	Debug.fprint("failtrace","-reachable_nodes failed, eqn: ") &
	int_string(eqn) => eqnstr & Debug.fprint("failtrace", eqnstr) &
	Debug.fprint("failtrace", "\n")
	-----------------------
	reachable_nodes(eqn,_,_,_,_) => fail  
end			  


(** relation: iterate_reachable_nodes
 ** author: PA
 **
 ** Helper relation to strong_connect.
 **
 ** inputs:  (int list, IncidenceMatrix, IncidenceMatrixT, int vector, int vector,
              int /* i */, int /* v */, int list /* stack */, int list list /* components */)
 ** outputs: (int /* i */, int list /* stack */, int list list /* components */)
 **)
relation iterate_reachable_nodes: (int list, 
				   IncidenceMatrix,
				   IncidenceMatrixT,
				   int vector,
				   int vector,
				   int, 
				   int, 
				   int list, 
				   int list list) 
	  => (int, int list, int list list) =
	
  rule	DAEEXT.get_number(w) => 0 &
	strong_connect(m,mt,a1,a2,i,w,stack,comps) 
	  => (i,stack,comps') &
	DAEEXT.get_lowlink(v) => lv &
	DAEEXT.get_lowlink(w) => lw &
	int_min(lv,lw) => minv &
	DAEEXT.set_lowlink(v,minv) &
	iterate_reachable_nodes(ws,m,mt,a1,a2,i,v,stack,comps') 
	  => (i,stack,comps'')
	  ----------------------------
	iterate_reachable_nodes(w::ws,m,mt,a1,a2,i,v,stack,comps) 
	  => (i, stack,comps'')
	  
  rule	DAEEXT.get_number(w) => nw &
	DAEEXT.get_number(v) => nv &
	int_lt(nw,nv) => true &
	list_member(w,stack) => true &
	DAEEXT.get_lowlink(w) => lowlinkw &
	int_min(nw,lowlinkw) => minv &
	DAEEXT.set_lowlink(v,minv) &
	iterate_reachable_nodes(ws,m,mt,a1,a2,i,v,stack,comps) 
	  => (i,stack,comps')
	  -----------------------
	iterate_reachable_nodes(w::ws,m,mt,a1,a2,i,v,stack,comps)
	  => (i,stack,comps')
	  
  rule	iterate_reachable_nodes(ws,m,mt,a1,a2,i,v,stack,comps) 
	  => (i,stack,comps')
	  -----------------------------
	iterate_reachable_nodes(w::ws,m,mt,a1,a2,i,v,stack,comps)
	  => (i,stack,comps')
	  
  axiom iterate_reachable_nodes([],m,mt,a1,a2,i,v,stack,comps)
	  => (i,stack,comps)
end


(** relation: dump_list
 ** author: PA
 **
 ** Helper relation to dump.
 **)
relation dump_list: (int list, string) => () =

  rule	Util.list_map(l,int_string) => s &
	Util.string_delimit_list(s,", ") => sl &
	print str & print sl & print "\n" 
	-------------------
	dump_list(l,str) => ()
end

	    
(** relation: check_root
 ** author: PA
 **
 ** Helper relation to strong_connect.
 ** 
 ** inputs:  (IncidenceMatrix, IncidenceMatrixT, int vector, int vector,
              int /* i */, int /* v */, int list /* stack */)
 ** outputs: (int /* i */, int list /* stack */, int list /* comps */)
 **)
relation check_root: (IncidenceMatrix,
		      IncidenceMatrixT,
		      int vector,
		      int vector,
		      int, 
		      int, 
		      int list) 
		     
	  => (int,
	      int list, 
	      int list) =

  rule	DAEEXT.get_lowlink(v) => lv &
	DAEEXT.get_number(v) => nv &
	int_eq(lv,nv) => true &
	check_stack(m,mt,a1,a2,i,v,stack,[])
	=> (i,stack',comps) 
	------------------------------------
	check_root(m,mt,a1,a2,i,v,stack)
	  => (i, stack',comps)

  axiom	check_root(m,mt,a1,a2,i,v,stack) 
	  => (i,stack,[])	
end


(** relation: check_stack
 ** author: PA
 **
 ** Helper relation to check_root.
 **
 ** inputs:  (IncidenceMatrix, IncidenceMatrixT, int vector, int vector,
              int /* i */, int /* v */, int list /* stack */, int list /* component list */)
 ** outputs: (int /* i */, int list /* stack */, int list /* comps */)
 **)
relation check_stack: (IncidenceMatrix,
		       IncidenceMatrixT,
		       int vector,
		       int vector,
		       int,
		       int,
		       int list, 
		       int list) 		     
	  => (int, int list, int list) =

  rule	DAEEXT.get_number(top) => topn &
	DAEEXT.get_number(v) => vn &
	int_ge(topn,vn) => true &
	check_stack(m,mt,a1,a2,i,v,rest,comp) 
	  => (i,stack',comp') 
	  -----------------------------
	check_stack(m,mt,a1,a2,i,v,top::rest,comp)
	  => (i,stack',top::comp')
	  
  axiom	check_stack(m,mt,a1,a2,i,v,stack,comp) 
	  => (i,stack,comp)
end


(** relation: dump_components
 ** author: PA
 **
 ** Prints the blocks of the BLT sorting on stdout.
 **)
relation dump_components: (Block list) => () =

  rule	print "Blocks\n" &
	print "=======\n" &
	dump_components2(l,1)
	---------------------
	dump_components (l) => ()
end


(** relation: dump_components2
 ** author: PA
 **
 ** Helper relation to dump_components.
 **)
relation dump_components2: (Block list,int) => () =

  axiom	dump_components2([],_) => ()
	
  rule	DAEEXT.get_lowlink(i) => ni &
	print "{" & 
	Util.list_map(l,int_string) => ls &
	Util.string_delimit_list(ls,", ") =>  s &
	print s & print "}\n" 
	& int_add(i,1) => i' &
	dump_components2(lst,i') 
	---------------------
	dump_components2(EQN_BLOCK(l)::lst,i) 

  rule	Exp.print_exp_str(cond) => s &
	DAEEXT.get_lowlink(i) => ni &
	print "if " & print s & print  " {" & 
	Util.list_map(l,int_string) => ls &
	Util.string_delimit_list(ls,", ") =>  s &
	print s & print "}\n" 
	& int_add(i,1) => i' &
	dump_components2(lst,i') 
	---------------------
	dump_components2(COND_EQN_BLOCK(l,cond,indx)::lst,i) 
end

(** relation: translate_dae
 ** author: PA
 **
 ** Translates the dae so variables are indexed into different arrays:
 ** - xd for derivatives
 ** - x for states
 ** - dummy_der for dummy derivatives
 ** - dummy for dummy states
 ** - y for algebraic variables 
 ** - p for parameters
 ** 
 **  The equations are updated with the new variable names.
 **)

relation translate_dae: DAELow => DAELow =
	
  rule   var_list(vars) => varlst &
	var_list(knvars) => knvarlst &
	calculate_indexes(varlst,knvarlst) => (varlst',knvarlst') &
	list_append(varlst',knvarlst') => totvars &
        equation_list(eqns) => eqnsl &
        equation_list(seqns) => seqnsl &
        equation_list(ieqns) => ieqnsl &
	variable_replacements(totvars,eqnsl) => (s,t) &
	
	translate_dae_replace(s,t,eqnsl,seqnsl,ieqnsl,ae,al,wc,zc,varlst',knvarlst',"%")
	  => (eqnsl',seqnsl',ieqnsl',ae',al',wc',zc',varlst'',knvarlst'') &
	  
	  (* remove dollar sign *)
        variable_replacements_no_dollar(varlst'',knvarlst'') => (s1,t1) &

	translate_dae_replace(s1,t1,eqnsl',seqnsl',ieqnsl',ae',al',wc',zc',varlst'',knvarlst'',"")
	  => (eqnsl'',seqnsl'',ieqnsl'',ae'',al'',wc'',zc'',varlst''',knvarlst''') &

          empty_vars() => vars' &
	empty_vars() => knvars' &
	add_vars(varlst''',vars') => vars'' &
	add_vars(knvarlst''',knvars') => knvars'' &
	list_equation(eqnsl'') => eqns'  &
	list_equation(seqnsl'') => seqns' &
	list_equation(ieqnsl'') => ieqns' &
	let trans_dae = DAELOW(vars'',knvars'',eqns',seqns',ieqns',ae'',al'',EVENT_INFO(wc'',zc''))
	& Debug.fcall("dumpindxdae",dump,trans_dae) 
	------------------------------------
	translate_dae(DAELOW(vars,knvars,eqns,seqns,ieqns,ae,al,EVENT_INFO(wc,zc)))
	  => trans_dae
end


(** relation: translate_dae_replace
 ** author: PA
 **
 ** Helper relation to translate_dae, replaces all expressions in various parts
 ** of the daelow,
 ** given a set of transformation rules.
 ** 
 ** inputs:  (Exp.Exp list, /* sources */
              Exp.Exp list, /* targets */
              Equation list, /* eqns */
              Equation list, /* reqns */
              Equation list, /* ieqns */
              MultiDimEquation array, /* arreqns */
              Algorithm.Algorithm array, /*algs */
              WhenClause list, /* wc */
              ZeroCrossing list, /* zc */
              Var list, /* vars */
              Var list, /* knvars */
              string) /* variable prefix, "$" or "" */
 ** outputs: (Equation list, /* eqns */
              Equation list, /* reqns */
              Equation list, /* ieqns */
              MultiDimEquation array, /* arreqns */
              Algorithm.Algorithm array, /*algs */
              WhenClause list,
              ZeroCrossing list,
              Var list,
              Var list)
 **)

relation translate_dae_replace: (Exp.Exp list, 
				 Exp.Exp list, 
				 Equation list,
				 Equation list,
				 Equation list, 
				 MultiDimEquation array, 
				 Algorithm.Algorithm array, 
				 WhenClause list, 
				 ZeroCrossing list, 
				 Var list, 
 				 Var list, 
				 string) 
	  => (Equation list, 
	      Equation list, 
	      Equation list, 
	      MultiDimEquation array, 
	      Algorithm.Algorithm array, 
	      WhenClause list,
	      ZeroCrossing list,
	      Var list,
	      Var list) =

  rule	 replace_variables(eqnsl,s,t) => eqnsl' &
	replace_variables(seqnsl,s,t) => seqnsl' &
	replace_variables(ieqnsl,s,t) => ieqnsl' &
        replace_variables_in_multidimarr(ae,s,t) => ae' &
	replace_variables_in_alg(al,s,t) => al' &
	replace_variables_in_when_clauses(wc,s,t) => wc' &
        replace_variables_in_zero_crossings(zc,s,t) => zc' &
        transform_variables(varlst,s,t,var_prefix) => varlst' &
        transform_variables(knvarlst,s,t,var_prefix) => knvarlst'  
	------------------------------
	translate_dae_replace(s,t,eqnsl,seqnsl,ieqnsl,ae,al,wc,zc,varlst,knvarlst,var_prefix)
	  => (eqnsl',seqnsl',ieqnsl',ae',al',wc',zc',varlst',knvarlst')
end


(** relation: replace_variables_in_when_clauses
 **
 ** Replace variables present in all the expressions in when clauses.
 **
 ** inputs:  (WhenClause list, 
              Exp.Exp list, /* source list */ 
              Exp.Exp list) /* target list */
 ** outputs: WhenClause list 
 **)
relation replace_variables_in_when_clauses: (WhenClause list, 
					     Exp.Exp list, 
					     Exp.Exp list) 
	  => WhenClause list =

  axiom	replace_variables_in_when_clauses([],_,_) => [] 

  rule	replace_variables_in_when_clause(wc,s,t) => wc' &
	replace_variables_in_when_clauses(wcx,s,t) => wcx'
	----------------------------------------
	replace_variables_in_when_clauses(wc::wcx,s,t) => (wc'::wcx')
end


(** relation: replace_variables_in_when_clause
 **
 ** Helper relation to replace_variables_in_when_clauses.
 **
 ** inputs:  (WhenClause, 
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs:  WhenClause =
 **)
relation replace_variables_in_when_clause: (WhenClause, 
					     Exp.Exp list,
					     Exp.Exp list)
	  => WhenClause =

  rule	Exp.replace_exp_list(e,s,t) => (e',_) & 
	Util.list_map_2(reinit, replace_variable_in_reinit, s, t) => reinit'
	----------------------------------------
	replace_variables_in_when_clause(WHEN_CLAUSE(e,reinit),s,t) 
	  => WHEN_CLAUSE(e',reinit')

end


(** relation: replace_variable_in_reinit
 ** Replaces varaiables in reinit statements.
 **
 ** inputs:  (ReinitStatement,
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs: (ReinitStatement)
 **)
relation replace_variable_in_reinit: (ReinitStatement,
				      Exp.Exp list, 
				      Exp.Exp list) 
	  => (ReinitStatement) =
	
  rule	Exp.replace_exp_list(e,s,t) => (e',_) &
	Exp.replace_exp_list(Exp.CREF(cr,Exp.OTHER),s,t) => (Exp.CREF(cr',_),_)
	----------------------------------------
	replace_variable_in_reinit(REINIT(cr,e),s,t) => REINIT(cr',e')

end


(** relation: replace_variables_in_zero_crossings
 ** Replaces variables in zero crossing releations
 **
 ** inputs:  (ZeroCrossing list, 
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs: ZeroCrossing list
 **)
relation replace_variables_in_zero_crossings: (ZeroCrossing list, 
					     Exp.Exp list, 
					     Exp.Exp list) 
	  => ZeroCrossing list =

  axiom	replace_variables_in_zero_crossings([],_,_) => [] 

  rule	replace_variables_in_zero_crossing(zc,s,t) => zc' &
	replace_variables_in_zero_crossings(zcx,s,t) => zcx'
	----------------------------------------
	replace_variables_in_zero_crossings(zc::zcx,s,t) => (zc'::zcx')
end


(** relation: replace_variables_in_zero_crossing
 ** Replaces variables in a zero crossing releation
 **
 ** inputs:  (ZeroCrossing, 
              Exp.Exp list, /* source list */ 
              Exp.Exp list) /* target list */
 ** outputs:  ZeroCrossing =
 **)
relation replace_variables_in_zero_crossing: (ZeroCrossing, 
					     Exp.Exp list, 
					     Exp.Exp list) 
	  => ZeroCrossing =

  rule	Exp.replace_exp_list(e,s,t) => (e',_) 
	----------------------------------------
	replace_variables_in_zero_crossing(ZERO_CROSSING(e,eql,wcl),s,t) 
	  => ZERO_CROSSING(e',eql,wcl)

end


(** relation: replace_variables_in_multidimarr
 ** author: PA
 **
 ** This relation repalces variables in multidimensional array equations.
 ** See also replace_variables.
 ** 
 ** inputs:  (MultiDimEquation array,
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs: MultiDimEquation array
 **)
 relation replace_variables_in_multidimarr:(MultiDimEquation array,
					    Exp.Exp list, 
					    Exp.Exp list) 
	  => MultiDimEquation array =

  rule	array_list(arr) => lst &
	replace_variables_in_multidimarr2(lst,s,t) => lst' &
	list_array(lst') => arr'
	 --------------------------------
	 replace_variables_in_multidimarr(arr,s,t) => arr' 
end


(** relation: replace_variables_in_multidimarr2
 ** author: PA
 **
 ** Helper relation to replace_variables_in_multidimarr
 **
 ** inputs:  (MultiDimEquation list,
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs:  MultiDimEquation list 
 **)
relation replace_variables_in_multidimarr2: (MultiDimEquation list,
					     Exp.Exp list,
					     Exp.Exp list)
	  => MultiDimEquation list =

  axiom	replace_variables_in_multidimarr2([],_,_) => []

  rule	Exp.replace_exp_list(e1,s,t) => (e1',_) &
	Exp.replace_exp_list(e2,s,t) => (e2',_) & 
	replace_variables_in_multidimarr2(es,s,t) => es' 
	-----------------------
	replace_variables_in_multidimarr2(MULTIDIM_EQUATION(ds,e1,e2)::es,s,t)
	  => MULTIDIM_EQUATION(ds,e1',e2')::es'
end     


(** relation: replace_variables_in_alg
 ** author: PA
 **
 ** This relation replaces variabless in algorithms.
 ** See also replace_variables.
 **
 ** inputs:  (Algorithm.Algorithm array, 
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs: (Algorithm.Algorithm array) 
 **)
relation replace_variables_in_alg:(Algorithm.Algorithm array, 
				   Exp.Exp list, 
				   Exp.Exp list) 
	 => (Algorithm.Algorithm array) =

  rule	array_list(algarr) => alglst &
	replace_variables_in_alg2(alglst,s,t) => alglst' &
	list_array(alglst') => algarr'
	-------------------
	replace_variables_in_alg(algarr,s,t) => algarr'

  rule	print "-replace_variables_in_alg failed\n" 
	--------------------------
	replace_variables_in_alg(_,_,_) => fail
end


(** relation: replace_variables_in_alg2
 ** author: PA
 **
 ** Helper relation to replace_variables_in_alg.
 **
 ** inputs:  (Algorithm.Algorithm list, 
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs:  Algorithm.Algorithm list 
 **)
relation replace_variables_in_alg2: (Algorithm.Algorithm list, 
				     Exp.Exp list,
				     Exp.Exp list)
	  => Algorithm.Algorithm list =

  axiom	replace_variables_in_alg2([],_,_) => []

  rule	replace_variables_in_alg2(algs,s,t) => algs' &
	replace_variables_in_stmts(stmts,s,t) => stmts'
	-----------------------------------------------
	replace_variables_in_alg2(Algorithm.ALGORITHM(stmts)::algs,s,t) 
	  => Algorithm.ALGORITHM(stmts')::algs'
end


(** relation: replace_variables_in_stmts
 ** author: PA
 **
 ** Helper relation to replace_variables_in_alg2
 ** Traverses a list of statements.
 ** inputs:  (Algorithm.Statement list, 
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */
 ** outputs:  Algorithm.Statement list 
 **)
relation replace_variables_in_stmts: (Algorithm.Statement list, 
				     Exp.Exp list,
				     Exp.Exp list)
	  => Algorithm.Statement list =

  axiom	replace_variables_in_stmts([],_,_) => []

  rule	replace_variables_in_stmt(stmt,s,t) => stmt' &
	replace_variables_in_stmts(stmts,s,t) => stmts' 
	-----------------------------------------------
	replace_variables_in_stmts(stmt::stmts,s,t) => stmt'::stmts'
end


(** relation: replace_variables_in_stmt
 ** author: PA
 **
 ** Helper relation to replace_variables_in_stmts
 ** Investigates a single statement.
 ** 
 ** inputs:  (Algorithm.Statement,
              Exp.Exp list, /* source list */
              Exp.Exp list) /* target list */				   
 ** outputs:  Algorithm.Statement 
 **)
relation replace_variables_in_stmt:(Algorithm.Statement,
				   Exp.Exp list, 
				   Exp.Exp list) 
	=> Algorithm.Statement =

  rule	Exp.replace_exp_list(e,s,t) => (e',_) &
	Exp.replace_exp_list(Exp.CREF(cr,Exp.OTHER),s,t) => (Exp.CREF(cr',_),_)
	-----------------
	replace_variables_in_stmt(Algorithm.ASSIGN(tp,cr,e),s,t) 
	  => Algorithm.ASSIGN(tp,cr',e')

  rule	Util.list_map_2_2(expl,Exp.replace_exp_list,s,t) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Exp.replace_exp_list(exp,s,t) => (exp',_)
	------------------------------------
	replace_variables_in_stmt(Algorithm.TUPLE_ASSIGN(tp,expl,exp),s,t)
	  => Algorithm.TUPLE_ASSIGN(tp,expl',exp')

  rule	Exp.replace_exp_list(e,s,t) => (e',_)
	---------------------------------
	replace_variables_in_stmt(Algorithm.ASSIGN_ARR(tp,cr,e),s,t)
	  => Algorithm.ASSIGN_ARR(tp,cr,e)

  rule	Exp.replace_exp_list(e,s,t) => (e',_) &
	replace_variables_in_stmts(stmts,s,t) => stmts' &
	replace_variables_in_else_branch(else_branch,s,t) => else_branch' 
	-----------------------------------------------------------------
	replace_variables_in_stmt(Algorithm.IF(e,stmts,else_branch),s,t)
	  => Algorithm.IF(e',stmts',else_branch')
  rule	
	Exp.replace_exp_list(e,s,t) => (e',_) &
	replace_variables_in_stmts(stmts,s,t) => stmts'
	-----------------------------------------------
	replace_variables_in_stmt(Algorithm.FOR(tp,b,id,e,stmts),s,t) 
	  => Algorithm.FOR(tp,b,id,e',stmts')

  rule	Exp.replace_exp_list(e,s,t) => (e',_) &
	replace_variables_in_stmts(stmts,s,t) => stmts' 
	-----------------------------------------------
	replace_variables_in_stmt(Algorithm.WHILE(e,stmts),s,t)
	  => Algorithm.WHILE(e,stmts)

  rule	Exp.replace_exp_list(e1,s,t) => (e1',_) &
	Exp.replace_exp_list(e2,s,t) => (e2',_)
	---------------------------------------
	replace_variables_in_stmt(Algorithm.ASSERT(e1,e2),s,t) 
	  => Algorithm.ASSERT(e1',e2')

  rule	print "Warning, fallthrough in replace_variables_in_stmts\n" 
	-----------------------------------
	replace_variables_in_stmt(a,_,_) => a 
end


(** relation: replace_variables_in_else_branch
 ** author: PA
 **
 ** Helper relation to replace_varibels_in_stmt
 ** Investigates the else branch of if statements.
 **
 ** inputs: (Algorithm.Else,
             Exp.Exp list, /* source list */
             Exp.Exp list) /* target list */
 ** outputs: Algorithm.Else 
 **)
relation replace_variables_in_else_branch: (Algorithm.Else,
				   Exp.Exp list, 
				   Exp.Exp list) 
                                         => Algorithm.Else =

  axiom	replace_variables_in_else_branch(Algorithm.NOELSE,_,_) 
	  => Algorithm.NOELSE
	
  rule	replace_variables_in_else_branch(else_branch,s,t) => else_branch' &
	Exp.replace_exp_list(e,s,t) => (e',_) &
	replace_variables_in_stmts(stmts,s,t) => stmts' 
	-------------
	replace_variables_in_else_branch(Algorithm.ELSEIF(e,stmts,else_branch),s,t)
	=> Algorithm.ELSEIF(e',stmts',else_branch')

  rule	replace_variables_in_stmts(stmts,s,t) => stmts'
	-----------------------------------------------
	replace_variables_in_else_branch(Algorithm.ELSE(stmts),s,t)
	  => Algorithm.ELSE(stmts') 
end
					    
			     
(** relation: add_vars
 ** author: PA
 **
 ** Adds a list of 'Var' to 'Variables'
 **)
relation add_vars: (Var list, Variables) => Variables =

  rule	Util.list_fold(varlst,add_var,vars) => vars'
	-------------------------
	add_vars(varlst,vars) => vars'
end


(** relation: analyze_jacobian
 ** author: PA
 ** 
 ** Analyze the jacobian to find out if the jacobian of system of equations 
 ** can be solved at compiletime or runtime or if it is a nonlinear system 
 ** of equations.
**)
relation analyze_jacobian:(DAELow, (int * int * Equation) list option) 
	  => JacobianType =

  rule	jacobian_constant(jac) => true &
	rhs_constant(daelow) => true
	-------------------------------
	analyze_jacobian(daelow,SOME(jac)) => JAC_CONSTANT

  rule	jacobian_nonlinear(daelow,jac) => true
	-----------------------
	analyze_jacobian(daelow,SOME(jac)) => JAC_NONLINEAR

  axiom	analyze_jacobian(daelow,SOME(jac)) => JAC_TIME_VARYING

  axiom	analyze_jacobian(daelow,NONE) => JAC_NO_ANALYTIC
      
end


(** relation: rhs_constant
 ** author: PA
 ** 
 ** Determines if the right hand sides of an equation system,
 ** represented as a DAELow, is constant. 
 **)
relation rhs_constant: (DAELow) => bool =

  rule	equation_list(eqns) => eqn_lst &
	rhs_constant2(eqn_lst,dae) => res
	----------------------
	rhs_constant(dae as DAELOW(vars,knvars,eqns,_,_,_,_,_)) => res
end


(** relation: get_eqnsys_rhs_exp
 ** author: PA
 ** 
 ** Retrieve the right hand side expression of an equation
 ** in an equation system, given a set of variables.
 ** 
 ** inputs:  (Exp.Exp, Variables /* variables of the eqn sys. */)
 ** outputs:  Exp.Exp =
 **)
relation get_eqnsys_rhs_exp: (Exp.Exp, Variables) => Exp.Exp =

rule  	Exp.terms(exp) => term_lst &
	Util.list_select_1(term_lst,vars,free_from_any_var) => rhs_lst &
	Exp.make_sum(rhs_lst) => new_exp &
	Exp.simplify(new_exp) => res
	----------------------------
	get_eqnsys_rhs_exp(exp,vars) => res

  rule	Debug.fprint("failtrace","-get_eqnsys_rhs_exp failed\n")
	-------------------
	get_eqnsys_rhs_exp(_,_) => fail
end


(** relation: rhs_constant2
 ** author: PA
 **
 ** Helper relation to rhs_constant, traverses equation list.
 **)
relation rhs_constant2: (Equation list, 
			 DAELow) 
	  => bool =

  axiom rhs_constant2([],_) => true

	(* check rhs for for EQUATION nodes. *)
  rule	Exp.typeof(e1) => tp &
	let new_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	get_eqnsys_rhs_exp(new_exp,vars) => rhs_exp &
	Exp.is_const(rhs_exp) => true &
	rhs_constant2(rest,dae) => res 
	----------------------
	rhs_constant2(EQUATION(e1,e2)::rest,
		      dae as DAELOW(vars,_,_,_, _,_,_,_)) => res

	(* check rhs for for ARRAY_EQUATION nodes. *)
  rule	int_sub(indx,1) => indx' & 
	array_nth(arreqn,indx) => MULTIDIM_EQUATION(ds,e1,e2) &
	Exp.typeof(e1) => tp &
	(* NOTE: illegal to use SUB for arrays, but we only need to 
	 * check if constant or not, expr not saved..*)
	let new_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	get_eqnsys_rhs_exp(new_exp,vars) => rhs_exp &
	Exp.is_const(rhs_exp) => true &
	rhs_constant2(rest,dae) => res 
	----------------------
	rhs_constant2(ARRAY_EQUATION(indx,expl)::rest,
		      dae as DAELOW(vars,_,_,_,_,arreqn,_,_))
	  => res

	(* check rhs for for RESIDUAL_EQUATION nodes. *)
  rule	get_eqnsys_rhs_exp(e,vars) => rhs_exp &
	Exp.is_const(rhs_exp) => true &
	rhs_constant2(rest,dae) => res
	----------------------
	rhs_constant2(RESIDUAL_EQUATION(e)::rest,
		      dae as DAELOW(vars,_,_,_,_,_,_,_)) 
	  => res

  axiom	rhs_constant2(_,_) => false
end


(** relation: free_from_any_var
 ** author: PA
 **
 ** Helper relation to rhs_constant2
 ** returns true if expression does not contain any of the variables
 ** passed as argument.
 **)
relation free_from_any_var: (Exp.Exp, Variables) => bool =

  rule	(* Special case for expressions with no variables*)
	Exp.get_cref_from_exp(e) => []
	------------------------------
	free_from_any_var(e,_) => true 

  rule	Exp.get_cref_from_exp(e) => crefs  &
	Util.list_map_1(crefs,exists_var,vars) => b_lst &
	Util.bool_or_list(b_lst) => res &
	bool_not(res) => res' 
	-----------------------
	free_from_any_var(e,vars) => res'

  axiom	free_from_any_var(_,_) => true

end


(** relation: jacobian_type_str
 ** author: PA
 ** 
 ** Returns the jacobian type as a string, used for debugging.
 **)
relation jacobian_type_str: JacobianType => string = 

  axiom	jacobian_type_str JAC_CONSTANT => "Jacobian Constant"

  axiom	jacobian_type_str JAC_TIME_VARYING => "Jacobian Time varying"

  axiom	jacobian_type_str JAC_NONLINEAR => "Jacobian Nonlinear"
end


(** relation: jacobian_constant
 ** author: PA
 **
 ** Checks if jacobian is constant, i.e. all expressions in each equation are constant.
 **)
relation jacobian_constant:((int * int * Equation) list) => bool =

  axiom	jacobian_constant ([]) => true

	(* TODO: Algorithms and ArrayEquations *)

  rule	Exp.is_const(e1) => true &
	Exp.is_const(e2) => true &
	jacobian_constant(eqns) => true 
	------------------------------
	jacobian_constant((_,_,EQUATION(e1,e2))::eqns) => true

  rule	Exp.is_const(e) => true &
	jacobian_constant(eqns) => true
	--------------------------
	jacobian_constant((_,_,RESIDUAL_EQUATION(e))::eqns) => true
	
  rule	Exp.is_const(e) => true &
	jacobian_constant(eqns) => true
	--------------------------
	jacobian_constant((_,_,SOLVED_EQUATION(_,e))::eqns) => true

  axiom	jacobian_constant(_) => false

end


(** relation: jacobian_nonlinear
 ** author: PA
 ** 
 ** Check if jacobian indicates a nonlinear system.
 ** TODO: Algorithms and Array equations
 **)
relation jacobian_nonlinear:(DAELow,(int*int*Equation) list) => bool =


  rule	jacobian_nonlinear_exp(daelow,e1) => false &
	jacobian_nonlinear_exp(daelow,e2) => false &
	jacobian_nonlinear(daelow,xs) => false
	---------------------------------------
	jacobian_nonlinear(daelow,(_,_,EQUATION(e1,e2))::xs) => false


  rule	jacobian_nonlinear_exp(daelow,e) => false &
	jacobian_nonlinear(daelow,xs) => false
	---------------------------------------
	jacobian_nonlinear(daelow,(_,_,RESIDUAL_EQUATION(e))::xs) => false

  axiom	jacobian_nonlinear(_,[]) => false

  axiom	jacobian_nonlinear(_,_) => true
end


(** relation: jacobian_nonlinear_exp
 ** author: PA
 ** 
 ** Checks wheter the jacobian indicates a nonlinear system.
 ** This is true if the jacobian contains any of the variables that is solved
 ** for.
 **)
relation jacobian_nonlinear_exp: (DAELow, Exp.Exp) => bool =
	
  rule	Exp.get_cref_from_exp(e) => crefs &
	contain_any_var(crefs,vars) => res
	---------------------------------
	jacobian_nonlinear_exp(DAELOW(vars,_,_,_,_,_,_,_),e) => res
end


(** relation: contain_any_var
 ** author: PA
 **
 ** Returns true if any of the variables given as ComponentRef list is among 
 ** the Variables.
 **)
relation contain_any_var:(Exp.ComponentRef list, Variables) => bool =

  axiom	contain_any_var([],_) => false

  rule	get_var(cr,vars) => (_,_) 
	----------------------------
	contain_any_var(cr::crefs,vars) => true

  rule	contain_any_var(crefs,vars) => res
	------------------------
	contain_any_var(_::crefs,vars) => res
end


(** relation: calculate_jacobian
 ** This relation takes an array of equations and the variables of the equation
 ** and calculates the jacobian of the equations.
 **)
relation calculate_jacobian: (Variables, 
			      EquationArray, 
			      MultiDimEquation array,
			      IncidenceMatrix,
			      IncidenceMatrixT) 
	  => ((int * int * Equation) list option) =

  rule	equation_list(eqns) => eqn_lst &
	Util.list_map(eqn_lst,equation_to_residual_form) => eqn_lst' &
	calculate_jacobian_rows(eqn_lst',vars,ae,m,mt) => SOME(jac) &
	list_reverse(jac) => jac' 
	-----------------------------
	calculate_jacobian(vars, eqns,ae,m,mt) => SOME(jac')

	(* no analythic jacobian available*)
  axiom	calculate_jacobian(_,_,_,_,_) => NONE
end


(** relation: calculate_jacobian_rows
 ** author: PA
 **
 ** This relation takes a list of Equations and a set of variables and 
 ** calculates the jacobian expression for each variable over each equations,
 ** returned in a sparse matrix representation. 
 ** For example, the equation on index e1: 3*a*x+5*y*z+ z*z  given the 
 ** variables {x,y,z} on index x1,y1,z1 gives
 ** {(e1,x1,3*a), (e1,y1,5*z), (e1,z1,5*y+2*z)}
 **)
relation calculate_jacobian_rows:(Equation list, Variables, 
				  MultiDimEquation array,
				 IncidenceMatrix, IncidenceMatrixT) 
	  => ((int * int * Equation) list option) =

  rule	calculate_jacobian_rows2(eqns,vars,ae,m,mt,1) => res
	--------------------------
	calculate_jacobian_rows(eqns,vars,ae,m,mt) => res 
end


(** relation: calculate_jacobian_rows2
 ** author: PA
 **
 ** Helper relation to calculate_jacobian_rows
 **)
relation calculate_jacobian_rows2:(Equation list, Variables, 
				   MultiDimEquation array,
				 IncidenceMatrix, IncidenceMatrixT, int)
	  => ((int * int * Equation) list option) =
  axiom	calculate_jacobian_rows2([],_,_,_,_,_) => SOME([])

  rule	eqn_indx + 1 => eqn_indx' &
	calculate_jacobian_rows2(eqns,vars,ae,m,mt,eqn_indx') => SOME(l1) &
	calculate_jacobian_row(eqn,vars,ae,m,mt,eqn_indx) => SOME(l2) &
	list_append(l1,l2) => res
	-------------------------
	calculate_jacobian_rows2(eqn::eqns,vars,ae,m,mt,eqn_indx) => SOME(res)
end


(** relation: calculate_jacobian_row
 ** author: PA
 **
 ** Calculates the jacobian for one equation. See calculate_jacobian_rows.
 **
 ** inputs:  (Equation, 
              Variables,
              MultiDimEquation array,
              IncidenceMatrix,
              IncidenceMatrixT,
              int /* eqn index */) 
 ** outputs: ((int * int * Equation) list option)
 **)
relation calculate_jacobian_row: (Equation, 
				  Variables,
				  MultiDimEquation array,
				  IncidenceMatrix,
				  IncidenceMatrixT,
				  int) 
	  => ((int * int * Equation) list option) =


  rule	(* residual equations *)
	vars_in_eqn(m,eqn_indx) => var_indxs &
	(* Remove duplicates and get in correct order: acsending index *)
	Util.list_union_p(var_indxs,[],int_eq) => var_indxs' &
	list_reverse(var_indxs') => var_indxs'' &
	calculate_jacobian_row2(e,vars,eqn_indx,var_indxs'') => SOME(eqns)
	----------------------------------------------
	calculate_jacobian_row(RESIDUAL_EQUATION(e),vars,ae,m,mt,eqn_indx) 
	  => SOME(eqns)

	(* algorithms give no jacobian *)
  axiom	calculate_jacobian_row(ALGORITHM(indx,in,out),vars,ae,m,mt,eqn_indx) 
	  => NONE

	(* array equations *)
  rule	array_nth(ae,indx) => MULTIDIM_EQUATION(ds,e1,e2) & 
	let new_exp = Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2) &
	vars_in_eqn(m,eqn_indx) => var_indxs &
	(* Remove duplicates and get in correct order: acsending index *)
	Util.list_union_p(var_indxs,[],int_eq) => var_indxs' &
	list_reverse(var_indxs') => var_indxs'' &
	calculate_jacobian_row2(new_exp,vars,eqn_indx,var_indxs'') => SOME(eqns)
	----------------------------------------------
	calculate_jacobian_row(ARRAY_EQUATION(indx,expl),vars,ae,m,mt,eqn_indx) => SOME(eqns)


  rule	print "calculate_jacobian_row failed\n" 
	--------------------------------------
	calculate_jacobian_row(_,_,_,_,_,_) => fail
end


(** relation: make_residual_eqn
 ** author: PA
 **
 ** Transforms an expression into a residual equation
 **)
relation make_residual_eqn: Exp.Exp => Equation =

axiom make_residual_eqn(e) => RESIDUAL_EQUATION(e)
end


(** relation: calculate_jacobian_row2
 ** author: PA
 **
 ** Helper relation to calculate_jacobian_row
 ** Differentiates expression for each variable cref.
 **
 ** inputs: (Exp.Exp, 
             Variables,
             int, /* equation index */
             int list) /* var indexes */
 ** outputs: ((int* int* Equation) list option)
 **)
relation calculate_jacobian_row2: (Exp.Exp, 
				   Variables,
				   int, 
				   int list) 
	  => ((int* int* Equation) list option) =

  axiom	calculate_jacobian_row2(e,_,_,[]) => SOME([])

  rule	get_var_at(vars,vindx) => v &
	var_cref(v) => cr &
	Derive.differentiate_exp(e,cr) => e' &
	Exp.simplify(e') => e'' &
	calculate_jacobian_row2(e,vars,eqn_indx,vindxs) => SOME(es)
	-----------------------------------
	calculate_jacobian_row2(e,vars,eqn_indx,vindx::vindxs) 
	  => (SOME((eqn_indx,vindx,RESIDUAL_EQUATION(e''))::es))
end


(** relation: residual_exp
 ** author: PA
 **
 ** This relation extracts the residual expression from a residual equation
 **)
relation residual_exp: (Equation) => Exp.Exp =

  axiom	residual_exp(RESIDUAL_EQUATION(e)) => e

end


(** relation: to_residual_form
 ** author: PA
 **
 ** This relation transforms a daelow to residualform on the equations.
 **)
relation to_residual_form: (DAELow) => DAELow =

  rule	equation_list(eqns) => eqn_lst &
	Util.list_map(eqn_lst,equation_to_residual_form) => eqn_lst2 &
	list_equation(eqn_lst2) => eqns2
	------------------------
	to_residual_form(DAELOW(vars,knvars,eqns,seqns,ieqns,ae,ialg,wc))
	  => DAELOW(vars,knvars,eqns2,seqns,ieqns,ae,ialg,wc)
end


(** relation: equation_to_residual_form
 ** author: PA
 **
 ** This relation transforms an equation to its residual form.
 ** For instance, a=b is transformed to a-b=0 
 **)
relation equation_to_residual_form:(Equation) => Equation =

  rule	Exp.simplify(Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2))=> e
	-----------------------------------------
	equation_to_residual_form(EQUATION(e1,e2)) => RESIDUAL_EQUATION(e)

  rule	Exp.simplify(Exp.BINARY(Exp.CREF(cr,Exp.REAL),Exp.SUB(Exp.REAL),exp)) => e
	--------------------------------------------------------------------------
	equation_to_residual_form(SOLVED_EQUATION(cr,exp)) => RESIDUAL_EQUATION(e)

  axiom	equation_to_residual_form(e as RESIDUAL_EQUATION(_)) => e
  axiom	equation_to_residual_form(e as ALGORITHM(_,_,_)) => e
  axiom	equation_to_residual_form(e as ARRAY_EQUATION(_,_)) => e

  rule	print "equation_to_residual_form failed\n" 
	--------------------------
	equation_to_residual_form(_) => fail
end


(** relation: calculate_sizes
 ** author: PA
 **
 ** Calculates the number of state variables, nx,
 ** the number of algebraic variables, ny
 ** and the number of parameters/constants, np.
 ** 
 ** inputs:  DAELow 
 ** outputs: (int, /* nx */
              int, /* ny */
              int, /* np */ 
              int) /* ng */
 **)
relation calculate_sizes: DAELow => (int, 
                                     int,
                                     int,
                                     int) =
  rule	(* input variables are put in the known var list, 
	 ** but they should be counted by the ny counter. *)
	var_list(vars) => varlst &
	var_list(knvars) => knvarlst &
	calculate_param_sizes(knvarlst) => np &
        int_string(np) => np_str &
	list_length zc => ng &
	calculate_var_sizes(varlst,0,0) => (nx,ny) &
	calculate_var_sizes(knvarlst,nx,ny) => (nx',ny')
	-----------------------------------
	calculate_sizes(DAELOW(vars,knvars,_,_,_,_,_,EVENT_INFO(wc,zc))) => 
        (nx',ny',np,ng)
end


(** relation: calculate_param_sizes
 ** author: PA
 **
 ** Helper relation to calculate_sizes
 **)
relation calculate_param_sizes:( Var list) => (int) =

  axiom	calculate_param_sizes([]) => 0

  rule  calculate_param_sizes(vs) => s1 &
        is_param(var) => true &
	int_add(s1,1) => s2 
	------------------
	calculate_param_sizes(var::vs) 
	  => (s2)

  rule	calculate_param_sizes(vs) => s1 
	------------------
	calculate_param_sizes(_::vs) 
	  => (s1)
end


(** relation: calculate_var_sizes
 ** author: PA
 **
 ** Helper relation to calculate_sizes
 **)
relation calculate_var_sizes:( Var list, int, int) => (int, int) =

  axiom	calculate_var_sizes([],nx,ny) => (nx,ny)

  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,VARIABLE,_,_,_, _,_,_,_,_,_,_,_,flow)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,DISCRETE,_,_,_, _,_,_,_,_,_,_,_,flow)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	int_add(nx,1) => nx' &
	calculate_var_sizes(vs,nx',ny) => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,STATE,_,_,_ ,_,_,_,_,_,_,_,_,flow)::vs,nx,ny) 
	  => (nx'',ny'')

	  (* A dummy state is an algebraic variable *)
  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,DUMMY_STATE,_,_,_ ,_,_,_,_,_,_,_,_,flow)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,DUMMY_DER,_,_,_, _,_,_,_,_,_,_,_,flow)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	calculate_var_sizes(vs,nx,ny) => (nx',ny')
	----------------------------
	calculate_var_sizes(_::vs,nx,ny) 
	  => (nx',ny')

  rule	print "-calculate_var_sizes failed\n" 
	----------------------------
	calculate_var_sizes(_,_,_) 
	  => fail
end


(** relation: replace_variables
 ** author: PA
 **
 ** Transforms the equations (incl. algorithms and array eqns), 
 ** given two lists with source and target expressions
 **
 ** inputs:  (Equation list, /* equations   */
              Exp.Exp list,  /* source list */
              Exp.Exp list)  /* target list */
 ** outputs: Equation list =
 **) 
relation replace_variables: (Equation list,
			     Exp.Exp list, 
			     Exp.Exp list) 
	  => Equation list =
	
  axiom	replace_variables ([],_,_) => []
	
  rule	Exp.replace_exp_list(e1,s,t) => (e1',_) &
	Exp.replace_exp_list(e2,s,t) => (e2',_) &
	replace_variables(es,s,t) => es'
	---------------------------------------
	replace_variables(EQUATION(e1,e2)::es,s,t) 
	  => EQUATION(e1',e2')::es'


  rule	Exp.replace_exp_list(Exp.CREF(cr,Exp.OTHER),s,t) 
	  => (Exp.CREF(cr',_),_) &
	Exp.replace_exp_list(e1,s,t) => (e1',_) &
	replace_variables(es,s,t) => es'
	---------------------------------------
	replace_variables(SOLVED_EQUATION(cr,e1)::es,s,t) 
	  => SOLVED_EQUATION(cr',e1')::es'

  rule	let e1 = Exp.CREF(cr,Exp.OTHER) &
	Exp.replace_exp_list(e1,s,t) => (e1' as Exp.CREF(cr',_),_) &
	Exp.replace_exp_list(e2,s,t) => (e2',_) &
	replace_variables(es,s,t) => es'
	---------------------------------------
	replace_variables(WHEN_EQUATION(WHEN_EQ(i,cr,e2))::es,s,t) 
	  => WHEN_EQUATION(WHEN_EQ(i,cr',e2'))::es'

	  (* algorithms are replaced separately in translate_dae_replace *)
  rule	replace_variables(es,s,t) => es'
 	---------------------------------------
 	replace_variables(ALGORITHM(indx,inputs,outputs)::es,s,t) 
 	  => ALGORITHM(indx,inputs,outputs)::es'

	  (* array eqns are replaced separatedly in translate_dae_replace*)
  rule	replace_variables(es,s,t) => es'
 	---------------------------------------
 	replace_variables(ARRAY_EQUATION(indx,expl)::es,s,t) 
 	  => ARRAY_EQUATION(indx,expl)::es'


  rule	print "-replace_variables failed\n" 
	------------------
	replace_variables(_,_,_) => fail
end


(** relation: calculate_values
 ** author: PA
 **
 ** This relation calculates the values from the parameter binding expressions.
 ** This is performed by building an environment and adding all the parameters
 ** and constants to it and then calling ceval to retreive the constant values
 ** of each parameter or constant.
 ** NOTE: This depends on the DAELow having the indexed forms of component
 ** references, since the environment requires simple names for each variable.
 **
**)
relation calculate_values: (DAELow) => DAELow =
	
  rule	Builtin.initial_env => env &
	var_list(knvars) => knvarlst &
	add_variables_to_env(knvarlst,env) => env' &
	update_variables(knvarlst,env') => knvarlst' &
	empty_vars() => knvars &
	add_vars(knvarlst',knvars) => knvars'
	--------------------------------------
	calculate_values(DAELOW(vars,knvars,eqns,seqns,ie,ae,al,wc)) 
	  => DAELOW(vars,knvars',eqns,seqns,ie,ae,al,wc)
end


(** relation: add_variables_to_env
 ** author: PA
 **
 ** Helper relation to calculate_values
 **)
relation add_variables_to_env: (Var list, Env.Env) => Env.Env =
	
  axiom	add_variables_to_env([],env) => env
	
  rule	(* Some of the attributes added to env here does not matter, defaults are used *)
	DAE.generate_dae_type(t) => t' &
	Env.extend_frame_v(env,Types.VAR(crn,Types.ATTR(false,SCode.RW,SCode.CONST,Absyn.BIDIR),
                                         false,t',Types.EQBOUND(e,NONE,Types.C_CONST)),
			   NONE,false,[]) 
	  => env' &
	add_variables_to_env(rest,env') => env'' 
	------------------
	add_variables_to_env(VAR(Exp.CREF_IDENT(crn,_),a,b,t,SOME(e),_,d,f,g,h,i,dae_var_attr,comment,flow)::rest,env) => env''
	
  rule	(* Some of the attributes added to env here does not matter, defaults are used *)
	DAE.generate_dae_type(t) => t' &
	Env.extend_frame_v(env,Types.VAR(crn,Types.ATTR(false,SCode.RW,SCode.CONST,Absyn.BIDIR),false,t',Types.UNBOUND),
			   NONE,false,[])
	  => env' &
	add_variables_to_env(rest,env') => env'' 
	-------------------------------------------
	add_variables_to_env(VAR(Exp.CREF_IDENT(crn,_),a,b,t,NONE,_,d,f,g,h,i,dae_var_attr,comment,flow)::rest,env) => env''

  rule	Print.print_buf "Warning, skipping a variable qualified:" &
	Exp.print_component_ref cr &
	add_variables_to_env(rest,env) => env'
	------------------
	add_variables_to_env(VAR(cr as Exp.CREF_QUAL(_,_,_),_,_,_,_,_,_,_,_,_,_,_,_,flow)::rest,env) => env'

  rule	Print.print_buf "Warning, skipping a variable :" &
	add_variables_to_env(rest,env) => env'
	------------------
	add_variables_to_env(_::rest,env) => env'

end


(** relation: update_variables
 ** author: PA
 **
 ** Helper relation to calculate_values
 **)
relation update_variables:(Var list, Env.Env) => Var list =

  axiom	update_variables([],_) => []

  rule	update_variables(rest,env) => rest' &
	Ceval.ceval(env,e,false,NONE,NONE,Ceval.MSG) => (v,_)
	-----------------------------------
	update_variables(VAR(cr,a,b,c,SOME(e),_,d,f,g,h,i,dae_var_attr,comment,flow)::rest,env)
	  => (VAR(cr,a,b,c,SOME(e),SOME(v),d,f,g,h,i,dae_var_attr,comment,flow)::rest')

  rule	update_variables(rest,env) => rest' &
	not Ceval.ceval(env,e,false,NONE,NONE,Ceval.NO_MSG) => (_,_) &
	Print.print_buf "Warning, ceval failed for parameter: " &
	Exp.print_component_ref cr & Print.print_buf "\n" 
	-----------------------------------
	update_variables(VAR(cr,a,b,c,SOME(e),v,d,f,g,h,i,dae_var_attr,comment,flow)::rest,env)
	  => (VAR(cr,a,b,c,SOME(e),v,d,f,g,h,i,dae_var_attr,comment,flow)::rest')

  rule	update_variables(rest,env) => rest'
	-----------------------------------
	update_variables(VAR(cr,a,b,c,NONE,v,d,f,g,h,i,dae_var_attr,comment,flow)::rest,env)
	  => (VAR(cr,a,b,c,NONE,v,d,f,g,h,i,dae_var_attr,comment,flow)::rest')
end


(** relation: variable_replacements
 ** author: PA
 **
 ** Returns a two list of replacement expressions for variable transformations.
 ** For instance, replacing state s with %x[3] and der(s) with %xd[3],
 ** NOTE: The derivative expressions must be first, so they are replaced first
 ** i.e der(s) is replaced before s is replaced which gives a wrong 
 ** variable like der(%x[5])
 **)
 relation variable_replacements: (Var list, Equation list) 
	  => (Exp.Exp list, Exp.Exp list) =
	   
  rule	states_eqns(eqns,empty_bintree) => bt  &
	 bintree_to_list(bt) => (states,_) &
         derivative_replacements(states,vars) => (s1,t1) &
	 alg_variable_replacements(vars) => (s2,t2) &
         list_append(s1,s2) => s &
	 list_append(t1,t2) => t
	 ---------------------
	 variable_replacements(vars,eqns) =>  (s,t)
	 
  rule	print "-variable_replacements failed\n" 
	 ---------------------------------------
	 variable_replacements(vars,eqns) =>  fail
end


(** relation: variable_replacements_no_dollar
 ** author: PA
 **
 ** When all variables have been replaced to a indexed variable starting
 ** with a dollar sig, '%', it can again be translated to remove the sign.
 ** This relation builds replacement rules for removing the sign.
 **)
relation variable_replacements_no_dollar: (Var list, Var list) 
	  => (Exp.Exp list, Exp.Exp list) =
	  
  rule	variable_replacements_remove_dollar(vars) => (s1,t1) &
	variable_replacements_remove_dollar(knvars) => (s2,t2) &
	list_append(s1,s2) => s &
	list_append(t1,t2) => t
	---------------------
	variable_replacements_no_dollar(vars,knvars) =>  (s,t)
	
  rule	print "-variable_replacements_no_dollar failed\n" 
	---------------------------------------
	variable_replacements_no_dollar(vars,knvars) =>  fail
end


(** relation: variable_replacements_remove_dollar
 ** author: PA
 **
 ** Removes the prefixed dollar sign on each variable, returning a list 
 ** of replacements rules.
 **)
relation variable_replacements_remove_dollar: Var list 
	  => (Exp.Exp list, Exp.Exp list) = 

  axiom variable_replacements_remove_dollar([]) => ([],[])

	(* Special case for states, add %xd[indx] too .*)
  rule	variable_replacements_remove_dollar(vs) => (s,t) &
(*         print str & print "<++++++++++++\n" &  *)
	string_list(str) => #"%"::(* #"x":: *)rest & 
 	list_string(rest) => name & 
(*         print name & print "<++++++++++++\n" &  *)
(* 	string_append("x",str') => str'' & *)
 	string_append(derivative_name_prefix,name) => xd_t & 
 	string_append("%derivative",name) => xd_s  
	-------------------------------
	variable_replacements_remove_dollar(VAR(cr as Exp.CREF_IDENT(str,[]),STATE,_,_,_,_,_,_,_,_,_,_,_,_)::vs) 
 	  => (Exp.CREF(cr,Exp.REAL)::Exp.CREF(Exp.CREF_IDENT(xd_s,[]),Exp.REAL)::s, 
	      Exp.CREF(Exp.CREF_IDENT(name,[]),Exp.REAL)::Exp.CREF(Exp.CREF_IDENT(xd_t,[]),Exp.REAL)::t)

  rule	variable_replacements_remove_dollar(vs) => (s,t) &
	string_list(str) => #"%"::rest & (* first character dollar sign. *)
	list_string(rest) => str' 
	-------------------------------
	variable_replacements_remove_dollar(VAR(cr as Exp.CREF_IDENT(str,[]),_,_,_,_,_,_,_,_,_,_,_,_,_)::vs) 
	  => (Exp.CREF(cr,Exp.REAL)::s, Exp.CREF(Exp.CREF_IDENT(str',[]),Exp.REAL)::t)

  rule	not string_list(str) => #"%"::_  &
	print "Error, variable not prefixed with dollar sign.\n"
	-------------------------------
	variable_replacements_remove_dollar(VAR(cr as Exp.CREF_IDENT(str,[]),_,_,_,_,_,_,_,_,_,_,_,_,_)::vs) 
	  => fail
  rule	print "-variable_replacements_remove_dollar failed\n" 
	----------------------------
	variable_replacements_remove_dollar(_) => fail
end


(** relation: alg_variable_replacements
 ** author: PA
 **
 ** Build replacement "rules" for the variables, eg. states, 
 ** algebraic variables, parameters, etc.
 ** Note: the new variable must be an identifier not valid in Modelica, 
 ** otherwise name collisions may occur.
 **)
relation alg_variable_replacements: (Var list) => (Exp.Exp list, Exp.Exp list) =

  axiom	alg_variable_replacements([]) => ([],[])

	(* algebraic variables, '%y[index]' *)
  rule	(* print "DAELow.rml 6697  " & *) alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
        (* 	Util.string_append_list(["%y[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,VARIABLE,_,_,_ ,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* state variables, '%x[index]' *)
  rule	(* print "DAELow.rml 6708  " & *)alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
        (* 	Util.string_append_list(["%x[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,STATE,_,_,_, _,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* dummy derivatives => alg. vars *)
  rule	(* print "DAELow.rml 6719  " & *) alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
        (* 	Util.string_append_list(["%y[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,DUMMY_DER,_,_, _,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* dummy states => alg. vars *)
  rule	(* print "DAELow.rml 6730  " & *) alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
        (* 	Util.string_append_list(["%y[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,DUMMY_STATE,_,_, _,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* discrete variables, => alg. vars *)
  rule	(* print "DAELow.rml 6741  " & *)alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
(* 	Util.string_append_list(["%y[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,DISCRETE,_,_, _,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* parameters *)
  rule	(* print "DAELow.rml 6752  " & *) alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
(* 	Util.string_append_list(["%p[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,PARAM,_,_, _,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* structural parameters *)
  rule	(* print "DAELow.rml 6763  " & *) alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
(* 	Util.string_append_list(["%p[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,STRUCTPARAM,_,_, _,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

	  (* constants, should not occur... *)
  rule	(* print "DAELow.rml 6774  " &  *)alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list(["%$",c_name]) => newid
(* 	Util.string_append_list(["%p[",indxs,"]"]) => newid *)
	--------------------
	alg_variable_replacements(VAR(cr,CONST,_,_, _,_,_,_,indx,_,_,dae_var_attr,comment,flow)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	print "-alg_variable_replacements failed\n" 
	-------------------------------------------
	alg_variable_replacements(_) => fail
end


(** relation: states_eqns
 ** author: PA
 **
 ** Takes a list of equations and an (empty) BinTree and 
 ** fills the tree with the state variables present in the equations
 **)
 relation states_eqns: (Equation list,BinTree) => BinTree =
	 
  axiom	states_eqns([],bt) => bt
         
  rule	states_eqns(es,bt) => bt &
	 states_exp(e1,bt) => bt &
	 states_exp(e2,bt) => bt 
	 -----------------------
	 states_eqns(EQUATION(e1,e2)::es,bt) => bt

  rule	states_eqns(es,bt) => bt &
	 Util.list_fold(expl,states_exp,bt) => bt 
	 -----------------------
	 states_eqns(ARRAY_EQUATION(ds,expl)::es,bt) => bt

  rule	Util.list_fold(expl1,states_exp,bt) => bt &
	 Util.list_fold(expl2,states_exp,bt) => bt &
	 states_eqns(es,bt) => bt 
	 ------------------------
	 states_eqns(ALGORITHM(indx,expl1,expl2)::es,bt) => bt

  rule	states_eqns(es,bt) => bt 
	 -----------------------
	 states_eqns(WHEN_EQUATION(_)::es,bt) => bt
         
  rule	print "-states_eqns failed\n" 
	 -----------------
	 states_eqns(_,_) => fail
 end


(** relation: derivative_replacements
 ** author: PA
 **
 ** Helper relation for variable_replacements 
 **)
 relation derivative_replacements: (Exp.ComponentRef list, Var list) 
	  => (Exp.Exp list, Exp.Exp list) =

  axiom	derivative_replacements([],_) => ([],[])
	 
  rule	derivative_replacements(ss,vars)  => (s1,t1) &
	 get_index(s,vars) => indx &
	 int_string(indx) => indxs &
         Exp.print_component_ref_str(s) => name &
         Util.modelica_string_to_c_str(name) => c_name &
         Util.string_append_list([derivative_name_prefix,"$",c_name]) => newid
         (* 	Util.string_append_list(["%xd[",indxs,"]"]) => newid *)
	 ------------------------------------------
	 derivative_replacements(s::ss,vars) 
	  => (Exp.CALL(Absyn.IDENT("der"),
		       [Exp.CREF(s,Exp.REAL)],
		       false,
		       true
		       )::s1,
	      Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	print "-derivative_replacements failed\n" 
	 ----------------------
	 derivative_replacements(_,_) => fail
 end


(** relation: get_index
 ** author: PA
 **
 ** Helper relation to derivative_replacements 
 **)
 relation get_index: (Exp.ComponentRef, Var list) => int =

  rule	Exp.cref_equal(cr1,cr2) => true
	 -------------------------------
	 get_index(cr1,VAR(cr2,_,_,_,_, _,_,_,indx,_,_,dae_var_attr,comment,flow)::_) => indx

  rule	get_index(cr1,vs) => indx
	 -------------------------
	 get_index(cr1,_::vs) => indx
 end


(** relation: calculate_indexes
 ** author: PA
 **
 ** Helper relation to translate_dae. Calculates the indexes for each variable
 ** in one of the arrays. x, xd, y.
 **)
 relation calculate_indexes: (Var list,
			      Var list) 
	  => (Var list,
	      Var list) =
  rule	calculate_indexes2(vars,0,0,0,0,0) => (vars',x,xd,y,p,dummy) &
	 calculate_indexes2(knvars,x,xd,y,p,dummy) => (knvars',_,_,_,_,_)		     
	 ----------------------------------------
	 calculate_indexes(vars,knvars) => (vars',knvars')
	 
  rule	print "-calculate_indexes failed\n" 
	 ------------------------
	 calculate_indexes(_,_) => fail
 end


(** relation: transform_variables
 ** author: PA
 **
 ** Helper relation to translate_dae
 **
 ** 
 ** inputs:  (Var list, 
              Exp.Exp list, 
              Exp.Exp list,
              string /* varible prefix, "$" or "" */)
 ** outputs: (Var list) 
 **)
 relation transform_variables: (Var list, 
			        Exp.Exp list, 
			        Exp.Exp list,
			        string (* varible prefix, "%" or "" *)
			        ) => (Var list) =


  axiom transform_variables([],_,_,_) => []

	 (* When dollar sign, save original name *)
  rule	transform_variables(vs,s,t,var_prefix) => vs' &
	 Exp.print_component_ref_str(cr) => name &	
	 transform_variable(name,i,kind,var_prefix) => cr' &
         Exp.replace_exp_list(e,s,t) => (e',_) &
         transform_startValue(start,s,t) => start'
	 -------------------
	 transform_variables(VAR(cr,kind,a,b,SOME(e), c,d,start,i,_,j,dae_var_attr,comment,flow)::vs,s,t,var_prefix as "%")
	  => (VAR(cr',kind,a,b,SOME(e'),c,d,start',i,name,j,dae_var_attr,comment,flow)::vs')
	   (* when empty prefix, use old original name *)
  rule	transform_variables(vs,s,t,var_prefix) => vs' &
	 transform_variable(name,i,kind,var_prefix) => cr' &
         Exp.replace_exp_list(e,s,t) => (e',_) &
         transform_startValue(start,s,t) => start'
	 ------------------- 
	 transform_variables(VAR(cr,kind,a,b,SOME(e), c,d,start,i,name,j,dae_var_attr,comment,flow)::vs,s,t,var_prefix as "")
	  => (VAR(cr',kind,a,b,SOME(e'),c,d,start',i,name,j,dae_var_attr,comment,flow)::vs')
	   (* When dollar sign, save original name *)
  rule	transform_variables(vs,s,t,var_prefix) => vs' &
	 Exp.print_component_ref_str(cr) => name &
 	 transform_variable(name,i,kind,var_prefix) => cr' &
         transform_startValue(start,s,t) => start'
	 ---------------------------------------
	 transform_variables(VAR(cr,kind,a,b,NONE, c,d,start,i,_,j,dae_var_attr,comment,flow)::vs,s,t,var_prefix as "%")
	  => (VAR(cr',kind,a,b,NONE,c,d,start',i,name,j,dae_var_attr,comment,flow)::vs')

	   (* when empty prefix, use old original name *)
  rule	transform_variables(vs,s,t,var_prefix) => vs' &
	 transform_variable(name,i,kind,var_prefix) => cr' &
         transform_startValue(start,s,t) => start'
	 ---------------------------------------
	 transform_variables(VAR(cr,kind,a,b,NONE, c,d,start,i,name,j,dae_var_attr,comment,flow)::vs,s,t,var_prefix as "")
	  => (VAR(cr',kind,a,b,NONE,c,d,start',i,name,j,dae_var_attr,comment,flow)::vs')

 end


(** relation: transform_startValue
 ** author: PA
 **
 ** Helper relation to transform_variables
 **)

 relation transform_startValue:(DAE.StartValue, Exp.Exp list, Exp.Exp list) 
	  => DAE.StartValue =

  rule  Exp.replace_exp_list(e,s,t) => (e',_)
         --------------------------
         transform_startValue(SOME(e),s,t) => SOME(e')
         
  axiom  transform_startValue(NONE,_,_) => NONE
         
 end


(** relation: transform_variable
 ** author: PA
 **
 ** Helper relation to transform_variables
 **
 ** inputs:  (int, 
              VarKind, 
              string /* varible prefix, "$" or "" */)
 ** outputs: Exp.ComponentRef
 **)
 relation transform_variable: (string,
                               int, 
			       VarKind, 
			       string (* varible prefix, "%" or "" *)
			       ) => Exp.ComponentRef =

  rule  Util.modelica_string_to_c_str(name) => id' &
         Util.string_append_list([var_prefix,"$",id']) => id
         --------------------------------
         transform_variable(name,i, _,var_prefix) => Exp.CREF_IDENT(id,[])

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"y[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, VARIABLE,var_prefix) => Exp.CREF_IDENT(id,[]) *)

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"x[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, STATE,var_prefix) => Exp.CREF_IDENT(id,[]) *)

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"y[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, DUMMY_DER,var_prefix) => Exp.CREF_IDENT(id,[]) *)

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"y[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, DUMMY_STATE,var_prefix) => Exp.CREF_IDENT(id,[]) *)

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"y[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, DISCRETE,var_prefix) => Exp.CREF_IDENT(id,[]) *)

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"p[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, PARAM,var_prefix) => Exp.CREF_IDENT(id,[]) *)

         (*   rule	int_string(i) => is & *)
         (* 	Util.string_append_list([var_prefix,"p[",is,"]"]) => id *)
         (* 	------------------- *)
         (*  	transform_variable(i, CONST,var_prefix) => Exp.CREF_IDENT(id,[]) *)
 end

(** relation: calculate_indexes2
 ** author: PA
 **
 ** Helper relation to calculate_indexes
 **)
relation calculate_indexes2: (Var list,int,int,int,int,int) 
	  => (Var list,int,int,int,int,int) =

  axiom	calculate_indexes2([],x,xd,y,p,dummy) => ([],x,xd,y,p,dummy)
	
  rule	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => (vars',x1,xd1,y1,p1,dummy1)
	----------------------------------------
	calculate_indexes2(VAR(cr,VARIABLE,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy) 
	  => (VAR(cr,VARIABLE,d,tp,b,value,dim,start,y,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)

  rule	int_add(x,1) => x' &
	calculate_indexes2(vs,x',xd,y,p,dummy) => (vars',x1,xd1,y1,p1,dummy1) 
	----------------------------------------
	calculate_indexes2(VAR(cr,STATE,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy) 
	  => (VAR(cr,STATE,d,tp,b,value,dim,start,x,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)

 rule	(* Dummy derivatives become algebraic variables *)
	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => (vars',x1,xd1,y1,p1,dummy1) 
	----------------------------------------
	calculate_indexes2(VAR(cr,DUMMY_DER,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy)
 	  => (VAR(cr,DUMMY_DER,d,tp,b,value,dim,start,y,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)

  rule	(* Dummy state become algebraic variables *)
	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => (vars',x1,xd1,y1,p1,dummy1) 
	----------------------------------------
	calculate_indexes2(VAR(cr,DUMMY_STATE,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy) 
	  => (VAR(cr,DUMMY_STATE,d,tp,b,value,dim,start,y,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)

  rule	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => (vars',x1,xd1,y1,p1,dummy1)
	----------------------------------------
	calculate_indexes2(VAR(cr,DISCRETE,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy) 
	  => (VAR(cr,DISCRETE,d,tp,b,value,dim,start,y,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)

  rule	int_add(p,1) => p' &
	calculate_indexes2(vs,x,xd,y,p',dummy) => (vars',x1,xd1,y1,p1,dummy1)
	----------------------------------------
	calculate_indexes2(VAR(cr,PARAM,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy) 
	  => (VAR(cr,PARAM,d,tp,b,value,dim,start,p,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)

  rule  calculate_indexes2(vs,x,xd,y,p,dummy) => (vars',x1,xd1,y1,p1,dummy1)
	----------------------------------------
	calculate_indexes2(VAR(cr,CONST,d,tp,b,value,dim,start,_,name,cl,dae_var_attr,comment,flow)::vs,x,xd,y,p,dummy) 
	  => (VAR(cr,CONST,d,tp,b,value,dim,start,p,name,cl,dae_var_attr,comment,flow)::vars',
	      x1,xd1,y1,p1,dummy1)
end


(** relation: print_equations
 ** author: PA
 **
 ** Helper relation to dump
 **)
relation print_equations: (int list, DAELow) => () =

  axiom	print_equations ([],_) => ()

  rule	print_equations(rest,dae) => () &
	print_equation_no(n,dae) => ()
	----------------
	print_equations(n::rest,dae) => ()
end


(** relation: print_equation_no
 ** author: PA
 **
 ** Helper relation to print_equations
 **)
relation print_equation_no: (int, DAELow) => () =

  rule	int_sub(eqno,1) => eqno' &
	equation_nth(eqns,eqno') => eq &
	print_equation eq => ()
	----------------
	print_equation_no(eqno,DAELOW(_,_,eqns,_,_,_,_,_)) => ()
end


(** relation: print_equation
 ** author: PA
 **
 ** Helper relation to print_equations
 **)
relation print_equation: Equation =>  () =

  rule	Exp.print_exp_str e1 => s1 &
	Exp.print_exp_str e2 => s2 &
	Util.string_append_list([s1, " = ", s2, "\n" ]) => res &
	print res
	-----------------
	print_equation(EQUATION(e1,e2))

  rule	get_when_equation_expr w =>(cr, e2) &
	Exp.print_component_ref_str cr => s1 &
	Exp.print_exp_str e2 => s2 &
	Util.string_append_list([s1, " =  ", s2, "\n" ]) => res &
	print res
	-----------------
	print_equation(WHEN_EQUATION(w))
 end
 
 
(** relation: tree_get
 ** author: PA
 **
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string can not be uniquely mapped to an int. Therefore we need to compare two strings
 ** to get a unique ordering.
**)

relation tree_get: (BinTree, Key) => Value =


  rule	Exp.print_component_ref_str(key) => keystr &
	tree_get2(bt,keystr) => v 
	-----------------------
	tree_get(bt,key) => v
end


(** relation: tree_get2
 ** author: PA
 **
 ** Helper relation to tree_get
 **)
relation tree_get2:(BinTree, string) => Value =
 
 rule	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => 0 
	----------------------------------
	tree_get2 (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right), keystr)
	   => rval

  rule	(* Search to the right*)
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_get2(right,keystr) => res
	--------------------
	tree_get2(TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right)),keystr)
	  => res

  rule	(* Search to the left*)
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => false &
	tree_get2(left,keystr) => res
	--------------------
	tree_get2(TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left),right),keystr)
	  => res
	
(*  rule	print "tree_get2 failed\n" 
	---------------
	tree_get2(_,_,_) => fail*)
end


(** relation: tree_add
 ** author: PA
 **
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string (ComponentRef) can not be uniquely mapped to an int. Therefore we need to compare two strings
 ** to get a unique ordering.
**)
relation tree_add: (BinTree, Key, Value) => (BinTree) =

  axiom	tree_add (TREENODE(NONE,NONE,NONE),key,value) 
	  => TREENODE(SOME(TREEVALUE(key,value)),NONE,NONE)

  rule	(* Replace this node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0
	----------------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),key,value)
	  => (TREENODE(SOME(TREEVALUE(rkey,value)),left,right))

  rule	(* Insert to right subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_add(t,key,value) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(t')))

  rule	(* Insert to right node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true & 
	tree_add(TREENODE(NONE,NONE,NONE),key,value) => right'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as NONE),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right')))

  rule	(* Insert to left subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add(t,key,value) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(t'),right))

  rule	(* Insert to left node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add(TREENODE(NONE,NONE,NONE),key,value) => left'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as NONE,right),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left'),right))

  rule	print "tree_add failed\n"
	-----------------------
	tree_add(_,_,_) => fail
 end 


(** relation: tree_delete
 ** author: PA
 **
 ** This relation deletes an entry from the BinTree.
 **)
relation tree_delete: (BinTree, Key) => (BinTree) =

  axiom	tree_delete(bt as TREENODE(NONE,NONE,NONE),key) => bt

  rule	(* delete this node, when existing right node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0 &
	tree_delete_rightmost_value(right) => (rightmost,right') &
	tree_prune_empty_nodes(right') => optright'
	-------------------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),
			      left,
			      SOME(right)),
		     key)
	  => (TREENODE(SOME(rightmost),left,optright'))
	  
  rule	(* delete this node, when no right node, but left node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0 
	-------------------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),
			      SOME(TREENODE(leftval,lleft,lright)),
			      NONE),
		     key)
	  => (TREENODE(leftval,lleft,lright))
	  
  rule	(* delete this node, when no left or right node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0 
	-------------------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),
			      NONE,
			      NONE),

		     key)
	  => (TREENODE(NONE,NONE,NONE))
	  
  rule	(* delete in right subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_delete(t,key) => t' &
	tree_prune_empty_nodes(t') => topt'
	------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,topt'))
	  
  rule	(* delete in left subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_delete(t,key) => t' &
	tree_prune_empty_nodes(t') => topt'
	------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),topt',right))

  rule	print "tree_delete failed\n" 
	----------------------------
	tree_delete(_,_) => fail
end


(** relation: tree_delete_rightmost_value
 ** author: PA
 **
 ** This relation takes a BinTree and deletes the rightmost value of the tree.
 ** Tt returns this value and the updated BinTree. This relation is used in 
 ** the binary tree deletion relation 'tree_delete'.
 **
 ** inputs:  (BinTree) 
 ** outputs: (TreeValue, /* deleted value */
              BinTree    /* updated bintree */)
 **)
 relation tree_delete_rightmost_value: (BinTree) => (TreeValue, BinTree) =	

  axiom	tree_delete_rightmost_value(TREENODE(SOME(treevalue),NONE,NONE)) 
	  => (treevalue,TREENODE(NONE,NONE,NONE))

  axiom	tree_delete_rightmost_value(TREENODE(SOME(treevalue),SOME(left),NONE))
	 => (treevalue,left)

  rule tree_delete_rightmost_value(right) => (value, right') &
	tree_prune_empty_nodes(right') => rightopt'
	--------------------------------------------
	tree_delete_rightmost_value(TREENODE(treeval,left,SOME(right)))
	  => (value,TREENODE(treeval,left,rightopt'))

  rule	not tree_delete_rightmost_value(right) => (_,_) &
	 print "right value was empty , left NONE\n" 
	--------------------------------------------
	tree_delete_rightmost_value(TREENODE(SOME(treeval),NONE,SOME(right))) 
	  => (treeval,TREENODE(NONE,NONE,NONE))


  rule	print "-tree_delete_rightmost_value failed\n" 
	 --------------------------------------------
	 tree_delete_rightmost_value(bt) => fail
end


(** relation: tree_prune_emtpy_nodes
 ** author: PA
 **
 ** This relation is a helper relation to tree_delete
 ** It is used to delete empty nodes of the BinTree representation, that might be introduced
 ** when deleting nodes.
 **)
relation tree_prune_empty_nodes: (BinTree) => BinTree option =
  axiom	tree_prune_empty_nodes TREENODE(NONE,NONE,NONE) => NONE
  axiom	tree_prune_empty_nodes bt => SOME(bt)
end


(** relation: bintree_to_list
 ** author: PA
 **
 ** This relation takes a BinTree and transform it into a list
 ** representation, i.e. two lists of keys and values
 **)
 relation bintree_to_list: (BinTree) => (Key list, Value list) =

  rule	bintree_to_list2(bt,[],[]) => (klst,vlst) 
	------------------------------------------
	bintree_to_list(bt) => (klst,vlst)

  rule	print "-bintree_to_list failed\n" 
	 --------------
	 bintree_to_list(_) => fail
end


(** relation: bintree_to_list2
 ** author: PA
 **
 ** helper relation to bintree_to_list
 **)
relation bintree_to_list2: (BinTree,Key list,Value list ) 
	  => (Key list, Value list) =

 axiom	bintree_to_list2( TREENODE(NONE,NONE,NONE),klst,vlst) => (klst,vlst)
 
  rule	bintree_to_list_opt(left,klst,vlst) => (klst,vlst) &
	bintree_to_list_opt(right,klst,vlst) => (klst,vlst) 
	------------------
	bintree_to_list2(TREENODE(SOME(TREEVALUE(key,value)),left,right),klst,vlst)
	  => (key::klst,value::vlst) 
	  
  rule	bintree_to_list_opt(left,klst,vlst) => (klst,vlst) &
	bintree_to_list_opt(left,klst,vlst) => (klst,vlst) 
	--------------------------------------------------
	bintree_to_list2(TREENODE(NONE,left,right),klst,vlst) => (klst,vlst)
end


(** relation: bintree_to_list_opt
 ** author: PA
 **
 ** helper relation to bintree_to_list
 **)
relation bintree_to_list_opt: (BinTree option, Key list, Value list) 
	  => (Key list, Value list) =

  axiom	bintree_to_list_opt(NONE,klst,vlst) => (klst,vlst)

  rule	bintree_to_list2(bt,klst,vlst) => (klst,vlst) 
	---------------------------------------------
	bintree_to_list_opt(SOME(bt),klst,vlst) => (klst,vlst)
end


(** relation: print_vars_statistics
 ** author: PA
 **
 ** Prints statistics on variables, currently depth of BinTree, etc.
 **)
relation print_vars_statistics: (Variables,Variables) => () =

  rule	print "Variable Statistics\n" &
	print "===================\n" &
	print "Number of variables: " &
        int_string(n1) => lenstr &
	print lenstr & print "\n" &
	print "Bucket size for variables: " &
	int_string(bsize1) => bstr & 
	print bstr & print "\n" &
	print "Number of known variables: " &
	int_string(n2) => lenstr &
	print lenstr & print "\n" &
	print "Bucket size for known variables: " &
	int_string(bsize1) => bstr & 
	print bstr & print "\n" 
	-----------------------
	print_vars_statistics(VARIABLES(_,_,v1,bsize1,n1),VARIABLES(_,_,v2,bsize2,n2)) => ()
end


(** relation: bintree_depth
 ** author: PA
 **
 ** This relation calculates the depth of the Binary Tree given
 ** as input. It can be used for debugging purposes to investigate
 ** how balanced binary trees are.
 **)
relation bintree_depth : (BinTree) => int =

  axiom	bintree_depth(TREENODE(_,NONE,NONE)) => 1 

  rule	bintree_depth(left) => ld &
	bintree_depth(right) => rd &
	int_max(ld,rd) => res &
	int_add(res,1) => res'
	--------------------
	bintree_depth(TREENODE(_,SOME(left),SOME(right))) => res'

  rule	bintree_depth(left) => ld 
	-------------------------
	bintree_depth(TREENODE(_,SOME(left),NONE)) => ld

  rule	bintree_depth(right) => rd 
	-------------------------
	bintree_depth(TREENODE(_,NONE,SOME(right))) => rd
end	


(** relation: is_algebraic
 ** author: PA
 **
 ** This relation returns true if an expression is purely algebraic, i.e. not
 ** containing any derivatives
 ** Otherwise it returns false.
 **)
relation is_algebraic : (Exp.Exp) => bool =
        
  axiom is_algebraic(Exp.END) => true
        
  axiom is_algebraic(Exp.ICONST(x))  => true

  axiom is_algebraic(Exp.RCONST(x)) => true

  axiom is_algebraic(Exp.SCONST(s))  => true

  axiom	is_algebraic(Exp.BCONST(false))  => true

  axiom	is_algebraic(Exp.BCONST(true)) => true

  axiom is_algebraic(Exp.CREF(c,_)) => true

  rule  is_algebraic (e1)  => true & 
        is_algebraic (e2) => true
        ------------------------
        is_algebraic (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22))) => true

  rule  is_algebraic (e1) => true & 
        is_algebraic (e2) => true
        ------------------------
        is_algebraic (Exp.BINARY(e1, op, e2)) => true

  rule  is_algebraic (e) => true 
        ----------------------------
        is_algebraic(Exp.UNARY(op, e)) => true
        
  rule  is_algebraic (e1) => true &
        is_algebraic (e2) => true 
        ----------------------------------------------------------------
        is_algebraic(Exp.LBINARY(e1, op, e2)) => true

  rule  is_algebraic (e) => true
        ---------------------------------------------------
        is_algebraic(Exp.LUNARY(op, e)) => true
        
  rule  is_algebraic(e1) => true & 
        is_algebraic(e2) => true
        -----------------------------------------------------------------
        is_algebraic(Exp.RELATION(e1, op, e2)) => true 

  rule	is_algebraic(c) => true &
        is_algebraic(t) => true &
        is_algebraic(f) => true
        ----------------------------
        is_algebraic(Exp.IFEXP(c,t,f)) => true

  axiom is_algebraic(Exp.CALL(Absyn.IDENT("der"), args,_,_)) => false

  axiom is_algebraic(Exp.CALL(fcn, args,_,_))  => true


  axiom is_algebraic (Exp.ARRAY(_,_,es)) => true

  axiom is_algebraic (Exp.TUPLE(es)) => true

  axiom is_algebraic (Exp.MATRIX(_,_,es)) => true

  rule  is_algebraic (start) => true &
        is_algebraic (stop) => true
        -------------------------------------------------------------
        is_algebraic (Exp.RANGE(_,start,NONE,stop)) => true

  rule  is_algebraic (start) => true &
        is_algebraic (step) => true &
        is_algebraic (stop) => true 
        -------------------------------------
        is_algebraic (Exp.RANGE(_,start,SOME(step),stop)) => true 
        
  axiom is_algebraic (Exp.CAST(REAL,Exp.ICONST(ival))) => true

  axiom is_algebraic (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival)))) => true

  axiom is_algebraic (Exp.CAST(Exp.REAL,e)) => true

  axiom is_algebraic (Exp.CAST(Exp.REAL,e)) => true

  rule  is_algebraic (e) => true 
        ---------------------------------------
        is_algebraic (Exp.ASUB(e,i)) => true

  axiom is_algebraic (Exp.SIZE(cr,SOME(dim))) => true

  axiom is_algebraic (Exp.SIZE(cr,NONE)) => true

  axiom is_algebraic (Exp.REDUCTION(fcn,exp,id,iterexp)) => true

  axiom	is_algebraic (_) => true

 end


(** relation: is_var_known
 ** author: PA
 **
 ** Returns true if the the variable is present in the variable list.
 ** This is done by traversing the list, searching for a matching variable 
 ** name.
 **)
relation is_var_known : (Var list, Exp.ComponentRef) => bool =
	
  rule	
        --------------------------------
        is_var_known([],var_name) => false
	
  rule	Exp.cref_equal(cr,var_name) => true
        -------------------------------
        is_var_known((variable as VAR(cr,_,_,_,_,_,_,_, indx,origname,_,dae_var_attr,comment,flow))::rest,
                     var_name) => true
	
  rule	is_var_known(rest,var_name) => res
        -------------------------------
        is_var_known((variable as VAR(cr,_,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow))::rest,
                     var_name) => res
end 


(** relation: get_all_exps
 ** author: PA
 **
 ** This relation goes through the DAELow structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps : DAELow => Exp.Exp list =

  rule	get_all_exps_vars vars1 => exps1 &
	get_all_exps_vars vars2 => exps2 &
	get_all_exps_eqns eqns => exps3 &
	get_all_exps_eqns reqns => exps4 &
	get_all_exps_eqns ieqns => exps5 &
	get_all_exps_array_eqns ae => exps6 &
	array_list algs => alglst &
	Util.list_map(alglst, Algorithm.get_all_exps) => explist6 &
	list_append([exps1, exps2, exps3, exps4, exps5,exps6],explist6) => explist &
	Util.list_flatten(explist) => exps
	---------------------------------------------------------------------	
	get_all_exps (DAELOW(vars1,vars2,eqns,reqns,ieqns,ae,algs,_)) => exps

end


(** relation: get_all_exps_array_eqns
 ** author: PA
 **
 ** Returns all expressions in array equations
 **)
relation get_all_exps_array_eqns: (MultiDimEquation array) => Exp.Exp list =

  rule	array_list(arr) => lst &
	Util.list_map(lst,get_all_exps_array_eqn) => llst &
	Util.list_flatten(llst) => res
	-------------------------------
	get_all_exps_array_eqns(arr) => res
end


(** relation: get_all_exps_array_eqn
 ** author: PA
 **
 ** Helper relation to get_all_exps_array_eqns
 **)
relation get_all_exps_array_eqn: MultiDimEquation => Exp.Exp list =

  axiom	get_all_exps_array_eqn(MULTIDIM_EQUATION(_,e1,e2)) => [e1,e2]
end


(** relation: get_all_exps_vars
 ** author: PA
 ** 
 ** Helper to get_all_exps. Goes through the Variables type
 **)
relation get_all_exps_vars : Variables => Exp.Exp list =

	
  rule	(* We can ignore crefs, they don't contain real expressions *)
	vararray_list vararray => vars &
	Util.list_map(vars, get_all_exps_var) => exps &
	Util.list_flatten(exps) => exps
	---------------------------------------------------------------------	
	get_all_exps_vars VARIABLES(crefindex,oldcrefindex, vararray, bsize, nvars) => exps

end


(** relation: get_all_exps_var
 ** author: PA
 ** 
 ** Helper to get_all_exps_vars. Get all exps from a  Var.
 ** Exp.OTHER is used as type for componentref. Not important here.
 ** We only use the exp list for finding function calls
 **)
relation get_all_exps_var : Var => Exp.Exp list =

  rule	Util.option_to_list bndexp => e1 &
	Util.option_to_list startvalexp => e2 &
	Util.list_map(instdims, get_all_exps_subscript) => e3 &
	Util.list_flatten(e3) => e3 &
	Util.list_flatten([e1, e2, e3, [Exp.CREF(cref, Exp.OTHER)]]) => exps
	-------------------------------------------------------
	get_all_exps_var VAR(cref, vk, vd, ty, bndexp, bndval, instdims,
			     startvalexp, ind, orgname, clsnames,dae_var_attr,comment,flow) => exps
			     
end


(** relation: get_all_exps_subscript
 ** author: PA
 ** 
 ** Get all exps from a Subscript 
 **)
relation get_all_exps_subscript : Exp.Subscript => Exp.Exp list =

  axiom	get_all_exps_subscript Exp.WHOLEDIM => []
  axiom	get_all_exps_subscript Exp.SLICE(e) => [e]
  axiom	get_all_exps_subscript Exp.INDEX(e) => [e]
			     
end


(** relation: get_all_exps_eqns
 ** author: PA
 ** 
 ** Helper to get_all_exps. Goes through the EquationArray type
 **)
relation get_all_exps_eqns : EquationArray => Exp.Exp list =

  rule	equation_list eqnarray => eqns &
	Util.list_map(eqns, get_all_exps_eqn) => exps &
	Util.list_flatten(exps) => exps
	-------------------------------
	get_all_exps_eqns (eqnarray as EQUATION_ARRAY(_,_,_)) => exps

end


(** relation: get_all_exps_eqn
 ** author: PA
 ** 
 ** Helper to get_all_exps_eqns. Get all exps from an Equation.
 **)
relation get_all_exps_eqn : Equation => Exp.Exp list =

  axiom	get_all_exps_eqn EQUATION(e1, e2) => [e1, e2]
  axiom	get_all_exps_eqn ARRAY_EQUATION(_,expl) => expl

  rule	Exp.typeof(e) => tp 
	-------------------
	get_all_exps_eqn SOLVED_EQUATION(cr, e) => [Exp.CREF(cr,tp),e]
  rule	Exp.typeof(e) => tp
	------------------------
  	get_all_exps_eqn WHEN_EQUATION(WHEN_EQ(_,cr, e)) => [Exp.CREF(cr,tp),e]

  rule	list_append(e1, e2) => exps
	---------------------------------
	get_all_exps_eqn ALGORITHM(ind,e1,e2) => exps
			     
end


(** relation: is_param
 **
 ** Return true if variable is a parameter.
 **)
relation is_param: (Var ) => bool =
          
  axiom	is_param(VAR(_,PARAM,_,_,_,_,_,_,_,_,_,_,_,flow)) => true
  axiom	is_param(_) => false
 end


(** relation: is_output
 **
 ** Return true if variable is declared as output. Note that the output
 ** attribute sticks with a variable even if it is originating from a sub
 ** component, which is not the case for Dymola.
 **)
relation is_output: (Var) => bool =

  axiom	is_output( VAR(_,_,DAE.OUTPUT,_,_,_,_,_,_,_,_,_,_,flow)) => true
  axiom	is_output(_) => false
end 	  


(** relation: is_input
 **
 ** Returns true if variable is declared as input.
 ** See also is_ouput above
**)
relation is_input: (Var) => bool =

  axiom	is_input( VAR(_,_,DAE.INPUT,_,_,_,_,_,_,_,_,_,_,flow)) => true

  axiom	is_input(_) => false
end


(** relation: get_when_equation_expr
 **
 ** Get the left and right hand parts from an equation appearing in a when clause
 **)
relation get_when_equation_expr : WhenEquation => (Exp.ComponentRef, Exp.Exp) =

  axiom get_when_equation_expr(WHEN_EQ(_,cr,e)) => (cr,e)

end


(** relation: get_zero_crossing_indices_from_when_clause
 ** Returns a list of indices of zerocrossings that a given when clause is dependent on.
 **)
relation get_zero_crossing_indices_from_when_clause: (DAELow, int) => (int list) =

  rule	get_zero_crossing_indices_from_when_clause2(zcLst,0,when_index) => res
	----------------------------------------
	get_zero_crossing_indices_from_when_clause(DAELOW(_,_,_,_,_,_,_,EVENT_INFO(_,zcLst)), when_index) => res

end


(** relation: get_zero_crossing_indices_from_when_clause2
 ** helper relation to get_zero_crossing_indices_from_when_clause
 **)
relation get_zero_crossing_indices_from_when_clause2: (ZeroCrossing list, int, int) => (int list) =

  axiom	get_zero_crossing_indices_from_when_clause2([],_,_) => []

  rule 	Util.list_getmember(when_index, whenClauseList) => _ &
	count + 1 => count' &
         get_zero_crossing_indices_from_when_clause2(rest,count',when_index) => resx
	----------------------------------------
	get_zero_crossing_indices_from_when_clause2(ZERO_CROSSING(_,_,whenClauseList)::rest,count,when_index) => count::resx

  rule	not Util.list_getmember(when_index, whenClauseList) => _ &
	count + 1 => count' &
         get_zero_crossing_indices_from_when_clause2(rest,count',when_index) => resx
	----------------------------------------
	get_zero_crossing_indices_from_when_clause2(ZERO_CROSSING(_,_,whenClauseList)::rest,count,when_index) => resx

  rule	print "-get_zero_crossing_indices_from_when_clause2 failed\n"
	--------------------------------------------------
	get_zero_crossing_indices_from_when_clause2(_,_,_) => fail

end


(** relation: dump_structural_if_conditions
 ** author: PA
 **
 ** Dups structual if conditiions to stdout.
 **)

 relation dump_structural_if_conditions: (Exp.Exp* int) list list  => () =

  rule Util.list_map_0(expl,dump_structural_if_conditions2) => ()
	 -------------------
	 dump_structural_if_conditions(expl) => ()

end

 relation dump_structural_if_conditions2: (Exp.Exp* int) list  => () =

  axiom	dump_structural_if_conditions2([]) => ()

  rule	Exp.print_exp_str(e) => s1 &
	int_string(e_indx) => s2 &
	Util.string_append_list(["if cond ",s1," in eqn:",s2,"\n"]) => s &
	print s &
	dump_structural_if_conditions2(es)
	-----------------
	dump_structural_if_conditions2((e,e_indx)::es) => ()

end

(** relation: structural_if_variables
 ** author: PA
 ** 
 ** Returns the list of boolean variables that are involved in structural
 ** if equations and need to be evaluated to produce several systems which
 ** are sent to the matching algorithm.
 **)

relation structural_if_variables: (Exp.Exp* int) list list 
	  => Exp.ComponentRef list =
	
  rule	Util.list_map(expl,Util.list_first) => expl1 &
	Util.list_map(expl1,Util.tuple2_1) => expl2 &
	Util.list_map(expl2,structural_if_variables_exp) => res
	--------------------------
	structural_if_variables(expl) => res
end

relation structural_if_variables_exp: (Exp.Exp) => Exp.ComponentRef =

  axiom	structural_if_variables_exp(Exp.IFEXP(Exp.CREF(cr,_),_,_)) => cr

end

(** relation: structural_if_eqn_indices
 ** author: PA
 ** 
 ** Returns the list of equation indices that are involved in structural
 ** if equations
 **)

relation structural_if_eqn_indices: (Exp.Exp* int) list list 
	  => int list list =
	
  rule	Util.list_list_map(expl,Util.tuple2_2) => res
	--------------------------
	structural_if_eqn_indices(expl) => res
end


(** relation: structural_if_equations
 ** author: PA
 **
 ** This relation returns all if expressions with the same if-condition 
 ** in two or more
 ** equations that has different variables sets in different branches.
 ** Such equation sets must be solved for all combinations of the values of 
 ** the boolean conditions and will potentially give different matching results
**)
relation structural_if_equations: (DAELow) => (Exp.Exp* int) list list =
	 
  rule	collect_if_conditions(daelow) => lst &
	structural_if_equations2(lst) => lst1 &
	structural_if_equations_split_groups(lst1) => groups  &
	structural_if_equations3(groups) => res 
	----------------------
	structural_if_equations(daelow) => res
end

(** relation: structural_if_equations3
 ** author: PA
 **
 ** Filters out if equations that have different cref sets in different 
 ** branches.
 **)
relation structural_if_equations3: (Exp.Exp* int) list list => (Exp.Exp* int) list list =

  axiom	structural_if_equations3([]) => []

  rule	structural_if_equations4(group) => group' &
	structural_if_equations3(groups) => groups'
	--------------------------
	structural_if_equations3(group::groups) => group'::groups 

	(* filter out group *)
  rule	structural_if_equations3(groups) => groups'
	--------------------------
	structural_if_equations3(group::groups) => groups'
end


(** relation structural_if_equations4
 ** 
 ** Helper relation to structural_if_equations3
 ** Filters out one group of if-expressions.
**)

relation structural_if_equations4:(Exp.Exp* int) list 
	  => (Exp.Exp* int) list  = 


  rule	Util.list_map(elst,structural_if_different_cref_branches) => blst &
	Util.bool_or_list(blst) => true
	-----------------------------
	structural_if_equations4(elst) => elst
end

(** relation structural_if_different_cref_branches
 ** author: PA
 **
 ** Returns true if the different branches of the (possible nested) IFEXP
 ** contains different cref sets
 **)

relation structural_if_different_cref_branches:(Exp.Exp * int) => bool =

  rule	Exp.ifexp_get_branches(e) => elst &
	Util.list_map(elst,Exp.get_cref_from_exp) => cref_llst &
	(* The set difference between all cref lists is empty *)
	Util.list_reduce_1(cref_llst,Util.list_setdifference_p,Exp.cref_equal)
	  => []
	----------------------------
	structural_if_different_cref_branches((e,_)) => false

  axiom	structural_if_different_cref_branches(_) => true

end


(** relation structural_if_equations_split_groups
 ** author: PA
 **
 ** Splits the ifexpression list into groups. All ifexpressions with the same
 ** condition belong to the same group.
 **)
relation structural_if_equations_split_groups:(Exp.Exp* int) list 
	  => (Exp.Exp* int) list list =

  axiom	structural_if_equations_split_groups ([]) => []

  rule	structural_if_equations_split_groups(es) => es' &
	structural_if_equations_insert_in_group(e,es') => res
	---------------------------
	structural_if_equations_split_groups(e::es) => res
end


(** relation structural_if_equations_insert_in_group
 ** author: PA
 **
 ** Helper relation to structural_if_equations_split_groups.
 **)

relation structural_if_equations_insert_in_group:((Exp.Exp*int), 
						 (Exp.Exp* int) list list) 
	  => (Exp.Exp* int) list list =

  axiom	structural_if_equations_insert_in_group(e,[]) => [[e]]

	(* insert into this group*)
  rule	Exp.exp_equal(cond,cond2) => true 
	------------------------------
	structural_if_equations_insert_in_group((e as Exp.IFEXP(cond,_,_),
						 e_indx),
						((e2 as Exp.IFEXP(cond2,_,_),e2_indx)::es)::es2)
	  => (((e,e_indx)::((e2,e2_indx)::es))::es2)

	  (* insert into following groups.*)
  rule	structural_if_equations_insert_in_group(e,groups) => groups'
	------------------------------
	structural_if_equations_insert_in_group(e,
						(group::groups))
	  => group::groups'
end


(** relation: structural_if_equations2
 ** author: PA
 **
 ** Filters out tuples that have same condition in two or more equations.
 **)

relation structural_if_equations2:((Exp.Exp * int) list) 
	  => ((Exp.Exp * int) list) =

  axiom	structural_if_equations2([]) => []

	(* If condition exist in more eqns *)
  rule	structural_if_equations_exist_several(c,e_indx,es) => (es1' as _::_) &
	structural_if_equations2(es) => es' &
	list_append(es1',es') => es''
	------------------------------
	structural_if_equations2((e as Exp.IFEXP(c,_,_),e_indx)::es)
	  => ((e,e_indx)::es'')

	  (* otherwise remove it *)
  rule	structural_if_equations2(es) => es'
	------------------------------
	structural_if_equations2((e as Exp.IFEXP(c,_,_),e_indx)::es) 
	  => es'
end

(** relation: structural_if_equations_exist_several
 ** author: PA
 ** 
 ** returns a list of condition expressions that exist in list with 
 ** different equation index but same condition expression.
 **)

relation structural_if_equations_exist_several: (Exp.Exp, int, 
						 (Exp.Exp * int) list) 
	  => ((Exp.Exp * int) list) =

  axiom	structural_if_equations_exist_several(cond,e_indx,[]) => []
	
	(* Succed if conditions same and e_index different *)
  rule	not e_indx = e_indx2 &
	Exp.exp_equal(cond,c2) => true  &
	structural_if_equations_exist_several(cond,e_indx,es) => es' 
	---------------------
	structural_if_equations_exist_several(cond,e_indx,(e as Exp.IFEXP(c2,_,_),e_indx2)::es) 
	  => ((e,e_indx2)::es')

	  (* check rest*)
  rule	structural_if_equations_exist_several(cond,e_indx,es) => res
	----------------------------
	structural_if_equations_exist_several(cond,e_indx,_::es) => res

end

(** relation: collect_if_conditions
 ** author: PA
 **
 ** This relation collects all if expressions (IFEXP) from the equations and
 ** return a tuple with the expressions and its corresponding equation index.
 ** inputs: 
 **)

relation collect_if_conditions: (DAELow) => (Exp.Exp*int) list =

  rule	equation_list(eqn) => eqn_lst &
	collect_if_conditions2(eqn_lst,1) => res
	--------------------------
	collect_if_conditions(DAELOW(v,kn,eqn,reqn,ieqn,arreqn,algs,event))
	
	  => res
end

(** relation: collect_if_conditions2
 ** author: PA
 **
 ** Helper relation to collect_if_conditions.
 **)

relation collect_if_conditions2:(Equation list,int) => (Exp.Exp * int) list =

  axiom	collect_if_conditions2([],_) => []

  rule	collect_if_conditions3(e,e_indx) => l1 &
	int_add(e_indx,1) => e_indx' &
	collect_if_conditions2(es,e_indx') => l2 &
	list_append(l1,l2) => res
	---------------------
	collect_if_conditions2(e::es,e_indx) => res
end

(** relatin: collect_if_condition3
 ** author: PA
 **
 ** Helper relation to collect_if_condition2. Collects if expressions from a 
 ** single equation given its index.
 **)

relation collect_if_conditions3: (Equation, int) => (Exp.Exp * int) list =

	(* EQUATION*)
  rule	Exp.get_ifexp(e1) => l1 &
	Exp.get_ifexp(e2) => l2 &
	list_append(l1,l2) => lst1 &
	list_length(lst1) => len &
	Util.list_fill(e_indx,len) => lst2 &
	Util.list_thread_tuple(lst1,lst2) => res
	--------------------
	collect_if_conditions3(EQUATION(e1,e2),e_indx) => res
	
	(* TODO: ARRAY_EQUATION*)
  rule	Debug.fprint("failtrace", "-collect_if_condition3 ARRAY_EQUATION not impl.\n")
	--------------------------
	 collect_if_conditions3(ARRAY_EQUATION(_,_),_) =>  []

  rule	Exp.get_ifexp(e) => lst1 &
	list_length(lst1) => len &
	Util.list_fill(e_indx,len) => lst2 &
	Util.list_thread_tuple(lst1,lst2) => res
	-------------------
	collect_if_conditions3(SOLVED_EQUATION(cr,e),e_indx) => res

  rule	Exp.get_ifexp(e) => lst1 &
	list_length(lst1) => len &
	Util.list_fill(e_indx,len) => lst2 &
	Util.list_thread_tuple(lst1,lst2) => res
	----------------------------------------
	collect_if_conditions3(RESIDUAL_EQUATION(e),e_indx) => res

	(* TODO: ARRAY_EQUATION*)
  rule	print "collect_if_condition3 ALGORITHM not impl.\n"
	--------------------------
	collect_if_conditions3(ALGORITHM(_,_,_),_) =>  []

  axiom	collect_if_conditions3(WHEN_EQUATION(_),_) => []
end




