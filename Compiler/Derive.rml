(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Derive.rml
 ** module:      Derive
 ** description: Differentiation of equations from DAELow
 **
 ** RCS: $Id$
 ** 
 ** This module is responsible for symbolic differentiation of equations and 
 ** expressions. Is is currently (2004-09-28) only used by the solve relation in 
 ** the exp module for solving equations.
 ** 
 ** The symbolic differentiation is used in the Newton-Raphson method and in
 ** index reduction.
 ** 
 ** 
 **)

module Derive:
  with "DAELow.rml"
  with "Exp.rml"

  relation differentiate_equation_time: (DAELow.Equation,
				    DAELow.Variables) (* all time varying variables *)
	  => DAELow.Equation
  relation differentiate_exp_time: (Exp.Exp, DAELow.Variables) => Exp.Exp
  relation differentiate_exp: (Exp.Exp, Exp.ComponentRef) => Exp.Exp
end


with "Absyn.rml" 
with "Util.rml"
with "Error.rml"
(* adrpo -- not used
with "Print.rml" 
with "Graphviz.rml" 
*)

(** relation: differentiate_equation_time
 **
 ** Differentiates an equation with respect to the time variable.
 **)
relation differentiate_equation_time: (DAELow.Equation,
				  DAELow.Variables) (* time varying variables *)
	  => DAELow.Equation =

  rule	differentiate_exp_time(e1,timevars) => e1' &
	differentiate_exp_time(e2,timevars) => e2' &
	Exp.simplify(e1') => e1'' &
	Exp.simplify(e2') => e2'' 
	(*& Exp.simplify(e1'') => e1'' &
	Exp.simplify(e2'') => e2'' *)
	----------------------
	differentiate_equation_time(DAELow.EQUATION(e1,e2),timevars) 
	  => DAELow.EQUATION(e1'',e2'')


  rule	print "-differentiate_equation_time on algorithm not impl yet.\n" 
	-----------------------
	differentiate_equation_time(DAELow.ALGORITHM(_,_,_),_) => fail

  rule	print "-differentiate_equation_time faile\n" 
	-----------------------
	differentiate_equation_time(_,_) => fail
end

(** relation: differentiate_exp_time
 **
 ** This relation differentiates expressions with respect to the 'time' variable.
 ** All other variables that are varying over time are given as the second variable.
 ** For instance, given the model:
 ** model test 
 **   Real x,y; 
 **   parameter Real PI=3.14; 
 ** equation
 **   x+y=5*PI;	
 ** end test;
 ** gives
 ** differentiate_exp_time('x+y=5*PI', [x,y]) => der(x)+der(y)=0
 **)
relation differentiate_exp_time: (Exp.Exp,DAELow.Variables) => Exp.Exp =

  axiom	differentiate_exp_time(Exp.ICONST(_),_) => Exp.RCONST(0.0)
  axiom	differentiate_exp_time(Exp.RCONST(_),_) => Exp.RCONST(0.0)
  axiom	differentiate_exp_time(Exp.CREF(Exp.CREF_IDENT("time",[]),tp),_) 
	  => Exp.RCONST(1.0)

	  (* special rule for DUMMY_STATES, they become DUMMY_DER *)
  rule	DAELow.get_var(cr,timevars) => ([DAELow.VAR(cr,DAELow.DUMMY_STATE,_,_,_,_,_,_,_,_,_,_,_,_)],_) &
	Exp.print_component_ref_str(cr) => cr_str &
	string_append("der_",cr_str) => cr_str' 
	--------------------------------
	differentiate_exp_time(e as Exp.CREF(cr,tp),timevars) 
	  => Exp.CREF(Exp.CREF_IDENT(cr_str',[]),Exp.REAL)


  rule	DAELow.get_var(cr,timevars) => (_,_)
	--------------------------------
	differentiate_exp_time(e as Exp.CREF(cr,tp),timevars) 
	  => Exp.CALL(Absyn.IDENT("der"),[e],false,true)

  rule  (* der(sin(x)) = der(x)*cos(x) *)
	differentiate_exp_time(e,timevars) => e'
	--------------------------------
	differentiate_exp_time(Exp.CALL(Absyn.IDENT("sin"),[e],false,true),timevars) 
	  => Exp.BINARY(e',Exp.MUL(Exp.REAL),Exp.CALL(Absyn.IDENT("cos"),[e],false,true))

  rule	(* list_member(cr,timevars) => false *)
	--------------------------------
	differentiate_exp_time(e as Exp.CREF(cr,tp),timevars) 
	  => Exp.RCONST(0.0)
	
  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.ADD(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.ADD(tp),e2')

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.SUB(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.SUB(tp),e2')

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.MUL(tp),e2),tv) 
	  => (* f'g + fg' *)
	  Exp.BINARY(Exp.BINARY(e1,Exp.MUL(tp),e2'),
			Exp.ADD(tp),
			Exp.BINARY(e1',Exp.MUL(tp),e2))

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.DIV(tp),e2),tv) 
	 => (* (f'g - fg' ) / g^2 *)
	  Exp.BINARY(Exp.BINARY(Exp.BINARY(e1',Exp.MUL(tp),e2)
				   ,Exp.SUB(tp),
				   Exp.BINARY(e1,Exp.MUL(tp),e2')),
			Exp.DIV(tp),
			Exp.BINARY(e2,Exp.MUL(tp),e2))


  rule	differentiate_exp_time(e,tv) => e' 
	-----------------------------
	differentiate_exp_time(Exp.UNARY(op,e),tv) => Exp.UNARY(op,e')

  rule	(* The derivative of logic expressions are non-existent *)
	Exp.print_exp_str e => e_str &
	Error.add_message(Error.NON_EXISTING_DERIVATIVE,[e_str])
	-----------------------------
	differentiate_exp_time(e as Exp.LBINARY(e1,op,e2),tv) 
	  => fail
	
  rule	differentiate_exp_time(e,tv) => e'
	-----------------------------
	differentiate_exp_time(Exp.LUNARY(op,e),tv) => Exp.LUNARY(op,e')

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2'
	-------------------------
	differentiate_exp_time(Exp.RELATION(e1,rel,e2),tv) => Exp.RELATION(e1',rel,e2')
	
  rule	differentiate_exp_time(e2,tv) => e2' &
	differentiate_exp_time(e3,tv) => e3'
	-------------------------
	differentiate_exp_time(Exp.IFEXP(e1,e2,e3),tv) => Exp.IFEXP(e1,e2',e3')

  rule	Util.list_map_1(expl,differentiate_exp_time,tv) => expl' 
	-------------------------------------------------
	differentiate_exp_time(Exp.CALL(a as Absyn.IDENT("der"),expl,b,c),tv) 
	  => Exp.CALL(a,expl',b,c)



  rule	Absyn.path_string(a) => str &
	string_append("differentiation of function ",str) => s1 &
	Error.add_message(Error.UNSUPPORTED_LANGUAGE_FEATURE, [s1,"no suggestion"]) 
	-------------------------------------------------
	differentiate_exp_time(Exp.CALL(a,expl,b,c),tv) => fail
	
  rule	Util.list_map_1(expl,differentiate_exp_time,tv) => expl' 
	--------------------------------------------
	differentiate_exp_time(Exp.ARRAY(tp,b,expl),tv) => Exp.ARRAY(tp,b,expl')
	
  rule	Error.add_message(Error.UNSUPPORTED_LANGUAGE_FEATURE, ["differentiation of matrix expressions","use nested vectors instead"]) 
	---------------------------------------
	differentiate_exp_time(e as Exp.MATRIX(_,_,_),_) => e
	
  rule	Util.list_map_1(expl,differentiate_exp_time,tv) => expl'
	-----------------------
	differentiate_exp_time(Exp.TUPLE(expl),tv) => Exp.TUPLE(expl')

  rule	differentiate_exp_time(e,tv) => e'
	-----------------------
	differentiate_exp_time(Exp.CAST(tp,e),tv) => Exp.CAST(tp,e')

  rule	differentiate_exp_time(e,tv) => e'
	----------------------------
	differentiate_exp_time(Exp.ASUB(e,i),tv) => Exp.ASUB(e,i)

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	------------------------------
	differentiate_exp_time(Exp.REDUCTION(a,e1,b,e2),tv) 
	  => Exp.REDUCTION(a,e1',b,e2')

  rule	Exp.print_exp_str e => str &
	print "-differentiate_exp_time on " & print str & print " failed\n" 
	--------------------
	differentiate_exp_time(e,tv) => fail
end

(** relation: differenatiate_exp
 **
 ** This relation differentiates expressions with respect to a given variable, 
 ** given as second argument.
 ** For example.
 ** differentiate_exp('2*x*y+2*x+y',x) => 2*x+2
 **)
relation differentiate_exp: (Exp.Exp, Exp.ComponentRef) => Exp.Exp =
        
  axiom	differentiate_exp(Exp.ICONST(_),_) => Exp.RCONST(0.0)
  axiom	differentiate_exp(Exp.RCONST(_),_) => Exp.RCONST(0.0)

  rule	(* D(x)/dx => 1 *)
	Exp.cref_equal (cr, crx) => true &
	int_real(1) => rval (* Since bug in RML makes 1.0 into 0.0 *)
	--------------------------------
	differentiate_exp(Exp.CREF(cr,_), crx) => Exp.RCONST(rval)
	  
  rule	(* D(c)/dx => 0 *)
 	Exp.cref_equal (cr, crx) => false
	--------------------------------
	differentiate_exp(e as Exp.CREF(cr,_), crx) => Exp.RCONST(0.0)
	
  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.ADD(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.ADD(tp),e2')

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.SUB(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.SUB(tp),e2')

  rule	(* a^x => ax^(a-1) *)
        Exp.cref_equal (cr, tv) => true &
        Exp.exp_contains(e2,Exp.CREF(tv,tp)) => false &
        differentiate_exp(Exp.CREF(tv,tp),tv) => const_one
	-----------------------------
	differentiate_exp(Exp.BINARY((e1 as Exp.CREF(cr,_)),Exp.POW(tp),e2),tv) 
	  => (* ax^(a-1) *)
	  Exp.BINARY(e2,
		     Exp.MUL(tp),
 		     Exp.BINARY(e1,Exp.POW(tp),                 
			        Exp.BINARY(e2,Exp.SUB(tp),const_one)))

  rule	(* e^x => x*der(e)*e^x-1 *)
	differentiate_exp(e1,tv) => d_e1 &
        Exp.exp_contains(e2,Exp.CREF(tv,tp)) => false &
        differentiate_exp(Exp.CREF(tv,tp),tv) => const_one & 
	let exp = Exp.BINARY(Exp.BINARY(d_e1,
				Exp.MUL(tp),
 				Exp.BINARY(e2,Exp.SUB(tp),Exp.RCONST(1.0))),
		     Exp.MUL(tp),
		     Exp.BINARY(e1,Exp.POW(tp),                 
			        Exp.BINARY(e2,Exp.SUB(tp),const_one)))
	-----------------------------
	differentiate_exp(Exp.BINARY((e1),Exp.POW(tp),e2),tv) 
	  => exp (* ax^(a-1) *)
	  
  rule	(* der(e)^x => x*der(e,2)*der(e)^(x-1)*)
        Exp.cref_equal (cr, tv) => true &
        Exp.exp_contains(e2,Exp.CREF(tv,tp)) => false &
        differentiate_exp(Exp.CREF(tv,tp),tv) => const_one
	-----------------------------
	differentiate_exp(Exp.BINARY((e1 as Exp.CALL(a as Absyn.IDENT("der"),[exp as Exp.CREF(cr,_)],b,c)),Exp.POW(tp),e2),tv) 
	  => (* ax^(a-1) *)
	  Exp.BINARY(Exp.BINARY(Exp.CALL(a,[exp,Exp.ICONST(2)],b,c),
				Exp.MUL(tp),
				e2),
		     Exp.MUL(tp),
 		     Exp.BINARY(e1,Exp.POW(tp),                 
			        Exp.BINARY(e2,Exp.SUB(tp),const_one)))


  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.MUL(tp),e2),tv) 
	  => (* f'g + fg' *)
	  Exp.BINARY(Exp.BINARY(e1,Exp.MUL(tp),e2'),
			Exp.ADD(tp),
			Exp.BINARY(e1',Exp.MUL(tp),e2))

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.DIV(tp),e2),tv) 
	 => (* (f'g - fg' ) / g^2 *)
	  Exp.BINARY(Exp.BINARY(Exp.BINARY(e1',Exp.MUL(tp),e2)
				   ,Exp.SUB(tp),
				   Exp.BINARY(e1,Exp.MUL(tp),e2')),
			Exp.DIV(tp),
			Exp.BINARY(e2,Exp.MUL(tp),e2))

  rule	differentiate_exp(e,tv) => e' 
	-----------------------------
	differentiate_exp(Exp.UNARY(op,e),tv) => Exp.UNARY(op,e')

	(* der(tanh(x)) = der(x) / cosh(x) *)
  rule	is_tanh(fname) &
	Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
			Exp.DIV(Exp.REAL),
			Exp.CALL(Absyn.IDENT("cosh"),[exp],b,c))

	(* der(cosh(x)) => der(x)*sinh(x) *)
  rule  is_cosh(fname) &
	Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
			Exp.MUL(Exp.REAL),
			Exp.CALL(Absyn.IDENT("sinh"),[exp],b,c))

	(* der(sinh(x)) => der(x)*sinh(x) *)
  rule  is_sinh(fname) &
	Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
			Exp.MUL(Exp.REAL),
			Exp.CALL(Absyn.IDENT("cosh"),[exp],b,c))


	(* sin(x) *)
  rule  is_sin(fname) &
	Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.CALL(Absyn.IDENT("cos"),[exp],b,c),
                        Exp.MUL(Exp.REAL),
                        exp')

  rule  is_cos(fname) &
	Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.UNARY(Exp.UMINUS(Exp.REAL),Exp.CALL(Absyn.IDENT("sin"),[exp],b,c)),
                        Exp.MUL(Exp.REAL),
                        exp')

  rule  (* exp(x) => x' * exp(x) *)
	is_exp(fname) &
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.CALL(fname,exp::[],b,c),
                        Exp.MUL(Exp.REAL),
                        exp')
 
  rule  (* log(x) => x' * 1/x *)
	is_log(fname) &
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
                        Exp.MUL(Exp.REAL),
                        Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   exp))

  rule  (* log10(x) => x'*1/(x*log(10)) *)
	is_log10(fname) &
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
                        Exp.MUL(Exp.REAL),
                        Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   Exp.BINARY(exp,
                                              Exp.MUL(Exp.REAL),
                                              Exp.CALL(Absyn.IDENT("log"),[Exp.RCONST(10.0)],b,c))))


  rule  (* sqrt(x) => 1(2 * sqrt(x)) * der(x) *)
	is_sqrt(fname) &
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   Exp.BINARY(Exp.RCONST(2.0),
                                              Exp.MUL(Exp.REAL),
                                              Exp.CALL(Absyn.IDENT("sqrt"),exp::[],b,c))),
                        Exp.MUL(Exp.REAL),
                        exp')
        

  rule  (* tan x => 1/((cos x)^2) *)
	is_tan(fname) &
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(fname,exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   Exp.BINARY(Exp.CALL(Absyn.IDENT("cos"),[exp],b,c),
                                              Exp.POW(Exp.REAL),
                                              Exp.RCONST(2.0))),
                        Exp.MUL(Exp.REAL),
                        exp')

  rule	(* The derivative of logic expressions are non-existent *)
	Exp.print_exp_str e => e_str &
	Error.add_message(Error.NON_EXISTING_DERIVATIVE,[e_str])
	-----------------------------
	differentiate_exp(e as Exp.LBINARY(e1,op,e2),tv) 
	  => fail
	
  rule	differentiate_exp(e,tv) => e'
	-----------------------------
	differentiate_exp(Exp.LUNARY(op,e),tv) => Exp.LUNARY(op,e')

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2'
	-------------------------
	differentiate_exp(Exp.RELATION(e1,rel,e2),tv) => Exp.RELATION(e1',rel,e2')
	
  rule	differentiate_exp(e2,tv) => e2' &
	differentiate_exp(e3,tv) => e3'
	-------------------------
	differentiate_exp(Exp.IFEXP(e1,e2,e3),tv) => Exp.IFEXP(e1,e2',e3')

	(* der(x) *)
  rule	Exp.cref_equal(cr,tv) => true
	-------------------------------------------------
	differentiate_exp(Exp.CALL(a as Absyn.IDENT("der"),[exp as Exp.CREF(cr,_)],b,c),tv) 
	  => Exp.CALL(a,[exp,Exp.ICONST(2)],b,c)

	(* der(abs(x)) = sign(x)*der(x) *)
  rule	differentiate_exp(exp,tv) => exp' 
	-------------------------------------------------
	differentiate_exp(Exp.CALL(a as Absyn.IDENT("abs"),[exp],b,c),tv) 
	  => Exp.BINARY(Exp.CALL(Absyn.IDENT("sign"),[exp'],false,true),
			Exp.MUL(Exp.REAL),
			exp')

  rule	Util.list_map_1(expl,differentiate_exp,tv) => expl' 
	--------------------------------------------
	differentiate_exp(Exp.ARRAY(tp,b,expl),tv) => Exp.ARRAY(tp,b,expl')
	
  rule	Util.list_map_1(expl,differentiate_exp,tv) => expl'
	-----------------------
	differentiate_exp(Exp.TUPLE(expl),tv) => Exp.TUPLE(expl')

  rule	differentiate_exp(e,tv) => e'
	-----------------------
	differentiate_exp(Exp.CAST(tp,e),tv) => Exp.CAST(tp,e')

  rule	differentiate_exp(e,tv) => e'
	----------------------------
	differentiate_exp(Exp.ASUB(e,i),tv) => Exp.ASUB(e,i)

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	------------------------------
	differentiate_exp(Exp.REDUCTION(a,e1,b,e2),tv) 
	  => Exp.REDUCTION(a,e1',b,e2')

  rule	(* If the expression does not contain the variable,
	 the derivative is zero. For efficiency reasons this rule
	 is last. Otherwise expressions is allways traversed twice 
	 when differentiating.*)
	Exp.exp_contains(e,Exp.CREF(cr,Exp.REAL)) => false
	--------------------------------
	differentiate_exp(e,cr) => Exp.RCONST(0.0)

  rule	print "differentiate_exp " &
	Exp.print_exp_str e => s & print s &
	Exp.print_component_ref_str cr => s2 & 
	print " w.r.t: " & print s2 & 
	print " failed\n" 
	------------------------
	differentiate_exp(e,cr) => fail
	
end

relation is_tanh: Absyn.Path => () =

  axiom	is_tanh(Absyn.IDENT("tanh")) =>

  axiom	is_tanh(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("tanh")))) => ()
end

relation is_cosh: Absyn.Path => () =

  axiom	is_cosh(Absyn.IDENT("cosh")) =>

  axiom	is_cosh(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("cosh")))) => ()
end

relation is_sinh: Absyn.Path => () =

  axiom	is_sinh(Absyn.IDENT("sinh")) =>

  axiom	is_sinh(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("sinh")))) => ()
end

relation is_sin: Absyn.Path => () =

  axiom	is_sin(Absyn.IDENT("sin")) =>

  axiom	is_sin(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("sin")))) => ()
end

relation is_cos: Absyn.Path => () =

  axiom	is_cos(Absyn.IDENT("cos")) =>

  axiom	is_cos(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("cos")))) => ()
end

relation is_exp: Absyn.Path => () =

  axiom	is_exp(Absyn.IDENT("exp")) =>

  axiom	is_exp(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("exp")))) => ()
end

relation is_log: Absyn.Path => () =

  axiom	is_log(Absyn.IDENT("log")) =>

  axiom	is_log(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("log")))) => ()
end

relation is_log10: Absyn.Path => () =

  axiom	is_log10(Absyn.IDENT("log10")) =>

  axiom	is_log10(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("log10")))) => ()
end

relation is_sqrt: Absyn.Path => () =

  axiom	is_sqrt(Absyn.IDENT("sqrt")) =>

  axiom	is_sqrt(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("sqrt")))) => ()
end

relation is_tan: Absyn.Path => () =

  axiom	is_tan(Absyn.IDENT("tan")) =>

  axiom	is_tan(Absyn.QUALIFIED("Modelica",Absyn.QUALIFIED("Math",Absyn.IDENT("tan")))) => ()
end
