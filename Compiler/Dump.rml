(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Dump.rml
 ** module:      Dump
 ** description: debug printing
 **
 ** RCS: $Id$
 **
 ** Printing routines for debugging of the AST.  These relations do
 ** nothing but print the data structures to the standard output.
 **
 ** The main entrypoint for this module is the relation "dump" which
 ** takes an entire program as an argument, and prints it all in
 ** Modelica source form. The other interface relations can be used
 ** to print smaller portions of a program.
 **)


module Dump:
  
  with "Absyn.rml"
  with "Interactive.rml"							  

  type Ident = string

(* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation unparse_str: Absyn.Program => string
  relation unparse_class_list: (int, Absyn.Class list) => string 
  relation dump_istmt: Interactive.InteractiveStmts => ()
  relation direction_symbol: Absyn.Direction => string
  relation print_exp: Absyn.Exp => ()
  relation print_exp_str: Absyn.Exp => string
  relation print_code_str: Absyn.Code => string 
  relation print_component: Absyn.Component => () 
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_component_ref_str : Absyn.ComponentRef => string
  relation print_path : Absyn.Path => ()
  relation print_subscripts : Absyn.Subscript list => ()
  relation print_subscripts_str : Absyn.Subscript list => string 
  relation print_arraydim: Absyn.ArrayDim => ()
  relation print_arraydim_str: Absyn.ArrayDim => string 
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list_debug : (string, 'a list, 'a => (), string) => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation print_elementspec: Absyn.ElementSpec => ()
  relation print_named_arg: Absyn.NamedArg => () 
  relation print_import : Absyn.Import => () 
  relation op_symbol : Absyn.Operator => string
  relation print_bool : bool => ()
  relation print_bool_str : bool => string 
  relation print_select: (bool,string,string) => ()
  relation print_option : (('a option),('a => ())) => () 
  relation select_string: (bool,string,string) => string
  relation get_string_list : ('a list, 'a => string, string) => string
  relation get_option_str: ('a option, 'a => string) => string 
  relation get_option_str_default: ('a option, 'a => string,string) => string 
  relation get_option_with_concat_str: ('a option, 'a => string,string) => string 
  relation unparse_annotation_option: (int, Absyn.Annotation option) => string 
  relation unparse_within: (int, Absyn.Within) => string 
  relation unparse_import_str : Absyn.Import => string 
  relation indent_str: (int) => string 
  relation unparse_algorithm_str: (int, Absyn.AlgorithmItem) => string 
  relation variability_symbol: Absyn.Variability => string
  relation unparse_modification_str: Absyn.Modification => string 
  relation unparse_restriction_str : Absyn.Restriction => string
  relation unparse_comment_option: (Absyn.Comment option) => string
  relation unparse_comment_option_no_annotation: (Absyn.Comment option) => string
  relation unparse_each_str: (Absyn.Each) => string
  relation stdout: () => ()

  relation print_info:(Absyn.Info) => ()
  relation unparse_info_str:(Absyn.Info) => string  
end


with "Print.rml"
with "Util.rml"
with "Debug.rml"
(* adrpo -- not used
with "RTOpts.rml"
with "ClassInf.rml"
*)

(** relation: dump
 **
 ** Prints a program, i.e. the whole AST, to the Print buffer.
 **)
relation dump : Absyn.Program => () =
		
  rule	Print.printBuf "Absyn.PROGRAM([\n" &
	print_list(cs, print_class, ", ") &
	Print.printBuf "]," &
	dump_within(w) &
	Print.printBuf(")\n")
	------------------------
	dump Absyn.PROGRAM(cs,w) => ()
end

(** relation: unparse_str
 ** 
 ** Prettyprints the Program, i.e. the whole AST, to a string.
 **)
relation unparse_str : Absyn.Program => string =
	
  axiom	unparse_str Absyn.PROGRAM([],_) => ""
	
  rule	unparse_within(0,w) => s1 &
	unparse_class_list(0,cs) => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3,"\n") => str
	------------------------
	unparse_str Absyn.PROGRAM(cs,w) => str

  axiom	unparse_str (_) => "unparsing failed\n" 
end

(** relation: unparse_class_list
 **
 ** Prettyprints a list of classes
 **)
relation unparse_class_list: (int, Absyn.Class list) => string =

  axiom	unparse_class_list(_,[]) => ""
	
  rule	unparse_class_str(i,c,"","","") => s1 &
	unparse_class_list(i,cs) => s2 &
	Util.string_append_list([s1,";\n",s2]) => res
	---------------------
	unparse_class_list(i, c::cs) => res
end

(** relation: unparse_within
 **
 ** Prettyprints a within statement.
 **)
relation unparse_within: (int, Absyn.Within) => string =

  axiom unparse_within (_, Absyn.TOP) => ""
	
  rule	indent_str(i) => s1 &
	Absyn.path_string p => s2 &
	Util.string_append_list([s1, "within ", s2, ";\n"]) => str
	------------------------------
	unparse_within (i, Absyn.WITHIN(p)) => str
end

(** relation: dump_within
 **
 ** Dumps within to the Print buffer.
 **)
relation dump_within:(Absyn.Within) => () =

  rule	Print.printBuf "Absyn.TOP"
	-----------------
	dump_within(Absyn.TOP) 

  rule	Print.printBuf ("Absyn.WITHIN(") & 
	dump_path p &
	Print.printBuf "\n"
	-------------------
	dump_within(Absyn.WITHIN(p))
end

(** relation: unparse_class_str
 **
 ** Prettyprints a Class.
 **)
relation unparse_class_str: (int, Absyn.Class,string,string,string) => string =
	
  rule	indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	int_add(i,1) => i' &
	unparse_class_part_str_lst(i',parts,true) => s4 &
	unparse_string_comment_option(optcmt) => s5 &
	Util.string_append_list([is, s2', s1, s2, re, io, s3, " ", n, s5, "\n", s4, is, "end ", n]) => str
	-----------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,optcmt),_),fi,re,io) => str

  rule	indent_str(indent) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 & 
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_elementattr_str attr => s4 &
	string_append(s1,s2) => s5 &
	Absyn.path_string i => s6 &
	get_option_str(dim,print_arraydim_str) => s7 &
	unparse_mod1_str m => s8 &
	unparse_comment_option(optcmt) => s9 &
	Util.string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= ",s4,s5,s6,s7,s8,s9]) 
	  => str
	------------------------------
	unparse_class_str(indent,Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED(i,dim,attr,m,optcmt),_),fi,re,io) => str
	
  rule	indent_str(i) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_enumliterals(l) => s4 &
	unparse_comment_option(cmt) => s5 &
	Util.string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= enumeration(",s4,")",s5]) => str
	-------------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(Absyn.ENUMLITERALS(l),cmt),_),fi,re,io) => str    

  rule	indent_str(i) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_comment_option(cmt) => s5 &
	Util.string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= enumeration(:)",s5]) => str
	-------------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(ENUM_COLON,cmt),_),fi,re,io) => str    

  rule	indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	int_add(i,1) => i' &
	unparse_class_part_str_lst(i',parts,true) => s4 &
	unparse_mod1_str(cmod) => s5 &
	unparse_string_comment_option(optcmt) => s6 &
	Util.string_append_list([is, s2', s1, s2, re, io, s3, " extends ",
				 name, s5, s6, "\n", s4, is, "end ", name]) => str
	-----------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.CLASS_EXTENDS(name,cmod,optcmt,parts),_),fi,re,io) => str

  rule  indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	Absyn.path_string fname => s4 &
	Util.string_delimit_list(vars,", ") => s5 &
	Util.string_append_list([is, s2', s1, s2, re, io, s3," ",n, " = der(",
				 s4,", ",s5,")"]) => str
	---------------------------
	unparse_class_str(i,Absyn.CLASS(n,p,f,e,r,Absyn.PDER(fname,vars),_),fi,re,io) => str 

end 

(** relation: unparse_comment_option
 **
 ** Prettyprints a Comment.
 **)
relation unparse_comment_option: (Absyn.Comment option) => string =

  axiom unparse_comment_option(NONE) => ""
	
  rule	unparse_annotation_option(0,annopt) => s1 &
	Util.string_append_list([" \"",cmt,"\"", s1]) => str
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,SOME(cmt)))) => str
	
  rule	unparse_annotation_option(0,annopt) => str 
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,NONE))) => str
	
end

(** relation: unparse_comment_option_no_annotation
 **
 ** Prettyprints a Comment without printing the annotation part.
 **)
relation unparse_comment_option_no_annotation: (Absyn.Comment option) => string =

  rule	Util.string_append_list([" \"",cmt,"\""]) => str
	---------------------------------------------
	unparse_comment_option_no_annotation(SOME(Absyn.COMMENT(_,SOME(cmt)))) 
	  => str
 
	axiom unparse_comment_option_no_annotation(_) => ""
end

(** relation: dump_comment_option
 **
 ** Prints a Comment to the Print buffer.
 **)
relation dump_comment_option: (Absyn.Comment option) => () =

  rule	Print.printBuf "NONE"
	------------------------
	dump_comment_option(NONE) => ()
	
  rule	Print.printBuf "SOME(Absyn.COMMENT(" &
	dump_annotation_option(annopt) => () &
	Util.string_append_list(["SOME(\"",cmt,
				 "\")))"]) => str &
 	Print.printBuf str 
	---------------------------------------------
	dump_comment_option(SOME(Absyn.COMMENT(annopt,SOME(cmt)))) => ()
	
  rule	Print.printBuf "SOME(Absyn.COMMENT(" &
	dump_annotation_option(annopt) => () &
	Print.printBuf ",NONE))" 			 
	---------------------------------------------
	dump_comment_option(SOME(Absyn.COMMENT(annopt,NONE))) => ()	
end

(** relation: dump_annotation_option
 **
 ** Dumps an annotation option to the Print buffer.
 **)
relation dump_annotation_option: (Absyn.Annotation option) => () =	

  rule	Print.printBuf "NONE" 
	-------------------------
	dump_annotation_option(NONE)

  rule	Print.printBuf "SOME(Absyn.ANNOTATION(" &
	print_mod1 mod &
	Print.printBuf "))" 
	----------------------------
	dump_annotation_option(SOME(Absyn.ANNOTATION(mod))) => ()

end

(** relation: unparse_enumliterals
 **
 ** Prettyprints enumeration literals, each consisting of an identifier
 ** and an optional comment.
 **)
relation unparse_enumliterals : Absyn.EnumLiteral list => string =
	
  axiom	unparse_enumliterals([]) => ""
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_enumliterals(a::b)=> s2 &
	Util.string_append_list([str,s1,", ",s2]) => res
	---------------------------
 	unparse_enumliterals(Absyn.ENUMLITERAL(str,optcmt)::a::b) => res
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_comment_option(optcmt2) => s2 &
	Util.string_append_list([str," ",s1,", " ,str2,
				 " ",s2]) => res
	---------------------------
	unparse_enumliterals([Absyn.ENUMLITERAL(str,optcmt),Absyn.ENUMLITERAL(str2,optcmt2)]) => res
end

(** relation: print_enumliterals
 **
 ** Prints enumeration literals, each consisting of an identifier
 ** and an optional comment to the Print buffer.
 **)
relation print_enumliterals : Absyn.EnumLiteral list => () =

  rule	Print.printBuf "[" &
	print_enumliterals2(lst) &
	Print.printBuf "]" 
	------------------------
	print_enumliterals (lst) =>  ()
end

(** relation: print_enumliterals2
 **
 ** Helper relation to print_enumliterals
 **)
relation print_enumliterals2 : Absyn.EnumLiteral list => () =

  axiom	print_enumliterals2([]) => ()
	
  rule	Print.printBuf "Absyn.ENUMLITERAL(\"" &
	Print.printBuf str &
	Print.printBuf "\"," &
	dump_comment_option(optcmt) &
	Print.printBuf "), " &
	print_enumliterals2(a::b) 
	---------------------------
	print_enumliterals2(Absyn.ENUMLITERAL(str,optcmt)::a::b) => ()
	
  rule	Print.printBuf "Absyn.ENUMLITERAL(\"" &
	Print.printBuf str &
	Print.printBuf "\"," &
	dump_comment_option(optcmt) &
	Print.printBuf "), Absyn.ENUMLITERAL(\"" &
	Print.printBuf str2 &
	Print.printBuf "\"," &
	dump_comment_option(optcmt2) &
	Print.printBuf ")"
	---------------------------
	print_enumliterals2([Absyn.ENUMLITERAL(str,optcmt),Absyn.ENUMLITERAL(str2,optcmt2)]) => ()
end

(** relation: unparse_restriction_str
 **
 ** Prettyprints the class restriction.
 **)
relation unparse_restriction_str : Absyn.Restriction => string =
	
  axiom	unparse_restriction_str Absyn.R_CLASS			=> "class"
  axiom	unparse_restriction_str Absyn.R_MODEL			=> "model"
  axiom	unparse_restriction_str Absyn.R_RECORD			=> "record"
  axiom	unparse_restriction_str Absyn.R_BLOCK			=> "block"
  axiom	unparse_restriction_str Absyn.R_CONNECTOR		=> "connector"
  axiom	unparse_restriction_str Absyn.R_EXP_CONNECTOR		=> "expandable connector"
  axiom	unparse_restriction_str Absyn.R_TYPE			=> "type"
  axiom	unparse_restriction_str Absyn.R_PACKAGE			=> "package"
  axiom	unparse_restriction_str Absyn.R_FUNCTION			=> "function"
  axiom	unparse_restriction_str  Absyn.R_PREDEFINED_INT		=> "Integer"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_REAL		=> "Real"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_STRING	=> "String"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_BOOL		=> "Boolean"
	
end

(** relation: dump_istmt
 **
 ** Dumps an interactive statement to the Print buffer.
 **)
relation dump_istmt : Interactive.InteractiveStmts => () =

  rule	Print.printBuf ("IALG(") &
	print_algorithmitem(alg) => () &
	Print.printBuf ")\n" 
	--------------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IALG(alg)],_)) => ()
	
  rule	Print.printBuf ("IEXP(") &
	print_exp(expr) &
	Print.printBuf ")\n" 
	----------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IEXP(expr)],_)) => ()
	
  rule Print.printBuf "IALG(" &
	print_algorithmitem(alg) => () &
	Print.printBuf "," &
	dump_istmt(Interactive.ISTMTS(l,sc)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IALG(alg)::l,sc)) => ()
	
  rule Print.printBuf "IEXP(" &
	print_exp(expr) => () &
	Print.printBuf "," &
	dump_istmt(Interactive.ISTMTS(l,sc)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IEXP(expr)::l,sc)) => ()
	
  axiom	dump_istmt(_) => ()
end

(** relation: print_info
 **
 ** Dumps an Info to the Print buffer.
 ** author: adrpo, 2006-02-05
 **)
relation print_info: Absyn.Info => () =

	rule	Print.printBuf("Absyn.INFO(\"") &
			Print.printBuf filename &
			Print.printBuf("\", ") &
			print_bool(isReadOnly) &
			Print.printBuf(", ") &	
			int_string sline => s1 &
		    Print.printBuf s1 &
			Print.printBuf(", ") &
			int_string scol => s2 &
		    Print.printBuf s2 &
			Print.printBuf(", ") &	
			int_string eline => s3 &
		    Print.printBuf s3 &
			Print.printBuf(", ") &
			int_string ecol => s4 &
		    Print.printBuf s4 &
			Print.printBuf(")")
			-----------------------------------------------------------------
			print_info(Absyn.INFO(filename,isReadOnly,sline,scol,eline,ecol)) => ()
end

(** relation: unparse_info_str
 **
 ** Translates Info to a string representation
 ** author: adrpo, 2006-02-05
 **)
relation unparse_info_str: Absyn.Info => string =

	rule	select_string(isReadOnly,"readonly","writable") => s1 &
			int_string sline => s2 &
			int_string scol => s3 &
			int_string eline => s4 &
			int_string ecol => s5 &
		    Util.string_append_list(
		    		   ["Absyn.INFO(\"", 
		                filename, "\", ", 
		                s1, ", ", 
		                s2, ", ", 
		                s3, ", ", 
		                s4, ", ", 
		                s5, ")\n"]) => str
			------------------------------------------------------------------------
			unparse_info_str(Absyn.INFO(filename,isReadOnly,sline,scol,eline,ecol)) => str
			
end

(** relation: print_class
 **
 ** Dumps a Class to the Print buffer.
 ** changed by adrpo, 2006-02-05 to use print_info.
 **)
relation print_class: Absyn.Class => () =
	
  rule	Print.printBuf("Absyn.CLASS(\"") &
	Print.printBuf n &
	Print.printBuf("\", ") &
	print_bool(p) &
	Print.printBuf(", ") &
	print_bool(f) &
	Print.printBuf(", ") &
	print_bool(e) &
	Print.printBuf(", ") &
	print_class_restriction(r) &
	Print.printBuf(", ") &
	print_classdef(cdef) &
	Print.printBuf(", ") &
	print_info(info) &
	Print.printBuf(")\n")
	----------------------------------------
	print_class(Absyn.CLASS(n,p,f,e,r,cdef,info)) => ()
end

(** relation: print_classdef
 **
 ** Prints a ClassDef to the Print buffer.
 **)
relation print_classdef: Absyn.ClassDef => () =
	
  rule	Print.printBuf "Absyn.PARTS([" &
	print_list_debug("print_classdef",parts, print_class_part, ", ") &
	Print.printBuf "], " &
	print_string_comment_option comment  &
	Print.printBuf ")" 
	----------------------------
	print_classdef(Absyn.PARTS(parts,comment))

  rule	Print.printBuf "Absyn.DERIVED(" &
	dump_path(path) &
	Print.printBuf ", " &
	print_arraydim_opt(arrdim) &
	Print.printBuf ", " &
	print_elementattr(attr) &
	Print.printBuf ",[" &
	print_list(earg,print_element_arg,",") &
	Print.printBuf "], " &
	unparse_comment_option comment => s &
	Print.printBuf s &
	Print.printBuf ")" 
	----------------------------
	print_classdef(Absyn.DERIVED(path,arrdim,attr,earg,comment))

  rule	Print.printBuf "Absyn.ENUMERATION(" &
	print_enumliterals (enumlst) &
	Print.printBuf ", " &
	dump_comment_option comment  &
	Print.printBuf ")" 
	----------------------------
	print_classdef(Absyn.ENUMERATION(Absyn.ENUMLITERALS(enumlst), comment))

  rule	Print.printBuf "Absyn.ENUMERATION( :, " &
	dump_comment_option comment  &
	Print.printBuf ")" 
	----------------------------
	print_classdef(Absyn.ENUMERATION(Absyn.ENUM_COLON, comment))

  rule	Print.printBuf "Absyn.OVERLOAD( fill in )"
 	------------------------
 	print_classdef(Absyn.OVERLOAD(_,_))
end

(** relation: print_class_restriction
 **
 ** Prints the class restriction to the Print buffer.
 *)
relation print_class_restriction: Absyn.Restriction => () =

  rule	Print.printBuf "Absyn.R_CLASS" 
	-----------------------
	print_class_restriction Absyn.R_CLASS

  rule	Print.printBuf "Absyn.R_MODEL" 
	-----------------------
	print_class_restriction Absyn.R_MODEL

  rule	Print.printBuf "Absyn.R_RECORD" 
	-----------------------
	print_class_restriction Absyn.R_RECORD

  rule	Print.printBuf "Absyn.R_BLOCK" 
	-----------------------
	print_class_restriction Absyn.R_BLOCK

  rule	Print.printBuf "Absyn.R_CONNECTOR" 
	-----------------------
	print_class_restriction Absyn.R_CONNECTOR

  rule	Print.printBuf "Absyn.R_EXP_CONNECTOR" 
	-----------------------
	print_class_restriction Absyn.R_EXP_CONNECTOR

  rule	Print.printBuf "Absyn.R_TYPE" 
	-----------------------
	print_class_restriction Absyn.R_TYPE

  rule	Print.printBuf "Absyn.R_PACKAGE" 
	-----------------------
	print_class_restriction Absyn.R_PACKAGE

  rule	Print.printBuf "Absyn.R_FUNCTION" 
	-----------------------
	print_class_restriction Absyn.R_FUNCTION

  rule	Print.printBuf "Absyn.R_ENUMERATION" 
	-----------------------
	print_class_restriction Absyn.R_ENUMERATION

  rule	Print.printBuf "Absyn.R_PREDEFINED_INT" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_INT

  rule	Print.printBuf "Absyn.R_PREDEFINED_REAL" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_REAL

  rule	Print.printBuf "Absyn.R_PREDEFINED_STRING" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_STRING

  rule	Print.printBuf "Absyn.R_PREDEFINED_BOOL" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_BOOL

  rule	Print.printBuf "Absyn.R_PREDEFINED_ENUM" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_ENUM

  axiom	print_class_restriction _

end

(** relation: print_class_modification
 **
 ** Prints a class modification to a print buffer.
 **)
relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	Print.printBuf "(" & print_list_debug("print_class_modification",l,print_element_arg,",") & Print.printBuf ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

(** relation: unparse_class_modification_str
 **
 ** Prettyprints a class modification to a string.
 **)
relation unparse_class_modification_str: Absyn.Modification => string =

  axiom	unparse_class_modification_str(Absyn.CLASSMOD([],_)) => ""
	
  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &	
	string_append("(",s1) => s2 &
	string_append(s2,")") => str 
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(l,NONE)) => str

  rule	print_exp_str e => s1 &
	Util.string_append_list(["=",s1]) => str
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(_,SOME(e))) => str
end


(** relation: print_element_arg
 **
 ** Prints an ElementArg to the Print buffer.
 **)
relation print_element_arg =
	
  rule	Print.printBuf "Absyn.MODIFICATION(" &
	print_bool(f)  &
	Print.printBuf ", " &
	dump_each each &
	Print.printBuf ", " &
	print_component_ref(r) &
	Print.printBuf ", " &
	print_opt_modification(optm) &
	Print.printBuf ", " &
	print_string_comment_option optcmt &
	Print.printBuf ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,each,r,optm,optcmt))

  rule	Print.printBuf "Absyn.REDECLARATION(" &
	print_bool(f) &
	print_elementspec spec &
	Print.printBuf ",_)"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,keywords,each,spec,_))

end

(** relation: unparse_element_arg_str
 **
 ** Prettyprints an ElementArg to a string.
 **)
relation unparse_element_arg_str: (Absyn.ElementArg) => string =
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","") => s2 &
	print_component_ref_str(r) => s3 &
	unparse_opt_modification_str(optm) => s4 &
	unparse_string_comment_option(optstr) => s5 &
	Util.string_append_list([s1, s2, s3, s4, s5]) => str
	-------------------------------------------
	unparse_element_arg_str(Absyn.MODIFICATION(f,each,r,optm,optstr)) => str
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	unparse_redeclarekeywords (keywords) => s3 &
	unparse_elementspec_str(0, spec,s2,"","") => s4 &
	unparse_constrainclass_opt_str(constr) => s5 &
	Util.string_append_list([s1,s2,s3,s4," ",s5]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,keywords,each, spec,constr)) => str

end

(** relation: unparse_redeclarekeywords
 ** 
 ** Prettyprints the redeclare keywords, i.e 'replaceable' and 'redeclare'
 **)
relation unparse_redeclarekeywords: Absyn.RedeclareKeywords => string =

  axiom	unparse_redeclarekeywords Absyn.REDECLARE => "redeclare "
  axiom	unparse_redeclarekeywords Absyn.REPLACEABLE => "replaceable "
  axiom	unparse_redeclarekeywords Absyn.REDECLARE_REPLACEABLE => "redeclare replaceable "
end

(** relation: unparse_each_str
 **
 ** Prettyprints the each keyword.
 **)
relation unparse_each_str: (Absyn.Each) => string =

  axiom	unparse_each_str(Absyn.EACH) => "each "

  axiom	unparse_each_str(Absyn.NON_EACH) => ""
end

(** relation: dump_each
 **
 ** Print the each keyword to the Print buffer
 **)
relation dump_each: (Absyn.Each) => () =

  rule	Print.printBuf "Absyn.EACH"
	--------------------------
	dump_each(Absyn.EACH) 

  rule	Print.printBuf "Absyn.NON_EACH"
	------------------
	dump_each(Absyn.NON_EACH)
end

(** relation: print_class_part
 **
 ** Prints the ClassPart to the Print buffer.
 **)
relation print_class_part: Absyn.ClassPart => () =

  rule	Print.printBuf "Absyn.PUBLIC(" & 
	print_elementitems(el) & Print.printBuf ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule	Print.printBuf "Absyn.PROTECTED(" & 
	print_elementitems(el) & Print.printBuf ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule	Print.printBuf "Absyn.EQUATIONS([" &
	print_list(eqs,print_equationitem,", ") &
	Print.printBuf "])"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))

  rule	Print.printBuf "Absyn.INITIALEQUATIONS([" &
	print_list(eqs,print_equationitem, ", ") &
	Print.printBuf "])"
	--------------------------------------
	print_class_part(Absyn.INITIALEQUATIONS(eqs))
	
  rule	Print.printBuf "Absyn.ALGORITHMS(" &
	print_list(algs,print_algorithmitem, ", ") &
	Print.printBuf ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(algs))

  rule	Print.printBuf "Absyn.INITIALALGORITHMS([" &
	print_list(algs,print_algorithmitem,", ") &
	Print.printBuf "])"
	--------------------------------------
	print_class_part(Absyn.INITIALALGORITHMS(algs))

  rule	Print.printBuf "Absyn.EXTERNAL(" &
	print_external_decl (edecl) &
	Print.printBuf ")"
	-------------------
	print_class_part(Absyn.EXTERNAL(edecl,_))

end

(** relation: print_external_decl
 **
 ** Prints an external declaration to the Print buffer.
 **)
relation print_external_decl : Absyn.ExternalDecl => () =

  rule	get_option_str (id, identity) => idstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	Util.string_append_list([idstr, ", ", crefstr, ", (",
				 expstr, ")"]) => str &
	Print.printBuf str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, NONE, cref, exps,_)

  rule	get_option_str (id, identity) => idstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	Util.string_append_list([idstr, ", \"", lang, "\", ", crefstr, ", (",
				 expstr, ")"]) => str &
	Print.printBuf str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, SOME(lang), cref, exps,_)

end

(** relation: unparse_class_part_str_lst
 **
 ** Prettyprints a ClassPart list to a string.
 **)
relation unparse_class_part_str_lst: (int, Absyn.ClassPart list,bool) 
	  => string =

  axiom	unparse_class_part_str_lst (_,[],false) => ""

  rule	unparse_class_part_str(i,x,skippublic) => s1 &
	unparse_class_part_str_lst(i,xs,false) => s2 &
	string_append(s1,s2) => res
	----------------------
	unparse_class_part_str_lst(i,x::xs,skippublic) => res
end

relation unparse_class_part_str: (int, Absyn.ClassPart,bool) => string =

  axiom	unparse_class_part_str(i, Absyn.PUBLIC([]),_) => ""
  axiom	unparse_class_part_str(i, Absyn.PROTECTED([]),_) => ""
  axiom	unparse_class_part_str(i, Absyn.EQUATIONS([]),_) => ""
  axiom	unparse_class_part_str(i, Absyn.INITIALEQUATIONS([]),_) => ""
  axiom	unparse_class_part_str(i, Absyn.ALGORITHMS([]),_) => ""
  axiom	unparse_class_part_str(i, Absyn.INITIALALGORITHMS([]),_) => ""

  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.PUBLIC(el),true) => str
	
  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"public \n",s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.PUBLIC(el),false) => str

  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"protected \n",s1]) => str 
	---------------------------------------
	unparse_class_part_str(i, Absyn.PROTECTED(el),_) => str
	
  rule	unparse_equationitem_str_lst(i,eqs,";\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list(["\n",is,"equation \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.EQUATIONS(eqs),_) => str
				
  rule	unparse_equationitem_str_lst(i,eqs,";\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list(["\n",is,"initial equation \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.INITIALEQUATIONS(eqs),_) => str

  rule	unparse_algorithm_str_lst(i,eqs,"\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"algorithm \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.ALGORITHMS(eqs),_) => str

  rule	unparse_algorithm_str_lst(i,eqs,"\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"initial algorithm \n",s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.INITIALALGORITHMS(eqs),_) => str

  rule	get_extlang_str(lang) => langstr &
	print_component_ref_str output => outputstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	indent_str(i) => is &
	unparse_annotation_option (i,ann) => annstr &
	unparse_annotation_option_semi(i,ann2) => annstr2 &
	Util.string_append_list(["\n", is, "external ",langstr," ", outputstr, "=",ident,"(",expstr,") ",annstr,";",annstr2,"\n"]) => str
	--------------------------------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,SOME(output),expl,ann),ann2),_)
	    => str

  rule	get_extlang_str(lang) => langstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	indent_str(i) => is &
	unparse_annotation_option (i,ann) => annstr &
	unparse_annotation_option_semi(i,ann2) => annstr2 &
	Util.string_append_list(["\n", is, "external ", langstr," ",ident,"(",expstr,") ",annstr,"; ",annstr2,"\n"]) => str
	--------------------------------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,NONE,expl,ann),ann2),_) 
	    => str

  rule	indent_str(i) => is &
	get_extlang_str(lang) => langstr &
	unparse_annotation_option (i,ann) => annstr &
	unparse_annotation_option_semi(i,ann2) => annstr2 &
	Util.string_append_list(["\n",is,"external ",langstr," ",annstr,";",annstr2,"\n"]) => res
	-----------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(NONE,lang,NONE,_,ann),ann2),_) 
	    => res
end

(** relation: get_extlang_str
 **
 ** Prettyprints the external function language string to a string.
 **)
relation get_extlang_str: (string option) => string =
	
  axiom	get_extlang_str(NONE) => ""

  rule	Util.string_append_list(["\"",str,"\""]) => res
	-------------
	get_extlang_str(SOME(str)) => res
end

(** relation: print_elementitems
 **
 ** Print a list of ElementItems to the Print buffer.
 **)
relation print_elementitems: Absyn.ElementItem list => () =

  rule	Print.printBuf "[" &
	print_elementitems2 (elts) &
	Print.printBuf "]" 
	------------------
	print_elementitems elts => ()
end

(** relation: print_elementitems2
 ** 
 ** Helper relation to print_elementitems
 **)
relation print_elementitems2: Absyn.ElementItem list => () =

  axiom print_elementitems2 [] => ()

  rule  Print.printBuf "Absyn.ELEMENTITEM(" &
	print_element e &
	Print.printBuf ")" 
	---------------
	print_elementitems2[ Absyn.ELEMENTITEM(e)]

  rule	Print.printBuf "Absyn.ANNOTATIONITEM(" &
	print_annotation a &
	Print.printBuf ")" 
	------------------
	print_elementitems2([Absyn.ANNOTATIONITEM(a)])
	
  rule	Print.printBuf "Absyn.ELEMENTITEM(" &
	print_element e &
	Print.printBuf "), " &
	print_elementitems2 els
	---------------
	print_elementitems2 Absyn.ELEMENTITEM(e)::els 

  rule	Print.printBuf "Absyn.ANNOTATIONITEM(" &
	print_annotation a &
	Print.printBuf "), " &
	print_elementitems2 els
	------------------
	print_elementitems2 Absyn.ANNOTATIONITEM(a)::els

  rule	Print.printBuf "Error print_elementitems\n"
	--------------
	print_elementitems2 _ 
end

(** relation: print_annotation
 **
 ** Prints an annotation to the Print buffer.
 **)
relation print_annotation: Absyn.Annotation => () =	
  rule	Print.printBuf "ANNOTATION(" &
	print_modification Absyn.CLASSMOD(mod,NONE) &
	Print.printBuf ")"
	---------
	print_annotation(Absyn.ANNOTATION(mod))
end

(** relation: unparse_elementitem_str_lst
 **
 ** Prettyprints a list of ElementItem to a string.
 **)
relation unparse_elementitem_str_lst: (int(* indent*), Absyn.ElementItem list) => string =

  axiom	unparse_elementitem_str_lst(_, []) => ""
	
  rule	unparse_elementitem_str(i, x) => s1 &
	unparse_elementitem_str_lst(i, xs) => s2 &
	Util.string_append_list([s1, "\n", s2]) => res
	----------------
	unparse_elementitem_str_lst(i, x::xs) => res
end

(** relation: unparse_elementitem_str
 **
 ** Prettyprints and ElementItem.
 **)
relation unparse_elementitem_str: (int(* indent*), Absyn.ElementItem) 
	  => string =

  rule	unparse_element_str(i, e) => str
	----------------------------
	unparse_elementitem_str (i, Absyn.ELEMENTITEM(e)) => str

  rule	unparse_annotation_option (i,SOME(a)) => s1 &
	string_append(s1,";") => str 
	-------------------------------
	unparse_elementitem_str(i, Absyn.ANNOTATIONITEM(a)) => str
	
end

(** relation: unparse_annotation_option_semi
 **
 ** Prettyprint an annotation and a semicolon if annoation present.
 **)
relation unparse_annotation_option_semi: (int, Absyn.Annotation option) 
	  => string =	

  axiom	unparse_annotation_option_semi(_,NONE) => ""

  rule	unparse_annotation_option(i,ann) => s &
	string_append(s,";") => res
	--------------------------
	unparse_annotation_option_semi(i,ann) => res
end

(** relation: unparse_annotation_option
 **
 ** Prettyprint an annotation.
 **)
relation unparse_annotation_option: (int, Absyn.Annotation option) => string =	
  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	string_append(" annotation",s1) => s2 &
	string_append(s2,"") => str
	----------------------------
	unparse_annotation_option(0, SOME(Absyn.ANNOTATION(mod))) => str

  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	indent_str(i) => is &
	Util.string_append_list([is,"annotation",s1]) => str 
	----------------------------
	unparse_annotation_option(i, SOME(Absyn.ANNOTATION(mod))) => str

  axiom	unparse_annotation_option(_, NONE) => ""
end

(** relation: print_element
 **
 ** Prints an Element to the Print buffer.
 ** changed by adrpo, 2006-02-06 to use print_info and dump Absyn.TEXT also 
 **)
relation print_element: Absyn.Element => () =
	
  rule	Print.printBuf "Absyn.ELEMENT(" & 
	print_bool(final) &
	Print.printBuf ", _" &
	Print.printBuf ", " &
	print_innerouter inout &
	Print.printBuf ", \"" &
	Print.printBuf name &
	Print.printBuf "\", " &
	print_elementspec spec & 
	Print.printBuf ", " &
	print_info info &
	Print.printBuf "), NONE)"
	---------------------------
	print_element (Absyn.ELEMENT(final,repl,inout,name,spec,info,NONE))

  rule	Print.printBuf "Absyn.ELEMENT(" & 
	print_bool(final) &
	Print.printBuf ", _" &
	Print.printBuf ", " &
	print_innerouter inout &
	Print.printBuf ", \"" &
	Print.printBuf name &
	Print.printBuf "\", " &
	print_elementspec spec & 
	Print.printBuf ", " &
	print_info info &
	Print.printBuf ", SOME(...))"
	---------------------------
	print_element (Absyn.ELEMENT(final,repl,inout,name,spec,info,SOME(_)))
	
  rule	Print.printBuf "Absyn.TEXT(" & 
	Print.printBuf "SOME(\"" &
	Print.printBuf name &
	Print.printBuf "\"), \"" &
	Print.printBuf text &
	Print.printBuf "\", " &
	print_info info &
	Print.printBuf ")"
	---------------------------
	print_element (Absyn.TEXT(SOME(name), text, info))	
	
  rule	Print.printBuf "Absyn.TEXT(" & 
	Print.printBuf "NONE, \"" &
	Print.printBuf text &
	Print.printBuf "\", " &
	print_info info &
	Print.printBuf ")"
	---------------------------
	print_element (Absyn.TEXT(NONE, text, info))	

end

(** relation: unparse_element_str
 **
 ** Prettyprints and Element to a string.
 ** changed by adrpo 2006-02-05 to print also Absyn.TEXT as a comment
 ** TODO?? - should we also dump info as a comment for an element??
 **        - should we dump Absyn.TEXT as an Annotation Item??
 **)
relation unparse_element_str: (int, Absyn.Element) => string = 

  rule	select_string(final, "final ", "") => s1 &
	unparse_redeclarekeywords repl => s2 &
	unparse_innerouter_str inout => s3 &
	unparse_elementspec_str(i, spec,s1,s2,s3) => s4 &	
	unparse_constrainclass_opt_str(constr) => s5 &
    Util.string_append_list([s4, s5, ";"]) => str
	----------------------------
	unparse_element_str(i, Absyn.ELEMENT(final,SOME(repl),inout,_,spec,info,constr)) => str

  rule	select_string(final, "final ", "") => s1 &
	unparse_innerouter_str inout => s3 &
	unparse_elementspec_str(i, spec,s1,"",s3) => s4 &	
	unparse_constrainclass_opt_str(constr) => s5 &
        Util.string_append_list([s4,s5, ";"]) => str
	----------------------------
	unparse_element_str(i, Absyn.ELEMENT(final,NONE,inout,_,spec,info,constr)) => str

  rule	unparse_info_str(info) => s1 &
  		Util.string_append_list(["/* Absyn.TEXT(SOME(\"",name,"\"), \"",text,"\", ", s1, "); */"]) => str
	----------------------------
	unparse_element_str(i, Absyn.TEXT(SOME(name),text,info)) => str

  rule	unparse_info_str(info) => s1 &
  		Util.string_append_list(["/* Absyn.TEXT(NONE, \"",text,"\", ", s1, "); */"]) => str
	----------------------------
	unparse_element_str(i, Absyn.TEXT(NONE,text,info)) => str
	
end

(** relation: unparse_constrainclass_opt_str
 ** author: PA
 **
 ** This relation prettyprints a ConstrainClass option to a string.
 **)
relation unparse_constrainclass_opt_str: (Absyn.ConstrainClass option) 
	  => string =

  axiom	unparse_constrainclass_opt_str(NONE) => ""

  rule	unparse_constrainclass_str(constr) => res
	----------------------
	unparse_constrainclass_opt_str(SOME(constr)) => res
end

(** relation: unparse_constrainclass_str
 ** author: PA
 **
 ** This relation prettyprints a ConstrainClass to a string.
 **)
relation unparse_constrainclass_str: (Absyn.ConstrainClass) => string =

  rule	unparse_elementspec_str(0,spec,"","","") => s1 &
	unparse_comment_option(cmt) => s2 &
	string_append(s1,s2) => res
	---------------------------------
	unparse_constrainclass_str(Absyn.CONSTRAINCLASS(spec,cmt)) => res

end

(** relation: print_innerouter
 **
 ** Prints the inner or outer keyword to the Print buffer.
 **)
relation print_innerouter: Absyn.InnerOuter => () =
   rule Print.printBuf "Absyn.INNER"
	----------------------------
	print_innerouter(Absyn.INNER)

   rule Print.printBuf "Absyn.OUTER"
        ----------------------------
        print_innerouter(Absyn.OUTER)

   rule Print.printBuf "Absyn.INNEROUTER "
        ----------------------------------
        print_innerouter(Absyn.INNEROUTER)

   rule Print.printBuf "Absyn.UNSPECIFIED "
        ----------------------------------
        print_innerouter(Absyn.UNSPECIFIED)
end

(** relation: unparse_innerouter_str
 **
 ** Prettyprints the inner or outer keyword to a string.
 **)
relation unparse_innerouter_str: Absyn.InnerOuter => string =
	
  axiom	unparse_innerouter_str(Absyn.INNER) => "inner "

  axiom	unparse_innerouter_str(Absyn.OUTER) => "outer "

  axiom	unparse_innerouter_str(Absyn.INNEROUTER) => "inner outer "

  axiom	unparse_innerouter_str(Absyn.UNSPECIFIED) => ""
end

(** relation: print_elementspec
 **
 ** Prints the ElementSpec to the Print buffer.
 **)
relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	Print.printBuf "Absyn.CLASSDEF(" & 
	print_bool(repl) &
	Print.printBuf ", " &
	print_class cl & 
	Print.printBuf ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
  rule	Print.printBuf "Absyn.EXTENDS(" & 
	dump_path p & Print.printBuf ", [" &
	print_list_debug("print_elementspec",l,print_element_arg,",") & 
	Print.printBuf "])"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	Print.printBuf "Absyn.COMPONENTS(" &
	print_elementattr(attr) & Print.printBuf "," &
	dump_path(t) & Print.printBuf ",[" &
	print_list_debug("print_elementspec",cs, print_componentitem, ",") &
	Print.printBuf "])"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	Print.printBuf "Absyn.IMPORT(" &
	print_import i &
	Print.printBuf ")"
	--------
	print_elementspec(Absyn.IMPORT(i,_))

  rule	Print.printBuf " ##ERROR## "
	-------------------
	print_elementspec(_)

end

(** relation: unparse_elementspec_str
 **
 ** Prettyprints the ElementSpec to a string.
 **)
relation unparse_elementspec_str: (int,(*indent*) 
				   Absyn.ElementSpec,
				   string,
				   string,
				   string) 
	  => string =
	
  rule	unparse_class_str(i,cl,f,r,io) => str 
	-------------------------
	unparse_elementspec_str(i, Absyn.CLASSDEF(repl,cl),f,r,io) => str
	
  rule	Absyn.path_string p => s1 &
	string_append("extends ",s1) => s2 &
	indent_str(i) => is &
	Util.string_append_list([is,f,r,io,s2]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.EXTENDS(p,[]),f,r,io) => str

  rule	Absyn.path_string p => s1 &
	string_append("extends ",s1) => s2 &
	get_string_list(l,unparse_element_arg_str,",") => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,f,r,io,s2,"(",s3,")"]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.EXTENDS(p,l),f,r,io) => str

  rule	Absyn.path_string(t) => s1 &
	unparse_elementattr_str(attr) => s2 &
	unparse_arraydim_in_attr(attr) => ad &
	get_string_list(cs, unparse_componentitem_str, ",") => s3 &
	indent_str(i) => is &
	Util.string_append_list([is, f,r,io,s2, s1,ad, " ",  s3]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.COMPONENTS(attr,t,cs),f,r,io) => str
	
  rule	unparse_import_str i => s1 &
	string_append("import ",s1) => s2 &
	indent_str(indent) => is &
	Util.string_append_list([is,f,r,io,s2]) => str
	----------------------------
	unparse_elementspec_str(indent, Absyn.IMPORT(i,_),f,r,io) => str

  rule	Print.printBuf " ##ERROR## "
	-------------------
	unparse_elementspec_str(_,_,_,_,_) => ""
end

(** relation: print_import
 **
 ** Prints an Import to the Print buffer.
 **)
relation print_import : Absyn.Import => () =

  rule	Print.printBuf i & Print.printBuf " = " &
	print_path p
	-----------------------
	print_import(Absyn.NAMED_IMPORT(i,p))

  rule	print_path p
	-------------
	print_import(Absyn.QUAL_IMPORT(p))

  rule	print_path p & Print.printBuf ".*"
	--------------------------
	print_import(Absyn.UNQUAL_IMPORT(p))
		     
end

(** relation: unparse_import_str
 **
 ** Prettyprints an Import to a string.
 **)
relation unparse_import_str : Absyn.Import => string =

  rule	string_append(i," = ") => s1 &
	Absyn.path_string p => s2 &
	string_append(s1,s2) => str
	-----------------------
	unparse_import_str(Absyn.NAMED_IMPORT(i,p)) => str

  rule	Absyn.path_string p => str
	-------------
	unparse_import_str(Absyn.QUAL_IMPORT(p)) => str

  rule	Absyn.path_string p => s1 &
	string_append(s1, ".*") => str
	--------------------------
	unparse_import_str(Absyn.UNQUAL_IMPORT(p)) => str
end

(** relation: print_elementattr
 **
 ** Prints ElementAttributes to the Print buffer.
 **)
relation print_elementattr: Absyn.ElementAttributes => () =

  rule	Print.printBuf "Absyn.ATTR(" &
	print_bool(fl) &
	Print.printBuf ", " &	
	variability_symbol(var) => vs &
	Print.printBuf vs &
	Print.printBuf ", " &	
	direction_symbol(dir) => ds &
	Print.printBuf ds &
	Print.printBuf ", " &	
	print_arraydim adim &
	Print.printBuf ")"
	-----------------------------------
	print_elementattr(Absyn.ATTR(fl,var,dir,adim))

  rule	Print.printBuf " ##ERROR## print_elementattr"
	-------------------
	print_elementattr(_)

end

(** relation: unparse_elementattr_str
 **
 ** Prettyprints ElementAttributes to a string.
 **)
relation unparse_elementattr_str: Absyn.ElementAttributes => string =

  rule	
	select_string(fl,"flow ","") => fs &
	unparse_variability_symbol_str(var) => vs &
	unparse_direction_symbol_str(dir) => ds &
	Util.string_append_list([fs,vs,ds]) => str
	------------------------------------------
	unparse_elementattr_str(Absyn.ATTR(fl,var,dir,adim)) => str

  rule	Print.printBuf " ##ERROR## unparse_elementattr_str"
	-------------------
	unparse_elementattr_str(_) => ""

end

(** relation: unparse_arraydim_in_attr
 **
 ** Prettyprints the arraydimension in ElementAttributes to a string.
 **)
relation unparse_arraydim_in_attr: Absyn.ElementAttributes => string =

  rule	print_arraydim_str(adim) => str
	-----------------------------------
	unparse_arraydim_in_attr(Absyn.ATTR(_,_,_,adim)) => str
  axiom	unparse_arraydim_in_attr(_) => ""
end


(** relation: variability_symbol
 ** 
 ** Returns a string for the Variability.
 **)
relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => "Absyn.VAR"
  axiom	variability_symbol(Absyn.DISCRETE) => "Absyn.DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "Absyn.PARAM"
  axiom	variability_symbol(Absyn.CONST) => "Absyn.CONST"

end

(** relation: direction_symbol
 ** 
 ** Returns a string for the direction.
 **)
relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => "Absyn.BIDIR"
  axiom	direction_symbol(Absyn.INPUT) => "Absyn.INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "Absyn.OUTPUT"

end

(** relation: unparse_variability_symbol_str
 **
 ** Returns a prettyprinted string of variability.
 **)
relation unparse_variability_symbol_str: Absyn.Variability => string =

  axiom unparse_variability_symbol_str(Absyn.VAR) => ""
  axiom	unparse_variability_symbol_str(Absyn.DISCRETE) => "discrete "
  axiom	unparse_variability_symbol_str(Absyn.PARAM) => "parameter "
  axiom	unparse_variability_symbol_str(Absyn.CONST) => "constant "

end

(** relation: unparse_direction_symbol_str
 **
 ** Returns a prettyprinted string of direction.
 **)
relation unparse_direction_symbol_str: Absyn.Direction => string =

  axiom unparse_direction_symbol_str(Absyn.BIDIR) => ""
  axiom	unparse_direction_symbol_str(Absyn.INPUT) => "input "
  axiom	unparse_direction_symbol_str(Absyn.OUTPUT) => "output "

end

(** relation: print_component
 **
 ** Prints a Component to the Print buffer.
 **)
relation print_component: Absyn.Component => () =

  rule	Print.printBuf "Absyn.COMPONENT(\"" &
	Print.printBuf n &
	Print.printBuf "\"," &
	print_arraydim a &
	Print.printBuf ", " &
	print_option(m,print_modification) &
	Print.printBuf ")"
	------------------------------------------
	print_component(Absyn.COMPONENT(n,a,m))

end

(** relation: print_componentitem
 **
 ** Prints a ComponentItem to the Print buffer.
 **)
relation print_componentitem: Absyn.ComponentItem => () =

  rule	Print.printBuf "Absyn.COMPONENTITEM(" &
	print_component c &	
	Print.printBuf ", " &
	dump_comment_option optcmt &
	Print.printBuf ")" 
	------------------------------------------
	print_componentitem(Absyn.COMPONENTITEM(c,optcond,optcmt))
end

(** relation: unparse_component_str
 **
 ** Prettyprints a Component to a string.
 **)
relation unparse_component_str: Absyn.Component => string =

  rule	print_arraydim_str a => s1 &
	string_append(n,s1) => s2 &
	get_option_str(m,unparse_modification_str) => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_component_str(Absyn.COMPONENT(n,a,m)) => str
end

(** relation: unparse_componentitem_str
 **
 ** Prettyprints a ComponentItem to a string.
 **)
relation unparse_componentitem_str: Absyn.ComponentItem => string =

  rule	unparse_component_str c => s1 &
	unparse_comment_option cmtopt => s3 &
	unparse_component_condition optcond => s2 &
	Util.string_append_list([s1,s2,s3]) => str
	------------------------------------------
	unparse_componentitem_str(Absyn.COMPONENTITEM(c,optcond,cmtopt)) => str
end

(** relation: unparse_component_condition
 **
 ** Prints a ComponentCondition option to a string.
 **)
relation unparse_component_condition: Absyn.ComponentCondition option 
	  => string =

  rule	print_exp_str(cond) => s1 &
	string_append (" if ",s1) => res
	--------------------------------
	unparse_component_condition(SOME(cond)) => res

  axiom	unparse_component_condition(NONE) => ""
end

(** relation: print_arraydim_opt
 **
 ** Prints an ArrayDim option to the Print buffer.
 **)
relation print_arraydim_opt: Absyn.ArrayDim option => () =
	
  rule	Print.printBuf "NONE"
	------------------------
	print_arraydim_opt( NONE) 

  rule	Print.printBuf "SOME(" &
	print_subscripts(s) &
	Print.printBuf ")" 
	-------------------
	print_arraydim_opt(SOME(s))
end

(** relation: print_arraydim
 **
 ** Prints an ArrayDim to the Print buffer.
 **)
relation print_arraydim: Absyn.ArrayDim => () =

  rule	print_subscripts(s)
	-------------------
	print_arraydim(s)
	
end

(** relation: print_arraydim_str
 **
 ** Prettyprints an ArrayDim to a string.
 **)
relation print_arraydim_str: Absyn.ArrayDim => string =

  rule	print_subscripts_str (s) => str
	-------------------------------
	print_arraydim_str(s) => str
	
end

(** relation: print_subscript
 **
 ** Prints an Subscript to the Print buffer.
 **)
relation print_subscript: Absyn.Subscript => () =

  rule	Print.printBuf "Absyn.NOSUB"
	---------
	print_subscript(Absyn.NOSUB)

  rule	Print.printBuf "Absyn.SUBSCRIPT(" &
	print_exp(e1) &
	Print.printBuf ")" 
	----------
	print_subscript(Absyn.SUBSCRIPT(e1))

end

(** relation: print_subscript_str
 **
 ** Prettyprints an Subscript to a string.
 **)
relation print_subscript_str: Absyn.Subscript => string =

  axiom	print_subscript_str (Absyn.NOSUB) => ":"

  rule	print_exp_str (e1) => s
	-----------------------
	print_subscript_str (Absyn.SUBSCRIPT(e1)) => s

end

(** relation: print_opt_modification
 ** 
 ** Prints a Modification option to the Print buffer.
 **)
relation print_opt_modification: Absyn.Modification option => () =

  rule	Print.printBuf "SOME(" &
	print_modification(m) &
	Print.printBuf ")" 
	----------------------
	print_opt_modification(SOME(m)) => ()

  axiom	print_opt_modification(NONE) => ()
end

(** relation: print_modification
 ** 
 ** Prints a Modification to the Print buffer.
 **)
relation print_modification: Absyn.Modification => () =
	
  rule	Print.printBuf "Absyn.CLASSMOD([" &
	print_mod1 l & 
	Print.printBuf "], " &
	print_mod2 e &
	Print.printBuf ")"
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	Print.printBuf "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

(** relation: print_mod1
 **
 ** Helper relaton to print_modification.
 **)
relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	Print.printBuf "(" &
	print_list_debug("print_mod1",l,print_element_arg,",") &
	Print.printBuf ")"
	------------------------------------
	print_mod1 l

end

(** relation: print_mod2
 **
 ** Helper relaton to print_mod1
 **)
relation print_mod2 : Absyn.Exp option => () =

  rule	Print.printBuf "NONE"
	-----------------
	print_mod2 NONE

  rule	Print.printBuf "SOME(" & print_exp(e) &
	Print.printBuf ")" 
	-------------------------
	print_mod2 SOME(e)

end

(** relation: unparse_opt_modification_str
 **
 ** Prettyprints a Modification option to a string.
 **)
relation unparse_opt_modification_str: Absyn.Modification option => string =

  rule	unparse_modification_str(opt) => str
	-------------------
	unparse_opt_modification_str(SOME(opt)) => str

  axiom	unparse_opt_modification_str(NONE) => ""
end

(** relation: unparse_modification_str
 **
 ** Prettyprints a Modification to a string.
 **)
relation unparse_modification_str: Absyn.Modification => string =
	(* Special case for empty modifications *)
  axiom	unparse_modification_str(Absyn.CLASSMOD([],NONE)) => "()"

  rule	unparse_mod1_str l => s1 & 
	unparse_mod2_str e => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_modification_str(Absyn.CLASSMOD(l, e)) => str
	
  rule	Print.printBuf " Failure MODIFICATION \n"
	-------------
	unparse_modification_str(_) => ""	
end

(** relation: unparse_mod1_str
 **
 ** Helper relation to unparse_modification_str
 **)
relation unparse_mod1_str: Absyn.ElementArg list => string =

  axiom	unparse_mod1_str [] => ""

  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str
	------------------------------------
	unparse_mod1_str l => str
end

(** relation: unparse_mod2_str
 **
 ** Helper relation to unparse_mod1_str
 **)
relation unparse_mod2_str : Absyn.Exp option => string =

  axiom	unparse_mod2_str NONE => ""

  rule	print_exp_str(e) => s1 &
	string_append("=",s1) => str
	-------------------------
	unparse_mod2_str SOME(e) => str
end

(* Equations *)

(** relation: print_equation
 **
 ** Prints an Equation to the Print buffer.
 **)
relation print_equation: Absyn.Equation => () =
	

  rule	Print.printBuf "IF (" & print_exp(e) & Print.printBuf ") THEN " &
	print_list_debug("print_equation",tb, print_equationitem, ";") &
	print_list_debug("print_equation",eb, print_eq_elseif, " ") &
	Print.printBuf " ELSE " & print_list_debug("print_equation",fb, print_equationitem, ";")
	----------------------------------------------------
	print_equation(Absyn.EQ_IF(e,tb,eb,fb))
	
  rule	Print.printBuf "EQ_EQUALS(" & print_exp(e1) & Print.printBuf "," &
	print_exp(e2) & Print.printBuf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	Print.printBuf "EQ_CONNECT(" & print_component_ref(e1) & Print.printBuf "," &
	print_component_ref(e2) & Print.printBuf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	Print.printBuf "FOR " & Print.printBuf i & Print.printBuf " in " & print_exp(e) &
	Print.printBuf " {" & print_list_debug("print_equation",el, print_equationitem, ";") & Print.printBuf "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	Print.printBuf " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

(** relation: print_equationitem
 **
 ** Prints and EquationItem to the Print buffer.
 **)
relation print_equationitem: Absyn.EquationItem => () =
  rule	Print.printBuf "EQUATIONITEM(" &
	print_equation eq &
	Print.printBuf ", <comment>)\n"
	-------------------------------
	print_equationitem Absyn.EQUATIONITEM(eq,_)
	
  rule	Print.printBuf "EQUATIONITEMANN(<annotation>)\n" 
	--------------
	print_equationitem Absyn.EQUATIONITEMANN(_)
end

(** relation: unparse_equation_str
 **
 ** Prettyprints an Equation to a string.
 **)
relation unparse_equation_str: (int, Absyn.Equation) => string =
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i',tb,";\n") => s2 &
	indent_str(i) => is &
	Util.string_append_list(["if ", s1, " then\n",is, s2,is,"end if"]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_IF(e,tb,[],[])) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i',tb,";\n") => s2 &
	unparse_eq_elseif_str_lst(i',eb, "\n") => s3 &
	unparse_equationitem_str_lst(i',fb,";\n") => s4 &
	indent_str(i) => is &
	Util.string_append_list([is,"if ", s1, " then\n",s2, s3, "\n",is,"else\n", s4,"\n", is, "end if"]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_IF(e,tb,eb,fb)) => str
	
  rule	print_exp_str(e1) => s1 &
	print_exp_str(e2) => s2 &
	indent_str(i) => is &
	Util.string_append_list([is,s1, "=", s2]) => str
	-------------------------------------------
	unparse_equation_str(i,Absyn.EQ_EQUALS(e1,e2)) => str
	
  rule	print_component_ref_str(e1) => s1 &
	print_component_ref_str(e2) => s2 &
	indent_str(i) => is &
	Util.string_append_list([is,"connect(", s1, ",", s2, ")"]) => str
	-------------------------------------------
	unparse_equation_str(i, Absyn.EQ_CONNECT(e1,e2)) => str
	
  rule	print_exp_str(e) => s1 &
	unparse_equationitem_str_lst(indent,el,";\n") => s2 &
	indent_str(indent) => is &
	Util.string_append_list([is,"for ", i, " in ", s1, " loop\n", s2, "\n",is,"end for"]) => str
	----------------------------------------------------------
	unparse_equation_str (indent,Absyn.EQ_FOR(i,e,el)) => str

  rule	print_function_args_str(fargs) => s2 &
	Util.string_append_list([id,"(",s2,")"]) => str
	-----------------------------------------------
	unparse_equation_str(i, Absyn.EQ_NORETCALL(id,fargs)) => str

  rule	print_exp_str(exp) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i', eql, ";\n") => s2 &
	indent_str(i) => is &
	unparse_eq_elsewhen_str_lst(i',eqlelse) => s4 &
	Util.string_append_list([is,"when ", s1, " then\n", is, s2, is, s4, "\n", is, "end when"]) => str
	-------------------
	unparse_equation_str(i, Absyn.EQ_WHEN_E(exp,eql,eqlelse)) => str

  rule	Print.printBuf " ** Failure! UNKNOWN EQUATION ** "
	--------------------------------
	unparse_equation_str(_,_) => ""
	
end

(** relation:unparse_equationitem_str_lst
 **
 ** Prettyprints and EquationItem list to a string.
 **)
relation unparse_equationitem_str_lst: (int (* indent *), 
					Absyn.EquationItem list, 
					string) 
	  => string =

  axiom	 unparse_equationitem_str_lst(_,[],_) => ""
	
  rule	unparse_equationitem_str(i, x) => s1 &
	unparse_equationitem_str_lst(i, xs, sep) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	----------------------
	unparse_equationitem_str_lst(i,x::xs,sep) => res
end

(** relation: unparse_equationitem_str
 **
 ** Prettyprints an EquationItem to a string.
 **)
relation unparse_equationitem_str: (int, Absyn.EquationItem) => string =

  rule	unparse_equation_str (i, eq) => s1 &
	unparse_comment_option(optcmt) => s2 &
	string_append(s1,s2) => str
	---------------------------
	unparse_equationitem_str (i, Absyn.EQUATIONITEM(eq,optcmt)) => str 
	
  rule	unparse_annotation_option(i,SOME(ann)) => str
	-------------------------------------------
	unparse_equationitem_str (i, Absyn.EQUATIONITEMANN(ann)) => str
end
	
(** relation: print_eq_elseif
 **
 ** Prints an Elseif branch to the Print buffer.
 **)
relation print_eq_elseif : (Absyn.Exp * Absyn.EquationItem list) => () =
	
  rule	Print.printBuf " ELSEIF " & print_exp e & Print.printBuf " THEN " &
	print_list_debug("print_eq_elseif",el, print_equationitem, ";")
	-----------------------------------
	print_eq_elseif((e,el))
end

(** relation: unparse_eq_elseif_str_lst
 **
 ** Prettyprints an elseif branch to a string.
 **)
relation unparse_eq_elseif_str_lst: (int, (Absyn.Exp * Absyn.EquationItem list) list, string) => string =
	
  axiom	 unparse_eq_elseif_str_lst(_,[],_) => ""

  rule	unparse_eq_elseif_str(i,x1) => s1 &
	Util.string_append_list([s1,sep]) => res
	-------------------------------------
	unparse_eq_elseif_str_lst(i,[x1],sep) => res

  rule	unparse_eq_elseif_str_lst(i,xs,sep) => s2 &
	unparse_eq_elseif_str(i,x) => s1 &
	Util.string_append_list([s1,sep,s2]) => res
	--------------------
	unparse_eq_elseif_str_lst(i,x::(xs as _::_),sep) => res

  rule	unparse_eq_elseif_str(i,x1) => s1 &
	unparse_eq_elseif_str(i,x2) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	-------------------------------------
	unparse_eq_elseif_str_lst(i,[x1,x2],sep) => res
end

(** relation: unparse_eq_elseif_str
 **
 ** Helper relation to unparse_eq_elseif_str_lst
 **)
relation unparse_eq_elseif_str : (int, (Absyn.Exp * Absyn.EquationItem list)) => string =
	    
  rule	print_exp_str e => s1 &
	unparse_equationitem_str_lst(i,el,";\n") => s2 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list(["\n",is,"elseif ",s1," then\n",s2]) => res
	-----------------------------------
	unparse_eq_elseif_str(i,(e,el)) => res
end

(* Algorithm clauses *)

(** relation: print_algorithmitem
 **
 ** Prints an AlgorithmItem to the Print buffer.
 **)
relation print_algorithmitem: Absyn.AlgorithmItem => () =

  rule	Print.printBuf "ALGORITHMITEM(" &
	print_algorithm(alg)&
	Print.printBuf ")\n"
	-------------------
	print_algorithmitem (Absyn.ALGORITHMITEM(alg,_))

  rule	Print.printBuf "ALGORITHMITEMANN(<annotation>)\n"
	----------------------------------------
	print_algorithmitem(Absyn.ALGORITHMITEMANN(ann))
end

(** relation: print_algorithm
 **
 ** Prints an Algorithm to the Print buffer.
 **)
relation print_algorithm: Absyn.Algorithm => () =
	
  rule	Print.printBuf "ALG_ASSIGN(" & print_component_ref cr &
	Print.printBuf " := " & print_exp(exp) & Print.printBuf ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	Print.printBuf "ALG_TUPLE_ASSIGN(" & print_exp(e1) &
	Print.printBuf " := " & print_exp(e2) & Print.printBuf ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_TUPLE_ASSIGN(e1,e2))

  rule	Print.printBuf "IF (" & print_exp(e) & Print.printBuf ") THEN " &
	print_list_debug("print_algorithm",tb, print_algorithmitem, ";") &
	print_list_debug("print_algorithm",eb, print_alg_elseif, " ") &
	Print.printBuf " ELSE " & print_list_debug("print_algorithm",fb, print_algorithmitem, ";")
	----------------------------------------------------
	print_algorithm(Absyn.ALG_IF(e,tb,eb,fb))
	
  rule	Print.printBuf "FOR " & Print.printBuf i & Print.printBuf " in " & print_exp(e) &
	Print.printBuf " {" & print_list_debug("print_algorithm",el, print_algorithmitem, ";") & Print.printBuf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	Print.printBuf "WHILE " & print_exp(e) &
	Print.printBuf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.printBuf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
	(*  rule	Print.printBuf "WHEN_E " & print_exp(e) &
	Print.printBuf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.printBuf "}"
	 ----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_E(e,al)
*)
  rule	Print.printBuf "WHEN_A " & print_exp(e) &
	Print.printBuf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.printBuf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_A(e,al,el)
	
  rule	Print.printBuf " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

(** relation: unparse_algorithm_str_lst
 **
 ** Prettyprints an AlgorithmItem list to a string.
 **)
relation unparse_algorithm_str_lst: (int, Absyn.AlgorithmItem list,string)
	  => string =

  axiom unparse_algorithm_str_lst (_,[],_) => ""

  rule	unparse_algorithm_str(i,x) => s1 &
	unparse_algorithm_str_lst(i,xs,sep) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	------------------------------------
	unparse_algorithm_str_lst(i, x::xs, sep) => res
end

(** relation: unparse_algorithm_str
 ** 
 ** Helper relation to unparse_algorithm_str
 **)
relation unparse_algorithm_str: (int, Absyn.AlgorithmItem) => string =
	
	(* ALG_ASSIGN *)
  rule	print_component_ref_str cr => s1 &
	print_exp_str(exp) => s2 & 
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,s1,":=",s2,s3,";"]) => str
	-------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(cr,exp),optcmt)) => str

	(* ALG_TUPLE_ASSIGN *)
  rule	print_exp_str(e1) => s1 &
	print_exp_str(e2) => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,s1," := ",s2,s3,";"]) => str
	----------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_TUPLE_ASSIGN(e1,e2),optcmt)) => str
	
	(* ALG_IF *)
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i,tb,"\n") => s2 &
	unparse_alg_elseif_str_lst(i',eb,"\n") => s3 &
	unparse_algorithm_str_lst(i,fb,"\n") => s4 &
	unparse_comment_option(optcmt) => s5 &
	indent_str(i) => is &
	Util.string_append_list([is,"if ",s1," then \n",is, s2, s3, "\n",is, "else ", s4, "\n", is, "end if" , s5, ";"]) => str
	----------------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_IF(e,tb,eb,fb),optcmt)) => str
	
	(* ALG_FOR *)
  rule	print_exp_str(e)=> s1 &
	int_add(ident,1) => ident' &
	unparse_algorithm_str_lst(ident',el,"\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(ident) => is &
	Util.string_append_list([is,"for ", i, " in ", s1, " loop\n",is, s2, "\n",is,"end for", s3, ";"]) => str
	----------------------------------------------------------
        unparse_algorithm_str (ident, Absyn.ALGORITHMITEM(Absyn.ALG_FOR(i,e,el),optcmt)) => str
			
	(* ALG_WHILE *)
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i',al,"\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,"while (", s1, ") loop\n", is, s2, "\n", is, "end while", s3, ";"]) => str
	----------------------------------------------------------
	unparse_algorithm_str (i, Absyn.ALGORITHMITEM(Absyn.ALG_WHILE(e,al),optcmt)) => str
	
	(* ALG_WHEN_A *)
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i', al, "\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	unparse_alg_elsewhen_str_lst(i',al2) => s4 &
	Util.string_append_list([is,"when ", s1, " then\n", is, s2, is, s4, "\n", is, "end when", s3,";"]) => str
        ----------------------------------------------------------
	unparse_algorithm_str (i, Absyn.ALGORITHMITEM(Absyn.ALG_WHEN_A(e,al,al2),optcmt)) => str
	
	(* ALG_NORETCALL *)
  rule	print_component_ref_str(cr) => s1 &
	print_function_args_str(fargs) => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,s1,"(",s2,")",s3,";"]) => str
	-----------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(cr,fargs),optcmt)) => str

  rule	unparse_annotation_option(i, SOME(ann)) => str &
	string_append(str,";") => str'
	------------------------------------------
	unparse_algorithm_str (i,Absyn.ALGORITHMITEMANN(ann)) => str'
  
  rule	Print.printErrorBuf "#Error, unparse_algorithm_str failed\n"
	--------------------------------
	unparse_algorithm_str(_,_) => ""
	
end

(** relation: unparse_alg_elsewhen_str_lst
 **
 ** Unparses an elsewhen branch in an algorithm to a string.
 **)
relation unparse_alg_elsewhen_str_lst: (int,(Absyn.Exp * Absyn.AlgorithmItem list) list) => string =

  axiom	unparse_alg_elsewhen_str_lst (_,[]) => ""

  rule	unparse_alg_elsewhen_str(i,x) => res
	----------------------------
	unparse_alg_elsewhen_str_lst(i,[x]) => res

  rule	unparse_alg_elsewhen_str(i,x1) => s1 &
	unparse_alg_elsewhen_str(i,x2) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res 
	----------------------------
	unparse_alg_elsewhen_str_lst(i,[x1,x2]) => res

  rule	unparse_alg_elsewhen_str(i,x) => s1 &
	unparse_alg_elsewhen_str_lst(i,xs) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_alg_elsewhen_str_lst(i,x::(xs as _::_)) => res
end

(** relation: unparse_alg_elsewhen_str
 **
 ** Helper relation to unparse_alg_elsewhen_str_lst
 **)
relation unparse_alg_elsewhen_str: (int, (Absyn.Exp * Absyn.AlgorithmItem list)) => string =
	
  rule	indent_str(i) => is &
	unparse_algorithm_str_lst(i,algl,"\n") => s1 &
	print_exp_str(exp) => s2 &
	Util.string_append_list(["elsewhen ",s2, " then\n",s1]) => res
	------------------------
	unparse_alg_elsewhen_str (i,(exp, algl)) => res
end

(** relation: unparse_eq_elsewhen_str_lst
 **
 ** Prettyprints an equation elsewhen branch to a string.
 **)
relation unparse_eq_elsewhen_str_lst: (int,(Absyn.Exp * Absyn.EquationItem list) list) => string =

  axiom	unparse_eq_elsewhen_str_lst (_,[]) => ""

  rule	unparse_eq_elsewhen_str(i,x) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,[x]) => res

  rule	unparse_eq_elsewhen_str(i,x1) => s1 &
	unparse_eq_elsewhen_str(i,x2) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,[x1,x2]) => res

  rule	unparse_eq_elsewhen_str(i,x) => s1 &
	unparse_eq_elsewhen_str_lst(i,xs) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,x::xs) => res
end

(** relation: unparse_eq_elsewhen_str
 **
 ** Helper relation to unparse_eq_elsewhen_str_lst
 **)
relation unparse_eq_elsewhen_str: (int, (Absyn.Exp * Absyn.EquationItem list)) => string =
	
  rule	indent_str(i) => is &
	unparse_equationitem_str_lst(i,eql,";\n") => s1 &
	print_exp_str(exp) => s2 &
	Util.string_append_list(["elsewhen ",s2, " then\n",s1]) => res
	------------------------
	unparse_eq_elsewhen_str (i,(exp, eql)) => res
end

(** relation: print_alg_elseif
 **
 ** Prints an algorithm elseif branch to the Print buffer.
 **)
relation print_alg_elseif : (Absyn.Exp * Absyn.AlgorithmItem list) => () =

  rule	Print.printBuf " ELSEIF " & print_exp e & Print.printBuf " THEN " &
	print_list_debug("print_alg_elseif",el, print_algorithmitem, ";")
	-----------------------------------
	print_alg_elseif((e,el))

end

(** relation: unparse_alg_elseif_str_lst
 **
 ** Prettyprints an algorithm elseif branch to a string.
 **)
relation unparse_alg_elseif_str_lst: (int, (Absyn.Exp * Absyn.AlgorithmItem list) list, string) => string =
	
  axiom	 unparse_alg_elseif_str_lst(_,[],_) => ""

  rule	unparse_alg_elseif_str_lst(i,xs,sep) => s2 &
	unparse_alg_elseif_str(i,x) => s1 &
	Util.string_append_list([s1,sep,s2]) => res
	--------------------
	unparse_alg_elseif_str_lst(i,x::xs,sep) => res
end

(** relation: unparse_alg_elseif_str
 **
 ** Helper relation to unparse_alg_elseif_str_lst
 **)
relation unparse_alg_elseif_str : (int,(Absyn.Exp * Absyn.AlgorithmItem list)) => string =

  rule  print_exp_str e => s1 &
	unparse_algorithm_str_lst(i,el,"\n") => s2 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"elseif ", s1, " then\n", s2]) => str
	-----------------------------------
	unparse_alg_elseif_str(i,(e,el)) => str
end

(* Component references and paths *)

(* relation: print_component_ref
 *
 * Print a `ComponentRef' to the Print buffer.
 *)
relation print_component_ref : Absyn.ComponentRef => () =

  rule	Print.printBuf "Absyn.CREF_IDENT(\"" &
	Print.printBuf s &
	Print.printBuf "\", " &
	print_subscripts subs &
	Print.printBuf ")" 
	---------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	Print.printBuf "Absyn.CREF_QUAL(\"" &
	Print.printBuf s &
	Print.printBuf "\", " &
	print_subscripts subs &
	Print.printBuf "," &
	print_component_ref cr &
	Print.printBuf ")"
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

(** relation: print_subscripts
 **
 ** Prints a Subscript to the Print buffer.
 **)
relation print_subscripts : Absyn.Subscript list => () =

  rule	Print.printBuf "[]" 
	-------------------
	print_subscripts []

  rule	Print.printBuf "[" & print_list_debug("print_subscripts",l,print_subscript,",") & Print.printBuf "]"
	-------------------------------------------------------
	print_subscripts l

end

(* relation: print_component_ref_str
 *
 * Print a `ComponentRef' and return as a string.
 *)
relation print_component_ref_str : Absyn.ComponentRef => string =

  rule	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s'
	--------------------------------
	print_component_ref_str Absyn.CREF_IDENT(s,subs) => s'

  rule	print_component_ref_str cr => crs &
	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s' &
	string_append (s', ".") => s'' &
	string_append (s'', crs) => s'''
	--------------------------------
	print_component_ref_str Absyn.CREF_QUAL(s,subs,cr) => s'''
end

(** relation: print_subscripts_str
 **
 ** Prettyprint a Subscript list to a string.
 **)
relation print_subscripts_str : Absyn.Subscript list => string =

  axiom	print_subscripts_str [] => ""

  rule	print_list_str(l,print_subscript_str,",") => s &
	string_append ("[", s) => s' & 
	string_append (s', "]") => s''
	-------------------------------------------------------
	print_subscripts_str l => s''

end

(* relation: print_path
 *
 * Print a `Path'.
 *)
relation print_path : Absyn.Path => () =

  rule	Absyn.path_string p => s & Print.printBuf s
	----------------------------------
	print_path p
end

(** relation: dump_path
 **
 ** Dumps path to the Print buffer
 **)
relation dump_path: Absyn.Path => () =

  rule	Print.printBuf("Absyn.IDENT(\"") &
	Print.printBuf str & 
	Print.printBuf "\")"
	---------------------------
	dump_path(Absyn.IDENT(str)) 
		    
  rule	Print.printBuf("Absyn.QUALIFIED(\"") &
	Print.printBuf str & 
	Print.printBuf "\"," &
	dump_path(path) &
	Print.printBuf ")"
	---------------------------
	dump_path(Absyn.QUALIFIED(str,path)) 
end

(* relation: print_path
 *
 * Print a `Path'.
 *)
relation print_path_str : Absyn.Path => string =

  rule	Absyn.path_string p => s
	----------------------------------
	print_path_str p => s

end

(* - Expressions *)

(* relation: print_exp
 *
 * This relation prints a complete expression to the Print buffer.
 *)
relation print_exp : Absyn.Exp => () =
	
  rule	int_string(x) => s & 
	Print.printBuf "Absyn.INTEGER(" &
	Print.printBuf s &
	Print.printBuf ")" 
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & 
	Print.printBuf "Absyn.REAL(" &
	Print.printBuf s &
	Print.printBuf ")" 
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	Print.printBuf "Absyn.CREF(" &
	print_component_ref(c) &
	Print.printBuf ")" 
	---------------------
	print_exp(Absyn.CREF(c))

  rule	Print.printBuf "Absyn.STRING(\"" &
	Print.printBuf s &
	Print.printBuf "\")"
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	Print.printBuf "Absyn.BOOL(false)"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	Print.printBuf "Absyn.BOOL(true)"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	dump_op_symbol(op) => sym & 
	Print.printBuf "Absyn.BINARY(" & 
	print_exp e1 & 
	Print.printBuf "," &
	Print.printBuf sym & 
	Print.printBuf "," &
	print_exp e2 &
	Print.printBuf ")" 
	--------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	dump_op_symbol(op) => sym &
	Print.printBuf "Absyn.UNARY(" &
	Print.printBuf sym &
	Print.printBuf ", " & 
	print_exp e &
	Print.printBuf ")" 
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	dump_op_symbol(op) => sym & 
	Print.printBuf "Absyn.LBINARY(" &
	print_exp e1 & 
	Print.printBuf "," &
	Print.printBuf sym & 
	Print.printBuf "," &
	print_exp e2 &
	Print.printBuf ")" 
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	dump_op_symbol(op) => sym &
	Print.printBuf "Absyn.UNARY(" &
	Print.printBuf sym &
	Print.printBuf ", " & 
	print_exp e &
	Print.printBuf ")" 
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	dump_op_symbol(op) => sym & 
	Print.printBuf "Absyn.RELATION(" &
	print_exp e1 & 
	Print.printBuf "," &
	Print.printBuf sym & 
	Print.printBuf "," &
	print_exp e2 &
	Print.printBuf ")" 
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	Print.printBuf "Absyn.IFEXP(" & print_exp(c) &
	Print.printBuf ", " & print_exp(t) &
	Print.printBuf ", " & print_exp(f) &
	Print.printBuf ")" 
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f,lst))

  rule	Print.printBuf "Absyn.CALL(" &
	print_component_ref(fcn) &
 	Print.printBuf ", " & 
	print_function_args(args) & Print.printBuf ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	Print.printBuf "Absyn.ARRAY([" &
	print_list_debug("print_exp",es, print_exp, ",") &
	Print.printBuf "])"
	---------
	print_exp Absyn.ARRAY(es)

	(* PR. *)
  rule	Print.printBuf "Absyn.TUPLE([" &
	Print.printBuf "(" &
	print_list_debug("print_exp",es, print_exp, ",") &
	Print.printBuf "])"
	---------
	print_exp Absyn.TUPLE(es)
	
  rule	Print.printBuf "Absyn.MATRIX([" &
	print_list_debug("print_exp",es, print_row, ";") &
	Print.printBuf "])"
	---------
	print_exp Absyn.MATRIX(es)

  rule	Print.printBuf "Absyn.RANGE(" & print_exp start & 
	Print.printBuf ",NONE," & print_exp stop & Print.printBuf ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	Print.printBuf "Absyn.RANGE(" & print_exp start & 
	Print.printBuf ",SOME(" & print_exp step &
 	Print.printBuf ")," & print_exp stop & Print.printBuf ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule Print.printBuf "Absyn.END"
	----------------------------------
	print_exp Absyn.END

  rule	Print.printBuf "#UNKNOWN EXPRESSION#"
	----------------------------------
	print_exp (_)
end

(** relation: print_function_args
 **
 ** Prints FunctionArgs to Print buffer.
 **)
relation print_function_args: Absyn.FunctionArgs => () =
	
  rule  Print.printBuf "FUNCTIONARGS(" &
	print_list_debug("print_exp",expargs,print_exp,", ") &
	Print.printBuf ", " &
	print_list_debug("print_namedarg",nargs,print_named_arg,", ") &
	Print.printBuf ")"
	-------------------
	print_function_args Absyn.FUNCTIONARGS(expargs,nargs)

  rule  Print.printBuf "FOR_ITER_FARG(" &
	print_exp exp &
	Print.printBuf ", " &
	Print.printBuf id &
	Print.printBuf ", " &
	print_exp iterexp &
	Print.printBuf ")"
	-------------------
	print_function_args Absyn.FOR_ITER_FARG (exp, id, iterexp)
end

(** relation: print_function_args_str
 **
 ** Prettyprint FunctionArgs to a string.
 **)
relation print_function_args_str: Absyn.FunctionArgs => string =
	
  rule	(* Both positional and named arguments *)
	print_list_str(expargs,print_exp_str,", ") => s1 &
	string_append(s1,", ") => s2 &
	print_list_str(nargs,print_named_arg_str,", ") => s3 &
	string_append(s2,s3) => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs as _::_,nargs as _::_) => str

  rule	(* Only named arguments *)
	print_list_str(nargs,print_named_arg_str,", ") => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS([],nargs) => str

  rule	(* Only positional arguments *)
	print_list_str(expargs,print_exp_str,", ") => str 
	---------------------------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs,[]) => str

  rule	print_exp_str exp => estr &
	print_exp_str iterexp => istr &
	Util.string_append_list([estr," for ",id," in ", istr]) => str
	--------------------------------------------------------------
	print_function_args_str Absyn.FOR_ITER_FARG(exp,id,iterexp) => str
	
end

(** relation: print_named_arg
 **
 ** Print NamedArg to the Print buffer.
 **)
relation print_named_arg: Absyn.NamedArg => () =

  rule	Print.printBuf ident &
	Print.printBuf "=" &
	print_exp(e) 
	------------
	print_named_arg Absyn.NAMEDARG(ident,e)
end

(** relation: print_named_arg_str
 **
 ** Prettyprint NamedArg to a string.
 **)
relation print_named_arg_str: Absyn.NamedArg => string =
  rule	string_append(ident,"=") => s1 &
	print_exp_str(e) => s2 &
	string_append(s1,s2) => str
	---------------------------
	print_named_arg_str Absyn.NAMEDARG(ident,e) => str
end	

(** relation: print_row
 **
 ** Print an Expression list to the Print buffer.
 **)
relation print_row : Absyn.Exp list => () =

  rule	print_list_debug("print_row",es, print_exp, ",")
	------------------------------
	print_row es

end


(* relation: exp_priority
*
* Returns a priority number for an expression.
* This relation is used to output parenthesis when needed. eg 3*(1+2) should output 3*(1+2) 
* and not 3*1+2
 *)
relation exp_priority: Absyn.Exp => int =

  axiom	exp_priority(Absyn.INTEGER(_)) => 0
  axiom	exp_priority(Absyn.REAL(_)) => 0
  axiom	exp_priority(Absyn.STRING(_)) => 0
  axiom	exp_priority(Absyn.BOOL(_)) => 0
  axiom	exp_priority(Absyn.CREF(_)) => 0
  axiom	exp_priority(Absyn.END) => 0
  axiom	exp_priority(Absyn.CALL(_,_)) => 0
  axiom	exp_priority(Absyn.ARRAY(_)) => 0
  axiom	exp_priority(Absyn.MATRIX(_)) => 0

  axiom	exp_priority(Absyn.BINARY(_,Absyn.POW,_)) => 1 

  axiom	exp_priority(Absyn.BINARY(_,Absyn.DIV,_)) => 2
  axiom	exp_priority(Absyn.BINARY(_,Absyn.MUL,_)) => 3

  axiom	exp_priority(Absyn.UNARY(Absyn.UPLUS,_)) => 4
  axiom	exp_priority(Absyn.UNARY(Absyn.UMINUS,_)) => 4

  axiom	exp_priority(Absyn.BINARY(_,Absyn.ADD,_)) => 5
  axiom	exp_priority(Absyn.BINARY(_,Absyn.SUB,_)) => 5

  axiom	exp_priority(Absyn.RELATION(_,Absyn.LESS,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.LESSEQ,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.GREATER,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.GREATEREQ,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.EQUAL,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.NEQUAL,_)) => 6

  axiom	exp_priority(Absyn.LUNARY(Absyn.NOT,_)) => 7

  axiom	exp_priority(Absyn.LBINARY(_,Absyn.AND,_)) => 8

  axiom	exp_priority(Absyn.LBINARY(_,Absyn.OR,_)) => 9

  axiom	exp_priority(Absyn.RANGE(_,_,_)) => 10

  axiom	exp_priority(Absyn.IFEXP(_,_,_,_)) => 11

	(* Not valid in inner expressions, only included here for completeness *)
  axiom	exp_priority(Absyn.TUPLE(_)) => 12
	
  axiom	exp_priority(_) => 13
end

(** relation: parenthesize
 **
 ** Adds parentheisis to a string if expression and parent expression 
 ** priorities requires it.
 **)
relation parenthesize: (string, 
			int, (*expressuion prio*)
			int (*parent expr prio*)
			) => string =

  rule	int_gt(pparent,pexpr) => true &
	Util.string_append_list(["(",str,")"]) => str'
	---------------------------
	parenthesize(str,pparent,pexpr) => str'

  axiom	parenthesize(str,_,_) => str
end

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)
relation print_exp_str : Absyn.Exp => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp_str(Absyn.INTEGER(x)) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp_str(Absyn.REAL(x)) => s

  rule	print_component_ref_str (c) => s
	---------------------
	print_exp_str(Absyn.CREF(c)) => s

  rule	string_append("\"", s) => s' &
	string_append(s', "\"") => s''
	---------------------------------
	print_exp_str(Absyn.STRING(s)) => s''

  rule	print_bool_str b => s
	---------------------
	print_exp_str(Absyn.BOOL(b)) => s

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p2,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str(e as Absyn.BINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e1 => s &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	parenthesize(s,p1,p) => s' &
	string_append (sym, s') => s''
	----------------------------
	print_exp_str(e as Absyn.UNARY(op, e1)) => s''

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p1,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str (e as Absyn.LBINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e1 => s &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &	
	parenthesize(s,p1,p) => s' &
	string_append (sym, s') => s''
	----------------------------
	print_exp_str(e as Absyn.LUNARY(op, e1)) => s''

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p1,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str(e as Absyn.RELATION(e1, op, e2)) => s'

  rule	print_exp_str c => cs &
	print_exp_str t => ts &
	print_exp_str f => fs &
	exp_priority(e) => p &
	exp_priority(c) => pc &
	exp_priority(t) => pt &
	exp_priority(f) => pf &
	parenthesize(cs,pc,p) => cs' &
	parenthesize(ts,pt,p) => ts' &
	parenthesize(fs,pf,p) => fs' &
	print_elseif_str elseif => el &		       
	Util.string_append_list(["if ", cs', " then ", ts', el, " else ", fs']) => str
	---------------------------------
	print_exp_str(e as Absyn.IFEXP(c,t,f,elseif)) => str

  rule	print_component_ref_str(fcn) => fs &
	print_function_args_str(args) => argsstr &
	string_append(fs, "(") => s &
	string_append(s, argsstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp_str(Absyn.CALL(fcn, args)) => s''


  rule	(* Does not need parentheses *)
	print_list_str(es, print_exp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp_str Absyn.ARRAY(es) => s''

  rule	(* Does not need parentheses *)
	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp_str Absyn.TUPLE(es) => s''
	
  rule	(* Does not need parentheses *)
	print_list_str(es, print_row_str, ";") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.MATRIX(es) => s''

  rule	print_exp_str (start) => s1 &
	print_exp_str (stop) => s3 &
	exp_priority(e) => p &
	exp_priority(start) => pstart &
	exp_priority(stop) => pstop &
	parenthesize(s1,pstart,p) => s1' &
	parenthesize(s3,pstop,p) => s3' &
	Util.string_append_list([ s1', ":", s3']) => s
	--------------------------------
	print_exp_str(e as  Absyn.RANGE(start,NONE,stop)) => s

  rule	print_exp_str (start) => s1 &
	print_exp_str (step) => s2 &
	print_exp_str (stop) => s3 &
	exp_priority(e) => p &
	exp_priority(start) => pstart &
	exp_priority(stop) => pstop &
	exp_priority(step) => pstep &
	parenthesize(s1,pstart,p) => s1' &
	parenthesize(s3,pstop,p) => s3' &
	parenthesize(s2,pstep,p) => s2' &
	Util.string_append_list([s1',":", s2', ":", s3']) => s
	------------------------------------
	print_exp_str (e as Absyn.RANGE(start,SOME(step),stop)) => s

  rule	print_code_str(c) => res &
	Util.string_append_list(["Code(",res,")"]) => res'
	--------------------------
	print_exp_str ( Absyn.CODE(c)) => res'

  axiom print_exp_str Absyn.END => "end"

  axiom	print_exp_str (_) =>  "#UNKNOWN EXPRESSION#"

end

(** relation: print_code_str
 **
 **  Prettyprint Code to a string.
 **)
relation print_code_str: Absyn.Code => string =
	
  rule	print_path_str p => s
	---------------------
	print_code_str( Absyn.C_TYPENAME(p)) => s

  rule	print_component_ref_str cr => s
	---------------------
	print_code_str( Absyn.C_VARIABLENAME(cr)) => s

  rule	select_string(b,"initial ", "") => s1 &
	unparse_equationitem_str_lst (1,eqitems,";\n") => s2 &
	Util.string_append_list([s1, "equation ",s2]) => res
	------------------------------------------------
	print_code_str( Absyn.C_EQUATIONSECTION(b, eqitems)) => res

  rule	select_string(b,"initial ", "") => s1 &
	unparse_algorithm_str_lst (1,algitems,";\n") => s2 &
	Util.string_append_list([s1,"algorithm ", s2]) => res
	------------------------------------------------
	print_code_str( Absyn.C_ALGORITHMSECTION(b, algitems)) => res

  rule	unparse_element_str(1,elt) => res
	------------------------------------------------
	print_code_str( Absyn.C_ELEMENT(elt)) => res

  rule	print_exp_str(exp) => res
	------------------------------------------------
	print_code_str( Absyn.C_EXPRESSION(exp)) => res

  rule	unparse_modification_str(m) => res
	------------------------------------------------
	print_code_str( Absyn.C_MODIFICATION(m)) => res

end

(** relation: print_eleseif_str
 **
 ** Prettyprint elseif to a string
 **)	       
relation print_elseif_str: (Absyn.Exp * Absyn.Exp) list => string =
  axiom print_elseif_str ([]) => ""

  rule	print_exp_str(ec) => s1 &
	print_exp_str(ee) => s2 &
	print_elseif_str(rest) => s3 &
	Util.string_append_list([" elseif ", s1, " then ", s2, s3]) => str
	-------------------------------------------------------------
	print_elseif_str((ec,ee)::rest) => str
end

(** relation: print_row_str
 **
 ** Prettyprint a list of expressions to a string.
 **)
relation print_row_str : Absyn.Exp list => string =

  rule	print_list_str (es, print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)
relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end


(* relation: op_symbol
 *
 * Make a string describing different operators.
 *)
relation op_symbol : Absyn.Operator => string =
  axiom	op_symbol(Absyn.ADD) => " + "
  axiom	op_symbol(Absyn.SUB) => " - "
  axiom	op_symbol(Absyn.MUL) => "*"
  axiom	op_symbol(Absyn.DIV) => "/"
  axiom	op_symbol(Absyn.POW) => "^"

  axiom	op_symbol(Absyn.UMINUS) => "-"
  axiom	op_symbol(Absyn.UPLUS) => "+"

  axiom	op_symbol(Absyn.AND) => " and "
  axiom	op_symbol(Absyn.OR) => " or "

  axiom	op_symbol(Absyn.NOT) => "not "

  axiom	op_symbol(Absyn.LESS)      => " < "
  axiom	op_symbol(Absyn.LESSEQ)    => " <= "
  axiom	op_symbol(Absyn.GREATER)   => " > "
  axiom	op_symbol(Absyn.GREATEREQ) => " >= "
  axiom	op_symbol(Absyn.EQUAL)     => " == "
  axiom	op_symbol(Absyn.NEQUAL)    => " <> "
end


(* relation: dump_op_symbol
 *
 * Make a string describing different operators.
 *)
relation dump_op_symbol : Absyn.Operator => string =
  axiom	dump_op_symbol(Absyn.ADD) => "Absyn.ADD"
  axiom	dump_op_symbol(Absyn.SUB) => "Absyn.SUB"
  axiom	dump_op_symbol(Absyn.MUL) => "Absyn.MUL"
  axiom	dump_op_symbol(Absyn.DIV) => "Absyn.DIV"
  axiom	dump_op_symbol(Absyn.POW) => "Absyn.POW"

  axiom	dump_op_symbol(Absyn.UMINUS) => "Absyn.UMINUS"
  axiom	dump_op_symbol(Absyn.UPLUS) => "Absyn.UPLUS"

  axiom	dump_op_symbol(Absyn.AND) => "Absyn.AND"
  axiom	dump_op_symbol(Absyn.OR) => "Absyn.OR"

  axiom	dump_op_symbol(Absyn.NOT) => "Absyn.NOT"

  axiom	dump_op_symbol(Absyn.LESS)      => "Absyn.LESS"
  axiom	dump_op_symbol(Absyn.LESSEQ)    => "Absyn.LESSEQ"
  axiom	dump_op_symbol(Absyn.GREATER)   => "Absyn.GREATER"
  axiom	dump_op_symbol(Absyn.GREATEREQ) => "Absyn.GREATEREQ"
  axiom	dump_op_symbol(Absyn.EQUAL)     => "Absyn.EQUAL"
  axiom	dump_op_symbol(Absyn.NEQUAL)    => "Absyn.NEQUAL"
end

(* - Utility relations
 *
 * These are utility relations used in some of the other
 * relations. *)


(** relation: select_string
 **
 ** Select one of the two strings depending on boolean value.
 **)
relation select_string: (bool,string,string) => string =

  axiom	select_string(true,a,b) => a
  axiom	select_string(false,a,b) => b

end

(** relation: print_select
 **
 ** Select one of the two string depending on boolean value 
 ** and print it on the Print buffer.
 **)
relation print_select: (bool,string,string) => () =

  rule	select_string(f,yes,no) => res &
	Print.printBuf res
	-------------------------
	print_select(f,yes,no)

end

(** relation: print_option
 **
 ** Prints an option value given a print relation.
 **)
relation print_option : (('a option),('a => ())) => () =

  rule	Print.printBuf "NONE" 
	------------------------
	print_option(NONE,_) => ()
	
  rule	Print.printBuf "SOME(" &
	r( x ) &
	Print.printBuf ")" 
	-------------------
	print_option(SOME(x),r) => ()
end

(** relation: print_list_debug
 **
 ** Prints a list of values given a print relation and a caller string.
 **)
relation print_list_debug : (string, 'a list, 'a => (), string) => () =

  rule	Debug.fprintln ("dumptr", "print_list_debug-1")
	-----------------------------------------------
	print_list_debug(_,[],_,_)
	
  rule	Debug.fprintl ("dumptr", ["print_list_debug-2 from ", caller, "\n"]) &
	r(h) &
	Debug.fprintln ("dumptr", "//print_list_debug-2")
	------------------
	print_list_debug(caller,[h],r,_)

  rule	string_append("print_list_debug-3 from ", caller) => s1 &
	Debug.fprintl ("dumptr", [s1, "\n"]) &
	r(h) & 
	Print.printBuf sep & 
	Debug.fprintln ("dumptr", "//print_list_debug-3") &
	print_list_debug(s1, rest, r, sep)
	-------------------------------------
	print_list_debug(caller, h::rest, r, sep)

end

(** relation: print_list
 **
 ** Prints a list of values given a print relation.
 **)
relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & Print.printBuf sep &
	print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(** relation get_string_list
 **
 ** Append strings from a list of values output with a relation converting
 ** a value to a string. 
 **)
relation get_string_list : ('a list, 'a => string, string) => string =

  axiom	get_string_list ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	get_string_list([h],r,_) => s

  rule	r(h) => s & 
	string_append (s, sep) => s' &
	get_string_list (t,r,sep) => srest &
	string_append (s', srest) => s''
	-------------------------------------
	get_string_list (h::t,r,sep) => s''

end

(** relation: print_bool
 **
 ** Print a bool value to the Print buffer
 **)
relation print_bool : bool => () =

  rule	print_select (b, "true", "false")
	---------------------------------
	print_bool b
end


(** relation get_option_str
 **
 ** Retrieve the string from a string option.
 ** If NONE return empty string.
 **)
relation get_option_str: ('a option, 'a => string) => string =
  rule  r (a) => str
	------------
	get_option_str (SOME(a),r) => str

  axiom	get_option_str(NONE,_) => ""
end

(** relation get_option_str_default
 **
 ** Retrieve the string from a string option.
 ** If NONE return default string.
 **)
relation get_option_str_default: ('a option, 'a => string,string) => string =
  rule  r (a) => str
	------------
	get_option_str_default (SOME(a),r,_) => str

  axiom	get_option_str_default(NONE,_,def) => def
end

(** relation: get_option_with_concat_str
 **
 ** Get option string value using a relation translating the value to a string
 ** and concatenate with an additional suffix string.
 **)
relation get_option_with_concat_str: ('a option, 
				      'a => string,
				      string) (* suffix *)
	  => string =
  rule  r (a) => str &
        string_append(default_str,str) => str'
	------------
	get_option_with_concat_str (SOME(a),r,default_str) => str'

  axiom	get_option_with_concat_str(NONE,_,default_str) => ""
end


(** relation: unparse_string_comment_option
 **
 ** Prettyprint a string comment option, which is a string option.
 **)
relation unparse_string_comment_option: string option => string =
	
  axiom unparse_string_comment_option(NONE) => ""
	
  rule	Util.string_append_list([" \"",s,"\""])=> str 
	--------------------------
	unparse_string_comment_option(SOME(s)) => str
end

(** relation: print_string_comment_option
 **
 ** Print a string comment option on the Print buffer
 **)
relation print_string_comment_option: string option => () =
	
  rule	Print.printBuf "NONE" 
	--------------------
	print_string_comment_option(NONE) => ()
	
  rule	Util.string_append_list(["SOME( \"",s,"\")"])=> str &
	Print.printBuf str 
	--------------------------
	print_string_comment_option(SOME(s)) => ()
end

(** relation: identity
 ** 
 ** The identity relation.
 **)
relation identity: ('a) => 'a =
  axiom identity(x) => x
end

(** relation: print_bool_str
**
** Prints a bool to a string.
**)
relation print_bool_str : bool => string =

  rule	select_string (b, "true", "false") => s
	---------------------------------
	print_bool_str b => s

end

(** relation: indent_str
 ** 
 ** Creates an indentation string, i.e. whitespaces, given and indentation 
 ** level.
 **)
relation indent_str: (int) => string =
  axiom	indent_str(0) => ""

  rule	int_sub(i,1) => i' &
	indent_str(i') => s1 &
	(* Indent using two whitespaces *)
	string_append(s1,"  ") => res
	--------------------
	indent_str(i) => res
end

(** relation: stdout
 **
 ** Prints the text sent to the print buffer (Print.rml) to stdout (i.e. 
 ** using RML standard print). After printing, the print buffer is cleared.
 **)
relation stdout: () => () =

  rule 	Print.getString() => str &
        print str &
        Print.clearBuf()
        ------------------------
        stdout() => ()
end 


