(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 Env.rml
 ** module:      Env
 ** description: Environmane management
 **
 ** RCS: $Id$
 **
 ** An environment is a stack of frames, where each frame contains a
 ** number of class and variable bindings.
 ** Each frame consist of:
 ** - a frame name (corresponding to the class partially instantiated in that frame)
 ** - a binary tree containing a list of classes
 ** - a binary tree containing a list of functions (functions are overloaded so serveral
						     function names can exist)
 ** - a list of unnamed items consisting of import statements
 **
 ** As an example lets consider the following Modelica code:
 ** package A
 **   package B
 **    import Modelica.SIunits.*;
 **    constant Voltage V=3.3;
 **    function foo
 **    end foo;
 **    model M1
 **      Real x,y;  
 **    end M1;
 **    model M2
 **    end M2;
 **  end B;
 ** end A;
 ** 
 ** When instantiating M1 we will first create the environment for its surrounding scope
 ** by a recursive instantiation on A.B giving the environment:
 **  { 
 **  FRAME("A", [Class:B],[],{},false) ,  
 **  FRAME("B", [Class:M1, Class:M2, Variable:V], [Type:foo],
	   {import Modelica.SIunits.*},false)
 **  }
 **
 ** Then, the class M1 is instantiated in a new scope/Frame giving the environment:
 **  { 
 **  FRAME("A", [Class:B],[],{},false) ,  
 **  FRAME("B", [Class:M1, Class:M2, Variable:V], [Type:foo], 
	   {Import Modelica.SIunits.*},false),
 **  FRAME("M1, [Variable:x, Variable:y],[],{},false)
 **  }

 ** NOTE: The instance hierachy (components and variables) and the class hierachy 
 ** (packages and classes) are combined into the same data structure, enabling a 
 ** uniform lookup mechanism
 **)

 module Env:
  
  with "Absyn.rml"
  with "Values.rml"
  with "SCode.rml"
  with "Types.rml"
  with "ClassInf.rml"
  with "Exp.rml"

  type Ident = string

  datatype Frame = FRAME of Ident option *  (* Class name *)
			    BinTree * (* List of uniquely named classes and variables *)
			    BinTree * (* List of types, which DOES NOT be uniquely named, eg. size have several types*)		 
			    Item list * (* list of unnamed items (imports)**)
			    Frame list * (* list of frames for inherited elements*)
			    bool  (* encapsulated *)
  (* bool=true means that FRAME is created due to encapsulated class  *)

  datatype Item = VAR of Types.Var * (* instantiated var *)
			(SCode.Element*Types.Mod) option *(* declaration if not fully instantiated. *)
                        bool (* if it typed/fully instantiated or not *)
		| CLASS of SCode.Class * Env
		| TYPE of Types.Type list (* list since several types with the same name can exist in the same scope (overloading) *)
		| IMPORT of Absyn.Import

  type Env = Frame list

(** The binary tree data structure
 ** ==============================
 ** The binary tree data structure used for the environment is generic and can 
 ** be used in any RML application.
 ** The Tree data structure BinTree is defined as:**)

  datatype BinTree = TREENODE of TreeValue option * (* Value *)
				BinTree option * (* left subtree *)
				BinTree option (* right subtree *)

(* Each node in the binary tree can have a value associated with it.*)

  datatype TreeValue = TREEVALUE of Key (* Key *)
				* Value (* Value *)

  type Key = Ident

  type Value = Item


  val empty_env   : Env
 
  relation new_frame : (bool) => Frame
  relation open_scope       : (Env,bool (*encapsulated?*), Ident option) => Env
  relation extend_frame_c   : (Env, SCode.Class) => Env
  relation extend_frame_classes   : (Env, SCode.Program) => Env
  relation extend_frame_v   : (Env, Types.Var,(SCode.Element*Types.Mod) option,bool) => Env
  relation update_frame_v   : (Env, Types.Var,bool(*encapsulated*)) => Env
  relation extend_frame_t : (Env,Ident,Types.Type) => Env
  relation extend_frame_i : (Env, Absyn.Import) => Env
  relation top_frame : Env => Frame
  relation get_env_path: (Env) => Absyn.Path option
  relation print_env_path: (Env) => ()
  relation print_env_path_str: Env => string 
  relation print_env        : Env => ()
  relation print_env_str: Env => string 
	  
  relation print_env_graphviz : (Env * string) => ()

  relation local_outside_connector_flowvars: (Env) => Exp.ComponentRef list
  relation local_inside_connector_flowvars: (Env) => Exp.ComponentRef list	  
  relation tree_get: (BinTree, Key, Key => int) => Value 
  relation tree_add: (BinTree, Key, Value, Key => int) => (BinTree) 
  relation myhash: Key => int 

end

with "Dump.rml"
with "Graphviz.rml"
with "DAE.rml"
with "Print.rml"
with "Util.rml"
with "System.rml"

(** - Values *)

val empty_env = []

(** - Relations *)

(** relation: new_frame
 **
 ** This relation creates a new frame, which includes setting up the 
 ** hashtable for the frame.
**)

relation new_frame: (bool) => Frame =

  rule	tree_new => ht &
	tree_new => httypes 
	--------------------
	new_frame(enc) => FRAME(NONE,ht,httypes,[],[],enc)	
end		 

(** relation: open_scope
 **
 ** Opening a new scope in the environment mans adding a new frame on
 ** top of the stack of frames. If the scope is not the top scope a classname
 ** of the scope should be provided such that a name for the scope can be
 ** derived, see name_scope.
 **)

relation open_scope: (Env,
		      bool (*encapsulated*),
		      Ident option)  (*classname*)
	  => Env =

  rule	new_frame(encflag) => frame &
	name_scope(frame::env,id) => env' 
	------------------------------
	open_scope(env,encflag, SOME(id)) =>  env'

  rule	new_frame(encflag) => frame
	------------------------------
	open_scope(env,encflag, NONE) =>  frame::env
end

(** relation: name_scope
 **
 ** This relation names the current scope, giving it an identifier.
 ** Scopes needs to be named for several reasons. First, it is needed for
 ** debugging purposes, since it is easier to follow the environment if we 
 ** know what the current class being instantiated is.
 ** 
 ** Secondly, it is needed when expanding type names in the context of 
 ** flattening of the inheritance hierarchy. The reason for this is that types
 ** of inherited components needs to be expanded such that the types can be 
 ** looked up from the environment of the base class.
 **)
 
relation name_scope: (Env,Ident) => Env =

  axiom	name_scope(FRAME(_,ht,httypes,imps,bcframes,encflag)::res,id) 
	  => FRAME(SOME(id),ht,httypes,imps,bcframes,encflag)::res
end

(** relation: extend_frame_c
 **
 ** This relation adds a class definition to the environment.
 **)

relation extend_frame_c : (Env, SCode.Class) => Env =

  rule	tree_add(ht,n,CLASS(c,env),System.hash) => (ht')
	--------------------------
	extend_frame_c(env as (FRAME(id,ht,httypes,imps,bcframes,encflag)::fs),c as SCode.CLASS(n,_,_,_,_))
	  => ((FRAME(id,ht',httypes,imps,bcframes,encflag)::fs))

  rule	print "extend_frame_c FAILED\n" 
	--------------------------
	extend_frame_c(_,_)
	  => fail
end

(** relation: extend_frame_classes
 **
 ** Adds all clases in a Program to the environment.
 **)

relation extend_frame_classes : (Env, SCode.Program) => Env =

  axiom	extend_frame_classes(env,[]) => env

  rule	extend_frame_c(env,c) => env' &
	extend_frame_classes(env',cs) => env''
	-------------------------------------
	extend_frame_classes(env,c::cs) => env''
end

(** relation: extend_frame_v
 **
 ** This relation adds a component to the environment.
 **)

relation extend_frame_v : (Env,
			   Types.Var, (* instantated var*)
			   (SCode.Element*Types.Mod) option, (* declaration*)
			   bool) (* fully instantiated *)
	  => Env =
	
  rule	tree_add(ht,n,VAR(v,c,i),System.hash) => (ht')
	---------------------------------------
	extend_frame_v(FRAME(id,ht,httypes,imps,bcframes,encflag)::fs,v as Types.VAR(n,_,_,_,_),c,i)
	    => (FRAME(id,ht',httypes,imps,bcframes,encflag)::fs)
	    
end
	
(** relation: update_frame_v
 **
 ** This relation updates a component already added to the environment, but 
 ** that prior to the update did not have any binding. I.e this relation is
 ** called in the second stage of instantiation with declare before use.
**)
	
relation update_frame_v : (Env,Types.Var,bool(*fully instantiated*) ) 
	  => Env =

  axiom	update_frame_v ([],_,i) => []

  rule	tree_get(ht,n,System.hash) => VAR(_,c,_) &
        tree_add(ht,n,VAR(v,c,i),System.hash) => (ht')
	------------------------
	update_frame_v (FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs, v as Types.VAR(n,_,_,_,_),i)
	  => (FRAME(sid,ht',httypes,imps,bcframes,encflag)::fs)
	  
	  (* Also check frames above, e.g. when variable is in base class *)
  rule	update_frame_v(fs,v,i) => frames
	--------------
	update_frame_v(FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs,v as Types.VAR(n,_,_,_,_),i)
	  => (FRAME(sid,ht,httypes,imps,bcframes,encflag)::frames)

  rule	Print.print_buf "- update_frame_v, variable " & Print.print_buf n &
	Print.print_buf " not found\n rest of env:" &
	print_env fs & Print.print_buf "\n" 
	--------------
	update_frame_v(FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs, Types.VAR(n,_,_,_,_),_)
	  => (FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs)

  rule	Print.print_buf "- update_frame_v failed\n" &
	Print.print_buf "  - variable: " & Types.print_var v &
	Print.print_buf "\n" 
	----------------
	update_frame_v(_,v as Types.VAR(id,_,_,_,_),_) => fail
end
	
(** relation: extend_frame_t
 **
 ** This relation adds a type to the environment.  Types in the
 ** environment are used for looking up constants etc. inside class
 ** definitions, such as packages.  For each type in the environment,
 ** there is a class definition with the same name in the
 ** environment.
 **)
		 
relation extend_frame_t : (Env,Ident,Types.Type) => Env =

  rule	(* Other types with that name allready exist, add this type as well *)
	tree_get(httypes,n,System.hash) => TYPE(tps) &
	tree_add(httypes,n,TYPE(t::tps),System.hash) => (httypes')
	-----------------------------
	extend_frame_t(FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs, n, t)
	  => (FRAME(sid,ht,httypes',imps,bcframes,encflag)::fs)

  rule	(* No other types exists *)
	not tree_get(httypes,n,System.hash) => TYPE(_) &
	tree_add(httypes,n,TYPE([t]),System.hash) => (httypes')
	-----------------------------
	extend_frame_t(FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs, n, t)
	  => (FRAME(sid,ht,httypes',imps,bcframes,encflag)::fs)
end

(** relation: extends_frame_i
 **
 ** Adds an import statement to the environment.
 **)

relation extend_frame_i : (Env,Absyn.Import) => Env =
	      
  axiom	extend_frame_i(FRAME(sid,ht,httypes,imps,bcframes,encflag)::fs,imp)
	  => (FRAME(sid,ht,httypes, IMPORT(imp)::imps,bcframes,encflag)::fs)
end

(** relation: top_frame
 **
 ** Returns the top frame.
 **)

relation top_frame : Env => Frame =
  axiom	top_frame([fr]) => fr
  rule	top_frame(lst) => fr
	--------------------
	top_frame(elt::(lst as (_::_))) => fr
end

(** relation: get_env_path
 **
 ** This relation returns all partially instantiated parents as an Absyn.Path 
 ** option I.e. it collects all identifiers of each frame until it reaches 
 ** the topmost unnamed frame. If the environment is only the topmost frame, 
 ** NONE is returned.
**)

relation get_env_path: Env => Absyn.Path option =

  axiom	get_env_path ([FRAME(SOME(id),_,_,_,_,_),FRAME(NONE,_,_,_,_,_)]) 
	  => SOME(Absyn.IDENT(id))
	
  rule	get_env_path(rest) => SOME(path) &
	Absyn.join_paths(path,Absyn.IDENT(id)) => path'
	----------------------------------------------
	get_env_path(FRAME(SOME(id),_,_,_,_,_)::rest) =>SOME(path')

  axiom	get_env_path(_) => NONE
end

(** relation: print_env_path_str
 **
 ** Retrive the environment path as a string, see get_env_path.
 **)

relation print_env_path_str: Env => string =

  rule	get_env_path(env) => SOME(path) &
	Absyn.path_string(path) => pathstr 
	---------------
	print_env_path_str(env) => pathstr

  axiom	print_env_path_str(env) => "<global scope>"
end

(** relation: print_env_path
 **
 ** Print the environment path to the Print buffer. 
 ** See also get_env_path
 **)

relation print_env_path: Env => () =

  rule	get_env_path(env) => SOME(path) &
	Absyn.path_string(path) => pathstr &
	Print.print_buf pathstr
	---------------
	print_env_path(env) => ()

  rule	Print.print_buf "TOPENV"
	---------------
	print_env_path(env) => ()

end

(** relation: print_env_str
 **
 ** Print the environment as a string.
 **)

relation print_env_str: Env => string =

  axiom	print_env_str [] => "Empty env\n"

  rule	print_frame_str fr => s1 & 
	print_env_str frs => s2 &
	string_append(s1,s2) => res
	------------
	print_env_str fr::frs => res

end

(** relation: print_env
 **
 ** Print the environment to the Print buffer.
 **)

relation print_env : Env => () =

  rule	print_env_str e => s &
	Print.print_buf s 
	---------------------
	print_env e
end

(** relation: print_frame_str
 **
 ** Print a Frame to a string.
 **)

relation print_frame_str : Frame => string =

  rule	print_bintree_str ht => s1 &
	print_bintree_str httypes => s2  &
	print_imports_str imps => s3 &
	Util.bool_string encflag => encflag_str &
	Util.string_append_list(["FRAME: ", sid, " (enc=", encflag_str,
				 ") \nclasses and vars:\n=============\n",
				 s1,
			 	 "   Types:\n======\n",
				 s2,
				 "   Imports:\n=======\n",
				 s3,
				 "\n\n\n"]) => res
	--------------------------------------------
	print_frame_str FRAME(SOME(sid),ht,httypes,imps,bcframes,encflag)
	  => res

  rule	print_bintree_str ht => s1 &
	print_bintree_str httypes => s2  &
	print_imports_str imps => s3 &
	Util.bool_string encflag => encflag_str &
	Util.string_append_list(["FRAME: unnamed (enc=", encflag_str,
				 ") \nclasses and vars:\n=============\n",
				 s1,
			 	 "   Types:\n======\n",
				 s2,
				 "   Imports:\n=======\n",
				 s3,
				 "\n\n\n"]) => res
	--------------------------------------------
	print_frame_str FRAME(NONE,ht,httypes,imps,bcframes,encflag) => res

end

(** relation: print_imports_str
 **
 ** Print import statements to a string.
 **)

relation print_imports_str:  Item list => string =

  axiom	print_imports_str [] => ""

  rule	print_frame_element_str (("",e)) => s1
	-------------------------
	print_imports_str [e] => s1

  rule	print_frame_element_str (("",e)) => s1 &
        print_imports_str rst => s2 &
	Util.string_append_list([s1, ", " ,s2]) => res
	------------------------------------------------
	print_imports_str (e::rst) => res
end


(** relation: print_frame_element_str
 **
 ** Print frame element to a string
 **)

relation print_frame_element_str: (Ident * Item) => string =

  rule	SCode.variability_string var => s &
	SCode.print_element_str elt => elt_str &
	Types.unparse_type tp => tp_str &
	Types.unparse_var tv => var_str &
	Util.string_append_list(["v:",n," ",s,"(",elt_str,") [",tp_str,"] {",
				var_str,"}\n"]) => res
	---------------------------------------------
	print_frame_element_str ((n,VAR(tv as Types.VAR(_,Types.ATTR(_,_,var,_),_,tp,_),SOME((elt,_)),i))) => res

  rule	Util.string_append_list(["v:",n,"\n"]) => res
	---------------------------------------------
	print_frame_element_str ((n,VAR(Types.VAR(_,_,_,_,bnd),NONE,i))) => res

  rule	Util.string_append_list(["c:",n,"\n"]) => res
	--------------------------------------------
	print_frame_element_str ((n,CLASS(_,_))) => res

  rule	list_length(lst) => len &
	int_string(len) => lenstr &
	Util.string_append_list(["t:",n," (",lenstr,")\n"]) => res
	-----------------------
	print_frame_element_str ((n,TYPE(lst))) => res

  rule	Dump.unparse_import_str imp => s &
	Util.string_append_list(["imp:",s, "\n"]) => res
	------------------------------------------------
	print_frame_element_str ((n,IMPORT(imp))) => res
end

(** relation: print_env_graphviz
 **
 ** Print the environment in Graphviz format to the Print buffer.
 **)


relation print_env_graphviz : (Env * string) => () =

  rule	build_env_graphviz ((env,str)) => r &
	Graphviz.dump(r)
	----------------
	print_env_graphviz ((env,str))

end

(** relation: build_env_graphviz
 **
 ** Build the graphviz graph from an Env.
 **)

relation build_env_graphviz : (Env * string) => Graphviz.Node =

  rule	string_append ("ROOT: ", str) => str' &
	build_env_graphviz_2 env => nodelist
	------------------------------------
	build_env_graphviz ((env,str)) => Graphviz.NODE(str',[],nodelist)

end

(** relation: build_env_graphviz_2
 **
 ** Helper relation to build_env_graphviz.
 **)

relation build_env_graphviz_2 : Env => Graphviz.Node list =

  axiom	build_env_graphviz_2 [] => []

  rule	build_env_graphviz_2 rest => nodelist &
	build_frame_graphviz frame => node
	----------------------------------
	build_env_graphviz_2 frame::rest => node::nodelist

end

(** relation: is_var_item
 **
 ** Succeeds if item is a VAR.
 **)

relation is_var_item = 
  axiom	is_var_item ((_,VAR(_,_,_))) 
end

(** relation: is_class_item
 **
 ** Succeeds if item is a CLASS.
 **)

relation is_class_item = 
  axiom	is_class_item ((_,CLASS(_,_))) 
end

(** relation: is_type_item
 **
 ** Succeds if item is a TYPE.
 **)
relation is_type_item = 
  axiom	is_type_item ((_,TYPE(_))) 
end

(** relation: build_frame_graphviz
 **
 ** Build a Grapviz Node from a Frame.
 **)

relation build_frame_graphviz : Frame => Graphviz.Node =

  axiom	build_frame_graphviz FRAME(sid,ht,httypes,imps,bcframes,encflag) 
	  => Graphviz.NODE("FRAME",[],[])
end

(** relation: build_item_listnode
 **
 ** Build a Graphviz Node from a list of items, selected by a condition
 ** relation among the input list.
 **)

relation build_item_listnode : ((Ident * Item) list, 
				(Ident * Item) => (), (* condition *)
				string) (* node name *)
	  => Graphviz.Node =

  rule	Util.list_matching (items, cond) => selitems &
	build_item_listnode_2 (selitems, 1) => node
	--------------------------------------------------------
	build_item_listnode (items, cond, name) 
	  => Graphviz.NODE(name, [], [node])

end

(** relation: build_item_listnode_2
 **
 ** Helper relation to build_item_listnode.
**)

relation build_item_listnode_2 : ((Ident * Item) list, int) 
	  => Graphviz.Node =

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, []) &
	int_string count => cstr
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [])

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, ignored) &
	int_string count => cstr &
	int_add (count, 1) => count' &
	build_item_listnode_2 (ignored, count') => restnode 
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [restnode])

end

(** relation: build_item_str
 **
 ** Helper relation to build_item_listnode_2, creates a string from an item.
 **)

relation build_item_str : (Ident * Item) => string =

  rule	string_append ("VAR: ",id) => s
	------------------------------
	build_item_str ((id, VAR(_,_,_))) => s

  rule	(*build_env_graphviz env => r &*)
	string_append ("CLASS: ", id) => s
	----------------------------------
	build_item_str ((id, CLASS(cls, env))) => s

  rule	string_append ("TYPE: ", id) => s
	---------------------------------
	build_item_str ((id, TYPE(_))) => s

end


(** BinTree implementation *)

(** relation: myhash
 **
 ** Hash function for binary tree implementation, using standard string
 ** hashing.
 **)

relation myhash: Key => int =

  rule	System.hash str => res
	------------
	myhash(str) => res
end


(** relation: tree_new
 **
 ** Create a new binary tree.
 **)

relation tree_new: () => BinTree =

  axiom	tree_new()  => TREENODE(NONE,NONE,NONE)

end

(** relation: tree_add
 **
 ** Add a tree to a binary tree.
 **)
relation tree_add: (BinTree, 
		    Key, 
		    Value, 
		    Key => int) (* hash func *)
	  => (BinTree) =

  axiom	tree_add (TREENODE(NONE,NONE,NONE),key,value,_) 
	  => TREENODE(SOME(TREEVALUE(key,value)),NONE,NONE)

	  (* Replace this node *)
  rule	rkey = key
	---------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),key,value,hashfunc)
	  => (TREENODE(SOME(TREEVALUE(rkey,value)),left,right))

	  (* Insert to right subtree*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_add(t,key,value,hashfunc) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(t')))

	  (* Insert to right node*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_add(TREENODE(NONE,NONE,NONE),key,value,hashfunc) => right'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as NONE),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right')))

	  (* Insert to left subtree*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_add(t,key,value,hashfunc) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(t'),right))

	  (* Insert to left node*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_add(TREENODE(NONE,NONE,NONE),key,value,hashfunc) => left'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as NONE,right),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left'),right))

  rule	print "tree_add failed\n"
	-----------------------
	tree_add(_,_,_,_) => fail
end 

(** relation: local_outside_connector_flowvars
 **
 ** Return the outside connector variables that are flow in the local scope.
 **)

relation local_outside_connector_flowvars: (Env) => Exp.ComponentRef list =

  rule	local_outside_connector_flowvars2(SOME(ht)) => res
	--------------------------------
	local_outside_connector_flowvars(FRAME(sid,ht,_,_,_,_)::_) => res
end

(** relation: local_outside_connector_flowvars2
 **
 ** Helper relation to local_outside_connector_flowvars
 **)

relation local_outside_connector_flowvars2: (BinTree option) 
	  => Exp.ComponentRef list =

  axiom	local_outside_connector_flowvars2(NONE) => []
	
  rule	local_outside_connector_flowvars2(l) => lst1 &
	local_outside_connector_flowvars2(r) => lst2 &
	Types.flow_variables(vars,Exp.CREF_IDENT(id,[])) => lst3 &
	Util.list_flatten([lst1,lst2,lst3])=> res
	-----------------------------
	local_outside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),vars),_),_),_,_))),l,r)))
	=> res

  rule	local_outside_connector_flowvars2(l) => lst1 &
	local_outside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_outside_connector_flowvars2(SOME(TREENODE(SOME(_),l,r)))
	  => res
end

(** relation: local_inside_connector_flowvars
 **
 ** Returns the inside connector variables that are flow from the local scope.
 **)

relation local_inside_connector_flowvars: (Env) => Exp.ComponentRef list =

  rule	local_inside_connector_flowvars2(SOME(ht)) => res
	--------------------------------
	local_inside_connector_flowvars(FRAME(sid,ht,_,_,_,_)::_) => res
end

(** relation: local_inside_connector_flowvars2
 ** 
 ** Helper relation to local_inside_connector_flowvars
 **)

relation local_inside_connector_flowvars2:(BinTree option) => Exp.ComponentRef list =

  axiom	local_inside_connector_flowvars2(NONE) => []

	(* If CONNECTOR then  outside and not inside, skip.. *)
  rule	local_inside_connector_flowvars2(l) => lst1 &
	local_inside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),_),_),_),_,_))),l,r)))
	=> res

	(* ... else retrieve connectors as subcomponents*)
  rule	local_inside_connector_flowvars3(vars,id) => lst1 &
	local_inside_connector_flowvars2(l) => lst2 &
	local_inside_connector_flowvars2(r) => lst3 &
	Util.list_flatten([lst1,lst2,lst3]) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(_,vars),_),_),_,_))),l,r)))
	=> res

	  (* if not complex, skip *)
  rule	local_inside_connector_flowvars2(l) => lst1 &
	local_inside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,t,_),_,_))),l,r)))
	=> res
end

(** relation: local_inside_connector_flowvars3
 **
 ** Helper relation to local_inside_connector_flowvars2
 **)

relation local_inside_connector_flowvars3: (Types.Var list,Ident) 
	  => Exp.ComponentRef list =

  axiom	 local_inside_connector_flowvars3 ([],_) => []

  rule	local_inside_connector_flowvars3(xs,oid) => lst1 &
	Types.flow_variables(vars,Exp.CREF_QUAL(oid,[],Exp.CREF_IDENT(id,[]))) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------------------------------
	local_inside_connector_flowvars3 (Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),vars),_),_)::xs,oid) => res

  rule	local_inside_connector_flowvars3(xs,oid) => res
	-----------------------------------------------
	local_inside_connector_flowvars3 (_::xs,oid) => res

end

(** relation: tree_get
 **
 ** Get a value from the binary tree given a key.
 **)

relation tree_get: (BinTree, Key, Key => int (* hash func *)) => Value =

  rule	rkey = key 
	---------------
	tree_get (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),
		  key,hashfunc) 
	  => rval

	  (* Search to the right*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_get(right,key,hashfunc) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right)),key,hashfunc)
	  => res
	  (* Search to the left*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_get(left,key,hashfunc) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left),right),key,hashfunc)
	  => res
end

(** relation: print_bintree_str
 **
 ** Prints the binary tree to a string
 **)

relation print_bintree_str: (BinTree ) => string =

  rule	print_frame_element_str((rkey,rval)) => s1 &
	Dump.get_option_str(l,print_bintree_str) => s2 &
	Dump.get_option_str(r,print_bintree_str) => s3 &
	Util.string_append_list([s2,s1,s3]) => res
	----------------------
	print_bintree_str(TREENODE(SOME(TREEVALUE(rkey,rval)),l,r)) => res

  rule	Dump.get_option_str(l,print_bintree_str) => s2 &
	Dump.get_option_str(r,print_bintree_str) => s3 &
	string_append(s2,s3) => res
	----------------------
	print_bintree_str(TREENODE(NONE,l,r)) => res
end
