(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Env.rml
 ** module:      Env
 ** description: Environmane management
 **
 ** RCS: $Id$
 **
 ** An environment is a stack of frames, where each frame contains a
 ** number of class and variable bindings.
 ** Each frame consist of:
 ** - a frame name (corresponding to the class partially instantiated in that frame)
 ** - a binary tree containing a list of classes
 ** - a binary tree containing a list of functions (functions are overloaded so serveral
						     function names can exist)
 ** - a list of unnamed items consisting of import statements
 **
 ** As an example lets consider the following Modelica code:
 ** package A
 **   package B
 **    import Modelica.SIunits.*;
 **    constant Voltage V=3.3;
 **    function foo
 **    end foo;
 **    model M1
 **      Real x,y;  
 **    end M1;
 **    model M2
 **    end M2;
 **  end B;
 ** end A;
 ** 
 ** When instantiating M1 we will first create the environment for its surrounding scope
 ** by a recursive instantiation on A.B giving the environment:
 **  { 
 **  FRAME("A", [Class:B],[],{},false) ,  
 **  FRAME("B", [Class:M1, Class:M2, Variable:V], [Type:foo],
	   {import Modelica.SIunits.*},false)
 **  }
 **
 ** Then, the class M1 is instantiated in a new scope/Frame giving the environment:
 **  { 
 **  FRAME("A", [Class:B],[],{},false) ,  
 **  FRAME("B", [Class:M1, Class:M2, Variable:V], [Type:foo], 
	   {Import Modelica.SIunits.*},false),
 **  FRAME("M1, [Variable:x, Variable:y],[],{},false)
 **  }

 ** NOTE: The instance hierachy (components and variables) and the class hierachy 
 ** (packages and classes) are combined into the same data structure, enabling a 
 ** uniform lookup mechanism
 **)

 module Env:
  
  with "Absyn.rml"
  with "Values.rml"
  with "SCode.rml"
  with "Types.rml"
  with "ClassInf.rml"
  with "Exp.rml"

  type Ident = string

  datatype Frame = FRAME of Ident option *  (* Class name *)
			    BinTree * (* List of uniquely named classes and variables *)
			    BinTree * (* List of types, which DOES NOT be uniquely named, eg. size have several types*)		 
			    Item list * (* list of unnamed items (imports)**)
			    Frame list * (* list of frames for inherited elements*)
			    Exp.ComponentRef list * (* current connection set crefs *)	
			    bool  (* encapsulated *)
  (* bool=true means that FRAME is created due to encapsulated class  *)

  datatype Item = VAR of Types.Var * (* instantiated component *)
			(SCode.Element*Types.Mod) option *(* declaration if not fully instantiated. *)
                        bool * (* if it typed/fully instantiated or not *)
			Env  (** The environment of the instantiated component
			      ** Contains e.g. all sub components 
			      **)
		| CLASS of SCode.Class * Env
		| TYPE of Types.Type list (* list since several types with the same name can exist in the same scope (overloading) *)
		| IMPORT of Absyn.Import

  type Env = Frame list

(** The binary tree data structure
 ** ==============================
 ** The binary tree data structure used for the environment is generic and can 
 ** be used in any RML application.
 ** The Tree data structure BinTree is defined as:**)

  datatype BinTree = TREENODE of TreeValue option * (* Value *)
				BinTree option * (* left subtree *)
				BinTree option (* right subtree *)

(* Each node in the binary tree can have a value associated with it.*)

  datatype TreeValue = TREEVALUE of Key (* Key *)
				* Value (* Value *)

  type Key = Ident

  type Value = Item


  val empty_env   : Env
 
  relation new_frame : (bool) => Frame
  relation open_scope       : (Env,bool (*encapsulated?*), Ident option) => Env
  relation extend_frame_c   : (Env, SCode.Class) => Env
  relation extend_frame_classes   : (Env, SCode.Program) => Env
  relation extend_frame_v   : (Env, Types.Var,(SCode.Element*Types.Mod) option,bool,Env) => Env
  relation update_frame_v   : (Env, Types.Var,bool(*encapsulated*),Env) => Env
  relation extend_frame_t : (Env,Ident,Types.Type) => Env
  relation extend_frame_i : (Env, Absyn.Import) => Env
  relation top_frame : Env => Frame
  relation get_env_path: (Env) => Absyn.Path option
  relation print_env_path: (Env) => ()
  relation print_env_path_str: Env => string 
  relation print_env        : Env => ()
  relation print_env_str: Env => string 
	  
  relation print_env_graphviz : (Env * string) => ()

  relation local_outside_connector_flowvars: (Env) => Exp.ComponentRef list
  relation local_inside_connector_flowvars: (Env) => Exp.ComponentRef list	  
  relation tree_get: (BinTree, Key, Key => int) => Value 
  relation tree_add: (BinTree, Key, Value, Key => int) => (BinTree) 
  relation myhash: Key => int 

end

with "Dump.rml"
with "Graphviz.rml"
with "DAE.rml"
with "Print.rml"
with "Util.rml"
with "System.rml"

(** - Values *)

val empty_env = []

(** - Relations *)

(** relation: new_frame
 **
 ** This relation creates a new frame, which includes setting up the 
 ** hashtable for the frame.
**)

relation new_frame: (bool) => Frame =

  rule	tree_new => ht &
	tree_new => httypes 
	--------------------
	new_frame(enc) => FRAME(NONE,ht,httypes,[],[],[],enc)	
end		 

(** relation: open_scope
 **
 ** Opening a new scope in the environment mans adding a new frame on
 ** top of the stack of frames. If the scope is not the top scope a classname
 ** of the scope should be provided such that a name for the scope can be
 ** derived, see name_scope.
 **)

relation open_scope: (Env,
		      bool (*encapsulated*),
		      Ident option)  (*classname*)
	  => Env =

  rule	new_frame(encflag) => frame &
	name_scope(frame::env,id) => env' 
	------------------------------
	open_scope(env,encflag, SOME(id)) =>  env'

  rule	new_frame(encflag) => frame
	------------------------------
	open_scope(env,encflag, NONE) =>  frame::env
end

(** relation: name_scope
 **
 ** This relation names the current scope, giving it an identifier.
 ** Scopes needs to be named for several reasons. First, it is needed for
 ** debugging purposes, since it is easier to follow the environment if we 
 ** know what the current class being instantiated is.
 ** 
 ** Secondly, it is needed when expanding type names in the context of 
 ** flattening of the inheritance hierarchy. The reason for this is that types
 ** of inherited components needs to be expanded such that the types can be 
 ** looked up from the environment of the base class.
 **)
 
relation name_scope: (Env,Ident) => Env =

  axiom	name_scope(FRAME(_,ht,httypes,imps,bcframes,crs,encflag)::res,id) 
	  => FRAME(SOME(id),ht,httypes,imps,bcframes,crs,encflag)::res
end

(** relation: extend_frame_c
 **
 ** This relation adds a class definition to the environment.
 **)

relation extend_frame_c : (Env, SCode.Class) => Env =

  rule	tree_add(ht,n,CLASS(c,env),System.hash) => (ht')
	--------------------------
	extend_frame_c(env as (FRAME(id,ht,httypes,imps,bcframes,crs,encflag)::fs),c as SCode.CLASS(n,_,_,_,_))
	  => ((FRAME(id,ht',httypes,imps,bcframes,crs,encflag)::fs))

  rule	print "extend_frame_c FAILED\n" 
	--------------------------
	extend_frame_c(_,_)
	  => fail
end

(** relation: extend_frame_classes
 **
 ** Adds all clases in a Program to the environment.
 **)

relation extend_frame_classes : (Env, SCode.Program) => Env =

  axiom	extend_frame_classes(env,[]) => env

  rule	extend_frame_c(env,c) => env' &
	extend_frame_classes(env',cs) => env''
	-------------------------------------
	extend_frame_classes(env,c::cs) => env''
end

(** relation: extend_frame_v
 **
 ** This relation adds a component to the environment.
 **)

relation extend_frame_v : (Env,
			   Types.Var, (* instantated var*)
			   (SCode.Element*Types.Mod) option, (* declaration*)
			   bool,(* fully instantiated *)
			   Env) (* environment of component *)
	  => Env =
	
  rule	tree_add(ht,n,VAR(v,c,i,env),System.hash) => (ht')
	---------------------------------------
	extend_frame_v(FRAME(id,ht,httypes,imps,bcframes,crs,encflag)::fs,v as Types.VAR(n,_,_,_,_),c,i,env)
	    => (FRAME(id,ht',httypes,imps,bcframes,crs,encflag)::fs)
	    
end
	
(** relation: update_frame_v
 **
 ** This relation updates a component already added to the environment, but 
 ** that prior to the update did not have any binding. I.e this relation is
 ** called in the second stage of instantiation with declare before use.
**)
	
relation update_frame_v : (Env,
			   Types.Var,
			   bool,(*fully instantiated*) 
			   Env) (* env of component *)
	  => Env =

  axiom	update_frame_v ([],_,i,_) => []

  rule	tree_get(ht,n,System.hash) => VAR(_,c,_,_) &
        tree_add(ht,n,VAR(v,c,i,env),System.hash) => (ht')
	------------------------
	update_frame_v (FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs, v as Types.VAR(n,_,_,_,_),i,env)
	  => (FRAME(sid,ht',httypes,imps,bcframes,crs,encflag)::fs)
	  
	  (* Also check frames above, e.g. when variable is in base class *)
  rule	update_frame_v(fs,v,i,env) => frames
	--------------
	update_frame_v(FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs,v as Types.VAR(n,_,_,_,_),i,env)
	  => (FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::frames)

  rule	Print.print_buf "- update_frame_v, variable " & Print.print_buf n &
	Print.print_buf " not found\n rest of env:" &
	print_env fs & Print.print_buf "\n" 
	--------------
	update_frame_v(FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs, Types.VAR(n,_,_,_,_),_,_)
	  => (FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs)

  rule	Print.print_buf "- update_frame_v failed\n" &
	Print.print_buf "  - variable: " & Types.print_var v &
	Print.print_buf "\n" 
	----------------
	update_frame_v(_,v as Types.VAR(id,_,_,_,_),_,_) => fail
end
	
(** relation: extend_frame_t
 **
 ** This relation adds a type to the environment.  Types in the
 ** environment are used for looking up constants etc. inside class
 ** definitions, such as packages.  For each type in the environment,
 ** there is a class definition with the same name in the
 ** environment.
 **)
		 
relation extend_frame_t : (Env,Ident,Types.Type) => Env =

  rule	(* Other types with that name allready exist, add this type as well *)
	tree_get(httypes,n,System.hash) => TYPE(tps) &
	tree_add(httypes,n,TYPE(t::tps),System.hash) => (httypes')
	-----------------------------
	extend_frame_t(FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs, n, t)
	  => (FRAME(sid,ht,httypes',imps,bcframes,crs,encflag)::fs)

  rule	(* No other types exists *)
	not tree_get(httypes,n,System.hash) => TYPE(_) &
	tree_add(httypes,n,TYPE([t]),System.hash) => (httypes')
	-----------------------------
	extend_frame_t(FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs, n, t)
	  => (FRAME(sid,ht,httypes',imps,bcframes,crs,encflag)::fs)
end

(** relation: extends_frame_i
 **
 ** Adds an import statement to the environment.
 **)

relation extend_frame_i : (Env,Absyn.Import) => Env =
	      
  axiom	extend_frame_i(FRAME(sid,ht,httypes,imps,bcframes,crs,encflag)::fs,imp)
	  => (FRAME(sid,ht,httypes, IMPORT(imp)::imps,bcframes,crs,encflag)::fs)
end

(** relation: top_frame
 **
 ** Returns the top frame.
 **)

relation top_frame : Env => Frame =
  axiom	top_frame([fr]) => fr
  rule	top_frame(lst) => fr
	--------------------
	top_frame(elt::(lst as (_::_))) => fr
end

(** relation: get_env_path
 **
 ** This relation returns all partially instantiated parents as an Absyn.Path 
 ** option I.e. it collects all identifiers of each frame until it reaches 
 ** the topmost unnamed frame. If the environment is only the topmost frame, 
 ** NONE is returned.
**)

relation get_env_path: Env => Absyn.Path option =

  axiom	get_env_path ([FRAME(SOME(id),_,_,_,_,_,_),FRAME(NONE,_,_,_,_,_,_)]) 
	  => SOME(Absyn.IDENT(id))
	
  rule	get_env_path(rest) => SOME(path) &
	Absyn.join_paths(path,Absyn.IDENT(id)) => path'
	----------------------------------------------
	get_env_path(FRAME(SOME(id),_,_,_,_,_,_)::rest) =>SOME(path')

  axiom	get_env_path(_) => NONE
end

(** relation: print_env_path_str
 **
 ** Retrive the environment path as a string, see get_env_path.
 **)

relation print_env_path_str: Env => string =

  rule	get_env_path(env) => SOME(path) &
	Absyn.path_string(path) => pathstr 
	---------------
	print_env_path_str(env) => pathstr

  axiom	print_env_path_str(env) => "<global scope>"
end

(** relation: print_env_path
 **
 ** Print the environment path to the Print buffer. 
 ** See also get_env_path
 **)

relation print_env_path: Env => () =

  rule	get_env_path(env) => SOME(path) &
	Absyn.path_string(path) => pathstr &
	Print.print_buf pathstr
	---------------
	print_env_path(env) => ()

  rule	Print.print_buf "TOPENV"
	---------------
	print_env_path(env) => ()

end

(** relation: print_env_str
 **
 ** Print the environment as a string.
 **)

relation print_env_str: Env => string =

  axiom	print_env_str [] => "Empty env\n"

  rule	print_frame_str fr => s1 & 
	print_env_str frs => s2 &
	string_append(s1,s2) => res
	------------
	print_env_str fr::frs => res

end

(** relation: print_env
 **
 ** Print the environment to the Print buffer.
 **)

relation print_env : Env => () =

  rule	print_env_str e => s &
	Print.print_buf s 
	---------------------
	print_env e
end

(** relation: print_frame_str
 **
 ** Print a Frame to a string.
 **)

relation print_frame_str : Frame => string =

  rule	print_bintree_str ht => s1 &
	print_bintree_str httypes => s2  &
	print_imports_str imps => s3 &
	Util.bool_string encflag => encflag_str &
	Util.string_append_list(["FRAME: ", sid, " (enc=", encflag_str,
				 ") \nclasses and vars:\n=============\n",
				 s1,
			 	 "   Types:\n======\n",
				 s2,
				 "   Imports:\n=======\n",
				 s3,
				 "\n\n\n"]) => res
	--------------------------------------------
	print_frame_str FRAME(SOME(sid),ht,httypes,imps,bcframes,crs,encflag)
	  => res

  rule	print_bintree_str ht => s1 &
	print_bintree_str httypes => s2  &
	print_imports_str imps => s3 &
	Util.bool_string encflag => encflag_str &
	Util.string_append_list(["FRAME: unnamed (enc=", encflag_str,
				 ") \nclasses and vars:\n=============\n",
				 s1,
			 	 "   Types:\n======\n",
				 s2,
				 "   Imports:\n=======\n",
				 s3,
				 "\n\n\n"]) => res
	--------------------------------------------
	print_frame_str FRAME(NONE,ht,httypes,imps,bcframes,crs,encflag) => res

end

(** relation: print_frame_vars_str
 **
 ** Print only the variables in a Frame to a string.
 **)

relation print_frame_vars_str : Frame => string =

  rule	print_bintree_str ht => s1 &
	Util.bool_string encflag => encflag_str &
	Util.string_append_list(["FRAME: ", sid, " (enc=", encflag_str,
				 ") \nclasses and vars:\n=============\n",
				 s1,
				 "\n\n\n"]) => res
	--------------------------------------------
	print_frame_vars_str FRAME(SOME(sid),ht,httypes,imps,bcframes,crs,encflag)
	  => res

  rule	print_bintree_str ht => s1 &
	Util.bool_string encflag => encflag_str &
	Util.string_append_list(["FRAME: unnamed (enc=", encflag_str,
				 ") \nclasses and vars:\n=============\n",
				 s1,
				 "\n\n\n"]) => res
	--------------------------------------------
	print_frame_vars_str FRAME(NONE,ht,httypes,imps,bcframes,crs,encflag) => res
  axiom	print_frame_vars_str _ => ""
end

(** relation: print_imports_str
 **
 ** Print import statements to a string.
 **)

relation print_imports_str:  Item list => string =

  axiom	print_imports_str [] => ""

  rule	print_frame_element_str (("",e)) => s1
	-------------------------
	print_imports_str [e] => s1

  rule	print_frame_element_str (("",e)) => s1 &
        print_imports_str rst => s2 &
	Util.string_append_list([s1, ", " ,s2]) => res
	------------------------------------------------
	print_imports_str (e::rst) => res
end


(** relation: print_frame_element_str
 **
 ** Print frame element to a string
 **)

relation print_frame_element_str: (Ident * Item) => string =

  rule	SCode.variability_string var => s &
	SCode.print_element_str elt => elt_str &
	Types.unparse_type tp => tp_str &
	Types.unparse_var tv => var_str &
	print_frame_vars_str(compframe) => frame_str &
	Types.print_binding_str(bind) => bind_str &
	Util.string_append_list(["v:",n," ",s,"(",elt_str,") [",tp_str,"] {",
				var_str,"}, binding:", bind_str,", compframe:",
				 frame_str]) => res
	---------------------------------------------
	print_frame_element_str ((n,VAR(tv as Types.VAR(_,Types.ATTR(_,_,var,_),_,tp,bind),SOME((elt,_)),i,compframe::_))) => res

  rule	SCode.variability_string var => s &
	SCode.print_element_str elt => elt_str &
	Types.unparse_type tp => tp_str &
	Types.unparse_var tv => var_str &
	Util.string_append_list(["v:",n," ",s,"(",elt_str,") [",tp_str,"] {",
				var_str,"}, compframe: []"]) => res
	---------------------------------------------
	print_frame_element_str ((n,VAR(tv as Types.VAR(_,Types.ATTR(_,_,var,_),_,tp,_),SOME((elt,_)),i,[]))) => res

  rule	Util.string_append_list(["v:",n,"\n"]) => res
	---------------------------------------------
	print_frame_element_str ((n,VAR(Types.VAR(_,_,_,_,bnd),NONE,i,env))) => res

  rule	Util.string_append_list(["c:",n,"\n"]) => res
	--------------------------------------------
	print_frame_element_str ((n,CLASS(_,_))) => res

  rule	list_length(lst) => len &
	int_string(len) => lenstr &
	Util.string_append_list(["t:",n," (",lenstr,")\n"]) => res
	-----------------------
	print_frame_element_str ((n,TYPE(lst))) => res

  rule	Dump.unparse_import_str imp => s &
	Util.string_append_list(["imp:",s, "\n"]) => res
	------------------------------------------------
	print_frame_element_str ((n,IMPORT(imp))) => res
end

(** relation: print_env_graphviz
 **
 ** Print the environment in Graphviz format to the Print buffer.
 **)


relation print_env_graphviz : (Env * string) => () =

  rule	build_env_graphviz ((env,str)) => r &
	Graphviz.dump(r)
	----------------
	print_env_graphviz ((env,str))

end

(** relation: build_env_graphviz
 **
 ** Build the graphviz graph from an Env.
 **)

relation build_env_graphviz : (Env * string) => Graphviz.Node =

  rule	string_append ("ROOT: ", str) => str' &
	build_env_graphviz_2 env => nodelist
	------------------------------------
	build_env_graphviz ((env,str)) => Graphviz.NODE(str',[],nodelist)

end

(** relation: build_env_graphviz_2
 **
 ** Helper relation to build_env_graphviz.
 **)

relation build_env_graphviz_2 : Env => Graphviz.Node list =

  axiom	build_env_graphviz_2 [] => []

  rule	build_env_graphviz_2 rest => nodelist &
	build_frame_graphviz frame => node
	----------------------------------
	build_env_graphviz_2 frame::rest => node::nodelist

end

(** relation: is_var_item
 **
 ** Succeeds if item is a VAR.
 **)

relation is_var_item = 
  axiom	is_var_item ((_,VAR(_,_,_,_))) 
end

(** relation: is_class_item
 **
 ** Succeeds if item is a CLASS.
 **)

relation is_class_item = 
  axiom	is_class_item ((_,CLASS(_,_))) 
end

(** relation: is_type_item
 **
 ** Succeds if item is a TYPE.
 **)
relation is_type_item = 
  axiom	is_type_item ((_,TYPE(_))) 
end

(** relation: build_frame_graphviz
 **
 ** Build a Grapviz Node from a Frame.
 **)

relation build_frame_graphviz : Frame => Graphviz.Node =

  axiom	build_frame_graphviz FRAME(sid,ht,httypes,imps,bcframes,crs,encflag) 
	  => Graphviz.NODE("FRAME",[],[])
end

(** relation: build_item_listnode
 **
 ** Build a Graphviz Node from a list of items, selected by a condition
 ** relation among the input list.
 **)

relation build_item_listnode : ((Ident * Item) list, 
				(Ident * Item) => (), (* condition *)
				string) (* node name *)
	  => Graphviz.Node =

  rule	Util.list_matching (items, cond) => selitems &
	build_item_listnode_2 (selitems, 1) => node
	--------------------------------------------------------
	build_item_listnode (items, cond, name) 
	  => Graphviz.NODE(name, [], [node])

end

(** relation: build_item_listnode_2
 **
 ** Helper relation to build_item_listnode.
**)

relation build_item_listnode_2 : ((Ident * Item) list, int) 
	  => Graphviz.Node =

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, []) &
	int_string count => cstr
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [])

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, ignored) &
	int_string count => cstr &
	int_add (count, 1) => count' &
	build_item_listnode_2 (ignored, count') => restnode 
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [restnode])

end

(** relation: build_item_str
 **
 ** Helper relation to build_item_listnode_2, creates a string from an item.
 **)

relation build_item_str : (Ident * Item) => string =

  rule	string_append ("VAR: ",id) => s
	------------------------------
	build_item_str ((id, VAR(_,_,_,_))) => s

  rule	(*build_env_graphviz env => r &*)
	string_append ("CLASS: ", id) => s
	----------------------------------
	build_item_str ((id, CLASS(cls, env))) => s

  rule	string_append ("TYPE: ", id) => s
	---------------------------------
	build_item_str ((id, TYPE(_))) => s

end


(** BinTree implementation *)

(** relation: myhash
 **
 ** Hash function for binary tree implementation, using standard string
 ** hashing.
 **)

relation myhash: Key => int =

  rule	System.hash str => res
	------------
	myhash(str) => res
end


(** relation: tree_new
 **
 ** Create a new binary tree.
 **)

relation tree_new: () => BinTree =

  axiom	tree_new()  => TREENODE(NONE,NONE,NONE)

end

(** relation: tree_add
 **
 ** Add a tree to a binary tree.
 **)
relation tree_add: (BinTree, 
		    Key, 
		    Value, 
		    Key => int) (* hash func *)
	  => (BinTree) =

  axiom	tree_add (TREENODE(NONE,NONE,NONE),key,value,_) 
	  => TREENODE(SOME(TREEVALUE(key,value)),NONE,NONE)

	  (* Replace this node *)
  rule	rkey = key
	---------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),key,value,hashfunc)
	  => (TREENODE(SOME(TREEVALUE(rkey,value)),left,right))

	  (* Insert to right subtree*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_add(t,key,value,hashfunc) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(t')))

	  (* Insert to right node*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_add(TREENODE(NONE,NONE,NONE),key,value,hashfunc) => right'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as NONE),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right')))

	  (* Insert to left subtree*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_add(t,key,value,hashfunc) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(t'),right))

	  (* Insert to left node*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_add(TREENODE(NONE,NONE,NONE),key,value,hashfunc) => left'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as NONE,right),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left'),right))

  rule	print "tree_add failed\n"
	-----------------------
	tree_add(_,_,_,_) => fail
end 

(** relation: local_outside_connector_flowvars
 **
 ** Return the outside connector variables that are flow in the local scope.
 **)

relation local_outside_connector_flowvars: (Env) => Exp.ComponentRef list =

  rule	local_outside_connector_flowvars2(SOME(ht)) => res
	--------------------------------
	local_outside_connector_flowvars(FRAME(sid,ht,_,_,_,_,_)::_) => res
end

(** relation: local_outside_connector_flowvars2
 **
 ** Helper relation to local_outside_connector_flowvars
 **)

relation local_outside_connector_flowvars2: (BinTree option) 
	  => Exp.ComponentRef list =

  axiom	local_outside_connector_flowvars2(NONE) => []
	
  rule	local_outside_connector_flowvars2(l) => lst1 &
	local_outside_connector_flowvars2(r) => lst2 &
	Types.flow_variables(vars,Exp.CREF_IDENT(id,[])) => lst3 &
	Util.list_flatten([lst1,lst2,lst3])=> res
	-----------------------------
	local_outside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),vars),_),_),_,_,_))),l,r)))
	=> res

  rule	local_outside_connector_flowvars2(l) => lst1 &
	local_outside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_outside_connector_flowvars2(SOME(TREENODE(SOME(_),l,r)))
	  => res
end

(** relation: local_inside_connector_flowvars
 **
 ** Returns the inside connector variables that are flow from the local scope.
 **)

relation local_inside_connector_flowvars: (Env) => Exp.ComponentRef list =

  rule	local_inside_connector_flowvars2(SOME(ht)) => res
	--------------------------------
	local_inside_connector_flowvars(FRAME(sid,ht,_,_,_,_,_)::_) => res
end

(** relation: local_inside_connector_flowvars2
 ** 
 ** Helper relation to local_inside_connector_flowvars
 **)

relation local_inside_connector_flowvars2:(BinTree option) => Exp.ComponentRef list =

  axiom	local_inside_connector_flowvars2(NONE) => []

	(* If CONNECTOR then  outside and not inside, skip.. *)
  rule	local_inside_connector_flowvars2(l) => lst1 &
	local_inside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),_),_),_),_,_,_))),l,r)))
	=> res

	(* ... else retrieve connectors as subcomponents*)
  rule	local_inside_connector_flowvars3(vars,id) => lst1 &
	local_inside_connector_flowvars2(l) => lst2 &
	local_inside_connector_flowvars2(r) => lst3 &
	Util.list_flatten([lst1,lst2,lst3]) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(_,vars),_),_),_,_,_))),l,r)))
	=> res

	  (* if not complex, skip *)
  rule	local_inside_connector_flowvars2(l) => lst1 &
	local_inside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,t,_),_,_,_))),l,r)))
	=> res
end

(** relation: local_inside_connector_flowvars3
 **
 ** Helper relation to local_inside_connector_flowvars2
 **)

relation local_inside_connector_flowvars3: (Types.Var list,Ident) 
	  => Exp.ComponentRef list =

  axiom	 local_inside_connector_flowvars3 ([],_) => []

  rule	local_inside_connector_flowvars3(xs,oid) => lst1 &
	Types.flow_variables(vars,Exp.CREF_QUAL(oid,[],Exp.CREF_IDENT(id,[]))) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------------------------------
	local_inside_connector_flowvars3 (Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),vars),_),_)::xs,oid) => res

  rule	local_inside_connector_flowvars3(xs,oid) => res
	-----------------------------------------------
	local_inside_connector_flowvars3 (_::xs,oid) => res

end

(** relation: tree_get
 **
 ** Get a value from the binary tree given a key.
 **)

relation tree_get: (BinTree, Key, Key => int (* hash func *)) => Value =

  rule	rkey = key 
	---------------
	tree_get (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),
		  key,hashfunc) 
	  => rval

	  (* Search to the right*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_get(right,key,hashfunc) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right)),key,hashfunc)
	  => res
	  (* Search to the left*)
  rule	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_get(left,key,hashfunc) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left),right),key,hashfunc)
	  => res
end

(** relation: print_bintree_str
 **
 ** Prints the binary tree to a string
 **)

relation print_bintree_str: (BinTree ) => string =

  rule	print_frame_element_str((rkey,rval)) => s1 &
	Dump.get_option_str(l,print_bintree_str) => s2 &
	Dump.get_option_str(r,print_bintree_str) => s3 &
	Util.string_append_list([s2,s1,s3]) => res
	----------------------
	print_bintree_str(TREENODE(SOME(TREEVALUE(rkey,rval)),l,r)) => res

  rule	Dump.get_option_str(l,print_bintree_str) => s2 &
	Dump.get_option_str(r,print_bintree_str) => s3 &
	string_append(s2,s3) => res
	----------------------
	print_bintree_str(TREENODE(NONE,l,r)) => res
end
