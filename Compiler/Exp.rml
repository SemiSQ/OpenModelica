(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Exp.rml
 ** module:      Exp
 ** description: Expressions
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing expressions, after they have been examined by the
 ** static analyzer in the module `StaticExp'.  There are of course
 ** great similarities with the expression types in the `Absyn'
 ** module, but there are also several important differences.
 **
 ** No overloading of operators occur, and subscripts have been
 ** checked to see if they are slices.  All expressions are also type
 ** consistent, and all implicit type conversions in the AST are made
 ** explicit here.
 **
 ** Some expression simplification and solving is also done here. This is used
 ** for symbolic transformations before simulation, in order to rearrange
 ** equations into a form needed by simulation tools. simplify, solve,
 ** exp_contains, exp_equal are part of this code.
 **
 ** This module also contains relations for printing expressions, to io or to
 ** strings. Also graphviz output is supported.
 **)

module Exp:

  with "Absyn.rml"
  with "Graphviz.rml"


  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  (** - Basic types *)
  datatype Type = INT | REAL | BOOL | STRING | ENUM | OTHER 
  (** These types are not used as expression types (see the `Types'
   ** module for expression types).  They are used to parameterize
   ** operators which may work on several simple types. *)

  (** - Expressions *)
  datatype Exp = ICONST of int					(* Integer constants *)
	       | RCONST of real					(* Real constants *)
	       | SCONST of string				(* String constants *)
	       | BCONST of bool					(* Bool constants *)
	       | CREF of ComponentRef * Type			(* component references, e.g. a.b[2].c[1] *)
	       | BINARY of Exp * Operator * Exp			(* Binary operations, e.g. a+4 *)
	       | UNARY of Operator * Exp			(* Unary operations, -(4*x) *)
	       | LBINARY of Exp * Operator * Exp		(* Logical binary operations: and, or *)
	       | LUNARY of Operator * Exp			(* Logical unary operations: not *)
	       | RELATION of Exp * Operator * Exp		(* Relation, e.g. a <= 0 *)
	       | IFEXP of Exp * Exp * Exp			(* If expressions *)
	       | CALL of Absyn.Path * Exp list * bool (* tuple *) * bool (* builtin *) (* Function call *)
	       | ARRAY of Type * bool (*scalar for codegen*) * Exp list		(* Array constructor, e.g. {1,3,4} *)
	       | MATRIX of Type * int * (Exp*bool (*scalar*)) list list	(* Matrix constructor. e.g. [1,0;0,1] *)
	       | RANGE of Type * Exp * Exp option * Exp		(* Range constructor, e.g. 1:0.5:10 *)
	       | TUPLE of Exp list (*PR.*)			(* Tuples, used in func calls returning several 
								  arguments *)
                 (* New constructors *)
	       | CAST of Type * Exp				(* Cast operator *)
	       | ASUB of Exp * int				(* Array subscripts *)
               | SIZE of Exp * Exp option			(* The ssize operator *)
	       | CODE of Absyn.Code * Type			(* Modelica AST constructor *)
	       | REDUCTION of Absyn.Path * Exp (*expr*) * Ident * Exp (*range*)  (* Reduction expression *)
	       | END						(* array index to last element, e.g. a[end]:=1; *)
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp'
   ** datatype, but is used for statically analyzed expressions.  It
   ** includes explicit type promotions and typed (non-overloaded)
   ** operators. It also contains expression indexing with the `ASUB'
   ** constructor.  Indexing arbitrary array expressions is currently
   ** not supported in Modelica, but it is needed here. *)

  datatype Operator = ADD    	  of Type
		    | SUB    	  of Type
		    | MUL    	  of Type
		    | DIV    	  of Type
		    | POW    	  of Type
		    | UMINUS 	  of Type
		    | UPLUS  	  of Type
		    | UMINUS_ARR  of Type
		    | UPLUS_ARR   of Type
		    | ADD_ARR     of Type
		    | SUB_ARR     of Type
		    | MUL_SCALAR_ARRAY of Type   (* a * { b, c }            *)
		    | MUL_ARRAY_SCALAR of Type   (* {a, b} * c              *)
		    | MUL_SCALAR_PRODUCT of Type (* {a, b} * {c, d}         *)
		    | MUL_MATRIX_PRODUCT of Type (* {{..},..} * {{..},{..}} *)
		    | DIV_ARRAY_SCALAR of Type   (* {a, b} / c              *)
		    | POW_ARR     of Type
		    | AND | OR
		    | NOT
		    | LESS        of Type
		    | LESSEQ      of Type
		    | GREATER     of Type
		    | GREATEREQ   of Type
		    | EQUAL       of Type
		    | NEQUAL      of Type
		    | USERDEFINED of Absyn.Path (* The FQ name of the overloaded operator function *)
  (** Operators which are overloaded in the abstract syntax are here
   ** made type-specific.  The integer addition operator (`ADD(INT)')
   ** and the real addition operator (`ADD(REAL)') are two distinct
   ** operators. *)

  (** - Component references
   ** CREF_QUAL(...) is used for qualified component names, e.g. a.b.c
   ** CREF_IDENT(..) is used for non-qualifed component names, e.g. x 
   **)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Subscript = WHOLEDIM     (* a[:,1] *)
		     | SLICE of Exp (* a[1:3,1], a[1:2:10,2] *)
		     | INDEX of Exp (* a[i+1] *)
  (** The `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Absyn' module. *)

  (** - Exported relations *)

  relation is_range : Exp => bool
  relation is_zero: Exp => bool 
  relation is_const: Exp => bool 
  relation is_not_const: Exp => bool 

  relation is_relation: Exp => bool
  relation get_relations : Exp => Exp list 

  relation prepend_string_cref : (string, ComponentRef) => ComponentRef
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation subscript_cref: (ComponentRef, Subscript list) => ComponentRef	  
  relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef
  relation int_subscripts : int list => Subscript list
  relation simplify : Exp => Exp
  relation unelab_exp : Exp => Absyn.Exp 	   
  relation unelab_cref: ComponentRef => Absyn.ComponentRef
  relation contain_functioncall : Exp => bool
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_component_ref_str : ComponentRef => string
  relation print_subscript: Subscript => ()
  relation print_subscript_str: Subscript => string

  relation print_leftpar_str : (int,int) => (string, int) 
  relation print_rightpar_str : (int,int) => string 
  relation binop_symbol : Operator => string
  relation binop_priority : Operator => int 
  relation lbinop_symbol : Operator => string
  relation lbinop_priority : Operator => int
  relation unaryop_priority : Operator => int 
  relation lunaryop_priority : Operator => int 
  relation relop_priority : Operator => int 
  relation print_row_str : (Exp*bool) list => string 


  relation make_real_add: (Exp, Exp) => Exp
  relation make_real_array: (Exp list) => Exp

  relation print_list : ('a list, 'a => (), string) => ()
  relation cref_equal : (ComponentRef, ComponentRef) => bool
  relation cref_str : ComponentRef => string
  relation cref_to_path : ComponentRef => Absyn.Path
  relation path_to_cref : Absyn.Path => ComponentRef 
  relation cref_modelica_str : ComponentRef => string
  relation cref_last_ident : ComponentRef => Ident 
  relation cref_last_subs: ComponentRef => Subscript list
  relation cref_strip_last_subs: ComponentRef => ComponentRef
  relation cref_contained_in: (ComponentRef(*x*), ComponentRef(*y*))
	  => bool
  relation cref_prefix_of: (ComponentRef (* x*), ComponentRef (*y*))
	  => bool
  relation ident_equal: (Ident, Ident) => bool 
  relation print_list_str : ('a list, 'a => string, string) => string
  relation print_exp_str : Exp => string
  relation to_exp_cref : Absyn.ComponentRef => ComponentRef
  relation exp_equal: (Exp,Exp) => bool
  relation replace_exp: (Exp (*expr*), Exp(* source expr*),Exp(*target expr*)) 
	  => (Exp,int)
  relation replace_exp_list: (Exp (*expr*), Exp list (* source list*), Exp list (* target list*))
	  => (Exp,int)
  relation stringify_crefs: (Exp) => Exp
  relation stringify_component_ref: ComponentRef => ComponentRef 
  relation binop_symbol_1 : Operator => string 
  relation unaryop_symbol : Operator => string 
  relation lunaryop_symbol : Operator => string 
  relation relop_symbol : Operator => string 
  relation dump_exp_graphviz : Exp => Graphviz.Node
  relation exp_contains : (Exp, Exp) => bool
  relation solve : (Exp, Exp, Exp) => Exp
  relation get_cref_from_exp: (Exp) => ComponentRef list	 
  relation typeof: (Exp) => Type 
  relation type_builtin: (Type) => bool
  relation get_function_calls_list : Exp list => Exp list
  relation get_function_calls : Exp  => Exp list
  relation type_string : Type => string

  relation factors: Exp => Exp list 
  relation terms: Exp => Exp list 
  relation quotient: Exp => (Exp,Exp)	  
  relation make_sum: (Exp list) => Exp 
  relation abs: (Exp) => Exp

  relation dump_exp_str : (Exp,int) => string  


  relation traverse_exp: (Exp, 
			  ((Exp * 'a) => (Exp * 'a)),  (* rel-ation to apply*)
			  'a) (* extra value passed to re-lation*)
	  => (Exp *  'a) 

end


with "RTOpts.rml"
with "Util.rml"
with "Print.rml"
with "ModUtil.rml"
with "Derive.rml"
with "System.rml" 
with "Dump.rml"

val rconstone = RCONST(1.0)


(** relation: cref_to_path
 **
 ** This relation converts a `ComponentRef' to a `Path', if possible.
 ** If the component reference contains subscripts, it will silently
 ** fail.
 **)

relation cref_to_path : ComponentRef => Absyn.Path =

  axiom	cref_to_path CREF_IDENT(i,[]) => Absyn.IDENT(i)

  rule	cref_to_path c => p
	-------------------
	cref_to_path CREF_QUAL(i,[],c) => Absyn.QUALIFIED(i,p)
end

(** relation: path_to_cref
 **
 ** This relation converts a `Absyn.Path' to a `ComponentRef'.
 **)

relation path_to_cref : Absyn.Path => ComponentRef   =

  axiom	path_to_cref Absyn.IDENT(i) => CREF_IDENT(i,[]) 

  rule	path_to_cref p => c
	-------------------
	path_to_cref Absyn.QUALIFIED(i,p) => CREF_QUAL(i,[],c) 
end

(** relation: cref_str
 **
 ** This relation simply converts a `ComponentRef' to a `string'.
 **)

relation cref_str: ComponentRef => string =

  axiom	cref_str(CREF_IDENT(s,_)) => s
  
  rule	cref_str(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	cref_str(CREF_QUAL(s,_,n)) => ss
end

(** relation: cref_modelica_str
 **
 ** Same as cre_str, but uses '_' instead of '.' 
 **)

relation cref_modelica_str : ComponentRef => string =
  axiom	cref_modelica_str(CREF_IDENT(s,_)) => s
  
  rule	cref_modelica_str(n) => ns &
	string_append(s,"_") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	cref_modelica_str(CREF_QUAL(s,_,n)) => ss
end

(** relation: cref_last_ident
 ** author: PA
 **
 ** Returns the last identfifier of a 'ComponentRef'.
 **)

relation cref_last_ident : ComponentRef => Ident =

  axiom	cref_last_ident(CREF_IDENT(id,_)) => id

  rule	cref_last_ident(cr) => res
	-------------------
	cref_last_ident(CREF_QUAL(_,_,cr)) => res
end

(** relation: cref_last_subs
 **
 ** Return the last subscripts of a ComponentRef
**)

relation cref_last_subs: ComponentRef => Subscript list =

  axiom	cref_last_subs(CREF_IDENT(id,subs)) => subs 

  rule	cref_last_subs(cr) => res
	---------------------
	cref_last_subs(CREF_QUAL(_,_,cr)) => res
end

(** relation: cref_strip_last_subs
 **
 ** Strips the last subscripts of a ComponentRef
**)

relation cref_strip_last_subs: ComponentRef => ComponentRef =

  axiom	cref_strip_last_subs(CREF_IDENT(id,subs)) => CREF_IDENT(id,[]) 

  rule	cref_strip_last_subs(cr) => cr'
	---------------------
	cref_strip_last_subs(CREF_QUAL(id,s,cr)) => CREF_QUAL(id,s,cr')
end

(** relation: cref_contained_in
 ** author: PA
 **
 ** Returns true if y is a sub component ref of x.
 ** For instance, b.c. is a sub_component of a.b.c.
 **)
relation cref_contained_in: (ComponentRef(*x*), ComponentRef(*y*)) 
	  => bool =
	  
  rule	cref_equal(x,y) => true
	-----------------------
	cref_contained_in(x,y) => true
	
  rule	cref_contained_in(y,cr2) => res
	----------------------
	cref_contained_in(CREF_QUAL(_,_,cr2),y) => res

  axiom	cref_contained_in(_,_) => false
end

(** relation: cref_prefix_of
 ** author: PA
 ** 
 ** Returns true if y is a prefix of x
 ** For example, a.b is a prefix of a.b.c
 **)
relation cref_prefix_of: (ComponentRef (* x*), ComponentRef (*y*))
	=> bool =

  rule	cref_equal(cr1,cr2) => true 
	------------------------
	cref_prefix_of(cr1,cr2) => true 

  rule	id1=id2 &
	subscript_equal(ss1,ss2) => true &
	cref_prefix_of(cr1,cr2) => res
	-------------------------
	cref_prefix_of(CREF_QUAL(id1,ss1,cr1),CREF_QUAL(id2,ss2,cr2)) => res

  rule	id1 = id2 &
	subscript_equal(ss1,ss2) => res
	-------------------------------
	cref_prefix_of(CREF_IDENT(id1,ss1),CREF_QUAL(id2,ss2,_)) => res

  axiom	cref_prefix_of(_,_) => false
end

(** relation: ident_equal
 ** author: PA
 **
** Compares two 'Ident'.
**)

relation ident_equal: (Ident, Ident) => bool =

  rule	id1 = id2 
	-------------------
	ident_equal(id1,id2) => true

  axiom	ident_equal(_,_) => false
end

(** relation: is_range
 **
 ** Returns true if expression is a range expression.
 **)

relation is_range : Exp => bool =

  axiom	is_range RANGE(_,_,_,_) => true
  axiom	is_range _ => false

end

(** relation: is_zero
 **
 ** Returns true íf an expression is constant and has the value zero, 
 ** otherwise false
 **)
relation is_zero: Exp => bool =

  rule	int_eq(ival,0) => true
	----------------------
	is_zero(ICONST(ival)) => true

  rule	(* Due to bug in rml, go trough a cast from int *)
	int_real(0) => rzero &
	real_eq(rzero,rval) => true 
	---------------------------
	is_zero(RCONST(rval)) => true

  rule	(* Casting to zero is still zero *)
	is_zero(e) => res 
	------------------
	is_zero(CAST(t,e)) => res

  axiom	is_zero(_) => false

end

(** relation: is_const
 **
 ** Returns true íf an expression is constant 
 ** otherwise false
 **)

relation is_const: Exp => bool =

  axiom	is_const(ICONST(ival)) => true

  axiom	is_const(RCONST(rval)) => true

  axiom	is_const(BCONST(bval)) => true

  axiom	is_const(SCONST(sval)) => true

  rule	is_const(e) => res
	---------------------------
	is_const(UNARY(op,e)) => res

	(* Casting to zero is still zero *)
  rule	is_const(e) => res 
	------------------
	is_const(CAST(t,e)) => res

  axiom	is_const(_) => false
end

(** relation is_not_const
 ** author: PA
 **
 ** Check if expression is not constant.
 **)
relation is_not_const: Exp => bool =
	
  rule	is_const(e) => b &
	bool_not(b) => nb
	-----------------
	is_not_const(e) => nb
end

(** relation: is_relation
 **
 ** Returns true if expression is a relation expression.
 **)

relation is_relation : (Exp) => bool =

  axiom	is_relation(RELATION(_,_,_)) => true
  axiom  is_relation(LUNARY(_,RELATION(_,_,_))) => true

  rule   is_relation(e1) => b1 &
	is_relation(e2) => b2 &
	bool_or(b1,b2) => res
	----------------------------------------
	is_relation(LBINARY(e1,_,e2)) => res
	
  axiom	is_relation(_) => false
end

(** relation: get_relations
 **
 ** Retrieve all relation sub expressions in an expression.
 **)

relation get_relations : (Exp) => Exp list =
  axiom	get_relations(e as RELATION(_,_,_)) => [e]

  rule	get_relations(e1) => rellst1 &
	get_relations(e2) => rellst2 &
	list_append(rellst1,rellst2) => rellst
	----------------------------------------
	get_relations(LBINARY(e1,_,e2)) => rellst

  rule	get_relations(e) => rellst 
	----------------------------------------
	get_relations(LUNARY(_,e)) => rellst

  rule	get_relations(e1) => rellst1 &
	get_relations(e2) => rellst2 &
	list_append(rellst1,rellst2) => rellst
	----------------------------------------
	get_relations(BINARY(e1,_,e2)) => rellst

  rule	get_relations(cond) => rellst1 &
	get_relations(tb) => rellst2 &
	get_relations(fb) => rellst3 &
	list_append(rellst1,rellst2) => rellst4 &
	list_append(rellst3,rellst4) => rellst
	----------------------------------------
	get_relations(IFEXP(cond,tb,fb)) => rellst

  rule	get_relations(e) => rellst
	----------------------------------------
	get_relations(ARRAY(_,_,[e])) => rellst

  rule	get_relations(ARRAY(t,sc,xs)) => rellst1 &
	get_relations(e) => rellst2 &
	list_append(rellst1,rellst2) => rellst
	----------------------------------------
	get_relations(ARRAY(t,sc,e::xs)) => rellst

  rule	get_relations(e) => rellst 
	----------------------------------------
	get_relations(UNARY(_,e)) => rellst

  axiom	get_relations(_) => []
end

(** relation: join_crefs
 **
 ** Join two component references by concatenating them.
 **)

relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef =

  axiom	join_crefs ( CREF_IDENT(id,sub),cr2) => CREF_QUAL(id,sub,cr2)
	
  rule	join_crefs(cr,cr2) => cr'
	------------------------
	join_crefs (CREF_QUAL(id,sub,cr),cr2) => CREF_QUAL(id,sub,cr')
end 

(** relation: cref_equal
 **
 ** Returns true if two component references are equal
 **)

relation cref_equal : (ComponentRef, ComponentRef) => bool =

  rule	n1 = n2 &
	subscript_equal(idx1,idx2) => true
	-------
	cref_equal (CREF_IDENT(n1, idx1), CREF_IDENT(n2, idx2)) => true

  rule	n1 = n2 &
	cref_equal (cr1, cr2) => true &
	subscript_equal(idx1,idx2) => true 
	-----------------------------
	cref_equal (CREF_QUAL(n1, idx1, cr1), CREF_QUAL(n2, idx2, cr2))
	  => true

  rule	(* There is a bug here somewhere or in RML.
	 * Therefore as a last resort, print the strings and compare.
	 **)
 	print_component_ref_str cr1 => s1 &
	print_component_ref_str cr2 => s2 &
	s1 = s2
	------------------------
	cref_equal(cr1,cr2) => true

  axiom	cref_equal (_, _) => false

end

(** relation: subscript_equal
 ** 
 ** Returns true if two subscript lists are equal.
 **)

relation subscript_equal: ( Subscript list, Subscript list) => bool =

  axiom	subscript_equal([],[]) => true

  rule	subscript_equal(xs1,xs2) => res 
	-------------------------------
	subscript_equal(WHOLEDIM::xs1,WHOLEDIM::xs2) => res

  rule	exp_equal(e1,e2) => true &
	subscript_equal(xs1,xs2) => res 
	-------------------------------
	subscript_equal(SLICE(e1)::xs1,SLICE(e2)::xs2) => res

  rule	exp_equal(e1,e2) => true &
	subscript_equal(xs1,xs2) => res 
	-------------------------------
	subscript_equal(INDEX(e1)::xs1,INDEX(e2)::xs2) => res

  axiom	subscript_equal(_,_) => false
end

(** relation: prepend_string_cref
 **
 ** Prepend a string to a component reference.
 ** For qualified named, this means prepending a string to the 
 ** first identifier.
 **)

relation prepend_string_cref : (string, ComponentRef) => ComponentRef =

  rule	string_append (p, i) => i'
	------------------------------
	prepend_string_cref (p, CREF_QUAL(i, s, c)) => CREF_QUAL(i',s,c)

  rule	string_append (p, i) => i'
	--------------------------
	prepend_string_cref (p,CREF_IDENT(i, s)) => CREF_IDENT(i',s)

end	

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end

(** relation: subscript_cref
 **
 ** The 'subscript_cref' relation adds a subscript to the 'ComponentRef'
 ** For instance 'a.b' with subscript 10 becomes 'a.b[10] and 'c.d[1,2] with subscript 
 ** 3,4 becomes 'c.d[1,2,3,4]' 
 **)

relation subscript_cref: (ComponentRef, Subscript list) => ComponentRef	=

  rule	list_append(sub,newsub) => newsub'
	-----------------------------------
	subscript_cref (CREF_IDENT(id,sub),newsub) => CREF_IDENT(id,newsub')

  rule	subscript_cref(cref,newsub) => cref'
	-----------------------------------
	subscript_cref (CREF_QUAL(id,sub,cref),newsub) => CREF_QUAL(id,sub,cref')
end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

(** relation: int_subscripts
 **
 ** This relation describes the relation between a list of integers
 ** and a list of `Exp.Subscript' where each integer is converted to
 ** an integer indexing expression.
 **)

relation int_subscripts : int list => Subscript list =

  axiom	int_subscripts [] => []

  rule	int_subscripts xs => xs'
	------------------------
	int_subscripts x::xs => INDEX(ICONST(x))::xs'

end

(** relation: simplify
 **
 ** This relation does some very basic simplification on expressions.
 ** It is not intended to be used to simplify expressions provided by
 ** the model, but to simplify unnecessarily complex expressions
 ** constructed during instantiation. 
 ** PA. Added rules for binary, unary operations
 ** and multiplication with zero, addition with zero, etc. Useful when deriving 
 ** equations and then want to simplify
 **)

relation simplify : Exp => Exp =


  axiom	simplify (CAST(REAL,RCONST(v))) => RCONST(v)

  rule	simplify(e) => ICONST(v) &
	int_real(v) => rv 
	-----------------
	simplify (CAST(REAL,e)) => RCONST(rv)

	(* cast of array *)
  rule	simplify(e) => ARRAY(t,b,exps) &
 	Util.list_map_1(exps,add_cast,tp) => exps' &
 	simplify(ARRAY(t,b,exps')) => res
	-----------------
	simplify (CAST(tp,e)) => res
	
  rule	simplify(e) => MATRIX(t,n,exps) &
	matrix_exp_map_1(exps,add_cast,tp) => exps' &
	simplify(MATRIX(tp,n,exps')) => res
	----------------------------------
	simplify(CAST(tp,e)) => res

	(* Array and Matrix stuff *)

  rule	simplify e => ARRAY(t,b,exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify ASUB(e, i) => exp

  rule	simplify e => MATRIX(t,n,exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => (expl) &
	Util.split_tuple2_list(expl) => (expl',bls) &
	Util.bool_and_list(bls) => b
	-----------------------
	simplify ASUB(e, i) => ARRAY(t,b,expl')

  rule	simplify e => IFEXP(c,t,f) &
	simplify ASUB(t,i) => t' &
	simplify ASUB(f,i) => f'
	------------------------
	simplify ASUB(e, i) => IFEXP(c,t',f')

  rule	simplify e => CREF(CREF_IDENT(n,s),t) &
	subscripts_append(s,i) => s'
	------------------------
	simplify ASUB(e, i) => CREF(CREF_IDENT(n,s'),t)

  rule	simplify e => CREF(CREF_QUAL(n,s,c),t) &
	simplify ASUB(CREF(c,t), i) => CREF(c',t)
	-------------------------------------
	simplify ASUB(e, i) => CREF(CREF_QUAL(n,s,c'),t)

  rule	(* For arbitrary vector operations, e.g (a+b-c)[1] => a[1]+b[1]-c[1] *)
	
 	simplify_asub(e,i) => e 
	-----------------------
	simplify ASUB(e,i) => e

	(* Operations *)


  rule	simplify e1 => e1' &
	let exp' = UNARY(op, e1') &
	simplify_unary (exp', op, e1') => e
	----------------------------------
	simplify (exp as UNARY(op, e1)) => e


  rule	simplify e1 => e1' &
	simplify e2 => e2' &
	let exp' = BINARY(e1', op, e2') &
	simplify_binary_sort_constants(exp') => exp'' &
	try_simplify_binary(exp'') => exp''' &
	simplify_binary_coeff(exp''') => e'
	----------------------------------------
	simplify (exp as BINARY(e1, op, e2)) => e'

  rule	simplify e1 => e1' &
	simplify e2 => e2' &
	let exp' = RELATION(e1', op, e2') &
	simplify_binary (exp', op, e1', e2') => e
	----------------------------------------
	simplify (exp as RELATION(e1, op, e2)) => e

  rule	simplify e1 => e1' &
	let exp' = LUNARY(op, e1') &
	simplify_unary (exp', op, e1') => e
	----------------------------------
	simplify (exp as LUNARY(op, e1)) => e

  rule	simplify e1 => e1' &
	simplify e2 => e2' &
	let exp' = LBINARY(e1', op, e2') &
	simplify_binary (exp', op, e1', e2') => e
	----------------------------------------
	simplify (exp as LBINARY(e1, op, e2)) => e


  rule	simplify(e1) => e1' &
	simplify(e2) => e2' &
	simplify(e3) => e3' &
	exp_equal(e2,e3) => remove_if &
	Util.if(remove_if,e2',IFEXP(e1,e2',e3')) => res
	-----------------------
	simplify (IFEXP(e1,e2,e3)) 
	  => res

  axiom	simplify e => e

end

(** relation: add_cast
 **
 ** Adds a cast of a Type to an expression.
 **)

relation add_cast:(Exp, Type) => Exp =

  axiom	add_cast(e,tp) => CAST(tp,e)
end

(** relation: simplify_binary_sort_constants
 ** author: PA
 **
 ** Sorts all constants of a sum or product to the beginning of the expression.
 ** Also combines expressions like 2*a+4*a and a*a*a+3*a^3.
 **)

relation simplify_binary_sort_constants: (Exp) => Exp =

  rule	factors(e) => e_lst &
	Util.list_map(e_lst,simplify) => e_lst' &
	Util.list_select(e_lst',is_const) => const_es1 &
	Util.list_select(e_lst',is_not_const) => notconst_es1 &
	simplify_binary_mul_constants(const_es1) => const_es1' &
	list_append(const_es1',notconst_es1) => e_lst'' &
	make_product(e_lst'') => res 
	------------------------
	simplify_binary_sort_constants(e as BINARY(e1,MUL(tp),e2)) 
	  => res

  rule	terms(e) => e_lst &
	Util.list_map(e_lst,simplify) => e_lst' &
	Util.list_select(e_lst',is_const) => const_es1 &
	Util.list_select(e_lst',is_not_const) => notconst_es1 &
	simplify_binary_add_constants(const_es1) => const_es1' &
	list_append(const_es1',notconst_es1) => e_lst'' &
	make_sum(e_lst'') => res 
	------------------------
	simplify_binary_sort_constants(e as BINARY(e1,ADD(tp),e2)) 
	  => res

  axiom	simplify_binary_sort_constants(e) => e
end

(** relation: simplify_binary_coeff
 ** author: PA
 **
 ** Combines expressions like 2*a+4*a and a*a*a+3*a^3, etc
 **)

relation simplify_binary_coeff: (Exp) => Exp =

  rule	factors(e) => e_lst &
	simplify_mul(e_lst) => e_lst' &
	make_product(e_lst') => res 
	------------------------
	simplify_binary_coeff(e as BINARY(e1,MUL(tp),e2)) 
	  => res

  rule	factors(e1) => e1_lst &
	factors(e2) => e2_lst &
 	inverse_factors(e2_lst) => e2_lst' &
	list_append(e1_lst,e2_lst') => e_lst &
 	simplify_mul(e_lst) => e_lst' &
	make_product(e_lst') => res 
	------------------------
 	simplify_binary_coeff(e as BINARY(e1,DIV(tp),e2)) 
	  => res

  rule	terms(e) => e_lst & 
	simplify_add(e_lst) => e_lst' &
	make_sum(e_lst') => res 
	------------------------
	simplify_binary_coeff(e as BINARY(e1,ADD(tp),e2)) 
	  => res

  axiom	simplify_binary_coeff(e) => e
end

(** relation: try_simplify_binary
 ** author: PA
 **
 ** Helper relation to simplify. Tries to call simplify binary.
 **)

relation try_simplify_binary:(Exp) => Exp =

  rule	simplify_binary(e,op,e1,e2) => res
	-----------------------
	try_simplify_binary(e as BINARY(e1,op,e2)) => res

  axiom	try_simplify_binary(e) => e

end

(** relation: simplify_binary_add_constants
 ** author: PA
 **
 ** Adds all expressions in the list, given that they are constant.
**)

relation simplify_binary_add_constants: (Exp list) => Exp list =

  axiom	simplify_binary_add_constants([]) => []
  axiom	simplify_binary_add_constants([e]) => [e]

  rule	simplify_binary_add_constants(es) => [e] &
	simplify_binary_const(ADD(REAL),e1,e) => e' 
	------------------------------------
	simplify_binary_add_constants(e1::es) => [e']

  rule	print "simplify_binary_add_constants failed\n" 
	-------------------------
	simplify_binary_add_constants(_) => fail
end

(** relation: simplify_binary_add_constants
 ** author: PA
 **
 ** Multiplies all expressions in the list, given that they are constant.
**)

relation simplify_binary_mul_constants: (Exp list) => Exp list =

  axiom	simplify_binary_mul_constants([]) => []
  axiom	simplify_binary_mul_constants([e]) => [e]

  rule	simplify_binary_mul_constants(es) => [e] &
	simplify_binary_const(MUL(REAL),e1,e) => e' 
	------------------------------------
	simplify_binary_mul_constants(e1::es) => [e']
end

(** relation: simplify_mul
 ** author: PA
 **
 ** Simplifies expressions like a*a*a*b*a*b*a
 **)

relation simplify_mul: (Exp list ) => Exp list =

  rule	Util.list_map(expl,print_exp_str) => sl &
	Util.string_delimit_list(sl,", ") => s &
	
	simplify_mul2(expl) => exp_const &
	simplify_mul_join_factors(exp_const) => exp_const' &
	simplify_mul_make_pow(exp_const') => expl'
	-------------------------
	simplify_mul(expl) => expl'
end

(** relation: simplify_mul2
 ** author: PA
 ** 
 ** Helper relation to simplify_mul.
 **)

relation simplify_mul2: (Exp list) => (Exp*real) list =

  axiom	simplify_mul2([]) => [] 

  rule	simplify_binary_mul_coeff2(e) => (e',coeff) &
	simplify_mul2(es) => rest 
	-----------------------------
	simplify_mul2(e::es) => ((e',coeff)::rest)
end


(** relation: simplify_mul_join_factors
** author: PA
 **
 ** Helper relation to simplify_mul. Joins expressions that have the same
 ** base. E.g. [(a,2), (a,4),(b,2)] => [(a,6),(b,2)]
**) 
relation simplify_mul_join_factors:((Exp*real) list) => ((Exp*real) list) =

  axiom	simplify_mul_join_factors([]) => [] 

  rule	simplify_mul_join_factors_find(e,rest) => (coeff2,rest') &
	simplify_mul_join_factors(rest') => res &
	real_add(coeff,coeff2) => coeff' 
	------------------------------
	simplify_mul_join_factors((e,coeff)::rest) => ((e,coeff')::res)
end

(** relation: simplify_mul_join_factors_find
 ** author: PA
 **
 ** Helper relation to simplify_mul_join_factors. Searches rest of list
 ** to find all occurences of a base.
 **)
relation simplify_mul_join_factors_find: (Exp, (Exp*real) list) 
	  => (real, (Exp*real) list) = 

  axiom	simplify_mul_join_factors_find(_,[]) => (0.0,[])

	(* e1 == e2 *)
  rule	exp_equal(e,e2) => true &
	simplify_mul_join_factors_find(e,rest) => (coeff2,res) &
	real_add(coeff,coeff2) => coeff3
	------------------------------
	simplify_mul_join_factors_find(e,(e2,coeff)::rest) => (coeff3,res)

	(* e11-e12 and e12-e11, negative -1.0 factor *)
  rule	exp_equal(e,BINARY(e2,SUB(tp),e1)) => true &
	simplify_mul_join_factors_find(e,rest) => (coeff2,res) &
	real_sub(coeff,coeff2) => coeff3
	------------------------------
	simplify_mul_join_factors_find(e,(BINARY(e1,SUB(tp),e2),coeff)::rest) => (coeff3,res)

	(* not exp_equal *)
  rule	simplify_mul_join_factors_find(e,rest) => (coeff2,res)
	------------------------------
	simplify_mul_join_factors_find(e,(e2,coeff)::rest)
	  => (coeff2, (e2,coeff)::res)
end

(** relation: simplify_mul_make_pow
 ** author: PA
 ** 
 ** Helper relation to simplify_mul. Makes each item in the list into
 ** a pow expression, except when exponent is 1.0.
 **)

relation simplify_mul_make_pow:((Exp*real) list) => Exp list =

  axiom	simplify_mul_make_pow([]) => []

  rule	real_eq(r,1.0) => true &
	simplify_mul_make_pow(xs) => res
	-----------------------------
	simplify_mul_make_pow((e,r)::xs) => (e::res)

  rule	simplify_mul_make_pow(xs) => res
	-----------------------------
	simplify_mul_make_pow((e,r)::xs) 
	  => (BINARY(e,POW(REAL),RCONST(r))::res)
end

(** relation: simplify_add
 ** author: PA
 **
 ** Simplifies ters like 2*a+4*b+2*a+a+b
 **)

relation simplify_add: (Exp list ) => Exp list =

  rule	simplify_add2(expl) => exp_const &
	simplify_add_join_terms(exp_const) => exp_const' &
	simplify_add_make_mul(exp_const') => expl'
	-------------------------
	simplify_add(expl) => expl'

  rule	print "-simplify_add failed\n" 
	-------------------------
	simplify_add(_) => fail
end

(** relation: simplify_add2
 ** author: PA
 ** 
 ** Helper relation to simplify_add
 **)

relation simplify_add2: (Exp list) => (Exp*real) list =

  axiom	simplify_add2([]) => [] 

  rule	simplify_binary_add_coeff2(e) => (e',coeff) &
	simplify_add2(es) => rest 
	-----------------------------
	simplify_add2(e::es) => ((e',coeff)::rest)

  rule	print "simplify_add2 failed\n" 
	----------------------
	simplify_add2(_) => fail
end

(** relation: simplify_add_join_terms
 ** author: PA
 **
 ** Helper relation to simplify_add. Join all terms with the same expression.
 ** i.e. 2*a+4*a gives an element  (a,6) in the list.
**)

relation simplify_add_join_terms:((Exp*real) list) => ((Exp*real) list) =

  axiom	simplify_add_join_terms([]) => [] 

  rule	simplify_add_join_terms_find(e,rest) => (coeff2,rest') &
	simplify_add_join_terms(rest') => res &
	real_add(coeff,coeff2) => coeff3
	------------------------------
	simplify_add_join_terms((e,coeff)::rest) => ((e,coeff3)::res)
end

(** relation: simplify_add_join_terms_find
 ** author: PA
 ** 
 ** Helper relation to simplify_add_join_terms, finds all occurences of exp.
 **)

relation simplify_add_join_terms_find: (Exp, (Exp*real) list) 
	  => (real, (Exp*real) list) = 

  axiom	simplify_add_join_terms_find(_,[]) => (0.0,[])

  rule	exp_equal(e,e2) => true &
	simplify_add_join_terms_find(e,rest) => (coeff2,res) &
	real_add(coeff,coeff2) => coeff3
	------------------------------
	simplify_add_join_terms_find(e,(e2,coeff)::rest) => (coeff3,res)

	(* not exp_equal *)
  rule	simplify_add_join_terms_find(e,rest) => (coeff2,res)
	------------------------------
	simplify_add_join_terms_find(e,(e2,coeff)::rest)
	  => (coeff2, (e2,coeff)::res)
end

(** relation: simplify_add_make_mul
 ** author: PA
 **
 ** Makes multiplications of each element in the list, except for 
 ** coefficient 1.0
 **)

relation simplify_add_make_mul:((Exp*real) list) => Exp list =

  axiom	simplify_add_make_mul([]) => []

  rule	real_eq(r,1.0) => true &
	simplify_add_make_mul(xs) => res
	-----------------------------
	simplify_add_make_mul((e,r)::xs) => (e::res)

  rule	simplify_add_make_mul(xs) => res
	-----------------------------
	simplify_add_make_mul((e,r)::xs) 
	  => (BINARY(RCONST(r),MUL(REAL),e)::res)
end

(** relation: make_factor_division
 ** author: PA
 **
 ** Takes two expression lists (factors) and makes a division of the two
 ** If the second list is empty, no division node is created.
 **)
relation make_factor_division: (Exp list, Exp list) => Exp =

  axiom	make_factor_division([],[])=> RCONST(1.0)

  rule	Util.list_select(es1,is_const) => const_es1 &
	Util.list_select(es1,is_not_const) => notconst_es1&
	list_append(const_es1,notconst_es1) => es1' &
	make_product(es1') => res &
	simplify res => res'
 	------------------------
	make_factor_division(es1,[]) => res'

	(* e1*...*en / 1.0 => e1*...*en *)
  rule	is_const_one(e1) => true &
	make_product(es1) => res 
 	------------------------
	make_factor_division(es1,[e1]) => res

  rule	Util.list_select(es2,is_const) => const_es2 &
	Util.list_select(es2,is_not_const) => notconst_es2 &
	list_append(const_es2,notconst_es2) => es2' &
	make_product(es2') => q &
	simplify q => q'
	------------------------
	make_factor_division([],es2) 
	  => BINARY(RCONST(1.0),DIV(REAL),q')
	
  rule	Util.list_select(es1,is_const) => const_es1 &
	Util.list_select(es1,is_not_const) => notconst_es1&
	list_append(const_es1,notconst_es1) => es1' &
	Util.list_select(es2,is_const) => const_es2 &
	Util.list_select(es2,is_not_const) => notconst_es2 &
	list_append(const_es2,notconst_es2) => es2' &
	make_product(es1') => p &
	make_product(es2') => q &
	simplify p => p' &
	simplify q => q' 
	--------------------
	make_factor_division(es1,es2) => BINARY(p',DIV(REAL),q')
end

(** relation: remove_common_factors
 ** author: PA
 **
 ** Takes two lists of expressions (factors) and removes the factors common
 ** to both lists. The special case of the ident^exp is treated by subtraction 
 ** of the exponentials.
 **)
relation remove_common_factors: (Exp list, Exp list) => (Exp list, Exp list) =

  rule	find_pow_factor(cr,es2) => (BINARY(_,POW(_),e2),es2') &
	remove_common_factors(es1,es2') => (es1',es2'') &
	simplify(BINARY(CREF(cr,tp),POW(REAL),BINARY(e1,SUB(REAL),e2))) 
	  => pow_e 
	-------------------
	remove_common_factors(BINARY(CREF(cr,tp),POW(_),e1)::es1,es2)
	  => (pow_e::es1',es2'')
		 
  rule	Util.list_getmember_p(e,es2,exp_equal) => _ &
	Util.list_deletemember_p(es2,e,exp_equal) => es2' &
	remove_common_factors(es1,es2') => (es1',es2'')
	---------------------------------
	remove_common_factors(e::es1,es2) => (es1',es2'')

  rule	remove_common_factors(es1,es2) => (es1',es2')
	----------------------
	remove_common_factors(e::es1,es2) => (e::es1',es2')

  axiom	remove_common_factors([],es2) => ([],es2)
end

(** relation find_pow_factor
 ** author: PA
 ** 
 ** Helper relation to remove_common_factors. Finds a POW expression in
 ** a list of factors.
 **)

relation find_pow_factor: (ComponentRef, Exp list) => (Exp, Exp list) =

  rule	cref_equal(cr,cr2) => true
	------------------------
	find_pow_factor(cr,(e as BINARY(CREF(cr2,_),POW(_),_))::es) 
	  => (e,es)

  rule	find_pow_factor(cr,es) => (pow_e,es)
	------------------------
	find_pow_factor(cr,e::es) 
	  => (pow_e,e::es)
end


(** relation: simplify_binary_add_coeff2
 **
 ** This relation checks for x+x+x+x and returns (x,4.0)
 **)

 relation simplify_binary_add_coeff2:(Exp) => (Exp, real) =

  axiom	simplify_binary_add_coeff2(exp as CREF(_,_)) => (exp, 1.0)
	 
  axiom	simplify_binary_add_coeff2(BINARY(RCONST(coeff),MUL(_),e1))
	  => (e1,coeff )

  axiom	simplify_binary_add_coeff2(BINARY(e1,MUL(_),RCONST(coeff)))
	  => (e1,coeff )
        
  rule	int_real(coeff) => coeff'
        -------------------------------
        simplify_binary_add_coeff2(BINARY(e1,MUL(_),ICONST(coeff))) 
	  => (e1,coeff' )

  rule	int_real(coeff) => coeff'
        -------------------------------
        simplify_binary_add_coeff2(BINARY(ICONST(coeff),MUL(_),e1)) 
	  => (e1,coeff')

  rule	exp_equal(e1,e2) => true
        --------------------------
        simplify_binary_add_coeff2 (BINARY(e1,ADD(tp),e2)) => (e1,2.0)

  axiom	simplify_binary_add_coeff2(e) => (e,1.0)
       
end

(** relation: simplify_binary_mul_coeff2
 **
 ** This relation takes an expression X*X*X*X*X and return (X,5.0)
 ** to be used for X^5.
 **)
		 
relation simplify_binary_mul_coeff2:(Exp) => (Exp, real) =

  axiom	simplify_binary_mul_coeff2(e as CREF(cr,_)) => (e, 1.0)

  axiom	simplify_binary_mul_coeff2(BINARY(e1,POW(_),RCONST(coeff)))
	  => (e1,coeff )

  rule	real_sub(0.0,coeff) => coeff'
	------------------------------------------
	
	simplify_binary_mul_coeff2(BINARY(e1,POW(_),UNARY(UMINUS(tp),RCONST(coeff)))) 
	  => (e1,coeff')

  rule	int_real(coeff) => coeff'
        -------------------------------
        simplify_binary_mul_coeff2(BINARY(e1,POW(_),ICONST(coeff))) 
	  => (e1,coeff' )

  rule	int_real(coeff) => coeff' &
	real_sub(0.0,coeff') => coeff''
	------------------------------------------
	simplify_binary_mul_coeff2(BINARY(e1,POW(_),UNARY(UMINUS(tp),ICONST(coeff)))) 
	  => (e1,coeff')

  rule	int_real(coeff) => coeff'
        -------------------------------
        simplify_binary_mul_coeff2(BINARY(ICONST(coeff),POW(_),e1)) 
	  => (e1,coeff')
        
  rule	exp_equal(e1,e2) => true
        --------------------------
        simplify_binary_mul_coeff2(BINARY(e1,MUL(tp),e2)) => (e1,2.0)
        
  axiom	simplify_binary_mul_coeff2(e) => (e,1.0)

end
(** relation: simplify_asub
 **
 ** This relation simplifies array subscripts on vector operations
 **)
		 
relation simplify_asub: (Exp, int) => Exp =

  rule	simplify_asub(e,indx) => e'
	-----------------------------
	simplify_asub(UNARY(UMINUS_ARR(t),e),indx)
	  => UNARY(UMINUS_ARR(t),e')

  rule	simplify_asub(e,indx) => e'
	-------------------------
	simplify_asub(UNARY(UPLUS_ARR(t),e),indx)
	  => UNARY(UPLUS_ARR(t),e')

  rule	simplify_asub(e1,indx) => e1' &
	simplify_asub(e2,indx) => e2' 
	-----------------------------
	simplify_asub(BINARY(e1,SUB_ARR(t),e2),indx)
	  => BINARY(e1',SUB_ARR(t),e2')
      
  rule	simplify_asub(e2,indx) => e2' &
	simplify(e1) => e1' 
	----------------------------
	simplify_asub(BINARY(e1,MUL_SCALAR_ARRAY(t),e2),indx)
	  => (BINARY(e1',MUL_SCALAR_ARRAY(t),e2'))

  rule	simplify_asub(e1,indx) => e1' &
	simplify(e2) => e2' 
	----------------------------
	simplify_asub(BINARY(e1,MUL_ARRAY_SCALAR(t),e2),indx)
	  => (BINARY(e1',MUL_ARRAY_SCALAR(t),e2'))

  rule	simplify_asub(e1,indx) => e1' &
	simplify(e2) => e2' 
	----------------------------
	simplify_asub(BINARY(e1,DIV_ARRAY_SCALAR(t),e2),indx)
	  => (BINARY(e1',DIV_ARRAY_SCALAR(t),e2'))

  rule	simplify_asub(e1,indx) => e1' &
	simplify_asub(e2,indx) => e2' 
	----------------------------
	simplify_asub(BINARY(e1,ADD_ARR(t),e2),indx)
	  => (BINARY(e1',ADD_ARR(t),e2'))

  rule	simplify_asub(e1,indx) => e1' &
	simplify_asub(e2,indx) => e2' 
	----------------------------
	simplify_asub(BINARY(e1,SUB_ARR(t),e2),indx)
	  => (BINARY(e1',SUB_ARR(t),e2'))


  rule	int_sub (indx,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify_asub (ARRAY(t,b,exps),indx) => exp

  rule	int_sub (indx,1) => i' &
	list_nth(exps,i') => (expl) &
	Util.split_tuple2_list(expl) => (expl',bls) &
	Util.bool_and_list(bls) => b
	-----------------------
	simplify_asub( MATRIX(t,n,exps),indx) => ARRAY(t,b,expl')

  rule	simplify(ASUB(e,indx)) => e'
	--------------------------------
	simplify_asub(e as CREF(cr,t),indx) => e'

end


(** relation: divide
 ** author: PA
 **
 ** divides two expressions.
 **)

relation divide: (Exp,Exp) => Exp =
	
  axiom	divide(e1,e2) => BINARY(e1,DIV(REAL),e2)
end

(** relation: remove_factor
 **
 ** Remove the factor from the expression (factorize it out)
 **)
relation remove_factor: (Exp, (* factor *)
			 Exp) (* expr *)
	=> (Exp) =	(* updated expr *)


	  (* factor = expr, return one *)
  rule  factors(factor) => e1::rest  &
	factors(expr) => e2s &
	make_product(e1::rest) => factor1 &
	make_product(e2s) => expr1 &
	Util.list_setdifference_p(e2s,e1::rest,exp_equal) => [] & 
	typeof(e1) => tp &
	make_const_one(tp) => one
	----------------------
	remove_factor(factor,expr) => one
	
  rule  factors(factor) => e1s &
	factors(expr) => e2s &
	Util.list_setdifference_p(e2s,e1s,exp_equal) => factors' &
	make_product(factors') => exp
	----------------------
	remove_factor(factor,expr) => exp

rule	print_exp_str factor => fs & 
	print_exp_str expr => es & print "remove_factor failed, factor:" &
	print fs & print " expr:" & print es & print "\n" &
	factors(expr) => e2s &
	Util.list_map(e2s,print_exp_str) => elst &
	Util.string_delimit_list(elst,", ") => factorsstr &
	print " factors:" & print factorsstr & print "\n" 
	--------------------
	remove_factor(factor,expr) => fail
end

(** relation: gcd
 **
 ** Return the greatest common divisor expression from two expressions.
 ** If no common divisor besides a numerical expression can be found, the 
 ** relation fails.
 **)

relation gcd: (Exp, Exp) => Exp =


  rule	factors(e1) => e1s &
	factors(e2) => e2s &
	Util.list_intersection_p(e1s,e2s,exp_equal) => (factor as _::_) &
	make_product(factor) => product 
	------------------------------
	gcd(e1,e2) => product
end

(** relation no_factors
 **
 ** Helper relation to factors.
 ** If a factor list is empty, the expression has no subfactors.
 ** But the complete expression is then a factor for larger expressions,
 ** returned by this relation.
 **)
relation no_factors: (Exp list, Exp) => Exp list =
  axiom no_factors ([],e) => [e]
  axiom	no_factors(lst,_) => lst
end


(** relation: negate
 ** author: PA
 **
 ** Negates an expression.
 **)

relation negate: (Exp) => Exp =

  rule	typeof(e) => t
	--------------
	negate(e) => UNARY(UMINUS(t),e)

end

(**  relation: terms
 ** author: PA
 **
 ** Returns the terms of the expression if any as a list of expressiosn
 **)

relation terms: Exp => Exp list =

  rule	terms(e1) => f1 &
	terms(e2) => f2 &
	list_append(f1,f2) => res
	-------------------------
	terms (BINARY(e1,ADD(_),e2)) => res

  rule	terms e1 => f1 &
	terms e2 => f2 &
	Util.list_map(f2,negate) => f2' &
	list_append(f1,f2') => res
	-------------------------
	terms(BINARY(e1,SUB(_),e2)) => res

  axiom	terms (e as BINARY(_,MUL(_),_)) => [e] 
  axiom	terms (e as BINARY(_,DIV(_),_)) => [e]
  axiom	terms (e as BINARY(_,POW(_),_)) => [e]
  axiom	terms (e as CREF(cr,_)) => [e]
	
  axiom	terms (e as ICONST(_)) => [e]
  axiom	terms (e as RCONST(_)) => [e]
  axiom	terms (e as SCONST(_)) => [e]
  axiom	terms (e as UNARY(_,_)) => [e]
  axiom	terms (e as IFEXP(_,_,_)) => [e]
  axiom	terms (e as CALL(_,_,_,_)) => [e]
  axiom	terms (e as ARRAY(_,_,_)) => [e]
  axiom	terms (e as MATRIX(_,_,_)) => [e]
  axiom	terms (e as RANGE(_,_,_,_)) => [e]
  axiom	terms (e as CAST(_,_)) => [e]
  axiom	terms (e as ASUB(_,_)) => [e]
  axiom	terms (e as SIZE(_,_)) => [e]
  axiom	terms (e as REDUCTION(_,_,_,_)) => [e]

  axiom	terms (_) => []
end

(** relation: quotient
 ** author: PA
 **
 ** Returns the quotient of an expression.
 ** For instance e = p/q returns (p,q) for nominator p and denominator q.
 **)

relation quotient: Exp => (Exp, (* nominator*)
			   Exp) (* denominator*) =

  axiom	quotient(BINARY(e1,DIV(_),e2)) => (e1,e2)

  rule	quotient(e1) => (p,q) &
	typeof(p) => tp
	----------------------------
	quotient(BINARY(e1,MUL(_),e2)) 
	  => (BINARY(e2,MUL(tp),p),q)

  rule	quotient(e2) => (p,q) &
	typeof(p) => tp
	----------------------------
	quotient(BINARY(e1,MUL(_),e2))
		 => (BINARY(e1,MUL(tp),p),q)
end

(** relation: factors
 **
 ** Returns the factors of the expression if any as a list of expressions
 **)

relation factors: Exp => Exp list =

  rule	(* Both subexpression has factors*)
	factors(e1) => f1 &
	factors(e2) => f2 &
	no_factors(f1,e1) => f1' &
	no_factors(f2,e2) => f2' &
	list_append(f1',f2') => res
	-------------------------
	factors (BINARY(e1,MUL(_),e2)) => res

  rule	factors e1 => f1 &
	factors e2 => f2 &
	no_factors(f1,e1) => f1' &
	no_factors(f2,e2) => f2' &
	inverse_factors f2' => f2'' &
	list_append(f1',f2'') => res
	-------------------------
	factors(BINARY(e1,DIV(REAL),e2)) => res
	
  axiom	factors (e as CREF(cr,_)) => [e]
  axiom	factors (e as BINARY(_,_,_)) => [e]
  axiom	factors (e as ICONST(_)) => [e]
  axiom	factors (e as RCONST(_)) => [e]
  axiom	factors (e as SCONST(_)) => [e]
  axiom	factors (e as UNARY(_,_)) => [e]
  axiom	factors (e as IFEXP(_,_,_)) => [e]
  axiom	factors (e as CALL(_,_,_,_)) => [e]
  axiom	factors (e as ARRAY(_,_,_)) => [e]
  axiom	factors (e as MATRIX(_,_,_)) => [e]
  axiom	factors (e as RANGE(_,_,_,_)) => [e]
  axiom	factors (e as CAST(_,_)) => [e]
  axiom	factors (e as ASUB(_,_)) => [e]
  axiom	factors (e as SIZE(_,_)) => [e]
  axiom	factors (e as REDUCTION(_,_,_,_)) => [e]


  axiom	factors (_) => []
end

(** relation inverse_factors
 **
 ** Takes a list of expressions and returns each expression in the list 
 ** inversed.
 ** For example inverse_factors [a,3+b] => [1/a, 1/3+b]
 **)

relation inverse_factors: Exp list => Exp list =

  axiom	inverse_factors ([]) => []

  rule	inverse_factors(es) => es' &
	typeof(e2) => tp2 
	-----------------------------
	inverse_factors(BINARY(e1,POW(tp),e2)::es) 
	  => BINARY(e1,POW(tp),UNARY(UMINUS(tp2),e2))::es'

  rule	typeof(e) => REAL &
	inverse_factors(es) => es'
	--------------------
	inverse_factors (e::es) => BINARY(RCONST(1.0),DIV(REAL),e)::es'

  rule	typeof(e) => INT &
	inverse_factors(es) => es'
	--------------------
	inverse_factors (e::es) => BINARY(ICONST(1),DIV(INT),e)::es'
end

(** relation: make_product
 **
 ** Takes a list of expressions an makes a product expression multiplying all 
 ** elements in the list.
 **)

relation make_product: (Exp list) => Exp =

  axiom	make_product([]) => RCONST(1.0)

  axiom	make_product([e1]) => e1

	(* to prevent infinite recursion, disregard constant 1. *)
  rule	is_const_one(e) => true &
	make_product(es) => res
	------------------------
	make_product(e::es) => res


  rule	is_const_one(e1) => true 
	----------------
	make_product([BINARY(e1,DIV(tp),e),e2])
	  => BINARY(e2,DIV(tp),e)

  rule	(* Take type info from e1, ok since type checking already performed. *)
	typeof(e1) => tp
	----------------
	make_product([e1,e2]) => BINARY(e1,MUL(tp),e2)

  rule	is_const_one(e1) => true &
	make_product(es) => p1
	--------------------------
	make_product(BINARY(e1,DIV(tp),e)::es)
	  => BINARY(p1,DIV(tp),e)

  rule	make_product(rest) => e2 &
	typeof(e2) => tp
	------------------
	make_product(e1::rest) => BINARY(e1,MUL(tp),e2)

  rule	print "-make_product failed, exp lst:" &
	Util.list_map(lst,print_exp_str) => explst &
	Util.string_delimit_list(explst,", ") => str &
	print str & print "\n" 
	------------------------------
	make_product(lst) => fail
end


(** relation: make_sum
 **
 ** Takes a list of expressions an makes a sum expression adding all 
 ** elements in the list.
 **)

relation make_sum: (Exp list) => Exp =

  axiom	make_sum([]) => RCONST(0.0)

  axiom	make_sum([e1]) => e1

  rule	(* Take type info from e1, ok since type checking already performed. *)
	typeof(e1) => tp
	----------------
	make_sum([e1,e2]) => BINARY(e1,ADD(tp),e2)

  rule	make_sum(rest) => e2 &
	typeof(e2) => tp
	------------------
	make_sum(e1::rest) => BINARY(e1,ADD(tp),e2)

  rule	print "-make_sum failed, exp lst:" &
	Util.list_map(lst,print_exp_str) => explst &
	Util.string_delimit_list(explst,", ") => str &
	print str & print "\n" 
	------------------------------
	make_sum(lst) => fail
end

(** relation: abs
 ** author: PA
 **
 ** Makes the expression absolute. i.e. non-negative.
 **)

relation abs: (Exp) => Exp =

  rule	int_abs(i) => i2 
	----------------
	abs(ICONST(i)) => ICONST(i2)

  rule	real_abs(r) => r2 
	--------------------
	abs(RCONST(r)) => RCONST(r2)

  rule	abs(e) => e'
	--------------------
	abs(UNARY(UMINUS(tp),e)) => e'

  rule	abs(e1) => e1' &
	abs(e2) => e2' 
	-----------------------
	abs(BINARY(e1,op,e2)) => BINARY(e1',op,e2') 

  axiom	abs(e) => e
end

(** relation: type_builtin
 **
 ** Returns true if type is one of the builtin types.
 **)

relation type_builtin: (Type) => bool =

  axiom	type_builtin(INT) => true
  axiom	type_builtin(REAL) => true
  axiom	type_builtin(STRING) => true
  axiom	type_builtin(BOOL) => true
  axiom	type_builtin(_) => false

end

(** relation typeof
 **
 ** Retrieves the Type of the Expression
 **)

relation typeof: (Exp) => Type =
  axiom	typeof (ICONST(_)) =>  INT
  axiom	typeof (RCONST(_)) =>  REAL
  axiom	typeof (SCONST(_)) =>  STRING
  axiom	typeof (BCONST(_)) =>  BOOL
  axiom	typeof (CREF(_,tp)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (BINARY(_,op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (UNARY(op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (LBINARY(_,op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (LUNARY(op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (RELATION(_,op,_)) => tp

  rule	typeof(e2) => tp
	----------------
	typeof(IFEXP(e1,e2,e3)) => tp

  axiom	typeof(CALL(_,_,_,_)) => OTHER (* Not always true *)

  axiom	typeof(ARRAY(tp,_,_)) => tp
  axiom	typeof(MATRIX(tp,_,_)) => tp
  axiom	typeof(RANGE(tp,_,_,_)) => tp
  axiom	typeof(CAST(tp,_)) => tp

  rule	typeof(e) => tp
	-------------------
	typeof(ASUB(e,_)) => tp

  axiom	typeof(CODE(_,tp)) => tp

  rule	typeof (e) => tp
	----------------
	typeof(REDUCTION(_,e,_,_)) => tp

  axiom	typeof(END) => OTHER (* Can be any type. *)
end

(** relation: typeof_op
 **
 ** Helper relation to typeof
 **)

relation typeof_op: Operator => Type =

  axiom	typeof_op(ADD(t)) => t
  axiom	typeof_op(SUB(t)) => t
  axiom	typeof_op(MUL(t)) => t
  axiom	typeof_op(DIV(t)) => t
  axiom	typeof_op(POW(t)) => t
  axiom	typeof_op(UMINUS(t)) => t
  axiom	typeof_op(UPLUS(t)) => t
  axiom	typeof_op(UMINUS_ARR(t)) => t
  axiom	typeof_op(UPLUS_ARR(t)) => t
  axiom	typeof_op(ADD_ARR(t)) => t
  axiom	typeof_op(SUB_ARR(t)) => t
  axiom	typeof_op(MUL_SCALAR_ARRAY(t)) => t
  axiom	typeof_op(MUL_SCALAR_PRODUCT(t)) => t
  axiom	typeof_op(MUL_MATRIX_PRODUCT(t)) => t
  axiom	typeof_op(DIV_ARRAY_SCALAR(t)) => t
  axiom	typeof_op(POW_ARR(t)) => t
  axiom	typeof_op(AND) => BOOL
  axiom	typeof_op(OR) => BOOL
  axiom	typeof_op(NOT) => BOOL
  axiom	typeof_op(LESS(t)) => t
  axiom	typeof_op(LESSEQ(t)) => t
  axiom	typeof_op(GREATER(t)) => t
  axiom	typeof_op(GREATEREQ(t)) => t
  axiom	typeof_op(EQUAL(t)) => t
  axiom	typeof_op(NEQUAL(t)) => t
  axiom	typeof_op(USERDEFINED(t)) => OTHER
end

(** relation: is_const_one
 ** 
 ** Return true if expression is 1
 **)

relation is_const_one : Exp => bool =

  rule	int_real(1) => rval &
	e = RCONST(rval)
	--------------
	is_const_one e => true

  axiom	is_const_one ICONST(1) => true
  axiom is_const_one (_) => false

end

(** relation: is_const_minus_one
 **
 ** Return true if expression is -1
**)

relation is_const_minus_one : Exp => bool =

  rule	int_real(-1) => rval &
	real_eq(v,rval) => true
	-----------------------
	is_const_minus_one RCONST(v) => true

  axiom	is_const_minus_one ICONST(-1) => true
  axiom is_const_minus_one (_) => false

end

(** relation: is_const_zero
 **
 ** Return true if expression is 0
 **)

relation is_const_zero : Exp => bool =

  rule	int_real(0) => rval &
	e = RCONST(rval)
	--------------
	is_const_zero e => true

  axiom	is_const_zero ICONST(0) => true
  axiom is_const_zero (_) => false

end

(** relation make_const_one
 ** author: PA
 **
 ** Create the constant value one, given a type that is INT or REAL
 **)

relation make_const_one: Type => Exp = 

  axiom	make_const_one(INT) => ICONST(1)

  axiom	make_const_one(REAL) => RCONST(1.0)

end

(** relation: simplify_binary_const
 **
 ** This relation evaluates constant binary expressions.
 **)

relation simplify_binary_const : (Operator, Exp, Exp) => Exp =

  rule  int_add(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( ADD(_), ICONST(e1), ICONST(e2)) => ICONST(e3)

  rule  real_add(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( ADD(_), RCONST(e1), RCONST(e2)) => RCONST(e3)

  rule  int_real(e2) => e2' &
        real_add(e1, e2') => e3 
	---------------------------
	simplify_binary_const ( ADD(_), RCONST(e1), ICONST(e2)) => RCONST(e3)

  rule  int_real(e1) => e1' &
        real_add(e1', e2) => e3 
	---------------------------
	simplify_binary_const ( ADD(_), ICONST(e1), RCONST(e2)) => RCONST(e3)

  rule  int_sub(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( SUB(_), ICONST(e1), ICONST(e2)) => ICONST(e3)

  rule  real_sub(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( SUB(_), RCONST(e1), RCONST(e2)) => RCONST(e3)

  rule  int_real(e2) => e2' &
        real_sub(e1, e2') => e3 
	---------------------------
	simplify_binary_const ( SUB(_), RCONST(e1), ICONST(e2)) => RCONST(e3)

  rule  int_real(e1) => e1' &
        real_sub(e1', e2) => e3 
	---------------------------
	simplify_binary_const ( SUB(_), ICONST(e1), RCONST(e2)) => RCONST(e3)


  rule  int_mul(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( MUL(_), ICONST(e1), ICONST(e2)) => ICONST(e3)

  rule  real_mul(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( MUL(_), RCONST(e1), RCONST(e2)) => RCONST(e3)

  rule  int_real(e2) => e2' &
        real_mul(e1, e2') => e3 
	---------------------------
	simplify_binary_const ( MUL(_), RCONST(e1), ICONST(e2)) => RCONST(e3)

  rule  int_real(e1) => e1' &
        real_mul(e1', e2) => e3 
	---------------------------
	simplify_binary_const ( MUL(_), ICONST(e1), RCONST(e2)) => RCONST(e3)


  rule  int_div(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( DIV(_), ICONST(e1), ICONST(e2)) => ICONST(e3)

  rule  real_div(e1, e2) => e3 
	---------------------------
	simplify_binary_const ( DIV(_), RCONST(e1), RCONST(e2)) => RCONST(e3)

  rule  int_real(e2) => e2' &
        real_div(e1, e2') => e3 
	---------------------------
	simplify_binary_const ( DIV(_), RCONST(e1), ICONST(e2)) => RCONST(e3)

  rule  int_real(e1) => e1' &
        real_div(e1', e2) => e3 
	---------------------------
	simplify_binary_const ( DIV(_), ICONST(e1), RCONST(e2)) => RCONST(e3)
        
  axiom simplify_binary_const ( op, e1,e2) => fail
        
end

(** relation: simplify_binary
 ** 
 ** This relation simplifies binary expressions.
 **)

relation simplify_binary : (Exp, Operator, Exp, Exp) => Exp =
        
 
  rule  simplify e1 => e1' &
        simplify e2 => e2' &
        is_const (e1') => true &
        is_const (e2') => true  & 
        simplify_binary_const(oper,e1',e2') => e3
	---------------------------
	simplify_binary (e, oper, e1, e2) => e3

	(* (a+b)/c1 => a/c1+b/c1, for constant c1 *)
  rule	is_const(e3) => true &
	simplify(BINARY(BINARY(e1,DIV(ty),e3),ADD(ty2),BINARY(e2,DIV(ty),e3))) 
	  => res
	--------------------------------
	simplify_binary(_,DIV(ty),BINARY(e1,ADD(ty2),e2),e3) => res

	(* (a-b)/c1 => a/c1-b/c1, for constant c1 *)
  rule	is_const(e3) => true &
	simplify(BINARY(BINARY(e1,DIV(ty),e3),SUB(ty2),BINARY(e2,DIV(ty),e3))) 
	  => res
	--------------------------------
	simplify_binary(_,DIV(ty),BINARY(e1,SUB(ty2),e2),e3) => res

	(* (a+b)*c1 => a*c1+b*c1, for constant c1 *)
  rule	is_const(e3) => true &
	simplify(BINARY(BINARY(e1,MUL(ty),e3),ADD(ty2),BINARY(e2,MUL(ty),e3))) 
	  => res
	--------------------------------
	simplify_binary(_,MUL(ty),BINARY(e1,ADD(ty2),e2),e3) => res

	(* (a-b)*c1 => a/c1-b/c1, for constant c1 *)
  rule	is_const(e3) => true &
	simplify(BINARY(BINARY(e1,MUL(ty),e3),SUB(ty2),BINARY(e2,MUL(ty),e3))) 
	  => res
	--------------------------------
	simplify_binary(_,MUL(ty),BINARY(e1,SUB(ty2),e2),e3) => res

	(* a+(-b) and (-b)+a *)
  rule	simplify(BINARY(e1,SUB(tp),e2)) => e
	-------------------
	simplify_binary(_,ADD(tp),e1,UNARY(UMINUS(tp2),e2)) => e

  rule	simplify(BINARY(e1,SUB(tp),e2)) => e1
	-------------------
	simplify_binary(_,ADD(tp),e1,UNARY(UMINUS(tp2),e2)) => e1

  rule	(* a/b/c => (a*c)/b) *)
	simplify(BINARY(BINARY(e1,MUL(tp),e3),DIV(tp2),e2)) => e
	-------------------
	simplify_binary(_,DIV(tp),e1,BINARY(e2,DIV(tp2),e3)) => e

  rule	(* (a/b)/c => a/(b*c)) *)
	simplify(BINARY(e1,DIV(tp2),BINARY(e2,MUL(tp),e3))) => e
	-------------------
	simplify_binary(_,DIV(tp),BINARY(e1,DIV(tp2),e2),e3) => e

  rule	is_const_zero (e1) => true &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, ADD(ty), e1, e2) => e2'

  rule	is_const_zero (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, ADD(ty), e1, e2) => e1'

  rule	is_const_zero (e1) => true &	
	let e = UNARY(UMINUS(ty), e2) &
	simplify e => e'
	---------------------------
	simplify_binary (_, SUB(ty), e1, e2) => e'

  rule	is_const_zero (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, SUB(ty), e1, e2) => e1'

  rule	is_const_zero (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, SUB(ty), e1, e2) => e1'

  rule  (* a-(-b) = a+b *)
	simplify BINARY(e1, ADD(ty), e2) => e
	--------------------
	simplify_binary (_, SUB(ty), e1, UNARY(UMINUS(ty2),e2)) => e

	(* (e1/e2)*e3 => (e1*e3)/e2*)
  rule	simplify(BINARY(BINARY(e1,MUL(tp),e3),DIV(tp2),e2)) => res
        -----------------------------
	simplify_binary(_,MUL(tp),BINARY(e1,DIV(tp2),e2),e3) => res

	(* e1*(e2/e3) => (e1*e2)/e3*)
  rule	simplify(BINARY(BINARY(e1,MUL(tp),e2),DIV(tp2),e3)) => res
        -----------------------------
	simplify_binary(_,MUL(tp),e1,BINARY(e2,DIV(tp2),e3)) => res

  rule	is_const_zero (e1) => true 
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e1

  rule	is_const_zero (e2) => true 
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e2

  rule	is_const_one (e1) => true &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e2'

  rule	is_const_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e1'

  rule	is_const_minus_one (e1) => true &
	simplify UNARY(UMINUS(ty),e2) => e
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e

  rule	is_const_minus_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => UNARY(UMINUS(ty),e1')

  rule	simplify BINARY(e1,MUL(ty),e2) => e
	---------------------------
	simplify_binary (_, MUL(ty), UNARY(UMINUS(ty1),e1), UNARY(UMINUS(ty2),e2)) 
	  => e

  rule	(* e1 * -e2 => -e1 * e2 *)
	simplify UNARY(UMINUS(ty),e1) => e1' &
	simplify e2  => e2' 
	---------------------------
	simplify_binary (_, MUL(ty), e1, UNARY(UMINUS(ty2),e2)) 
	  => BINARY(e1',MUL(ty),e2')

  rule	is_const_zero (e1) => true 
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) =>  RCONST(0.0)

  rule	is_const_zero (e2) => true &
        Print.print_error_buf "# Error, division by zero.\n" 
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) =>  fail

  rule	is_const_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) => e1'

  rule	is_const_minus_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) => UNARY(UMINUS(ty),e1')

  rule	simplify e1 => e1' &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, DIV(ty), UNARY(UMINUS(ty1),e1), UNARY(UMINUS(ty2),e2)) 
	  => BINARY(e1',DIV(ty),e2')

  rule	(* e1 / -e2  => -e1 / e2 *)
	simplify UNARY(UMINUS(ty),e1) => e1' &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, DIV(ty), e1, UNARY(UMINUS(ty2),e2)) 
	  => BINARY(e1',DIV(ty),e2')

  rule	(* (c1*x)/c2 *)
	is_const(e3) => true &
	is_const(e1) => true &
	simplify(BINARY(BINARY(e1,DIV(tp2),e3),MUL(tp),e2)) => e
	-------------------------------------
	simplify_binary(_,DIV(tp2),BINARY(e2,MUL(tp),e3),e1) => e

  rule	(* (x*c1)/c2 *)
	is_const(e3) => true &
	is_const(e2) => true &
	simplify(BINARY(BINARY(e2,DIV(tp2),e3),MUL(tp),e1)) => e
	-------------------------------------
	simplify_binary(_,DIV(tp2),BINARY(e2,MUL(tp),e3),e1) => e
  

  rule	(* e1^e2, where e2 is one *)
	simplify(e) => e' & 
	simplify(e1) => e1' &
	is_const_one(e') => true
	------------------
 	simplify_binary(_, POW(_), e1,  e) => e1'

  rule	(* e1^e2, where e2 is minus one *)
	simplify(e2) => e2' &
	simplify(e) => e' &
	is_const_minus_one(e') => true &
	make_const_one(tp) => one
	------------------
 	simplify_binary(_, POW(tp), e2,  e) 
	  => BINARY(one,DIV(REAL),e2')

  rule	(* e1^e2, where e2 is zero *)
	simplify(e) => e' &
	typeof(e1) => tp &
	is_zero(e') => true &
	create_const_one(tp) => res
	---------------------------
 	simplify_binary(_, POW(_), e1, e) => res

	(* (a1*a2*...*an)^e2 => a1^e2*a2^e2*..*an^e2 *)
  rule	factors(e1) => (exp_lst as _::_::_) &
	simplify_binary_distribute_pow(exp_lst,e2) => exp_lst' &
	make_product(exp_lst') => res
	---------------------------
	simplify_binary(_,POW(_),e1,e2) => res


  axiom	simplify_binary (e, _, _, _) => e

end

(** relation simplify_binary_distribute_pow
 ** author: PA
 **
 ** Distributes the pow operator over a list of expressions.
 ** ([e1,e2,..,en] , pow_e) =>  [e1^pow_e, e2^pow_e,..,en^pow_e]
 **)

relation simplify_binary_distribute_pow: (Exp list, Exp) => Exp list =

axiom simplify_binary_distribute_pow([],_) => []

  rule	simplify_binary_distribute_pow(es,pow_e) => es' &
	typeof(e) => tp
	---------------------------------------
	simplify_binary_distribute_pow(e::es,pow_e) 
	  => BINARY(e,POW(tp),pow_e)::es'
end

(** relation: create_const_one
 ** Creates a constant value one, given a type INT or REAL
 **)

relation create_const_one:(Type) => Exp =

  rule	int_real(1) => realv
	---------------------
	create_const_one(REAL) => RCONST(realv)

  axiom	create_const_one(INT) => ICONST(1)
end

(** relation: simplify_unary
 **
 ** Simplifies unary expressions.
 **)

relation simplify_unary : (Exp, Operator, Exp) => Exp =

  axiom	simplify_unary (_, UPLUS(ty), e1) => e1

  rule	int_sub(0,i) => i' 
	--------------
	simplify_unary(_,UMINUS(ty),ICONST(i)) => ICONST(i')

  rule	real_sub(0.0,r) => r' 
	--------------
	simplify_unary(_,UMINUS(ty),RCONST(r)) => RCONST(r')

  rule	simplify e1 => e1' &
	is_const_zero e1' => true
	-----------------------
	simplify_unary (_, UMINUS(ty), e1) => e1'

  rule	(* -(a-b) => b-a *)
	simplify BINARY(e2,SUB(ty1),e1) => e' 
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,SUB(ty1),e2)) => e'

  rule	(* -(a+b) => b-a *)
	simplify BINARY(UNARY(UMINUS(ty),e1),ADD(ty1),UNARY(UMINUS(ty),e2)) => e'
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,ADD(ty1),e2)) => e'

  rule	(* -(a/b) => -a/b *)
	simplify BINARY(UNARY(UMINUS(ty),e1),DIV(ty1),e2) => e'
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,DIV(ty1),e2)) => e'

  rule	(* -(a*b) => -a*b *)
	simplify BINARY(UNARY(UMINUS(ty),e1),MUL(ty1),e2) => e'
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,MUL(ty1),e2)) => e'

	(* --a => a*)
  rule	simplify e1 => e1'
	-------------------
	simplify_unary (_, UMINUS(_), UNARY(UMINUS(_),e1)) => e1'

  axiom	simplify_unary (e, _, _) => e

end

(** relation: contain_functioncall
 ** Returns true if expression or subexpression is a functioncall.
 ** otherwise false.
 ** Note: the 'der' operator is represented as a function call but still return 
 ** false.
**)
	    
relation contain_functioncall : Exp => bool =

  axiom	contain_functioncall(CALL(Absyn.IDENT("der"),_,_,_)) => false

  axiom	contain_functioncall(CALL(_,_,_,_)) => true

	(* Binary *)
  rule	contain_functioncall(e1) => true
	---------------------
	contain_functioncall(BINARY(e1,_,e2)) => true

  rule	contain_functioncall(e2) => true 
	---------------------
	contain_functioncall(BINARY(e1,_,e2)) => true

	(* Unary *)
  rule	contain_functioncall(e) => res
	---------------------
	contain_functioncall(UNARY(_,e)) => res

	(* LBinary *)
  rule	contain_functioncall(e1) => true
	---------------------
	contain_functioncall(LBINARY(e1,_,e2)) => true

  rule	contain_functioncall(e2) => true 
	---------------------
	contain_functioncall(LBINARY(e1,_,e2)) => true

	(* LUnary *)
  rule	contain_functioncall(e) => res
	---------------------
	contain_functioncall(LUNARY(_,e)) => res

	(* Relation *)
  rule	contain_functioncall(e1) => true
	---------------------
	contain_functioncall(RELATION(e1,_,e2)) => true

  rule	contain_functioncall(e2) => true
	---------------------
	contain_functioncall(RELATION(e1,_,e2)) => true

	(* If exp*)
  rule	contain_functioncall(e1) => true
	--------------------------------
	contain_functioncall(IFEXP(e1,e2,e3)) => true

  rule	contain_functioncall(e2) => true
	--------------------------------
	contain_functioncall(IFEXP(e1,e2,e3)) => true

  rule	contain_functioncall(e3) => true
	--------------------------------
	contain_functioncall(IFEXP(e1,e2,e3)) => true

	(* Array *)
  rule	Util.list_map(elst,contain_functioncall) => blst &
	Util.bool_or_list(blst) => res
	------------------------------
	contain_functioncall(ARRAY(_,_,elst)) => res

	(* Matrix *)
  rule	Util.list_flatten(explst) => flatexplst &
	Util.list_map(flatexplst,Util.tuple2_1) => elst &
	Util.list_map(elst,contain_functioncall) => blst &
	Util.bool_or_list(blst) => res
	------------------------------
	contain_functioncall(MATRIX(_,_,explst)) => res

	(* Range *)
  rule	contain_functioncall(e1) => true
	------------------------------
	contain_functioncall(RANGE(_,e1,optexp,e2)) => true

  rule	contain_functioncall(e2) => true
	------------------------------
	contain_functioncall(RANGE(_,e1,optexp,e2)) => true

  rule	contain_functioncall(e) => true
	------------------------------
	contain_functioncall(RANGE(_,e1,SOME(e),e2)) => true

	(* Tuple *)
  axiom	contain_functioncall(TUPLE(_)) => true

  rule	contain_functioncall(e) => res
	------------------------------
	contain_functioncall(CAST(_,e)) => res
	
	(* Size *)
  rule	contain_functioncall(e1) => true
	--------------------------------
	contain_functioncall(SIZE(e1,e2)) => true

  rule	contain_functioncall(e2) => true
	--------------------------------
	contain_functioncall(SIZE(e1,SOME(e2))) => true

  axiom	contain_functioncall(_) => false
end

(** relation: unelab_exp
 **
 ** Transform an Exp into Absyn.Exp. 
 ** Note: This relation currently only works for constants and component 
 ** references.
 **)

relation unelab_exp : Exp => Absyn.Exp =

  axiom	unelab_exp(ICONST(i)) => Absyn.INTEGER(i)
  axiom	unelab_exp(RCONST(r)) => Absyn.REAL(r)
  axiom	unelab_exp(SCONST(s)) => Absyn.STRING(s)
  axiom	unelab_exp(BCONST(b)) => Absyn.BOOL(b)

  rule	unelab_cref(cr) => cr'
	----------------
	unelab_exp(CREF(cr,t))=> Absyn.CREF(cr')
end

(** relation: unelab_cref
 **
 ** Helper relation to unelab_exp, handles component references.
 **)

relation unelab_cref: ComponentRef => Absyn.ComponentRef =

  rule	unelab_subscripts(subs) => subs'
	-------------------------------
	unelab_cref(CREF_IDENT(id,subs)) => Absyn.CREF_IDENT(id,subs')
	
  rule	unelab_cref(cr) => cr' &
	unelab_subscripts(subs)=> subs'
	----------------------
	unelab_cref(CREF_QUAL(id,subs,cr)) => Absyn.CREF_QUAL(id,subs',cr')
end

(** relation: unelab_subscripts
 **
 ** Helper relation to unelab_cref, handles subscripts.
 **)

relation unelab_subscripts: Subscript list => Absyn.Subscript list =
	
  axiom	unelab_subscripts([]) => []

  rule	unelab_subscripts(xs) => xs'
	---------------------------
	unelab_subscripts(WHOLEDIM::xs) => Absyn.NOSUB::xs'
	
  rule	unelab_subscripts(xs) => xs' &
	unelab_exp(e) => e'
	---------------------------
	unelab_subscripts(SLICE(e)::xs) => Absyn.SUBSCRIPT(e')::xs'

  rule	unelab_subscripts(xs) => xs' &
	unelab_exp(e) => e'
	---------------------------
	unelab_subscripts(INDEX(e)::xs) => Absyn.SUBSCRIPT(e')::xs'
end


(** relation: to_exp_cref
 **
 ** Translate an Absyn.ComponentRef into a ComponentRef.
 ** Note: Only support for indexed subscripts of integers
 **)

relation to_exp_cref: Absyn.ComponentRef => ComponentRef =

  rule	to_exp_cref_subs(subs) => subs'
	-------------------------------
	to_exp_cref(Absyn.CREF_IDENT(id,subs)) => CREF_IDENT(id,subs')
	
  rule	to_exp_cref(cr) => cr' &
	to_exp_cref_subs(subs) => subs'
	-------------------------------
	to_exp_cref(Absyn.CREF_QUAL(id,subs,cr)) => CREF_QUAL(id,subs',cr')
end

(** relation: to_exp_cref_subs
 **
 ** Helper relation to to_exp_cref.
 **)

relation to_exp_cref_subs: Absyn.Subscript list => Subscript list =
	
  axiom	to_exp_cref_subs([]) => []

  rule	to_exp_cref_subs(xs) => xs' 
	---------------------------
	to_exp_cref_subs(Absyn.SUBSCRIPT(Absyn.INTEGER(i))::xs) 
	  => INDEX(ICONST(i))::xs'

	  (* Assumes index is INTEGER. TODO: what about if index
	   * is an array? *)
  rule	to_exp_cref(cr) => cr' &
	to_exp_cref_subs(xs) => xs' 
	---------------------------
	to_exp_cref_subs(Absyn.SUBSCRIPT(Absyn.CREF(cr))::xs) 
	  => INDEX(CREF(cr',INT))::xs'

  rule	Dump.print_subscripts_str [e] => s &
	Util.string_append_list(["#Error converting subscript: ",s," to Exp.\n"]) 
	  => str &
	  Print.print_error_buf str &
	to_exp_cref_subs(xs) => xs' 
	---------------------------
	to_exp_cref_subs(e::xs)  => xs'
end


(** relation: subscripts_append
 **
 ** This relation takes a subscript list and adds a new subscript.
 ** But there are a few special cases.  When the last existing
 ** subscript is a slice, it is replaced by the slice indexed by the
 ** new subscript.
 **)

relation subscripts_append : (Subscript list, int) => Subscript list =

  axiom	subscripts_append([], i) => [INDEX(ICONST(i))]

  axiom	subscripts_append([WHOLEDIM], i) => [INDEX(ICONST(i))]

  rule	simplify ASUB(e, i) => e'
	-------------------------
	subscripts_append([SLICE(e)], i) => [INDEX(e')]

  axiom	subscripts_append([s as INDEX(_)], i) => [s, INDEX(ICONST(i))]

  rule	subscripts_append(ss, i) => ss'
	-------------------------------
	subscripts_append(s::ss, i) => s::ss'

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **)

(*!ignorecode*)

relation type_string : Type => string =

  axiom	type_string INT => "INT"
  axiom	type_string REAL => "REAL"
  axiom	type_string BOOL => "BOOL"
  axiom	type_string STRING => "STRING"

end

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref CREF_IDENT(s,subs)

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2 (s,subs) &
	Print.print_buf "__" &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

  rule	RTOpts.modelica_output => false &
	print_component_ref2 (s,subs) &
	Print.print_buf "." &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

end

(** relation: print_component_ref2
 **
 ** Helper relation to print_component_ref
 **)

relation print_component_ref2 =

  rule	Print.print_buf s
	-------
	print_component_ref2 (s,[])

  rule	RTOpts.modelica_output => true &
	Print.print_buf s &
	Print.print_buf "_L" & print_list(l,print_subscript,",") & Print.print_buf "_R"
	-------------------------------------------------------
	print_component_ref2 (s,l)

  rule	RTOpts.modelica_output => false &
	Print.print_buf s &
	Print.print_buf "[" & print_list(l,print_subscript,",") & Print.print_buf "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** relation: print_subscript
 **
 ** Print a `Subscript'.
 **)

relation print_subscript: Subscript => () =
	
  rule	Print.print_buf ":"
	---------
	print_subscript(WHOLEDIM)
	
  rule	print_exp(e1)
	-------------
	print_subscript(INDEX(e1))
	
  rule	print_exp(e1)
	-------------
	print_subscript(SLICE(e1))
	
end

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp : Exp => () =

  rule	print_exp2 (e,0)
	----------------
	print_exp e

end

(** relation: print_exp2
 **
 ** Helper relation to print_exp.
 **)

relation print_exp2 : (Exp,int) => () =
	
  rule	int_string(x) => s & Print.print_buf s
	----------------------------
	print_exp2(ICONST(x),_)

  rule	real_string(x) => s & Print.print_buf s
	-----------------------------
	print_exp2(RCONST(x),_)

  rule	Print.print_buf "\"" & Print.print_buf s & Print.print_buf "\""
	---------------------------------
	print_exp2(SCONST(s),_)

  rule	Print.print_buf "false"
	-------------
	print_exp2(BCONST(false),_)

  rule	Print.print_buf "true"
	-------------
	print_exp2(BCONST(true),_)

  rule	print_component_ref(c)
	---------------------
	print_exp2(CREF(c,_),_)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2' &
	int_add (pri2', 1) => pri2 & (* binary minus have higher priority than itself *)
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri2) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op as SUB(ty), e2 as BINARY(e21, SUB(ty2), e22)),pri1)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri2) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op, e2),pri1)

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	Print.print_buf sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------
	print_exp2(UNARY(op, e),pri1)

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri2) &
	print_rightpar(pri1,pri2)
	----------------------------------------------------------------
	print_exp2(LBINARY(e1, op, e2),pri1)

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	Print.print_buf sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	---------------------------------------------------
	print_exp2(LUNARY(op, e),pri1)

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print_exp2(e1,pri3) & Print.print_buf sym & print_exp2(e2,pri2) &
	print_rightpar(pri1,pri2)
	-----------------------------------------------------------------
	print_exp2(RELATION(e1, op, e2),pri1)

  rule	Print.print_buf "if " & print_exp2(c,0) &
	Print.print_buf " then " & print_exp2(t,0) &
	Print.print_buf " else " & print_exp2(f,0)
	----------------------------
	print_exp2(IFEXP(c,t,f),_)

  rule	Absyn.path_string(fcn) => fs &
	Print.print_buf fs & Print.print_buf "(" & print_list(args,print_exp,",") & Print.print_buf ")"
	---------------------------------------------
	print_exp2(CALL(fcn, args,_,_),_)

  rule	(* Print.print_buf "This an array: " & *)
	Print.print_buf "{" &
	print_list(es, print_exp, ",") &
	Print.print_buf "}"
	---------
	print_exp2 (ARRAY(_,_,es),_)

	(*PR.*)
  rule	Print.print_buf "(" &
	print_list(es, print_exp, ",") &
	Print.print_buf ")"
	---------
	print_exp2 (TUPLE(es),_)
	
  rule	Print.print_buf "<matrix>[" &
	print_list(es, print_row, ";") &
	Print.print_buf "]"
	---------
	print_exp2 (MATRIX(_,_,es),_)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & Print.print_buf ":" & print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------------------------------------------
	print_exp2 (RANGE(_,start,NONE,stop),pri1)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & Print.print_buf ":" &
	print_exp2 (step,pri3) & Print.print_buf ":" &
 	print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------
	print_exp2 (RANGE(_,start,SOME(step),stop),pri1)

  rule	RTOpts.modelica_output => false &
	int_real(i) => r &
	real_string(r) => rstr &
	Print.print_buf rstr
	---------------------------------------
	print_exp2 (CAST(REAL,ICONST(i)),_)

  rule	RTOpts.modelica_output => false &
	Print.print_buf "Real(" & print_exp e & Print.print_buf ")"
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	RTOpts.modelica_output => true &
	print_exp e
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	let pri2 = 51 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e,pri3) &
 	print_rightpar(pri1,pri2) &
 	Print.print_buf "<asub>[" &
 	int_string i => s & Print.print_buf s & Print.print_buf "]"
	---------------------------------------
	print_exp2 (ASUB(e,i),pri1)

  rule	print_exp_str e => str &
	Print.print_buf str
	-------------
	print_exp2 (e as SIZE(cr,SOME(dim)),_)

  rule	print_exp_str e => str &
	Print.print_buf str
	-------------
	print_exp2 (e as SIZE(cr,NONE),_)

  rule	print_exp_str e => str &
	Print.print_buf str
	-----------------------------
	print_exp2 (e as REDUCTION(fcn,exp,i,iterexp),_)

  rule	Print.print_buf "#UNKNOWN EXPRESSION# ----eee "
        ----------------------------------
	print_exp2 (_,_)

end

(** relation: print_leftpar
 **
 ** Print a left paranthesis if priorities require it.
 **)
	    
relation print_leftpar : (int(* prio1 *),int (* prio2 *)) => int =

  rule	int_gt(x,y) => true & Print.print_buf "("
	-----------------------
	print_leftpar(x,y) => 0

  axiom	print_leftpar(pri1,pri2) => pri2

end

(** relation: print_leftpar
 **
 ** Print a left paranthesis if priorities require it.
 **)

relation print_rightpar : (int (* prio1 *),int (* prio2 *)) => () =

  rule	int_gt(x,y) => true & Print.print_buf ")"
	-----------------------
	print_rightpar(x,y)

  axiom	print_rightpar(_,_)

end




(** relation: binop_priority
 **
 ** Returns a priority number for each operator. Used to determine when
 ** parenthesis in expressions is required.
 ** priorities:
 **
 **   and, or		10
 **   not		11
 **   <, >, =, != etc.	21
 **   bin +		32
 **   bin -		33
 **   *			35
 **   /			36
 **   unary +, unary -	37
 **   ^			38
 **   :			41
 **   []		51
 **
 ** LS: Changed precedence for unary +-
 **  which must be higher than binary operators but lower than power
 **  according to e.g. matlab 
 **
 ** LS: Changed precedence for binary - , should be higher than + and also
 **  itself, but this is specially handled in print_exp2 and print_exp2_str 
 **)

relation binop_priority : Operator => int =
  axiom	binop_priority(ADD(_))    	      	 => 32
  axiom	binop_priority(SUB(_))    	      	 => 33
  axiom	binop_priority(ADD_ARR(_))    	      	 => 32
  axiom	binop_priority(SUB_ARR(_))    	      	 => 33
  axiom	binop_priority(MUL(_))    	      	 => 35
  axiom	binop_priority(MUL_SCALAR_ARRAY(_))   	 => 35
  axiom	binop_priority(MUL_ARRAY_SCALAR(_))    	 => 35
  axiom	binop_priority(MUL_SCALAR_PRODUCT(_))  	 => 35
  axiom	binop_priority(MUL_MATRIX_PRODUCT(_))  	 => 35
  axiom	binop_priority(DIV(_))   	      	 => 36
  axiom	binop_priority(DIV_ARRAY_SCALAR(_))    	 => 36
  axiom	binop_priority(POW(_))   	      	 => 38
end

(** relation: unaryop_priority
 **
 ** Determine unary operator priorities, see binop_priority.
 **)

relation unaryop_priority : Operator => int =
  axiom	unaryop_priority(UMINUS(_))   => 37
  axiom	unaryop_priority(UPLUS(_))    => 37
  axiom	unaryop_priority(UMINUS_ARR(_))   => 37
  axiom	unaryop_priority(UPLUS_ARR(_))    => 37
end

(** relation: lbinop_priority
 **
 ** Determine logical binary operator priorities, see binop_priority.
 **)

relation lbinop_priority : Operator => int =
  axiom	lbinop_priority(AND) => 10
  axiom	lbinop_priority(OR) => 10
end

(** relation: lunaryop_priority
 **
 ** Determine logical unary operator priorities, see binop_priority.
 **)

relation lunaryop_priority : Operator => int =
  axiom	lunaryop_priority(NOT) => 11
end

(** relation: relop_priority
 **
 ** Determine relation operator priorities, see binop_priority.
 **)
relation relop_priority : Operator => int =
  axiom	relop_priority(LESS(_))       => 21
  axiom	relop_priority(LESSEQ(_))     => 21
  axiom	relop_priority(GREATER(_))    => 21
  axiom	relop_priority(GREATEREQ(_))  => 21
  axiom	relop_priority(EQUAL(_))      => 21
  axiom	relop_priority(NEQUAL(_))     => 21
end

(** relation: make_real_add
 ** Construct an add node of the two expressions of type REAL
 **)
relation make_real_add: (Exp, Exp) => Exp =

  axiom	make_real_add(e1,e2) => BINARY(e1,ADD(REAL),e2)
end

(** relation: make_real_array
 **
 ** Construct an array node of an Exp list of type REAL
 **)
relation make_real_array: (Exp list) => Exp =

  axiom	make_real_array(expl) => ARRAY(REAL,false,expl)

end

(** relation: binop_symbol
 **
 ** Return a string representation of the Operator.
 **)
	    
relation binop_symbol : Operator => string =
	
  rule	RTOpts.typeinfo => false &
	binop_symbol_1 op => s
	----------------------
	binop_symbol op => s

  rule	RTOpts.typeinfo => true &
	binop_symbol_2 op => s
	----------------------
	binop_symbol op => s

end

(** relation: binop_symbol_1
 **
 ** Helper relation to binop_symbol
 **)
	    
relation binop_symbol_1 : Operator => string =
  axiom	binop_symbol_1(ADD(_)) => " + "
  axiom	binop_symbol_1(SUB(_)) => " - "
  axiom	binop_symbol_1(MUL(_)) => " * "
  axiom	binop_symbol_1(DIV(_)) => " / "
  axiom	binop_symbol_1(POW(_)) => " ^ "
  axiom	binop_symbol_1(ADD_ARR(_)) => " + "
  axiom	binop_symbol_1(SUB_ARR(_)) => " - "
  axiom	binop_symbol_1(MUL_SCALAR_ARRAY(_)) => " * "
  axiom	binop_symbol_1(MUL_ARRAY_SCALAR(_)) => " * "
  axiom	binop_symbol_1(MUL_SCALAR_PRODUCT(_)) => " * "
  axiom	binop_symbol_1(MUL_MATRIX_PRODUCT(_)) => " * "
  axiom	binop_symbol_1(DIV_ARRAY_SCALAR(_)) => " / "
end

(** relation: binop_symbol_2
 **
 ** Helper relation to binop_symbol.
 **)

relation binop_symbol_2 : Operator => string =
  rule	type_string t => ts &
	string_append(" +<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(ADD(t)) => s'

  axiom	binop_symbol_2(SUB(t)) => " - "
  axiom	binop_symbol_2(MUL(t)) => " * "

  rule	type_string t => ts &
	string_append(" /<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(DIV(t)) => s'

  axiom	binop_symbol_2(POW(t)) => " ^ "

  axiom	binop_symbol_2(ADD_ARR(_)) => " + "
  axiom	binop_symbol_2(SUB_ARR(_)) => " - "
  axiom	binop_symbol_2(MUL_SCALAR_ARRAY(_)) => " * "
  axiom	binop_symbol_2(MUL_ARRAY_SCALAR(_)) => " * "
  axiom	binop_symbol_2(MUL_SCALAR_PRODUCT(_)) => " * "
  axiom	binop_symbol_2(MUL_MATRIX_PRODUCT(_)) => " * "
  axiom	binop_symbol_2(DIV_ARRAY_SCALAR(_)) => " / "

end

(** relation: unaryop_symbol
 **
 ** Return string representation of unary operators.
 **)

relation unaryop_symbol : Operator => string =
  axiom	unaryop_symbol(UMINUS(_)) => "-"
  axiom	unaryop_symbol(UPLUS(_)) => "+"
  axiom	unaryop_symbol(UMINUS_ARR(_)) => "-"
  axiom	unaryop_symbol(UPLUS_ARR(_)) => "+"
end

(** relation: lbinop_symbol
 **
 ** Return string representation of logical binary operator.
**)

relation lbinop_symbol : Operator => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

(** relation: lunaryop_symbol
 **
 ** Return string representation of logical unary operator.
**)

relation lunaryop_symbol : Operator => string =
  axiom	lunaryop_symbol(NOT) => " NOT "
end

(** relation: relop_symbol
 **
 ** Return string representation of relation operator.
**)

relation relop_symbol : Operator => string =
  axiom	relop_symbol(LESS(_))       => " < "
  axiom	relop_symbol(LESSEQ(_))     => " <= "
  axiom	relop_symbol(GREATER(_))    => " > "
  axiom	relop_symbol(GREATEREQ(_))  => " >= "
  axiom	relop_symbol(EQUAL(_))      => " == "
  axiom	relop_symbol(NEQUAL(_))     => " <> "
end

(** relation: print_list
 **
 ** Print a list of values given a print-relation and a separator
 ** string.
 **)

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & Print.print_buf sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(** relation: print_row
 **
 ** Print a list of expressions to the Print buffer.
 **)

relation print_row : (Exp*bool) list =>() =

  rule	Util.list_map(es,Util.tuple2_1) => es' &
	print_list(es',print_exp,",")
	----------------------------
	print_row es

end


(******************************************************************)
(** LS: print relations that return a string instead of printing **)
(** Had to duplicate the huge print_exp2 and modify              **)
(** An alternative would be to implement "sprint" somehow        **)
(** which would need internal state, with reset and              **)
(** get_string methods                                           **)
(**                                                              **)
(** Once these are tested and ok, the print_exp* above can be    **)
(** replaced by a call to these _str relations and printing      **)
(** the result.                                                  **)
(******************************************************************)

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref_str : ComponentRef => string =

  axiom	print_component_ref_str(CREF_IDENT(s,[])) => s (* optimize *)

  rule	print_component_ref2_str (s,subs) => str
	----------------------------
	print_component_ref_str CREF_IDENT(s,subs) => str

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2_str (s,subs) => str &
	print_component_ref_str cr => strrest &
	string_append (str, "__") => str' &
	string_append (str', strrest) => str''
	---------------------
	print_component_ref_str CREF_QUAL(s,subs,cr) => str''

  rule	RTOpts.modelica_output => false &
	print_component_ref2_str (s,subs) => str &
	print_component_ref_str cr => strrest &
	string_append (str, ".") => str' &
	string_append (str', strrest) => str''
	---------------------
	print_component_ref_str CREF_QUAL(s,subs,cr) => str''

end

(** relation: print_component_ref2_str
 **
 ** Helper relation to print_component_ref_str.
 **)

relation print_component_ref2_str : (Ident, Subscript list) => string =

  axiom	print_component_ref2_str (s,[]) => s

  rule	RTOpts.modelica_output => true &
	print_list_str (l, print_subscript_str, ",") => str &
	string_append (s, "_L") => str' &
	string_append (str', str) => str'' &
	string_append (str'', "_R") => str'''
	-------------------------------------------------------
	print_component_ref2_str (s,l) => str'''

  rule	RTOpts.modelica_output => false &
	print_list_str (l, print_subscript_str, ",") => str &
	string_append (s, "[") => str' &
	string_append (str', str) => str'' &
	string_append (str'', "]") => str'''
	-------------------------------------------------------
	print_component_ref2_str (s,l) => str'''

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end

(** relation: print_subscript_str
 **
 ** Print a `Subscript'.
 **)

relation print_subscript_str: Subscript => string =
	
  axiom	print_subscript_str (WHOLEDIM) => ":"
	
  rule	print_exp_str (e1) => s
	-------------
	print_subscript_str (INDEX(e1)) => s
	
  rule	print_exp_str (e1) => s
	-------------
	print_subscript_str (SLICE(e1)) => s
	
end

(** relation: print_exp_str
 **
 ** This relation prints a complete expression.
 **)

relation print_exp_str : Exp => string =

  rule	print_exp2_str (e,0) => s
	--------------------
	print_exp_str e => s

end

(** relation: print_exp2_str
 **
 ** Helper relation to print_exp_str.
 **)

relation print_exp2_str : (Exp,int) => string =
	
  axiom print_exp2_str(END,_) => "end"
  
  rule	int_string(x) => s
	----------------------------
	print_exp2_str(ICONST(x),_) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp2_str(RCONST(x),_) => s

  rule	string_append ("\"", s) => s' &
	string_append (s', "\"") => s''
	---------------------------------
	print_exp2_str(SCONST(s),_) => s''

  axiom	print_exp2_str(BCONST(false),_) => "false"

  axiom	print_exp2_str(BCONST(true),_) => "true"

  rule	print_component_ref_str (c) => s
	--------------------------------
	print_exp2_str(CREF(c,_),_) => s

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2' &
	int_add (pri2',1) => pri2 & (* binary minus have higher priority than itself *)
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (BINARY(e1, op as SUB(ty), e2 as BINARY(e21, SUB(ty2), e22)),pri1) => s'''

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (BINARY(e1, op, e2),pri1) => s'''

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
	print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	----------------------------
	print_exp2_str(UNARY(op, e),pri1) => s''

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	----------------------------------------------------------------
	print_exp2_str(LBINARY(e1, op, e2),pri1) => s'''

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str (e,pri3) => s2 &
	print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	---------------------------------------------------
	print_exp2_str(LUNARY(op, e),pri1) => s''

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str(e1,pri3) => s2 & 
	print_exp2_str(e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-----------------------------------------------------------------
	print_exp2_str(RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	print_exp2_str(t,0) => thenstr &
	print_exp2_str(f,0) => elsestr &
	string_append ("if ", ifstr) => s &
	string_append (s, " then ") => s' &
	string_append (s', thenstr) => s'' &
	string_append (s'', " else ") => s''' &
	string_append (s''', elsestr) => s''''
	----------------------------
	print_exp2_str(IFEXP(c,t,f),_) => s''''

  rule	Absyn.path_string(fcn) => fs &
	print_list_str(args,print_exp_str,",") => argstr &
	string_append(fs, "(") => s &
	string_append(s, argstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp2_str(CALL(fcn, args,_,_),_) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp2_str (ARRAY(_,_,es),_) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp2_str (TUPLE(es),_) => s''
	
  rule	print_list_str(es, print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s''
	-----------------------------
	print_exp2_str (MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (stop,pri3) => s3 &
 	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-------------------------------------------------------------
	print_exp2_str (RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	print_leftpar_str (pri1,pri2) => (s1,pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (step,pri3) => s3 &
 	print_exp2_str (stop,pri3) => s4 &
 	print_rightpar_str (pri1,pri2) => s5 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s4) => s'''' &
	string_append (s'''', s5) => s'''''
	-------------------------------------
	print_exp2_str (RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res
	---------------------------------------
	print_exp2_str (CAST(REAL,ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res &
	string_append("-",res) => res2
	---------------------------------------
	print_exp2_str (CAST(REAL,UNARY(UMINUS(_),ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	print_exp_str e => s & 
	string_append ("Real(", s) => s' &
	string_append (s', ")") => s''
	---------------------------------------
	print_exp2_str (CAST(REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	print_exp_str e => s
	---------------------------------------
	print_exp2_str (CAST(REAL,e),_) => s

  rule  type_string tp => str  &
	print_exp_str e => s &
	Util.string_append_list(["CAST(",str,", ",s,")"]) => res
	---------------------------------------
	print_exp2_str (CAST(tp,e),_) => res

  rule	let pri2 = 51 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
 	print_rightpar_str (pri1,pri2) => s3 &
 	int_string i => s4 &
	string_append (s1, s2) => s &
	string_append (s, s3) => s' &
	string_append (s', "[") => s'' &
	string_append (s'', s4) => s''' &
	string_append (s''', "]") => s''''
	---------------------------------------
	print_exp2_str (ASUB(e,i),pri1) => s''''

  rule	print_exp_str cr => crstr &
	print_exp_str dim => dimstr &
	Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	------------------------
	print_exp2_str (SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_str cr => crstr &
	Util.string_append_list(["size(",crstr,")"]) => str
	------------------------
	print_exp2_str (SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	print_exp_str exp => expstr &
	print_exp_str iterexp => iterstr &
	Util.string_append_list(["<reduction>",
				 fs,"(",expstr," for ",
				 id," in ",iterstr,")"]) => str
	-------------------------------------------------------
	print_exp2_str (REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

end

(** relation: print_row_str
 **
 ** Prints a list of expressions to a string.
 **)

relation print_row_str : (Exp*bool) list => string =

  rule	Util.list_map (es,Util.tuple2_1) => es' &
	print_list_str (es', print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end


(** relation: print_leftpar_str
 **
 ** Print a left parenthesis to a string if priorities require it.
 **)

relation print_leftpar_str : (int (* prio1 *),int (* prio2 *)) 
 => (string, int) =

  rule	int_gt(x,y) => true
	-----------------------
	print_leftpar_str (x,y) => ("(", 0)

  axiom	print_leftpar_str (pri1,pri2) => ("", pri2)

end

(** relation: print_rightpar_str
 **
 ** Print a right parenthesis to a string if priorities require it.
 **)

relation print_rightpar_str : (int,int) => string =

  rule	int_gt(x,y) => true
	-----------------------
	print_rightpar_str (x,y) => ")"

  axiom	print_rightpar_str (_,_) => ""

end

(** relation: exp_equal
 **
 ** Returns true if the two expressions are equal.
 **)

relation exp_equal: (Exp,Exp) => bool =

  rule  int_eq(c1,c2) => res
	-------------------
	exp_equal(ICONST(c1),ICONST(c2)) => res

  rule  real_eq(c1,c2) => res
	-------------------
	exp_equal(RCONST(c1),RCONST(c2)) => res

  rule  c1 = c2
	-------------------
	exp_equal(SCONST(c1),SCONST(c2)) => true

  rule  bool_and(c1,c2) => b1 &
	bool_not(c1) => c1' &
	bool_not(c2) => c2' &
	bool_and(c1',c2') => b2 &
	bool_or(b1,b2) => res
	-------------------
	exp_equal(BCONST(c1),BCONST(c2)) => res

  rule  cref_equal(c1,c2) => res
	------------------------
	exp_equal(CREF(c1,_),CREF(c2,_)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(BINARY(e11,op1,e12),BINARY(e21,op2,e22)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(LBINARY(e11,op1,e12),LBINARY(e21,op2,e22)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e1,e2) => b2 &
	bool_and(b1,b2) => res
	------------------------
	exp_equal(UNARY(op1,e1),UNARY(op2,e2)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e1,e2) => b2 &
	bool_and(b1,b2) => res
	------------------------
	exp_equal(LUNARY(op1,e1),LUNARY(op2,e2)) => res
	
  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(RELATION(e11,op1,e12),RELATION(e21,op2,e22)) => res

  rule  exp_equal(e13,e23) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(IFEXP(e11,e12,e13),IFEXP(e21,e22,e23)) => res

  rule  ModUtil.path_equal(path1,path2) => b1 &
	Util.list_thread_map(expl1,expl2,exp_equal) => bs &
	Util.bool_and_list(b1::bs) => res 
	--------------------------------------------------
	exp_equal(CALL(path1,expl1,_,_),CALL(path2,expl2,_,_)) => res

  rule	tp1 = tp2 &
	Util.list_thread_map(expl1,expl2,exp_equal) => bs &
	Util.bool_and_list(bs) => res 
	--------------------------------------------------
	exp_equal(ARRAY(tp1,_,expl1),ARRAY(tp2,_,expl2)) => res

  rule	print "exp_equal for MATRIX not impl. yet.\n"
	--------------------------------------------------
	exp_equal(MATRIX(_,_,_),MATRIX(_,_,_)) => false

  rule  exp_equal(e13,e23) => b1 &
	exp_equal(e11,e21) => b2 &
	Util.bool_and_list([b1,b2]) => res
	------------------------
	exp_equal(RANGE(tp1,e11,NONE,e13),RANGE(tp2,e21,NONE,e23)) => res

  rule  exp_equal(e13,e23) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(RANGE(tp1,e11,SOME(e12),e13),RANGE(tp2,e21,SOME(e22),e23)) 
	  => res

  rule	Util.list_thread_map(expl1,expl2,exp_equal) => bs &
	Util.bool_and_list(bs) => res 
	--------------------------------------------------
	exp_equal(TUPLE(expl1),TUPLE(expl2)) => res

  rule	tp1 = tp2 &
	exp_equal(e1,e2) => res
	---------------------
	exp_equal(CAST(tp1,e1),CAST(tp2,e2)) => res

  rule	int_eq(i1,i2) => b1 &
	exp_equal(e1,e2) => b2 &
	bool_and(b1,b2) => res
	-----------------------
	exp_equal(ASUB(e1,i1),ASUB(e2,i2)) => res

  rule	exp_equal(e1,e2) => res
	-----------------------
	exp_equal(SIZE(e1,NONE),SIZE(e2,NONE)) => res

  rule	exp_equal(e1,e2) => b1 &
	exp_equal(e11,e22) => b2 &
	bool_and(b1,b2) => res
	-----------------------
	exp_equal(SIZE(e1,SOME(e11)),SIZE(e2,SOME(e22))) => res

  rule	print "exp_equal on CODE not impl.\n" 
	--------------------------------------
	exp_equal(CODE(_,_),CODE(_,_)) => false

  rule	id1=id2 &
	ModUtil.path_equal(path1,path2) => b1 &
	exp_equal(e1,e2) => b2 &
	exp_equal(r1,r2) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	--------------------------
	exp_equal(REDUCTION(path1,e1,id1,r1),REDUCTION(path2,e2,id2,r2)) =>  res

  axiom	exp_equal(END, END) => true

  axiom	exp_equal(_,_) => false
end

(** relation: operator_equal
 **
 ** Helper relation to exp_equal.
 **)

relation operator_equal: (Operator,Operator) => bool =

  axiom	operator_equal(ADD(_),ADD(_)) => true
  axiom	operator_equal(SUB(_),SUB(_)) => true
  axiom	operator_equal(MUL(_),MUL(_)) => true
  axiom	operator_equal(DIV(_),DIV(_)) => true
  axiom	operator_equal(POW(_),POW(_)) => true
  axiom	operator_equal(UMINUS(_),UMINUS(_)) => true
  axiom	operator_equal(UMINUS_ARR(_),UMINUS_ARR(_)) => true
  axiom	operator_equal(UPLUS_ARR(_),UPLUS_ARR(_)) => true
  axiom	operator_equal(ADD_ARR(_),ADD_ARR(_)) => true
  axiom	operator_equal(SUB_ARR(_),SUB_ARR(_)) => true
  axiom	operator_equal(MUL_SCALAR_ARRAY(_),MUL_SCALAR_ARRAY(_)) => true
  axiom	operator_equal(MUL_ARRAY_SCALAR(_),MUL_ARRAY_SCALAR(_)) => true
  axiom	operator_equal(MUL_SCALAR_PRODUCT(_),MUL_SCALAR_PRODUCT(_)) => true
  axiom	operator_equal(MUL_MATRIX_PRODUCT(_),MUL_MATRIX_PRODUCT(_)) => true
  axiom	operator_equal(DIV_ARRAY_SCALAR(_),DIV_ARRAY_SCALAR(_)) => true
  axiom	operator_equal(POW_ARR(_),POW_ARR(_)) => true
  axiom	operator_equal(AND,AND) => true
  axiom	operator_equal(OR,OR) => true
  axiom	operator_equal(NOT,NOT) => true
  axiom	operator_equal(LESS(_),LESS(_)) => true
  axiom	operator_equal(LESSEQ(_),LESSEQ(_)) => true
  axiom	operator_equal(GREATER(_),GREATER(_)) => true
  axiom	operator_equal(GREATEREQ(_),GREATEREQ(_)) => true
  axiom	operator_equal(EQUAL(_),EQUAL(_)) => true
  axiom	operator_equal(NEQUAL(_),NEQUAL(_)) => true
  rule	ModUtil.path_equal(p1,p2) => res
	--------------------------------
  	operator_equal(USERDEFINED(p1),USERDEFINED(p2)) => res
  axiom	operator_equal(_,_) => false
end

(** relation: replace_exp_list.
 **
 ** Replaces an expression with a list of several expressions. 
 ** NOTE: Not repreteadly applied, so the source and target lists must be 
 ** disjunct Useful for instance when replacing several variables at once 
 ** in an expression. 
 **)

 relation replace_exp_list: (Exp (*expr*), 
			     Exp list (* source list*), 
			     Exp list (* target list*))
	  => (Exp,int) =

  axiom	replace_exp_list(e,[],[]) => (e,0)

  rule	replace_exp(e,s1,t1) => (e',c1) &
	replace_exp_list(e',sr,tr) => (e'',c2) &
	int_add(c1,c2) => c 
	----------------------------------------
	replace_exp_list(e,s1::sr,t1::tr) => (e'',c)
end

(** relation: replace_exp
 **
 ** Helper relation to replace_exp_list.
 **)

relation replace_exp: (Exp (*expr*), Exp(* source expr*),Exp(*target expr*)) 
	  => (Exp,int) =

  rule	exp_equal(expr,source) => true
	------------------------------
	replace_exp(expr,source,target) => (target,1)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	------------------------------------
	replace_exp(BINARY(e1,op,e2),source,target) 
	  => (BINARY(e1',op,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	------------------------------------
	replace_exp(LBINARY(e1,op,e2),source,target) 
	  => (LBINARY(e1',op,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c)
	------------------------------------
	replace_exp(UNARY(op,e1),source,target) 
	  => (UNARY(op,e1'),c)

  rule	replace_exp(e1,source,target) => (e1',c)
	------------------------------------
	replace_exp(LUNARY(op,e1),source,target) 
	  => (LUNARY(op,e1'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	------------------------------------
	replace_exp(RELATION(e1,op,e2),source,target) 
	  => (RELATION(e1',op,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	replace_exp(e3,source,target) => (e3',c3) &
	Util.list_reduce([c1,c2,c3],int_add) => c
	------------------------------------
	replace_exp(IFEXP(e1,e2,e3),source,target) 
	  => (IFEXP(e1',e2',e3'),c)

  rule  Util.list_map_2_2(expl,replace_exp,source,target) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Util.list_reduce(cnt,int_add) => cnt'
	-----------------------------------------------
	replace_exp(CALL(path,expl,t,c),source,target) 
	  => (CALL(path,expl',t,c),cnt')

  rule	Util.list_map_2_2(expl,replace_exp,source,target) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Util.list_reduce(cnt,int_add) => cnt'
	-----------------------------------------------
	replace_exp(ARRAY(tp,c,expl),source,target) 
	  => (ARRAY(tp,c,expl'),cnt')

  rule	print "replace_exp for matrix not impl." 
	-----------------------------------------------
	replace_exp(MATRIX(a,b,c),source,target) 
	  => (MATRIX(a,b,c),0)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	-----------------------------------------------
	replace_exp(RANGE(tp,e1,NONE,e2),source,target) 
	  => (RANGE(tp,e1',NONE,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	replace_exp(e3,source,target) => (e3',c3) &
	Util.list_reduce([c1,c2,c3],int_add) => c
	-----------------------------------------------
	replace_exp(RANGE(tp,e1,SOME(e3),e2),source,target) 
	  => (RANGE(tp,e1',SOME(e3'),e2'),c)

  rule	Util.list_map_2_2(expl,replace_exp,source,target) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Util.list_reduce(cnt,int_add) => cnt'
	-----------------------------------------------
	replace_exp(TUPLE(expl),source,target) 
	  => (TUPLE(expl'),cnt')

  rule	replace_exp(e1,source,target) => (e1',c)
	-----------------------------------------------
	replace_exp(CAST(tp,e1),source,target) 
	  => (CAST(tp,e1'),c)

  rule	replace_exp(e1,source,target) => (e1' ,c)
	-----------------------------------------------
	replace_exp(ASUB(e1,i),source,target) 
	  => (ASUB(e1',i),c)

  rule	replace_exp(e1,source,target) => (e1',c)
	-----------------------------------------------
	replace_exp(SIZE(e1,NONE),source,target) 
	  => (SIZE(e1',NONE),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	-----------------------------------------------
	replace_exp(SIZE(e1,SOME(e2)),source,target) 
	  => (SIZE(e1',SOME(e2')),c)

  rule	print "replace_exp on CODE not impl.\n" 
	-----------------------------------------------
	replace_exp(CODE(a,b),source,target) 
	  => (CODE(a,b),0)

  rule	replace_exp(e,source,target) => (e',c1) &
	replace_exp(r,source,target) => (r' ,c2) &
	int_add(c1,c2) => c
	-----------------------------------------------
	replace_exp(REDUCTION(p,e,id,r),source,target) 
	  => (REDUCTION(p,e',id,r'),c)

 axiom	replace_exp(e,s,_) => (e,0)
end

(** relation: stringify_component_ref
 **
 ** Translates a ComponentRef into a CREF_IDENT by putting the string
 ** representation of the ComponentRef into it. See also stringigy_crefs.
 **)

relation stringify_component_ref: ComponentRef => ComponentRef =
	
  rule	print_component_ref_str(cr) => crs 
	----------------------------------
	stringify_component_ref(cr) => CREF_IDENT(crs,[])
end

(** relation: stringify_crefs
 **
 ** This relation takes an expression and transforms all component reference 
 ** names contained in the expression to a simpler form.
 ** For instance CREF_QUAL("a",[], CREF_IDENT("b",[])) becomes
 ** CREF_IDENT("a.b",[])
 **)

relation stringify_crefs: Exp => Exp =

  axiom	stringify_crefs(e as ICONST(_)) => e
  axiom	stringify_crefs(e as RCONST(_)) => e
  axiom	stringify_crefs(e as SCONST(_)) => e
  axiom	stringify_crefs(e as BCONST(_)) => e
	
  rule	stringify_component_ref(cr) => cr'
	----------------------------------
	stringify_crefs(CREF(cr,t)) => CREF(cr',t)

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	-------------------
	stringify_crefs(BINARY(e1,op,e2)) => BINARY(e1',op,e2')

  rule	stringify_crefs(e) => e'
	-------------------
	stringify_crefs(UNARY(op,e)) => UNARY(op,e')

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	-------------------
	stringify_crefs(LBINARY(e1,op,e2)) => LBINARY(e1',op,e2')
	
  rule	stringify_crefs(e) => e'
	-------------------
	stringify_crefs(LUNARY(op,e)) => LUNARY(op,e')
	
  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	--------------------------
	stringify_crefs(RELATION(e1,op,e2)) => RELATION(e1',op,e2')
	
  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' &
	stringify_crefs(e3) => e3' 
	--------------------------
	stringify_crefs(IFEXP(e1,e2,e3)) => IFEXP(e1',e2',e3')
	
  rule	Util.list_map(expl,stringify_crefs) =>  expl'
	-----------------------
	stringify_crefs(CALL(p,expl,t,b)) => CALL(p,expl',t,b)

  rule	Util.list_map(expl,stringify_crefs) =>  expl'
	-----------------------
	stringify_crefs(ARRAY(t,b,expl)) => ARRAY(t,b,expl')
	
  rule	print "stringify_crefs on MATRIX not impl. yet\n"
	-----------------------
	stringify_crefs(e as MATRIX(t,b,expl)) => e

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' &
	stringify_crefs(e3) => e3' 
	-----------------------
	stringify_crefs(RANGE(t,e1,SOME(e2),e3)) => RANGE(t,e1',SOME(e2'),e3')

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e3) => e3' 
	-----------------------
	stringify_crefs(RANGE(t,e1,NONE,e3)) => RANGE(t,e1',NONE,e3')


  rule	Util.list_map(expl,stringify_crefs) =>  expl'
	-------------------
	stringify_crefs(TUPLE(expl)) => TUPLE(expl')

  rule	stringify_crefs(e1) => e1'
	--------------------------
	stringify_crefs(CAST(t,e1)) => CAST(t,e1')

  rule	stringify_crefs(e1) => e1' 
	--------------------------
	stringify_crefs(ASUB(e1,i)) => ASUB(e1',i)

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	--------------------------
	stringify_crefs(SIZE(e1,SOME(e2))) => SIZE(e1',SOME(e2'))

  rule	stringify_crefs(e1) => e1'
	--------------------------
	stringify_crefs(SIZE(e1,NONE)) => SIZE(e1',NONE)

  axiom	stringify_crefs(e as CODE(_,_)) => e

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	--------------------------
	stringify_crefs( REDUCTION(p,e1,id,e2)) => REDUCTION(p,e1',id,e2')

  axiom	stringify_crefs END => END
  axiom	stringify_crefs (e) => e
end

(** relation: dump_exp_graphviz
 **
 ** Creates a Graphviz Node from an Expression.
 **)

relation dump_exp_graphviz : Exp => Graphviz.Node =
	
  axiom dump_exp_graphviz(END) => Graphviz.NODE("END",[],[])
  
  rule	int_string(x) => s
	----------------------------
	dump_exp_graphviz(ICONST(x)) => Graphviz.LNODE("ICONST",[s],[],[])

  rule	real_string(x) => s
	-----------------------------
	dump_exp_graphviz(RCONST(x)) => Graphviz.LNODE("RCONST",[s],[],[])

  rule	string_append ("\"", s) => s' &
	string_append (s', "\"") => s''
	---------------------------------
	dump_exp_graphviz(SCONST(s)) => Graphviz.LNODE("SCONST",[s''],[],[])

  axiom	dump_exp_graphviz(BCONST(false)) => Graphviz.LNODE("BCONST",["false"],[],[])

  axiom	dump_exp_graphviz(BCONST(true)) => Graphviz.LNODE("BCONST",["true"],[],[])

  rule	print_component_ref_str (c) => s
	--------------------------------
	dump_exp_graphviz(CREF(c,_)) => Graphviz.LNODE("CREF",[s],[],[])

  rule	binop_symbol(op) => sym &
	dump_exp_graphviz (e1) => lt & 
	dump_exp_graphviz (e2) => rt
	----------------------------
	dump_exp_graphviz (BINARY(e1, op, e2)) => Graphviz.LNODE("BINARY",[sym],[],[lt,rt])

  rule	unaryop_symbol(op) => sym &
	dump_exp_graphviz (e) => ct
	----------------------------
	dump_exp_graphviz(UNARY(op, e)) => Graphviz.LNODE("UNARY",[sym],[],[ct])

  rule	lbinop_symbol(op) => sym &
	dump_exp_graphviz (e1) => lt & 
	dump_exp_graphviz (e2) => rt
	----------------------------------------------------------------
	dump_exp_graphviz(LBINARY(e1, op, e2)) => Graphviz.LNODE("LBINARY",[sym],[],[lt,rt])

  rule	lunaryop_symbol(op) => sym &
 	dump_exp_graphviz (e) => ct
	---------------------------------------------------
	dump_exp_graphviz(LUNARY(op, e)) =>  Graphviz.LNODE("LUNARY",[sym],[],[ct])

  rule	relop_symbol(op) => sym &
 	dump_exp_graphviz(e1) => lt & 
	dump_exp_graphviz(e2) => rt
	-----------------------------------------------------------------
	dump_exp_graphviz(RELATION(e1, op, e2)) =>  Graphviz.LNODE("RELATION",[sym],[],[lt,rt])

  rule	dump_exp_graphviz(c) => ct &
	dump_exp_graphviz(t) => tt &
	dump_exp_graphviz(f) => ft
	----------------------------
	dump_exp_graphviz(IFEXP(c,t,f)) =>  Graphviz.NODE("IFEXP",[],[ct,tt,ft])

  rule	Absyn.path_string(fcn) => fs &
	Util.list_map(args, dump_exp_graphviz) => argnodes
	---------------------------------------------
	dump_exp_graphviz(CALL(fcn, args,_,_)) => Graphviz.LNODE("CALL",[fs],[],argnodes)

  rule	Util.list_map(es, dump_exp_graphviz) => nodes
	-----------------------------
	dump_exp_graphviz (ARRAY(_,_,es)) => Graphviz.NODE("ARRAY",[],nodes)

  rule	Util.list_map(es, dump_exp_graphviz) => nodes
	-----------------------------
	dump_exp_graphviz (TUPLE(es)) => Graphviz.NODE("TUPLE",[],nodes)

	
  rule	print_list_str(es, print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s''
	-----------------------------
	dump_exp_graphviz (MATRIX(_,_,es)) => Graphviz.LNODE("MATRIX",[s''],[],[])

  rule	dump_exp_graphviz (start) => t1 &
	let t2 = Graphviz.NODE(":",[],[]) &
	dump_exp_graphviz (stop) => t3
	-------------------------------------------------------------
	dump_exp_graphviz (RANGE(_,start,NONE,stop)) => Graphviz.NODE("RANGE",[],[t1,t2,t3])

  rule	dump_exp_graphviz (start) => t1 &
	dump_exp_graphviz (step) => t2 &
 	dump_exp_graphviz (stop) => t3
	-------------------------------------
	dump_exp_graphviz (RANGE(_,start,SOME(step),stop)) => Graphviz.NODE("RANGE",[],[t1,t2,t3])

  rule	type_string ty => tystr &
	dump_exp_graphviz e => ct
	---------------------------------------
	dump_exp_graphviz (CAST(ty,e)) => Graphviz.LNODE("CAST",[tystr],[],[ct])

  rule	dump_exp_graphviz (e) => ct &
 	int_string i => istr &
	Util.string_append_list(["[",istr,"]"]) => s
	---------------------------------------
	dump_exp_graphviz (ASUB(e,i)) => Graphviz.LNODE("ASUB",[s],[],[ct])

  rule	dump_exp_graphviz (cr) => crt &
 	dump_exp_graphviz (dim) => dimt
	------------------------
	dump_exp_graphviz (SIZE(cr,SOME(dim))) => Graphviz.NODE("SIZE",[],[crt,dimt])

  rule	dump_exp_graphviz (cr) => crt
	------------------------
	dump_exp_graphviz (SIZE(cr,NONE)) => Graphviz.NODE("SIZE",[],[crt])

  rule	Absyn.path_string fcn => fs &
	dump_exp_graphviz exp => expt &
	dump_exp_graphviz iterexp => itert
	-------------------------------------------------------
	dump_exp_graphviz (REDUCTION(fcn,exp,id,iterexp)) =>  Graphviz.LNODE("REDUCTION",[fs],[],[expt,itert])

  axiom	dump_exp_graphviz (_) => Graphviz.NODE("#UNKNOWN EXPRESSION# ----eeestr ",[],[])

end

(** relation:get_string_n_time
**
 ** Appends the string to itself n times.
 **)
relation gen_string_n_time:(string,int(* n *)) => string =

  axiom gen_string_n_time(str,0) => ""
        
  rule  int_add(level,-1) => new_level &
        gen_string_n_time(str,new_level ) => new_str &
        string_append(str,new_str) => res_str 
        -------------------------------
        gen_string_n_time(str,level) => res_str
        

end

(** relation: dump_exp_str
 **
 ** Dumps expression to a string.
 **)

relation dump_exp_str : (Exp,int) => string  =
	
  rule  gen_string_n_time("   |",level) => gen_str &
        Util.string_append_list([gen_str,"END","\n"]) => res_str
        --------------------------------
        dump_exp_str(END,level) => res_str
        
  rule  gen_string_n_time("   |",level) => gen_str &
        int_string(x) => s &
        Util.string_append_list([gen_str,"ICONST ",s,"\n"]) => res_str
	----------------------------
	dump_exp_str(ICONST(x),level) => res_str (*Graphviz.LNODE("ICONST",[s],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
   	real_string(x) => s &
	Util.string_append_list([gen_str,"RCONST ",s,"\n"]) => res_str
        -----------------------------
	dump_exp_str(RCONST(x),level) => res_str (*Graphviz.LNODE("RCONST",[s],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
   	string_append ("\"", s) => s' &
	string_append (s', "\"") => s'' &
	Util.string_append_list([gen_str,"SCONST ",s'',"\n"]) => res_str
	---------------------------------
	dump_exp_str(SCONST(s),level) => res_str (*Graphviz.LNODE("SCONST",[s''],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
	Util.string_append_list([gen_str,"BCONST ","false","\n"]) => res_str
        -------------------------
   	dump_exp_str(BCONST(false),level) => res_str (*Graphviz.LNODE("BCONST",["false"],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
	Util.string_append_list([gen_str,"BCONST ", "true","\n"]) => res_str
        ----------------------------
   	dump_exp_str(BCONST(true),level) => res_str (*Graphviz.LNODE("BCONST",["true"],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
   	print_component_ref_str (c) => s &
	Util.string_append_list([gen_str,"CREF ",s,"\n"]) => res_str
	--------------------------------
	dump_exp_str(CREF(c,_),level) => res_str (*Graphviz.LNODE("CREF",[s],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
   	binop_symbol(op) => sym &
	dump_exp_str(e1,new_level1) => lt & 
	dump_exp_str(e2,new_level2) => rt &
	Util.string_append_list([gen_str,"BINARY ",sym,"\n",lt,rt,""]) => res_str
	----------------------------
	dump_exp_str(BINARY(e1, op, e2),level) => res_str (*Graphviz.LNODE("BINARY",[sym],[],[lt,rt])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
   	unaryop_symbol(op) => sym &
	dump_exp_str(e,new_level1) => ct &
	Util.string_append_list([gen_str,"UNARY ",sym,"\n",ct,""]) => res_str
	----------------------------
	dump_exp_str(UNARY(op, e),level) => res_str (*Graphviz.LNODE("UNARY",[sym],[],[ct])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
   	lbinop_symbol(op) => sym &
	dump_exp_str(e1,new_level1) => lt & 
	dump_exp_str(e2,new_level2) => rt &
	Util.string_append_list([gen_str,"LBINARY ",sym,"\n",lt,rt,""]) => res_str
	----------------------------------------------------------------
	dump_exp_str(LBINARY(e1, op, e2),level) => res_str (*Graphviz.LNODE("LBINARY",[sym],[],[lt,rt])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
   	lunaryop_symbol(op) => sym &
 	dump_exp_str(e,new_level1) => ct &
	Util.string_append_list([gen_str,"LUNARY ",sym,"\n",ct,""]) => res_str
	---------------------------------------------------
	dump_exp_str(LUNARY(op, e),level) => res_str (*Graphviz.LNODE("LUNARY",[sym],[],[ct])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
   	relop_symbol(op) => sym &
 	dump_exp_str(e1,new_level1) => lt & 
	dump_exp_str(e2,new_level2) => rt & 
	Util.string_append_list([gen_str,"RELATION ",sym,"\n",lt,rt,""]) => res_str
	-----------------------------------------------------------------
	dump_exp_str(RELATION(e1, op, e2),level) => res_str (*Graphviz.LNODE("RELATION",[sym],[],[lt,rt])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
        int_add(level,1) => new_level3 &
   	dump_exp_str(c,new_level1) => ct &
	dump_exp_str(t,new_level2) => tt &
	dump_exp_str(f,new_level3) => ft & 
	Util.string_append_list([gen_str,"IFEXP ","\n",ct,tt,ft,""]) => res_str
	----------------------------
	dump_exp_str(IFEXP(c,t,f),level) => res_str (*Graphviz.NODE("IFEXP",[],[ct,tt,ft])*)

  rule gen_string_n_time("   |",level) => gen_str &
   	Absyn.path_string(fcn) => fs &
        int_add(level,1) => new_level1 &
	Util.list_map_1(args, dump_exp_str,new_level1) => argnodes &
        Util.string_append_list(argnodes) => argnodes' &
	Util.string_append_list([gen_str,"CALL ",fs,"\n",argnodes',""]) => res_str
	---------------------------------------------
	dump_exp_str(CALL(fcn, args,_,_),level) => res_str (*Graphviz.LNODE("CALL",[fs],[],argnodes)*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
  	Util.list_map_1(es, dump_exp_str,new_level1) => nodes &
        Util.string_append_list(nodes) => nodes' &
	Util.string_append_list([gen_str,"ARRAY ",nodes',"\n"]) => res_str
	-----------------------------
	dump_exp_str(ARRAY(_,_,es),level) => res_str (*Graphviz.NODE("ARRAY",[],nodes)*)

  rule gen_string_n_time("   |",level) => gen_str &
       int_add(level,1) => new_level1 &
   	Util.list_map_1(es, dump_exp_str,new_level1) => nodes &
        Util.string_append_list(nodes) => nodes' &
	Util.string_append_list([gen_str,"TUPLE ",nodes',"\n"]) => res_str
	-----------------------------
	dump_exp_str(TUPLE(es),level) => res_str (*Graphviz.NODE("TUPLE",[],nodes)*)

	
  rule gen_string_n_time("   |",level) => gen_str &
   	print_list_str(es, print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s'' & 
	Util.string_append_list([gen_str,"MATRIX ","\n",s'',"","\n"]) => res_str
	-----------------------------
	dump_exp_str(MATRIX(_,_,es),level) => res_str (*Graphviz.LNODE("MATRIX",[s''],[],[])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
   	dump_exp_str(start,new_level1) => t1 &
	let t2 = ":" &
	dump_exp_str(stop,new_level2) => t3 & 
	Util.string_append_list([gen_str,"RANGE ","\n",t1,t2,t3,""]) => res_str
	-------------------------------------------------------------
	dump_exp_str(RANGE(_,start,NONE,stop),level) => res_str (*Graphviz.NODE("RANGE",[],[t1,t2,t3])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
        int_add(level,1) => new_level3 &
   	dump_exp_str(start,new_level1) => t1 &
	dump_exp_str(step,new_level2) => t2 &
 	dump_exp_str(stop,new_level3) => t3 & 
	Util.string_append_list([gen_str,"RANGE ","\n",t1,t2,t3,""]) => res_str
	-------------------------------------
	dump_exp_str(RANGE(_,start,SOME(step),stop),level) => res_str (*Graphviz.NODE("RANGE",[],[t1,t2,t3])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
    	type_string ty => tystr &
	dump_exp_str(e,new_level1) => ct & 
	Util.string_append_list([gen_str,"CAST ","\n",ct,""]) => res_str
	---------------------------------------
	dump_exp_str(CAST(ty,e),level) => res_str (*Graphviz.LNODE("CAST",[tystr],[],[ct])*)

  rule gen_string_n_time("   |",level) => gen_str &
       int_add(level,1) => new_level1 &
   	dump_exp_str(e,new_level1) => ct &
 	int_string i => istr &
	Util.string_append_list(["[",istr,"]"]) => s & 
	Util.string_append_list([gen_str,"ASUB ","\n",s,ct,""]) => res_str
	---------------------------------------
	dump_exp_str(ASUB(e,i),level) => res_str (*Graphviz.LNODE("ASUB",[s],[],[ct])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
  	dump_exp_str(cr,new_level1) => crt &
 	dump_exp_str(dim,new_level2) => dimt & 
	Util.string_append_list([gen_str,"SIZE ","\n",crt,dimt,""]) => res_str
	------------------------
	dump_exp_str(SIZE(cr,SOME(dim)),level) => res_str (*Graphviz.NODE("SIZE",[],[crt,dimt])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
   	dump_exp_str(cr,new_level1) => crt & 
	Util.string_append_list([gen_str,"SIZE ","\n",crt,""]) => res_str
	------------------------
	dump_exp_str(SIZE(cr,NONE),level) => res_str (*Graphviz.NODE("SIZE",[],[crt])*)

  rule gen_string_n_time("   |",level) => gen_str &
        int_add(level,1) => new_level1 &
        int_add(level,1) => new_level2 &
   	Absyn.path_string fcn => fs &
	dump_exp_str(exp,new_level1) => expt &
	dump_exp_str(iterexp,new_level2) => itert & 
	Util.string_append_list([gen_str,"REDUCTION ","\n",expt,itert,""]) => res_str
	-------------------------------------------------------
	dump_exp_str(REDUCTION(fcn,exp,id,iterexp),level) => res_str (*Graphviz.LNODE("REDUCTION",[fs],[],[expt,itert])*)

  rule gen_string_n_time("   |",level) => gen_str &
 	Util.string_append_list([gen_str," UNKNOWN EXPRESSION ","\n"]) => res_str
        -----------------------------------------
  	dump_exp_str(_,level) => res_str (*Graphviz.NODE("#UNKNOWN EXPRESSION# ----eeestr ",[],[])*)

end

(** relation: solve
 **
 ** Solves an equation consisting of a right hand side (rhs) and a left hand 
 ** side (lhs), with respect to the expression given as third argument, 
 ** usually a variable. 
 **)

relation solve : (Exp, (* lhs *)
		  Exp, (* rhs *)
		  Exp) (* solve for *)
	  => Exp =

	  (** Special case when already solved, cr1 = rhs
	   ** otherwise division by zero when dividing with derivative *)
  rule	cref_equal(cr1,cr2) => true &
	exp_contains (rhs,crexp) => false 
	---------------------------------
	solve (crexp as CREF(cr1,_), rhs, CREF(cr2,_)) => rhs
	
	(* Special case when already solved, lhs = cr1
 	 ** otherwise division by zero  when dividing with derivative *)
  rule	cref_equal(cr1,cr2) => true &
	exp_contains (lhs,crexp) => false 
	---------------------------------
	solve (lhs, crexp as CREF(cr1,_), CREF(cr2,_)) => lhs

  rule	solve2 (lhs, rhs, cr) => res &
	simplify res => res'
	-------------------------------------
	solve (lhs,rhs, cr as CREF(_,_)) => res'
	
  rule	Print.print_buf "solve failed: Not an equation or trying to solve for\n" &
	Print.print_buf "a non-component-reference, or a non-linear equation:\n" &
	print_exp e1 &
	Print.print_buf "\n" &
	print_exp e2 &
	Print.print_buf "\n"
        ----------------------------------
	solve (e1, e2, e3) => fail
end

(** relation: solve2
 **
 ** This relation solves an equation e1 = e2 with respect to the variable
 ** given as an expression e3 
 **)
relation solve2 : ( Exp (*e1*), Exp (*e2*), Exp(*e3*)) => Exp =

  rule	let lhs = BINARY(e1, SUB(REAL), e2) &
	Derive.differentiate_exp (lhs, cr) => lhsder &
	simplify (lhsder) => lhsder' &
	exp_contains (lhsder', crexp) => false &
	replace_exp (lhs, crexp, RCONST(0.0)) => (lhszero,_) &
	simplify (lhszero) => lhszero' &
	let rhs = UNARY(UMINUS(REAL), BINARY(lhszero', DIV(REAL), lhsder')) &
	simplify (rhs) => rhs' 
	(*
	& dump_exp_graphviz lhs => lhsnode 
	& Print.print_buf "------------------ LHS -----------------\n"
	& Graphviz.dump lhsnode
	& Print.print_buf "------------------ /LHS -----------------\n"
	 *)
	---------------------------------------
	solve2 (e1, e2, crexp as CREF(cr,_)) => rhs'


  rule	let lhs = BINARY(e1, SUB(REAL), e2) &
	Derive.differentiate_exp (lhs, cr) => lhsder &
	simplify lhsder => lhsder' &
	exp_contains (lhsder', crexp) => true &
	Print.print_buf "solve2 failed: Not linear: " &
	print_exp e1 &
	Print.print_buf " = " &
	print_exp e2 &
	Print.print_buf "\nsolving for: " &
	print_exp crexp &
	Print.print_buf "\n" &
       Print.print_buf "derivative: " &
	print_exp lhsder & 
	Print.print_buf "\n" 
	---------------------------------------
	solve2 (e1, e2, crexp as CREF(cr,_)) => fail



  rule	let lhs = BINARY(e1, SUB(REAL), e2) &
	Derive.differentiate_exp (lhs, cr) => lhsder &
	simplify lhsder => lhsder' &
	Print.print_buf "solve2 failed: " &
	print_exp e1 &
	Print.print_buf " = " &
	print_exp e2 &
	Print.print_buf "\nsolving for: " &
	print_exp crexp &
	Print.print_buf "\nDerivative :" &
	print_exp lhsder' & 
	Print.print_buf "\n"
	
        ----------------------------------
	solve2 (e1, e2, crexp as CREF(cr,_)) => fail

end

(** relation get_terms_containing_x
 **
 ** Retrieves all terms of an expression containng a variable, given
 ** as second argument (in the form of an Exp)
 **)

relation get_terms_containing_x : (Exp, Exp) => (Exp, Exp) =

  rule	get_terms_containing_x (e1, cr) => (xt1, nonxt1) &
	get_terms_containing_x (e2, cr) => (xt2, nonxt2) &
	let xt = BINARY(xt1, ADD(ty), xt2) &
	let nonxt = BINARY(nonxt1, ADD(ty), nonxt2)
	---------------------------------------
	get_terms_containing_x (BINARY(e1, ADD(ty), e2), cr as CREF(_,_)) => (xt,nonxt)

  rule	get_terms_containing_x (e1, cr) => (xt1, nonxt1) &
	get_terms_containing_x (e2, cr) => (xt2, nonxt2) &
	let xt = BINARY(xt1, SUB(ty), xt2) &
	let nonxt = BINARY(nonxt1, SUB(ty), nonxt2)
	---------------------------------------
	get_terms_containing_x (BINARY(e1, SUB(ty), e2), cr as CREF(_,_)) => (xt,nonxt)

  rule	get_terms_containing_x (e, cr) => (xt1, nonxt1) &
	let xt = UNARY(UPLUS(ty), xt1) &
	let nonxt = UNARY(UPLUS(ty), nonxt1)
	---------------------------------------
	get_terms_containing_x (UNARY(UPLUS(ty), e), cr as CREF(_,_)) => (xt,nonxt)

  rule	get_terms_containing_x (e, cr) => (xt1, nonxt1) &
	let xt = UNARY(UMINUS(ty), xt1) &
	let nonxt = UNARY(UMINUS(ty), nonxt1)
	---------------------------------------
	get_terms_containing_x (UNARY(UMINUS(ty), e), cr as CREF(_,_)) => (xt,nonxt)

  rule	exp_contains (e, cr) => res &
	Util.if(res, e, RCONST(0.0)) => xt &
	Util.if(res, RCONST(0.0), e) => nonxt
	-----------------------------------
	get_terms_containing_x (e, cr as CREF(_,_)) => (xt, nonxt)

  rule	Print.print_buf "get_terms_containing_x failed: " &
	print_exp e &
	Print.print_buf "\nsolving for: " &
	print_exp cr &
	Print.print_buf "\n"
        ----------------------------------
	get_terms_containing_x (e, cr) => fail

end

(** relation: exp_contains
 ** 
 ** Returns true if first expression contains the second one as a sub
 ** expression.
 ** Only component references can be checked so far,
 **  i.e. check whether an expression contains a given component reference 
 **)

relation exp_contains : (Exp, Exp) => bool =

  axiom	exp_contains (ICONST(i), cr as CREF(_,_)) => false
  axiom	exp_contains (RCONST(i), cr as CREF(_,_)) => false
  axiom	exp_contains (SCONST(i), cr as CREF(_,_)) => false
  axiom	exp_contains (BCONST(i), cr as CREF(_,_)) => false


  rule	Util.list_map_1(explist, exp_contains,cr) => reslist &
	Util.bool_or_list reslist => res
	----------------------------
	exp_contains (ARRAY(_,_,explist),cr) => res

  rule	cref_equal (cr1, cr2) => res
	---------------------------
	exp_contains (c1 as CREF(cr1,_), c2 as CREF(cr2,_)) => res
	
  rule	exp_contains (e1, cr) => res1 &
	exp_contains (e2, cr) => res2 &
	bool_or (res1, res2) => res
	------------------------
	exp_contains (BINARY(e1, op, e2), cr as CREF(_,_)) => res

  rule	exp_contains (e, cr) => res
	----------------------------
	exp_contains (UNARY(op, e), cr as CREF(_,_)) => res

  rule	exp_contains (e1, cr) => res1 &
	exp_contains (e2, cr) => res2 &
	bool_or (res1, res2) => res
	----------------------------------------------------------------
	exp_contains (LBINARY(e1, op, e2), cr as CREF(_,_)) => res

  rule	exp_contains (e, cr) => res
	---------------------------------------------------
	exp_contains (LUNARY(op, e), cr as CREF(_,_)) => res

  rule	exp_contains (e1, cr) => res1 &
	exp_contains (e2, cr) => res2 &
	bool_or (res1, res2) => res
	-----------------------------------------------------------------
	exp_contains (RELATION(e1, op, e2), cr as CREF(_,_)) => res

  rule	exp_contains (c, cr) => res1 &
	exp_contains (t, cr) => res2 &
	exp_contains (f, cr) => res3 &
	Util.bool_or_list ([res1, res2, res3]) => res
	---------------------------------------------
	exp_contains (IFEXP(c,t,f), cr as CREF(_,_)) => res

  rule	Util.list_map_1 (args, exp_contains, cr) => reslist &
	Util.bool_or_list reslist => res
	--------------------------------
	exp_contains (CALL(fcn, args,_,_), cr as CREF(_,_)) => res


  axiom	exp_contains (CAST(REAL,ICONST(i)), cr as CREF(_,_)) => false


  rule	exp_contains (e, cr) => res
	---------------------------------------
	exp_contains (CAST(REAL,e), cr as CREF(_,_)) => res


  rule	exp_contains (e, cr) => res
	---------------------------------------
	exp_contains (ASUB(e,i), cr as CREF(_,_)) => res


  rule	Print.print_buf "exp_contains failed: When looking for \"" &
	print_exp  cr &
	Print.print_buf "\" in \"" &
	print_exp  e &
	Print.print_buf "\n"
        ----------------------------------
	exp_contains (e, cr) => fail
end


(** relation: get_cref_from_exp
 **
 ** Return a list of all component references occuring in the
 ** expression.
 **)

relation get_cref_from_exp: ( Exp ) => ComponentRef list =

  axiom	get_cref_from_exp(ICONST(_)) => []
  axiom	get_cref_from_exp(RCONST(_)) => []
  axiom	get_cref_from_exp(SCONST(_)) => []
  axiom	get_cref_from_exp(BCONST(_)) => []
  axiom	get_cref_from_exp(CREF(cr,_)) => [cr]

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(BINARY(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => res
	----------------------------
	get_cref_from_exp(UNARY(op,e1)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(LBINARY(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => res
	----------------------------
	get_cref_from_exp(LUNARY(op,e1)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(RELATION(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res1 &
	get_cref_from_exp(e3) => l3 &
	list_append(res1,l3) => res
	---------------------------
	get_cref_from_exp(IFEXP(e1,e2,e3)) => res
	
  rule	Util.list_map(farg,get_cref_from_exp) => res &
	Util.list_flatten(res) => res2
	--------------------------------------------
	get_cref_from_exp(CALL(_,farg,_,_)) => res2


  rule	Util.list_map(expl,get_cref_from_exp) => res1 &
	Util.list_flatten(res1) => res
	--------------------------------------------
	get_cref_from_exp(ARRAY(_,_,expl)) => res

  rule	print "get_cref_from_exp MATRIX not impl. yet\n" 
	----------------
	get_cref_from_exp(MATRIX(_,_,_)) => []

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res1 &
	get_cref_from_exp(e3) => l3 &
	list_append(res1,l3) => res
	---------------------------
	get_cref_from_exp(RANGE(_,e1,SOME(e3),e2)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res 
	---------------------------
	get_cref_from_exp(RANGE(_,e1,NONE,e2)) => res
	    
  rule	(*Util.list_map(expl,get_cref_from_exp) => res*)
	Print.print_buf "Not implemented yet\n" 
	------------------
	get_cref_from_exp(TUPLE(expl)) => []

  rule	get_cref_from_exp(e) => res
	---------------------------
	get_cref_from_exp(CAST(_,e)) => res

  rule	get_cref_from_exp(e) => res
	---------------------------
	get_cref_from_exp(ASUB(e,_)) => res

  axiom	get_cref_from_exp(_) => []
end


(** relation: get_function_calls_list
 **
 ** calls get_function_calls for a list of exps
 **)

relation get_function_calls_list : Exp list => Exp list =

  rule	Util.list_map(exps, get_function_calls) => explists &
	Util.list_flatten (explists) => res
	-----------------------------------
	get_function_calls_list exps => res
end

(** relation: get_function_calls
 **
 ** Return all exps that are function calls.
 ** Inner call exps are returned separately but not extracted from the exp they
 ** are in, e.g. CALL(foo, [CALL(bar)]) will return
 ** [CALL(foo, [CALL(bar)]), CALL(bar,[])]
 **)

relation get_function_calls : Exp => Exp list =

  rule	get_function_calls_list args => argexps &
	list_append([e], argexps) => exps
	---------------------------------
	get_function_calls(e as CALL(path,args,tuple,builtin)) => exps

	(* Binary *)
  rule	get_function_calls e1 => a &
	get_function_calls e2 => b &
	list_append(a,b) => res
	--------------------------------------
	get_function_calls(BINARY(e1,_,e2)) => res

	(* Unary *)
  rule	get_function_calls(e) => res
	---------------------
	get_function_calls(UNARY(_,e)) => res

	(* LBinary *)
  rule	get_function_calls(e1) => a &
	get_function_calls(e2) => b &
	list_append(a,b) => res
	---------------------
	get_function_calls(LBINARY(e1,_,e2)) => res

	(* LUnary *)
  rule	get_function_calls(e) => res
	---------------------
	get_function_calls(LUNARY(_,e)) => res

	(* Relation *)
  rule	get_function_calls(e1) => a &
	get_function_calls(e2) => b &
	list_append(a,b) => res
	---------------------
	get_function_calls(RELATION(e1,_,e2)) => res

  rule	get_function_calls_list [e1,e2,e3] => res
	--------------------------------
	get_function_calls(IFEXP(e1,e2,e3)) => res

	(* Array *)
  rule	get_function_calls_list elts => res
	------------------------------
	get_function_calls(ARRAY(_,_,elts)) => res

	(* Matrix *)
  rule	Util.list_flatten(explst) => flatexplst &
	Util.list_map(flatexplst,Util.tuple2_1) => elst &
	get_function_calls_list elst => res	
	----------------------------------------
	get_function_calls(MATRIX(_,_,explst)) => res

	(* Range *)
  rule	Util.option_to_list optexp => e3 &
	list_append([e1,e2], e3) => elist &
	get_function_calls_list (elist) => res
	--------------------------------------
	get_function_calls(RANGE(_,e1,optexp,e2)) => res

	(* Tuple *)
  rule	get_function_calls_list exps => res
	-----------------------------------
	get_function_calls(TUPLE(exps)) => res

  rule	get_function_calls(e) => res
	------------------------------
	get_function_calls(CAST(_,e)) => res
	
	(* Size *)
  rule	Util.option_to_list e2 => a &
	list_append(a, [e1]) => elist &
	get_function_calls_list elist => res
	--------------------------------
	get_function_calls(SIZE(e1,e2)) => res

 axiom	get_function_calls(_) => []

end

(** relation traverse_exp
 **
 ** Traverses all subexpressions of an expression.
 ** Takes a relation and an extra argument passed through the traversal.
 **)
		    
 relation traverse_exp: (Exp, 
			 ((Exp * 'a) => (Exp * 'a)),  (* rel-ation to apply*)
			 'a) (* extra value passed to re-lation*)
	  => (Exp *  'a) =
	   
	   (* unary *)
  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	 rel((e,ext_arg')) => ((UNARY(op',_),ext_arg''))
	 -----------------------------------
	 traverse_exp(e as UNARY(op,e1),rel,ext_arg) 
	  => ((UNARY(op',e1'),ext_arg''))
	   
	   (* binary *)
  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	 traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	 rel((e,ext_arg'')) => ((BINARY(_,op',_),ext_arg'''))
	 ----------------------------------------------
	 traverse_exp(e as BINARY(e1,op,e2),rel,ext_arg) 
	  => ((BINARY(e1',op',e2'),ext_arg'''))
	   
	   (* logic unary *)
  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	 rel((e,ext_arg')) => ((LUNARY(op',_),ext_arg''))
 	 -----------------------------------
	 traverse_exp(e as LUNARY(op,e1),rel,ext_arg) 
	  => ((LUNARY(op',e1'),ext_arg''))
	   
	   (* logic binary *)
  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	 traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	 rel((e,ext_arg'')) => ((LBINARY(_,op',_),ext_arg'''))
	 ----------------------------------------------
	 traverse_exp(e as LBINARY(e1,op,e2),rel,ext_arg) 
	  => ((LBINARY(e1',op',e2'),ext_arg'''))
	   
	   (* RELATION *)
  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	 rel((e,ext_arg'')) => ((RELATION(_,op',_),ext_arg'''))
	 ----------------------------------------------
	 traverse_exp(e as RELATION(e1,op,e2),rel,ext_arg) 
	  => ((RELATION(e1',op',e2'),ext_arg'''))

	  (* if expression *)
  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	traverse_exp(e3,rel,ext_arg'') => ((e3',ext_arg''')) &
	 rel((e,ext_arg''')) => ((e',ext_arg''''))
	----------------------------------------------
	traverse_exp(e as IFEXP(e1,e2,e3),rel,ext_arg) 
	  => ((IFEXP(e1',e2',e3'),ext_arg''''))

  rule	Util.list_fold_map(expl,rel,ext_arg) =>(expl',ext_arg') &
	 rel((e,ext_arg')) => ((CALL(fn',_,t',b'),ext_arg''))
	----------------------------------------------
	traverse_exp(e as CALL(fn,expl,t,b),rel,ext_arg) 
	  => ((CALL(fn',expl',t',b'),ext_arg''))

  rule	Util.list_fold_map(expl,rel,ext_arg) =>(expl',ext_arg') &
	 rel((e,ext_arg')) => ((ARRAY(tp',scalar',_),ext_arg''))
	----------------------------------------------
	traverse_exp(e as ARRAY(tp,scalar,expl),rel,ext_arg) 
	  => ((ARRAY(tp',scalar',expl'),ext_arg''))

  rule	traverse_exp_matrix(expl,rel,ext_arg) => (expl',ext_arg') &
	 rel((e,ext_arg')) => ((MATRIX(tp',scalar',_),ext_arg''))
	----------------------------------------------
	traverse_exp(e as MATRIX(tp,scalar,expl),rel,ext_arg) 
	  => ((MATRIX(tp,scalar,expl'),ext_arg''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	 rel((e,ext_arg'')) => ((RANGE(tp',_,_,_),ext_arg'''))
	----------------------------------------------
	traverse_exp(e as RANGE(tp,e1,NONE,e2),rel,ext_arg) 
	  => ((RANGE(tp',e1',NONE,e2'),ext_arg'''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg''))  &
	traverse_exp(e3,rel,ext_arg'') => ((e3',ext_arg''')) &
	 rel((e,ext_arg''')) => ((RANGE(tp',_,_,_),ext_arg''''))
	----------------------------------------------
	traverse_exp(e as RANGE(tp,e1,SOME(e2),e3),rel,ext_arg) 
	  => ((RANGE(tp',e1',SOME(e3),e2'),ext_arg''''))

  rule	Util.list_fold_map(expl,rel,ext_arg) => (expl',ext_arg') &
	 rel((e,ext_arg')) => ((e',ext_arg''))
	----------------------------------------------
	traverse_exp(e as TUPLE(expl),rel,ext_arg) 
	  => ((TUPLE(expl'),ext_arg''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	 rel((e,ext_arg')) => ((CAST(tp',_),ext_arg''))
	----------------------------------------------
	traverse_exp(e as CAST(tp,e1),rel,ext_arg) 
	  => ((CAST(tp,e1'),ext_arg''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	rel((e,ext_arg')) => ((ASUB(_,i'),ext_arg''))
	----------------------------------------------
	traverse_exp(e as ASUB(e1,i),rel,ext_arg) 
	  => ((ASUB(e1',i'),ext_arg''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	rel((e,ext_arg')) => ((e',ext_arg''))
	----------------------------------------------
	traverse_exp(e as SIZE(e1,NONE),rel,ext_arg)
	  => ((SIZE(e1',NONE),ext_arg''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	rel((e,ext_arg'')) => ((e',ext_arg'''))
	----------------------------------------------
	traverse_exp(e as SIZE(e1,SOME(e2)),rel,ext_arg) 
	  => ((SIZE(e1',SOME(e2')),ext_arg'''))

  rule	traverse_exp(e1,rel,ext_arg) => ((e1',ext_arg')) &
	traverse_exp(e2,rel,ext_arg') => ((e2',ext_arg'')) &
	 rel((e,ext_arg'')) => ((REDUCTION(path',_,id',_),ext_arg'''))
	 ------------------------
	 traverse_exp(e as REDUCTION(path,e1,id,e2),rel,ext_arg)
	  => ((REDUCTION(path',e1',id',e2'),ext_arg'''))

  rule	rel((e,ext_arg)) => ((e',ext_arg'))
	-----------------------
	traverse_exp(e,rel,ext_arg) => ((e',ext_arg'))
end

(** relation: traverse_exp_matrix
 ** author: PA
 ** 
 **  Helper relation to traverse_exp, traverses matrix expressions.
 **)
relation traverse_exp_matrix:((Exp*bool) list list, 
			      ((Exp * 'a) => (Exp * 'a)),
			      'a) 
	  => ((Exp*bool) list list,'a) =
	  
  axiom	traverse_exp_matrix([],rel,e_arg) => ([],e_arg)
	
  rule	traverse_exp_matrix_2(row,rel,e_arg) => (row',e_arg') &
	traverse_exp_matrix(rows,rel,e_arg') => (rows',e_arg'')
	----------------
	traverse_exp_matrix(row::rows,rel,e_arg) 
	  => (row'::rows',e_arg'')
end

(** relation: traverse_exp_matrix_2
 ** author: PA
 **
 ** Helper relation to traverse_exp_matrix.
 **)

relation traverse_exp_matrix_2: ((Exp*bool) list, 
				  ((Exp * 'a) => (Exp * 'a)),
				  'a) 
	  => ((Exp*bool) list,'a) = 

  axiom	traverse_exp_matrix_2([],_,e_arg) => ([],e_arg)

  rule	traverse_exp(e,rel,e_arg) => ((e',e_arg')) &
	traverse_exp_matrix_2(rest,rel,e_arg') => (rest',e_arg'')
	------------------------------
	traverse_exp_matrix_2((e,b)::rest,rel,e_arg) 
	  => ( (e',b)::rest',e_arg'')
end


(** relation: matrix_exp_map_1
 ** author: PA
 ** 
 ** Maps a relation, taking one extra argument over a MATRIX expression
 ** list.
**)

relation matrix_exp_map_1:((Exp*bool) list list, (Exp, 'b) => Exp, 'b) 
	  => (Exp*bool) list list =

  axiom	matrix_exp_map_1([],_,_) => []

  rule	matrix_exp_map_1_help(e,rel,arg) => e' &
	matrix_exp_map_1(es,rel,arg) => es'
	-----------------------------
	matrix_exp_map_1(e::es,rel,arg) => e'::es'
end

(** relation: matrix_exp_map_1_help
 **
 ** Helper relation to matrix_exp_map_1.
 **)

relation matrix_exp_map_1_help:((Exp*bool) list, (Exp, 'b) => Exp, 'b) 
	  => (Exp*bool) list =

  axiom	matrix_exp_map_1_help([],_,_) => []

  rule	rel(e,arg) => e' &
	matrix_exp_map_1_help(es,rel,arg) => es' 
	----------------------
	matrix_exp_map_1_help((e,b)::es,rel,arg) => ((e',b)::es')
end