(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Inst.rml
 ** module:      Inst
 ** description: Model instantiation
 **
 ** RCS: $Id$
 **
 ** This module is responsible for instantiation of Modelica
 **  models. The instantation is the process of instantiating model
 ** components, flattening inheritance and generating equations from
 ** connect statements.
 ** The instantiation process takes Modelica AST as defined in SCode
 ** and produces variables and equations and algorithms, etc. as
 ** defined in DAE.
 ** 
 ** This module uses 'Lookup' to lookup classes and variables from the
 ** environment defined in 'Env'. It uses 'Connect' for generating equations from
 ** connect statements. The type system defined in 'Types' is used for
 ** variable instantiation and type . 'Mod' is used for modifiers and
 ** merging of modifiers. 
 ** 
 **)

(** debug flags: inst *)

module Inst:
  with "ClassInf.rml"
  with "Connect.rml"
  with "DAE.rml"
  with "Env.rml"
  with "Exp.rml"
  with "SCode.rml"
  with "Mod.rml"
  with "Prefix.rml"
  with "Types.rml"
  with "Absyn.rml"

  (* Calling scope is used to determine when unconnected flow variables 
   * should be set to zero. *)
  datatype CallingScope = TOP_CALL | INNER_CALL

  type InstDims = Exp.Subscript list

  (** Intial is used in relations for instantiating equations to 
   ** specify if they are initial or not.
   **)
  datatype Initial = INITIAL | NON_INITIAL

  datatype DimExp = DIMINT of int
		  | DIMEXP of Exp.Subscript * Exp.Exp option

(* Instantiation *)

(** There are basically four different ways/granularities of instantiation.
 ** 1. Using partial_inst_class_in which only instantiates class definitions.
 **    This relation is used for looking up class definitions in e.g. packages.
 **    For example, if looking up the class A.B.C, a new scope is opened and 
 **    A is partially instantiated in that scope using partial_inst_class_in.
 **
 ** 2. Function implicit instantiation. is the last argument of type bool to 
 **    inst_class_in. It is needed since instantiation of functions is needed 
 **    to generate code for functions and there are cases where such 
 **    instantiations differ 
 **    from standard function instantiation. For example
 **    function foo
 **      input Real x[:];
 **      ...
 **    end foo;
 **    should be possible to instantiate even though the dimension size of x is
 **    not known.
 **
 ** 3. Implicit instantiation controlled by the next last argument to 
 **    inst_class_in. 
 **    This is also needed, when a DAE should not be generated. 
 **    It is not clear when this is needed, perhaps it can be removed in the 
 **    future.
 ** 4. Full instantiation, which is used for standard model instantiation, 
 **    when equations variables, etc., are generated. This is enabled by 
 **    setting the last two booleans of inst_class_in to false.
 **
 ** Instantiation steps
 ** ===================
 ** The instantiation is done in several steps, see relation inst_classdef.
 ** 1. All local class definitions are added to the environment.
 ** 2. The inheritance structure is flattened out annotating each inherited 
 **    component with the base class it originates from, for correct lookup
 **    later on.
 ** 3. All components are added (untyped) to the environment
 ** 4. Instantiation of components occur.
 **    When a component is instantiated in inst_element it first collects all 
 **    other component references from array dimensions and modifiers and 
 **    recursively (i.e. backpatching) instantiates these first. This is 
 **    performed to allow using a variable before it has been declared. This 
 **    is done in the update_component_in_env function.
**)
 


  (* Exported Relations *)
  relation instantiate: SCode.Program => DAE.DAElist
  relation instantiate_implicit: SCode.Program => DAE.DAElist
  
  relation make_binding : (Env.Env, SCode.Attributes, Types.Mod)
	  => Types.Binding

  relation instantiate_class : (SCode.Program,SCode.Path) => (DAE.DAElist,Env.Env)
  relation instantiate_class_implicit : (SCode.Program,SCode.Path) => (DAE.DAElist,Env.Env)

  relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env 
  relation make_simple_env_from_program: (SCode.Program,SCode.Path) => Env.Env 

  relation inst_class: ( Env.Env, Types.Mod, Prefix.Prefix, 
			Connect.Sets, SCode.Class, InstDims,bool (*impl*),CallingScope)
	  => ( DAE.Element list, Env.Env, Connect.Sets, Types.Type, ClassInf.State)


  relation inst_class_decl : ( Env.Env, Types.Mod, Prefix.Prefix,
			      Connect.Sets, SCode.Class, InstDims, bool (*packimpl?*))
	  => ( Env.Env, DAE.Element list)

  relation inst_class_in: ( Env.Env, Types.Mod, Prefix.Prefix, 
			   Connect.Sets, ClassInf.State,
			   SCode.Class, bool, InstDims, 
			   bool(*implicit inst*),
			   bool(* function implicit inst*))
	  => ( DAE.Element list, Env.Env, Connect.Sets, 
	      ClassInf.State, Types.Var list)

  relation partial_inst_class_in: ( Env.Env, Types.Mod, Prefix.Prefix, 
			   Connect.Sets, ClassInf.State,
			   SCode.Class, bool, InstDims)
	  => (Env.Env, ClassInf.State)

  relation implicit_instantiation : (Env.Env, Types.Mod, Prefix.Prefix,
				     Connect.Sets, SCode.Class,InstDims, bool)
	  => (Env.Env, DAE.Element list)
	    
  relation inst_record_constructor_elt : (Env.Env, SCode.Element, bool (*impl*)) 
	 => (Types.Var)
  relation mktype : (Absyn.Path, ClassInf.State,Types.Var list) => Types.Type

  relation init_vars_modelica_output : DAE.Element list => DAE.Element list

  relation new_ident : () => Exp.ComponentRef
  relation implicit_function_instantiation : ( Env.Env, Types.Mod, 
					      Prefix.Prefix, Connect.Sets, SCode.Class,
					      InstDims, bool)
	  => ( Env.Env, DAE.Element list)
 relation implicit_function_type_instantiation:(Env.Env, SCode.Class)
	  => (Env.Env)
  relation make_fully_qualified : (Env.Env, Absyn.Path) => Absyn.Path
  relation add_nomod: SCode.Element list => (SCode.Element*Types.Mod) list

  relation elab_component_arraydim_from_env: (Env.Env, Exp.ComponentRef) => DimExp list

end

with "Debug.rml"
with "Interactive.rml"							  
with "Util.rml"
with "Algorithm.rml"
with "Builtin.rml"
with "Dump.rml"
with "Lookup.rml"
with "ModUtil.rml"
with "RTOpts.rml"
with "Static.rml"
with "Values.rml"
with "Print.rml"
with "System.rml"
with "Ceval.rml"

val for_scope_name = "$for loop scope$"	  
(**
 ** These type aliases are introduced to make the code a little more
 ** readable.
 **)

type Prefix = Prefix.Prefix
type Mod = Types.Mod
type Ident = Exp.Ident
type Env = Env.Env


(** relation: print_dims
 ** 
 ** Print DimExp list
 **)

relation print_dims: DimExp list => () =
  rule	print_dim([SOME(x)]) => () &
	print_dims(xs) => ()
	-------------------
	print_dims(x::xs) => ()

  axiom	print_dims([]) => ()
end


(** relation: new_ident
 **
 ** This relation creates a new, unique identifer.  The same name is
 ** never returned twice.
 **)

relation new_ident : () => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append("__TMP__",is) => s
	-----------------------------------------------------------------
	new_ident => Exp.CREF_IDENT(s,[])

end


(** relation: select
 **
 ** This utility relation selects one of two objects depending on a
 ** boolean variable.
 **)

relation select : (bool, 'a, 'a) => 'a =

  axiom	select (true,x,_) => x
  axiom	select (false,_,x) => x

end

(** relation: is_not_function
 **
 ** This relation returns true if the Class is not a function.
 **)

relation is_not_function : SCode.Class => bool =

  rule	SCode.is_function cls => res &
	bool_not(res) => res
	------------------------------
	is_not_function cls => res

end

(** relation: instantiate
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAElist =

  rule	Debug.fprintln("insttr", "instantiate") &
	Util.list_select (p, is_not_function) => pnofunc &
	Util.list_select (p, SCode.is_function) => pfunc &
	Builtin.initial_env => env &
	Debug.fprintln("insttr", "Instantiating functions") &
	Util.list_map(pfunc, SCode.class_name) => pfuncnames &
	Util.string_delimit_list(pfuncnames,", ") => str1 &
	Debug.fprint("insttr", "Instantiating functions: ") &
	Debug.fprintln("insttr", str1) &
	Env.extend_frame_classes(env,(*pfunc*)p) => envimpl &
	inst_program_implicit(envimpl,pfunc) => (lfunc,envimpl')  &
	Debug.fprint("insttr", "Instantiating other classes: ") &
	Util.list_map(pnofunc, SCode.class_name) => pnofuncnames &
	Util.string_delimit_list(pnofuncnames,", ") => str2 &
	Debug.fprintln("insttr", str2) &
	inst_program(envimpl',pnofunc) => lnofunc &
	list_append(lfunc, lnofunc) => l
	-----------------------------
	instantiate(p) => DAE.DAE(l)

  rule	Debug.fprintln("failtrace", "instantiate failed")
	-----------------------------------------------
	instantiate _ => fail

end


(** relation: instantiate_implicit
 **
 ** Implicit instantiation of a program can be used for e.g. code generation 
 ** of functions, since a function must be implicitly instantiated in order to
 ** generate code from it. 
 **)

relation instantiate_implicit: SCode.Program => DAE.DAElist =

  rule	Debug.fprintln("insttr", "instantiate_implicit") &
	Builtin.initial_env => env &
	Env.extend_frame_classes(env,p) => env' &
	inst_program_implicit(env',p) => (l,_) 
	-----------------------------
	instantiate_implicit(p) => DAE.DAE(l)

  rule	Debug.fprintln("failtrace", "instantiate_implicit failed")
	-----------------------------------------------
	instantiate_implicit _ => fail
end


(** relation: instantiate_class
 **

 ** To enable interactive instantiation, an arbitrary class in the program 
 ** needs to be possible to instantiate. This relation performs the same 
 ** action as `inst_program', but given a specific class to instantiate.
 ** 
 **  First, all the class definitions are added to the environment without 
 ** modifications, and then the specified class is instantiated in the 
 ** relation `inst_class_in_program'
 **)

relation instantiate_class : (SCode.Program, SCode.Path) 
	  => (DAE.DAElist,Env.Env) =

  rule	Print.print_error_buf "# Empty program\n"
	------------------------------
	instantiate_class([],cr) => fail

	(* top level class *)
  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path) => (env',dae1) &
 	inst_class_in_program(env',cdecls,path) => (dae,env'')
	-----------------------------
	instantiate_class(cdecls as _::_, path as Absyn.IDENT(name2)) 
	  => (DAE.DAE([DAE.COMP(name2,DAE.DAE(dae))]),env'')
	  
	  (* class in package *)
  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path)=> (env',_) &
	Lookup.lookup_class(env',path,true) 
	  => (cdef as SCode.CLASS(n,_,_,_,_), env'') &
	inst_class(env'', Types.NOMOD, Prefix.NOPRE, [], cdef, [], false(*impl*),TOP_CALL) 
	  => (dae,env'', _, _, _) &
	Absyn.path_string path => pathstr
	--------------------------------------------
	instantiate_class(cdecls as _::_, path as Absyn.QUALIFIED(name,_)) 
	  => (DAE.DAE([DAE.COMP(pathstr,DAE.DAE(dae))]),env'')
	
end

(** relation: instantiate_class_implicit
 ** author: PA
 **
 ** Similar to instantiate_class, i.e. instantation of arbitrary classes
 ** but this one instantiates the class implicit, e.g. for functions.
 **)

relation instantiate_class_implicit : (SCode.Program, SCode.Path) 
	  => (DAE.DAElist,Env.Env) =

  rule	Print.print_error_buf "# Empty program\n"
	------------------------------
	instantiate_class_implicit([],cr) => fail

	(* top level class *)
  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path) => (env',dae1) &
 	inst_class_in_program_implicit(env',cdecls,path) => (dae,env'')
	---------------------------------------------------------------
	instantiate_class_implicit(cdecls as _::_, path as Absyn.IDENT(name2)) 
	  => (DAE.DAE(dae),env'')
	  
	  (* class in package *)
  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path)=> (env',_) &
	Lookup.lookup_class(env',path,true) 
	  => (cdef as SCode.CLASS(n,_,_,_,_), env'') &
	implicit_instantiation(env'',Types.NOMOD,Prefix.NOPRE,[],cdef,[],false)
	  => (env,dae) 
	--------------------------------------------
	instantiate_class_implicit(cdecls as _::_, path as Absyn.QUALIFIED(name,_)) 
	  => (DAE.DAE(dae),env)
	
  rule	print "-instantiate_class_implicit failed\n"
	------------
	instantiate_class_implicit(_,_) => fail
end

(** relation: inst_class_in_program
 **
 ** Instantitates a specifc class in a Program. The class must reside on top
 ** level.
 **)

relation inst_class_in_program: (Env, SCode.Program, SCode.Path ) 
	  => (DAE.Element list, Env.Env) =

  rule	name = name2 &
	inst_class(env, Types.NOMOD, Prefix.NOPRE, [], c, [], false(*impl*),TOP_CALL) 
	  => (dae, env', _, _,_) 
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_,_))::cs,Absyn.IDENT(name2)) 
	  => (dae,env')

  rule	not name = name2 &
	inst_class_in_program(env,cs,path) => (dae,env)
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_,_))::cs, path as Absyn.IDENT(name2)) 
	  => (dae, env)

  axiom	inst_class_in_program(env,[],_) => ([],env)
	
  rule	(*Debug.fprint("failtrace", "inst_class_in_program failed\n")*)
	-------------------------------
	inst_class_in_program(env,_,_) => fail

end

(** relation: inst_class_in_program_implicit
 **
 ** Instantitates a specifc class in a Program using implicit instatiation. 
 ** The class must reside on top level.
 **)

relation inst_class_in_program_implicit: (Env, SCode.Program, SCode.Path ) 
	  => (DAE.Element list, Env.Env) =

  rule	name = name2 &
	implicit_instantiation(env, Types.NOMOD, Prefix.NOPRE, [], c, [], false(*packimpl*)) 
	  => ( env',dae) 
	-------------------------------------------------------------
	inst_class_in_program_implicit(env,(c as SCode.CLASS(name,_,_,_,_))::cs,Absyn.IDENT(name2)) 
	  => (dae,env')

  rule	not name = name2 &
	inst_class_in_program_implicit(env,cs,path) => (dae,env)
	-------------------------------------------------------------
	inst_class_in_program_implicit(env,(c as SCode.CLASS(name,_,_,_,_))::cs, path as Absyn.IDENT(name2)) 
	  => (dae, env)

  axiom	inst_class_in_program_implicit(env,[],_) => ([],env)
	
  rule	(*Debug.fprint("failtrace", "inst_class_in_program failed\n")*)
	-------------------------------
	inst_class_in_program_implicit(env,_,_) => fail

end

(** relation: inst_class_decls
 **
 ** This relation instantiated class definitions, i.e. adding the class 
 ** definitions to the environment. See also partial_inst_class_in.
 **)

relation inst_class_decls:(Env, SCode.Program, SCode.Path) 
	  => ( Env.Env, DAE.Element list) =

  rule	not name = name2 &
	inst_class_decl(env, Types.NOMOD, Prefix.NOPRE, [], c, [], false(*packimpl*)) 
	  => (env', dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env'',dae)

  rule	name = name2 &      
	inst_class_decls(env,cs,ref) => (env', dae2)
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env',dae2)

  rule	name = name2 &      
	(* How should be do here ??? *)
	inst_class_decl(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false(*packimpl*)) 
	  => (env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae  
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.QUALIFIED(name2,_)) => (env'',dae)

  rule	not name = name2 &      
	inst_class_decl(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false(*packimpl*)) 
	  => (env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae  
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.QUALIFIED(name2,_)) => (env'',dae)

axiom	inst_class_decls(env,[],_) => (env,[])
	
  rule	print "inst_class_decls failed\n ref =" &
	Absyn.path_string ref => str &
	print str & print "\n" 
	--------------------
	inst_class_decls(_,_,ref) => fail
end

(** relation: make_env_from_program
 **
 ** This relation takes a `SCode.Program' and builds an environment, 
 ** excluding the class in A1.
**)

relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env = 
  rule	Builtin.initial_env => env &
	add_program_to_env(env,prog,c) => env'
	--------------------------------
	make_env_from_program (prog,c) => env'
end

(** relation: make_simple_env_from_program
 **
 ** Similar as to make_env_from_program, but not using the complete
 ** builtin environment, but a more simple one without the builtin operators.
 ** See Builtin.simple_initial_env.
 **)

relation make_simple_env_from_program: (SCode.Program,SCode.Path) => Env.Env = 
  rule	Builtin.simple_initial_env => env &
	add_program_to_env(env,prog,c) => env'
	--------------------------------
	make_simple_env_from_program (prog,c) => env'
end

(** relation: add_program_to_env
 **
 ** Adds all classes in a Program to the environment.
 **)

relation add_program_to_env: (Env.Env,SCode.Program,SCode.Path) => Env.Env =
  rule	inst_class_decls(env,p,path) => (env' ,_) 
	-----------------------------------------
	add_program_to_env (env,p,path) => env'
end


(** relation: inst_program
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'.
 ** This is used when calling the compiler with a Modelica source code file.
 ** It is not used in the interactive environment when instantiating a class.
 **)

relation inst_program : (Env, SCode.Program) => DAE.Element list =

  rule	Print.print_error_buf "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail


  rule	Debug.fprint ("insttr", "inst_program1: ") &
	Debug.fprint ("insttr", n) &
	Debug.fprintln ("insttr", "") &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_class(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false(*packimp*),TOP_CALL) 
	  => (dae,env',csets,_,_) 
	-----------------------------
	inst_program(env,[c as SCode.CLASS(n,_,_,_,_)])
	  => [DAE.COMP(n,DAE.DAE(dae))]

  rule	Debug.fprintln ("insttr", "inst_program2") &
	inst_class_decl(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false(*packimpl*)) 
	  => (env',dae1) &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_program(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	----------------------
	inst_program(env,c::(cs as (_::_))) => dae

  rule	Debug.fprintln("failtrace", "- inst_program failed")
	------------
	inst_program(_,_) => fail
end
(** relation: inst_program_implicit
 **
 ** Instantiates a program using implicit instantiation. 
 ** Used when instantiating functions.
 **)

relation inst_program_implicit : (Env, SCode.Program) 
	  => (DAE.Element list, Env) =
	
  rule	Debug.fprint ("insttr", "inst_program_implicit: ") &
	Debug.fprint ("insttr", n) &
	Debug.fprintln("insttr", "") &
	implicit_instantiation(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false(*packimpl*)) 
	  => (env', dae1) &
	inst_program_implicit(env',cs) => (dae2, env'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_program_implicit(env,(c as SCode.CLASS(n,_,_,restr,_))::cs) => (dae, env'')

  rule	Debug.fprintln ("insttr", "inst_program_implicit (end)")
	----------------------------------------------------
	 inst_program_implicit(env,[]) => ([], env)

end

(** relation: inst_class
 **
 ** Instantiation of a class can be either implicit or "normal". This 
 ** relation is used in both cases. When implicit instantiation is performed, 
 ** the last argument is true, otherwise it is false.
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class : (Env, Mod, Prefix, Connect.Sets, SCode.Class, 
		       InstDims,bool (*impl*) ,CallingScope)
	  => (DAE.Element list, Env.Env, Connect.Sets, 
	      Types.Type, ClassInf.State) =

	(* Classes with the keyword partial can not be instantiated.
	 They can only be inherited *)  
  rule	Print.print_error_buf "# Can't instantiate partial class " & 
	Print.print_error_buf n & Print.print_error_buf "\n"
	------------------------------------------------------	
	inst_class(env,mod,pre, csets, SCode.CLASS(n,partial as true,_,_,_),_,impl as false,_) => fail

  rule	Env.open_scope(env,encflag,SOME(n)) => env' &
	ClassInf.start(r,n) => ci_state &
	inst_class_in(env', mod, pre, csets, ci_state, c, false(*accesibility*), inst_dims, impl,false (*packimpl*))
	  => (dae1, env''', csets', ci_state', tys) &
	make_fully_qualified(env,Absyn.IDENT(n)) => fq_class &
	DAE.set_component_type(dae1,fq_class) => dae1' &
	is_top_call(callscope) => callscope' &  
	Connect.equations csets' => dae2 &
	Connect.unconnected_flow_equations (csets',dae1,env''', callscope') 
	  => dae3 &
	Util.list_flatten([dae1', dae2, dae3]) => dae &
	make_fully_qualified(env, Absyn.IDENT(n)) => typename &
	mktype(typename,ci_state',tys) => ty
	-------------------------------------------
	inst_class(env, mod, pre, csets, c as SCode.CLASS(n,_,encflag,r,_),inst_dims,impl,callscope)
	  => (dae, env''', [], ty, ci_state')

  rule	Debug.fprint("failtrace", "- inst_class ") & 
	Debug.fprint("failtrace",  n) &
	Debug.fprint("failtrace", " failed\n") 
	-----------------------------------------------------
	inst_class(_,_,_,_,SCode.CLASS(n,_,_,_,_),_,impl,_) => fail
	
end

(** relation: inst_class_in
 **
 ** This rule instantiates the contents of a class definition, with a
 ** new environment already setup.
 ** The next last boolean indicates if the class should be instantiated 
 ** implicit, i.e. without generating DAE.
 ** The last boolean is a even stronger indication of implicit instantiation,
 ** used when looking up variables in packages. This must be used because 
 ** generation of functions in implicit instanitation (according to next last 
 ** boolean) can cause circular dependencies (e.g. if a function uses a
 ** constant in its body) 
 **)

relation inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool (*Accesibility*), InstDims, 
			 bool, (*implicit instantiation*)
			 bool (* implicit function (ls:package?) instantiation *)
			 )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  axiom inst_class_in(env,mods,pre,csets,ci_state,
                      c as SCode.CLASS("Real",_,_,_,_),_,_, impl,packimpl)
          => ([] (* No DAE *), env, [], ci_state, [])
	  
  axiom inst_class_in(env,mods,pre,csets,ci_state,
                      c as SCode.CLASS("Integer",_,_,_,_),_,_, impl,packimpl)
          => ([] (* No DAE *), env, [], ci_state, [])
	  
  axiom inst_class_in(env,mods,pre,csets,ci_state,
                      c as SCode.CLASS("String",_,_,_,_),_,_, impl,packimpl)
          => ([] (* No DAE *), env, [], ci_state, [])
	  
 axiom inst_class_in(env,mods,pre,csets,ci_state,
                     c as SCode.CLASS("Boolean",_,_,_,_),_,_, impl,packimpl)
         => ([] (* No DAE *), env, [], ci_state, [])

	  (* Ignore functions if not implicit instantiation *)
  rule	SCode.is_function cls => true
	& Debug.fprint("insttr", "Ignoring function in explicit instantiation: ")
	& SCode.class_name cls => clsname
	& Debug.fprint("insttr", clsname) 
	& Debug.fprint("insttr", "\n") 
	-----------------------------
	inst_class_in(env,mods,pre,cset,ci_state, cls,_,_,impl as false,packimpl)
	=> ([] (* No DAE *), env, [], ci_state, [])

  rule	(*print "inst_class_in" & print n & print "\n" &*)
	SCode.class_name c => clsname
	& Debug.fprint("insttr", "Instantiating class: ")
	& Util.if(impl, " (implicit) ", " (explicit) ") => implstr
	& Debug.fprint("insttr", implstr)
	& Debug.fprint("insttr", clsname) 
	& Debug.fprint("insttr", "\n") &
	inst_classdef(env,mods,pre,csets,ci_state,d,r,prot,inst_dims,impl,packimpl)
	  => (l,env', csets', ci_state', tys)  
	-------------------------------------
	inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,_,r,d), prot, inst_dims,
		      impl,packimpl)
	  => (l,env', csets', ci_state', tys)

  rule  Debug.fprint("failtrace", "- inst_class_in failed\n")
	----------------------------------
	inst_class_in(_,_,_,csets,_,_,_,_,_,_) => fail

end

(** relation: partial_inst_class_in
**
** This relation is used when instantiating classes in lookup of other classes.
** The only work performed by this relation is to instantiate local classes and
** inherited classes.
**)

relation partial_inst_class_in: (Env, Mod, Prefix, Connect.Sets, 
				 ClassInf.State, SCode.Class, bool, InstDims)
	  => (Env, ClassInf.State) =

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("Real",_,_,_,_),_,_) 
	  => (env,ci_state)

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("Integer",_,_,_,_),_,_)
	  => (env,ci_state)

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("String",_,_,_,_),_,_)
	  => (env,ci_state)

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("Boolean",_,_,_,_),_,_)
	  => (env,ci_state)

  rule	partial_inst_classdef(env,mods,pre,csets,ci_state,d,r,prot,inst_dims)
	  => (env',ci_state') 
	-------------------------------------
	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,_,r,d), prot, inst_dims)
	  => (env',ci_state')
end

(** relation: inst_classdef
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 ** The last two arguments are the same as for inst_class_in: 
 ** implicit instantiation and implicit package/function instantiation
 **)

relation inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, SCode.Restriction, bool,InstDims,
			 bool (*implicit inst*), bool (* implicit package inst*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	component_elts(els) => compelts &
	extends_elts(els) => extendselts &
	
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,impl) => env1 &
	
	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	
	inst_extends_list(env1, mods, extendselts, ci_state,impl)
	  => (env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) &
	  (* Problem. Modifiers on inherited components are unelabed, loosing their 
	   type information. This will not work, since the modifier type can not always be found.
	   for instance. 
	   model B extends B2; end B; model B2 Integer ni=1; end B2;
	   model test
	   Integer n=2;
	   B b(ni=n);
	   end test;
	   The modifier (n=n) will be untypes when B is instantiated and the variable n can not be 
	   found, since the component b is instantiated in env of B.
	   Solution:
	   Redesign inst_extends_list to return (SCode.Element, Types.Mod) list and
	   convert other component elements to the same format, such that inst_element can 
	   handle the new format uniformely.
	   *)
	add_nomod(compelts) => compelts' &
	add_nomod(cdefelts) => cdefelts' &
	Util.list_flatten([extcomps,compelts',cdefelts']) => compelts' &	

	(* Add components from base classes to be instantiated in 3 as well. *)
	list_append(eqs,eqs2) => eqs' &
	list_append(initeqs,initeqs2) => initeqs' &
	list_append(alg,alg2) => alg' &
	list_append(initalg,initalg2) => initalg' &	

	(* Add variables to env, wihtout type and binding, *)
	(* which will be added later in inst_element_list  *)
	(* (where update_variable is called) *)
	add_components_to_env(env2,emods,pre,csets,ci_state,compelts',
			      compelts',eqs',inst_dims,impl) 
	  => env3 &
	  (* Update the modifiers of elements to typed ones, needed for modifiers
	   on components that are inherited. *)
	update_compelts_mods(env3,pre,compelts',ci_state,impl)  
	  => (compelts'',env4) &

	(*3. Instantiate components *)
	inst_element_list(env4, mods, pre, csets, ci_state1, compelts'', 
			  inst_dims, impl, packimpl)
	  => (dae1,env5, csets1, ci_state2, tys) &
	(* Instantiate equations *)
	  inst_list(env5,mods,pre,csets1,ci_state2,inst_equation, eqs',impl)
	  => (dae2,_,csets2, ci_state3) &
	inst_list(env5,mods,pre,csets2,ci_state3,inst_initialequation, initeqs',impl)
	  => (dae3,_,csets3, ci_state4) &
	  (* instantiate algorithms *)
	inst_list(env5,mods,pre,csets3,ci_state4, inst_algorithm, alg',impl)
	  => (dae4,_,csets4, ci_state5) &
	inst_list(env5,mods,pre,csets4,ci_state5, inst_initialalgorithm, initalg',impl)
	  => (dae5,_,csets5, ci_state6) &
	  (* collect the dae's *)
	Util.list_flatten([dae1,dae2,dae3,dae4,dae5]) => dae
	------------------------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims, impl, packimpl as false)
	  => (dae, env5, csets5, ci_state6, tys)

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &
	classdef_elts(els) => cdefelts &
	component_elts(els) => compelts &
	extends_elts(els) => extendselts &
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,impl) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	inst_extends_list(env1, mods, extendselts, ci_state, impl)
	  => (env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) &
		
	add_nomod(compelts) => compelts' &
	add_nomod(cdefelts) => cdefelts' &
	Util.list_flatten([extcomps,compelts',cdefelts']) => compelts' &

	(* Add components from base classes to be instantiated in 3 as well. *)
	list_append(eqs,eqs2) => eqs' &
	list_append(initeqs,initeqs2) => initeqs' &
	list_append(alg,alg2) => alg' &
	list_append(initalg,initalg2) => initalg' &
	
	(* Add variables to env, wihtout type and binding, *)
	(* which will be added later in inst_element_list  *)
	(* (where update_variable is called) *)
	add_components_to_env(env2,emods,pre,csets,ci_state,compelts',
			      compelts',eqs',inst_dims,impl) => env3 &

	(*3. Instantiate components *)
	inst_element_list(env3,mods,pre,csets,ci_state1, compelts', 
			  inst_dims, impl, true(*packimpl*))
	  => (dae1, env4, csets1, ci_state2, tys) 
	------------------------------------------------------
	inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims, impl, true(*packimpl*))
	  => (dae1, env4, csets1, ci_state2, tys)


	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Lookup.lookup_class(env,cn,true) 
	  => (c as SCode.CLASS(cn2,_,enc2,r,_), cenv) &
	Env.open_scope(cenv,enc2,SOME(cn2)) => cenv'' &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod,impl) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	(* merge modifiers *)
	Mod.merge(mods,m,cenv'',pre) => mods' &
	Mod.merge(mods',mod',cenv'',pre) => mods'' &
	(* instantate class in opened scope.*)
	inst_class_in(cenv'', mods'', pre, csets, new_ci_state, c,prot,inst_dims,impl,false(*packimpl*))
	  => (dae, env'', csets', ci_state', tys) &
	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims, impl, packimpl)
	  => (dae, env'', csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn,false) => (_,_) &
	Absyn.path_string(cn) => cns &
	Print.print_error_buf "# unknown class: " & 
	Print.print_error_buf cns & 
	Print.print_error_buf " in scope: " & 
	Env.print_env_path_str env => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n" 
	----------------------------------------
	inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims, impl, packimpl)
	  => fail
	
  rule	Debug.fprint("failtrace", "- inst_classdef failed\n")
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_,_,_,_) => fail

end	

(** relation: partial_inst_classdef
 **
 ** This relation is used by partial_inst_class_in for instantiating local
 ** class definitons and inherited class definitions only.
 **)

relation partial_inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, SCode.Restriction, bool,InstDims)
	  => ( Env, ClassInf.State ) =

  rule	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	extends_elts(els) => extendselts &
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,true) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	inst_extends_list(env1, mods, extendselts, ci_state, true)
	  => (env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) 
	------------------------------------------------------
	partial_inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims)
	  => (env2,ci_state1)


	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Lookup.lookup_class(env,cn,true) 
	  => (c as SCode.CLASS(cn2,_,enc2,r,_), cenv) &
	Env.open_scope(cenv,enc2,SOME(cn2)) => cenv'' &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod,false(* FIXME: impl*)) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	Mod.merge(mods,m,cenv'',pre) => mods' &
	Mod.merge(mods',mod',cenv'',pre) => mods'' &
	partial_inst_class_in(cenv'', mods'', pre, csets, new_ci_state, c,prot,inst_dims)
	  =>  (env'',new_ci_state')
	----------------------------------------
	partial_inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims)
	  => (env'',new_ci_state')

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn,false) => (_,_) &
	Absyn.path_string(cn) => cns &
	Print.print_error_buf "# unknown class: " & 
	Print.print_error_buf cns & 
	Print.print_error_buf " in scope: " & 
	Env.print_env_path_str env => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n" 
	----------------------------------------
	partial_inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims)
	  => fail
end	

(** relation: update_compelts_mods
 ** author: PA
 **
 ** This relation updates component modifiers to typed modifiers.
 ** Typed modifiers are needed  to merge modifiers and to be able to 
 ** fully instantiate a component.
 **)

relation update_compelts_mods: (Env.Env, Prefix.Prefix, 
				(SCode.Element*Types.Mod) list,
				ClassInf.State, bool (* impl *)) 
	=> ((SCode.Element * Types.Mod) list, Env.Env) =

  axiom	update_compelts_mods(env,pre,[],_,_) =>([],env)

  rule	Mod.unelab_mod(cmod) => umod &
	get_cref_from_mod(umod) => crefs &
	update_components_in_env(cmod,crefs,env,ci_state,impl) => env2 &
	Mod.update_mod(env2,pre,cmod,impl) => cmod' &
	update_compelts_mods(env2,pre,xs,ci_state,impl) => (res,env3)
	-------------------
	update_compelts_mods(env,pre,(comp,cmod)::xs,ci_state,impl) 
	  => ((comp,cmod')::res,env3)
end

(** relation: get_option_arraydim
 **
 ** Return the Arraydim of an optional arradim. Empty list returned if no 
 ** arraydim present.
 **)

relation get_option_arraydim: (Absyn.ArrayDim option) => Absyn.ArrayDim =

  axiom	get_option_arraydim (SOME(dim)) => dim

  axiom	get_option_arraydim (NONE) => []
end

(** relation: inst_extends_list 
 ** author: PA
 ** 
 ** This relation flattens out the inheritance structure of a class.
 ** It takes an SCode.Element list and flattens out the extends nodes
 ** of that list. The result is a list of components and lists of equations
 ** and algorithms.
**)
	    
 relation inst_extends_list:(Env.Env, Types.Mod, SCode.Element list, 
			     ClassInf.State, bool (* impl *))
	  => (Env.Env, Types.Mod, 
	      (SCode.Element * Types.Mod) list,  (* inherited components *)
	      SCode.Equation list,		 (* inherited equations *)
	      SCode.Equation list,		 (* inherited initial equations *)
	      SCode.Algorithm list,		 (* inherited algorithms *)
	      SCode.Algorithm list)		 (* inherited initial algorithms *)
	=
  rule	Lookup.lookup_class(env, tp, true) 
	  => (c as SCode.CLASS(cn,_,encf,r,_), cenv) &
	Mod.lookup_modification_p(mod, Absyn.IDENT(cn)) => outermod &
	inst_derived_classes(cenv, outermod, c, impl) =>
	  (cenv1, els, eq1, ieq1, alg1, ialg1) &
	make_fully_qualified(cenv1,tp) => tp' &
	(* Add the scope of the base class to elements*)
	add_inherit_scope(els,tp') => els' &
	add_eqn_inherit_scope(eq1,tp') => eq1' &
	add_eqn_inherit_scope(ieq1,tp') => ieq1' &
	add_alg_inherit_scope(alg1,tp') => alg1' &
	add_alg_inherit_scope(ialg1,tp') => ialg1' &
	Env.open_scope(cenv1,encf,SOME(cn)) => cenv3 &
	ClassInf.start(r, cn) => new_ci_state &
	Mod.elab_untyped_mod(emod,cenv3,Prefix.NOPRE) => mod' &
	Mod.merge(outermod,mod',cenv3,Prefix.NOPRE) => mod'' &

	 (* recurse to fully flatten extends elements *)
	inst_extends_list(cenv1(*env*), outermod, els', ci_state, impl) 
	  => (_,mods, compelts1, eq2, ieq2, alg2, ialg2) &  
	 
	  (* continue with next element in list *)
	inst_extends_list(env, mod, rest, ci_state,impl)
	  => (env2, mods', compelts2, eq3, ieq3, alg3, ialg3) & 
	(* corresponding elements. But emod is Absyn.Mod and can not  *)
	(* Must merge(mod,emod) here and then apply the bindings to the *)
	(* be elaborated, because for instance extends A(x=y) can reference *)
	(* a variable y defined in A and will thus not be found. *)
	(* On the other hand: A(n=4), n might be a structural parameter that must be set to *)
	(* instantiate A. How could this be solved? *)
	(* Solution: made new relation elab_untyped_mod which transforms *)
	(* to a Mod, but set the type information to unknown. *)
	(* We can then perform the merge, and update untyped modifications *)
	(* later (using update_mod), when we are instantiating the components. *)
	Mod.elab_untyped_mod(emod,env2,Prefix.NOPRE) => emod' &
	Mod.merge(mod,mods',env2,Prefix.NOPRE) => mod' &
	Mod.merge(mod',emod',env2,Prefix.NOPRE) => mods' &
	list_append(compelts1, compelts2) => compelts &	

				      
	(* update components with new merged modifiers *)
	update_components(compelts,mods',env2) => compelts3 &
        Util.list_flatten([eq1', eq2, eq3]) => eq &
	Util.list_flatten([ieq1', ieq2, ieq3]) => ieq &
	Util.list_flatten([alg1', alg2, alg3]) => alg &
	Util.list_flatten([ialg1', ialg2,ialg3]) => ialg 
	-----------------------------------
	inst_extends_list(env, mod, SCode.EXTENDS(tp,emod)::rest, ci_state,impl)
	  => (env2, mods',compelts3, eq, ieq, alg, ialg)

	(* base class not found *)				
  rule	not Lookup.lookup_class(env, tp, true) 
	  => (c as SCode.CLASS(cn,_,encf,r,_), cenv) &
	Print.print_error_buf "#Error, base class " &
	Absyn.path_string(tp) => s &
	Print.print_error_buf s &			      
	Print.print_error_buf " not found.\n" 			      
 	  ------------------------------------------------
	inst_extends_list(env, mod, SCode.EXTENDS(tp,emod)::rest, ci_state, impl) 
	  => fail
  rule	Debug.fprint("failtrace", "Failed inst_extends_list on EXTENDS\n env:") &
	Env.print_env env 			      
	------------------------------------------------
	inst_extends_list(env, mod, SCode.EXTENDS(tp,emod)::rest, ci_state, impl) 
	  => fail
	(* Components that are not EXTENDS *)
  rule	inst_extends_list(env, mod, rest, ci_state, impl)
	  => (env', mods, compelts2, eq2, initeq2, alg2, ialg2) 
	------------------------------------------------
	inst_extends_list(env, mod, elt::rest, ci_state, impl) 
	  => (env',mods, (elt,Types.NOMOD)::compelts2, eq2, initeq2, alg2, ialg2) 

  axiom	inst_extends_list(env, mod, [], ci_state, impl) 
	  => (env, mod, [], [], [], [], [])

  rule	Debug.fprint("failtrace",  "- inst_extends_list failed\n" )
	---------------------
	inst_extends_list(_,_,_,_,_) => fail
end

(** relation: add_inherit_scope
 ** author: PA
 **
 ** Adds the optional base class in a SCode.COMPONENTS to indicate which base 
 ** class the component originates from. This is needed in instantiation to 
 ** be able to look up classes, etc. from the scope where the component is 
 ** defined.
 **)

relation add_inherit_scope: ( SCode.Element list, Absyn.Path) 
	  => SCode.Element list =

  axiom	add_inherit_scope ([],_) => []

  rule	add_inherit_scope(xs,tp) => res
	-------------------------------
	add_inherit_scope(SCode.COMPONENT(a,b,c,d,e,f,g,_,comment)::xs,tp)
	  => SCode.COMPONENT(a,b,c,d,e,f,g,SOME(tp),comment)::res

  rule	add_inherit_scope(xs,tp) => res
	-------------------------------
	add_inherit_scope(SCode.CLASSDEF(a,b,c,d,_)::xs,tp)
	  => SCode.CLASSDEF(a,b,c,d,SOME(tp))::res

  rule	add_inherit_scope(xs,tp) => res
	-------------------------------
	add_inherit_scope(x::xs,tp)
	  => x::res

  rule	print "add_inherit_scope failed\n" 
	------------------
	add_inherit_scope(_,_) => fail
end

(** relation: add_eqn_inherit_scope
 ** author: PA
 **
 ** Adds the optional base class in a SCode.EQUATION to indicate which 
 ** base class the equation originates from. This is needed in instantiation
 ** to be able to look up e.g. constants, etc. from the scope where the 
 ** equation  is defined.
 **)

relation add_eqn_inherit_scope: ( SCode.Equation list, Absyn.Path) 
	  => SCode.Equation list =

  axiom	add_eqn_inherit_scope ([],_) => []

  rule	add_eqn_inherit_scope(xs,tp) => res
	-------------------------------------
	add_eqn_inherit_scope(SCode.EQUATION(e,_)::xs,tp)
	  => SCode.EQUATION(e,SOME(tp))::res
end

(** relation: add_alg_inherit_scope
 ** author: PA
 **
 ** Adds the optional base class in a SCode.Algorithm to indicate which 
 ** base class the algorithm originates from. This is needed in instantiation
 ** to be able to look up e.g. constants, etc. from the scope where the 
 ** algorithm is defined.
 **)

relation add_alg_inherit_scope: ( SCode.Algorithm list, Absyn.Path) 
	  => SCode.Algorithm list =

  axiom	add_alg_inherit_scope ([],_) => []

  rule	add_alg_inherit_scope(xs,tp) => res
	-------------------------------------
	add_alg_inherit_scope(SCode.ALGORITHM(a,_)::xs,tp)
	  => SCode.ALGORITHM(a,SOME(tp))::res
end

(** relation: add_nomod 
 **
 ** This relation takes an SCode.Element list and tranforms it into a 
 ** (SCode.Element* Types.Mod) list by inserting Types.NOMOD for each element.
 ** Used to transform elements into a uniform list 
 ** combined from inherited elements and ordinary elements.
 **)

relation add_nomod: SCode.Element list => (SCode.Element*Types.Mod) list =

  axiom	add_nomod [] => []

  rule	add_nomod(xs) => res 
	--------------------
	add_nomod(x::xs) => ((x,Types.NOMOD)::res)
end

(** relation: update_components
 ** author: PA
 **
 ** This relation takes a list of components and a Mod and returns a list of
 ** components  with the modifiers updated.  The relation is used when 
 ** flattening the inheritance structure, resulting in a list of components 
 ** to insert into the class definition. For instance 
 ** model A 
 **   extends B(modifiers) 
 ** end A; 
 ** will result in a list of components 
 ** from B for which 'modifiers' should be applied to.
 **)

relation update_components: ((SCode.Element*Types.Mod) list, Types.Mod,Env.Env)
	  => (SCode.Element*Types.Mod) list =

  axiom	update_components([],_,_) => []

  rule 	Mod.lookup_comp_modification(mod,id) => cmod2 &
	Mod.merge(cmod,cmod2,env,Prefix.NOPRE) => mod' &
	update_components(xs,mod,env) => res 
	--------------------------------
	update_components((comp as SCode.COMPONENT(id,_,_,_,_,_,_,_,_),cmod)::xs,mod,env) 
	  => ((comp,mod')::res)

  rule	update_components(xs,mod,env) => res 
	--------------------------------
	update_components(((c as SCode.EXTENDS(_,_)),emod)::xs,mod,env) 
	  => ((c,emod)::res)

  rule	update_components(xs,mod,env) => res 
	--------------------------------
	update_components(((c as SCode.CLASSDEF(_,_,_,_,_)),cmod)::xs,mod,env) 
	  => ((c,cmod)::res)

  rule	update_components(xs,mod,env) => res 
	--------------------------------
	update_components(((c as SCode.IMPORT(_)),_)::xs,mod,env) 
	  => ((c,Types.NOMOD)::res)

  rule	Debug.fprint("failtrace", "-update_components failed\n")
	----------------------
	update_components(_,_,_) => fail
end

(** relation: no_import_elements
 **
 ** Returns all elements except imports, i.e. filter out import elements.
 **)

relation no_import_elements: SCode.Element list => SCode.Element list =

  axiom no_import_elements [] => []

  rule  no_import_elements rest => elt 
        ------------------------------
        no_import_elements SCode.IMPORT(_)::rest => elt

  rule  no_import_elements rest => elt
        ------------------------------
        no_import_elements e::rest => e::elt

end

(** relation: inst_derived_classes
 ** author: PA
 ** 
 ** This relation takes a class definition and returns the
 ** elements and equations and algorithms of the class.
 ** If the class is derived, the class is looked up and the 
 ** derived class parts are fetched.
 **)

relation inst_derived_classes: 	(Env.Env, Types.Mod, SCode.Class, bool) =>
	  (Env.Env, SCode.Element list, SCode.Equation list, 
	   SCode.Equation list, SCode.Algorithm list, SCode.Algorithm list) =
	
  rule   no_import_elements elt => elt' 
         ------------------------------
         inst_derived_classes(env,mod,SCode.CLASS(_,_,_,_,SCode.PARTS(elt,eq,ieq,alg,ialg,_)),_) => (env,elt',eq,ieq,alg,ialg)

  rule	Lookup.lookup_class(env,tp,true) => (c,cenv) &
	(* Mod.lookup_modification_p(mod, c) => innermod & *)
	(* We have to merge and apply modifications as well! *)
	inst_derived_classes(cenv, mod, c, impl) 
	  => (env, elt, eq, ieq, alg, ialg)
	-------------------------------------
	inst_derived_classes(env, mod, SCode.CLASS(_,_,_,_,SCode.DERIVED(tp,_,dmod)),impl) 
	  => (env, elt, eq, ieq, alg, ialg) 

  rule	Debug.fprint("failtrace", "- inst_derived_classes failed\n")
	----------------------
	inst_derived_classes(_,_,_,_) => fail
end


(** relation: inst_element_list
 ** author: PA
 **
 ** Moved to inst_classdef, FIXME: Move commments later
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 ** P.A, Modelica1.4: (allows declare before use)
 ** 1. "First names of declared local classes (and components) are found. 
 **     Redeclarations are performed."
 ** This means that we first handle all CLASSDEF nodes and apply modifiers and 
 ** declarations to them and also COMPONENT nodes to add the variables to the
 ** environment.
 ** 2. Second, "base-classes are looked up, flattened and inserted into the 
 **            class."
 ** This means that all EXTENDS nodes are handled.
 ** 3. Third, "Flatten the class, apply modifiers and instantiate all local
 **	    elements."
 ** This handles COMPONENT nodes.
 **)

relation inst_element_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			    (SCode.Element*Types.Mod) list, InstDims, bool(*impl*), bool(*packimpl*))
	    => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
		Types.Var list) =
	
  axiom	inst_element_list(env,_,_,csets,ci_state,[],_,_,_)
	    => ([], env, csets, ci_state, [])

	(* most work done in inst_element. *)
  rule  inst_element(env,mod,pre,csets,ci_state,el,inst_dims,impl, packimpl)
	  => (dae1,env',csets',ci_state',tys1) &
	inst_element_list(env',mod,pre,csets',ci_state',els,inst_dims,impl,packimpl)
	  => (dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae 
	------------------------------
	inst_element_list(env, mod, pre, csets, ci_state, el::els, inst_dims, impl, packimpl)
	  => (dae, env'', csets'', ci_state'', tys)

  rule	Debug.fprint("failtrace", "- inst_element_list failed\n")
	------------------------------------
	inst_element_list(_,_,_,_,_,els,_,_,_) => fail
end

(** relation: classdef_elts
 ** author: PA
 **
 ** This relation filters out the class definitions of an Element list.
 **)

relation classdef_elts: (SCode.Element list) => (SCode.Element list) =

  axiom classdef_elts ([]) => []
	
  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts ((cdef as SCode.CLASSDEF(_,_,_,_,_))::xs) => cdef::res

  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts((imp as SCode.IMPORT(_))::xs) => imp::res

  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts(_::xs) => res
end

(** relation: extends_elts
 ** author: PA
 **
 ** This relation filters out the extends Element's in an Element list
 **)

relation extends_elts: (SCode.Element list) => (SCode.Element list) =

  axiom extends_elts ([]) => []
	
  rule	extends_elts(xs) => res
	------------------------
	extends_elts ((cdef as SCode.EXTENDS(_,_))::xs) => cdef::res

  rule	extends_elts(xs) => res
	------------------------
	extends_elts(_::xs) => res
end

(** relation: component_elts
 ** author: PA
 **
 ** This relation filters out the component Element's in an Element list
 **)
		 
relation component_elts: (SCode.Element list) => (SCode.Element list) =

  axiom component_elts ([]) => []
	
  rule	component_elts(xs) => res
	------------------------
	component_elts ((cdef as SCode.COMPONENT(_,_,_,_,_,_,_,_,_))::xs) => cdef::res

  rule	component_elts(xs) => res
	------------------------
	component_elts(_::xs) => res
end

(** relation: add_classdefs_to_env
 ** author: PA
 **
 ** This relation adds classdefinitions and import statements to the 
 ** environment.
 **)

relation add_classdefs_to_env : (Env, SCode.Element list, bool) => (Env) =

  axiom	add_classdefs_to_env(env,[],_) => env

  rule	Env.extend_frame_c(env,cl) => env' &
	add_classdefs_to_env(env',xs,impl) => env''
	------------------
	add_classdefs_to_env(env,(SCode.CLASSDEF(_,_,_,cl,_))::xs,impl) => env''

  rule	Env.extend_frame_i(env,imp) => env' &
	add_classdefs_to_env(env',xs,impl) => env''
	-------------------------
	add_classdefs_to_env(env,(SCode.IMPORT(imp))::xs,impl) => env''
end  


(** relation: is_structural_parameter
 ** author: PA
 **
 ** This relation investigates a component to find out if it is a structural 
 ** parameter.
 ** This is achieved by looking at the restriction to find if it is a parameter
 ** and by investigating all components to find it is used in array dimensions 
 ** of the component. A parameter can also be structural if is is used
 ** in an if equation with different number of equations in each branch.
 **)

relation is_structural_parameter: (SCode.Variability, (* components variability*)
				   Absyn.ComponentRef, (* component name *)
				   (SCode.Element*Types.Mod) list, (* all elements *)		 
				   SCode.Equation list) (* equations *)
	=> bool =

	  (* constants does not need to be checked. 
	   Must return false here to prevent constants from be outputed
	   as structural parameters, i.e. "parameter" in DAE, which is 
	   incorrect
	   *)
  axiom	is_structural_parameter(SCode.CONST,_,_,_) => false

	(* Check if structural:
	 1. By investigating array dimensions.
	 2. By investigating if-equations.
	 *)
  rule	SCode.is_parameter_or_const param => true &
	get_crefs_from_compdims(allcomps) => crefs &
	member_crefs(compname,crefs) => b1 &
	is_structural_if_equation_parameter(compname,eqns) => b2 &
	bool_or(b1,b2) => res
	-----------------------------------
	is_structural_parameter(param,compname,allcomps,eqns) => res

  axiom	is_structural_parameter(_,_,_,_) => false
end

(** relation is_structural_if_equation_parameter
 ** author: PA
 **
 ** This relation checks if a parameter is structural because it is present
 ** in the condition expression of an if equation.
**)

relation is_structural_if_equation_parameter: (Absyn.ComponentRef, 
					       SCode.Equation list)
	=> bool =

  axiom	is_structural_if_equation_parameter(_,[]) => false

  rule	Absyn.get_cref_from_exp(cond) => crefs &
	member_crefs(compname,crefs) => true
	----------------------------
	is_structural_if_equation_parameter(compname,
					    SCode.EQUATION(SCode.EQ_IF(cond,_,_),
							   _)::_)
	  => true

  rule	is_structural_if_equation_parameter(compname,eqns) => res
	----------------------------
	is_structural_if_equation_parameter(compname,_::eqns) => res

end

(** relation: add_components_to_env
 ** author: PA
 **
 ** Since Modelica has removed the declare before use limitation, all 
 ** components are intially added untyped to the environment, i.e. the 
 ** SCode.Element is added. This is performed by this relation. Later, 
 ** during the second pass of the instantiation of components, the components 
 ** are updated  in the environment. This is done by the relation 
 ** update_components_in_env. This relation is also responsible for 
 ** changing parameters into structural  parameters if they are affecting 
 ** the number of variables or equations. This is needed because Modelica has
 ** no language construct for structural parameters, i.e. they must be 
 ** detected by the compiler.
 **
 ** Structural parameters are identified by investigating array dimension 
 ** sizes of components and by investigating if-equations. If an if-equation
 ** has a boolean expression controlled by parameter(s), these are structural
 ** parameters.
**)

relation add_components_to_env : (Env, Mod, Prefix, Connect.Sets, 
				  ClassInf.State,
				  (SCode.Element*Types.Mod) list, (* iterated list of elements*)
				  (SCode.Element*Types.Mod) list, (* all elements *)
				  SCode.Equation list, (* equations *)
				  InstDims, 
				  bool (* implicit inst. *))
	=> (Env) =

  axiom	add_components_to_env(env,_,_,_,_,[],_,_,_,_) => env 

  	(* Check if the component is a structural parameter, change it's
	 attribute to STRUCTPARAM. *)
  rule	not ClassInf.is_function(cistate) &  (* Functions not considered *)
	int_eq(1,0) => true & 
	is_structural_parameter(param,Absyn.CREF_IDENT(n,[]),allcomps,eqns) 
	  => true &
	add_components_to_env2(env,mod,pre,csets,
			       cistate,[(SCode.COMPONENT(n,final,repl,prot,
							 SCode.ATTR(ad,flow,acc,SCode.STRUCTPARAM,dir),t,m,bc,comment),cmod)],instdims,impl) => env' &
	add_components_to_env(env',mod,pre,csets,cistate,xs,allcomps,eqns,instdims,impl) => env''
	-----------------------------------------------------------------------
	add_components_to_env (env, mod, pre, csets, cistate, 
			       ((comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc,comment)),cmod)::xs, allcomps,
			       eqns,instdims,impl) => env''

	(* Not structural parameter. No Change.*)
  rule	add_components_to_env2(env,mod,pre,csets,cistate,[(SCode.COMPONENT(n,final,repl,prot,
									   SCode.ATTR(ad,flow,acc,param,dir),t,m,bc,comment),cmod)],instdims,impl) => env' &
	
	add_components_to_env(env',mod,pre,csets,cistate,xs,allcomps,eqns,instdims,impl) => env''
	-----------------------------------------------------------------------
	add_components_to_env (env, mod, pre, csets, cistate, 
			       ((comp as SCode.COMPONENT(n,final,repl,prot,
							 attr as SCode.ATTR(ad,flow,acc,param,dir),
							 t,m,bc,comment)),cmod)::xs, allcomps,
			       eqns,instdims,impl) => env''
	
	(* Import statements *)
  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,eqns,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			      ((SCode.IMPORT(_),_))::xs, allcomps,
			      eqns,instdims,impl) => env''
	
	(* Extends elements*)
  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,eqns,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			      ((SCode.EXTENDS(_,_),_))::xs, allcomps,
			      eqns,instdims,impl) => env''
	(* Class definitions *)
  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,eqns,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			      ((SCode.CLASSDEF(_,_,_,_,_),_))::xs, allcomps,
			      eqns,instdims,impl) => env''
	
  rule	Debug.fprint("failtrace", "- add_components_to_env failed\n" ) 
	-------------------------------------
	add_components_to_env(_,_,_,_,_,comps,_,_,_,_) => fail
end

(** relation add_components_to_env2
 ** Helper relation to add_components_to_env. Extends the environment with an 
 ** untyped variable for the component.
 **)
relation add_components_to_env2 : (Env, Mod, Prefix, Connect.Sets, 
				   ClassInf.State,
				   (SCode.Element*Types.Mod) list, 
				   InstDims, bool (* impl *))
	    => (Env) =

  rule	(** PA: PROBLEM, Modifiers should be merged in this phase, but
	   since undeclared components can not be found (is done in this phase)
	   the modifiers can not be elaborated to get a variable binding.
	   Thus, we need to store the merged modifier for elaboration in the 
	   next stage. 
	   Solution: Save all modifiers in environment...
	   **)	

	(** Use type T_NOTYPE instead of as earier trying to instantiate, 
	 ** since instanitation might fail without having correct 
	 ** modifications, e.g. when instanitating a partial class that must
	 ** be redeclared through a modification
	 **)
	Mod.lookup_comp_modification(mods,n) => compmod &
	Mod.merge(compmod,cmod,env,pre) => cmod' &
	Env.extend_frame_v(env,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
	    prot,(Types.T_NOTYPE,NONE),Types.UNBOUND),SOME((comp,cmod')),
			   false,[] (* comp env *)) => env' & 
	add_components_to_env2(env',mods,pre,csets,ci_state,xs,inst_dims,impl) 
	  => env'' 
	-----------------
	add_components_to_env2(env,mods,pre,csets,ci_state,
		     ((comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc,comment),cmod))::xs,inst_dims,impl) => env''

  axiom	add_components_to_env2(env,_,_,_,_,[],_,_) => env

  rule	Debug.fprint("failtrace", "- add_components_to_env2 failed\n") &
	Debug.fprint("failtrace", "\n\n") 
	--------------------
	add_components_to_env2(env,_,_,_,_,comps,_,_) => fail 
end

(** relation: get_crefs_from_compdims
 ** author: PA
 **
 ** This relation collects all variables from the dimensionalities of 
 ** component elements. These variables are candidates for structural 
 ** parameters.
 **)

relation get_crefs_from_compdims: ((SCode.Element*Types.Mod) list) 
	  => Absyn.ComponentRef list =

  axiom	get_crefs_from_compdims([]) => []
	
  rule	get_cref_from_dim(arraydim) => crefs1 &
	get_crefs_from_compdims(xs) => crefs2 &
	list_append(crefs1,crefs2) => crefs
	------------------------------------
	get_crefs_from_compdims((SCode.COMPONENT(_,_,_,_,SCode.ATTR(arraydim,_,_,_,_),_,_,_,_),_)::xs)
	  => crefs

  rule	get_crefs_from_compdims(xs) => crefs
	------------------------------------
	get_crefs_from_compdims(_::xs) => crefs
end

(** relation member_cref
 ** author: PA
 **
 ** This relation checks if a componentreferece is a member of a list of 
 ** component references, disregarding subscripts.
 **)

relation member_crefs: (Absyn.ComponentRef, Absyn.ComponentRef list) => bool =

  rule	Absyn.cref_equal(cr,cr1) => true
	-------------------
	member_crefs(cr,cr1::xs) => true

  rule	Absyn.cref_equal(cr,cr1) => false &
	member_crefs(cr,xs) => res
	-------------------
	member_crefs(cr,cr1::xs) => res

  axiom	member_crefs(_,_) => false

end

(** relation: inst_element
 **
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 ** Last two bools are implicit instanitation and implicit package instantiation
 **)

relation inst_element : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 (SCode.Element*Types.Mod), InstDims, bool, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** imports
	   ** imports are simply added to the current frame, so that the lookup rule can find them.
	   **)

	(** Import have allready been added to the environment so there 
	 ** is nothing more to do here.
	 **)
axiom	inst_element(env, mod, pre, csets, ci_state, (SCode.IMPORT(imp),_), instdims,_,_) 
	  => ([], env, csets, ci_state, [])
		 
	(* If a variable is declared multiple times, the first is used *)
  rule	Lookup.lookup_ident_local(env,n) => (_,NONE,true,_) 
	-------------------------------------
	inst_element(env, mods, pre, csets, ci_state,
		     (SCode.COMPONENT(n,final,repl,prot,_,_,_,_,_),_),_,_,_)
	  => ([], env, csets, ci_state, []) 

  	  (* Illegal redeclarations *)
  rule	Lookup.lookup_ident_local(env,n) => (_,_,_,_) &
	Print.print_error_buf "# Trying to redeclare the class " & 
	Print.print_error_buf n &
	Print.print_error_buf " as a variable\n" 
	------------------------
	inst_element(env, mods, pre, csets, ci_state,
		     (SCode.CLASSDEF(n,_,_,_,_),_),_,_,_)
 	  => fail 
	  
          (**  A new class definition
	   **
	   ** Put it in the current frame in the environment
	   **)

  rule	(* Redeclare of class definition, replaceable is true *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Types.REDECL(final, [(SCode.CLASSDEF(n2,f2,repl2,cls2,_),_)])) &
	(*Debug.fprintln ("insttr", "*--*Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "*--*All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &*)
	inst_class_decl(env, classmod, pre, csets, cls2, inst_dims, packimpl)
	  => (env', dae)
	-------------------------------------------------
	inst_element(env, mods, pre, csets, ci_state, 
		     (SCode.CLASSDEF(n,_,true,c,_),_), inst_dims, impl, packimpl)
	  => (dae, env', csets, ci_state, [])

  rule	(* Redeclare of class definition, replaceable is false *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Types.REDECL(final, [(SCode.CLASSDEF(n2,f2,repl2,cls2,_),_)])) &
	Print.print_error_buf "# Trying to redeclare class " 
	& Print.print_error_buf n &
	Print.print_error_buf " but class not declared as replacable.\n" 
	-------------------------------------------------
	inst_element(env, mods, pre, csets, ci_state, 
		     (SCode.CLASSDEF(n,_,false,c,_),_),inst_dims,impl,packimpl)
	  => fail
	  (* Classdefinition without redeclaration *)
  rule	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) => classmod &
	(*Debug.fprintln ("insttr", "**Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "**All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &*)
	inst_class_decl(env,classmod,pre,csets,c,inst_dims,packimpl) 
	  => (env',dae)
	-------------------------------------------------------
	inst_element(env, mods, pre, csets, ci_state, 
		     (SCode.CLASSDEF(n,_,_,c,_),_),inst_dims,impl,packimpl)
	  => (dae, env', csets, ci_state, []) 
	  
	  (**  A component
	   **
	   ** This is the rule for instantiating a model component.  A
	   ** component can be a structured subcomponent or a variable,
	   ** parameter or constant.  All of these are treated in a
	   ** similar way.
	   **
	   ** Lookup the class name, apply modifications and add the
	   ** variable to the current frame in the environment. Then
	   ** instantiate the class with an extended prefix.
	   **)
	
  rule	(*Debug.fprint("insttr", "Instantiating component ") &
	Debug.fprint("insttr", n) & Debug.fprint("insttr", "\n") &*)
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &
	
	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation_ is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)
	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	(* The types in the environment does not have correct Binding.
	   We must update those variables that is found in m into a new environment.*)
	let owncref = Absyn.CREF_IDENT(n,[]) &

	get_cref_from_mod(m) => crefs &
 	get_cref_from_dim(ad) => crefs2 &
	Util.list_flatten([crefs,crefs2]) => crefs' &
	remove_cref_from_crefs(crefs',owncref) => crefs'' &

	get_derived_env(env,bc) => env &
	update_components_in_env(mods,crefs'',env,ci_state,impl) => env2 &

	(* Update the untyped modifiers to typed ones, and extract class *)
	(* and component modifiers again.*)
	Mod.update_mod(env2,pre,mods,impl) => mods' &


	(* refetch the component from environment, since attributes, etc.
	 ** might have changed.. comp used in redeclare_type below... *)
	Lookup.lookup_ident_local(env2,n) => (_,SOME((comp,_)),_,_) & 

	Mod.lookup_modification_p(mods',t) => classmod' &
	Mod.lookup_comp_modification(mods',n) => mm' &


	Mod.elab_mod(env2,pre,m,impl) => m' &


	Mod.merge(classmod',mm',env2,pre) => mod &
 	Mod.merge(mod,m',env2,pre) => mod1 &
	Mod.merge(cmod,mod1,env2,pre) => mod1' &

	redeclare_type(mod1',comp,env2,pre,ci_state,impl) 
	  => (SCode.COMPONENT(n,final,repl,prot,
			      attr as SCode.ATTR(ad,flow,acc,param,dir),
			      t,m,bc,comment),mod',env2') &
	
	
	get_derived_env(env,bc) => env' &
	Lookup.lookup_class(env',t,true) => (cl,cenv) & 
	
	
	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm', vn) &

	Mod.mod_equation mod' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	
	elab_arraydim(env2',owncref,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(cenv,ci_state, mod', pre, csets, n, cl, attr, dims, [], inst_dims, impl,comment)
	  => (compenv, dae, csets', ty) &
	(** The environment is extended (updated) with the new variable 
	 ** binding. 
	 **)

	make_binding (env2',attr,mod') => binding &
	(* true in update_frame means the variable is now instantiated. *)
	
	let new_var = Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding) &
     
	Env.update_frame_v(env2',new_var,
			   true,(*type info present*)
			   compenv) => env' 
	(* Now we can also put the binding into the dae *)
	(** If the type is one of the simple, predifined types a *)
	(** simple variable declaration is added to the DAE. *)
					       
	(* & Debug.fprint("insttr","inst_element Component succeeded\n") *)
	-----------------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     (comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc,comment),cmod),inst_dims,impl,packimpl)
          => (dae, env',csets',ci_state,
	      [Types.VAR(n,Types.ATTR(flow,acc,param,dir), prot, ty, binding)])
	

	(** If the class lookup in the previous rule fails, this
	 ** rule catches the error and prints an error message about
	 ** the unknown class. 
	 **)

	(**  Failure *)
  rule	not Lookup.lookup_class(env,t,false) => (cl,cenv) &
	Absyn.path_string(t) => s &
	Print.print_error_buf "# unknown class '" 
	& Print.print_error_buf s &
	Print.print_error_buf "' while instantiating " &
	Prefix.prefix_add(n,[],pre) => pre' &
	Prefix.print_prefix_str pre' => ns &
	Print.print_error_buf ns & Print.print_error_buf "\n" 
(*	Debug.fcall ("instdb", Env.print_env, env) *)
	--------------------------
	inst_element(env,_,pre,csets,ci_state,
		     (SCode.COMPONENT(n,final,repl,prot,_,t,_,_,_),_),_,_,_)
(*         => ([],env,csets,ci_state,[]) *) => fail

  rule	Debug.fprint("failtrace", "- inst_element failed\n") &
	Debug.fcall("failtrace",SCode.print_element, el) &
	Debug.fprint("failtrace", "\n") 
	-----------------------------------------------------------------
	inst_element(env,omod,_,_,_,(el,mod),_,_,_) => fail 

end	

(** relation: get_derived_env
 **
 ** This relation returns the environment of a baseclass.
 ** It is used when instantiating a component defined in a baseclass.
**)

relation get_derived_env: (Env.Env, Absyn.Path option) => Env.Env =

  axiom	get_derived_env(env,NONE) => env

  rule	Lookup.lookup_class(env,tp,true) => (_,env') 
	---------------------------------------
	get_derived_env(env as (Env.FRAME(id,cl,tps,imps,_,enc)::fs),SOME(tp)) 
	  => Env.FRAME(id,cl,tps,imps,env',enc)::fs
end

(** relation: remove_cref_from_crefs
 **
 ** Removes a variable from a variable list
 **)

relation remove_cref_from_crefs : (Absyn.ComponentRef list, Absyn.ComponentRef)
	  => Absyn.ComponentRef list =

  axiom	remove_cref_from_crefs ([],_) => []

  rule	let Absyn.CREF_IDENT(n1,[]) = cr1 &
	let Absyn.CREF_IDENT(n2,[]) = cr2 &
	n1 = n2 &
	remove_cref_from_crefs (rest, cr2) => rest'
	------------------------------------------
	remove_cref_from_crefs (cr1::rest, cr2) => rest'

  rule	remove_cref_from_crefs (rest, cr2) => rest'
	------------------------------------------
	remove_cref_from_crefs (cr1::rest, cr2) => cr1::rest'


end

(** relation: redeclare_type
 **
 ** This relation takes a 'Mod' and an SCode.Element and if the modification 
 ** contains a redeclare of that element, the type is changed and an updated
 ** element is returned
**)

relation redeclare_type: (Types.Mod, 
			  SCode.Element,
			  Env.Env,
			  Prefix.Prefix,
			  ClassInf.State,
			  bool (* Implicit instantation *)) 
	  => (SCode.Element,Types.Mod,Env.Env) =

  rule	n1=n2 &
	get_cref_from_mod(mod) => crefs &
	update_components_in_env(Types.NOMOD (* m *),crefs,env,ci_state,impl) => env' &
	Mod.elab_mod(env',pre,mod,impl) => m' &
	Mod.elab_mod(env',pre,old_mod,impl) => old_m' &
	Mod.merge(rmod,m',env',pre) => m'' &
	Mod.merge(m'',old_m',env',pre) => m''' 
	--------------------------------
	redeclare_type ((m as Types.REDECL(_,((redecl as SCode.COMPONENT(n1,final,repl,prot,_,t,mod,bc,comment)),rmod)::rest)),
			SCode.COMPONENT(n2,false,repl2,prot2,_,t2,old_mod,_,_),env,pre,ci_state,impl) => (redecl,m''',env')

  rule	not n1=n2 &
	redeclare_type(Types.REDECL(redfin,rest),comp,env,pre,ci_state,impl) 
	  => (newcomp,mod,env')
	  -------------
	redeclare_type (mod as Types.REDECL(redfin,
                                            ((redecl as SCode.COMPONENT(n1,final,repl,prot,_,t,_,bc,comment)),
                                             rmod)::rest),
			comp as SCode.COMPONENT(n2,false,repl2,prot2,_,t2,_,_,comment2),env,pre,ci_state,impl)
	  => (newcomp,mod,env')

  rule	redeclare_type(Types.REDECL(redfin,rest),comp,env,pre,ci_state,impl) 
	  => (newcomp,mod,env')
	  ----------------------------
	redeclare_type(Types.REDECL(redfin,_::rest),comp,env,pre,ci_state,impl) 
	  =>(newcomp,mod,env')

  axiom	redeclare_type(Types.REDECL(redfin,[]),comp,env,pre,ci_state,impl) => (comp,Types.NOMOD,env)

  axiom redeclare_type(mod,comp,env,pre,ci_state,impl) => (comp,mod,env)

  rule	Debug.fprint("failtrace", "- redeclare_type failed\n")
	------------------------------------------------------
	redeclare_type(_,_,_,_,_,_) => fail
end


(** relation: inst_var
 **
 ** A component element in a class may consist of several subcomponents
 ** or array elements.  This relation is used to instantiate a
 ** component, instantiating all subcomponents and array elements
 ** separately.
 ** P.A: Most of the implementation is moved to inst_var2. inst_var collects 
 ** dimensions for userdefined types, such that these can be correctly 
 ** handled by inst_var2 (using inst_array)
 **)

relation inst_var : (Env.Env,
		     ClassInf.State,
		     Types.Mod,
		     Prefix.Prefix,
		     Connect.Sets,
		     Ident,
		     SCode.Class,
		     SCode.Attributes,
		     DimExp list, 
		     int list,
		     InstDims,
		     bool (*impl*),
                     Absyn.Comment option)
	  => (Env.Env, (* component environment *)
	      DAE.Element list, (* dae elements for component *)
	      Connect.Sets,
	      Types.Type) =

	  (** Variables of userdefined type, e.g. Point p => Real p[3]; **)
	  (** These must be handled separately since even if they do not 
	   ** appear to be an array, they can. Therefore we need to collect
	   ** the full dimensionality and call inst_var2 
	   ***)
  rule	(* Collect dimensions *)
	get_usertype_dimensions(env,mod,pre,cl,inst_dims,impl) 
	  => (dims' as _::_) &
	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dims',idxs,inst_dims,impl,comment) 
	  => (compenv,dae,csets',ty') &
	  make_array_type(dims',ty') => ty 
	--------------------------
	inst_var(env,ci_state,mod,pre,csets,n,
                 cl as SCode.CLASS(id,_,_,SCode.R_TYPE,_),
                 attr,dims,idxs,inst_dims,impl,comment)
          => (compenv,dae,csets',ty)

	(* Generic case: fall trough *)  
  rule	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dims,idxs,inst_dims,impl,comment) 
	  => (compenv,dae,csets',ty')
	----------------------
	inst_var(env,ci_state,mod,pre,csets,n,cl as SCode.CLASS(id,_,_,_,_),
                 attr,dims,idxs,inst_dims,impl,comment)
          => (compenv,dae,csets',ty')
end

(** relation: inst_var2
 **
 ** Helper relation to inst_var, does the main work.
 **)

relation inst_var2 : (Env.Env,
		      ClassInf.State,
		      Types.Mod,
		      Prefix.Prefix,
		      Connect.Sets,
		      Ident,
		      SCode.Class,
		      SCode.Attributes,
		      DimExp list, 
		      int list,
		      InstDims,
		      bool, (* True = Implicit instantiation, should only be 
			    used when instantiating functions. Then we can 
			    not always find dimensional sizes. e.g. 
			    input Real x[:]; *)
		      Absyn.Comment option)
	  => (Env.Env, (* component environement *)
	      DAE.Element list,
	      Connect.Sets,
	      Types.Type) =

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)


	(** LS: Removed the part which checks if modelica_output is true
	 ** and generates variables with initialization expression from the
	 ** modifications, because it cannot handle right hand side which is a
	 ** component (T_COMPLEX) anyway. This case is handled by the rule below
	 ** which generates correct equations according to the modification.
	 ** Separate code can parse the DAE and put the rhs of the latest
	 ** equation inside the variable declaration, and discard all the
	 ** equations.
	 **)

(** Rules for normal instantiation, will resolv dimensional sizes, etc. *)

	(* Constants *)
  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,env',csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	(*inst_mod_equation(cr,ty,mod) => dae2 &*)


	dae_declare(cr,ci_state,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e), 
		    inst_dims,NONE,NONE,comment)
	  => dae3 & 
	list_append(dae1',dae3) => dae 
	--------------------------
	inst_var2(env,ci_state,mod as Types.MOD(_,_,SOME(Types.TYPED(e,_,_))),
                  pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt as SCode.CONST,dir),
		 [],idxs,inst_dims,impl (*as false*),comment)
          => (env',dae,csets',ty)

	  (* Parameters *)
  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,env',csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	dae_declare(cr,ci_state,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e),inst_dims,NONE,NONE,comment)
	  => dae3 &  
	list_append(dae1',dae3) => dae
	--------------------------
	inst_var2(env,ci_state,mod as Types.MOD(_,_,SOME(Types.TYPED(e,_,_))),pre,csets,n,cl,SCode.ATTR(_,flow,acc, vt as SCode.PARAM,dir),
		 [],idxs,inst_dims,impl (*as false*),comment)
          => (env',dae,csets',ty)

	  (* Structural Parameters *)
  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,env',csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	dae_declare(cr,ci_state,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e),inst_dims,NONE,NONE,comment)
	  => dae3 &  
	list_append(dae1',dae3) => dae
	--------------------------
	inst_var2(env,ci_state,mod as Types.MOD(_,_,SOME(Types.TYPED(e,_,_))),pre,csets,n,cl,SCode.ATTR(_,flow,acc, vt as SCode.STRUCTPARAM,dir),
		 [],idxs,inst_dims,impl (*as false*),comment)
          => (env',dae,csets',ty)

	  (* Scalar Variables *)
  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
        Prefix.print_prefix_str(pre') => prefix_str &
        
	Debug.fprintl ("insttr", ["instantiating var class: ", n," prefix ",prefix_str, "\n"]) &
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,env',csets',ty,st) &
       
	fix_direction(dae1,dir) => dae1' &
        Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	inst_mod_equation(cr,ty,mod,impl) => dae2 &
        
        Util.list_map(idxs',int_string) => index_string &

        Debug.fprint ("insttrind", "\n ******************\n ") &
        Debug.fprint ("insttrind", "\n index_string ") &   Debug.fprintl ("insttr", index_string) &
        Debug.fprint ("insttrind", "\n component ref ") &   Debug.fcall ("insttr", Exp.print_component_ref,cr) &
        Debug.fprint ("insttrind", "\n ******************\n ") &
	Debug.fprint ("insttrind", "\n ") &
	
        inst_start_binding_exp(mod,ty,idxs') => start &

        inst_dae_variable_attributes(env,mod,ty,idxs') => dae_var_attr &

        dae_declare(cr,ci_state,ty,SCode.ATTR([], flow, acc, vt, dir), NONE,
 		            inst_dims, start, dae_var_attr,comment) => dae3 & 
        
	list_append(dae1',dae2) => daex &
	list_append(daex,dae3) => dae 
	--------------------------
	inst_var2(env,ci_state,mod,pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt,dir),
		  [],idxs,inst_dims,impl,comment)
          => (env',dae,csets',ty)

	  (* Array vars with binding in functions,e.g. input Real x[:]=Y *)
  rule	(* Do not flatten because it is a function *)
	inst_dim_exp_lst (dims,impl) => dims' &
	(* get the equation modification *)
	Mod.mod_equation(mod) => SOME(Types.TYPED(e,_,p)) &  
	(* Instantiate type of the component *)
	inst_class(env,mod,pre,csets,cl,inst_dims,impl,INNER_CALL) 
	  => (_,env',_,ty,st) &
	(* Make it an array type since we are not flattening *)
	make_array_type(dims,ty) => ty' &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	Types.elab_type(ty') => ty'' &
	Types.match_prop(e,Types.PROP(ty',Types.C_VAR),p) => e' &
	(* Put the mod equation in the dae so that code will be generated *)
	make_dae_equation(Exp.CREF(cr,ty''),e',NON_INITIAL) => daeeq &

	dae_declare(cr,ci_state,ty,attr,NONE,dims',NONE,NONE,comment) => dae1 &
	list_append (dae1, [daeeq]) => dae
	-------------------------------
	inst_var2(env,ci_state as
		  ClassInf.FUNCTION(_),mod,pre,csets,n,cl,
                  attr,dims as _::_,idxs,inst_dims,impl,comment)
          => (env',dae,csets,ty')

	  (* Array vars without binding in functions , e.g. input Real x[:] *)
  rule	(* Do not flatten because it is a function *)
	inst_class(env,mod,pre,csets,cl,inst_dims,impl,INNER_CALL) 
	  => (_,env',_,ty,st) &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	(* Do all dimensions... *)
	inst_dim_exp_lst(dims,impl) => dims' &
	dae_declare(cr,ci_state,ty,attr,NONE,dims',NONE,NONE,comment) => dae &
	make_array_type(dims,ty) => arrty 
	-------------------------------
	inst_var2(env,ci_state as ClassInf.FUNCTION(_),mod,pre,csets,
                  n,cl,attr,dims as _::_,idxs,inst_dims,impl,comment)
          => (env',dae,csets,arrty)
	  

	  (* FIXME: make a similar rule: if implicit=true and we fail to flatten, we should leave it unflattened *)
  rule	(* Array variables , e.g. Real x[3]*)
	(* flatten *)
	inst_dim_exp (dim,impl) => dime &
	list_append(inst_dims,[dime]) => inst_dims' &
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),1,dim,dims,idxs,inst_dims',impl,comment)
	  => (compenv,dae, csets', ty) &
	inst_dim_type dim => dimt &
	Types.lift_array(ty,dimt) => ty' 
	-------------------------------
	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dim::dims,idxs,inst_dims,impl,comment)
          => (compenv,dae,csets',ty')

(* Rules for instantation of function variables (e.g. input and output 
  parameters and protected variables) *)

  rule	Debug.fprint("failtrace", "- inst_var2 failed: ") & 
	Debug.fprint("failtrace",  n) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------
	inst_var2(_,_,_,_,_,n,_,_,_,_,_,_,_) => fail
	
end

(** relation: make_array_type
 **
 ** Creates an array type from the element type given as argument and a 
 ** list of dimensional sizes.
 **)

relation make_array_type: (DimExp list, Types.Type) 
	  => Types.Type =

  axiom	make_array_type ([],ty) => ty

  rule	make_array_type(xs,(ty,p)) => ty'
	-----------------------------
	make_array_type(DIMINT(i)::xs,(ty,p)) 
	  => ((Types.T_ARRAY(Types.DIM(SOME(i)),(ty')),p))

  rule	make_array_type(xs,(ty,p)) => ty'
	-------------------------
	make_array_type(DIMEXP(_,_)::xs,(ty,p)) 
	  => ((Types.T_ARRAY(Types.DIM(NONE),ty'),p))

  rule	Debug.fprint("failtrace", "- make_array_type failed\n")
	-------------------------------------------------------
	make_array_type(_,_) => fail
end

(** relation: get_usertype_dimensions
 **
 ** Retrieves the dimensions of a usertype.
 ** The builtin types have no dimension, whereas a user defined type might
 ** have dimensions. For instance, type Point = Real[3]; 
 ** has one dimension of size 3.
 **)

relation get_usertype_dimensions:(Env.Env, Types.Mod, Prefix.Prefix, 
				  SCode.Class,
				  InstDims, bool (*impl*) )
	  => (DimExp list) =
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("Real",_,_,_,_),_,_) => []
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("Integer",_,_,_,_),_,_) => []
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("String",_,_,_,_),_,_) => []
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("Boolean",_,_,_,_),_,_) => []

	(* Derived classes with restriction type, e.g. type Point = Real[3];*)
  rule	Lookup.lookup_class(env,cn,true) => (cl,cenv) &
	let owncref = Absyn.CREF_IDENT(id,[]) &
	get_option_arraydim(ad) => ad' &
	Mod.elab_mod(env,pre,mod,impl) => mod' &
	Mod.merge(mods,mod',env,pre) => mods'' &
	Mod.mod_equation mods'' => eq &
	Mod.lookup_comp_modification(mods'',id) => mods''' &
	get_usertype_dimensions(cenv,mods''',pre,cl,dims,impl) => dim1 &
	elab_arraydim(env,owncref,ad',eq,impl,NONE) => dim2 &
	list_append(dim2,dim1) => res
	------------------------------
	get_usertype_dimensions(env,mods,pre,
				SCode.CLASS(id,_,_,SCode.R_TYPE,
					    SCode.DERIVED(cn,ad,mod)),dims,impl) 
	  => res

  rule	Debug.fprint("failtrace", "- get_usertype_dimensions failed\n")
	--------------
	get_usertype_dimensions(_,_,_,_,_,_) => fail
end

(** relation: get_cref_from_mod
 ** author: PA
 **
 ** Return all variables in a modifier, SCode.Mod.
 ** This is needed to prepare the second pass of instantiation, because a 
 ** component can not be instantiated unless the types of the modifiers are
 ** known. Therefore the variables in all  modifiers must be instantiated 
 ** before the component itself is instantiated. This is done by backpatching 
 ** in the instantiation process. NOTE: This means that a recursive 
 ** modification structure (which is not allowed in Modelica) will currently 
 ** run the compiler into infinite recursion.
 **)

relation get_cref_from_mod: SCode.Mod => Absyn.ComponentRef list =

	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
  rule	get_cref_from_mod(SCode.REDECL(b,xs)) => res1 &
	get_cref_from_mod(m) => res2 &
	list_append(res1,res2) => res 
	-----------------------------
	get_cref_from_mod(SCode.REDECL(b, SCode.COMPONENT(n,_,_,_,_,_,m,_,_)::xs)) 
	  => res

	  (* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
  rule	get_cref_from_mod(SCode.REDECL(b,xs)) => res
	-----------------------------
	get_cref_from_mod(SCode.REDECL(b, _::xs)) 
	  => res

  axiom	get_cref_from_mod(SCode.REDECL(b,[])) => []

	(* Find in sub modifications e.g A(B=3) find B *)
  rule	get_cref_from_submods(submods) => l1 &
	Absyn.get_cref_from_exp(e) => l2 &
	list_append(l2,l1) => res
	-------------------------
	get_cref_from_mod(mod as SCode.MOD(_,submods,SOME(e))) => res

  rule	get_cref_from_submods(submods) => res
	-------------------------------------
	get_cref_from_mod(SCode.MOD(_,submods,NONE)) => res 
	
  axiom	get_cref_from_mod(_) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_mod failed\n")
	----------
	get_cref_from_mod(_) => fail
end

(** relation: get_cref_from_dim
 ** author: PA
 **
 ** Similar to get_cref_from_mod, but investigates array dimensionalitites 
 ** instead.
 **)

relation get_cref_from_dim: Absyn.ArrayDim => Absyn.ComponentRef list =
	
  rule	get_cref_from_dim(rest) => l1 &
	Absyn.get_cref_from_exp(exp) => l2 &
	list_append(l1,l2) => res
	----------------------
	get_cref_from_dim(Absyn.SUBSCRIPT(exp)::rest) => res
	
  rule	get_cref_from_dim(rest) => res
	------------------------------
	get_cref_from_dim(Absyn.NOSUB::rest) => res

  axiom	 get_cref_from_dim([]) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_dim failed\n")
	------------
	get_cref_from_dim(_) => fail
end

(** relation: get_cref_from_submods
 **
 ** Helper relation to get_cref_from_mod, investigates sub modifiers.
 **)

relation get_cref_from_submods: (SCode.SubMod list) 
	  => Absyn.ComponentRef list =

  rule	get_cref_from_mod(mod) => res1 &
	get_cref_from_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_submods(SCode.NAMEMOD(_,mod)::rest) => res
	   
	axiom get_cref_from_submods([]) => []
end

(** relation: update_components_in_env
 ** author: PA
 **
 ** This relation is the second pass of component instantiation, when a 
 ** component can be instantiated fully and the type of the component can be 
 ** determined. The type is added/updated to the environment such that other 
 ** components can use it when they are instantiated.
 **)

relation update_components_in_env:(Types.Mod,
				  Absyn.ComponentRef list,
				  Env.Env, 
				  ClassInf.State, 
				  bool (* Implicit instantiation*)) 
	=> Env.Env =
	
  rule	update_component_in_env(mods,cr,env,ci_state,impl) => env' &
	update_components_in_env(mods,rest,env',ci_state,impl) => env''
	-------------------------------------------
	update_components_in_env(mods,cr::rest,env,ci_state,impl) => env'' 

  rule (*	Debug.fprint("decl", "update_components_in_env finished\n")*)
	---------------
	update_components_in_env(_,[],env,ci_state,impl) => env
end

(** relation: update_component_in_env
 ** author: PA
 **
 ** Helper relation to update_components_in_env.
 ** Does the work for one variable.
 **)

relation update_component_in_env: (Types.Mod,Absyn.ComponentRef, Env.Env, 
				   ClassInf.State, bool) 
	  => Env.Env =

	  (** Variables that have Element in Environment, i.e. no type 
	   ** information are instnatiated here to get the type. **)	
  rule	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME((SCode.COMPONENT(n,final,repl,prot,
				   attr as SCode.ATTR(ad,flow,acc,param,dir),
				   t,m,bc,comment),cmod)),_) &

	Lookup.lookup_class(env,t,false) => (cl,cenv) & 

	get_cref_from_mod(m) => crefs &
 	get_cref_from_dim(ad) => crefs2 &
	list_append(crefs,crefs2) => crefs' &
	remove_cref_from_crefs(crefs',cref) => crefs'' &
	update_components_in_env(mods,crefs'',env,ci_state,impl) => env2 &
	(* Prefix does not matter, since we only update types in env, and does
	   not make any dae elements, etc.. *)
	Mod.elab_mod(env2,Prefix.NOPRE,m,impl) => m' &


	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.merge(classmod,mm,env2,Prefix.NOPRE) => mod &
	Mod.merge(mod,m',env2,Prefix.NOPRE) => mod' &
	Mod.merge(cmod,mod',env2,Prefix.NOPRE) => mod'' &

	Mod.update_mod(env2,Prefix.NOPRE,mod'',impl) => mod''' &


	Mod.mod_equation mod''' => eq &
	
	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	elab_arraydim(env2,cref,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(cenv,ci_state, mod''', Prefix.NOPRE, [], n, cl, attr,
		 dims, [], [], impl,NONE)
	  => (compenv,dae1, csets', ty) &
	(** The environment is extended with the new variable *)
	(** binding. *)
	make_binding (env2,attr,mod''') => binding &

	(** Check if binding makes other variables into structural parameters
	 ** For example input Integer n=p;
	 ** If p is known to be a structural parameter, n should also become
	 ** one.
	 **)
	check_structural_param_binding(param,binding,env2) => (env2',binding') &

	Env.update_frame_v(env2',Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding'),
			   false,(*type info present*)
			   compenv) => env' 
	----------------------------------
	update_component_in_env (mods,cref as Absyn.CREF_IDENT(id,subscr),env,ci_state, impl) => env'

	(* Variable with NONE element is allready instantiated.*)
  rule	Lookup.lookup_ident(env,id) => (ty,NONE,_) 
	----------------------------------
	update_component_in_env (mods,cref as Absyn.CREF_IDENT(id,subscr),env,ci_state, impl) => env
	
	(** If first part of ident is a class, e.g StateSelect.None, nothing 
	 ** to update **)	
  rule	Lookup.lookup_class(env,Absyn.IDENT(id),false) => (cl,cenv)
	--------------------------------------------------------------------
	update_component_in_env(mods, Absyn.CREF_QUAL(id,_,_),env,ci_state, impl) => env

	(* Nothing to update. *)
  rule	Lookup.lookup_ident(env,id) => (ty,NONE,_) 
	----------------------------------
	update_component_in_env (mods, Absyn.CREF_QUAL(id,_,_),env,ci_state,impl) => env

	(* For qualified names, e.g. a.b.c, instanitate component a *)
  rule	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME((SCode.COMPONENT(n,final,repl,prot,
				    attr as SCode.ATTR(ad,flow,acc,param,dir),
				    t,m,_,comment),cmod)),_) &
	Lookup.lookup_class(env,t,false) => (cl,cenv) & 

	get_cref_from_mod(m) => crefs &
 	update_components_in_env(mods,crefs,env,ci_state,impl) => env2' &
	
	get_cref_from_dim(ad) => crefs2 &
	update_components_in_env(mods,crefs2,env2',ci_state,impl) => env2 &
	(* Prefix does not matter, since we only update types in env, and does
	   not make any dae elements, etc.. *)
	Mod.elab_mod(env2,Prefix.NOPRE,m,impl) => m' &

	(** lookup and merge modifications *)
	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.merge(classmod,mm,env2,Prefix.NOPRE) => mod &
	Mod.merge(mod,m',env2,Prefix.NOPRE) => mod' &
	Mod.merge(cmod,mod',env2,Prefix.NOPRE) => mod'' &

	Mod.update_mod(env2,Prefix.NOPRE,mod'',impl) => mod''' &
	Mod.mod_equation mod''' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	let owncref = Absyn.CREF_IDENT(n,[]) &
	elab_arraydim(env2,owncref,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(cenv, ci_state, mod''', Prefix.NOPRE, [], n, cl, attr,
		 dims, [], [], false,NONE)
	  => (compenv,dae1, csets', ty) &
	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env2,attr,mod''') => binding &

	Env.update_frame_v(env2,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),
			   false,(*type info present*)
			   compenv) => env' 
	------------
	update_component_in_env(mods, Absyn.CREF_QUAL(id,_,_),env,ci_state, impl) 
	  => env'

  rule 	Debug.fprint("failtrace", "-update_component_in_env failed, ident = ") &
	Debug.fcallret("failtrace",Dump.print_component_ref_str, cref,"") => str &
	Debug.fprint("failtrace",str) &
	Debug.fprint("failtrace","\n mods:") &
	Debug.fcallret("failtrace",Mod.print_mod_str, mod,"") => str2 &
	Debug.fprint("failtrace",str2) &
	Debug.fprint("failtrace", "\n   env:   " ) &
	Debug.fcallret("failtrace", Env.print_env_str , env, "") => str3 &
	Debug.fprint("failtrace",str3) &
	Debug.fprint("failtrace","\n") 
	------------------------------
	update_component_in_env(mod,cref,env,ci_state,impl) => env
end


(** relation: check_structural_param_binding
 ** author: PA
 ** 
 ** Checks if the binding of a structural parameter makes other parameters 
 ** structural. For instance,
 ** parameter Integer m=n
 ** if m is structural, so will n be.
 **)

relation check_structural_param_binding: (SCode.Variability, 
					  Types.Binding, 
					  Env.Env)
	=> (Env.Env, Types.Binding) =

	  (** collect varnames from binding and make them structural. Also 
	   ** make sure that binding has constant = true.
	   **)
  rule	Exp.get_cref_from_exp(exp) => crefs & Exp.print_exp_str exp => str &
	Util.list_fold(crefs,make_structural_in_env,env) => env' 
	-------------------------------------------------
	check_structural_param_binding(SCode.STRUCTPARAM,Types.EQBOUND(exp,e_val,const),env)
	  => (env',Types.EQBOUND(exp,e_val,Types.C_CONST))

  axiom	check_structural_param_binding(_,bind,env) => (env,bind)

end

(** relation: make_structural_in_env
 ** author: PA
 **
 ** This relation is used to update a parameter in the environment to a 
 ** structural parameter.
 **)

relation make_structural_in_env:(Exp.ComponentRef,Env.Env) => Env.Env =

  axiom	make_structural_in_env(_,env) => env 

  rule	Lookup.lookup_ident(env,id) 
	  => (Types.VAR(n,Types.ATTR(flow,acc,SCode.PARAM,dir),prot,tp,bind),
	      SOME((SCode.COMPONENT(a,b,c,d,
				   SCode.ATTR(e,f,g,SCode.PARAM,h),i,j,k,l),m)),typed) &
 	(* replace variable, relies on hash_add to replace node. *)
 	Env.extend_frame_v(env,Types.VAR(n,Types.ATTR(flow,acc,SCode.STRUCTPARAM,dir),prot,tp,bind),
			   SOME((SCode.COMPONENT(a,b,c,d,
					    SCode.ATTR(e,f,g,SCode.STRUCTPARAM,h),i,j,k,l),m)),false,[] (* comp env *)) => env'
	--------------------------------------------------------
	make_structural_in_env(Exp.CREF_IDENT(id,_),env) => env'

  rule	print "make_structural_in_env failed for component " &
	Exp.print_component_ref_str(cr) => s & print s & print "\n" 
	--------------------------
	make_structural_in_env(cr,env) => env
end
	
(** relation: inst_dim_exp_lst
 **
 ** Instantiates dimension expressions, DimExp, which are transformed to 
 ** Exp.Subscript's
 **)

relation inst_dim_exp_lst : (DimExp list, bool (*impl*)) => Exp.Subscript list =
  axiom	inst_dim_exp_lst ([],_) => []

  rule	inst_dim_exp_lst(xs,b) => res &
	inst_dim_exp(x,b) => r 
	----------------
	inst_dim_exp_lst(x::xs,b) => r::res
end

(** relation: inst_dim_exp_lst
 **
 ** instantiates one dimension expression, See also isnt_dim_exp_lst.
 **)

relation inst_dim_exp : (DimExp, bool (*impl*) ) => Exp.Subscript =
(* FIXME: Fix slicing, e.g. Exp.SLICE, for impl=true *)

  rule	Print.print_error_buf "# Error, can not determine size of array.\n"
	-------------------------------------------
	inst_dim_exp (DIMEXP(Exp.WHOLEDIM,_),impl as false) => fail

  rule	Print.print_error_buf "# Error, can not determine size of array slice\n"
	-------------------------------------------
	inst_dim_exp (DIMEXP(Exp.SLICE(_),_),impl as false) => fail

  axiom	inst_dim_exp (DIMEXP(e as Exp.WHOLEDIM,_),impl as true) => e
  axiom	inst_dim_exp (DIMINT(i),_) => Exp.INDEX(Exp.ICONST(i))

  axiom	inst_dim_exp (DIMEXP(e as Exp.INDEX(_),_),_) => e

end

(** relation inst_dim_type
 ** Retrieves the dimension expression as an integer option. 
 ** Non constant dimensions give NONE.
 **)
relation inst_dim_type : DimExp => int option =

  axiom	inst_dim_type DIMINT(i) => SOME(i)
  axiom	inst_dim_type DIMEXP(_,_) => NONE

end

(** relation: fix_direction
 **
 ** Updates the direction of a DAE element list.
 ** If a component has prefix input, all variables of the component 
 ** should be input.
 ** Similarly if a component has prefix output.
 ** If the component is bidirectional, the original direction is kept
 **)

relation fix_direction : (DAE.Element list, Absyn.Direction)
	  => DAE.Element list =
	  (** Component that is bidirectional does not change direction 
	   ** on subcomponents  **)
  axiom	fix_direction(lst,Absyn.BIDIR) => lst 
	
  axiom	fix_direction ([],_) => []

	(** Bidirectional variables are changed to input or output if 
	 ** component has such prefix. **)
  rule	absyn_dir_to_dae_dir dir => dir' &
	fix_direction (r,dir) => r'
	-----------------------------
	fix_direction (DAE.VAR(cr,vk,DAE.BIDIR,t,e,id,start,flow,class,dae_var_attr,comment)::r,dir) 
	  => DAE.VAR(cr,vk,dir',t,e,id,start,flow,class,dae_var_attr,comment)::r'

	  (** Error, component declared as input or output  when containing 
	   ** variable that has prefix input. **)
  rule	Print.print_error_buf "#Error, component declared as " & 
	Dump.direction_symbol dir => str &
	Print.print_error_buf str & 
	Print.print_error_buf " when having the variable " & 
	Exp.print_component_ref_str cr => str & 
	Print.print_error_buf str &
	Print.print_error_buf " declared as input\n"
 	-----------------------------
	fix_direction (DAE.VAR(cr,vk,DAE.INPUT,t,e,id,start,flow,class,dae_var_attr,comment)::r,dir) 
	  => fail

	  (** Error, component declared as input or output  when containing 
	   ** variable that has prefix output. **)
  rule	Print.print_error_buf "#Error, component declared as " &
	Dump.direction_symbol dir => str &
	Print.print_error_buf str & 
	Print.print_error_buf " when having the variable " & 
	Exp.print_component_ref_str cr => str &
	Print.print_error_buf str & 
	Print.print_error_buf " declared as input\n"
 	-----------------------------
	fix_direction (DAE.VAR(cr,vk,DAE.OUTPUT,t,e,id,start,flow,class,dae_var_attr,comment)::r,dir) 
	  => fail

  rule	fix_direction(lst,dir) => lst' &
 	fix_direction(r,dir) => r'
 	-------------------------------
 	fix_direction(DAE.COMP(id,DAE.DAE(lst))::r,dir) 
 	  => DAE.COMP(id,DAE.DAE(lst'))::r'

  rule	fix_direction(r,dir) => r'
	---------------------------
	fix_direction (x::r,dir) => x::r'

end

(** relation: absyn_dir_to_dae_dir
 **
 ** Helper relation to fix_direction. 
 ** Translates Absyn.Direction to DAE.VarDirection. Needed so that 
 ** input, output is transferred to DAE.
 **)

relation absyn_dir_to_dae_dir : Absyn.Direction => DAE.VarDirection =
	
  axiom	absyn_dir_to_dae_dir Absyn.INPUT  => DAE.INPUT
  axiom	absyn_dir_to_dae_dir Absyn.OUTPUT => DAE.OUTPUT
  axiom	absyn_dir_to_dae_dir Absyn.BIDIR  => DAE.BIDIR

end

(** relation: inst_array
 **
 ** When an array is instantiated by `inst_var', this relation is used
 ** to go through all the array elements and instantiate each array
 ** element separately.
 **)

relation inst_array : (Env.Env,
		       ClassInf.State,
		       Types.Mod,
		       Prefix.Prefix,
		       Connect.Sets,
		       Ident,
		       (SCode.Class*SCode.Attributes),
		       int,
		       DimExp,
		       DimExp list,
		       int list,
		       InstDims,
		       bool,
		       Absyn.Comment option)
	  => (Env.Env, (* component environment *)
	      DAE.Element list, 
	      Connect.Sets, 
	      Types.Type) =
	
	  (* If is a function var.*)  
  rule	Mod.mod_equation(mod) => SOME(Types.TYPED(e,_,p)) &  (* Which has an 
							  expression binding *)
	inst_class(env,mod,pre,csets,cl,inst_dims,true,INNER_CALL) 
	  => (_,env',_,ty,st) &
	(* Check their types... *)
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	Types.elab_type(ty) => ty' &
	Types.match_prop(e,Types.PROP(ty,Types.C_VAR),p) => e' &
	make_dae_equation(Exp.CREF(cr,ty'),e',NON_INITIAL) => dae 
	---------------------------------------------------
	inst_array(env,ci_state as ClassInf.FUNCTION(_),
                   mod,pre,csets,n,(cl,attr),i,
                   DIMEXP(_,_),dims,idxs,inst_dims,impl,comment)
	  => (env',[dae],[],ty)

  rule	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl,comment)
	  => (compenv,dae,csets,ty) 
	-----------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,
                   DIMEXP(_,_),dims,idxs,inst_dims,impl,comment)
	  => (compenv,dae,csets,ty)

  rule	int_gt(i,stop) => true
	----------------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,
                   DIMINT(stop),dims,idxs,inst_dims,impl,comment)
	  => ([],[], csets, (Types.T_NOTYPE,NONE))

	  (** Modifiers of arrays that are functioncall, eg. 
	   ** Real x[:]=foo(...) Should only generate -one- functioncall **)
  rule	Mod.mod_equation(mod) => SOME(Types.TYPED(e,_,p)) &
	Exp.contain_functioncall(e) => true &
	inst_var2(env,ci_state,Types.NOMOD,pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl,comment)
	  => (env',dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,ci_state,Types.NOMOD,pre,csets',n,(cl,attr),i',DIMINT(stop),dims,idxs,inst_dims,impl,comment)
	  => (_,dae2, csets'',arrty) &
	(* Make the equation containing the functioncall *)
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	Types.elab_type(arrty) => arrty' &
	make_dae_equation(Exp.CREF(cr,arrty'),e,NON_INITIAL) => dae3 &
	Util.list_flatten([dae1,dae2,[dae3]]) => dae
	-----------------------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl,comment)
          => (env',dae,csets',ty)

  rule	Mod.lookup_idx_modification(mod,i) => mod' &
	inst_var2(env,ci_state,mod',pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl,comment)
	  => (env',dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,ci_state,mod,pre,csets',n,(cl,attr),i',DIMINT(stop),dims,idxs,inst_dims,impl,comment)
	  => (_,dae2, csets'',_) &

	list_append(dae1,dae2) => dae
	-----------------------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl,comment)
          => (env',dae,csets'',ty)

  rule	Debug.fprint("failtrace", "- inst_array failed: ") &
	Debug.fcall("failtrace", Print.print_buf,  n) &
	Debug.fprint("failtrace", "\n") 
	--------------------------------------------------
	inst_array(_,_,_,_,_,n,(_,_),_,_,_,_,_,_,_) => fail
	
end

(** relation elab_component_arraydim_from_env
 ** author: PA
 **
 ** Lookup uninstantiated component in env, elaborate its modifiers to
 ** find arraydimensions and return as DimExp list.
 ** Used when components have submodifiers (on e.g. attributes) using size 
 ** to find dimensions of component.
 **)
relation elab_component_arraydim_from_env: (Env.Env, Exp.ComponentRef) 
	  => DimExp list =

  rule	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME((SCode.COMPONENT(n,final,repl,prot,
				   attr as SCode.ATTR(ad,flow,acc,param,dir),
				   t,m,bc,comment),cmod)),_) &
	Types.strip_submod(cmod) => cmod' &
	SCode.strip_submod(m) => m' &
	Mod.elab_mod(env,Prefix.NOPRE,m',false) => m'' &
	Mod.merge(cmod',m'',env,Prefix.NOPRE) => mod'' &
	Mod.mod_equation mod'' => SOME(eq) &
	elab_component_arraydim_from_env_2(eq,env) => dims
	-----------------------------------------------
	elab_component_arraydim_from_env(env,cref as Exp.CREF_IDENT(id,_)) => dims
end

(** relation: elab_component_arraydim_from_env_2 
 ** author: PA
 **
 ** Helper relation to elab_component_arraydim_from_env. This relation is 
 ** similar to elab_arraydim, but it will only investigate binding 
 ** (Types.EqMod) and not the component declaration.
 **)

relation elab_component_arraydim_from_env_2:( Types.EqMod,Env.Env) 
	  => DimExp list =

  rule	Types.get_dimension_sizes(t) => lst &
	Util.list_map(lst,make_dimexp_from_int) => lst'
	--------------------
	elab_component_arraydim_from_env_2(Types.TYPED(e,_,Types.PROP(t,_)),env) 
	  => lst'
end

(** relation: make_dimexp_from_int
 **
 ** Helper relation to elab_component_arraydfum_from_env_2
 **)

relation make_dimexp_from_int: int => DimExp =

  axiom	make_dimexp_from_int(i) => DIMINT(i)

end


(** relation: elab_arraydim
 **
 ** This relations examines both an `Absyn.ArrayDim' and an `Types.EqMod
 ** option' argument to find out the dimensions af a component.  If
 ** no equation modifications is given, only the declared dimension is
 ** used.
 **
 ** When the size of a dimension in the type is undefined, the
 ** corresponding size in the type of the modification is used.
 **
 ** All this is accomplished by examining the two arguments separately
 ** and then using `complete_arraydime' or `compatible_arraydim' to
 ** check that that the dimension sizes are compatible and complete.
 **)

relation elab_arraydim : (Env.Env, Absyn.ComponentRef, Absyn.ArrayDim, 
			  Types.EqMod option, bool (*impl *), 
			  Interactive.InteractiveSymbolTable option)
	  => DimExp list =

  rule	elab_arraydim_decl(env,cref,ad,impl,st) => dim &
	complete_arraydim(dim) => dim'
	------------------------------
	elab_arraydim(env,cref,ad,NONE,impl,st) => dim'

  rule	elab_arraydim_decl(env,cref,ad,impl,st) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3 
	---------------------------------
	elab_arraydim(env,cref,ad,SOME(Types.TYPED(e,_,Types.PROP(t,_))),impl,st) => dim3
	(* Untyped expressions must be elaborated. *)
  rule	Static.elab_exp(env,e,impl,st) => (e',Types.PROP(t,_),_) &
	elab_arraydim_decl(env,cref,ad,impl,st) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3 
	---------------------------------
	elab_arraydim(env,cref,ad,SOME(Types.UNTYPED(e)),impl,st) => dim3


  rule	elab_arraydim_decl(env,cref,ad,impl,st) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	not compatible_arraydim(dim1,dim2) => dim3 &
	Print.print_error_buf "# Array dimension mismatch\n" &
	Print.print_error_buf "    expression " & 
	Exp.print_exp_str e => str &
	Print.print_error_buf str &
	Print.print_error_buf " has type " & 
	Types.unparse_type t => str &
	Print.print_error_buf str & 
	Print.print_error_buf "\n" &
	Print.print_error_buf "    expected array dimensions [" &
	print_dim_str dim1 => str & 
	Print.print_error_buf str &
	Print.print_error_buf "]\n"
	---------------------------------
	elab_arraydim(env,cref,ad,SOME(Types.TYPED(e,_,Types.PROP(t,_))),impl,st) => fail

  rule	Debug.fprint("failtrace", "- elab_arraydim failed\n cref:") &
	Debug.fcall("failtrace", Dump.print_component_ref, cref) &
	Debug.fprint("failtrace", " dim: " )  &
	Debug.fcall("failtrace", Dump.print_arraydim, ad) &
	Debug.fprint("failtrace", "\n" ) 
	-------------------------------------
	elab_arraydim(_,cref,ad,_,_,_) => fail

end

(** relation: print_dim
 **
 ** This relation prints array dimensions.  The code is not included
 ** in the report.
 **)

(*!ignorecode*)

relation print_dim_str: (DimExp option) list => string =

  axiom	print_dim_str [NONE] => ":"

  rule	int_string x => s 
	---------------------------
	print_dim_str [SOME(DIMINT(x))] => s

  rule	Exp.print_subscript_str x => s
	---------------------------
	print_dim_str [SOME(DIMEXP(x,_))] => s 

  rule	print_dim_str xs => str &
	string_append(":,",str) => res
	-------------------------
	print_dim_str NONE::xs => res

  rule	int_string x => s &   print_dim_str xs => s2 &
	Util.string_append_list([s,",",s2]) => res
	------------------------------------------------
	print_dim_str SOME(DIMINT(x))::xs => res

rule	Exp.print_subscript_str x => s1 & 
	print_dim_str xs => s2 &
	Util.string_append_list([s1,",",s2]) => res
	------------------------------------------------
	print_dim_str SOME(DIMEXP(x,_))::xs => res

end

(** relation: print_dim
 **
 ** Prints a dimension expression option list to the print buffer.
 **)

relation print_dim : (DimExp option) list => () =

  rule	print_dim_str(dims) => str &
	Print.print_buf str 
	-----------------
	print_dim (dims) => ()

end

(** relation print_dim2
 **
 ** Helper relation to print_dim
 **)

relation print_dim2 : DimExp  list => () =

  rule	int_string x => s & Print.print_buf s
	---------------------------
	print_dim2 [DIMINT(x)]

  rule	Exp.print_subscript x
	---------------------------
	print_dim2 [DIMEXP(x,_)]

  rule	int_string x => s & Print.print_buf s & Print.print_buf "," & print_dim2 xs
	------------------------------------------------
	print_dim2 DIMINT(x)::xs

rule	Exp.print_subscript x & Print.print_buf "," & print_dim2 xs
	------------------------------------------------
	print_dim2 DIMEXP(x,_)::xs
  axiom	print_dim2[] => ()

end
(*!includecode*)

(** relation: elab_arraydim_decl
 **
 ** Given an `Absyn.ArrayDim', this relation evaluates all dimension
 ** size specifications, creating a list of (optional) integers.  When
 ** the array dimension size is specified as `:', the result will
 ** contain `NONE'.
 **)

relation elab_arraydim_decl : (Env.Env, Absyn.ComponentRef, Absyn.ArrayDim, bool, Interactive.InteractiveSymbolTable option)
	    => (DimExp option) list =

  axiom	elab_arraydim_decl(_,_,[],_,_) => []

  rule	elab_arraydim_decl(env,cref,ds,impl,st) => l 	
	-------------------------------
	elab_arraydim_decl(env,cref,Absyn.NOSUB::ds,impl,st) => NONE::l

	(** For functions, this can occur: Real x[:,size(x,1)] ,i.e. 
	 ** refering to  the variable itself but a different dimension.**)
  rule	Absyn.cref_equal(cref,cr) => true &
	elab_arraydim_decl(env,cref,ds,impl,st) => l 	
	-------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(Absyn.CALL(Absyn.CREF_IDENT("size",_),Absyn.FUNCTIONARGS([Absyn.CREF(cr),_],_)))::ds,impl,st) => NONE::l

	(** Constant dimension creates DIMINT, valid for both implicit and 
	 ** nonimplicit instantiation.
	 **)
  rule	Debug.fprintln("insttr", "elab_arraydim_decl5") &
	Static.elab_exp(env, d,impl,st)
	    => (e,Types.PROP((Types.T_INTEGER(_),_),cnst),_) &  
	not cnst = Types.C_VAR &  
	Ceval.ceval(env,e,impl,st,NONE,Ceval.MSG) => (Values.INTEGER(i),_) &
 	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl(* as false*),st) => SOME(DIMINT(i))::l

	(* when not implicit instantiation, array dim. must be constant.*)
  rule	Debug.fprintln("insttr", "elab_arraydim_decl5") &
	Static.elab_exp(env, d,impl,st)
	    => (e,Types.PROP((Types.T_INTEGER(_),_),Types.C_VAR),_) &  
	Print.print_error_buf "#Error, non constant array dimension: " &
        Dump.print_exp_str d => str & Print.print_error_buf str & 
	Print.print_error_buf "\n"
	-------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl as false,st) 
	  => fail

	(* Non-constant dimension creates DIMEXP *)
  rule	Debug.fprintln("insttr", "elab_arraydim_decl6") &
	Static.elab_exp(env, d,impl,st) => (e,Types.PROP((Types.T_INTEGER(_),_),cnst),_) &
	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl as true,st) 
	  => SOME(DIMEXP(Exp.INDEX(e),NONE))::l 

	  (* Size(x,1) in e.g. functions => Unknown dimension *)
  rule	Static.elab_exp(env,d,impl,st)
	  => (e as Exp.SIZE(_,_),Types.PROP(t,_),_) &
	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl,st) 
	  => SOME(DIMEXP(Exp.INDEX(e),NONE))::l

  rule	Static.elab_exp(env,d,impl,st)
	  => (e,Types.PROP(t,_),_) &
	Print.print_error_buf "# Array dimensions must be integer\n" &
	Print.print_error_buf "    expression: " & 
	Exp.print_exp_str e => str &
	Print.print_error_buf str &
 	Print.print_error_buf " (" & Types.unparse_type t  => str & 
	Print.print_error_buf str &
	Print.print_error_buf ")\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl,st) => fail

  rule	Print.print_error_buf "elab_arraydim_decl failed\n" &
	Debug.fprint("failtrace", "- elab_arraydim_decl failed\n")
	-------------------------------------
	elab_arraydim_decl(_,_,_,_,_) => fail     
end

(** relation: complete_arraydim
 **
 ** This relation converts a list of optional integers to a list of
 ** integers.  If one element of the list is `NONE', this relation
 ** will fail.
 **
 ** This is used to check that an array specification contain fully
 ** specified array dimension sizes.
 **)

relation complete_arraydim : (DimExp option) list => DimExp list =

  axiom	complete_arraydim [] => []

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim SOME(x)::xs => x::xs'

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim NONE::xs => DIMEXP(Exp.WHOLEDIM,NONE)::xs'

end

(** relation: compatible_arraydim
 **
 ** Given two, possibly incomplete, array dimension size
 ** specifications as list of optional integers, this relation checks
 ** whether they are compatible.  Being compatible means that they
 ** have the same number of dimension, and for every dimension at
 ** least one of the lists specifies its size.  If both lists specify
 ** a dimension size, they have to specify the same size.
 **)

relation compatible_arraydim : ((DimExp option) list,(DimExp option) list)
	  => DimExp list =

  axiom	compatible_arraydim([],[]) => []

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(SOME(x)::xs,NONE::ys) => x::l

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(NONE::xs,SOME(y)::ys) => y::l

  rule	x = y &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMINT(y))::ys) 
	  => DIMINT(x)::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(x)),NONE),DIMEXP(y,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMEXP(y,e))::ys)
	  => de::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(y)),NONE),DIMEXP(x,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e))::xs,SOME(DIMINT(y))::ys) 
	  => de::l

  rule	arraydim_condition(DIMEXP(x,e1),DIMEXP(y,e2))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e1))::xs,SOME(DIMEXP(y,e2))::ys)
	  => de::l

  rule	compatible_arraydim(xs,ys) => l
	--------------------------------
	compatible_arraydim (NONE::xs,NONE::ys) 
	  => DIMEXP(Exp.WHOLEDIM,NONE)::l

  rule	Print.print_buf "-compatible_arraydim failed\n" &
	Debug.fprint("failtrace", "- compatible_arraydim failed\n")
	--------------------------------------
	compatible_arraydim (_,_) => fail

end

(** relation arraydim_condition
 ** 
 ** This relation checks that the two arraydim expressions have the same 
 ** dimension.
 ** FIXME: no check performed yet, just return first DimExp.
 **)
relation arraydim_condition : (DimExp, DimExp) => DimExp =
	
  axiom arraydim_condition (de,_) => de

end

(** relation: elab_arraydim_type
 **
 ** Find out the dimension sizes of a type.  The second argument is
 ** used to know how many dimensions should be extracted from the
 ** type.
 **)

relation elab_arraydim_type : (Types.Type, Absyn.ArrayDim)
	  => DimExp option list =

  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type((Types.T_ARRAY(Types.DIM(NONE),t),_), _::ad) 
	  => NONE::l
	
  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type((Types.T_ARRAY(Types.DIM(SOME(i)),t),_), _::ad) 
	  => SOME(DIMINT(i))::l
	
 axiom elab_arraydim_type(_,[]) => []

	(* PR, for debugging *)
  rule 	Debug.fprint("failtrace", "Undefined!") &
	Debug.fprint("failtrace", " The type detected: ") &
  	Debug.fcall("failtrace", Types.print_type, t)
       --------------------
	elab_arraydim_type(t,_::ad) => fail
end

(** relation: inst_class_decl
 **
 ** The class definition is instantiated although no variable
 ** is declared with it.  After instantiating it, it is
 ** checked to see if it can be used as a package, and if it
 ** can, then it is added as a variable under the same name as
 ** the class.  This makes it possible to use a unified lookup
 ** mechanism.  And since packages only can contain constants
 ** and class definition, instantiating a package does not do
 ** anything else.
 **)

relation inst_class_decl : (Env.Env, Types.Mod, Prefix.Prefix,
			    Connect.Sets, SCode.Class,InstDims, bool (*packimpl*) )
	  => (Env.Env, DAE.Element list) =

  rule	Env.extend_frame_c(env,c) => env' &
	implicit_instantiation(env',Types.NOMOD,pre,csets,c,inst_dims,packimpl) 
	  => (env'',dae) 
	----------------------------------
	inst_class_decl(env,mod,pre,csets,c as SCode.CLASS(n,_,_,restr,_),inst_dims,packimpl)
	  => (env'', dae)

  rule	Debug.fprint("failtrace",  "- inst_class_decl failed\n") 
	----------------------------------
	inst_class_decl(env,_,_,_,_,_,_) => fail
end

(** relation implicit_instantiation
 **
 ** This relation adds types to the environment.
 **
 ** If a class definition is a function or a package or an enumeration , 
 ** it is implicitly instantiated and added as a type binding under the
 ** same name as the class name.
 **)

relation implicit_instantiation : (Env.Env, Types.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims, bool (*packimpl*) )
	  => (Env.Env, DAE.Element list) =

	  (* Implicit instantiation of functions *)
  rule	inst_class(env, mod, pre, csets, c, inst_dims, true (*impl*),INNER_CALL)
 	  => (dae, _, csets', ty, st) &
 	Env.extend_frame_t(env, n, ty) => env' &
         make_fully_qualified (env, Absyn.IDENT(n)) => fpath
 	--------------------------------------
 	implicit_instantiation(env, mod, pre, csets,
 			       c as SCode.CLASS(n,_,_,SCode.R_FUNCTION,_),
 			       inst_dims, packimpl as false)
 	  => (env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])

	  (* Implicit instantiation of external functions *)
  rule	inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
 	  => (dae, _, csets', ty, st) &
 	
 	Env.extend_frame_t(env, n, ty) => env'	&
	make_fully_qualified (env, Absyn.IDENT(n)) => fpath &
	let prot = false & 
	inst_classdef (env, mod, pre, csets, ClassInf.UNKNOWN(n), parts, restr, 
		       prot, inst_dims, true (*impl*), packimpl ) 
	  =>(_, tempenv,_,_,_) &

	inst_ext_decl(tempenv, n, parts, true (*impl*) ) => extdecl
	--------------------------------------
	implicit_instantiation(env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_, restr as SCode.R_EXT_FUNCTION, 
			       parts as SCode.PARTS(els,_,_,_,_,_)),
			       inst_dims, packimpl as false)
	  => (env', [DAE.EXTFUNCTION(fpath,DAE.DAE(dae), ty, extdecl)])

	  (* enumerations *)
  rule	inst_enumeration(n,l) => enumclass &
	Env.extend_frame_c(env,enumclass) => env'' 
	-----------------------------------
	implicit_instantiation(env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_TYPE, SCode.ENUMERATION(l)),inst_dims,packimpl)
	=> (env'', [])

	  (*.. the rest will fall trough *)
  axiom	implicit_instantiation(env, mod, pre, csets, c, _, _) => (env, [])
	
end

(** relation: make_fully_qualified
 ** author: PA
 **
 ** Transforms a class name to its fully qualified name by investigating the 
 ** environment.
 ** For instance, the model Resistor in Modelica.Electrical.Analog.Basic will
 ** given the correct environment have the fully qualified name: 
 ** Modelica.Electrical.Analog.Basic.Resistor
 **)

relation make_fully_qualified : (Env.Env, Absyn.Path) => Absyn.Path =

  rule	Env.get_env_path env => NONE
	----------------------------
	make_fully_qualified (env,path) => path

	(** To make a class fully qualified, the class path
	 ** is looked up in the environment.
	 ** The FQ path consist of the simple class name
	 ** appended to the environment path of the looked up class.
	 **)
  rule	Lookup.lookup_class(env,path,false) => (_,env') &
	Env.get_env_path env' => SOME(path') &
	Absyn.path_last_ident(path) => class_name &
	Absyn.join_paths(path',Absyn.IDENT(class_name)) => path''
	--------------------------------------
	make_fully_qualified (env,path) => path''

	(* If it fails, leave name unchanged. *)
  axiom	make_fully_qualified(env,path) => path
end

(** relation: implicit_function_instantiation
 **
 ** This relation instantiates a function, which is performed "implicitly" 
 ** since the variables of a function should not be instantiated as for an 
 ** ordinary class.
 **)

relation implicit_function_instantiation : (Env.Env, Types.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims, bool)
	  => (Env.Env, DAE.Element list) =

  rule	inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
	  => (dae, _, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
        make_fully_qualified (env, Absyn.IDENT(n)) => fpath
	--------------------------------------
	implicit_function_instantiation(env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_FUNCTION,_),
			       inst_dims, packimpl as false)
	  => (env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])

	  (** External functions should also have their type in env, 
	   ** but no dae. **)
  rule	inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
	  => (dae, _, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env'	&
        make_fully_qualified (env, Absyn.IDENT(n)) => fpath &
        let prot = false & (* how to get this? *)
 	inst_classdef (env', mod, pre, csets, ClassInf.FUNCTION(n), parts, 
		       restr, prot, inst_dims, true (*impl*), packimpl) 
	  =>(_, tempenv,_,_,_) &
	inst_ext_decl(tempenv, n, parts, true (*impl*) ) => extdecl 
	--------------------------------------
	implicit_function_instantiation(env, mod, pre, csets,
		       c as SCode.CLASS(n,_,_, restr as SCode.R_EXT_FUNCTION, 
			       parts as SCode.PARTS(els,_,_,_,_,_)),
			       inst_dims, packimpl as false)
	  => (env', [DAE.EXTFUNCTION(fpath,DAE.DAE(dae), ty, extdecl)])
				
  rule        (* Overloaded functions *)
        inst_overloaded_functions(env,n,funcnames) => (env',daefuncs)
	-----------------------------
         implicit_function_instantiation(env,mod,pre,csets,
                              c as SCode.CLASS(n,_,_, restr as SCode.R_FUNCTION,
                              SCode.OVERLOAD(funcnames)),
                              inst_dims, packimpl as false)
         => (env', daefuncs)

  rule	(*Debug.fprint("failtrace", "#-- implicit_function_instantiation failed\n")*)
	------------------------------------------------------------------------
	implicit_function_instantiation(_,_,_,_,_,_,_) => fail 

end

(** relation implicit_function_type_instantiation
 ** author: PA
 **
 ** When looking up a function type it is sufficient to only instantiate the 
 ** input  and output arguments of the function. 
 ** The implicit_function_instantiation relation will instantiate the function
 ** body, resulting in a DAE for the body. This relation does not do that. 
 ** Therefore this relation is the only solution available for recursive 
 ** functions, where the function body contain a call to the function itself.
 **)

 relation implicit_function_type_instantiation:(Env.Env, SCode.Class)
	  => (Env.Env) =

	   (* The function type can be determined without the body. *)
  rule	let stripped_class = SCode.CLASS(id,p,e,r,SCode.PARTS(elts,[],[],[],[],NONE)) &
	implicit_function_instantiation(env,Types.NOMOD,
					Prefix.NOPRE, [], stripped_class
					, [], false) => (env',_)
	 --------------------------------------------------------
	 implicit_function_type_instantiation(env,SCode.CLASS(id,p,e,r,SCode.PARTS(elts,_,_,_,_,_)))
	 => env'
end
							      

(** relation: inst_overloaded_functions
 **
 ** This relation instantiates the functions in the overload list of a 
 ** overloading function definition and register the function types using the
 ** overloaded name. It also creates dae elements for the functions. 
**)

relation inst_overloaded_functions: (Env.Env, Absyn.Ident, Absyn.Path list)
	=> (Env.Env, DAE.Element list) =

  axiom	inst_overloaded_functions(env,_,[]) => (env, [])

	(** Instantiate each function, add its FQ name to the type, 
	 ** needed when deoverloading **)
  rule	Lookup.lookup_class(env,fn,true) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_FUNCTION,_),cenv) &
	inst_class(cenv, Types.NOMOD, Prefix.NOPRE, [], c, [], true,INNER_CALL) 
	  => (dae, _, _, (Types.T_FUNCTION(args,tp),_), st) &
        make_fully_qualified (env, Absyn.IDENT(overloadname)) => fpath &
	make_fully_qualified (cenv, Absyn.IDENT(id)) => ovlfpath &
	let ty = ((Types.T_FUNCTION(args,tp),SOME(ovlfpath))) &
	Env.extend_frame_t(env, overloadname, ty) => env' &
	inst_overloaded_functions(env',overloadname,fns) => (env'', dae1) 	
	-----------------------------------------------------------------
	inst_overloaded_functions(env,overloadname,fn::fns) 
	  => (env'', DAE.FUNCTION(fpath, DAE.DAE(dae), ty)::dae1 )

  rule	Debug.fprint("failtrace", "inst_overloaded_functions failed\n" )
	--------------------------
	inst_overloaded_functions(env,_,_) => fail
end


(** relation: inst_ext_decl
 ** author: LS
 **
 ** This relation handles the external declaration. If there is an explicit 
 ** call of the external function, the component references are looked up and
 ** inserted in the argument list, otherwise the input and output parameters
 ** are inserted in the argument list with their order. The return type is
 ** determined according to the specification; if there is a explicit call 
 ** and a lhs, which must be an output parameter, the type of the function is
 ** that type. If no explicit call and only one output parameter exists, then
 ** this will be the return type of the function, otherwise the return type 
 ** will be void. 
 **)

relation inst_ext_decl: (Env.Env, Ident, SCode.ClassDef, bool (*impl*) ) => DAE.ExternalDecl =
	
  rule	is_ext_explicit_call (extdecl) &
	inst_ext_get_fname (extdecl, n) => fname &
	inst_ext_get_fargs (env, extdecl,impl) => fargs &
	inst_ext_get_rettype (env, extdecl,impl) => rettype &
	inst_ext_get_lang (extdecl) => lang &
	let daeextdecl = DAE.EXTERNALDECL(fname,fargs,rettype,lang)
	-------------------------------------
	inst_ext_decl (env, n, SCode.PARTS(_,_,_,_,_,SOME(extdecl)),impl) => daeextdecl

  rule	not is_ext_explicit_call (orgextdecl) &
	inst_ext_make_externaldecl (n, els, orgextdecl) => extdecl &
	inst_ext_get_fname (extdecl, n) => fname &
	inst_ext_get_fargs (env, extdecl,impl) => fargs &
	inst_ext_get_rettype (env, extdecl, impl) => rettype &
	inst_ext_get_lang (extdecl) => lang &
	let daeextdecl = DAE.EXTERNALDECL(fname,fargs,rettype,lang)
	-------------------------------------
	inst_ext_decl (env, n, SCode.PARTS(els,_,_,_,_,SOME(orgextdecl)),impl) => daeextdecl

  rule	Debug.fprint("failtrace",  "#-- inst_ext_decl failed" )
	--------------------------
	inst_ext_decl (env, _, _, _) => fail
end


(** relation: is_ext_explicit_call
 ** 
 ** If the external function id is present, then a function call must
 ** exist, i.e. explicit call was written in the external clause.
 **)

relation is_ext_explicit_call : Absyn.ExternalDecl => () =

  axiom is_ext_explicit_call Absyn.EXTERNALDECL(SOME(id),_,_,_,_)

end

(** relation: inst_ext_make_externaldecl
 ** author: LS
 **
 ** This relation generates a default explicit function call, 
 ** when it is omitted. If only one output variable exists, the 
 ** implicit call is equivalent to 
 ** 
 **    external "C" output_var=func(input_var1, input_var2,...)
 **
 ** with the input_vars in their declaration order. If several output 
 ** variables exists, the implicit call is equivalent to
 **
 **    external "C" func(var1, var2, ...)
 **
 ** where each var can be input or output.
 **)

relation inst_ext_make_externaldecl: (Ident, SCode.Element list, Absyn.ExternalDecl) 
	  => Absyn.ExternalDecl = 

  (* the case with only one output var, and that cannot be array, otherwise
      inst_ext_make_crefs outvar will fail *)
  rule	Util.list_matching (els, is_output_var) => outvar::[] &
	Util.list_matching (els, is_input_var) => invars &
	Util.list_map (invars, inst_ext_make_crefs) => explists &
	Util.list_flatten explists => exps &
	inst_ext_make_crefs outvar => [Absyn.CREF(retcref)] &
	let extdecl = Absyn.EXTERNALDECL(SOME(id),lang,SOME(retcref),exps,NONE)
	------------------------------------------------
	inst_ext_make_externaldecl (id, els, Absyn.EXTERNALDECL(_,lang,_,_,_)) 
	  => extdecl

  rule	Util.list_matching (els, is_inout_var) => inoutvars &
	Util.list_map (inoutvars, inst_ext_make_crefs) => explists &
	Util.list_flatten explists => exps &
	let extdecl = Absyn.EXTERNALDECL(SOME(id),lang,NONE,exps,NONE)
	------------------------------------------------
	inst_ext_make_externaldecl (id, els, Absyn.EXTERNALDECL(_,lang,_,_,_)) 
	  => extdecl

  rule	Debug.fprint("failtrace", "#-- inst_ext_make_externaldecl failed\n")
	---------------------------------------------------------
	inst_ext_make_externaldecl (_,_,_) => fail

end	

(** relation: is_inout_var 
 **
 ** Succeds for Elements that are input or output components
 **)

relation is_inout_var : SCode.Element => () =

  rule is_output_var e
       --------------
       is_inout_var e

  rule is_input_var e
       --------------
       is_inout_var e
end

(** relation: is_output_var
 **
 ** Succeds for element that is output component
**)

relation is_output_var : SCode.Element => () =
  axiom	is_output_var SCode.COMPONENT(_,_,_,_,SCode.ATTR(_,_,_,_,Absyn.OUTPUT),_,_,_,_)
end

(** relation: is_input_var
 **
 ** Succeds for element that is input component
 **)
relation is_input_var : SCode.Element => () =
  axiom	is_input_var SCode.COMPONENT(_,_,_,_,SCode.ATTR(_,_,_,_,Absyn.INPUT),_,_,_,_)
end

(** relation: inst_ext_make_crefs
 ** author: LS
 **
 ** This relation is used in external function declarations. It collects the 
 ** component identifier and the dimension sizes and returns as a 
 ** Absyn.Exp list
 **)

relation inst_ext_make_crefs : SCode.Element => Absyn.Exp list =

  rule	inst_ext_make_crefs_2 (id,dims,1) => sizelist &
	let crlist = Absyn.CREF(Absyn.CREF_IDENT(id,[]))::sizelist
	-----------------------------------------------
	inst_ext_make_crefs SCode.COMPONENT(id,fi,re,pr,SCode.ATTR(dims,_,_,_,_),path,mod,_,comment)
	  => crlist
end

(** relation: inst_ext_make_crefs_2
 **
 ** Helper relation to inst_ext_make_crefs, collects array dimension sizes.
 **)

relation inst_ext_make_crefs_2 : (SCode.Ident, Absyn.ArrayDim, int) => Absyn.Exp list =

  axiom	inst_ext_make_crefs_2 (id, [], _) => []

  rule	int_add(dimno,1) => nextdimno &
	inst_ext_make_crefs_2 (id, restdim, nextdimno) => restlist &
	let exps = Absyn.CALL(Absyn.CREF_IDENT("size",[]),
			      Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(id,[])),
						  Absyn.INTEGER(dimno)], []))::restlist
	---------------------------------------
	inst_ext_make_crefs_2 (id,dim::restdim,dimno) => exps

end


(** relation: inst_ex_get_fname
 ** 
 ** Returns the function name of the externally defined function.
 **)

relation inst_ext_get_fname : (Absyn.ExternalDecl, Ident) => Ident =

  axiom	inst_ext_get_fname (Absyn.EXTERNALDECL(SOME(id),_,_,_,_), fid) => id
  axiom	inst_ext_get_fname (Absyn.EXTERNALDECL(NONE,_,_,_,_), fid) => fid

end


(** relation: inst_ext_get_lang
 **
 ** Return the implementation language of the external function declaration
 ** Defaults to "C" if no language specified.
 **)

relation inst_ext_get_lang : Absyn.ExternalDecl => string =

  axiom	inst_ext_get_lang Absyn.EXTERNALDECL(_,SOME(lang),_,_,_) => lang

  axiom	inst_ext_get_lang Absyn.EXTERNALDECL(_,NONE,_,_,_) => "C"
end

(** relation: elab_exp_list_ext
 **
 ** special elab_exp for explicit external calls. This special relation calls 
 ** elab_exp_ext which handles size builtin calls specially, and uses the 
 ** ordinary  Static.elab_exp for other expressions.
 **)

relation elab_exp_list_ext : (Env.Env, Absyn.Exp list, bool,
			      Interactive.InteractiveSymbolTable option) =>
	(Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option) =

  axiom	elab_exp_list_ext (_,[],impl,st) => ([],[],st)

  rule	elab_exp_ext (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list_ext (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list_ext (env, e::rest,impl,st) => (exp::exps, p::props,st'') 

end

(** relation: elab_exp_ext
 ** author: LS
 **
 ** special elab_exp for explicit external calls. This special relation calls 
 ** elab_exp_ext which handles size builtin calls specially, and uses the 
 ** ordinary Static.elab_exp for other expressions.
 **)

relation elab_exp_ext : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

	  (* special case for  size*)
  rule	Static.elab_exp(env,dim,impl,NONE) 
	  => (dimp, Types.PROP(dimty,_),_) &
	Static.elab_exp(env,arraycr,impl,NONE) => (arraycrefe, arraycrprop,_) &
	let exp = Exp.SIZE(arraycrefe,SOME(dimp)) 
	----------------------------------------------------	
	elab_exp_ext (env,
		      call as Absyn.CALL(Absyn.CREF_IDENT("size",_),
					 Absyn.FUNCTIONARGS(args as [arraycr,dim],nargs)),impl,st) 
	  => (exp,Types.PROP((Types.T_INTEGER([]),NONE),Types.C_VAR),st)
	  (* For all other expressions, use normal elaboration*)  
  rule	Static.elab_exp (env,exp,impl,st) => (e,prop,st) 
	---------------------------------------------------
	elab_exp_ext (env,exp,impl,st) => (e,prop,st)

  rule	Debug.fprint("failtrace", "-elab_exp_ext failed\n")
	-------------------
	elab_exp_ext (env,exp,impl,st) => fail
end

(** relation: inst_ext_get_fargs
 ** author: LS
 **
 ** instantiates function arguments, i.e. actual parameters, in external 
 ** declaration.
 **)

relation inst_ext_get_fargs : (Env.Env, Absyn.ExternalDecl, bool (*impl*) ) => DAE.ExtArg list =

  rule	elab_exp_list_ext (env, absexps, impl, NONE) => (exps,props,_) &
	inst_ext_get_fargs2 (env, exps, props) => extargs	
	---------------------------------------------------------
	inst_ext_get_fargs (env, Absyn.EXTERNALDECL(id,lang,retcr,absexps,_),impl) => extargs

  rule	Debug.fprint("failtrace", "- inst_ext_get_fargs failed\n")
	-------------------------------------------------
	inst_ext_get_fargs (_,_,impl) => fail
	
end

(** relation: inst_ext_get_fargs2
 ** author: LS
 **
 ** Helper relation to inst_ext_get_fargs
 **)

relation inst_ext_get_fargs2 : (Env.Env, Exp.Exp list, Types.Properties list) 
	  => DAE.ExtArg list =

  axiom	inst_ext_get_fargs2 (_,[],_) => []

  rule	inst_ext_get_fargs2 (env,exps,props) => extargs &
	inst_ext_get_fargs_single (env,e,p) => extarg
	-----------------------------------------
	inst_ext_get_fargs2 (env, e::exps,p::props) => extarg::extargs
end

(** relation: inst_ext_get_fargs_single
 ** author: LS
 **
 ** Helper relation to inst_ext_get_fargs2, does the work for one argument.
 **)

relation inst_ext_get_fargs_single : (Env.Env, Exp.Exp, Types.Properties) 
	  => DAE.ExtArg =

  rule	Lookup.lookup_var_local (env, cref) => (attr, ty, bnd) 
	--------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.CREF(cref,crty), Types.PROP(ty,cnst)) => DAE.EXTARG(cref,attr,ty)

  rule	not Lookup.lookup_var_local (env, cref) => (attr, ty, bnd) &
	Print.print_buf "inst_ext_get_fargs_single lookup_var_local failed\n" &
	Exp.print_component_ref_str cref => crefstr &
	Util.string_append_list (["#-- Unknown component ", crefstr, " in external clause\n"]) => str &
	Print.print_error_buf str
	--------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.CREF(cref,crty), Types.PROP(ty,cnst)) => fail

  rule	Lookup.lookup_var_local (env, cref) => (attr, varty, bnd)
	------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.SIZE(Exp.CREF(cref,crty), SOME(dim)), Types.PROP(ty,cnst)) 
	  => DAE.EXTARGSIZE(cref,attr,varty,dim)
				   
  axiom	inst_ext_get_fargs_single (env, exp, Types.PROP(ty,cnst)) => DAE.EXTARGEXP(exp,ty)

  rule	Debug.fprint("failtrace", "#-- inst_ext_get_fargs_single failed\n") &
	Debug.fcall("failtrace", Exp.print_exp, exp) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------------
	inst_ext_get_fargs_single (_,exp,prop) => fail
end

(** relation: inst_ext_get_rettype
 ** author: LS
 **
 ** Instantiates the return type of an external declaration.
 **)

relation inst_ext_get_rettype : (Env.Env, Absyn.ExternalDecl, bool (*impl*) ) 
	  => DAE.ExtArg =

  axiom	inst_ext_get_rettype (_, Absyn.EXTERNALDECL(_,_,NONE,_,_),_) => DAE.NOEXTARG

  rule	Static.elab_cref (env,cref,impl) => (exp,prop,acc) &
	inst_ext_get_fargs_single (env, exp,prop) => extarg
	-----------------------------------------
	inst_ext_get_rettype (env,Absyn.EXTERNALDECL(n,lang,SOME(cref),args,_),impl) => extarg

  rule	Debug.fprint("failtrace", "#-- inst_ext_rettype failed\n")
	--------------------------------------------------------
	inst_ext_get_rettype (_,_,_) => fail

end

(** relation: inst_enumeration
 ** author: PA
 **
 ** This relation takes an 'Ident' and list of strings, and returns an 
 ** enumeration class.
**)

relation inst_enumeration: (SCode.Ident, string list) => SCode.Class =
  rule	make_enum_components(l) => comp
	--------------------------------
	inst_enumeration(n,l) => SCode.CLASS(n,false,false,SCode.R_ENUMERATION,SCode.PARTS(comp,[],[],[],[],NONE))
end

(** relation: make_enum_components
 ** author: PA
 **
 ** This relation takes a list of strings and returns the elements of 
 ** type 'EnumType' each corresponding to one of the enumeration values.
 **)

relation make_enum_components: string list => SCode.Element list =

  axiom make_enum_components ([str]) 
	  =>  [SCode.COMPONENT(str,true,false,false,SCode.ATTR([],false,SCode.RO,SCode.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD,NONE,NONE)]
	  
  rule	make_enum_components(x) => els
	----------------------------
	make_enum_components (str::(x as (_::_)))
	  => SCode.COMPONENT(str,true,false,false,SCode.ATTR([],false,SCode.RO,SCode.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD,NONE,NONE):: els
end

(** relation: dae_declare
 **
 ** Given a global component name, a type, and a set of attributes,
 ** this relation declares a component for the DAE result.  Altough
 ** this relation returns a list of `DAE.Element's, only one component
 ** is actually declared.
 **
 ** The relations `dae_declare2' and `dae_declare3' below are helper
 ** relations that perform parts of the task.
 **)

relation dae_declare : (Exp.ComponentRef,
			ClassInf.State,
			Types.Type, 
			SCode.Attributes, 
			Exp.Exp option,
			InstDims,
			DAE.StartValue,
			DAE.VariableAttributes option,
                        Absyn.Comment option) 
	  => DAE.Element list =

  rule	DAE.to_flow (flow,ci_state) => flow' &
	dae_declare2 (vn, ty, flow', par, dir, e, inst_dims, start,dae_var_attr,comment) => dae
	-----------------------------------
	dae_declare (vn, ci_state,ty, SCode.ATTR(_,flow,_,par,dir), e, inst_dims,start,dae_var_attr,comment) 
	  => dae

  rule	Debug.fprint("failtrace", "- dae_declare failed\n")
	------------------------------
	dae_declare(_,_,_,_,_,_,_,_,_) => fail

end

(** relation: dae_declare2
 ** 
 ** Helper relation to dae_declare.
 **)

relation dae_declare2 : (Exp.ComponentRef, Types.Type, DAE.Flow, 
			 SCode.Variability,
			 Absyn.Direction, Exp.Exp option, 
			 InstDims, DAE.StartValue,
			 DAE.VariableAttributes option,
                        Absyn.Comment option)
	  => DAE.Element list =

  rule	dae_declare3 (vn, ty, flow, DAE.VARIABLE, dir, e, 
		      inst_dims,start, dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.VAR, dir, e, inst_dims,start,dae_var_attr,comment) => dae

  rule	dae_declare3 (vn, ty, flow,  DAE.DISCRETE, dir, e,  
		      inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.DISCRETE, dir, e, inst_dims,start,dae_var_attr,comment) => dae

  rule	dae_declare3 (vn, ty, flow, DAE.PARAM, dir, e,  
		      inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.PARAM, dir, e, inst_dims,start,dae_var_attr,comment) 
	  => dae

  rule	dae_declare3 (vn, ty, flow, DAE.CONST, dir, e,  
		      inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.CONST, dir, e, inst_dims,start,dae_var_attr,comment) 
	  => dae

  rule	dae_declare3 (vn, ty, flow, DAE.PARAM, dir, e, 
		      inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.STRUCTPARAM, dir, e, inst_dims,start,dae_var_attr,comment) 
	  => dae

  rule	Debug.fprint("failtrace", "- dae_declare2 failed\n")
	------------------------------
	dae_declare2(_,_,_,_,_,_,_,_,_,_) => fail

end

(** relation: dae_declare3
 ** 
 ** Helper relation to dae_declare2.
 **)

relation dae_declare3 : (Exp.ComponentRef, Types.Type, DAE.Flow, DAE.VarKind,
			 Absyn.Direction, Exp.Exp option, 
			 InstDims, DAE.StartValue,DAE.VariableAttributes option,
                        Absyn.Comment option)
	  => DAE.Element list =

  rule	dae_declare4 (vn, ty, fl, vk, DAE.INPUT, e, inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, fl, vk, Absyn.INPUT, e, inst_dims,start,dae_var_attr,comment) 
	  => dae

  rule	dae_declare4 (vn, ty, fl, vk, DAE.OUTPUT, e, inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, fl, vk, Absyn.OUTPUT, e, inst_dims,start,dae_var_attr,comment) => dae

  rule	dae_declare4 (vn, ty, fl, vk, DAE.BIDIR, e, inst_dims,start,dae_var_attr,comment) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, fl, vk, Absyn.BIDIR, e, inst_dims,start,dae_var_attr,comment) => dae

  rule	Debug.fprint("failtrace", "#- dae_declare3 failed\n")
	------------------------------
	dae_declare3(_,_,_,_,_,_,_,_,_,_) => fail

end

(** relation: dae_declare4
 ** 
 ** Helper relation to dae_declare3.
 **)

relation dae_declare4 : (Exp.ComponentRef, Types.Type, DAE.Flow, DAE.VarKind,
			 DAE.VarDirection, Exp.Exp option, InstDims, 
			 DAE.StartValue,DAE.VariableAttributes option,
                        Absyn.Comment option)
	  => DAE.Element list =

  axiom	dae_declare4 (vn, (Types.T_INTEGER(_),_), fl, kind, dir, e,  
		      inst_dims,start,dae_var_attr,comment)
	  => [DAE.VAR(vn, kind, dir, DAE.INT, e,  inst_dims,start,fl,[],dae_var_attr,comment)]
	
  axiom	dae_declare4 (vn, (Types.T_REAL(_),_), fl, kind, dir, e, 
		      inst_dims,start,dae_var_attr,comment)
	  => [DAE.VAR(vn, kind, dir, DAE.REAL, e, inst_dims,start,fl,[],dae_var_attr,comment)]

  axiom	dae_declare4 (vn, (Types.T_BOOL(_),_), fl, kind, dir, e, 
		      inst_dims,start,dae_var_attr,comment)
	  => [DAE.VAR(vn, kind, dir, DAE.BOOL, e, inst_dims,start,fl,[],dae_var_attr,comment)]
	
  axiom	dae_declare4 (vn, (Types.T_STRING(_),_), fl, kind, dir, e, 
		      inst_dims,start,dae_var_attr,comment)
	  => [DAE.VAR(vn, kind, dir, DAE.STRING, e, inst_dims,start,fl,[],dae_var_attr,comment)]

  axiom dae_declare4 (vn, (Types.T_ENUM,_), fl, kind, dir, e, inst_dims,start,dae_var_attr,comment)
	=> []
	(* We should not declare each enumeration value of an enumeration when instantiating,e.g Myenum my !=> constant EnumType my.enum1,... *)
	(*[DAE.VAR(vn, kind, dir, DAE.ENUM, e, inst_dims)]*)

  axiom	dae_declare4 (vn, (Types.T_ENUMERATION(l,_),_), fl, kind, dir, e,
		      inst_dims,start,dae_var_attr,comment)
	  => [DAE.VAR(vn, kind, dir, DAE.ENUMERATION(l), e, inst_dims,start,fl,[],dae_var_attr,comment)]

  axiom	dae_declare4 (c,ty,_,_,_,_,_,_,_,_) => []

end

(** relation inst_equation
 ** author: LS, ELN
 **
 ** Instantiates an equation by calling inst_equation_common with Inital set 
 ** to NON_INITIAL. 
 **)

relation inst_equation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.Equation, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	(* Equation inherited from base class *)
	get_derived_env(env,bc) => env' &
	inst_equation_common (env',mods,pre,csets,ci_state,eq,NON_INITIAL,impl)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_equation (env,mods,pre,csets,ci_state,SCode.EQUATION(eq,bc),impl)
	  => (dae,env,csets',ci_state')

  rule	Debug.fprint("failtrace", "- inst_equation failed\n")
	----------------------------------
	inst_equation (_,_,_,_,_,_,impl) => fail

end


(** relation: inst_e_equation
 **
 ** Instantiation of EEquation, used in for loops and if-equations.
 **)

relation inst_e_equation: (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.EEquation, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_equation_common (env,mods,pre,csets,ci_state,eq,NON_INITIAL,impl)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_e_equation (env,mods,pre,csets,ci_state,eq,impl)
	  => (dae,env,csets',ci_state')
end

(** relation: inst_initialequation
 ** author: LS, ELN
 **
 ** Instantiates initial equation by calling inst_equation_common with Inital 
 ** set to INITIAL.
 **)

relation inst_initialequation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.Equation, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	(* Equation inherited from base class *)
	get_derived_env(env,bc) => env' &
	inst_equation_common (env',mods,pre,csets,ci_state,eq,INITIAL,impl)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_initialequation (env,mods,pre,csets,ci_state,SCode.EQUATION(eq,bc),impl)
	  => (dae,env,csets',ci_state')

  rule	Debug.fprint("failtrace", "- inst_initialequation failed\n")
	----------------------------------
	inst_initialequation (_,_,_,_,_,_,impl) => fail

end

(** relation: inst_e_initialequation
 **
 ** Instantiates initial EEquation used in for loops and if equations 
 **)

relation inst_e_initialequation : (Env,Mod, Prefix, Connect.Sets, 
				   ClassInf.State,
				 SCode.EEquation, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_equation_common (env,mods,pre,csets,ci_state,eq,INITIAL,impl)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_e_initialequation (env,mods,pre,csets,ci_state,eq,impl)
	  => (dae,env,csets',ci_state')
end

(** relation: inst_equation_common
 **
 ** The DAE output of the translation contains equations which
 ** in most cases directly corresponds to equations in the source.
 ** Some of them are also generated from `connect' clauses.
 **
 ** This relation takes an equation from the source and generates DAE
 ** equations and connection sets.
 ** 
 **)

relation inst_equation_common : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.EEquation, Initial, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

	(**  
	 ** Handle connect statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2,impl) => (csets',dae) &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	------------------------------------------------------------
	inst_equation_common(env,mods,pre, csets, ci_state, 
			     SCode.EQ_CONNECT(c1,c2), 
			     initial,impl)
	  => (dae,env,csets',ci_state')
	  
	(** The following rule handles shadowed (replaced) equations. *)
	(** If an equation has a simple name on the left-hand side, *)
	(** and that component has an equation modifier, this equation *)
	(** is discarded. *)
  rule	Lookup.lookup_ident_local(env,n)
	  => (Types.VAR(_,_,_,_,Types.EQBOUND(_,_,_)),_,_,_) &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	------------------------------------------------------
	inst_equation_common(env,mods,pre,csets,ci_state,
			     SCode.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2),
			     initial,impl)
	  => ([],env,csets,ci_state')

  rule	(* 
	 Do static analysis and constant evaluation of expressions. 
	 Gives expression and properties 
	 (Type * bool | (Type * Const as (bool | Const list))).
	 For a function, it checks the funtion name. 
	 Also the function call's in parameters are type checked with
	 the functions definition's inparameters. This is done with
	 regard to the position of the input arguments.

	 Returns the output parameters from the function.
	*)

	Static.elab_exp(env,e1,impl,NONE) => (e1',prop1,c1) &
	Static.elab_exp(env,e2,impl,NONE) => (e2',prop2,c2) &

	Prefix.prefix_exp(env,e1',pre) => e1'' &
	Prefix.prefix_exp(env,e2',pre) => e2'' &

	(* Check that the lefthandside and the righthandside get along. *)
	inst_eq_equation(e1'',prop1,e2'',prop2,initial,impl) => dae &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' 
	--------------------------------------------------------------
	inst_equation_common(env, mods, pre, csets, ci_state,
			     SCode.EQ_EQUALS(e1,e2), 
			     initial,impl)
	  => (dae, env, csets, ci_state')

	(**  `if' statements
	 **
	 ** If statements are instantiated by evaluating the
	 ** conditional expression, and selecting the branch that
	 ** should be used.
	 **)


	(** EQ_IF. When the condition is constant evaluate it and 
	 ** select the correct branch **)
  rule	Static.elab_exp(env,e,impl,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),_),_) &
	Ceval.ceval(env,e',impl,NONE,NONE,Ceval.NO_MSG) => (Values.BOOL(cond),_) &
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, b,impl)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     NON_INITIAL,impl)
	  => (dae,env',csets', ci_state')

	(** initial EQ_IF. When the condition is constant evaluate it and 
	 ** select the correct branch **)
  rule	Static.elab_exp(env,e,impl,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),_),_) &
	Ceval.ceval(env,e',impl,NONE,NONE,Ceval.NO_MSG) => (Values.BOOL(cond),_) &
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_e_initialequation, b,impl)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     INITIAL,impl)
	  => (dae,env',csets', ci_state')

	  (* IF_EQUATION *)
  rule	Static.elab_exp(env,e,impl,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),Types.C_VAR),_) &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, tb,impl)
	  => (dae1,env',_, ci_state') &  (* There are no connections inside if-clauses. *)
	inst_list(env',mod,pre,csets,ci_state,inst_e_equation, fb,impl)
	  => (dae2,env'',_, ci_state'')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     NON_INITIAL,impl)
	=> ([DAE.IF_EQUATION(e',dae1,dae2)],env',csets, ci_state')

	  (* Initial IF_EQUATION *)
  rule	Static.elab_exp(env,e,impl,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),Types.C_VAR),_) &
	inst_list(env,mod,pre,csets,ci_state,inst_e_initialequation, tb,impl)
	  => (dae1,env',_, ci_state') &  (* There are no connections inside if-clauses. *)
	inst_list(env',mod,pre,csets,ci_state,inst_e_initialequation, fb,impl)
	  => (dae2,env'',_, ci_state'')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     INITIAL,impl)
	=> ([DAE.INITIAL_IF_EQUATION(e',dae1,dae2)],env',csets, ci_state')

	(**  `when equation' statement, modelica 1.1 
	 **
	 ** When statements are instantiated by evaluating the
	 ** conditional expression.
	 **)

rule	Static.elab_exp (env,e,impl,NONE) => (e',_,_) &
	Prefix.prefix_exp(env,e',pre) => e'' &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, el, impl) => (dae1,env',_,_) &
	inst_equation_common(env',mod,pre,csets,ci_state,SCode.EQ_WHEN(ee,eel,eex),initial,impl) 
	  => (dae2::_, env'',_,ci_state') &
         inst_equation_common_ci_trans (ci_state', initial) => ci_state''
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el, (ee,eel)::eex),   
			     initial as NON_INITIAL,impl)
	=> ([DAE.WHEN_EQUATION(e'',dae1,SOME(dae2))], env'',csets, ci_state'')


rule	Static.elab_exp (env,e,impl,NONE) => (e',_,_) &
	Prefix.prefix_exp(env,e',pre) => e'' &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, el, impl) => (dae1,env',_,_) &
         inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el,[]),   
			     initial as NON_INITIAL,impl)
	  => ([DAE.WHEN_EQUATION(e'',dae1,NONE)], env', csets, ci_state')

(* seems unnecessary to handle when equations that are initial *) 


	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **
	 **)

	(** FIXME: Why lookup after add_for_loop_scope ? **)

  rule	(*Debug.fprintln ("insttr", "inst_equation_common_eqfor_1") &*)

	Static.elab_exp (env,e,impl,NONE)
	  => (e',Types.PROP((Types.T_ARRAY(Types.DIM(_),
					   id_t),_),
			     _),_) &
	(*Debug.fprintln ("insti", "for expression elaborated") &*)
	add_for_loop_scope(env,i,id_t) => env' &
(*	Debug.fprintln ("insti", "loop-variable added to scope") &*)
	Lookup.lookup_var(env', Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      (Types.T_INTEGER(_),_), Types.UNBOUND) &
(*	Debug.fprintln ("insti", "loop variable looked up") &*)
	
	(* FIXME: Check bounds *)
	Ceval.ceval (env,e',impl,NONE,NONE,Ceval.MSG) => (v,_) &
(*	Debug.fprintln ("insti", "for expression evaluated") &*)
	unroll(env',mod,pre,csets,ci_state,i,v,el,initial,impl) => (dae, csets') &
(*	Debug.fprintln ("insti", "for expression unrolled") &*)
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' 
(*	& Debug.fprintln ("insttr", "inst_equation_common_eqfor_1 succeeded")*)
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial,impl)
	  => (dae, env,csets', ci_state')

  rule	(* for loops with non-constant iteration bounds *)
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      (Types.T_INTEGER(_),_), Types.UNBOUND) &
	Static.elab_exp (env,e,impl,NONE)
	  => (e',Types.PROP((Types.T_ARRAY(Types.DIM(_),
					   (Types.T_INTEGER(_),_)),_),
			     Types.C_VAR),_) &
	Print.print_error_buf "# Error: Non-constant iteration bounds not supported\n" 
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial,impl)
	  => fail

  rule	(* assert statement *)
	Static.elab_exp(env,e1,impl,NONE) 
	  => (e1', Types.PROP((Types.T_BOOL(_),_),_),_) &
	Static.elab_exp(env,e2,impl,NONE) 
	  => (e2', Types.PROP((Types.T_STRING(_),_),_),_)
	-------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state, SCode.EQ_ASSERT(e1,e2),initial,impl)
	  => ([DAE.ASSERT(Exp.CALL(Absyn.IDENT("assert"),
				     [e1',e2'],false,false))], 
	      env, csets, ci_state)

  rule (* reinit statement *)
	Static.elab_cref(env,cr,impl) => (Exp.CREF(cr',_),_,_) &
         Static.elab_exp(env,e2,impl,NONE) => (e2',_,_)
	-------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state, SCode.EQ_REINIT(cr,e2),initial,impl)
          => ([DAE.REINIT(cr',e2')], env, csets, ci_state)

  rule	Debug.fprint("failtrace", "- inst_equation_common failed for eqn: ") &
	SCode.equation_str(eqn) => s & 
	Debug.fprint("failtrace", s) &
	Debug.fprint("failtrace", "\n") 
	----------------------------------
	inst_equation_common(_,_,_,_,_,eqn,_,impl) => fail
end


(** relation: inst_equation_common_ci_trans
 ** 
 ** updats The ClassInf state machine when an equation is instantiated.
 **)

relation inst_equation_common_ci_trans : (ClassInf.State, Initial)
	  => ClassInf.State = 

  rule	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	---------------------------------------------------------------
	inst_equation_common_ci_trans (ci_state, NON_INITIAL) => ci_state'

  axiom	inst_equation_common_ci_trans (ci_state, INITIAL) => ci_state

end

(** relation: add_for_loop_scope
 ** author: HJ
 **
 ** Adds a scope on the environment used in for loops.
 ** The name of the scope is for_scope_name, defined as a value.
 **)

relation add_for_loop_scope : (Env.Env, Ident, Types.Type) => Env.Env =

  rule	Env.open_scope (env,false,SOME(for_scope_name)) => env' &
	Env.extend_frame_v(env',
			   Types.VAR(i,
				     Types.ATTR(false,
						SCode.RW,
						SCode.VAR,
						Absyn.BIDIR),
				     false,
				     typ, 
				     Types.UNBOUND),NONE,false,[] (* comp env *)
			   ) => env''
	---------------
	add_for_loop_scope(env, i,typ) => env''

end

(** relation: is_parameter
 ** author: LS
 ** 
 ** Succeeds if a variable is a parameter.
 **)
relation is_parameter : (Exp.ComponentRef, Env.Env) => () =

  rule	(*Env.print_env env &*)
	Lookup.lookup_var (env, cr) 
	  => (Types.ATTR(fl, acc, SCode.PARAM,dir), ty, bnd)
	----------------------------------------------------
	is_parameter (cr, env)

end 


(** relation: inst_eq_equation
 ** author: LS, ELN
 **
 ** Equations follow the same typing rules as equality expressions.
 ** This relation adds the equation to the DAE.
 **
 **)

relation inst_eq_equation : (Exp.Exp, Types.Properties,
			     Exp.Exp, Types.Properties, Initial, bool (*impl*) ) => DAE.Element list =
	(*PR. e1= lefthandside, e2=righthandside
	* This seem to be a strange relation. 
	* wich rule is matched? or is both rules matched?
	*)

        (* LS: Static.type_convert in Static.match_prop can probably fail,
	 * then the first rule will not match. Question if whether the second
	 * rule can match in that case.
	 *)
	
	(* This rule is matched first, if it fail the next rule is matched.
	 *)
  rule	(*Debug.print("\ninst_eq_equation (match e1) PROP, PROP") &*)
	Types.match_prop(e1, p1, p2) => e1' &
	inst_eq_equation_2(e1', e2, t2, initial) => dae 

	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP(t1,_),
			 e2,p2 as Types.PROP(t2,_), initial,impl)
	  => dae

	(* If it fails then this rule is matched. *)
  rule	(*Debug.print("\ninst_eq_equation (match e2) PROP, PROP") &*)
	Types.match_prop(e2, p2, p1) => e2'&
(*	Debug.print("\n Second rule of relation_ inst_eq_equation ") &*)
	inst_eq_equation_2(e1, e2', t1, initial) => dae 
(*	& Debug.print("\n Second rule complete. ") *)
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP(t1,_),
			 e2,p2 as Types.PROP(t2,_), initial,impl)
	  => dae

  rule	(* Debug.print("\ninst_eq_equation(e1) PROP_TUPLE, PROP_TUPLE") &*)
	(*Exp.print_exp (e1) & *)
	Types.match_prop(e1, p1, p2) => e1' &
	(*Exp.print_exp (e1') & *)
	inst_eq_equation_2(e1', e2, t2, initial) => dae 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,p2 as Types.PROP_TUPLE(t2,_), initial,impl)
	  => dae

	(* PR. *)	
  rule	(*Debug.print("\ninst_eq_equation(e2) PROP_TUPLE, PROP_TUPLE") &
	Debug.print "\n About to do a static match e2. " &*)
	Types.match_prop(e2, p2, p1) => e2'&
(*	Debug.print("\n Second rule of relation_ inst_eq_equation ") &*)
	inst_eq_equation_2(e1, e2', t1, initial) => dae 
(*	& Debug.print("\n Second rule complete. ") *)
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,p2 as Types.PROP_TUPLE(t2,_), initial,impl)
	  => dae

	  (**
	   ** An assignment to a varaible of T_ENUMERATION type is an explicit 
	   ** assignment to the value componnent of the enumeration, i.e. having 
	   ** a type T_ENUM
	   **)
	
  rule	(*Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM or T_ENUMERATION.\n") &*)
	inst_eq_equation_2(e1,e2,t,initial) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Types.PROP((Types.T_ENUMERATION(_,_),_),_),
	    e2,Types.PROP(t as (Types.T_ENUM,_),_), initial,impl) => dae

  rule	(*Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM or T_ENUMERATION.\n") &*)
	inst_eq_equation_2(e1,e2,t,initial) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Types.PROP((Types.T_ENUMERATION(_,_),_),_),
	    e2,Types.PROP(t as (Types.T_ENUMERATION(_,_),_),_), initial,impl) => dae


  rule	(* Types.equivtypes(t1,t2) => false & *)
	Print.print_error_buf "# Illegal types in equation\n"&
	Print.print_error_buf "    lhs: " & Exp.print_exp_str e1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " :: " & 
	Types.unparse_type t1 => str &	Print.print_error_buf str &
	Print.print_error_buf "\n" &
	Print.print_error_buf "    rhs: " & 
	Exp.print_exp_str e2 => str &	Print.print_error_buf str &
	Print.print_error_buf " :: " & 
	Types.unparse_type t2  => str &	Print.print_error_buf str &
	Print.print_error_buf "\n"
	----------
	inst_eq_equation(e1,Types.PROP(t1,_), e2,Types.PROP(t2,_), initial,impl) => fail


(* No match. *)
  rule	Print.print_error_buf "# No match in inst_eq_equation\n" &
	Print.print_error_buf "    lhs: " & Exp.print_exp_str e1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " :: " & 
	Types.print_prop_str p1 => str & Print.print_error_buf str &
	Print.print_error_buf "\n" &
	Print.print_error_buf "    rhs: " & 
	Exp.print_exp_str e2 => str &	Print.print_error_buf str &
	Print.print_error_buf " :: " & 
	Types.print_prop_str p2  => str & Print.print_error_buf str &
	Print.print_error_buf "\n"
	---------------------------------	
	inst_eq_equation(e1,p1,e2,p2,initial,impl) => fail
end

(** relation: inst_eq_equation_2
 ** author: LS, ELN
 **
 ** This is the second stage of `inst_eq_equation', when the types are
 ** checked.
 **)

relation inst_eq_equation_2 : (Exp.Exp, Exp.Exp, Types.Type, Initial)
	=> DAE.Element list =

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_INTEGER(_),_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_REAL(_),_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_STRING(_),_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_BOOL(_),_),initial) => [dae]

  rule	make_dae_define (cr,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(Exp.CREF(cr,t),e2,(Types.T_ENUM,_),initial) => [dae]

  rule	make_dae_define (cr,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(Exp.CREF(cr,t),e2,(Types.T_ENUMERATION(_,_),_),initial) => [dae]


  rule	(*RTOpts.split_arrays => true &*)
	Exp.contain_functioncall(e1) => false &
	Exp.contain_functioncall(e2) => false &
(*	 For debugging.*)
(*	Print.print_buf "  Array equation: " &
	Exp.print_exp e1 & Print.print_buf " = " &
	Exp.print_exp e2 & Print.print_buf "\n" & *)
	inst_array_equation(e1,e2,ad,t,initial) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_ARRAY(ad,t),_),initial) => dae


	(* PR. The muliple outputs from functions is outputed as is. *)

  rule	make_dae_equation (e1,e2,initial) => dae 
	----------------------------------------
	inst_eq_equation_2 (e1,e2,(Types.T_TUPLE(_),_),initial) => [dae]


  rule	(*RTOpts.split_arrays => false &*)
	make_dae_equation (e1, e2, initial) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_ARRAY(ad,t),_),initial) => [dae]

  axiom	inst_eq_equation_2(e1, e2, (Types.T_COMPLEX(_,[]),_), initial) => []

  rule	Exp.extend_cref(c1,n,[]) => c1' &
	Exp.extend_cref(c2,n,[]) => c2' &
	inst_eq_equation_2(Exp.CREF(c1',t1), Exp.CREF(c2',t2), t, initial) => dae1 &
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   (Types.T_COMPLEX(cs,vs),p), initial) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   (Types.T_COMPLEX(cs,Types.VAR(n,_,_,t,_)::vs),p), initial) => dae

	(** When the type of the expressions is a complex type, and *)
	(** the left-hand side of the equation is not a component *)
	(** reference, a new variable is introduced to be able to *)
	(** dereference components of the expression. *)
	(** *)
	(** This is rather ugly, since it doesn't really solve the *)
	(** problem of describing the semantics.  Now the semantics of *)
	(** composite equations are defined in terms of other *)
	(** composite equations.  To make this a little cleaner, the *)
	(** equation that equates the new name to the expression is *)
	(** stored using DAE.DEFINE rather than DAE.EQUATION.  This *)
	(** makes it a little clearer. *)
  rule	new_ident => n &

	dae_declare(n,ClassInf.UNKNOWN(""), t, SCode.ATTR([], false, SCode.RW,
				     SCode.VAR, Absyn.BIDIR), NONE,[],NONE,NONE,NONE)
	  => decl &
	inst_eq_equation_2(Exp.CREF(n,Exp.OTHER), e2, t, initial) => dae1 &
	list_append(decl, DAE.DEFINE(n, e1)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2 as Exp.CREF(_,_),
			   t as (Types.T_COMPLEX(_,_),_), initial) => dae

	(** When the right-hand side is not a component reference a *)
	(** similar trick is applied.  This also catched the case *)
	(** where none of the sides is a component reference *)
  rule	new_ident => n &
	dae_declare(n, ClassInf.UNKNOWN(""),t, SCode.ATTR([], false, SCode.RW,
				     SCode.VAR, Absyn.BIDIR), NONE,[],NONE,NONE,NONE)
	  => decl &
	inst_eq_equation_2(e1, Exp.CREF(n,Exp.OTHER), t, initial) => dae1 &
	list_append(decl, DAE.DEFINE(n, e2)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2, t as (Types.T_COMPLEX(_,_),_), initial) => dae

  rule	Debug.fprint("failtrace", "- inst_eq_equation_2 failed\n exp1=") &
	Debug.fcall("failtrace",Exp.print_exp, e1) &
	Debug.fprint("failtrace", " exp2=" ) &
	Debug.fcall("failtrace",Exp.print_exp, e2) &
	Debug.fprint("failtrace", " type =") &
	Debug.fcall("failtrace",Types.print_type, t) &
	Debug.fprint("failtrace", "\n")
	-------------------------------------
	inst_eq_equation_2(e1,e2,t,initial) => fail

end

(** relation: make_dae_equation
 ** author: LS, ELN 
 **
 ** Constructs an equation in the DAE, they can be either an initial equation 
 ** or an ordinary equation.
**)

relation make_dae_equation : (Exp.Exp, Exp.Exp, Initial) => DAE.Element =

  axiom	make_dae_equation (e1,e2,NON_INITIAL) => DAE.EQUATION(e1,e2)

  axiom	make_dae_equation (e1,e2,INITIAL) => DAE.INITIALEQUATION(e1,e2)

end

(** relation: make_dae_define
 ** author: LS, ELN 
 **
 **)

relation make_dae_define : (Exp.ComponentRef, Exp.Exp, Initial) => DAE.Element = 

  axiom	make_dae_define (cr, e2, NON_INITIAL) => DAE.DEFINE(cr,e2)

  axiom	make_dae_define (cr, e2, INITIAL) => DAE.INITIALDEFINE(cr,e2)

end

(** relation: inst_array_equation
 **
 ** This checks the array size and uses `inst_array_el_eq' to create
 ** equations for each array element.
 **)

relation inst_array_equation : (Exp.Exp, Exp.Exp,
				Types.ArrayDim, Types.Type, Initial)
	  => DAE.Element list =

  rule	Print.print_error_buf "# Cannot instantiate equations with arrays of unknown size\n" &
	Print.print_error_buf "    " & Exp.print_exp_str e1 => str  & 
	Print.print_error_buf str &
	Print.print_error_buf " = " & Exp.print_exp_str e2 => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n"
	----------
	inst_array_equation(e1, e2, Types.DIM(NONE), t, initial) => fail

  rule	inst_array_el_eq(e1, e2, t, 1, sz, initial) => dae
	---------------------------------------------
	inst_array_equation(e1, e2, Types.DIM(SOME(sz)), t, initial) => dae

  rule	Debug.fprint("failtrace", "- inst_array_equation failed\n")
	--------------------------------------
	inst_array_equation (_,_,_,_,_) => fail

end

(** relation: inst_array_el_eq
 **
 ** This relation loops recursively through all indexes in the two
 ** arrays and generates an equation for each pair of elements.
 **)

relation inst_array_el_eq : (Exp.Exp, Exp.Exp, Types.Type, int, int, Initial)
	  => DAE.Element list =

  rule	int_le(i,sz) => true &
	Exp.simplify(Exp.ASUB(e1,i)) => e1' &
	Exp.simplify(Exp.ASUB(e2,i)) => e2' &
	inst_eq_equation_2(e1',e2',t,initial) => dae1 &
	int_add(i,1) => i' &
	inst_array_el_eq(e1,e2,t,i',sz,initial) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_array_el_eq(e1, e2, t, i, sz, initial) => dae

  rule	int_le(i,sz) => false
	---------------------
	inst_array_el_eq(e1, e2, t, i, sz, initial) => []

  rule	Debug.fprint("failtrace", "- inst_array_el_eq failed\n")
	-----------------------------------
	inst_array_el_eq(_,_,_,_,_,_) => fail

end

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, SCode.EEquation list, Initial, bool (*impl*) )
	  => (DAE.Element list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_,_,_) => ([], csets)

  rule	Env.open_scope (env,false,SOME(for_scope_name)) => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    SCode.CONST,
						    Absyn.BIDIR),
				      true,
				      (Types.T_INTEGER([]),NONE),
				      Types.VALBOUND(fst)),NONE,false,[](*comp env*))
	  => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_e_equation, eqs, impl)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs,
		initial, impl)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs,initial as NON_INITIAL,impl)
	  => (dae, csets'')

  rule	Env.open_scope (env, false,SOME(for_scope_name)) => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    SCode.CONST,
						    Absyn.BIDIR),
				      true,
				      (Types.T_INTEGER([]),NONE),
				      Types.VALBOUND(fst)),NONE,false,[](*comp env*))
	  => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_e_initialequation, eqs, impl)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs,
		initial, impl)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs,initial as INITIAL, impl)
	  => (dae, csets'')

  rule	Debug.fprint("failtrace",  "- unroll ") & 
	Debug.fcall("failtrace", Values.print_val, v) &
	Debug.fprint("failtrace", " failed\n")
	-------------------------
	unroll (_,_,_,_,_,_,v,_,_,_) => fail

end

(** relation: inst_algorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	(* If algorithm is inherited, find base class environment*)
	get_derived_env(env,bc) => env' &
	inst_statements(env',statements,impl) => statements'
	----------------------------------------------
	inst_algorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements,bc),impl)
	  => ([DAE.ALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	Debug.fprint("failtrace", "- inst_algorithm failed\n")
	---------------------------------
	inst_algorithm(_,_,_,_,_,_,_) => fail

end

(** relation: inst_initialalgorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_initialalgorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm, bool (*impl*) )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	get_derived_env(env,bc) => env' &
	inst_statements(env,statements,impl) => statements'
	----------------------------------------------
	inst_initialalgorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements,bc),impl)
	  => ([DAE.INITIALALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	Debug.fprint("failtrace", "- inst_algorithm failed\n")
	---------------------------------
	inst_initialalgorithm(_,_,_,_,_,_,_) => fail

end

(** relation: inst_statements
 **
 ** This relation converts a list of algorithm statements.
 **)

relation inst_statements : (Env, Absyn.Algorithm list, bool (*impl*) )
	  => Algorithm.Statement list =

  axiom	inst_statements(env,[],impl) => []

  rule	inst_statement(env,x,impl) => x' &
	inst_statements(env,xs,impl) => xs'
	------------------------------
	inst_statements(env,x::xs,impl) => x'::xs'
end


(** relation: inst_algorithmitems
 **
 ** Helper relation to inst_statement.
 **)

relation inst_algorithmitems : (Env, Absyn.AlgorithmItem list, bool (*impl*) )
	  => Algorithm.Statement list =

  axiom	inst_algorithmitems(env,[],impl) => []

  rule	inst_statement(env,x,impl) => x' &
	inst_algorithmitems(env,xs,impl) => xs'
	------------------------------
	inst_algorithmitems(env,Absyn.ALGORITHMITEM(x,_)::xs,impl) => x'::xs'

  rule	inst_algorithmitems(env,xs,impl) => xs'
	------------------------------
	inst_algorithmitems(env,Absyn.ALGORITHMITEMANN(_)::xs,impl) => xs'

end


(** relation: inst_statement
 **
 ** This relation Looks at an algorithm statement and uses relations
 ** in the `Algorithm' module to build a representation of it that can
 ** be used in the DAE output.
 **)

relation inst_statement : (Env, Absyn.Algorithm, bool (*impl*) ) => Algorithm.Statement =

  rule	Static.elab_cref (env,cr,impl) => (Exp.CREF(ce,t), cprop, acc) &
	Static.canon_cref (env,ce,impl) => ce' & 
	Static.elab_exp (env,e,impl,NONE) => (e', eprop,_) &
	Algorithm.make_assignment(Exp.CREF(ce',t),cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e),impl) => stmt

  rule	Static.elab_cref (env,cr,impl) => (ce, cprop, acc) &
	Static.elab_exp (env,e,impl,NONE) => (e', eprop,_) &
	Algorithm.make_assignment(ce,cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e),impl) => stmt

  rule	Static.elab_exp (env,e,impl,NONE) => (e' as Exp.CALL(_,_,_,_), eprop, _) &
	Static.elab_exp_list(env, expl, impl, NONE) 
	  => (expl', cprops, _) &
	Algorithm.make_tuple_assignment(expl',cprops,e',eprop) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(expl),e),impl) => stmt

  rule	Print.print_error_buf "#Error, tuple assignment only allowed when rhs is function call.\n" 
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(expl),e),impl) => fail

  rule	Static.elab_exp(env,e,impl,NONE) => (e',prop,_) &
	inst_algorithmitems(env,tb,impl) => tb' &
	inst_elseifs(env,eib,impl) => eib' &
	inst_algorithmitems(env,fb,impl) => fb' &
	Algorithm.make_if(e',prop,tb',eib',fb') => stmt
	--------------------------------------------
	inst_statement(env,Absyn.ALG_IF(e,tb,eib,fb),impl) => stmt

  rule	Static.elab_exp (env,e,impl,NONE)  =>
	(e', prop as Types.PROP((Types.T_ARRAY(_,t),_),_),_) &
	
	add_for_loop_scope(env,i,t) => env' &
	
	inst_algorithmitems(env',sl,impl) => sl' &
	Algorithm.make_for(i,e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_FOR(i,e,sl),impl) => stmt

  rule	Static.elab_exp (env,e,impl,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl,impl) => sl' &
	Algorithm.make_while(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHILE(e,sl),impl) => stmt


  rule	Static.elab_exp (env,e,impl,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl,impl) => sl' &
	Algorithm.make_when_a(e',prop,sl') => stmt
	(* TODO elsewhen *)
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN_A(e,sl,el),impl) => stmt

  rule	Static.elab_exp (env,cond,impl,NONE) 
	  => (cond',cprop,_) &
	Static.elab_exp (env,msg,impl,NONE) 
	  => (msg',msgprop,_) &
	Algorithm.make_assert(cond',msg',cprop,msgprop) => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),
					       Absyn.FUNCTIONARGS([cond,msg],[])),impl)
	  => stmt

  rule  Debug.fprint("failtrace", "- inst_statement failed\n alg:") &
	Debug.fcall("failtrace", Dump.print_algorithm, alg) &
	Debug.fprint("failtrace", "\n") 
	---------------------------------
	inst_statement(env,alg,impl) => fail
end

(** relation: inst_elseifs
 **
 ** This relation helps `inst_statement' to handle `elseif' parts.
 **)

relation inst_elseifs : (Env.Env, (Absyn.Exp * Absyn.AlgorithmItem list) list, bool (*impl*) )
	=> (Exp.Exp * Types.Properties * Algorithm.Statement list) list =

  axiom	inst_elseifs (env,[],impl) => []

  rule	Static.elab_exp(env,e,impl,NONE) => (e',prop,_) &
	inst_algorithmitems(env,l,impl) => stmts &
	inst_elseifs(env,tail,impl) => tail'
	-------------------------------
	inst_elseifs(env,(e,l)::tail,impl) => ((e',prop,stmts)::tail')

  rule	Debug.fprint("failtrace", "- inst_elseifs failed\n")
	-------------------------------
	inst_elseifs(_,_,_) => fail

end

(** relation: inst_connect
 ** 
 ** Generates connectionsets for connections.
 ** Parameters and constants in connectors should generate appropriate 
 ** assert statements.
 ** Hence, a 'DAE.Element list' is returned as well.
 **)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef, bool (*impl*) )
	  => (Connect.Sets,DAE.Element list) =

  rule	Static.elab_cref(env, c1, impl) => (Exp.CREF(c1',t1),prop1,acc) &
	Static.elab_cref(env, c2, impl) => (Exp.CREF(c2',t2),prop2,acc) &
	Static.canon_cref(env, c1', impl) => c1'' &
	Static.canon_cref(env, c2', impl) => c2'' &
	Lookup.lookup_var_local(env,c1'')
	  => (attr1 as Types.ATTR(flow1,_,_,_),ty1,_) &
	Lookup.lookup_var(env,c2'') => (attr2,ty2,_) &
	(** Check that the types of the connectors are good. *)
	valid_connector(ty1) &
	valid_connector(ty2) &
	check_connect_types(c1'',ty1,attr1,c2'',ty2,attr2) &
	component_face(c1'') => f1 &
	component_face(c2'') => f2 &
	connect_components(sets, env, pre, c1'', f1, ty1, c2'', f2, ty2, flow1)
	  => (sets',dae)
	---------------------------------
	inst_connect(sets, env,pre,c1,c2,impl) => (sets',dae)

end

(** relation: valid_connector
 **
 ** This relation tests whether a type is a eligible to be used in
 ** connections.
 **
 **)

relation valid_connector : Types.Type => () =

  axiom	valid_connector((Types.T_REAL(_),_))

  rule	ClassInf.valid(state,SCode.R_CONNECTOR)
	---------------------------------------
	valid_connector((Types.T_COMPLEX(state,_),_))

  rule	Print.print_error_buf "# Can't connect objects of type " &
	Types.unparse_type t => str &
	Print.print_error_buf str &
 	Print.print_buf "\n"
	-------------------------------
	valid_connector t => fail
end

(** relation: check_connect_types
 **
 ** Check that the type and type attributes of two connectors match,
 ** so that they really may be connected.
 **
 **)

relation check_connect_types : (Exp.ComponentRef, Types.Type,
				Types.Attributes,
			       	Exp.ComponentRef, Types.Type,
				Types.Attributes) => () =

  rule	assert_different_faces(c1,c2) &
	Print.print_error_buf "# Can't connect two input variables\n" &
	Print.print_error_buf "    while connecting " & 
	Exp.print_component_ref_str c1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " to " & Exp.print_component_ref_str c2 => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n unless one of them is inside connector and the other outside connector."
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.INPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.INPUT)) => fail

  rule	assert_different_faces(c1,c2) &
	Print.print_error_buf "# Can't connect two output variables\n" &
	Print.print_error_buf "    while connecting " & Exp.print_component_ref_str c1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " to " & Exp.print_component_ref_str c2 => str & 
	Print.print_error_buf str &
	Print.print_error_buf "\n unless one of them is inside connector and the other outside connector."
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.OUTPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.OUTPUT)) => fail

  rule	flow1 = flow2 &
	Types.equivtypes(t1, t2) => true
	-------------------------------
	check_connect_types(_,t1,Types.ATTR(flow1,_,_,_),
			    _,t2,Types.ATTR(flow2,_,_,_))

  rule	Print.print_error_buf "# Can't connect flow component " &
 	Exp.print_component_ref_str c1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " to non-flow component " &
 	Exp.print_component_ref_str c2 => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(true,_,_,_),
			    c2,_,Types.ATTR(false,_,_,_)) => fail

  rule	Print.print_error_buf "# Can't connect non-flow component " &
 	Exp.print_component_ref_str c1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " to flow component " &
 	Exp.print_component_ref_str c2 => str & 
	Print.print_error_buf str &
	Print.print_error_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(false,_,_,_),
			    c2,_,Types.ATTR(true,_,_,_)) => fail

  rule	Debug.fprint("failtrace", "- check_connect_types(") & 
	Debug.fcall("failtrace", Exp.print_component_ref, c1) &
	Debug.fprint("failtrace", " <-> ") & 
        Debug.fcall("failtrace", Exp.print_component_ref, c2) & 
	Debug.fprint("failtrace", ") failed\n")
	------------------------------------------------------
	check_connect_types(c1,_,_,c2,_,_) => fail

end

(** relation assert_different_faces
 **
 ** This relation fails if two connectors have same faces, 
 ** e.g both inside or both outside connectors 
 **)

relation assert_different_faces: (Exp.ComponentRef,Exp.ComponentRef)  => () =

  rule	component_face(c1) => Connect.INNER &	
	component_face(c1) => Connect.OUTER 
	----------------------------------
	assert_different_faces(c1,c2) => ()

  rule	component_face(c1) => Connect.OUTER &	
	component_face(c1) => Connect.INNER 
	----------------------------------
	assert_different_faces(c1,c2) => ()
end

(** relation: connect_components
 **
 ** This relation connects two components and generates connection
 ** sets along the way.  For simple components (of type `Real') it
 ** adds the components to the set, and for complex types it traverses
 ** the subcomponents and recursively connects them to each other.
 ** A DAE.Element list is returned for assert statements.
 **)

relation connect_components: (Connect.Sets,
			      Env.Env,
			      Prefix,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      bool) 
	  => (Connect.Sets, DAE.Element list) =
	  	
	(**  Flow type, must be a subtype of Real *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_flow(sets, c1', f1, c2', f2) => sets'
	-----------------------------------------
	connect_components(sets, env, pre, c1, f1, (Types.T_REAL(_),_),
			   c2, f2, (Types.T_REAL(_),_), true) => (sets',[])

  rule	Types.array_element_type(t1) => ((Types.T_REAL(_),_)) &
	Types.array_element_type(t2) => ((Types.T_REAL(_),_)) &
	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	----------------------------------------
	connect_components(sets,env, pre,c1,f1, (Types.T_ARRAY(_,t1),_),
			   c2,f2, (Types.T_ARRAY(_,t2),_),true) => (sets',[])
	
	(**  Non-flow type *)

	(** Parameters and constants generate assert statements *)
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Lookup.lookup_var_local(env,c1') => (Types.ATTR(_,_,vr,_),t1, _) &
	SCode.is_parameter_or_const(vr) => true &
	Types.basic_type t1 => true &
	Lookup.lookup_var_local(env,c2') => (Types.ATTR(_,_,_,_) ,t2, _) &
	Types.basic_type t2 => true 
	------------------------------------
	connect_components(sets, env, pre, c1, f1, (_,_),
			   c2, f2, (_,_), false) 
	  => (sets,
	      [DAE.ASSERT(Exp.CALL(Absyn.IDENT("assert"),
				     [Exp.RELATION(Exp.CREF(c1',Exp.REAL),
						 Exp.EQUAL(Exp.BOOL),
						 Exp.CREF(c2',Exp.REAL))
				      ,Exp.SCONST("automatically generated from connect")],false,true))])

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, env, pre, c1, _, (Types.T_REAL(_),_),
			   c2, _, (Types.T_REAL(_),_), false) => (sets',[])

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, env, pre, c1, _, (Types.T_INTEGER(_),_),
			   c2, _, (Types.T_INTEGER(_),_), false) => (sets',[])

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	dim1 = dim2 &
	Connect.add_array_equ(sets,c1',c2',dim1) => sets'
	----------------------------------------
	connect_components(sets,env,pre,c1,f1, (Types.T_ARRAY(Types.DIM(SOME(dim1)),t1),_),
			   c2,f2, (Types.T_ARRAY(Types.DIM(SOME(dim2)),t2),_),false) 
	  => (sets',[])

	(**  Complex types *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	connect_vars(sets,env,c1',f1,l1,c2',f2,l2) => (sets',dae)
	----------------------------------------
	connect_components(sets,env,pre,c1,f1, (Types.T_COMPLEX(_,l1),_),
			   c2,f2, (Types.T_COMPLEX(_,l2),_),_) => (sets',dae)
	
	(**  Error *)
	
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Print.print_error_buf "# Wrong type in connection\n"&
 	Print.print_error_buf "  while making connectiion " &
	Exp.print_component_ref_str c1 => str &
	Print.print_error_buf str &
	Print.print_error_buf " <-> " &
	Exp.print_component_ref_str c2 => str & 
	Print.print_error_buf str &
	Print.print_error_buf "\n" &
	Print.print_error_buf "  The type `" & Types.unparse_type t1 => str &
	Print.print_error_buf str &
	Print.print_error_buf "' is not allowed in connections\n"
	----------------------------------------
	connect_components(_,env,pre,c1,_,t1,c2,_,t2,_) => fail
	
end

(** relation: connect_vars
 **
 ** This relation connects two subcomponents by adding the component
 ** name to the current path and recursively connecting the components
 ** using the relation `connet_components'.
 **)

relation connect_vars : (Connect.Sets, 
			 Env.Env,
			 Exp.ComponentRef, Connect.Face, Types.Var list,
			 Exp.ComponentRef, Connect.Face, Types.Var list)
	  => (Connect.Sets, DAE.Element list) =

  axiom	connect_vars(sets,env,_,_,[],_,_,[]) => (sets,[])

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	check_connect_types(c1', ty1, attr1, c2', ty2, attr2) &
	connect_components(sets,env,Prefix.NOPRE,
			   c1',f1, ty1,
			   c2',f2, ty2, flow1) => (sets',dae) &
	connect_vars(sets',env,c1,f1,xs1,c2,f2,xs2) => (sets'',dae2) &
	list_append(dae,dae2) => dae'					 
	--------------------------------------
	connect_vars(sets,env,
		     c1,f1, Types.VAR(n,attr1 as Types.ATTR(flow1,_,vt1,_),
				      _,ty1,_)::xs1,
		     c2,f2, Types.VAR(_,attr2 as Types.ATTR(flow2,_,vt2,_),
				      _,ty2,_)::xs2)
	  => (sets'',dae')

end

(** relation: mktype 
 **
 ** From a class typename, its inference state, and a list of subcomponents, 
 ** this relation returns `Types.Type'.  If the class inference state
 ** indicates that the type should be a built-in type, one of the
 ** built-in type constructors is used.  Otherwise, a `T_COMPLEX' is
 ** built.
 **)

relation mktype : (Absyn.Path, ClassInf.State,Types.Var list) => Types.Type =
	
  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_INTEGER(_),v) => ((Types.T_INTEGER(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_REAL(_),v)    => ((Types.T_REAL(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_STRING(_),v)  => ((Types.T_STRING(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_BOOL(_),v)    => ((Types.T_BOOL(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_ENUM(_),_)    => ((Types.T_ENUM,somep))

	(* Insert function type construction here
	   after checking input/output arguments? 
	   see Types.rml T_FUNCTION *)

  rule	Types.make_function_type (p,vl) => functype
	--------------------------
	mktype(p,st as ClassInf.FUNCTION(name), vl) => functype

  rule	Types.make_enumeration_type (p,v1) => enumtype
	--------------------------------------------
	mktype(p,ClassInf.ENUMERATION(name),v1) => enumtype

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,st,l) => ((Types.T_COMPLEX(st,l),somep))

end


(** relation: get_opt_path
 ** 
 ** Helper relation to mktype
 ** Transforms a Path into a Path option.
 **)

relation get_opt_path: Absyn.Path => Absyn.Path option =

  axiom	get_opt_path Absyn.IDENT("") => NONE

  axiom	get_opt_path p => SOME(p)

end

(** relation: inst_list
 **
 ** This is a utility used to do instantiation of list of things,
 ** collecting the result in another list.
 **)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a, bool (*impl*) ) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list, bool (*impl*) )
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[],impl) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e,impl) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es,impl)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es,impl)
	  => (l'',env'',csets'',ci_state'')

end

(** relation: component_face
 ** 
 ** This relation determines whether a component reference refers to an
 ** inner or outer connector.
 **)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_QUAL(_,_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

end


(** relation: inst_binding
 **
 ** This relation investigates a modification and extracts the 
 ** <...> modification. E.g. Real x(<...>=1+3) => 1+3
 ** It also handles the case Integer T0[2](final <...>={5,6})={9,10} becomes
 ** Integer T0[1](<...>=5); Integer T0[2](<...>=6);
 **
 ** Arg 1 is the modification  
 ** Arg 2 is the expected type that the modification should have
 ** Arg 3 is the index list for the element: for T0[1,2] is {1,2} 
 **
 **)
relation inst_binding: (Types.Mod,Types.Type,int list,string) 
	  => Exp.Exp option =

          (* No subscript/index *)
  rule	Mod.lookup_comp_modification(mod,bind_name) => mod2 &
	Mod.mod_equation(mod2) => SOME(Types.TYPED(e,_,Types.PROP(ty2,_))) &
	Types.match_type(e,ty2,expected_type) => (e',ty') 
	---------------------------------------------------
	inst_binding (mod,expected_type,[],bind_name) => SOME(e')
	
        (* Have subscript/index *)
  rule  Mod.lookup_comp_modification(mod,bind_name) => mod2 &
        inst_binding2(mod2,etype,index_list,bind_name) => result 
	 ---------------------------------------------------
	 inst_binding (mod,etype,index_list,bind_name) => result

	(* No modifier for this name. *)
  rule  not Mod.lookup_comp_modification(mod,bind_name) => mod2 
	--------------------------------------------------
	inst_binding (mod,expected_type,[],bind_name) => NONE
        
  axiom	inst_binding(mod,etype,_,_) => NONE

end

(** relation: inst_binding2
 **
 ** This relation investigates a modification and extracts the <...> 
 ** modification if the modification is in array of components. 
 ** Help-relation to inst_binding
 **)

relation inst_binding2: (Types.Mod,Types.Type,int list,string) 
	  => Exp.Exp option  =

	  (* Only one element in the index-list *)
  rule	Mod.lookup_idx_modification(mod,index) => mod2 &
	
        Mod.mod_equation(mod2) => SOME(Types.TYPED(e,_,Types.PROP(ty2,_))) &
	
        Types.match_type(e,ty2,etype) => (e',ty') 
	---------------------------------------------------
	inst_binding2 (mod,etype,index::[],bind_name) => SOME(e')
 
	(* Several elements in the index-list *)
  rule	Mod.lookup_idx_modification(mod,index) => mod2 &
        inst_binding2(mod2,etype,res,bind_name) => result
	---------------------------------------------------
	inst_binding2 (mod,etype,index::res,bind_name) => result

  rule  not Mod.lookup_idx_modification(mod,index) => mod2
	---------------------------------------------------
	inst_binding2 (mod,etype,index::res,bind_name) => NONE

  rule  (*Print.print_buf("inst_binding2 failed\n")*)
        ---------------------------------------------------
	inst_binding2 (_,_,_,_) => fail
	
end


(** relation: inst_start_binding_exp
 **
 ** This relation investigates a modification and extracts the 
 ** start modification. E.g. Real x(start=1+3) => 1+3
 ** It also handles the case Integer T0[2](final start={5,6})={9,10} becomes
 ** Integer T0[1](start=5); Integer T0[2](start=6);
 **
 ** Arg 1 is the start modification  
 ** Arg 2 is the expected type that the modification should have
 ** Arg 3 is the index list for the element: for T0[1,2] is {1,2} 
 **)

relation inst_start_binding_exp: (Types.Mod,Types.Type,int list) 
	  => DAE.StartValue =
     
  rule inst_binding(mod,etype,index_list,"start") => result
        -----------------------------------------
        inst_start_binding_exp(mod,etype,index_list) => result   
end

(** relation: inst_dae_variable_attributes 
 **
 ** this relation extracts the attributes from the modification
 ** It returns a DAE.VariableAttributes option because 
 ** somtimes a varible does not contain the variable-attr.
 **)

relation inst_dae_variable_attributes: (Env.Env,Types.Mod,Types.Type,int list) 
	  => DAE.VariableAttributes option =

	  (* Real *)
  rule  inst_string_binding(env,mod,index_list,"quantity") => quantity_str &
        inst_string_binding(env,mod,index_list,"unit") => unit_str &
        inst_string_binding(env,mod,index_list,"displayUnit") => displayunit_str &
        inst_real_binding(env,mod,index_list,"min") => min_val &
        inst_real_binding(env,mod,index_list,"max") => max_val &
        inst_real_binding(env,mod,index_list,"start") => start_val &
        inst_bool_binding(env,mod,index_list,"fixed") => fixed_val &
        inst_real_binding(env,mod,index_list,"nominal") => nominal_val &

        inst_enumeration_binding(env,mod,index_list,"stateSelect") => exp_bind_select &
        get_stateSelect_from_exp_option(exp_bind_select) => stateSelect_value
        -----------------------------------------
        inst_dae_variable_attributes(env,mod,(Types.T_REAL(_),path),index_list) 
          => SOME(DAE.VAR_ATTR_REAL(quantity_str,unit_str,displayunit_str,(min_val,max_val),start_val,
                               fixed_val,nominal_val,stateSelect_value))

	(* Integer *)
  rule  inst_string_binding(env,mod,index_list,"quantity") => quantity_str &
        inst_int_binding(env,mod,index_list,"min") => min_val &
        inst_int_binding(env,mod,index_list,"max") => max_val &
        inst_int_binding(env,mod,index_list,"start") => start_val &
        inst_bool_binding(env,mod,index_list,"fixed") => fixed_val 
        -----------------------------------------
        inst_dae_variable_attributes(env,mod,(Types.T_INTEGER(_),_),index_list) 
          => SOME(DAE.VAR_ATTR_INT(quantity_str,(min_val,max_val),start_val,
                               fixed_val))
        
	(* Boolean *)
  rule  inst_string_binding(env,mod,index_list,"quantity") => quantity_str &
        inst_bool_binding(env,mod,index_list,"start") => start_val &
        inst_bool_binding(env,mod,index_list,"fixed") => fixed_val 
        -----------------------------------------
        inst_dae_variable_attributes(env,mod,(Types.T_BOOL(_),_),index_list) 
          => SOME(DAE.VAR_ATTR_BOOL(quantity_str,start_val,
                               fixed_val))
  
	(* String *)
  rule  inst_string_binding(env,mod,index_list,"quantity") => quantity_str &
        inst_string_binding(env,mod,index_list,"start") => start_val 
        -----------------------------------------
        inst_dae_variable_attributes(env,mod,(Types.T_STRING(_),_),index_list) 
          => SOME(DAE.VAR_ATTR_STRING(quantity_str,start_val))

	  (* Enumeration *)
  rule  inst_string_binding(env,mod,index_list,"quantity") => quantity_str &
        inst_binding(mod,enumtype,index_list,"min") => exp_bind_min &
        inst_binding(mod,enumtype,index_list,"max") => exp_bind_max &
        inst_binding(mod,enumtype,index_list,"start") => exp_bind_start &
        inst_bool_binding(env,mod,index_list,"fixed") => fixed_val 
        -----------------------------------------
        inst_dae_variable_attributes(env,mod, enumtype as (Types.T_ENUMERATION(_,_),_),index_list) 
          => SOME(DAE.VAR_ATTR_ENUMERATION(quantity_str,(exp_bind_min,exp_bind_max),exp_bind_start,fixed_val))

  rule  (*  Print.print_error_buf "# unknown type for variable.\n"  & *)
(*         Mod.print_mod_str(mod) => str & *)
(*         print str & print "<- mod \n" *)
        -----------------------------------------
        inst_dae_variable_attributes(env,mod,_,_) => NONE

end

(** relation inst_bool_binding
 ** author: LP
 **
 ** instantiates a bool binding and retrieves the value.
 ** FIXME: check the type of variable for the fixed because there is a 
 ** difference between parameters and variables
 **)

relation inst_bool_binding: (Env.Env, Types.Mod,int list,string) => bool option =
     
  rule inst_binding(mod,(Types.T_BOOL([]),NONE),index_list,bind_name) 
	  => SOME(e) &
	Ceval.ceval(env,e,false,NONE,NONE,Ceval.NO_MSG) => (Values.BOOL(result),_)
          -----------------------------------------
        inst_bool_binding(env,mod,index_list,bind_name) => SOME(result)

	(* Non constant expression return NONE *)
  rule inst_binding(mod,(Types.T_BOOL([]),NONE),index_list,bind_name) 
	  => SOME(e) 
          -----------------------------------------
        inst_bool_binding(env,mod,index_list,bind_name) => NONE
   
  rule inst_binding(mod,(Types.T_BOOL([]),NONE),index_list,bind_name) => NONE
        -----------------------------------------
        inst_bool_binding(env,mod,index_list,bind_name) => NONE

rule 	Print.print_error_buf "# Wrong type on " &
	Print.print_error_buf bind_name &
	Print.print_error_buf " expecting Boolean.\n"
        -----------------------------------------
        inst_bool_binding(env,mod,index_list,bind_name) => fail
   
end

(** relation: inst_real_binding
 ** author: LP
 **
 ** instantiates a real binding and retrieves the value.
 **)

relation inst_real_binding: (Env.Env,Types.Mod,int list,string) => real option =

  rule inst_binding(mod,(Types.T_REAL([]),NONE),index_list,bind_name) 
	  => SOME(e) &
	Ceval.ceval(env,e,false,NONE,NONE,Ceval.NO_MSG) => (Values.REAL(result),_)
        -----------------------------------------
        inst_real_binding(env,mod,index_list,bind_name) => SOME(result)

	(* non constant expression, return NONE *)
  rule inst_binding(mod,(Types.T_REAL([]),NONE),index_list,bind_name) 
	  => SOME(e) 
        -----------------------------------------
        inst_real_binding(env,mod,index_list,bind_name) => NONE

  rule	inst_binding(mod,(Types.T_REAL([]),NONE),index_list,bind_name) => NONE
        -----------------------------------------
        inst_real_binding(env,mod,index_list,bind_name) => NONE

  rule  Print.print_error_buf "# Wrong type on " &
	Print.print_error_buf bind_name &
	Print.print_error_buf " expecting Real.\n" 
        -----------------------------------------
        inst_real_binding(env,mod,index_list,bind_name) => fail 
   
end

(** relation: inst_int_binding
 ** author: LP
 **
 ** instantiates an int binding and retrieves the value.
 **)

relation inst_int_binding: (Env.Env,Types.Mod,int list,string) => int option =
     
  rule inst_binding(mod,(Types.T_INTEGER([]),NONE),index_list,bind_name) 
	  => SOME(e) &
	Ceval.ceval(env,e,false,NONE,NONE,Ceval.NO_MSG) => (Values.INTEGER(result),_)
        -----------------------------------------
        inst_int_binding(env,mod,index_list,bind_name) => SOME(result)

	(* got non-constant expression, return NONE *)
  rule	inst_binding(mod,(Types.T_INTEGER([]),NONE),index_list,bind_name) 
	  => SOME(e) 
	  ------------------
        inst_int_binding(env,mod,index_list,bind_name) => NONE
   
  rule inst_binding(mod,(Types.T_INTEGER([]),NONE),index_list,bind_name) => NONE
        -----------------------------------------
        inst_int_binding(env,mod,index_list,bind_name) => NONE


  rule  Print.print_error_buf "# Wrong type on " &
	Print.print_error_buf bind_name &
	Print.print_error_buf " expecting Integer\n"
        -----------------------------------------
        inst_int_binding(env,mod,index_list,bind_name) => fail
   
end

(** relation: inst_string_binding
 ** author: LP
 **
 ** instantiates a string binding and retrieves the value.
 **)

relation inst_string_binding: (Env.Env,Types.Mod,int list,string) => string option =
     
  rule inst_binding(mod,(Types.T_STRING([]),NONE),index_list,bind_name) 
	  => SOME(e) &
	Ceval.ceval(env,e,false,NONE,NONE,Ceval.NO_MSG) 
	  => (Values.STRING(result),_)
        -----------------------------------------
        inst_string_binding(env,mod,index_list,bind_name) => SOME(result)

	(* Non constant expression return NONE *)
  rule inst_binding(mod,(Types.T_STRING([]),NONE),index_list,bind_name) 
	  => SOME(e) 
        -----------------------------------------
        inst_string_binding(env,mod,index_list,bind_name) => NONE

  rule inst_binding(mod,(Types.T_STRING([]),NONE),index_list,bind_name) => NONE
        -----------------------------------------
        inst_string_binding(env,mod,index_list,bind_name) => NONE

  rule	Print.print_error_buf "# Wrong type on " &
	Print.print_error_buf bind_name &
	Print.print_error_buf " expecting Integer\n"
        -----------------------------------------
        inst_string_binding(env,mod,index_list,bind_name) => fail
   
end

(** relation: inst_enumeration_binding
 ** author: LP
 **
 ** instantiates a enumeration binding and retrieves the value.
 **)
relation inst_enumeration_binding: (Env.Env,Types.Mod,int list,string) 
	  => Exp.Exp option =
     
  rule inst_binding(mod,(Types.T_ENUMERATION([],[]),NONE),index_list,bind_name) 
	  => result
        -----------------------------------------
        inst_enumeration_binding(env,mod,index_list,bind_name) => result
   
  rule	Print.print_error_buf "# Wrong type on " &
	Print.print_error_buf bind_name &
	Print.print_error_buf " expecting enumeration type.\n"
        -----------------------------------------
        inst_enumeration_binding(env,mod,index_list,bind_name) => fail
   
end

(** relation: get_stateSelect_from_exp_option
 ** author: LP
 **
 ** Retrieves the stateSelect value, as defined in DAE,  from an Expression option.
 **)

relation get_stateSelect_from_exp_option:(Exp.Exp option) => DAE.StateSelect option =
        
  axiom get_stateSelect_from_exp_option(SOME(Exp.CREF(Exp.CREF_QUAL("StateSelect",([]),Exp.CREF_IDENT("never",[])),Exp.ENUM))) => SOME(DAE.NEVER)
  axiom get_stateSelect_from_exp_option(SOME(Exp.CREF(Exp.CREF_QUAL("StateSelect",([]),Exp.CREF_IDENT("avoid",[])),Exp.ENUM))) => SOME(DAE.AVOID)
  axiom get_stateSelect_from_exp_option(SOME(Exp.CREF(Exp.CREF_QUAL("StateSelect",([]),Exp.CREF_IDENT("default",[])),Exp.ENUM))) => SOME(DAE.DEFAULT)
  axiom get_stateSelect_from_exp_option(SOME(Exp.CREF(Exp.CREF_QUAL("StateSelect",([]),Exp.CREF_IDENT("prefer",[])),Exp.ENUM))) => SOME(DAE.PREFER)
  axiom get_stateSelect_from_exp_option(SOME(Exp.CREF(Exp.CREF_QUAL("StateSelect",([]),Exp.CREF_IDENT("always",[])),Exp.ENUM))) => SOME(DAE.ALWAYS)

  axiom get_stateSelect_from_exp_option(NONE) => NONE
  axiom get_stateSelect_from_exp_option(_) => NONE
       
end

(** relation: inst_mod_equation
 **
 ** This relation adds the equation in the declaration of a variable,
 ** if such an equation exists.
 **)

relation inst_mod_equation : (Exp.ComponentRef, Types.Type, Mod, bool (*impl*) )
	  => DAE.Element list =

	  
  rule	Types.elab_type ty1 => t &
	inst_eq_equation(Exp.CREF(cr,t),
			 Types.PROP(ty1,Types.C_VAR), e,prop2,NON_INITIAL,impl) => dae
	-----------------------------------------------
	inst_mod_equation(cr,ty1, mod as Types.MOD(_,_,SOME(Types.TYPED(e,_,prop2))),impl)
	  => dae

  axiom inst_mod_equation(_,_,Types.MOD(_,_,NONE),impl) => []
  axiom inst_mod_equation(_,_,Types.NOMOD,impl) => []
  axiom	inst_mod_equation(_,_,Types.REDECL(_,_),impl) => []

  rule	Debug.fprint("failtrace", "- inst_mod_equation failed\n type: ") &
	Debug.fcall("failtrace", Types.print_type, t) &
  	Debug.fprint("failtrace", "\n  cref: ") &
	Debug.fcall("failtrace", Exp.print_component_ref, c) &
	Debug.fprint("failtrace", "\n mod:") &
	Debug.fcall("failtrace", Mod.print_mod, m) &
	Debug.fprint("failtrace", "\n") 
	------------------------------------
  	inst_mod_equation (c,t,m,impl) => fail

end

(** relation: check_prot
 **
 ** This relation is used to check that a protected element is not
 ** modified.
 **)

relation check_prot : (bool, Types.Mod, Exp.ComponentRef) => () =

  axiom	check_prot(false,_,cref)
	
  axiom check_prot(_,Types.NOMOD,_)

  rule	Print.print_error_buf "# Trying to modify protected element " &
	Exp.print_component_ref_str cref => str & 
	Print.print_error_buf str &
	Print.print_error_buf "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(** relation: make_binding
 **
 ** This relation looks at the equation part of a modification, and if
 ** there is a declaration equation builds a `Types.Binding' for it.
 **
 **)

relation make_binding : (Env.Env, SCode.Attributes, Types.Mod)
	  => Types.Binding =

  axiom	make_binding (_,_,Types.NOMOD) => Types.UNBOUND
  axiom	make_binding (_,_,Types.REDECL(_,_)) => Types.UNBOUND
  axiom	make_binding (_,_,Types.MOD(_,_,NONE)) => Types.UNBOUND

(* Numerical values becoms VALBOUND *)
  axiom	make_binding (env, _, Types.MOD(_,_,SOME(Types.TYPED(Exp.ICONST(i),_,_))))
	    => Types.VALBOUND(Values.INTEGER(i))
	    
  axiom make_binding (env, _, Types.MOD(_,_,SOME(Types.TYPED(Exp.RCONST(r),_,_))))
	    => Types.VALBOUND(Values.REAL(r))
	    
  axiom	make_binding (env, _, Types.MOD(_,_,SOME(Types.TYPED(Exp.SCONST(s),_,_))))
	=> Types.VALBOUND(Values.STRING(s))
	    
  axiom	make_binding (env, _, Types.MOD(_,_,SOME(Types.TYPED(Exp.BCONST(b),_,_))))
	=> Types.VALBOUND(Values.BOOL(b))

	(* Constant binding *)
axiom  	make_binding (env, SCode.ATTR(_,_,_,SCode.CONST,_), Types.MOD(_,_,SOME(Types.TYPED(e,e_val,prop))))
	  => Types.EQBOUND(e,e_val,Types.C_CONST)

	(* default *)

  rule	Exp.simplify(e) => e' 
	-------------------
	make_binding (_,_, Types.MOD(_,_,
				     SOME(Types.TYPED(e,e_val,Types.PROP(t,c))))) 
	  => Types.EQBOUND(e',e_val,c)

  rule	Debug.fprint("failtrace", "- make_binding failed\n")
	-------------------------------
	make_binding(_,_,_) => fail

end


(** relation init_vars_modelica_output
 ** author: LS
 **
 ** This rule goes through the elements and for each variable, searches the 
 ** rest of the list for "equations" which refer to that variable on the LHS, 
 ** and puts their RHS in the variable as the initialization expression. This 
 ** is needed for modelica output where parameters must be "assigned" (?) 
 ** during declaration.
 **)

relation init_vars_modelica_output : DAE.Element list => DAE.Element list =

  rule	init_vars_modelica_output_1 ([], l) => l'
	---------------------------------------
	init_vars_modelica_output l => l'
end

(** relation: init_var_modelica_output_1
 **
 ** Helper relaation to init_vars_modelica_output
 **)

relation init_vars_modelica_output_1 : (DAE.Element list, DAE.Element list) 
	  => DAE.Element list =

  axiom init_vars_modelica_output_1 (done, []) => done

  rule	init_vars_modelica_output_2 (cr, exp, done) => (exp', done') &
	init_vars_modelica_output_2 (cr, exp', todorest) => (exp'', todorest') &
	list_append (done', [DAE.VAR(cr, vk, vd, ty, exp'',inst_dims,start,flow,class,dae_var_attr,comment)]) => done'' &
	init_vars_modelica_output_1 (done'', todorest') => done'''
	--------------------------------------------------------
	init_vars_modelica_output_1 (done, (v as DAE.VAR(cr, vk, vd, ty, exp,inst_dims,start,flow,class,dae_var_attr,comment)) :: todorest)
	  => done'''


  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.COMP(n, DAE.DAE(dae'))]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.COMP(n, DAE.DAE(dae)) :: rest)
	  =>  done''

  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.FUNCTION(fpath, DAE.DAE(dae'), ty)]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.FUNCTION(fpath, DAE.DAE(dae), ty) :: rest)
	  =>  done''


  rule	list_append (done, [e]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	---------------------------------------
	init_vars_modelica_output_1 (done,  e :: rest) => done''

end


(** relation init_vars_modelica_output_2
 ** author: LS
 **
 ** Search the list for equations with LHS as componentref = cr, remove from the
 ** list and return the RHS of the last of those equations
 **)

relation init_vars_modelica_output_2 : (Exp.ComponentRef, Exp.Exp option, DAE.Element list) 
	  => (Exp.Exp option, DAE.Element list) =

  axiom init_vars_modelica_output_2 (cr, exp, []) => (exp, [])


  rule	Exp.cref_equal (cr, e1cr) => true &
	init_vars_modelica_output_2 (cr, SOME(exp'), rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, DAE.EQUATION(Exp.CREF(e1cr,_ (*Exp.OTHER*)), exp') :: rest)
	  => (exp'', rest')


  rule	Exp.cref_equal (cr, e1cr) => false &
	init_vars_modelica_output_2 (cr, exp, rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, (e1 as DAE.EQUATION(Exp.CREF(e1cr,_(* Exp.OTHER*)), exp')) :: rest)
	  => (exp'', e1 :: rest')

  rule	init_vars_modelica_output_2 (excr, exp, rest) => (exp', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (excr, exp, e1 :: rest) => (exp', e1 :: rest')

end

(** relation: inst_record_constructor_elt
 ** author: PA
 **
 ** This relation takes an Env and an Element and builds a input argument to 
 ** a record constructor.
 ** E.g if the element is Real x; the resulting Var is "input Real x;"
 **)

relation inst_record_constructor_elt : (Env.Env,SCode.Element, bool (*impl*)) =>
	Types.Var =
	  
  rule	Debug.fprint ("recconst", "inst_record_constructor_elt called\n") &
	Lookup.lookup_class(env,t,true) => (cl,cenv) &
	Debug.fprint ("recconst", "looked up class\n") &
	Mod.elab_mod(env,Prefix.NOPRE,mod,impl) => mod' &
	let owncref = Absyn.CREF_IDENT(id,[]) &
	elab_arraydim(env,owncref,dim,NONE,false,NONE) => dimexp &
	Debug.fprint ("recconst", "calling inst_var\n") &
	inst_var(cenv, ClassInf.FUNCTION(""),mod', Prefix.NOPRE, [], id, cl, attr,
		 dimexp, [], [], impl,comment) => (_,_, _, tp') &
	Debug.fprint ("recconst", "Type of argument:") &
	Debug.fcall ("recconst",Types.print_type,tp') &
	Debug.fprint ("recconst","\nMod=") &
	Debug.fcall ("recconst",Mod.print_mod,mod') &
	make_binding(env,attr,mod') => bind
	---------------------------------------
	inst_record_constructor_elt (env,
				     SCode.COMPONENT(id,_,repl,prot,
						     attr as
						     SCode.ATTR(dim,f,acc,var,dir),t,mod,bc,comment),impl) 
	    => Types.VAR(id,Types.ATTR(f,acc,var,Absyn.INPUT),prot,tp',bind)

  rule	Debug.fprint("failtrace", "- inst_record_constructor_elt failed.,elt:")
	& SCode.print_element_str elt => str &
	Debug.fprint("failtrace", str) &
	Debug.fprint("failtrace","\n") 
	---------------------------------------
	inst_record_constructor_elt(env,elt,impl) => fail
end

(** relation: is_top_call
 ** author: PA
 **
 ** The topmost instantiation call is treated specially with for instance 
 ** unconnected connectors.
 ** This relation returns true if the CallingScope indicates the top call.
 **)
 
relation is_top_call: CallingScope => bool =
 
  axiom	is_top_call TOP_CALL => true
  axiom	is_top_call INNER_CALL => false

end


