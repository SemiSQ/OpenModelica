(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used toendorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(* $Id$ *)

(**
 ** This module contain functionality for model management, expression evaluation, etc. 
 ** in the interactive environment.
 ** The module defines a symboltable used in the interactive environment containing:
 ** - Modelica models (described using Absyn AST)
 ** - Variable bindings
 ** - Compiled functions (so they do not need to be recompiled)
 ** - Instantiated classes (that can be reused, not impl. yet)
 ** - Modelica models in SCode form (to speed up instantiation. not impl. yet)
 **)

module Interactive:

  with "Absyn.rml"
  with "SCode.rml" 
  with "DAE.rml" 							  
  with "Types.rml"
  with "Values.rml"
  with "Env.rml"

  (** An Statement given in the interactive environment can either be 
   ** an Algorithm statement or an expression.
   **)
  (* - Interactive Statement *)
  datatype InteractiveStmt = IALG of Absyn.AlgorithmItem (* algItem *)
			   | IEXP of Absyn.Exp (* exp *)

  (** Several interactive statements are used in Modelica scripts.**)
  (* - Interactive Statements *)
  datatype InteractiveStmts = ISTMTS of InteractiveStmt list (* interactiveStmtLst *)
                                     *  bool (* semicolon; true = statement ending with a semicolon. The result will not be shown in the interactive environment. *)

  (* - Instantiated Class *)
  datatype InstantiatedClass =  INSTCLASS of Absyn.Path (* qualName ;  The F.Q.name of the inst:ed class*)
                                          *  DAE.Element list (* daeElementLst ; The list of DAE elements *)
                                          *  Env.Env  (* env ; The env of the inst:ed class*)

  (* - Interactive Variable *)
  datatype InteractiveVariable = IVAR of Absyn.Ident  (* varIdent ; The variable identifier *)
                                       * Values.Value (* value ; The value *)
                                       * Types.Type   (* type ; The type of the expression *)

  (* - Interactive Symbol Table *)
  datatype InteractiveSymbolTable = SYMBOLTABLE of Absyn.Program                  (* ast ; The ast *)
                                                 * SCode.Program                  (* explodedAst ; The exploded ast *)
                                                 * InstantiatedClass list         (* instClsLst ;  List of instantiated classes *)
                                                 * InteractiveVariable list       (* lstVarVal ; List of variables with values *)  
                                                 * (Absyn.Path * Types.Type) list (* compiledFunctions ; List of compiled functions, F.Q name + type *)

  (* - Empty Interactive Symbol Table *)
  val empty_symboltable : InteractiveSymbolTable


(*    - a component in a class *)
(*    this is used in extracting all the components in all the classes *)
  datatype Component = COMPONENTITEM of Absyn.Path (* the class where the component is *)
                                        * Absyn.Path (* the type of the component *)
                                       * Absyn.ComponentRef (* the name of the component *)
                      | EXTENDSITEM of Absyn.Path (* the class which is extended *)
                                          * Absyn.Path (* the class which is the extension *)

  datatype Components = COMPONENTS of Component list 
                                    *  int (* the number of components in list. used to optimize the get_dependency_on_class *)

  datatype ComponentReplacement = COMPONENTREPLACEMENT of Absyn.Path         (* which class contain the old cref *)
                                                       * Absyn.ComponentRef  (* the old cref *)
                                                       * Absyn.ComponentRef  (* the new cref *)

  datatype ComponentReplacementRules = COMPONENTREPLACEMENTRULES of ComponentReplacement list
                                                                 * int (* the number of rules *)

  (* Exported Relations *)
  relation evaluate: (InteractiveStmts, InteractiveSymbolTable, bool) 
	  => (string,InteractiveSymbolTable) 
            (* this is exported due to the need of using several interactive modules *)

  relation type_check_function: (Absyn.Program, InteractiveSymbolTable) => ()            
  relation evaluate2:  (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable)
  
  
  relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program
  relation update_scope: (Absyn.Program, InteractiveVariable list) => InteractiveVariable list
  relation add_component: (string,Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program,string)
  relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int
  relation remove_compiled_functions: (Absyn.Program, (Absyn.Path * Types.Type) list)
	    => (Absyn.Path * Types.Type) list
  relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env 
  relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) => Absyn.Class 

  relation get_type_of_variable: (Absyn.Ident, InteractiveVariable list) => Types.Type 
  relation add_instantiated_class: (InstantiatedClass list, InstantiatedClass) => InstantiatedClass list 
  relation get_instantiated_class: (InstantiatedClass list, Absyn.Path) => InstantiatedClass 

  relation get_contained_class_and_file: (Absyn.Path, Absyn.Program) => (Absyn.Program, string)
  

relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	  => InteractiveSymbolTable
relation add_scope: (Absyn.Program, InteractiveVariable list) => Absyn.Program 
relation is_primitive: (Absyn.ComponentRef, Absyn.Program) => bool  


  relation get_elementitems_in_class: (Absyn.Class) => Absyn.ElementItem list 
  relation get_components_in_class: (Absyn.Class) => Absyn.Element list 
  relation get_classnames_in_elts: (Absyn.ElementItem list) => string list
  relation get_components: (Absyn.ComponentRef,Absyn.Program) => string 
  relation is_primitive_class: (Absyn.Class,Absyn.Program) => bool 
  relation get_componentitems_name: Absyn.ComponentItem list => string list 


          (* this is added for optimization of modeleditor*)
           
  relation get_top_classnames: (Absyn.Program) => string
  relation get_component_modification: Absyn.Element => string 
  relation get_modification_value:(Absyn.ElementArg list, Absyn.ComponentRef)
	  => Absyn.Modification

  relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class 

 relation traverse_classes: (Absyn.Program, 
                            Absyn.Path option,
			     ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)),  (* rel-ation to apply*)
			     'a, (* extra value passed to re-lation*)
			     bool) (* true = traverse protected elements*)
	  => (Absyn.Program *  Absyn.Path option * 'a) 


  relation is_package: (Absyn.ComponentRef, Absyn.Program) => bool

  relation get_top_classnames_in_program: Absyn.Program => string list
        
  relation build_within: Absyn.Path => Absyn.Within

  relation exist_class: (Absyn.ComponentRef, Absyn.Program) => bool

end


with "Connect.rml"
with "Dump.rml"
with "Debug.rml"
with "RTOpts.rml"
with "Util.rml"
with "Parser.rml"
with "Prefix.rml"
with "Mod.rml"
with "Lookup.rml"
with "ClassInf.rml"
with "Exp.rml"
with "Inst.rml"
with "Static.rml"							  
with "ModUtil.rml"
with "Codegen.rml"
with "Print.rml"
with "System.rml"
with "ClassLoader.rml"
with "Ceval.rml"
with "Error.rml"
with "ErrorExt.rml"


(* - Empty Interactive Symbol Table *)
val empty_symboltable = SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[IVAR("$echo",Values.BOOL(true),(Types.T_BOOL([]),NONE))],[])



(** relation: evaluate
 **
 ** This relation evaluates expressions or statements feed interactively to the compiler.
 **
 ** inputs:   (InteractiveStmts, InteractiveSymbolTable, bool /* verbose */) 
 ** outputs:   string:  
 **                    The resulting string after evaluation. If an error has occurred, this string
 **                    will be empty. The error messages can be retrieved by calling print_messages_str()
 **                    in Error.rml.
 **            InteractiveSymbolTable 
 **)
 relation evaluate: (InteractiveStmts, InteractiveSymbolTable, bool) 
	   => (string,InteractiveSymbolTable) =

            	   
   rule	evaluate2(ISTMTS([x],verbose),st) => (res,newst) &
	 get_echo(newst) => echo &
	 select_resultstr(res,semicolon,verbose,echo) => res'
	 -----------------------------------------------------------
	 evaluate (ISTMTS([x],semicolon),st,verbose) => (res',newst)

   rule	evaluate2(ISTMTS([x],semicolon),st) => (res,newst) &
	 get_echo(newst) => echo &
	 select_resultstr(res,semicolon,verbose,echo) => res' &
	 evaluate(ISTMTS(xs,semicolon),newst,verbose) => (res2,newst') &
	 Util.string_append_list([res',res2]) => res''
	 ---------------------------------------------------------------
	 evaluate (ISTMTS(x::xs,semicolon),st,verbose) => (res'',newst')
 end


(** relation: select_resultstr
 **
 ** Returns result string depending on three boolean variables
 ** - semicolon
 ** - verbose
 ** - echo
 ** 
 ** inputs:  (string,
              bool, /* semicolon */
              bool, /* verbose */
              bool  /* echo */)
 ** outputs:  string
 **)
relation select_resultstr: (string,
			    bool, 
			    bool, 
			    bool) 
	  => string =

	
  axiom	(* echo off allways empty string *)
           select_resultstr(str,_,_,false) => ""

	(* .. verbose on allways return str *)
  axiom	select_resultstr(str,_,true,_) => str 

	(* ... semicolon, no resultstr *)
  axiom	select_resultstr(str,true,_,_) => "" 

  axiom	select_resultstr(str,false,_,_) => str
end


(** relation: get_echo
 **
 ** Return echo variable, which determines if result should be printed or not.
 **)
relation get_echo: (InteractiveSymbolTable) => bool =

  rule	build_env_from_symboltable(st) => env &	
	 Ceval.ceval (env,Exp.CREF(Exp.CREF_IDENT("$echo",[]),
				   Exp.BOOL),true,SOME(st),NONE,Ceval.MSG) 
	  => (Values.BOOL(res),_)
	----------------------
	get_echo(st) => res	

  axiom	get_echo(_) => true

end


(** relation: type_check_function
 **
 ** Type check a function. 
 ** The relation will fail iff a function has illegally typed. Errors are handled
 ** using side effects in Error.rml
 **)
relation type_check_function: (Absyn.Program, InteractiveSymbolTable) => () =


        (* Do not typecheck the following *)
  axiom	type_check_function(Absyn.BEGIN_DEFINITION(_,_,_,_),_) => ()
  axiom type_check_function(Absyn.END_DEFINITION(_),_) => ()
  axiom type_check_function(Absyn.COMP_DEFINITION(_,_),_) => ()
  axiom type_check_function(Absyn.IMPORT_DEFINITION(_,_),_) => ()

  	(* If it is not a function, return succeess *)    
  rule 	not restriction = Absyn.R_FUNCTION
  	-------------------------------------------------------
  	type_check_function(Absyn.PROGRAM([Absyn.CLASS(_,_,_,_,restriction,_,_)],_), st) => ()
  
	(* Type check the function *)  	
  rule 	build_env_from_symboltable(st) => env &
        SCode.elab_class(absyn_class) => scode_class  &
	Inst.implicit_function_instantiation(env, Types.NOMOD, Prefix.NOPRE, 
        	Connect.empty_set, scode_class, [], false) => (env', d)
  	-------------------------------------------------------
  	type_check_function(Absyn.PROGRAM([absyn_class],_), st) => ()
  
  	(* Recursively go through all classes *)
  rule 	list_length(class_list) => len & (* avoid recurs forever *)
  	not len = 1 &
        type_check_function(Absyn.PROGRAM([cls],w), st) &
        type_check_function(Absyn.PROGRAM(morecls,w), st)
  	-------------------------------------------------------
  	type_check_function(Absyn.PROGRAM(class_list as cls::morecls,w), st) => ()    	
end


(** relation: evaluate2
 **
 ** Helper relation to evaluate.
 **)
 relation evaluate2:  (InteractiveStmts, InteractiveSymbolTable) 
	  => (string,InteractiveSymbolTable) =

  rule	get_variable_names(vars) => vars &
	string_append(vars,"\n") => str
	--------------------------
	evaluate2(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("listVariables",_),Absyn.FUNCTIONARGS([],[])))],_),st as SYMBOLTABLE(_,_,_,vars,_))
	  => (str,st)

  rule	evaluate_graphical_api(stmts,st) => (str,newst) &
	string_append(str,"\n") => str'
	----------------------------------------------------
	evaluate2(stmts as ISTMTS([IEXP(Absyn.CALL(_,_))],_),st) => (str',newst)

  rule	evaluate_graphical_api2(stmts,st) => (str,newst) &
	string_append(str,"\n") => str'
	----------------------------------------------------
	evaluate2(stmts as ISTMTS([IEXP(Absyn.CALL(_,_))],_),st) => (str',newst)


	(* Evaluate algorithm statements in  evaluate_alg_stmt() *)
  rule  evaluate_alg_stmt(algitem, st) => (str, st') &
 	string_append(str,"\n") => str' 
        ---------------------------------------------------------
        evaluate2(ISTMTS([IALG(algitem as Absyn.ALGORITHMITEM(_,_))], outres), st) => (str', st')

	(* Evaluate expressions in evaluate_expr_to_str() *)
  rule	evaluate_expr_to_str(exp,st) => (str, st') & 
   	string_append(str,"\n") => str' 
	------------------------------------------------------
	evaluate2(stmts as ISTMTS([IEXP(exp)],_),st) => (str',st')
	
 end
  


 (** relation: evaluate_alg_stmt
  **
  ** This relation takes an 'AlgorithmItem', i.e. a statement located in an 
  ** algorithm section, and a symboltable as input arguments. The statements 
  ** are recursivly evalutated and a new interactive symbol table is returned.
  **)
relation evaluate_alg_stmt: (Absyn.AlgorithmItem, InteractiveSymbolTable) =>
	 (string,InteractiveSymbolTable) =


   rule	build_env_from_symboltable(st) => env &	
	 Static.elab_exp(env,cond,true,SOME(st)) 
	   => (econd,prop,SOME(st')) &
	 Ceval.ceval (env,econd,true,SOME(st'),NONE,Ceval.MSG) 
	   => (Values.BOOL(true),SOME(st'')) 
	 -----------------------------------------------
	 evaluate_alg_stmt(Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),Absyn.FUNCTIONARGS([cond,msg],_)),_),st as SYMBOLTABLE(p,_,_,_,_))
	     => ("", st'')


   rule	build_env_from_symboltable(st) => env &	
	 Static.elab_exp(env,msg,true,SOME(st)) 
	   => (msg',prop,SOME(st')) &
	 Ceval.ceval (env,msg',true,SOME(st'),NONE,Ceval.MSG) 
	   => (Values.STRING(str),SOME(st'')) 
	 -----------------------------------------------
	 evaluate_alg_stmt(Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),Absyn.FUNCTIONARGS([cond,msg],_)),_),st as SYMBOLTABLE(p,_,_,_,_))
	     => (str, st'')

   rule	build_env_from_symboltable(st) => env &
	 Static.elab_exp(env,exp,true,SOME(st)) => (sexp,Types.PROP(t,_),SOME(st'))  &
	 Ceval.ceval(env,sexp,true,SOME(st'),NONE,Ceval.MSG) 
	  => (value,SOME(st'')) &
	 Values.val_string value =>  str &
	 add_var_to_symboltable(ident,value,t,st'') => newst	
	 -----------------------------------------------
	 evaluate_alg_stmt(Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(Absyn.CREF_IDENT(ident,[]),exp),_),st as SYMBOLTABLE(p,_,_,_,_)) 
	     => (str, newst)

	(* Since expressions cannot be tuples an empty string is returned *)
   rule	build_env_from_symboltable(st) => env &
	 Static.elab_exp(env,rexp,true,SOME(st)) => (srexp,rprop,SOME(st'))	&
	 Types.get_prop_type rprop => ((Types.T_TUPLE(types),_)) &
	 Util.list_map(crefexps, get_ident_from_tuple_crefexp) => idents &
	 Ceval.ceval(env,srexp,true,SOME(st'),NONE,Ceval.MSG) 
	  => (Values.TUPLE(values), SOME(st'')) &
	 add_vars_to_symboltable(idents,values,types,st'') => newst
	 -----------------------------------------------
	 evaluate_alg_stmt(Absyn.ALGORITHMITEM(Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(crefexps),rexp),_),st as SYMBOLTABLE(p,_,_,_,_)) 
	     => ("", newst)

    	(* IF-statement *)
    rule let cond1 = (exp,algitemlist) &
         let cond2 = cond1::elseifexpitemlist &
         list_append(cond2, [(Absyn.BOOL(true),elseitemlist)]) => cond3 &
         evaluate_if_statement_lst(cond3, st) => st'
         ---------------------------------------------------------------------------------------
         evaluate_alg_stmt(Absyn.ALGORITHMITEM(Absyn.ALG_IF(exp, algitemlist, elseifexpitemlist, 
         elseitemlist),_), st) => ("", st')

    	(* WHILE-statement *)
    rule evaluate_expr(exp, st) => (value, st') &
    	 evaluate_while_stmt(value, exp, algitemlist, st') => st''
         ---------------------------------------------------------------------------------------
         evaluate_alg_stmt(Absyn.ALGORITHMITEM(Absyn.ALG_WHILE(exp, algitemlist),_), st) => ("", st'')
         

end

(** relation: evaluate_while_stmt
 ** 
 ** Recursively evaluates the while statement. Note that it is tail-recursive, so we should result
 ** in a iterative implementation.
 **)
relation evaluate_while_stmt: (Values.Value, Absyn.Exp, Absyn.AlgorithmItem list, InteractiveSymbolTable) 
	=> InteractiveSymbolTable =
  
  axiom  evaluate_while_stmt(Values.BOOL(false),_,_,st) => st

  rule   evaluate_alg_stmt_lst(algitemlst, st) => st' & 
  	 evaluate_expr(exp, st') => (value, st'') &
  	 evaluate_while_stmt(value, exp, algitemlst, st'') => st'''
        -----------------------------------------------------------------------------------
         evaluate_while_stmt(Values.BOOL(true),exp,algitemlst, st) => st'''
           
         (* Report type error *)
  rule   string_repres_of_expr(exp,st) => estr &
  	 Types.type_of_value(value) => vtype &
  	 Types.unparse_type vtype => tstr & 
  	 Error.add_message(Error.WHILE_CONDITION_TYPE_ERROR,[estr,tstr])
  	-------------------------------------------------------------       
     	 evaluate_while_stmt(value,exp,_,st) => fail
end


(** relation: evaluate_part_of_if_statement
 **  
 ** Evaluates one part of a if statement, i.e. one "case". If the condition is true, the algorithm items
 ** associated with this condition are evaluated. The first argument returned is set to true if the 
 ** condition was evaluated to true. Fails if the value is not a boolean.
 ** Note that we are sending the expression as an value, so that it does not need to be evaluated twice.
 
 **)
relation evaluate_part_of_if_statement: (Values.Value, Absyn.Exp, Absyn.AlgorithmItem list, 
	(Absyn.Exp * Absyn.AlgorithmItem list) list, InteractiveSymbolTable) => InteractiveSymbolTable =
  
  rule   exp_val = true &
         evaluate_alg_stmt_lst(algitemlst, st) => st'
        -----------------------------------------------------------------------------------
         evaluate_part_of_if_statement(Values.BOOL(exp_val),_,algitemlst, _, st) => st'
         
  rule   exp_val = false &
         evaluate_if_statement_lst(algrest, st) => st'
        -----------------------------------------------------------------------------------
         evaluate_part_of_if_statement(Values.BOOL(exp_val),_,algitemlst, algrest, st) => st'
  
         (* Report type error *)
  rule   string_repres_of_expr(exp,st) => estr &
  	 Types.type_of_value(value) => vtype &
  	 Types.unparse_type vtype => tstr & 
  	 Error.add_message(Error.IF_CONDITION_TYPE_ERROR,[estr,tstr])
  	-------------------------------------------------------------       
     	 evaluate_part_of_if_statement(value,exp,_,_,st) => fail
end

(** relation: evaluate_if_statement_lst
 **  
 ** Evaluates all parts of a if statement (i.e. a list of exp * statements)
 **)
relation evaluate_if_statement_lst: ((Absyn.Exp * Absyn.AlgorithmItem list) list, InteractiveSymbolTable) =>
  InteractiveSymbolTable =
  
   axiom evaluate_if_statement_lst([], st) => st
  
   rule	 evaluate_expr(exp, st) => (value, st') &
	 evaluate_part_of_if_statement(value, exp, algitemlst, algrest, st') => st''
    	-----------------------------------------------
    	 evaluate_if_statement_lst((exp,algitemlst)::algrest, st) => st'' 
end


 (** relation: evaluate_alg_stmt_lst
  **  
  ** Evaluates a list of algorithm statements
  **)
relation evaluate_alg_stmt_lst: (Absyn.AlgorithmItem list, InteractiveSymbolTable) =>
  InteractiveSymbolTable =
  
   axiom evaluate_alg_stmt_lst([], st) => st
  
   rule	 evaluate_alg_stmt(algitem, st) => (_,st') &
    	 evaluate_alg_stmt_lst(algrest, st') => st''
    	-----------------------------------------------------
    	 evaluate_alg_stmt_lst(algitem::algrest, st) => st'' 
end



 (** relation: evaluate_expr
  **
  ** Evaluates an expression and returns its value. 
  ** We need to return the symbol table, since the command loadFile()
  ** reads in data to the interactive environment.
  ** Note that this relation may fail.
  **
  ** Input:  Absyn.Exp - Expression to be evaluated
  **         InteractiveSymbolTable - The symbol table
  ** Output: Values.Value - Resulting value of the expression
  **)

 relation evaluate_expr: (Absyn.Exp, InteractiveSymbolTable) => 
 	(Values.Value, InteractiveSymbolTable) =

  rule	build_env_from_symboltable(st) => env &	
   	Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
	Ceval.ceval (env,sexp,true,SOME(st'),NONE,Ceval.MSG) => (value,SOME(st'')) 
	--------------------------------------------------------------
	evaluate_expr(exp,st as SYMBOLTABLE(p,_,_,_,_)) => (value,st'')
 end

 
 
 (** relation: string_repres_of_expr
  **
  ** This relation returns a string representation of an expression. For example expression
  ** 33+22 will result in "55" and expression: "my" + "string" will result in  ""my"+"string"". 
  **)
relation string_repres_of_expr: (Absyn.Exp, InteractiveSymbolTable) => string =

  rule	build_env_from_symboltable(st) => env &	
   	Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
   	Exp.print_exp_str sexp => estr 
	--------------------------------------------------------------
	string_repres_of_expr(exp,st) => estr
end
 
 
 (** relation: evaluate_expr_to_str
  **
  ** This relation is similar to evaluate_expr, with the difference that it returns a string
  ** and that it never fails. If the expression contain errors, an empty string will be returned
  ** and the errors will be stated using Error.rml
  **
  ** Input:  Absyn.Exp - Expression to be evaluated
  **         InteractiveSymbolTable - The symbol table
  ** Output: string - The resulting value represented as a string
  **)

 relation evaluate_expr_to_str: (Absyn.Exp, InteractiveSymbolTable) => 
 	(string, InteractiveSymbolTable) =

  rule	evaluate_expr(exp, st) => (value, st') &
	Values.val_string value =>  str
	-----------------------------------
	evaluate_expr_to_str(exp,st) => (str, st')

  axiom evaluate_expr_to_str(_,st) => ("", st) 

end

 

(** relation: get_ident_from_tuple_crefexp
 **
 ** Return the (first) identifier of a Component Reference in an expression.
 **)
 relation get_ident_from_tuple_crefexp : Absyn.Exp => Absyn.Ident =

   axiom get_ident_from_tuple_crefexp Absyn.CREF(Absyn.CREF_IDENT(id, _)) => id

  rule	Dump.print_exp_str exp => str &
	 Error.add_message(Error.INVALID_TUPLE_CONTENT,[str])
	 --------------------
	 get_ident_from_tuple_crefexp exp => fail
 end


(** relation: get_variable_names
 **
 ** Return a string containing a comma separated list of variables.
**)
 relation get_variable_names: (InteractiveVariable list) => string =

   rule	get_variable_list_str(vars) => strlst &
	 Util.string_delimit_list(strlst,", ") => str &
	 Util.string_append_list(["{",str,"}"]) => res
	 ---------------------------------------------
	 get_variable_names(vars) => res
 end


(** relation: get_variable_list_str
 **
 ** Helper relation to get_variable_names
 **)
 relation get_variable_list_str: (InteractiveVariable list) => string list =

   axiom	get_variable_list_str([]) => []

   rule	get_variable_list_str(vs)=> res 
	 ----------------------------
	 get_variable_list_str(IVAR("$echo",_,_)::vs) => res

   rule	get_variable_list_str(vs)=> res 
	 ----------------------------
	 get_variable_list_str(IVAR(p,_,_)::vs) => p::res
 end


(** relation: get_type_of_variables
 **
 ** Return the type of an interactive variable, given a list of variables 
 ** and a variable identifier.
 **)
 relation get_type_of_variable: (Absyn.Ident, InteractiveVariable list) => Types.Type =

   axiom get_type_of_variable(id,[]) => fail

   rule	varid = id
	 ----------------------------------------------
	 get_type_of_variable (varid,IVAR(id,_,tp)::rest) => tp 

   rule	not varid = id &
	 get_type_of_variable(varid,rest) => tp
	 ----------------------------------------------
	 get_type_of_variable (varid,IVAR(id,_,_)::rest) => tp 
 end


(** relation: add_vars_to_symboltable
 **
 ** Add a list of variables to the interactive symboltable given names, 
 ** values and types.
 **)
 relation add_vars_to_symboltable: (Absyn.Ident list, Values.Value list,
				    Types.Type list, InteractiveSymbolTable) 
	   => InteractiveSymbolTable =

   axiom	add_vars_to_symboltable ([],_,_,st) => st

   rule	add_var_to_symboltable (id, v, t, st) => st' &
	 add_vars_to_symboltable(idrest, vrest, trest, st') => st''
	 -------------------------------------------------------------
	 add_vars_to_symboltable (id::idrest, v::vrest, t::trest, st) => st''
 end


(** relation: add_var_to_symboltable
 **
 ** Helper relation to add_vars_to_symboltable.
 **)
 relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	   => InteractiveSymbolTable =

   rule	add_var_to_varlist(ident,v,t,vars) => vars'
	 ----------------------------
	 add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,id,vars,cf))
	   => SYMBOLTABLE(p,sp,id,vars',cf)
 end


(** relation: add_var_to_varlist
 **
 ** Helper relation to add_var_to_symboltable
 **)
 relation add_var_to_varlist: (Absyn.Ident, Values.Value, Types.Type,
			       InteractiveVariable list) 
	   => InteractiveVariable list =
   rule	ident = id2
	 -----------
	 add_var_to_varlist(ident,v,t,IVAR(id2,_,_)::rest) 
	     => IVAR(ident,v,t)::rest

   rule	not ident = id2 &
	 add_var_to_varlist(ident,v,t,rest) => rest'
	  ------------------------------------
	 add_var_to_varlist(ident,v,t,IVAR(id2,val2,t2)::rest)
	     => IVAR(id2,val2,t2)::rest'

   axiom	add_var_to_varlist(ident,v,t,[]) => [IVAR(ident,v,t)]
 end


 (** relation: build_env_from_symboltable
  ** author: PA
  ** 
  ** Builds an environment from a symboltable by adding all interactive variables
  ** and their bindings to the environment.
  **)
 relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env =

   rule	SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	 add_vars_to_env(vars,env) => env'
	 ------------------------------------------
	 build_env_from_symboltable(SYMBOLTABLE(p,sp,ic,vars,cf)) => env'
 end


(** relation: add_vars_to_env
 **
 ** Helper relation to build_env_from_symboltable.
 **)
 relation add_vars_to_env: (InteractiveVariable list, Env.Env) => Env.Env =

   rule	Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	 Env.update_frame_v(env,
	     Types.VAR(
		 id,
		 Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),
		 false,
		 tp,
		 Types.VALBOUND(v)
	     ),false,[]) => env' &
	 add_vars_to_env(rest,env') => env''
	 ---------------------------------------
	 add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''

   rule	not Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	 Env.extend_frame_v(env,
	     Types.VAR(
		 id,
		 Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),
		 false,
		 tp,
		 Types.VALBOUND(v)
	     ),NONE,false,[]) => env' &
	 add_vars_to_env(rest,env') => env''
	 ---------------------------------------
	 add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''

   axiom	 add_vars_to_env([],env) => env

 end


(** relation: evaluate_graphical_api2
 **
 ** Second relation for evaluating graphical api. 
 ** The reason for having two relation is that the generated c-code can
 ** not be complied in Visual studio if the number of rules are large.
 ** This was actually fixed in the latest version of RML!
 **)
relation evaluate_graphical_api2: (InteractiveStmts, InteractiveSymbolTable) 
	  =>  (string, InteractiveSymbolTable) = 
  

   rule	set_extends_modifier_value(class,Absyn.CREF_IDENT(ident,[]),
				    subident,mod,p) 
	   => (newp,resstr)
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setExtendsModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident)),
				     Absyn.CODE(Absyn.C_MODIFICATION(mod))
				     ],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))			

   rule	get_extends_modifier_names(class,ident,p) => resstr 
	 --------------------------------------------  
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getExtendsModifierNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)			

   rule	get_extends_modifier_value(class,Absyn.CREF_IDENT(ident,[]),subident,p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getExtendsModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)			
   rule	get_component_modifier_names(class,ident,p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentModifierNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)			

   rule	get_component_modifier_value(class,Absyn.CREF_IDENT(ident,[]),subident,p) 
	   => resstr 
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_parameter_value(class,Absyn.CREF_IDENT(ident,[]),p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(Absyn.CREF_IDENT(ident,_))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_source_file(class,p) => resstr
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getSourceFile",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class)],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr,st)

   rule	set_source_file(class,filename,p) => (resstr,newp)
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setSourceFile",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.STRING(filename)
				     ],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))			

  rule	set_component_comment(class,comp_ref,cmt,p) => (resstr,newp)
	----------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentComment",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class), 
				     Absyn.CREF(comp_ref),
				     Absyn.STRING(cmt)
				     ],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr, SYMBOLTABLE(newp,s,ic,iv,cf))

  rule	Absyn.cref_to_path(class) => p_class &
	set_component_properties(p_class,comp_ref,final,flow,protected,repl,
				 variability,[dref1,dref2],causality,p) 
	  => (resstr,p')
	 --------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentProperties",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class), 
				     Absyn.CREF(comp_ref),
				     Absyn.ARRAY([
						  Absyn.BOOL(final),
						  Absyn.BOOL(flow),
						  Absyn.BOOL(protected),
						  Absyn.BOOL(repl)]),
				     Absyn.ARRAY([Absyn.STRING(variability)]),
				     Absyn.ARRAY([Absyn.BOOL(dref1),
						  Absyn.BOOL(dref2)]),
				     Absyn.ARRAY([Absyn.STRING(causality)])
				     ],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr, SYMBOLTABLE(p',s,ic,iv,cf))

   (* adrpo added 2005-11-03 *)
   rule	 get_elements_info(cr,p) => resstr 
	 ---------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getElementsInfo",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   (* adrpo added 2005-11-24 *)
   rule	 System.read_env(name) => resstr 
	 ---------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getEnvironmentVar",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)


   (* adrpo added 2005-11-24 *)
   rule	 not System.read_env(name) => resstr 
	 ---------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getEnvironmentVar",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)

   (* adrpo added 2005-11-24 *)
   rule	 System.set_env(name, value, 1 (* overwrite*) ) => 0 
	 --------------------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setEnvironmentVar",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name), Absyn.STRING(value)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("Ok",st)

   (* adrpo added 2005-11-24 *)
   rule	 System.set_env(name, value, 1 (* overwrite*) ) => rest &
            int_eq(rest, 0) => false    
	 --------------------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setEnvironmentVar",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name), Absyn.STRING(value)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)

   (* adrpo added 2005-12-16 *)	     
   rule  
         System.regular_file_exist(name) => 0 &
	 Parser.parse(name) => p1 &
	 update_program(p1,p) => newp &
	 get_top_qualified_classnames(p1) => top_names_str
	 ---------------------------------------------------
	 evaluate_graphical_api2(
	      ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractiveQualified",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (top_names_str,SYMBOLTABLE(newp,s,ic,iv,cf))


   (* adrpo added 2005-12-16 *)	     
	 (** it the rule above have failed then check if file exists **)
	 (* without this omc crashes *)
   rule  System.regular_file_exist(name) => rest &
	 int_gt(rest,0) => true
	 ---------------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractiveQualified",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)

   (* adrpo added 2005-12-16 *)	     
	 (*check if the parse went wrong*)
   rule  not Parser.parse(name) => p1
	 ---------------------------------------------------
	 evaluate_graphical_api2(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractiveQualified",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)
end


 (**relation: evaluate_graphical_api
  **
  ** Thisrelation evaluates all primitives in the graphical api.
  ** NOTE: Do NOT ADD more rules to thisrelation, instead add them
  ** to evaluate_graphical_api2, since it wont compile in Visual Studio 
  ** otherwise.
  **)
relation evaluate_graphical_api: (InteractiveStmts, InteractiveSymbolTable) 
	  =>  (string, InteractiveSymbolTable) = 


   rule	(* expressions *)
	 set_parameter_value(class,ident,exp,p) => (p',resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(ident as Absyn.CREF_IDENT(_,_)),
				     Absyn.CODE(Absyn.C_MODIFICATION(Absyn.CLASSMOD(_,SOME(exp))))
				     ],[])))],_),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))

   rule	(* special case for clearing modifier *)
	 set_component_modifier(class,ident,Absyn.CREF_IDENT("",[]),mod,p) 
	   => (p',resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(ident as Absyn.CREF_IDENT(_,_)),
				     Absyn.CODE(Absyn.C_MODIFICATION(mod as Absyn.CLASSMOD([],NONE)))
				     ],[])))],_),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))


   rule	set_component_modifier(class,Absyn.CREF_IDENT(ident,[]),subident,mod,p) 
	   => (p',resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident)),
				     Absyn.CODE(Absyn.C_MODIFICATION(mod))
				     ],[])))],_),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))

   rule	get_parameter_value(class,ident,p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getParameterValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	set_parameter_value(class,ident,exp,p) => (p',resstr)
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setParameterValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident),exp],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))


   rule	get_parameter_names(cr,p) => resstr
	 -----------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getParameterNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule update_program(
       Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE),Absyn.INFO("",false,0,0,0,0))],Absyn.TOP),
       p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf) 
	 ----------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("createModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)

   rule	Absyn.cref_to_path(path) => path' &
	 Absyn.path_last_ident(path') => name &
	 Absyn.strip_last(path') => wpath &
	update_program(
	               Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE),Absyn.INFO("",false,0,0,0,0))],Absyn.WITHIN(wpath)),p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv,cf)
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("createModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(path as Absyn.CREF_QUAL(_,_,_))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)

   rule	Absyn.cref_to_path(cr) => path &
	 update_program(
	     Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE),Absyn.INFO("",false,0,0,0,0))],Absyn.WITHIN(path)),
	     p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf) &
	 string_append(name,"\n") => resstr
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("newModel",_),
		 Absyn.FUNCTIONARGS( [Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(cr)] , [])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)


   rule  (*   System.regular_file_exist(name) => 0 & *)
(* 	 Parser.parse(name) => p1 & *)
        ClassLoader.load_file(name) => p1 &
        update_program(p1,p) => newp & 
	 get_top_classnames(p1) => top_names_str
	 ---------------------------------------------------
	 evaluate_graphical_api(
	      ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractive",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (top_names_str,SYMBOLTABLE(newp,s,ic,iv,cf))



	 (** it the rule above have failed then check if file exists **)
	 (* without this omc crashes *)
   rule  System.regular_file_exist(name) => rest &
	 int_gt(rest,0) => true
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractive",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)

	 (*check if the parse went wrong*)

   rule  not Parser.parse(name) => p1
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractive",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)



	 rule	delete_class(cr,p) => (resstr, newp)
	 ---------------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("deleteClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)], [])))],_
		 ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))


   rule	add_component(name,tp,model,nargs,p) => (newp,resstr)
	 & Print.get_string() => str & string_append(resstr,str) => resstr'
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("addComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	(*delete_component(name,model,p) => (newp,resstr) &
	 add_component(name,tp,model,nargs,newp) => (newp2,resstr)*)
	 update_component(name,tp,model,nargs,p) =>(newp, res)
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("updateComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (res, SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	delete_component(name,model,p) => (newp,resstr)
	 & Print.get_string() => str & string_append(resstr,str) => resstr'
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("deleteComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(model)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	add_class_annotation(cr,nargs,p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf) 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("addClassAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)

   rule	get_component_count(cr,p) => count &
	 int_string count => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_component(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_components(cr,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponents",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_component_annotations(cr,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentAnnotations",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_component_annotation(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthComponentAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_component_modification(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthComponentModification",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_inheritance_count(cr,p) => count &
	 int_string count => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getInheritanceCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_inherited_class(cr,n,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthInheritedClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_connection_count(cr,p) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getConnectionCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_connection(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	set_connection_comment(cr,cr1,cr2,cmt,p) => (newp,resstr)
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setConnectionComment",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(cr1),Absyn.CREF(cr2),Absyn.STRING(cmt)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	  => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	add_connection(cr,c1,c2,nargs,p) => (resstr,newp) 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("addConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	delete_connection(cr,c1,c2,p) => (resstr,newp) 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("deleteConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	delete_connection(cr,c1,c2,p) => (s1,newp) &
	 add_connection(cr,c1,c2,nargs,newp) => (resstr,newp') 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("updateConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp',s,ic,iv,cf))

   rule	get_nth_connection_annotation(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnectionAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_connector_count(cr,p) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getConnectorCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_connector(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnector",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_connector_icon_annotation(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnectorIconAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)


   rule	Absyn.cref_to_path(cr) => path &
	 get_icon_annotation(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getIconAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	Absyn.cref_to_path(cr) => path &
	 get_diagram_annotation(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getDiagramAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	Absyn.cref_to_path(cr) => path &
	 get_packages_in_path(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getPackages",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_top_packages(p) => s1 &
	 string_append(s1,"\n") => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getPackages",_),
		 Absyn.FUNCTIONARGS([],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	Absyn.cref_to_path(cr) => path &
	 get_classnames_in_path(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_top_classnames(p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassNames",_),
		 Absyn.FUNCTIONARGS([],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  axiom	evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassNames",_),
		 Absyn.FUNCTIONARGS(_,_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("{}",st)

   rule	System.get_classnames_for_simulation => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassNamesForSimulation",_),
		 Absyn.FUNCTIONARGS([],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	System.set_classnames_for_simulation(str)
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setClassNamesForSimulation",_),
		 Absyn.FUNCTIONARGS([Absyn.STRING(str)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",st)

  rule	 get_class_information(cr,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassInformation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	 set_class_comment(class,str,p) => (p',resstr)
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setClassComment",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.STRING(str)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	  => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))

  rule	get_class_restriction(cr,p) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassRestriction",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)


   rule	is_primitive(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isPrimitive",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_type(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isType",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_connector(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isConnector",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_model(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_record(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isRecord",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_block(cr,p) => b1 &
	 Util.bool_string(b1) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isBlock",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_function(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isFunction",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_package(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isPackage",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_class(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_parameter(cr,class,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isParameter",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_protected(cr,class,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isProtected",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_constant(cr,class,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isConstant",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	exist_class(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("existClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	exist_class(cr,p) => b1 &
	 is_model(cr,p) => b2 &
	 bool_and(b1,b2) => res &
	 Util.bool_string(res) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("existModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	exist_class(cr,p) => b1 &
	 is_package(cr,p) => b2 &
	 bool_and(b1,b2) => res &
	 Util.bool_string(res) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("existPackage",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)
 

   rule	(** For now, renaming a class clears all caches... **)
	 (* Substantial analysis required to find out what to keep in cache
	  ** and what must be thrown out *)
	 rename_class(p,old_cname,new_cname) => (res,p')  &
	 SCode.elaborate(p') => s'
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("renameClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(old_cname), Absyn.CREF(new_cname)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (res,SYMBOLTABLE(p',s',[],[],[]))

  rule  rename_component(p,cname,from_ident,to_ident) => (res_str,p')
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("renameComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cname),Absyn.CREF(from_ident),Absyn.CREF(to_ident)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (res_str,SYMBOLTABLE(p',s,[],[],[]))



   (* adrpo added 2005-11-03 *)
   rule	  get_cref_info(cr,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getCrefInfo",_),Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

 end





(** relation extract_all_componentreplacements
 ** author: x02lucpo
 **
 ** extracts all the componentreplacementrules from program.
 ** This is done by extracting all the components and then extracting the rules
 **)
            
 relation extract_all_componentreplacements:(Absyn.Program,
			     Absyn.ComponentRef, 
			     Absyn.ComponentRef,
                             Absyn.ComponentRef) 
          => ComponentReplacementRules =

           
  rule	(* class in package *)
         extract_all_components(p) => comps &

         Absyn.cref_to_path(class) => class_path &
         let comp_repsrules = COMPONENTREPLACEMENTRULES([COMPONENTREPLACEMENT(class_path,cref1,cref2)],1) &
         get_componentreplacementsrules(comps,comp_repsrules,0) => comp_reps 
         ----------------------------
         extract_all_componentreplacements(p,class,cref1,cref2) => comp_reps
         
         
end



(** relation: rename_component
 ** author: x02lucpo
 **
 ** This relation renames a component in a class
 **
 ** inputs:  (Absyn.Program, 
              Absyn.ComponentRef, /* old class as qualified name */
              Absyn.ComponentRef) /* new class, as identifier */
 ** outputs:  Absyn.Program
 **)

 relation rename_component: (Absyn.Program, 
			     Absyn.ComponentRef, 
			     Absyn.ComponentRef,
                             Absyn.ComponentRef ) 
	   => (string, Absyn.Program) =

   rule	(* class in package *)
	 Absyn.cref_to_path(class) => class_path &
  
         extract_all_componentreplacements(p,class,old_comp,new_comp) => comp_reps &
         rename_component_from_componentreplacements(p,comp_reps) => p' &
         extract_renamed_classes_as_string_list(comp_reps) => paths &
         Util.string_delimit_list(paths,",") => paths' &
         Util.string_append_list(["{",paths',"}"]) => paths''
	 ------------------------
	 rename_component(p,
                          class ,
                          old_comp ,
                          new_comp )
	   => (paths'',p')

  rule  Debug.fprint("failtrace",  "rename_component failed\n")
         ------------------------
         rename_component(p,_,_,_) => ("error",p) 

 end

(** relation extract_renamed_classes_as_string_list
 ** author: x02lucpo
 **
 ** this iterates through the Componentreplacementrules and returns the string list
 ** with all the changed classes
 **)
relation extract_renamed_classes_as_string_list:(ComponentReplacementRules)
        => string list =

  rule  empty_componentReplacementRules(comp_reps) => true
        ---------------------------
        extract_renamed_classes_as_string_list(comp_reps) => []

  rule  first_componentReplacement(comp_reps) => COMPONENTREPLACEMENT(path,_,_) &
        Absyn.path_string(path) => path_str &
        rest_componentReplacementRules(comp_reps) => res &
        extract_renamed_classes_as_string_list(res) => res' &
        Util.list_union([path_str],res') => res''
        --------------------------
        extract_renamed_classes_as_string_list(comp_reps) => res''

        
  rule  print "-extract_renamed_classes_as_string_list failed\n"
        ---------------------------
        extract_renamed_classes_as_string_list(_) => fail

end


(** relation rename_component_from_componentreplacements
 ** author: x02lucpo
 **
 ** this iterates through the Componentreplacementrules and renames the 
 ** componentes by traversing all the classes
 **)
relation rename_component_from_componentreplacements:(Absyn.Program,
                                                      ComponentReplacementRules)
        => Absyn.Program =

  rule  empty_componentReplacementRules(comp_reps) => true
        ---------------------------
        rename_component_from_componentreplacements(p,comp_reps) => p

  rule  
        first_componentReplacement(comp_reps) => comp_rep &
        traverse_classes(p,NONE,rename_component_visitor,
                         (comp_rep),
			 true (* traverse protected*)) => ((p',_,_)) &
        rest_componentReplacementRules(comp_reps) => res &
        rename_component_from_componentreplacements(p',res) => p''
        --------------------------
        rename_component_from_componentreplacements(p,comp_reps) => p''
        
  rule  print "-rename_component_from_componentreplacements failed\n"
        ---------------------------
        rename_component_from_componentreplacements(_,_) => fail

end
(** relation rename_component_visitor
 **
 ** author: x02lucpo
 ** this is a visitor for traverse class in rename components 
 **) 
            
relation rename_component_visitor: ((Absyn.Class* Absyn.Path option *(ComponentReplacement))) (* the new name for the component *)
	  => ((Absyn.Class*Absyn.Path option *(ComponentReplacement)))
          =

  rule  Absyn.join_paths(pa,Absyn.IDENT(id)) => path' &
        ModUtil.path_equal(class_id,path') => true &
         rename_component_in_class(class, old_comp, new_comp) => class' 
	 ----------------
	 rename_component_visitor((class as Absyn.CLASS(id,a,b,c,d,e,file_info),SOME(pa),
                                   (COMPONENTREPLACEMENT(class_id,old_comp,new_comp))))
	  => ((class',SOME(pa),(COMPONENTREPLACEMENT(class_id,old_comp,new_comp))))
           
  rule  let path' = Absyn.IDENT(id) &
        ModUtil.path_equal(class_id,path') => true &
        rename_component_in_class(class, old_comp, new_comp) => class' 
	 ----------------
	 rename_component_visitor((class as Absyn.CLASS(id,a,b,c,d,e,file_info),NONE,
                                   (COMPONENTREPLACEMENT(class_id,old_comp,new_comp))))
	  => ((class',NONE,(COMPONENTREPLACEMENT(class_id,old_comp,new_comp))))
           
  axiom  rename_component_visitor((class,pa,args)) => ((class,pa,args))


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_class: (Absyn.Class, (*the class with the component*)
                                     Absyn.ComponentRef, (* the old name for the component *)
                                     Absyn.ComponentRef) => Absyn.Class =

  rule  rename_component_in_parts(parts,old_comp,new_comp) => parts'
        -------------------------------
        rename_component_in_class(Absyn.CLASS(id,partial,final,encapsulated,restriction,
                                             Absyn.PARTS(parts,a),
                                              file_info),
                                  old_comp,new_comp) 
          => Absyn.CLASS(id,partial,final,encapsulated,restriction,
                         Absyn.PARTS(parts',a),
                         file_info)
        

  rule  rename_component_in_parts(parts,old_comp,new_comp) => parts'
        -------------------------------
        rename_component_in_class(Absyn.CLASS(id,partial,final,encapsulated,restriction,
                                             Absyn.CLASS_EXTENDS(a,b,c,parts),
                                              file_info),
                                  old_comp,new_comp) 
          =>  Absyn.CLASS(id,partial,final,encapsulated,restriction,
                          Absyn.CLASS_EXTENDS(a,b,c,parts'),
                          file_info)
        
        
  rule  
        -------------------------------
        rename_component_in_class(class,
                                  old_comp,new_comp) => class

end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_parts:(Absyn.ClassPart list,
                                     Absyn.ComponentRef, (* the old name for the component *)
                                     Absyn.ComponentRef) =>
        Absyn.ClassPart list =
        
  rule  
        --------------------------------------
        rename_component_in_parts([],_,_) => []

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_elements(elements,old_comp,new_comp) => elements'
        --------------------------------------
        rename_component_in_parts(Absyn.PUBLIC(elements)::res,old_comp,new_comp)
          => Absyn.PUBLIC(elements')::res'

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_elements(elements,old_comp,new_comp) => elements'
        --------------------------------------
        rename_component_in_parts(Absyn.PROTECTED(elements)::res,old_comp,new_comp)
          => Absyn.PROTECTED(elements')::res'

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_equation_list(equations,old_comp,new_comp) => equations' 
        --------------------------------------
        rename_component_in_parts(Absyn.EQUATIONS(equations)::res,old_comp,new_comp) => 
        Absyn.EQUATIONS(equations')::res'

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_equation_list(equations,old_comp,new_comp) => equations'
        --------------------------------------
        rename_component_in_parts(Absyn.INITIALEQUATIONS(equations)::res,old_comp,new_comp) =>
        Absyn.INITIALEQUATIONS(equations')::res'

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_algorithms(algorithms,old_comp,new_comp) => algorithms'
        --------------------------------------
        rename_component_in_parts(Absyn.ALGORITHMS(algorithms)::res,old_comp,new_comp)
          => Absyn.ALGORITHMS(algorithms')::res'
 
  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_algorithms(algorithms,old_comp,new_comp) => algorithms'
        --------------------------------------
        rename_component_in_parts(Absyn.INITIALALGORITHMS(algorithms)::res,old_comp,new_comp)
          => Absyn.INITIALALGORITHMS(algorithms')::res'

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' &
        rename_component_in_external_decl(external_decl,old_comp,new_comp) => external_decl'
        --------------------------------------
        rename_component_in_parts(Absyn.EXTERNAL(external_decl,ano)::res,old_comp,new_comp)
          => Absyn.EXTERNAL(external_decl',ano)::res'

  rule  rename_component_in_parts(res,old_comp,new_comp) => res' 
        --------------------------------------
        rename_component_in_parts(a::res,old_comp,new_comp) => a::res'
 end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_elements:(Absyn.ElementItem list,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.ElementItem list =

  rule  
        -------------------------------------
        rename_component_in_elements([],_,_) => []

  rule  rename_component_in_elements(res,old_comp,new_comp) => res' &
        rename_component_in_element_spec(elementspec,old_comp,new_comp) => elementspec' &
        let element' = Absyn.ELEMENTITEM(Absyn.ELEMENT(final,redeclare,inner_outer,name,elementspec',info,constraint))
        -------------------------------------
        rename_component_in_elements((element as Absyn.ELEMENTITEM(Absyn.ELEMENT(final,redeclare,inner_outer,name,elementspec,info,constraint)))
                                     ::res,old_comp,new_comp) => element'::res'


  rule  rename_component_in_elements(res,old_comp,new_comp) => res' &
        let element' = element 
        -------------------------------------
        rename_component_in_elements(element::res,old_comp,new_comp) => element'::res'


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_element_spec:(Absyn.ElementSpec,      
                                           Absyn.ComponentRef, (* the old name for the component *)
                                           Absyn.ComponentRef) =>
        Absyn.ElementSpec =

  rule  rename_component_in_componentitems(comps,old_comp,new_comp) => comps'
        -----------------------------------
        rename_component_in_element_spec(Absyn.COMPONENTS(attr,path,comps),old_comp,new_comp) 
          => Absyn.COMPONENTS(attr,path,comps')


  rule 
        -----------------------------------
        rename_component_in_element_spec(elementspec,old_comp,new_comp) 
          => elementspec


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_componentitems:(Absyn.ComponentItem list ,      
                                           Absyn.ComponentRef, (* the old name for the component *)
                                           Absyn.ComponentRef) =>
        Absyn.ComponentItem list  =

  rule  
        ------------------------------------
        rename_component_in_componentitems([],_,_) => []


  rule  Absyn.cref_to_path(old_comp) => old_comp_path & 
        Absyn.path_string(old_comp_path) => old_comp_string &

        name = old_comp_string &

        Absyn.cref_to_path(new_comp) => new_comp_path & 
        Absyn.path_string(new_comp_path) => new_comp_string &
        rename_component_in_componentitems(res,old_comp,new_comp) => res' &
        let comp' = Absyn.COMPONENTITEM(Absyn.COMPONENT(new_comp_string,arrayDim,mod),cond,comment)
        ------------------------------------
        rename_component_in_componentitems((comp as Absyn.COMPONENTITEM(Absyn.COMPONENT(name,arrayDim,mod),cond,comment))
                                           ::res,old_comp,new_comp) => comp'::res'

  rule  rename_component_in_componentitems(res,old_comp,new_comp) => res' 
        ------------------------------------
        rename_component_in_componentitems((comp as Absyn.COMPONENTITEM(Absyn.COMPONENT(name,arrayDim,mod),cond,comment))
                                           ::res,old_comp,new_comp) => comp::res'

  rule  print "-rename_component_in_componentitems failed\n"
        ------------------------------------
        rename_component_in_componentitems(_,_,_) => fail
end


(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_equation_list:(Absyn.EquationItem list,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.EquationItem list =

  rule  
        -------------------------------------
        rename_component_in_equation_list([],_,_) => []

  rule  rename_component_in_equation_list(res,old_comp,new_comp) => res' &
        rename_component_in_equation(equation,old_comp,new_comp) => equation' 
        -------------------------------------
        rename_component_in_equation_list((Absyn.EQUATIONITEM(equation,cmt))
                                      ::res,old_comp,new_comp) 
          => Absyn.EQUATIONITEM(equation',cmt)::res'
        
  rule  rename_component_in_equation_list(res,old_comp,new_comp) => res' &
        let equation' = equation 
        -------------------------------------
        rename_component_in_equation_list(equation::res,old_comp,new_comp) => equation'::res'

end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_exp_equationitem_list:((Absyn.Exp * Absyn.EquationItem list) list,
                                                    Absyn.ComponentRef, (* the old name for the component *)
                                                    Absyn.ComponentRef) =>
       (Absyn.Exp * Absyn.EquationItem list) list =


  axiom  rename_component_in_exp_equationitem_list([],_,_) => []

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_equation_list(eqn_item,old_comp,new_comp) => eqn_item' &
        rename_component_in_exp_equationitem_list(res,old_comp,new_comp) => res'
        ------------------------------
        rename_component_in_exp_equationitem_list((exp1,eqn_item)::res,old_comp,new_comp)
          => ((exp1',eqn_item')::res')

  rule  print "-rename_component_in_exp_equationitem_list failed\n"
        -------------------------------
        rename_component_in_exp_equationitem_list(_,_,_) => fail


end
        

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_equation:(Absyn.Equation,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.Equation =

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_equation_list(true_items,old_comp,new_comp) => true_items' &
        rename_component_in_exp_equationitem_list(exp_elseifs,old_comp,new_comp) => exp_elseifs' &
        rename_component_in_equation_list(elses,old_comp,new_comp) => elses' 
        -------------------------
        rename_component_in_equation(Absyn.EQ_IF(exp,true_items,exp_elseifs,elses),
                                     old_comp,new_comp) 
          => Absyn.EQ_IF(exp',true_items',exp_elseifs',elses')

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' 
        -------------------------
        rename_component_in_equation(Absyn.EQ_EQUALS(exp1, exp2),
                                     old_comp,new_comp)
          => Absyn.EQ_EQUALS(exp1', exp2')

          
  rule  replace_start_in_component_ref(cref1,old_comp,new_comp) => cref1' &
        replace_start_in_component_ref(cref2,old_comp,new_comp) => cref2' 
        (* print "-rename_component_in_equation EQ_CONNECT not implemented yet\n" *)
        -------------------------
        rename_component_in_equation(Absyn.EQ_CONNECT(cref1, cref2),
                                     old_comp,new_comp) 
          => Absyn.EQ_CONNECT(cref1',cref2')

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_equation_list(equations,old_comp,new_comp) => equations' 
        
        -------------------------
        rename_component_in_equation(Absyn.EQ_FOR(ident,exp,equations),
                                     old_comp,new_comp) 
          => Absyn.EQ_FOR(ident,exp',equations')

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_equation_list(equations,old_comp,new_comp) => equations' &
        rename_component_in_exp_equationitem_list(exp_equations,old_comp,new_comp) => exp_equations'
        -------------------------
        rename_component_in_equation(Absyn.EQ_WHEN_E(exp,equations,exp_equations),
                                     old_comp,new_comp) 
          => Absyn.EQ_WHEN_E(exp',equations',exp_equations')
          
  rule   print "-rename_component_in_equation EQ_NORETCALL not implemented yet\n"
        
        -------------------------
        rename_component_in_equation(Absyn.EQ_NORETCALL(ident ,function_args),
                                     old_comp,new_comp) 
          => Absyn.EQ_NORETCALL(ident ,function_args)
          
          
  rule  print "-rename_component_in_equation failed\n"
        -------------------------
        rename_component_in_equation(_,
                                     old_comp,new_comp) => fail

end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_exp_list:(Absyn.Exp list,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.Exp list =
        
  axiom  rename_component_in_exp_list([],_,_) => []

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_exp_list(res,old_comp,new_comp) => res'
        ------------------------------
        rename_component_in_exp_list(exp::res,old_comp,new_comp) => exp'::res'

  rule  print "-rename_component_in_exp_list failed\n"
        -------------------------------
        rename_component_in_exp_list(_,_,_) => fail

        
end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_exp_list_list:(Absyn.Exp list list,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.Exp list list =
        
  axiom  rename_component_in_exp_list_list([],_,_) => []

  rule  rename_component_in_exp_list(exp,old_comp,new_comp) => exp' &
        rename_component_in_exp_list_list(res,old_comp,new_comp) => res'
        ------------------------------
        rename_component_in_exp_list_list(exp::res,old_comp,new_comp) => exp'::res'

  rule  print "-rename_component_in_exp_list_list failed\n"
        -------------------------------
        rename_component_in_exp_list_list(_,_,_) => fail

        
end


(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_exp_tuple_list:((Absyn.Exp * Absyn.Exp) list,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        (Absyn.Exp * Absyn.Exp) list =
        
  axiom  rename_component_in_exp_tuple_list([],_,_) => []

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' &
        rename_component_in_exp_tuple_list(res,old_comp,new_comp) => res'
        ------------------------------
        rename_component_in_exp_tuple_list((exp1,exp2)::res,old_comp,new_comp) => ((exp1',exp2')::res')

  rule  print "-rename_component_in_exp_tuple_list failed\n"
        -------------------------------
        rename_component_in_exp_tuple_list(_,_,_) => fail

        
end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   

relation rename_component_in_element_arg_list:(Absyn.ElementArg list,
                                          Absyn.ComponentRef, (* the old name for the component *)
                                          Absyn.ComponentRef) 
          => Absyn.ElementArg list =
  
  axiom  rename_component_in_element_arg_list([],_,_) => []

  rule  rename_component_in_element_arg(element_arg,old_comp,new_comp) => element_arg' &
        rename_component_in_element_arg_list(res,old_comp,new_comp) => res'
        ------------------------------
        rename_component_in_element_arg_list(element_arg::res,old_comp,new_comp) => element_arg'::res'

  rule  print "-rename_component_in_element_arg_list failed\n"
        -------------------------------
        rename_component_in_element_arg_list(_,_,_) => fail

        
end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_element_arg:(Absyn.ElementArg,
                                          Absyn.ComponentRef, (* the old name for the component *)
                                          Absyn.ComponentRef) =>
        Absyn.ElementArg =
        
  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr' &
        rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_element_arg_list(element_args,old_comp,new_comp) => element_args'
        -----------------------------
        rename_component_in_element_arg(Absyn.MODIFICATION(b,
                                                           each,
                                                           cr,
                                                           SOME(Absyn.CLASSMOD(element_args,SOME(exp))),
                                                           str),
                                        old_comp,new_comp) 
          => Absyn.MODIFICATION(b,
                                each,
                                cr',
                                SOME(Absyn.CLASSMOD(element_args',SOME(exp'))),
                                str)
		   
  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr' &
        rename_component_in_element_arg_list(element_args,old_comp,new_comp) => element_args'
        -----------------------------
        rename_component_in_element_arg(Absyn.MODIFICATION(b,
                                                           each,
                                                           cr,
                                                           SOME(Absyn.CLASSMOD(element_args,NONE)),
                                                           str),
                                        old_comp,new_comp) 
          => Absyn.MODIFICATION(b,
                                each,
                                cr',
                                SOME(Absyn.CLASSMOD(element_args',NONE)),
                                str)
		   
  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr' 
        -----------------------------
        rename_component_in_element_arg(Absyn.MODIFICATION(b,
                                                           each,
                                                           cr,
                                                           NONE,
                                                           str),
                                        old_comp,new_comp) 
          => Absyn.MODIFICATION(b,
                                each,
                                cr',
                                NONE,
                                str)
		   
 
  rule  rename_component_in_element_spec(element_spec,old_comp,new_comp) => element_spec' &
        rename_component_in_element_spec(element_spec2,old_comp,new_comp) => element_spec2' 
        -----------------------------
        rename_component_in_element_arg(Absyn.REDECLARATION(b,
                                                            redecl,
                                                            each,
                                                            element_spec,
                                                            SOME(Absyn.CONSTRAINCLASS(element_spec2,c))),
                                        old_comp,new_comp) 
          => Absyn.REDECLARATION(b,
                                 redecl,
                                 each,
                                 element_spec',
                                 SOME(Absyn.CONSTRAINCLASS(element_spec2',c)))           

  rule  rename_component_in_element_spec(element_spec,old_comp,new_comp) => element_spec' 
        -----------------------------
        rename_component_in_element_arg(Absyn.REDECLARATION(b,
                                                            redecl,
                                                            each,
                                                            element_spec,
                                                            NONE),
                                        old_comp,new_comp) 
          => Absyn.REDECLARATION(b,
                                 redecl,
                                 each,
                                 element_spec',
                                 NONE)
        
end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_code:(Absyn.Code,                                  
                                   Absyn.ComponentRef, (* the old name for the component *)
                                   Absyn.ComponentRef) =>
        Absyn.Code =

  rule  
        ------------------------
        rename_component_in_code(Absyn.C_TYPENAME(path),old_comp,new_comp) 
          => Absyn.C_TYPENAME(path)
  
  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr'
        ------------------------
        rename_component_in_code(Absyn.C_VARIABLENAME(cr),old_comp,new_comp) 
          => Absyn.C_VARIABLENAME(cr')

  rule  rename_component_in_equation_list(eqn_items,old_comp,new_comp) => eqn_items'
        ------------------------
        rename_component_in_code(Absyn.C_EQUATIONSECTION(b,eqn_items),old_comp,new_comp) 
          => Absyn.C_EQUATIONSECTION(b,eqn_items')

  rule  rename_component_in_algorithms(algs,old_comp,new_comp) => algs'
        ------------------------
        rename_component_in_code(Absyn.C_ALGORITHMSECTION(b,algs),old_comp,new_comp)
          => Absyn.C_ALGORITHMSECTION(b,algs')

  rule  rename_component_in_element_spec(elementspec,old_comp,new_comp) => elementspec'
        ------------------------
        rename_component_in_code(Absyn.C_ELEMENT(Absyn.ELEMENT(final,redeclare,inner_outer,name,elementspec,info,constraint)),
                                 old_comp,new_comp)
          => Absyn.C_ELEMENT(Absyn.ELEMENT(final,redeclare,inner_outer,name,elementspec',info,constraint))


  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp'
        ------------------------
        rename_component_in_code(Absyn.C_EXPRESSION(exp),old_comp,new_comp) 
          => Absyn.C_EXPRESSION(exp')


  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_element_arg_list(element_args,old_comp,new_comp) => element_args'
        ------------------------
        rename_component_in_code(Absyn.C_MODIFICATION(Absyn.CLASSMOD(element_args,SOME(exp))),
                                 old_comp,new_comp)
          => Absyn.C_MODIFICATION(Absyn.CLASSMOD(element_args',SOME(exp')))

  rule  rename_component_in_element_arg_list(element_args,old_comp,new_comp) => element_args'
        ------------------------
        rename_component_in_code(Absyn.C_MODIFICATION(Absyn.CLASSMOD(element_args,NONE)),
                                 old_comp,new_comp)
          => Absyn.C_MODIFICATION(Absyn.CLASSMOD(element_args',NONE))


end



(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_exp:(Absyn.Exp,
                                  Absyn.ComponentRef, (* the old name for the component *)
                                  Absyn.ComponentRef) =>
        Absyn.Exp =

  rule
        ------------------------
        rename_component_in_exp(Absyn.INTEGER(a),old_comp,new_comp) => Absyn.INTEGER(a)

  rule
        ------------------------
        rename_component_in_exp(Absyn.REAL(a),old_comp,new_comp) => Absyn.REAL(a)

  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr'
        ------------------------
        rename_component_in_exp(Absyn.CREF(cr),old_comp,new_comp) => Absyn.CREF(cr')
        

  rule  
        ------------------------
        rename_component_in_exp(Absyn.STRING(a),old_comp,new_comp) => Absyn.STRING(a)
 
  rule  
        ------------------------
        rename_component_in_exp(Absyn.BOOL(a),old_comp,new_comp) => Absyn.BOOL(a)
 
  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' 
        ------------------------
        rename_component_in_exp(Absyn.BINARY(exp1,op,exp2),old_comp,new_comp) 
          => Absyn.BINARY(exp1',op,exp2')

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp'
        ------------------------
        rename_component_in_exp(Absyn.UNARY(op,exp),old_comp,new_comp) => Absyn.UNARY(op,exp)
 
  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' 
        ------------------------
        rename_component_in_exp(Absyn.LBINARY(exp1,op,exp2),old_comp,new_comp) 
          => Absyn.LBINARY(exp1',op,exp2')

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp'
        ------------------------
        rename_component_in_exp(Absyn.LUNARY(op,exp),old_comp,new_comp) => Absyn.LUNARY(op,exp)

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' 
        ------------------------
        rename_component_in_exp(Absyn.RELATION(exp1,op,exp2),old_comp,new_comp) 
          => Absyn.RELATION(exp1',op,exp2')

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' &
        rename_component_in_exp(exp3,old_comp,new_comp) => exp3' &
        rename_component_in_exp_tuple_list(exp_tuple_list,old_comp,new_comp) => exp_tuple_list'
        ------------------------
        rename_component_in_exp(Absyn.IFEXP(exp1,exp2,exp3,exp_tuple_list),old_comp,new_comp) 
          => Absyn.IFEXP(exp1',exp2',exp3',exp_tuple_list')

  rule  print "-rename_component_in_exp for Absyn.CALL not implemented yet\n"
        ------------------------
        rename_component_in_exp(Absyn.CALL(cref,func_args),old_comp,new_comp) => Absyn.CALL(cref,func_args)

  rule  rename_component_in_exp_list(exp_list,old_comp,new_comp) => exp_list'
        -----------------------------
       rename_component_in_exp(Absyn.ARRAY(exp_list),old_comp,new_comp) 
          => Absyn.ARRAY(exp_list')
        
  rule  rename_component_in_exp_list_list(exp_list_list,old_comp,new_comp) => exp_list_list'
        -----------------------------
        rename_component_in_exp(Absyn.MATRIX(exp_list_list),old_comp,new_comp) 
          => Absyn.MATRIX(exp_list_list')

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' &
        rename_component_in_exp(exp3,old_comp,new_comp) => exp3' 
        ------------------------
        rename_component_in_exp(Absyn.RANGE(exp1,SOME(exp2),exp3),old_comp,new_comp) 
          => Absyn.RANGE(exp1',SOME(exp2'),exp3')

  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp3,old_comp,new_comp) => exp3' 
        ------------------------
        rename_component_in_exp(Absyn.RANGE(exp1,NONE,exp3),old_comp,new_comp) 
          => Absyn.RANGE(exp1',NONE,exp3')

  rule  rename_component_in_exp_list(exp_list,old_comp,new_comp) => exp_list'
        -----------------------------
        rename_component_in_exp(Absyn.TUPLE(exp_list),old_comp,new_comp) 
          => Absyn.TUPLE(exp_list')
          
  rule  
        -----------------------------
        rename_component_in_exp(Absyn.END,old_comp,new_comp) => Absyn.END

  rule  rename_component_in_code(code,old_comp,new_comp) => code'
        -----------------------------
        rename_component_in_exp(Absyn.CODE(code),old_comp,new_comp) => Absyn.CODE(code')

  rule  print "-rename_component_in_exp failed\n"
        ------------------------
        rename_component_in_exp(_,old_comp,new_comp) => fail
end


        

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_algorithms:(Absyn.AlgorithmItem list,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.AlgorithmItem list =

  rule  
        -------------------------------------
        rename_component_in_algorithms([],_,_) => []

  rule  rename_component_in_algorithms(res,old_comp,new_comp) => res' &
        let algorithm' = algorithm 
        -------------------------------------
        rename_component_in_algorithms(algorithm::res,old_comp,new_comp) => algorithm'::res'

end


(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_algorithm:(Absyn.Algorithm,
                                        Absyn.ComponentRef, (* the old name for the component *)
                                        Absyn.ComponentRef) =>
        Absyn.Algorithm  =
        
  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr' &
        rename_component_in_exp(exp,old_comp,new_comp) => exp'
        ---------------------------
        rename_component_in_algorithm(Absyn.ALG_ASSIGN(cr,exp),old_comp,new_comp)
          => Absyn.ALG_ASSIGN(cr',exp')


  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2'
        ---------------------------
        rename_component_in_algorithm(Absyn.ALG_TUPLE_ASSIGN(exp1,exp2),old_comp,new_comp) 
          => Absyn.ALG_TUPLE_ASSIGN(exp1',exp2')


  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_algorithms(algs1,old_comp,new_comp) => algs1' &
        rename_component_in_exp_algoritms_list(exp_algs_list,old_comp,new_comp) => exp_algs_list' &
        rename_component_in_algorithms(algs2,old_comp,new_comp) => algs2' 
        ---------------------------
        rename_component_in_algorithm(Absyn.ALG_IF(exp,algs1,exp_algs_list,algs2),
                                      old_comp,new_comp)
          =>  Absyn.ALG_IF(exp',algs1',exp_algs_list',algs2')

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_algorithms(algs,old_comp,new_comp) => algs' 
        ---------------------------
        rename_component_in_algorithm(Absyn.ALG_FOR(id,exp,algs),old_comp,new_comp) 
          => Absyn.ALG_FOR(id,exp',algs')


  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_algorithms(algs,old_comp,new_comp) => algs' 
        ---------------------------
        rename_component_in_algorithm(Absyn.ALG_WHILE(exp,algs),old_comp,new_comp) 
          => Absyn.ALG_WHILE(exp',algs')


  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_algorithms(algs,old_comp,new_comp) => algs' &
        rename_component_in_exp_algoritms_list(exp_algs_list,old_comp,new_comp) => exp_algs_list' 
        ---------------------------
        rename_component_in_algorithm(Absyn.ALG_WHEN_A(exp,algs,exp_algs_list),old_comp,new_comp)
          => Absyn.ALG_WHEN_A(exp',algs',exp_algs_list')

  rule  replace_start_in_component_ref(cr,old_comp,new_comp) => cr' &
        rename_component_in_function_args(func_args,old_comp,new_comp) => func_args' 
        --------------------------
        rename_component_in_algorithm(Absyn.ALG_NORETCALL(cr,func_args),old_comp,new_comp)
        => Absyn.ALG_NORETCALL(cr',func_args')


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)

relation rename_component_in_exp_algoritms_list:((Absyn.Exp * Absyn.AlgorithmItem list) list,
                                                 Absyn.ComponentRef, (* the old name for the component *)
                                                 Absyn.ComponentRef) =>
        (Absyn.Exp * Absyn.AlgorithmItem list) list =

  axiom rename_component_in_exp_algoritms_list([],_,_) => []
        
  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_algorithms(algs,old_comp,new_comp) => algs' &
        rename_component_in_exp_algoritms_list(res,old_comp,new_comp) => res'
        ---------------------------------------------
        rename_component_in_exp_algoritms_list((exp,algs)::res,old_comp,new_comp)
          => (((exp',algs'))::res')

  rule  print "-rename_component_in_exp_algoritms_list failed\n"
        -----------------------------
        rename_component_in_exp_algoritms_list(_,_,_) => fail

end


(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)

relation rename_component_in_function_args:(Absyn.FunctionArgs,
                                            Absyn.ComponentRef, (* the old name for the component *)
                                            Absyn.ComponentRef) =>
        Absyn.FunctionArgs =

  rule  rename_component_in_exp_list(exps,old_comp,new_comp) => exps' &
        rename_component_in_namedArgs(namedArg,old_comp,new_comp) => namedArg' 
        -------------------------
        rename_component_in_function_args(Absyn.FUNCTIONARGS(exps,namedArg),old_comp,new_comp)
          => Absyn.FUNCTIONARGS(exps',namedArg')


  rule  rename_component_in_exp(exp1,old_comp,new_comp) => exp1' &
        rename_component_in_exp(exp2,old_comp,new_comp) => exp2' 
        -------------------------
        rename_component_in_function_args(Absyn.FOR_ITER_FARG(exp1,id,exp2),old_comp,new_comp) 
          =>Absyn.FOR_ITER_FARG(exp1',id,exp2')

 rule  print "-rename_component_in_function_args failed\n"
        -----------------------------
        rename_component_in_function_args(_,_,_) => fail
end
       
(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)

relation rename_component_in_namedArgs:(Absyn.NamedArg list,
                                            Absyn.ComponentRef, (* the old name for the component *)
                                            Absyn.ComponentRef) =>
        Absyn.NamedArg list =

  axiom rename_component_in_namedArgs([],_,_) => []

  rule  rename_component_in_exp(exp,old_comp,new_comp) => exp' &
        rename_component_in_namedArgs(res,old_comp,new_comp) => res' 
        ------------------------
        rename_component_in_namedArgs(Absyn.NAMEDARG(id,exp)::res,old_comp,new_comp)
          => Absyn.NAMEDARG(id,exp')::res'

 rule  print "-rename_component_in_namedArgs failed\n"
        -----------------------------
        rename_component_in_namedArgs(_,_,_) => fail


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_component_visitor
 **)
                   
relation rename_component_in_external_decl:(Absyn.ExternalDecl,
                                       Absyn.ComponentRef, (* the old name for the component *)
                                       Absyn.ComponentRef) =>
        Absyn.ExternalDecl =


  rule  print "-rename_component_in_external_decl not implemented yet\n" &
        let external' = external 
        -------------------------------------
        rename_component_in_external_decl(external,old_comp,new_comp) => external'

end


(**relation replace_start_in_component_ref
 ** author x02lucpo
 **
 ** this replace the start of a ComponentRef with another
 ** ie: (a.b.c.d, a.b, c.f) => c.f.c.d
 **    (a.b.c.d, d.c, c.f) => a.b.c.d
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **    (a.b.c.d, a.b, c.f.r) => a.b.c.d
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **)
relation replace_start_in_component_ref:(Absyn.ComponentRef,Absyn.ComponentRef,Absyn.ComponentRef) 
          => Absyn.ComponentRef =
          
  rule  
       (*  Dump.print_component_ref_str(cr1) => cref_str_tmp & print " " & print cref_str_tmp & *)
(*         Dump.print_component_ref_str(cr2) => cref_str_tmp & print " " & print cref_str_tmp & *)
(*         Dump.print_component_ref_str(cr3) => cref_str_tmp & print " " & print cref_str_tmp & *)
        replace_start_in_component_ref2(cr1,cr2,cr3) => res 
       (*  Dump.print_component_ref_str(res) => cref_str_tmp & print " res " & print cref_str_tmp & *)
(*         print "\n"  *)
        ---------------------------
        replace_start_in_component_ref(cr1,
                                       cr2,
                                       cr3) => res

end



(**relation replace_start_in_component_ref2 
 ** author x02lucpo
 **
 ** this replace the start of a ComponentRef with another
 ** ie: (a.b.c.d, a.b, c.f) => c.f.c.d
 **    (a.b.c.d, d.c, c.f) => a.b.c.d
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **    (a.b.c.d, a.b, c.f.r) => a.b.c.d
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **    WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
 **)
           
relation replace_start_in_component_ref2:(Absyn.ComponentRef,Absyn.ComponentRef,Absyn.ComponentRef) 
        => Absyn.ComponentRef =

  rule  id = id2
        ---------------------------
        replace_start_in_component_ref2(Absyn.CREF_IDENT(id,_),
                                       Absyn.CREF_IDENT(id2,_),
                                       res as Absyn.CREF_IDENT(id3,_)) => res

  rule  id = id2
        ---------------------------
        replace_start_in_component_ref2(Absyn.CREF_QUAL(id,a,cr1),
                                       Absyn.CREF_IDENT(id2,_),
                                       Absyn.CREF_IDENT(id3,_)) => Absyn.CREF_QUAL(id3,a,cr1)
         
  rule   id = id2 &
        replace_start_in_component_ref2(cr1,cr2,cr3) => cr
        ---------------------------
        replace_start_in_component_ref2(Absyn.CREF_QUAL(id,a,cr1),
                                       Absyn.CREF_QUAL(id2,_,cr2),
                                       Absyn.CREF_QUAL(id3,_,cr3)) => Absyn.CREF_QUAL(id3,a,cr)
        
  rule
        ---------------------
        replace_start_in_component_ref2(orig_cr,_,_) => orig_cr
end

(**  relation get_componentreplacementsrules
 ** author: x02lucpo
 **
 ** this extracts all the componentreplacementrules by searching for new rules until the
 ** list-size does not grow any more
 **)
             
relation get_componentreplacementsrules:(Components,ComponentReplacementRules,int) 
        => ComponentReplacementRules =

  rule  length_componentReplacementRules(comp_reps) => len &
        int_eq(len,old_len) => true
        ----------------------------
        get_componentreplacementsrules(comps,comp_reps,old_len) => comp_reps

  rule length_componentReplacementRules(comp_reps) => old_len &
        get_new_componentreplacementsrules_for_each_rule(comps,comp_reps) => comp_reps' &
        join_componentReplacementRules(comp_reps',comp_reps) => comp_reps'' &
        get_componentreplacementsrules(comps,comp_reps'',old_len) => comp_reps_res
        ----------------------------
        get_componentreplacementsrules(comps,comp_reps,len) => comp_reps_res

  rule  print "-get_componentreplacementsrules failed\n"
        ----------------------------
        get_componentreplacementsrules(comps,comp_reps,_) => fail

end

(** relation get_new_componentreplacementsrules_for_each_rule
 ** author: x02lucpo
 **
 **extracts the replacement rules from the components:
 **[COMP(path_1,path_2,cr1),COMP(path_3,path_2,cr2)],[REP_RULE(path_2,cr_1a,cr_1b)] 
 **          => [REP_RULE(path_1,cr1.cr_1a,cr1.cr_1b),REP_RULE(path_3,cr2.cr_1a,cr2.cr_1b)]
 **)
relation get_new_componentreplacementsrules_for_each_rule:(Components, ComponentReplacementRules)
        => ComponentReplacementRules =
          
  rule  empty_componentReplacementRules(comp_reps) => true
        -------------------------------------------
        get_new_componentreplacementsrules_for_each_rule(comps,comp_reps) => comp_reps

  rule  first_componentReplacement(comp_reps) => COMPONENTREPLACEMENT(path,cr1,cr2) &
        get_components_with_type(comps,path) => comps' &
        make_componentsReplacementRules_from_components(comps',cr1,cr2) => comp_reps' &
        rest_componentReplacementRules(comp_reps) => res &
        get_new_componentreplacementsrules_for_each_rule(comps,res) => comp_reps'' &
        join_componentReplacementRules(comp_reps',comp_reps'') => comp_reps'''
        ------------------------------
        get_new_componentreplacementsrules_for_each_rule(comps,comp_reps) => comp_reps'''
        
  rule  print "-get_new_componentreplacementsrules_for_each_rule failed\n"
        -------------------------------
        get_new_componentreplacementsrules_for_each_rule(_,_) => fail
        
end

(** relation make_componentsReplacementRules_from_components
 ** author: x02lucpo
 **
 ** this makes the replacementrules from each component in the first parameter:
 ** [COMP(path_1,path_2,cr1),COMP(path_3,path_2,cr2)],cr_1a,cr_1b 
 **           => [REP_RULE(path_1,cr1.cr_1a,cr1.cr_1b),REP_RULE(path_3,cr2.cr_1a,cr2.cr_1b)]
 ** 
 **) 

relation make_componentsReplacementRules_from_components:(Components,
                                                          Absyn.ComponentRef,
                                                          Absyn.ComponentRef) 
        => ComponentReplacementRules =
          
  rule  empty_components(comps) => true
        --------------------------
        make_componentsReplacementRules_from_components(comps,cr_from,cr_to) 
          => COMPONENTREPLACEMENTRULES([],0)

  rule   first_component(comps) => COMPONENTITEM(path_class,
                                                path_type,
                                                cr) &
        Absyn.join_crefs(cr,cr_from) => cr_from' &
        Absyn.join_crefs(cr,cr_to) => cr_to' &
        let comp_rep = COMPONENTREPLACEMENT(path_class,cr_from',cr_to') &
        rest_components(comps) => res &
        make_componentsReplacementRules_from_components(res,cr_from,cr_to) => comps' &
        join_componentReplacementRules(comps',COMPONENTREPLACEMENTRULES([comp_rep],1)) => comp_reps_res 
        ----------------------------------
        make_componentsReplacementRules_from_components(comps,cr_from,cr_to) => comp_reps_res

  rule   first_component(comps) => EXTENDSITEM(path_class,
                                               path_type) &
        let comp_rep = COMPONENTREPLACEMENT(path_class,cr_from,cr_to) &
        rest_components(comps) => res &
        make_componentsReplacementRules_from_components(res,cr_from,cr_to) => comps' &
        join_componentReplacementRules(comps',COMPONENTREPLACEMENTRULES([comp_rep],1)) => comp_reps_res 
        ----------------------------------
        make_componentsReplacementRules_from_components(comps,cr_from,cr_to) => comp_reps_res

  rule  print "-make_componentsReplacementRules_from_components failed\n"
        --------------------------
        make_componentsReplacementRules_from_components(_,_,_) => fail


end

(** relation empty_componentReplacementRules
 ** author: x02lucpo
 **
 ** returns true if the componentReplacementRules are empty
 **)

relation empty_componentReplacementRules:(ComponentReplacementRules) => bool =
   
  axiom empty_componentReplacementRules(COMPONENTREPLACEMENTRULES([],_)) => true
        
  axiom empty_componentReplacementRules(_) => false
end     


(**relation join_componentReplacementRules
 **author: x02lucpo
 **
 **joins two componentReplacementRules lists by union
 **)
relation join_componentReplacementRules:(ComponentReplacementRules, ComponentReplacementRules) => ComponentReplacementRules =


  rule  Util.list_union(comps1,comps2) => comps &
        list_length(comps) => len
        ---------------------------
        join_componentReplacementRules(COMPONENTREPLACEMENTRULES(comps1,len1),
                        COMPONENTREPLACEMENTRULES(comps2,len2)) 
          => COMPONENTREPLACEMENTRULES(comps,len)
                        
end

(**relation length_componentReplacementRules
 ** author: x02lucpo
 **
 ** return the number of the componentReplacementRules
 **)

relation length_componentReplacementRules:(ComponentReplacementRules) => int =
  
  axiom length_componentReplacementRules(COMPONENTREPLACEMENTRULES(_,len)) => len

end

(**  
 ** author: x02lucpo
 **
 ** dumps all the componentReplacementRules to string
**) 
relation dump_componentReplacementRules_to_string:(ComponentReplacementRules) => string =

  axiom dump_componentReplacementRules_to_string(COMPONENTREPLACEMENTRULES([],_)) => ""

  rule  rest_componentReplacementRules(comps) => res &
        dump_componentReplacementRules_to_string(res) => s1 &
        Absyn.path_string(pa) => pa_str &
        Absyn.cref_to_path(cr1) => cr1_pa &
        Absyn.path_string(cr1_pa) => cr1_str &
        Absyn.cref_to_path(cr2) => cr2_pa &
        Absyn.path_string(cr2_pa) => cr2_str &
        Util.string_append_list([s1,"In class: ", pa_str,"( ",cr1_str," => ", cr2_str," )\n"]) => res_str
        ---------------------------
        dump_componentReplacementRules_to_string(comps as COMPONENTREPLACEMENTRULES(COMPONENTREPLACEMENT(pa,cr1,cr2)::res,_)) => res_str
        
       
end        

(**
 ** author: x02lucpo
 **
 **extract the first componentReplacement in the componentReplacementReplacementRules
 **)
relation first_componentReplacement:(ComponentReplacementRules) => ComponentReplacement =
        
  rule  print "-first_componentReplacement failed: no componentReplacementReplacementRules\n" 
        -----------------------------
        first_componentReplacement(COMPONENTREPLACEMENTRULES([],_)) => fail
                        
  axiom first_componentReplacement(COMPONENTREPLACEMENTRULES(comp::res,_)) => comp

end

(**
 ** author: x02lucpo
 **
 **extract the rest componentReplacementRules from the compoents
 **)
relation rest_componentReplacementRules:(ComponentReplacementRules) => ComponentReplacementRules =
        
  axiom rest_componentReplacementRules(COMPONENTREPLACEMENTRULES([],_)) 
          => COMPONENTREPLACEMENTRULES([],0)
                        
  rule  int_sub(len,1) => len'
        ----------------------------                
        rest_componentReplacementRules(COMPONENTREPLACEMENTRULES(comp::res,len)) => COMPONENTREPLACEMENTRULES(res,len')

end



(**
 ** author:x02lucpo
 **
 **returns _all_ the Components that the class depends on. It can be components or extends
 ** i.e if a class b has a component of type a and this is called with (<components>,"a")
 ** the it will also return b
 **)
relation get_dependency_on_class:(Components,Absyn.Path) 
        => Components =

  rule  
        get_components_from_class(comps,path) => comps_types &
        
        get_dependency_with_type(comps,comps_types,0) => comps_types2 &
        
        dump_components_to_string(comps_types) => str & print "---------comps_types----------\n" & print str & print "===================\n" & 
        dump_components_to_string(comps_types2) => str & print "---------DEPENDENCIES----------\n" & print str & print "===================\n" & 

 
        join_components(comps_types,comps_types2) => comps2 
        ------------------------
        get_dependency_on_class(comps,path) => comps2

  rule  print "-get_dependency_on_class failed\n"
        ------------------------
        get_dependency_on_class(_,_) => fail

end

(**
**author: x02lucpo
 **
**helper relation to get_dependency_on_class
** extracts all the components that have the dependency on type
**)
relation get_dependency_with_type:(Components,Components,int) 
        => Components =

(*   rule  dump_components_to_string(comps) => str & print "---------comps----------\n" & print str & print "===================\n" & *)
(*         dump_components_to_string(in_comps) => str & print "---------in_comps----------\n" & print str & print "===================\n" & *)
(*         int_eq(1,2) => true *)
(*         --------------------------- *)
(*         get_dependency_with_type(comps, *)
(*                                  in_comps, *)
(*                                  old_len) => in_comps *)
        

  rule  length_components(in_comps) => len &
        int_eq(old_len,len) => true
        -------------------------
        get_dependency_with_type(comps,
                                 in_comps,
                                 old_len) 
          => in_comps

  rule  length_components(in_comps) => len &
(*         get_components_with_components_type(comps,in_comps) => in_comps' & *)
        get_components_with_components_class(comps,in_comps) => in_comps' &
        join_components(in_comps',in_comps) => comps'  &
        get_dependency_with_type(comps,comps',len) => out_comps 
        -------------------------
        get_dependency_with_type(comps,
                                 in_comps,
                                 old_len) 
          => out_comps

  rule  print "-get_dependency_with_type failed\n"
        -------------------------
        get_dependency_with_type(_,
                                 _,
                                 _) 
          => fail


end


(**
**author x02lucpo
 **
 ** extracts all the components with class == the class of the components 
 ** in the second list 
 ** from first list of Components 
 **)
relation get_components_with_components_class:(Components,Components) 
        => Components =

  rule  empty_components(in_comps) => true
        ---------------------------
        get_components_with_components_class(comps,in_comps) => COMPONENTS([],0)

  rule  first_component(in_comps) => (comp as COMPONENTITEM(comp_path,_,_)) &
        rest_components(in_comps) => in_comps' &
        get_components_with_type(comps,comp_path) => comp1 &
        get_components_with_components_class(comps,in_comps') => comps' &
        join_components(comp1,comps') => comps'' 
        ---------------------------
        get_components_with_components_class(comps,in_comps) => comps''

  rule  first_component(in_comps) => (comp as EXTENDSITEM(comp_path,_)) &
        rest_components(in_comps) => in_comps' &
        get_components_with_type(comps,comp_path) => comp1 &
        get_components_with_components_class(comps,in_comps') => comps' &
        join_components(comp1,comps') => comps'' 
        ---------------------------
        get_components_with_components_class(comps,in_comps) => comps''

  rule  print "-get_components_with_components_class failed\n"
        ---------------------------
        get_components_with_components_class(_,_) => fail
end

(**
**author x02lucpo
 **
** extracts all the components with class == the type of the components 
 ** in the second list 
** from first list of Components 
**)
relation get_components_with_components_type:(Components,Components) 
        => Components =

  rule  empty_components(in_comps) => true
        ---------------------------
        get_components_with_components_type(comps,in_comps) => COMPONENTS([],0)

  rule  first_component(in_comps) => (comp as COMPONENTITEM(_,comp_path,_)) &
        rest_components(in_comps) => in_comps' &
        get_components_with_type(comps,comp_path) => comp1 &
        get_components_with_components_type(comps,in_comps') => comps' &
        join_components(comp1,comps') => comps'' 
        ---------------------------
        get_components_with_components_type(comps,in_comps) => comps''

  rule  first_component(in_comps) => (comp as EXTENDSITEM(_,comp_path)) &
        rest_components(in_comps) => in_comps' &
        get_components_with_type(comps,comp_path) => comp1 &
        get_components_with_components_type(comps,in_comps') => comps' &
        join_components(comp1,comps') => comps'' 
        ---------------------------
        get_components_with_components_type(comps,in_comps) => comps''

  rule  print "-get_components_with_components_type failed\n"
        ---------------------------
        get_components_with_components_type(_,_) => fail
end
(**
 **author: x02lucpo
 **
 **extracts all the components that are in the class
 **)
relation get_components_from_class:(Components,Absyn.Path) 
        => Components =
          
(*   rule  Absyn.path_string(path) => comp_path & *)
(*         print "extracting comps for: " & print comp_path & print "\n" & *)
(*         int_eq(1,2) => true *)
(*         --------------------------- *)
(*         get_components_from_class(comps,path) => comps *)


  rule  empty_components(comps) => true
        ---------------------------
        get_components_from_class(comps,_) => COMPONENTS([],0)

  rule  first_component(comps) => (comp as COMPONENTITEM(comp_path,_,_)) &
        ModUtil.path_equal(comp_path,path) => true &
        rest_components(comps) => res &
        get_components_from_class(res,path) => comps' &
        add_component_to_components(comp,comps') => comps''
        ---------------------------
        get_components_from_class(comps,path) => comps''

  rule  first_component(comps) => (comp as EXTENDSITEM(comp_path,_)) &
        ModUtil.path_equal(comp_path,path) => true &
        rest_components(comps) => res &
        get_components_from_class(res,path) => comps' &
        add_component_to_components(comp,comps') => comps''
        ---------------------------
        get_components_from_class(comps,path) => comps''

  rule  rest_components(comps) => res &
        get_components_from_class(res,path) => comps'
        ---------------------------
        get_components_from_class(comps,path) => comps'

  rule  print "-get_components_from_class failed\n"
        ---------------------------
        get_components_from_class(_,_) => COMPONENTS([],0)

end

(**
 **author: x02lucpo
 **
 **extracts all the components that have the type
 **)
relation get_components_with_type:(Components,Absyn.Path) 
        => Components =
          
(*   rule  Absyn.path_string(path) => comp_path & *)
(*         print "extracting comps for: " & print comp_path & print "\n" & *)
(*         int_eq(1,2) => true *)
(*         --------------------------- *)
(*         get_components_with_type(comps,path) => comps *)


  rule  empty_components(comps) => true
        ---------------------------
        get_components_with_type(comps,_) => COMPONENTS([],0)

  rule  first_component(comps) => (comp as COMPONENTITEM(_,comp_path,_)) &
        ModUtil.path_equal(comp_path,path) => true &
        rest_components(comps) => res &
        get_components_with_type(res,path) => comps' &
        add_component_to_components(comp,comps') => comps''
        ---------------------------
        get_components_with_type(comps,path) => comps''

  rule  first_component(comps) => (comp as EXTENDSITEM(_,comp_path)) &
        ModUtil.path_equal(comp_path,path) => true &
        rest_components(comps) => res &
        get_components_with_type(res,path) => comps' &
        add_component_to_components(comp,comps') => comps''
        ---------------------------
        get_components_with_type(comps,path) => comps''

  rule  rest_components(comps) => res &
        get_components_with_type(res,path) => comps'
        ---------------------------
        get_components_with_type(comps,path) => comps'

  rule  print "-get_components_with_type failed\n"
        ---------------------------
        get_components_with_type(_,_) => COMPONENTS([],0)

end
(**
 ** author: x02lucpo
  **
** this traverse all the classes and extracts all the components and "extends"
 **)
 relation extract_all_components:(Absyn.Program)
        => Components =

  rule  SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
        traverse_classes(p,NONE,extract_all_components_visitor,
                         (COMPONENTS([],0),p,env),
			 true (* traverse protected*)) => ((p',_,(comps,p,env))) 
        
        -----------------------------------
        extract_all_components(p) => comps
        
        

end


(** relation extract_all_components_visitor 
 ** author: x02lucpo
 **
 ** the visitor for traverse-classes that extracts all the components and extends
 ** from all classes
 **)
            
 relation extract_all_components_visitor:((Absyn.Class* Absyn.Path option *(Components*Absyn.Program*Env.Env)))
	  => ((Absyn.Class*Absyn.Path option *(Components*Absyn.Program*Env.Env))) =
          (*)))*)
        
        
  rule  

        Absyn.join_paths(pa,Absyn.IDENT(id)) => path' &
        get_class_env_no_elaboration(p,path',env) => cenv &
        Inst.make_fully_qualified(cenv,path') => pa' &
        extract_components_from_class(class,pa',comps,cenv) => comps'
	----------------
	extract_all_components_visitor((class as Absyn.CLASS(id,a,b,c,d,e,file_info),SOME(pa),(comps,p,env)))
	  => ((class,SOME(pa),(comps',p,env)))
          
  rule  let path' = Absyn.IDENT(id) &
        get_class_env_no_elaboration(p,path',env) => cenv &
        Inst.make_fully_qualified(cenv,path') => pa' &
        extract_components_from_class(class,pa',comps,cenv) => comps'
	----------------
	extract_all_components_visitor((class as Absyn.CLASS(id,a,b,c,d,e,file_info),NONE,(comps,p,env)))
	  => ((class,NONE,(comps',p,env)))
          

end

(** 
 ** author: x02lucpo
 **
 ** help relation to extract_all_components_visitor
 **)

relation extract_components_from_class:(Absyn.Class, 
                                        Absyn.Path, (*the QUALIFIED path*)
                                        Components,
                                        Env.Env) 
          => Components =
          
  rule  extract_components_from_classdef(pa,classdef,comps,env) => comps'
        ---------------------
        extract_components_from_class(Absyn.CLASS(id,_,_,_,_,classdef,info),
                                      pa,
                                      comps,env) => comps'
        
  rule  print "-extract_components_from_class failed\n"
        ---------------------
        extract_components_from_class(_,_,comps,env) => fail
        

end


(** 
 ** author: x02lucpo
 **
 ** help relation to extract_all_components_visitor
 **)

relation extract_components_from_classdef:(Absyn.Path, (*the QUALIFIED path for the class*)
                                           Absyn.ClassDef,
                                           Components,
                                           Env.Env)
        => Components =

  rule  extract_components_from_classparts(pa,parts,comps,env) => comps'
        ----------------------------
        extract_components_from_classdef(pa,Absyn.PARTS(parts,_),comps,env) => comps'

  rule   
        extract_components_from_elementargs(pa,elementargs,comps,env) => comps'
(*          & print "extract_components_from_classdef for DERIVED not implemented yet\n"  *)
        ----------------------------
        extract_components_from_classdef(pa,Absyn.DERIVED(path,_,_,elementargs,_),comps,env) => comps'

  rule  extract_components_from_classparts(pa,parts,comps,env) => comps' 
        ----------------------------
        extract_components_from_classdef(pa,Absyn.CLASS_EXTENDS(id_ex,elementarg,_,parts),comps,env) => comps'

  rule  
        ----------------------------
        extract_components_from_classdef(pa,_,comps,env) => comps
     

end


(** 
 ** author: x02lucpo
 **
 ** help relation to extract_all_components_visitor
 **)

relation extract_components_from_classparts:(Absyn.Path, (*the QUALIFIED path for the class*)
                                             Absyn.ClassPart list,
                                             Components,
                                             Env.Env)
          => Components =
          
  axiom  extract_components_from_classparts(_,[],comps,env) => comps

  rule  extract_components_from_classparts(pa,res,comps,env) => comps' &
        extract_components_from_elements(pa,elements,comps',env) => comps''
        ---------------------------
        extract_components_from_classparts(pa,Absyn.PUBLIC(elements)::res,comps,env) => comps''

  rule  extract_components_from_classparts(pa,res,comps,env) => comps' &
        extract_components_from_elements(pa,elements,comps',env) => comps''
        ---------------------------
        extract_components_from_classparts(pa,Absyn.PROTECTED(elements)::res,comps,env) => comps''

  rule  
        ---------------------------
        extract_components_from_classparts(_,_,comps,env) => comps

end


(** 
 ** author: x02lucpo
 **
 ** help relation to extract_all_components_visitor
 **)

relation extract_components_from_elements:(Absyn.Path, (*the QUALIFIED path for the class*)
                                           Absyn.ElementItem list,
                                           Components,
                                           Env.Env)
          => Components =
          
  axiom extract_components_from_elements(_,[],comps,env) => comps

  rule  extract_components_from_elements(pa,res,comps,env) => comps' &
        extract_components_from_elementspec(pa,elementspec,comps',env) => comps''
        ------------------------------
        extract_components_from_elements(pa,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,elementspec,_,_))::res,comps,env) => comps''
          
  rule  extract_components_from_elements(pa,res,comps,env) => comps'
        ------------------------------
        extract_components_from_elements(pa,element::res,comps,env) => comps

end


(** 
 ** author: x02lucpo
 **
 ** help relation to extract_all_components_visitor
 **)

relation extract_components_from_elementspec:(Absyn.Path, (*the QUALIFIED path for the class*)
                                              Absyn.ElementSpec,
                                              Components,
                                              Env.Env)
          => Components =
          
  rule Lookup.lookup_class(env,path',false) => (SCode.CLASS(id,_,_,_,_),cenv) &
        let path' = Absyn.IDENT(id) &
        Inst.make_fully_qualified(cenv,path') => path &
        extract_components_from_componentitems(pa,path,comp_items,comps,env) => comps'
        -------------------------------
        extract_components_from_elementspec(pa,Absyn.COMPONENTS(_,path',comp_items),comps,env) => comps'

  rule  (* print "extract_components_from_elementspec Absyn.EXTENDS(path,_) not implemented yet" *)
        
        Lookup.lookup_class(env,path',false) => (_,cenv) &
        Inst.make_fully_qualified(cenv,path') => path &
        let comp = EXTENDSITEM(pa,path) & 
         add_component_to_components(comp,comps) => comps' &
        extract_components_from_elementargs(pa,elementargs,comps',env) => comps''
        -------------------------------
        extract_components_from_elementspec(pa,Absyn.EXTENDS(path',elementargs),comps,env) => comps''


(*   rule  extract_components_from_class(class,pa,comps,env) => comps' *)
(*         ------------------------------- *)
(*         extract_components_from_elementspec(pa,Absyn.CLASSDEF(_,class), *)
(*                                             comps,env) => comps' *)

  rule  
        -------------------------------
        extract_components_from_elementspec(_,_,comps,env) => comps

end



(** 
 ** author: x02lucpo
 **
 ** help relation to extract_all_components_visitor
 **)

relation extract_components_from_componentitems:(Absyn.Path, (*the QUALIFIED path for the class*)
                                                 Absyn.Path, (* the fully qualifired path for the type of the component*)
                                                 Absyn.ComponentItem list,
                                                 Components,
                                                 Env.Env)
          => Components =
          

  axiom extract_components_from_componentitems(_,_,[],comps,env) => comps

  rule  extract_components_from_componentitems(pa,path,res,comps,env) => comps' &
        let comp = Absyn.CREF_IDENT(id,[]) &
        add_component_to_components(COMPONENTITEM(pa,path,comp),comps') => comps'' &
        extract_components_from_modification_option(pa,mod_opt,comps'',env) => comps'''
        ------------------------------- 
        extract_components_from_componentitems(pa,
                                               path,
                                               Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,mod_opt),_,_)::res,
                                               comps,env) => comps'''

  rule  print "-extract_components_from_componentitems failed\n"
        -------------------------------
        extract_components_from_componentitems(_,_,_,_,env) => fail

end

relation extract_components_from_elementargs:(Absyn.Path, (*the QUALIFIED path for the class*)
                                              Absyn.ElementArg list,
                                              Components,
                                              Env.Env)
          => Components =

  axiom  extract_components_from_elementargs(pa,[],comps,env) => comps

  rule  extract_components_from_elementspec(pa,elementspec,comps,env) => comps' &
        extract_components_from_elementspec(pa,elementspec2,comps',env) => comps'' &
        extract_components_from_elementargs(pa,res,comps'',env) => comps'''
        ------------------------------
        extract_components_from_elementargs(pa,Absyn.REDECLARATION(_,_,_,elementspec,SOME(Absyn.CONSTRAINCLASS(elementspec2,_)))::res,
                                           comps,env)
          => comps'''

  rule  extract_components_from_elementspec(pa,elementspec,comps,env) => comps'  &
        extract_components_from_elementargs(pa,res,comps',env) => comps''
        ------------------------------
        extract_components_from_elementargs(pa,Absyn.REDECLARATION(_,_,_,elementspec,SOME(constrainclass))::res,
                                           comps,env) => comps''

  rule  extract_components_from_modification_option(pa,mod_opt,comps,env) => comps' &
        extract_components_from_elementargs(pa,res,comps',env) => comps''
        ------------------------------
        extract_components_from_elementargs(pa,Absyn.MODIFICATION(_,_,_,mod_opt,_)::res,
                                           comps,env)
          => comps''

  rule  extract_components_from_elementargs(pa,res,comps,env) => comps'
        --------------------------------        
        extract_components_from_elementargs(pa,a::res,comps,env) => comps'

end

relation extract_components_from_modification_option:(Absyn.Path, (*the QUALIFIED path for the class*)
                                              Absyn.Modification option,
                                              Components,
                                              Env.Env)
          => Components =

  axiom extract_components_from_modification_option(pa,NONE,comps,env) => comps
        
  rule  extract_components_from_elementargs(pa,elementargs,comps,env) => comps'
        -----------------
        extract_components_from_modification_option(pa,SOME(Absyn.CLASSMOD(elementargs,_)),comps,env) => comps'

end

(**
 **author: x02lucpo
 **joins two components lists by union
 **)
relation join_components:(Components, Components) => Components =


  rule  Util.list_union(comps1,comps2) => comps &
        list_length(comps) => len
        ---------------------------
        join_components(COMPONENTS(comps1,len1),
                        COMPONENTS(comps2,len2)) 
          => COMPONENTS(comps,len)
                        
end
(**
**author: x02lucpo
**checks if a component exists in the components
**)
relation exists_component_in_components:(Components,Component) => bool =

  axiom exists_component_in_components(COMPONENTS([],_),comp) => false

  rule  first_component(comps) => COMPONENTITEM(a,b,c) &
        ModUtil.path_equal(a,ap) => true &
        ModUtil.path_equal(b,bp) => true &
        Absyn.cref_equal(c,cr) => true
        -------------------------------
        exists_component_in_components(comps,
                                       COMPONENTITEM(ap,bp,cr)) => true

  rule   first_component(comps) => EXTENDSITEM(a,b) &
        ModUtil.path_equal(a,ap) => true &
        ModUtil.path_equal(b,bp) => true 
        -------------------------------
        exists_component_in_components(comps,
                                       EXTENDSITEM(ap,bp)) => true

  rule  exists_component_in_components(comps,comp) => res
        -------------------------------
        exists_component_in_components(comps,comp) => res

end


(**
 ** author: x02lucpo
 ** returns true if the components are empty
 **)
relation empty_components:(Components) => bool =
   
  axiom empty_components(COMPONENTS([],_)) => true
        
  axiom empty_components(_) => false
end     
(**
 ** author: x02lucpo
 **extract the first component in the components
 **)
relation first_component:(Components) => Component =
        
  rule  print "-first_component failed: no components\n" 
        -----------------------------
        first_component(COMPONENTS([],_)) => fail
                        
  axiom first_component(COMPONENTS(comp::res,_)) => comp

end

(**
 ** author: x02lucpo
 **extract the rest components from the compoents
 **)
relation rest_components:(Components) => Components =
        
  axiom rest_components(COMPONENTS([],_)) => COMPONENTS([],0)
                        
  rule  int_sub(len,1) => len'
        ----------------------------                
        rest_components(COMPONENTS(comp::res,len)) => COMPONENTS(res,len')

end
(**
 ** author: x02lucpo
 ** return the number of the components
 **)

relation length_components:(Components) => int =
  
  axiom length_components(COMPONENTS(_,len)) => len

end

(**
 ** author: x02lucpo
 ** add a component to components
 **)
relation add_component_to_components:(Component,Components) => Components  =

  rule  int_add(len,1) => len'
        ---------------------------
        add_component_to_components(comp,COMPONENTS(comps,len)) => COMPONENTS(comp::comps,len')

end
(**  
 ** author: x02lucpo
 ** dumps all the components to string
**) 
relation dump_components_to_string:(Components) => string =

  axiom dump_components_to_string(COMPONENTS([],_)) => ""

  rule  rest_components(comps) => res &
        dump_components_to_string(res) => s1 &
        Absyn.path_string(pa) => pa_str &
        Absyn.path_string(path) => path_str &
        Absyn.cref_to_path(cr) => cr_pa &
        Absyn.path_string(cr_pa) => cr_str &
        Util.string_append_list([s1,"cl: ", pa_str,"\t type: ",path_str,"\t\t name: ", cr_str,"\n"]) => res_str
        ---------------------------
        dump_components_to_string(comps as COMPONENTS(COMPONENTITEM(pa,path,cr)::res,_)) => res_str
        
  rule  rest_components(comps) => res &
        dump_components_to_string(res) => s1 &
        Absyn.path_string(pa) => pa_str &
        Absyn.path_string(path) => path_str &
        Util.string_append_list([s1,"ex: ", pa_str,"\t exte: ",path_str,"\n"]) => res_str
       ---------------------------
        dump_components_to_string(comps as COMPONENTS(EXTENDSITEM(pa,path)::res,_)) => res_str
       
end        


 (** relation: is_parameter_element
  **
  ** Returns true if Element is a component of variability parameter, 
  ** false otherwise.
 **)
 relation is_parameter_element: (Absyn.Element) => bool =

   axiom	is_parameter_element( Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.PARAM,_,_),_,_),_,_)) => true

   axiom	is_parameter_element(_) => false
end


 (**relation: get_parameter_names
  **
  ** Retrieves the names of all parameters in the class 
  **
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.Program)
  ** outputs:  string 
  **)
relation get_parameter_names: (Absyn.ComponentRef, 
				Absyn.Program) => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_select(comps,is_parameter_element) => comps' &
	 Util.list_map(comps',get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_map(compelts',get_componentitem_name) => names &
	 Util.string_delimit_list(names,", ") => res &
	 Util.string_append_list(["{",res,"}"]) => res'
	 -------------------------------------------
	 get_parameter_names(class,p) => res'

 axiom	get_parameter_names(_,_) => "Error"
end


 (**relation: get_class_env
  **
  ** Retrieves the environment of the class, including the frame of the class
  ** itself by partially instantiating it.
  **)
relation get_class_env: (Absyn.Program, Absyn.Path) => Env.Env =


   rule	SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,p_class,false) 
	   => (cl as SCode.CLASS(id,_,encflag,restr,_),env') &
	 Env.open_scope(env',encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,Connect.empty_set,ci_state,cl,false,[]) 
	   => (env'',_)
	 ---------------------
	 get_class_env(p,p_class) => env''

end
 (**relation: get_class_env_no_elaboration
  **
  ** Retrieves the environment of the class, including the frame of the class
  ** itself by partially instantiating it.
  **)
relation get_class_env_no_elaboration: (Absyn.Program, 
                                        Absyn.Path, 
                                        Env.Env (*SCode.elaborate(p) => p'& Inst.make_env_from_program(p',Absyn.IDENT("")) => env *)
                                        ) 
          => Env.Env =


   rule	 Lookup.lookup_class(env,p_class,false) 
	   => (cl as SCode.CLASS(id,_,encflag,restr,_),env') &
	 Env.open_scope(env',encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,Connect.empty_set,ci_state,cl,false,[]) 
	   => (env'',_)
	 ---------------------
	 get_class_env_no_elaboration(p,p_class,env) => env''

end


(**relation: set_component_properties
 **
 ** Sets the following "properties" of a component.
 ** - final 
 ** - flow
 ** - protected(true) or public(false)
 ** - replaceable 
 ** - variablity: "constant" or "discrete" or "parameter" or ""
 ** - dynamic_ref: {inner, outer} - two boolean values.
 ** - causality: "input" or "output" or ""
 **
 ** inputs:  (Absyn.Path, /* class */
              Absyn.ComponentRef, /* component_ref */
              bool, /* final = true */
              bool, /* flow = true */
              bool, /* protected = true, public=false */
              bool,  /* replaceable = true */
              string, /* variability */
              bool list, /* dynamic_ref, two booleans */
              string, /* causality */
              Absyn.Program)
 ** outputs: (string, Absyn.Program) 
 **)
relation set_component_properties: (Absyn.Path, 
				    Absyn.ComponentRef, 
				    bool, 
				    bool, 
				    bool, 
				    bool, 
				    string, 
				    bool list, 
				    string, 
				    Absyn.Program)
	  => (string, Absyn.Program) =

  rule	
	build_within(p_class) => within &
	get_pathed_class_in_program(p_class,p) => cdef &
	set_component_properties_in_class(cdef,varname,final,flow,prot,repl,
					  variability,dyn_ref,causality) 
	  => cdef' &
	update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	-----------------------------------
	set_component_properties(p_class,Absyn.CREF_IDENT(varname,_),
				 final,flow,prot,repl,variability,
				 dyn_ref,causality,p) 
	  => ("Ok",newp) 

  axiom	set_component_properties(_,_,_,_,_,_,_,_,_,p)  => ("Error",p) 
end


(**relation: set_component_properties_in_class
 **
 ** Helperrelation to set_component_properties.
 **
 ** inputs:  (Absyn.Class,
              string, /* comp_name */
              bool, /* final */
              bool, /* flow */
              bool, /* prot */
              bool, /* repl */
              string, /* variability */
              bool list, /* dynamic_ref, two booleans */
              string) /* causality */
 ** outputs: Absyn.Class 
 **)
relation set_component_properties_in_class:( Absyn.Class,
					    string, 
					    bool, 
					    bool, 
					    bool, 
					    bool, 
					    string, 
					    bool list, 
					    string) 
	=> Absyn.Class =


   rule	set_component_properties_in_classparts(parts,varname,final,flow,prot,repl,variability,dyn_ref,causality) 
	   => parts'
	   ---------------------------------------------------------
	 set_component_properties_in_class(Absyn.CLASS(id,p,f,e,r,
							Absyn.PARTS(parts,cmt),file_info),
					   varname, final,flow,prot,repl,
					   variability,dyn_ref,causality)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file_info)
end


 (**relation: set_component_properties_in_classparts
  **
  ** Helperrelation to set_component_properties_in_class.
  **
  ** inputs: (Absyn.ClassPart list, 
              Absyn.Ident, /* comp_name */
              bool, /* final */
              bool, /* flow */
              bool, /* prot */
              bool, /* repl */
              string, /* variability */
              bool list, /* dynamic_ref, two booleans */
              string) /* causality */
  ** outputs: Absyn.ClassPart list
  **)
relation set_component_properties_in_classparts: (Absyn.ClassPart list, 
						  Absyn.Ident,
						  bool,
						  bool,
						  bool,
						  bool,
						  string,
						  bool list,
						  string)
	 => Absyn.ClassPart list =

  axiom	set_component_properties_in_classparts([],_,_,_,_,_,_,_,_) => []

	  (* public moved to protected *)
  rule	get_public_list(parts) => publst &
	get_elementitem_contains_name(Absyn.CREF_IDENT(cr,[]),publst) 
	  => Absyn.ELEMENTITEM(elt) &
	set_component_properties_in_element(elt,cr,final,flow,repl,
					    variability,dyn_ref,
					    causality) => elt' &
	delete_component_from_elementitems(cr,publst) => publst' &
	get_protected_list(parts) => protlst &
	list_append(protlst,[Absyn.ELEMENTITEM(elt')]) => protlst' &
	replace_protected_list(parts,protlst') => parts' &
	replace_public_list(parts',publst') => parts''
	-----------------------------------
	set_component_properties_in_classparts(parts,cr,final,flow,
					       true (*protected*),
					       repl,variability,dyn_ref,
					       causality)
	  => parts''

	  (* protected moved to public *)
  rule	get_protected_list(parts) => protlst &
	get_elementitem_contains_name(Absyn.CREF_IDENT(cr,[]),protlst) 
	  => Absyn.ELEMENTITEM(elt) &
	set_component_properties_in_element(elt,cr,final,flow,repl,
					    variability,dyn_ref,
					    causality) => elt' &
	delete_component_from_elementitems(cr,protlst) => protlst' &
	get_public_list(parts) => publst &
	list_append(publst,[Absyn.ELEMENTITEM(elt')]) => publst' &
	replace_public_list(parts,publst') => parts' &
	replace_protected_list(parts',protlst') => parts''
	-----------------------------------
	set_component_properties_in_classparts(parts,cr,final,flow,
					       false, (* public *)
					       repl,
					       variability,dyn_ref,
					       causality)
	  => parts''

	  (* protected attr not changed. *)
  rule	set_component_properties_in_classparts(rest,cr,final,flow,prot,repl,
					       variability,dyn_ref,causality) 
	  => rest &
	  set_component_properties_in_elementitems(elts,cr,final,flow,repl,
						   variability,dyn_ref,
						   causality) 
	  => elts' 	
	-----------------------------------
	set_component_properties_in_classparts(Absyn.PUBLIC(elts)::rest,cr,
					       final,flow,prot,repl,
					       variability,dyn_ref,causality)
	  => Absyn.PUBLIC(elts')::rest

	  (* protected attr not changed, 2. *)
  rule	set_component_properties_in_classparts(rest,cr,final,flow,prot,repl,
					       variability,dyn_ref,causality) 
	  => rest &
	  set_component_properties_in_elementitems(elts,cr,final,flow,repl,
						   variability,dyn_ref,
						   causality) 
	  => elts' 	
	-----------------------------------
	set_component_properties_in_classparts(Absyn.PROTECTED(elts)::rest,cr,final,flow,prot,repl,variability,dyn_ref,causality)
	  => Absyn.PROTECTED(elts')::rest

	  (* protected attr not changed, 3. *)
  rule	set_component_properties_in_classparts(rest,cr,final,flow,prot,repl,
					       variability,dyn_ref,causality) 
	  => rest'
	-----------------------------------
	set_component_properties_in_classparts(part::rest,cr,final,flow,prot,
					       repl,
					       variability,dyn_ref,causality)
	  => part::rest'

end


(**relation: set_component_properties_in_elementitems
 **
 ** Helperrelation to set_component_properties_in_classparts.
 **
 ** inputs:  (Absyn.ElementItem list,
              Absyn.Ident, /* comp_name */
              bool, /* final */
              bool, /* flow */
              bool, /* repl */
              string, /* variability */
              bool list, /* dynamic_ref, two booleans */
              string) /* causality */
 ** outputs:  Absyn.ElementItem list
 **)
relation set_component_properties_in_elementitems: (Absyn.ElementItem list,
						    Absyn.Ident,
						    bool,
						    bool,
						    bool,
						    string,
						    bool list,
						    string)
							
	 => Absyn.ElementItem list =

  axiom	set_component_properties_in_elementitems([],_,_,_,_,_,_,_) => [] 

   rule	set_component_properties_in_elementitems(rest,cr,final,flow,
						 repl,va,dr,cau) 
	   => res &
	set_component_properties_in_element(elt,cr,final,flow,
					    repl,va,dr,cau) => elt'
	-------------------------------------------------
	set_component_properties_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,
						 cr,final,flow,repl,va,dr,cau)
	  => Absyn.ELEMENTITEM(elt')::res
	  
  rule	set_component_properties_in_elementitems(rest,cr,final,flow,repl,va,
						 dr,cau)
	  => res 
	  -------------------------------------------------
	set_component_properties_in_elementitems(elt::rest,
						 cr,final,flow,repl,va,dr,cau)
	  => elt::res
end


(**relation: set_component_properties_in_element
 ** 
 ** Helperrelation to e.g. set_component_properties_in_elementitems.
 **
 ** inputs:  (Absyn.Element,
              Absyn.Ident,
              bool, /* final */
              bool, /* flow */
              bool, /* repl */
              string, /* variability */
              bool list, /* dynamic_ref, two booleans */
              string) /* causality */
 ** outputs: Absyn.Element
 **)
relation set_component_properties_in_element: (Absyn.Element,
					       Absyn.Ident,
					       bool,
					       bool,
					       bool,
					       string,
					       bool list,
					       string)
	=> Absyn.Element =

  rule	get_compitem_named(Absyn.CREF_IDENT(cr,[]),ellst) => _ &
	set_replaceable_keyword_attributes(redeclkw,repl) => redeclkw' &
	set_inner_outer_attributes(dr) => inout' &
	set_component_properties_in_elementspec(spec,cr,flow,va,cau) => spec' 
	-----------------------------------------
	set_component_properties_in_element(Absyn.ELEMENT(_,redeclkw,inout,id,
	  spec as Absyn.COMPONENTS(_,_,ellst),info,constr),cr,final,flow,repl,va,dr,cau)
	  => Absyn.ELEMENT(final,redeclkw',inout',id,spec',info,constr)

  axiom	set_component_properties_in_element(elt,cr,_,_,_,_,_,_) => elt

end


(**relation: set_replaceable_keyword_attributes
 **
 ** Sets The RedeclareKeywords of an Element given a boolean 'replaceable'.
 **
 ** inputs:  (Absyn.RedeclareKeywords option, 
              bool /* repl */)
 ** outputs: Absyn.RedeclareKeywords option =
 **)
relation set_replaceable_keyword_attributes: (Absyn.RedeclareKeywords option, 
					    bool)
	=> Absyn.RedeclareKeywords option =


(* false *)
  axiom	set_replaceable_keyword_attributes(NONE,false) => NONE

  axiom	set_replaceable_keyword_attributes(SOME(Absyn.REPLACEABLE),false) 
	  => NONE
  axiom	set_replaceable_keyword_attributes(SOME(Absyn.REDECLARE_REPLACEABLE),false) 
	  => SOME(Absyn.REDECLARE)
  axiom	set_replaceable_keyword_attributes(SOME(Absyn.REDECLARE),false) => SOME(Absyn.REDECLARE)

(* true *)
  axiom	set_replaceable_keyword_attributes(NONE,true) => SOME(Absyn.REPLACEABLE)
  axiom	set_replaceable_keyword_attributes(SOME(Absyn.REDECLARE),true) 
	  => SOME(Absyn.REDECLARE_REPLACEABLE)
  axiom	set_replaceable_keyword_attributes(SOME(Absyn.REPLACEABLE),true) 
	  => SOME(Absyn.REPLACEABLE)
  axiom	set_replaceable_keyword_attributes(SOME(Absyn.REDECLARE_REPLACEABLE),true) 
	  => SOME(Absyn.REDECLARE_REPLACEABLE)
end


(**relation: set_inner_outer_attributes
 **
 **
 ** Sets InnerOuter according to a list of two booleans, {inner, outer}.
 **) 
relation set_inner_outer_attributes: (bool list)
	  => Absyn.InnerOuter =
	  
  axiom	set_inner_outer_attributes([false,false]) => Absyn.UNSPECIFIED
  axiom	set_inner_outer_attributes([true,false]) => Absyn.INNER
  axiom	set_inner_outer_attributes([false,true]) => Absyn.OUTER
  axiom	set_inner_outer_attributes([true,true]) => Absyn.INNEROUTER
end


(**relation: set_component_properties_in_elementspec
 **
 ** Sets component attributes on an elements spec if identifier matches.
 ** 
 ** inputs:  (Absyn.ElementSpec,
              Absyn.Ident,
              bool, /* flow */
              string, /* variability */
              string) /* causality */
 ** outputs:  Absyn.ElementSpec
 **)
relation set_component_properties_in_elementspec: (Absyn.ElementSpec,
						   Absyn.Ident,
						   bool, 
						   string, 
						   string) 
	=> Absyn.ElementSpec =

  rule	items_contain_compname(items,cr) &
	set_element_attributes(attr,flow,va,cau) => attr' 
	--------------------------------------
	set_component_properties_in_elementspec(Absyn.COMPONENTS(attr,path,items),cr,flow,va,cau) => Absyn.COMPONENTS(attr',path,items)

  axiom	set_component_properties_in_elementspec(spec,_,_,_,_) => spec
end


(**relation: items_contain_compname
 **
 ** Checks if a list of ElementItems contain a component named 'cr'.
 **)
relation items_contain_compname: (Absyn.ComponentItem list, Absyn.Ident) => () =

  rule	cr1 = cr2
	-------------------------
	items_contain_compname(Absyn.COMPONENTITEM(Absyn.COMPONENT(cr1,_,_),_,_)::_,cr2) => ()

  rule	items_contain_compname(rest,cr) 
	-------------------------
	items_contain_compname(_::rest,cr) => ()
end


(**relation: set_element_attributes
 **
 ** Sets  attributes associated with ElementAttribues.
 **
 ** inputs: (Absyn.ElementAttributes,
             bool, /* flow */
             string, /* variability */
             string) /*causality */
 ** outputs: Absyn.ElementAttributes
 **)
relation set_element_attributes: (Absyn.ElementAttributes,
				  bool,
				  string,
				  string)
	=> Absyn.ElementAttributes =
	  
  rule	set_element_variability(va) => va' &
	set_element_causality(cau) => cau'
	-------------
	set_element_attributes(Absyn.ATTR(_,_,_,dim),
			       flow,va,cau) 
	  => Absyn.ATTR(flow, va',cau',dim)
end


(**relation set_element_variability 
 **
 ** Sets Variability according to string value.
 **)
relation set_element_variability: (string) => Absyn.Variability =

  axiom	set_element_variability("") => Absyn.VAR

  axiom	set_element_variability("discrete") => Absyn.DISCRETE
  axiom	set_element_variability("parameter") => Absyn.PARAM
  axiom	set_element_variability("constant") => Absyn.CONST

end


(**relation set_element_causality 
 **
 ** Sets Direction (causality) according to string value.
 **)
relation set_element_causality: (string) => Absyn.Direction =

  axiom	set_element_causality("") => Absyn.BIDIR

  axiom	set_element_causality("input") => Absyn.INPUT
  axiom	set_element_causality("output") => Absyn.OUTPUT
end


 (** relation: select_string
  ** author: adrpo@ida
  ** date  : 2006-02-05 
  ** if bool is true select first string, otherwise the second one
  **)
relation select_string: (bool,string,string) => string = 

	axiom select_string (true,  s1,  _) => s1
	axiom select_string (false,  _, s2) => s2

end


 (** relation: get_cref_info
  ** author: adrpo@ida
  ** date  : 2005-11-03, changed 2006-02-05 to match new Absyn.INFO 
  ** Retrieves the Info attribute of a Class.
  ** When parsing classes, the source:
  ** file name + isReadOnly + start lineno + start columnno + end lineno + end columnno is added to the Class 
  ** definition and to all Elements, see Absyn.Info. This relation retrieves the
  ** Info contents.
  ** 
  ** inputs:   (Absyn.ComponentRef, /* class */
                Absyn.Program) 
  ** outputs:   string
  **)
relation get_cref_info: (Absyn.ComponentRef, Absyn.Program) => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 let Absyn.CLASS(id,_,_,_,_,_,Absyn.INFO(filename,isReadOnly,sline,scol,eline,ecol)) = cdef &
            int_string(sline) => str_sline &
            int_string(scol)  => str_scol &
            int_string(eline) => str_eline &
            int_string(ecol)  => str_ecol &
            string_append(filename,",") => s &
            select_string(isReadOnly,"readonly","writable") => str_readonly &
            string_append(s,str_readonly) => s &
            string_append(s,",") => s &
            string_append(s,str_sline) => s &
            string_append(s,",") => s &
            string_append(s,str_scol) => s &         
            string_append(s,",") => s &
            string_append(s,str_eline) => s &
            string_append(s,",") => s &
            string_append(s,str_ecol) => s         
			---------------------------------------------------
			get_cref_info(class,p) => s

   axiom	get_cref_info(_,_) => "Error"

end


 (**relation: get_import_string
  ** author: adrpo@ida
  ** date  : 2005-11-11
  ** helperrelation to get_element_type 
  **)
relation get_import_string: (Absyn.Import) => string =

  rule Absyn.path_string (path) => path_str &
       Util.string_append_list(["kind=named, id=", id, ", path=", path_str]) => str 
       ----------------------------------------------------------------------
       get_import_string(Absyn.NAMED_IMPORT(id, path)) => str

  rule Absyn.path_string (path) => path_str &
       Util.string_append_list(["kind=qualified, path=", path_str]) => str 
       ------------------------------------------------------------
       get_import_string(Absyn.QUAL_IMPORT(path)) => str


  rule Absyn.path_string (path) => path_str &
       Util.string_append_list(["kind=unqualified, path=", path_str]) => str 
       --------------------------------------------------------------
       get_import_string(Absyn.UNQUAL_IMPORT(path)) => str
end


 (**relation: get_element_type
  ** author: adrpo@ida
  ** date  : 2005-11-11
  ** helperrelation to get_element_info 
  **)
relation get_element_type: (Absyn.ElementSpec) => string =

  rule Absyn.path_string (path) => path_str &
       Util.string_append_list(["elementtype=extends, path=", path_str]) => str 
       -----------------------------------------------------------------------
       get_element_type(Absyn.EXTENDS(path, _)) => str

  rule get_import_string(import) => import_str &     
       Util.string_append_list(["elementtype=import, ",import_str]) => str 
       -------------------------------------------------------------------
       get_element_type(Absyn.IMPORT(import, _)) => str      

  rule Absyn.path_string(path_type) => typename &
       get_componentitems_name(lst) => names &
       attr_flow_str(attr) => flow_str &
       attr_variability_str(attr) => variability_str &
       attr_direction_str(attr) => dir_str &
       Util.string_delimit_list(names, ", ") => names_str &
       Util.string_append_list(["elementtype=component, typename=", typename, ", names={", names_str, 
                                "}, flow=", flow_str, ", variability=", variability_str,
                                ", direction=", dir_str]) => str 
       --------------------------------------------------------------------------------------
       get_element_type(Absyn.COMPONENTS(attr, path_type, lst)) => str      

end


 (**relation: get_element_info
  ** author: adrpo@ida
  ** date  : 2005-11-11
  ** helperrelation to construct_element_info & get_elements_info 
  **)
relation get_element_info: (Absyn.ElementItem) => string =

       (* ok, first see if is a classdef *)
  rule Util.bool_string(f) => final &
       keyword_replaceable(r) => r' &
       Util.bool_string(r') => repl &
       inner_outer_str(inout) => inout_str &
	   (* compile the classdef string *)
	   Absyn.restr_string (restr) => str_restriction &
       Util.string_append_list(["elementtype=classdef, classname=", id, ", classrestriction=", str_restriction]) 
		=> element_str & 
       int_string(sline) => sline_str &
       int_string(scol)  => scol_str &
       int_string(eline) => eline_str &
       int_string(ecol)  => ecol_str &
       select_string(isReadOnly, "readonly","writable") => readonly_str &
       Util.string_append_list(["elementfile=\"", file, "\", elementreadonly=\"",readonly_str,
       						    "\", elementStartLine=", sline_str, ", elementStartColumn=", scol_str, 
       						    ", elementEndLine=", eline_str, ", elementEndColumn=", ecol_str, 
                                ", final=", final, ", replaceable=", repl, ", inout=", inout_str, ", ", element_str]) => str
       ---------------------------------------------------------------------------------------------------------------
       get_element_info(Absyn.ELEMENTITEM(Absyn.ELEMENT(f, r, inout, _, 
			Absyn.CLASSDEF(_, Absyn.CLASS(id, p, fi, e, restr, _, 
       			Absyn.INFO(file, isReadOnly, sline, scol, eline, ecol))), _, _))) => str

     (* if is not a classdef, just follow the normal stuff *)
rule Util.bool_string(f) => final &
       keyword_replaceable(r) => r' &
       Util.bool_string(r') => repl &
       inner_outer_str(inout) => inout_str &
       get_element_type(elementSpec) => element_str &
       int_string(sline) => sline_str &
       int_string(scol)  => scol_str &
       int_string(eline) => eline_str &
       int_string(ecol)  => ecol_str &
       select_string(isReadOnly, "readonly","writable") => readonly_str &
       Util.string_append_list(["elementfile=\"", file, "\", elementreadonly=\"",readonly_str,
       						    "\", elementStartLine=", sline_str, ", elementStartColumn=", scol_str, 
       						    ", elementEndLine=", eline_str, ", elementEndColumn=", ecol_str, 
                                ", final=", final, ", replaceable=", repl, ", inout=", inout_str, ", ", element_str]) => str     
       ---------------------------------------------------------------------------------------------------------------
       get_element_info(Absyn.ELEMENTITEM(Absyn.ELEMENT(f, r, inout, id, elementSpec, 
       		info as Absyn.INFO(file, isReadOnly, sline, scol, eline, ecol), _))) => str

  (* for annotations we don't care *)
  axiom get_element_info(_) => "elementtype=annotation"

end


 (**relation: construct_elements_info
  ** author: adrpo@ida
  ** date  : 2005-11-11
  ** helperrelation to get_elements_info
  **
  ** inputs:  (string /* "public" or "protected" */, Absyn.ElementItem list) 
  ** outputs:  string
  **)
relation construct_elements_info: (string, Absyn.ElementItem list) => string =

  rule (* Util.string_append_list(["{ elementvisibility=", visibility_str," }"]) => res *)
       -----------------------------------------------------------------------------------
       construct_elements_info(visibility_str, []) => ""

  (* deal with the last element *)
  rule get_element_info(current) => s1 &
       Util.string_append_list(["{ elementvisibility=", visibility_str,", ", s1, " }"]) => element_str &
       Util.string_append_list([element_str, "\n"]) => res
       -------------------------------------------------------------
       construct_elements_info(visibility_str, current::nil) => res

  rule get_element_info(current) => s1 &
       Util.string_append_list(["{ elementvisibility=", visibility_str,", ", s1, " }"]) => element_str &
       construct_elements_info(visibility_str, rest) => s2 &
       Util.string_append_list([element_str, ",\n", s2]) => res
       -------------------------------------------------------------
       construct_elements_info(visibility_str, current::rest) => res
end


 (**relation: append_non_empty_strings
  ** author: adrpo@ida
  ** date  : 2005-11-11
  ** helper to get_elements_info
  ** input: "", "", "," => ""
  **        "some", "", "," => "some"
  **        "some", "some", "," => "some, some" 
  **)
relation append_non_empty_strings : (string, string, string) => string =

   axiom append_non_empty_strings("", "", _) => ""
   axiom append_non_empty_strings(s1, "", _) => s1
   axiom append_non_empty_strings("", s2, _) => s2

   rule  Util.string_append_list([s1, delimiter, s2]) => str
         ---------------------------------------------------
         append_non_empty_strings(s1, s2, delimiter) => str
end


 (**relation: get_elements_info
  ** author: adrpo@ida
  ** date  : 2005-11-11, changed 2006-02-06 to mirror the new Absyn.INFO
  ** Retrieves the Info attribute of an element.
  ** When parsing elements of the class composition, the source:
  **  -> file name + readonly + start lineno + start columnno + end lineno + end columnno is added to the Element 
  ** and to the Class definition, see Absyn.Info. 
  ** This relation retrieves the Info contents of the elements of a class.
  **)
relation get_elements_info: (Absyn.ComponentRef, Absyn.Program) => string = 

   rule	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => public_elementitem_list &
	 get_protected_list(parts) => protected_elementitem_list &
	 construct_elements_info("public", public_elementitem_list) => public_str &
 	 construct_elements_info("protected", protected_elementitem_list) => protected_str &
	 append_non_empty_strings(public_str, protected_str, ", ") => elements_str &
            Util.string_append_list(["{ ", elements_str, " }"]) => str
	 -----------------------------------------------------------------------------------
	 get_elements_info(model,p) => str


   rule	 Absyn.cref_to_path(model) => modelpath &
		 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(i,p,f,e,r,_,_)
		 (* there are no elements in DERIVED, ENUMERATION, OVERLOAD, CLASS_EXTENDS and PDER
		    maybe later we can give info about that also *)
		 -----------------------------------------------------------------------------------
		 get_elements_info(model,p) => "{ }"

	 axiom get_elements_info(_,_) => "Error"
end


 (**relation: get_source_file
  ** author: PA
  **
  ** Retrieves the Source file attribute of a Class.
  ** When parsing classes, the source file name is added to the Class 
  ** definition and to all Elements, see Absyn. Thisrelation retrieves the
  ** source file of the Class.
  ** 
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.Program)
  ** outputs: string
  **)
relation get_source_file: (Absyn.ComponentRef, (* class *)
			    Absyn.Program) => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 Absyn.class_filename(cdef) => filename
	 ---------------------------
	 get_source_file(class,p) => filename

 axiom	get_source_file(_,_) => "Error"

end


 (**relation: set_source_file
  ** author: PA
  **
  ** Sets the source file of a Class. Is for instance used
  ** when adding a new class to an aldready stored package.
  ** The class should then have the same file as the package.
  **
  ** inputs:   (Absyn.ComponentRef, /* class */
                string, /* filename */
                Absyn.Program) 
  ** outputs: (string, Absyn.Program)
  **)
relation set_source_file: (Absyn.ComponentRef,
			    string,
			    Absyn.Program) 
	   => (string, Absyn.Program) =

   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 build_within(p_class) => within &
	 Absyn.set_class_filename(cdef,filename) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 ----------------------------
	 set_source_file(class,filename,p) => ("Ok",newp)

   axiom	set_source_file(_,_,p) => ("Error" ,p)
end


 (**relation: set_extends_modifier_value
  **
  ** Thisrelation sets the submodifier value of an extends clause in a Class.
  ** for instance,
  ** model test extends A(p1=3,p2(z=3));end test;
  ** setExtendsModifierValue(test,A,p1,Code(=4)) => OK
  ** => model test extends A(p1=4,p2(z=3));end test;
  **
  ** inputs:   (Absyn.ComponentRef, /* class */
                Absyn.ComponentRef, /* inherit class */
                Absyn.ComponentRef, /* subident */
                Absyn.Modification,
                Absyn.Program)
  ** outputs:  (Absyn.Program,string)
  **)
relation set_extends_modifier_value: (Absyn.ComponentRef, 
				       Absyn.ComponentRef,
				       Absyn.ComponentRef,
				       Absyn.Modification,
				       Absyn.Program)
	 => (Absyn.Program,string)  =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(inheritclass) => inherit_class &
	 build_within(p_class) => within &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_class_env(p,p_class) => env &
	 set_extends_submodifier_in_class(cdef,inherit_class,subident,mod,env)
	   => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 ------------------------------
	 set_extends_modifier_value(class,inheritclass,subident,mod,p) 
	   => (newp, "Ok")

   axiom	set_extends_modifier_value(_,_,_,_,p) => (p,"Error")
end


 (**relation: set_extends_submodifier_in_class
  ** author: PA
  **
  ** Sets a modifier of an extends clause for a given subcomponent.
  ** For instance, 
  ** extends A(b=4); // b is subcomponent
  **
  ** inputs:  (Absyn.Class, 
               Absyn.Path, /* inherit_name */
               Absyn.ComponentRef, /* submodifier */
               Absyn.Modification,
               Env.Env)
  ** outputs: Absyn.Class
  **)
relation set_extends_submodifier_in_class:(Absyn.Class, 
					    Absyn.Path, 
					    Absyn.ComponentRef,
					    Absyn.Modification,
					    Env.Env) => Absyn.Class =

   rule	set_extends_submodifier_in_classparts(parts,inherit_name,submod,mod,env) 
	   => parts'
	   ---------------------------------------------------------
	 set_extends_submodifier_in_class(Absyn.CLASS(id,p,f,e,r,
							Absyn.PARTS(parts,cmt),file_info),
					    inherit_name, submod,mod,env)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file_info)
end


 (**relation: set_extends_submodifier_in_classparts
  **
  ** Helperrelation to set_extends_submodifier_in_class
  ** 
  ** inputs:   (Absyn.ClassPart list, 
                Absyn.Path, /* inherit_name */
                Absyn.ComponentRef, /* submodifier */
                Absyn.Modification,
                Env.Env)
  ** outputs:  Absyn.ClassPart list
  **)
relation set_extends_submodifier_in_classparts: (Absyn.ClassPart list, 
						  Absyn.Path, 
						  Absyn.ComponentRef,
						  Absyn.Modification,
						  Env.Env)
	   => Absyn.ClassPart list =

   axiom	set_extends_submodifier_in_classparts([],_,_,_,_) => []

   rule	set_extends_submodifier_in_classparts(rest,inherit,submod,mod,env) 
	   => res &
	 set_extends_submodifier_in_elementitems(elts,inherit,submod,mod,env) 
	   => elts'
	 -------------------------------------
	 set_extends_submodifier_in_classparts(Absyn.PUBLIC(elts)::rest,
						 inherit,submod,mod,env)
	   => (Absyn.PUBLIC(elts')::res)

   rule	set_extends_submodifier_in_classparts(rest,inherit,submod,mod,env) 
	   => res &
	 set_extends_submodifier_in_elementitems(elts,inherit,submod,mod,env) 
	   => elts'
	 -------------------------------------
	 set_extends_submodifier_in_classparts(Absyn.PROTECTED(elts)::rest,inherit,submod,mod,env)
	   => (Absyn.PROTECTED(elts')::res)

    rule	set_extends_submodifier_in_classparts(rest,inherit,submod,mod,env) => res 
	 -------------------------------------
	 set_extends_submodifier_in_classparts(elt::rest,inherit,submod,mod,env)
	   => (elt::res)
end


 (**relation: set_extends_submodifier_in_elementitems
  **
  ** Helperrelation to set_extends_submodifier_in_classparts
  **
  ** inputs:  (Absyn.ElementItem list,
               Absyn.Path, /* inherit_name */
               Absyn.ComponentRef, /* submodifier */
               Absyn.Modification,
               Env.Env)
  ** outputs:  Absyn.ElementItem list
  **)
relation set_extends_submodifier_in_elementitems:(Absyn.ElementItem list,
						   Absyn.Path,
						   Absyn.ComponentRef,
						   Absyn.Modification,
						   Env.Env)
	 => Absyn.ElementItem list =

   axiom	set_extends_submodifier_in_elementitems([],_,_,_,_) => [] 

   rule	set_extends_submodifier_in_elementitems(rest,inherit,submod,mod,env) 
	   => res &
	 set_extends_submodifier_in_element(elt,inherit,submod,mod,env) => elt'
	 -------------------------------------------------
	 set_extends_submodifier_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,inherit,submod,mod,env)
	   => Absyn.ELEMENTITEM(elt')::res

   rule	set_extends_submodifier_in_elementitems(rest,inherit,submod,mod,env) 
	   => res 
	 -------------------------------------------------
	 set_extends_submodifier_in_elementitems(elt::rest,inherit,submod,mod,env)
	   => elt::res
end


 (**relation: set_extends_submodifier_in_element
  **
  ** Helperrelation to set_extends_submodifier_in_elementitems
  ** 
  ** inputs: (Absyn.Element, 
              Absyn.Path, /* inherit_name */
              Absyn.ComponentRef, /* submodifier */
              Absyn.Modification,
              Env.Env)
  ** outputs:  Absyn.Element
  **)
relation set_extends_submodifier_in_element: (Absyn.Element, 
					       Absyn.Path,
					       Absyn.ComponentRef,
					       Absyn.Modification,
					       Env.Env)
	   => Absyn.Element =


   rule	(* special case for clearing modifications*)
	 -----------------------------
	 set_extends_submodifier_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,eargs),info,constr),inherit,submod,Absyn.CLASSMOD([],NONE),env) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,[]),info,constr)

   rule	Inst.make_fully_qualified(env,path) => path' &
	 ModUtil.path_equal(inherit,path') => true &
	 set_submodifier_in_elementargs(eargs,submod,mod) => eargs'
	 ----------------------------------------------------
	 set_extends_submodifier_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,eargs),info,constr),inherit,submod,mod,env) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,eargs'),info,constr)
   axiom	set_extends_submodifier_in_element(elt,_,_,_,_) => elt
end


 (**relation: get_extends_modifier_value
  **
  ** Return the submodifier value of an extends clause
  ** for instance,
  ** model test extends A(p1=3,p2(z=3));end test;
  ** getExtendsModifierValue(test,A,p1) => =3
  ** 
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.ComponentRef, /* ident */
               Absyn.ComponentRef, /* subident */
               Absyn.Program) 
  ** outputs:  string 
  **)
relation get_extends_modifier_value:(Absyn.ComponentRef, 
				      Absyn.ComponentRef,
				      Absyn.ComponentRef,
				      Absyn.Program) 
	   => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(inherit_name) => name &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_class_env(p,p_class) => env &
	 get_extends_elementspec_in_class(cdef) => exts &
	 Util.list_map_1(exts,make_extends_fully_qualified,env) => exts' &
	 Util.list_select_1(exts',name,extends_elementspec_named) 
	   => [ Absyn.EXTENDS(extpath,extmod) ] &	
	 get_modification_value(extmod,subident) => mod  &
	 Dump.unparse_modification_str(mod) => res 
	 -----------------------------------------
	 get_extends_modifier_value(class,inherit_name,subident,p)
	   => res

   axiom	get_extends_modifier_value(_,_,_,_) => "Error"
end


 (**relation: make_extends_fully_qualified
  **
  ** Makes an EXTENDS ElementSpec having a fully qualified extends path.
  **)
relation make_extends_fully_qualified: (Absyn.ElementSpec, Env.Env) 
	   => Absyn.ElementSpec =

   rule	Inst.make_fully_qualified(env,path) => path'
	 -------------------------
	 make_extends_fully_qualified(Absyn.EXTENDS(path,earg),env)
	   => Absyn.EXTENDS(path',earg)
end


 (**relation: get_extends_modifier_names
  **
  ** Return the modifier names of a modification on an extends clause.
  ** For instance,
  ** model test extends A(p1=3,p2(z=3));end test;
  ** getExtendsModifierNames(test,A) => {p1,p2}
  **
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.ComponentRef, /* inherited class */
               Absyn.Program) 
  ** outputs: (string)
  **)
relation get_extends_modifier_names: (Absyn.ComponentRef, 
				       Absyn.ComponentRef,
				       Absyn.Program) 
	 => (string) =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(inherit_name) => name &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_extends_elementspec_in_class(cdef) => exts &
	 get_class_env(p,p_class) => env &
	 Util.list_map_1(exts,make_extends_fully_qualified,env) => exts' &
	 Util.list_select_1(exts',name,extends_elementspec_named) => [ Absyn.EXTENDS(extpath,extmod) ] &
	 get_modification_names(extmod) => res &
	 Util.string_delimit_list(res,", ") => res' &
	 Util.string_append_list(["{",res',"}"]) => res''
	 ------------------------------------
	 get_extends_modifier_names(class,inherit_name,p) => res''

   axiom	get_extends_modifier_names(_,_,_) => "Error"

end


(**relation extends_elementspec_name
 **
 ** Returns true if elementspec of EXTENDS has the name given as path, 
 ** false otherwise.
 **)
relation extends_elementspec_named: (Absyn.ElementSpec, 
				      Absyn.Path) 
	   => bool  =

   rule	ModUtil.path_equal(path,extpath) => res
	 --------------------------
	 extends_elementspec_named(Absyn.EXTENDS(extpath,_),path) => res
end


(**relation extends_name
 **
 ** Return the class name of an EXTENDS element spec.
 **)
relation extends_name: (Absyn.ElementSpec) => Absyn.Path =

   axiom  extends_name (Absyn.EXTENDS(path,_)) => path	
end


(**relation: get_extends_elementspec_in_class
 **
 ** Retrieve all ElementSpec of a class that are EXTENDS.
 **)
relation get_extends_elementspec_in_class: (Absyn.Class) 
	   => Absyn.ElementSpec list =

   rule	get_extends_elementspec_in_classparts(parts) => ext
	 -------------------------
	 get_extends_elementspec_in_class( Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => ext

   axiom	get_extends_elementspec_in_class(_) => []
end


(**relation: get_extends_elementspec_in_classparts
 **
 ** Helperrelation to get_extends_elementspec_in_class.
 **)
relation get_extends_elementspec_in_classparts:(Absyn.ClassPart list) 
	   => Absyn.ElementSpec list = 


   axiom	get_extends_elementspec_in_classparts([]) => []

   rule	get_extends_elementspec_in_classparts(rest) 
	   => lst1 &
	 get_extends_elementspec_in_elementitems(elts) 
	   => lst2 &
	   list_append(lst1,lst2) => res
	 -------------------------------------
	 get_extends_elementspec_in_classparts(Absyn.PUBLIC(elts)::rest)
	   => res

   rule	get_extends_elementspec_in_classparts(rest) 
	   => lst1 &
	 get_extends_elementspec_in_elementitems(elts) 
	   => lst2 &
	   list_append(lst1,lst2) => res
	 -------------------------------------
	 get_extends_elementspec_in_classparts(Absyn.PROTECTED(elts)::rest)
	   => (res)

    rule	get_extends_elementspec_in_classparts(rest) 
	   => res 
	 -------------------------------------
	 get_extends_elementspec_in_classparts(elt::rest)
	   => (res)
end


(**relation: get_extends_elementspec_in_elementitems
 **
 ** Helperrelation to get_extends_elementspec_in_classparts.
 **)
relation get_extends_elementspec_in_elementitems: (Absyn.ElementItem list) 
	 => Absyn.ElementSpec list =

   axiom	get_extends_elementspec_in_elementitems([]) => [] 

   rule	(* Bug in RML. If the two premisses below are in swapped order
	 * the compiler enters infinite loop (but no stack overflow) *)
	 get_extends_elementspec_in_element(elt) => elt &
	 get_extends_elementspec_in_elementitems(rest) 
	   => res 
	 -------------------------------------------------
	 get_extends_elementspec_in_elementitems(Absyn.ELEMENTITEM(elt)::rest)
	   => elt::res

   rule	get_extends_elementspec_in_elementitems(rest) 
	   => res 
	 -------------------------------------------------
	 get_extends_elementspec_in_elementitems(_::rest)
	   => res
end


(**relation: get_extends_elementspec_in_element
 **
 ** Helperrelation to get_extends_elementspec_in_elementitems.
 **)	    
relation get_extends_elementspec_in_element:(Absyn.Element) 
	   => Absyn.ElementSpec =

   axiom	get_extends_elementspec_in_element(Absyn.ELEMENT(_,_,_,_,ext as Absyn.EXTENDS(_,_),_,_)) => ext

end


 (**relation: set_component_modifier
  **
  ** Sets a submodifier of a component.
  ** 
  ** inputs:   (Absyn.ComponentRef, /* class */
                Absyn.ComponentRef, /* variable name */
                Absyn.ComponentRef, /* submodifier name */
                Absyn.Modification, 
                Absyn.Program)
  ** outputs: (Absyn.Program, string)
  **)
relation set_component_modifier: (Absyn.ComponentRef,
				   Absyn.ComponentRef,
				   Absyn.ComponentRef,
				   Absyn.Modification, 
				   Absyn.Program)
	   => (Absyn.Program, string) =

   rule	Absyn.cref_to_path(class) => p_class &

	 build_within(p_class) => within &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 set_component_submodifier_in_class(cdef,varname,subident,mod) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 -----------------------------------
	 set_component_modifier(class,Absyn.CREF_IDENT(varname,_),subident,mod,p) 
	   => (newp,"Ok") 

   axiom	set_component_modifier(_,_,_,_,p) => (p, "Error")
end


 (**relation: set_component_submodifier_in_class
  **
  ** Sets a sub modifier on a component in a class.
  **
  ** inputs: (Absyn.Class, 
              Absyn.Ident, /* component name */
              Absyn.ComponentRef, /* subvariable path */
              Absyn.Modification)
  ** outputs: Absyn.Class
  **)
relation set_component_submodifier_in_class: (Absyn.Class, 
					       Absyn.Ident,
					       Absyn.ComponentRef,
					       Absyn.Modification)
	   => Absyn.Class =

   rule	set_component_submodifier_in_classparts(parts,varname,submodident,mod) 
	   => parts'
	   ---------------------------------------------------------
	 set_component_submodifier_in_class(Absyn.CLASS(id,p,f,e,r,
							Absyn.PARTS(parts,cmt),file_info),
					    varname, submodident,mod)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file_info)
end


 (**relation: set_component_submodifier_in_classparts
  **
  ** Helperrelation to set_component_submodifier_in_class
  ** 
  ** inputs:  (Absyn.ClassPart list, 
               Absyn.Ident, /* component name */
               Absyn.ComponentRef, /* subvariable path */
               Absyn.Modification)
  ** outputs:  Absyn.ClassPart list
  **)
relation set_component_submodifier_in_classparts: (Absyn.ClassPart list, 
						    Absyn.Ident, 
						    Absyn.ComponentRef,
						    Absyn.Modification)
	 => Absyn.ClassPart list =

   axiom	set_component_submodifier_in_classparts([],_,_,_) => []

   rule	set_component_submodifier_in_classparts(rest,varname,submodident,mod) 
	   => res &
	 set_component_submodifier_in_elementitems(elts,varname,submodident,mod) 
	   => elts'
	 -------------------------------------
	 set_component_submodifier_in_classparts(Absyn.PUBLIC(elts)::rest,
						 varname,submodident,mod)
	   => (Absyn.PUBLIC(elts')::res)

   rule	set_component_submodifier_in_classparts(rest,varname,submodident,mod) 
	   => res &
	 set_component_submodifier_in_elementitems(elts,varname,submodident,mod) 
	   => elts'
	 -------------------------------------
	 set_component_submodifier_in_classparts(Absyn.PROTECTED(elts)::rest,varname,submodident,mod)
	   => (Absyn.PROTECTED(elts')::res)

    rule	set_component_submodifier_in_classparts(rest,varname,submodident,mod) => res 
	 -------------------------------------
	 set_component_submodifier_in_classparts(elt::rest,varname,submodident,mod)
	   => (elt::res)
end


 (**relation: set_component_submodifier_in_elementitems
  **
  ** Helperrelation to set_component_submodifier_in_classparts
  ** 
  ** inputs: (Absyn.ElementItem list,
              Absyn.Ident, /* component name */
              Absyn.ComponentRef, /* subvariable path */
              Absyn.Modification)
  ** outputs: Absyn.ElementItem list
  **)
relation set_component_submodifier_in_elementitems:(Absyn.ElementItem list,
						     Absyn.Ident,
						     Absyn.ComponentRef,
						     Absyn.Modification)
	 => Absyn.ElementItem list =

   axiom	set_component_submodifier_in_elementitems([],_,_,_) => [] 

   rule	set_component_submodifier_in_elementitems(rest,varname,submodident,mod) 
	   => res &
	 set_component_submodifier_in_element(elt,varname,submodident,mod) => elt'
	 -------------------------------------------------
	 set_component_submodifier_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,varname,submodident,mod)
	   => Absyn.ELEMENTITEM(elt')::res

   rule	set_component_submodifier_in_elementitems(rest,varname,submodident,mod) 
	   => res 
	 -------------------------------------------------
	 set_component_submodifier_in_elementitems(elt::rest,varname,submodident,mod)
	   => elt::res
end


 (**relation: set_component_submodifier_in_element
  **
  ** Helperrelation to set_component_submodifier_in_elementitems
  **
  ** inputs: (Absyn.Element, 
              Absyn.Ident, /* component name */
              Absyn.ComponentRef, /* submodifier path */
              Absyn.Modification)
  ** outputs: Absyn.Element
  **)
relation set_component_submodifier_in_element: (Absyn.Element, 
						 Absyn.Ident, 
						 Absyn.ComponentRef,
						 Absyn.Modification)
	 => Absyn.Element =

   rule	set_component_submodifier_in_compitems(compitems,varname,submodident,mod) 
	   => compitems'
	 ----------------------------------------------------
	 set_component_submodifier_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems),info,constr),varname,submodident,mod) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems'),info,constr)

   axiom	set_component_submodifier_in_element(elt,_,_,_) => elt
end


 (**relation: set_component_submodifier_in_compitems
  **
  ** Helperrelation to set_component_submodifier_in_element
  ** 
  ** inputs:  (Absyn.ComponentItem list,
               Absyn.Ident, /* component name */
               Absyn.ComponentRef, /* submodifier path */
               Absyn.Modification)
  ** outputs: (Absyn.ComponentItem list)
  **)
relation set_component_submodifier_in_compitems:(Absyn.ComponentItem list,
						  Absyn.Ident, 
						  Absyn.ComponentRef,
						  Absyn.Modification)
	 => (Absyn.ComponentItem list) =

   axiom	set_component_submodifier_in_compitems([],_,_,_) => []


   rule	varname = id &
	 set_submodifier_in_elementargs(args,submodpath,mod) => args' &
	 create_opt_modification_from_eltargs(args') => optmod
	 ---------------------------------------
	 set_component_submodifier_in_compitems(
			   Absyn.COMPONENTITEM(
			    Absyn.COMPONENT(id,dim,
					    SOME(Absyn.CLASSMOD(args,
								expopt))),cond,cmt)::rest,
						varname,submodpath,mod)
	   => (Absyn.COMPONENTITEM(
		 Absyn.COMPONENT(id,dim,optmod),cond,cmt)::rest)

   rule	varname = id 
	 ----------------------------
	 set_component_submodifier_in_compitems(
			   Absyn.COMPONENTITEM(
			    Absyn.COMPONENT(id,dim,NONE),cond,cmt)::rest,
						varname,submod,mod)
	   => (Absyn.COMPONENTITEM(
		 Absyn.COMPONENT(id,dim,
				 SOME(Absyn.CLASSMOD([Absyn.MODIFICATION(false,Absyn.NON_EACH,submod,SOME(mod),NONE)],NONE))),cond,cmt)::rest)

   rule	set_component_submodifier_in_compitems(rest,varname,submodident,mod) => res
	 ---------------------------------
	 set_component_submodifier_in_compitems(comp::rest,varname,submodident,mod)
	   => comp::res

   rule	print "-set_component_submodifier_in_compitems failed\n" 
	 -----------------------
	 set_component_submodifier_in_compitems(_,_,_,_) => fail
end

(**relation: create_opt_modification_from_eltargs
 **
 ** Creates an Modification option from an ElementArg list.
 ** If list is empty, NONE is created.
 **)
relation create_opt_modification_from_eltargs: Absyn.ElementArg list =>
	Absyn.Modification option =

  axiom	create_opt_modification_from_eltargs([]) => NONE

  axiom	create_opt_modification_from_eltargs(args) => SOME(Absyn.CLASSMOD(args,NONE))
end

 (**relation: set_submodifier_in_elementargs
  **
  ** Helperrelation to set_component_submodifier_in_compitems
  ** 
  ** inputs:  (Absyn.ElementArg list,
               Absyn.ComponentRef, /* subcomponent name */
               Absyn.Modification)
  ** outputs:  Absyn.ElementArg list
  **)
relation set_submodifier_in_elementargs: (Absyn.ElementArg list,
					   Absyn.ComponentRef,
					   Absyn.Modification)
	   => Absyn.ElementArg list =

	 
   axiom	(* empty list, add as new modifier *)
           set_submodifier_in_elementargs([],cref ,mod) 
	   => [Absyn.MODIFICATION(false,Absyn.NON_EACH,cref,SOME(mod),NONE)]


	   (* empty modification, remove MODIFICATION *)
   rule	name = submodident
	  ----------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,idx),_,cmt)::rest,Absyn.CREF_IDENT(submodident,_),mod as Absyn.CLASSMOD([],NONE)) 
	   => rest

	   (* update modification*)
   rule	name = submodident
	  ----------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,idx),_,cmt)::rest,Absyn.CREF_IDENT(submodident,_),mod) 
	   => Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,idx),SOME(mod),cmt)::rest

   rule	Absyn.cref_equal(cr1,cr2) => true
	 ---------------------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,cr1 as Absyn.CREF_QUAL(_,_,_),_,cmt)::rest,cr2,mod) 
	   => Absyn.MODIFICATION(f,each,cr1,SOME(mod),cmt)::rest

   rule	name1 = name2 
	 ---------------------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,Absyn.CREF_QUAL(name1,_,_),_,cmt)::rest,Absyn.CREF_IDENT(name2,idx),mod) 
	   => Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name2,idx),SOME(mod),cmt)::rest

   rule	name1 = name2 &
	 set_submodifier_in_elementargs(args,cr1,mod) => args'
	 ---------------------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,cr as Absyn.CREF_IDENT(name2,_),SOME(Absyn.CLASSMOD(args,exp)),cmt)::rest,Absyn.CREF_QUAL(name1,_,cr1),mod) 
	   => Absyn.MODIFICATION(f,each,cr,SOME(Absyn.CLASSMOD(args',exp)),cmt)::rest

   rule	set_submodifier_in_elementargs(rest,submodident,mod) => res
	 ----------------------
	 set_submodifier_in_elementargs(m::rest,submodident,mod) 
	   => m::res

   rule  print "-set_submodifier_in_elementargs failed\n"
	 -------------------
	 set_submodifier_in_elementargs(_,_,_) => fail
end


 (**relation: get_component_modifier_value(class,ident,subident,p) => resstr 
  **
  ** Returns the modifier value of component ident for modifier subident.
  ** For instance, 
  ** model A
  **  B b1(a1(p1=0,p2=0));
  **end A;
  ** getComponentModifierValues(A,b1,a1) => Code((p1=0,p2=0))
  **
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.ComponentRef, /* variable name */
               Absyn.ComponentRef, /* submodifier name */
               Absyn.Program)
  ** outputs: string
  **)
relation get_component_modifier_value: (Absyn.ComponentRef, 
					 Absyn.ComponentRef, 
					 Absyn.ComponentRef, 
					 Absyn.Program)
	 => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(ident) => Absyn.IDENT(name) &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_map(comps,get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_select_1(compelts',name,componentitem_named) 
	   => [Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(Absyn.CLASSMOD(mod,_))),_,_)] &
	 get_modification_value(mod,subident) => mod  &
	 Dump.unparse_modification_str(mod) => res 
	   ---------------------------
	 get_component_modifier_value(class,ident,subident,p) => res

   axiom	get_component_modifier_value(_,_,_,_) => "Error"

end


 (**relation: get_modification_value
  **
  ** Helperrelation to get_component_modifier_value
  ** Investigates modifications to find submodifier.
  **)
relation get_modification_value:(Absyn.ElementArg list, Absyn.ComponentRef) 
	   => Absyn.Modification =

   rule	Absyn.cref_equal(cr1,cr2) => true
	 ---------------------
	 get_modification_value (Absyn.MODIFICATION(f,each,cr1,SOME(mod),cmt)::rest,
				 cr2) => mod
   rule	name1=name2 &
	 get_modification_value(args,cr2) => res
	 ---------------------
	 get_modification_value (Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name1,_),SOME(Absyn.CLASSMOD(args,exp)),cmt)::rest,Absyn.CREF_QUAL(name2,_,cr2)) 
	   => res


   rule	get_modification_value(rest,name) => mod
	 ---------------------
	 get_modification_value (_::rest,name) => mod
end


 (**relation: get_component_modifier_names
  **
  ** Return the modifiernames of a component, i.e. Foo f( )
  **
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.ComponentRef, /* variable name */
               Absyn.Program) 
  ** outputs:  string
  **)
relation get_component_modifier_names: (Absyn.ComponentRef, 
					 Absyn.ComponentRef,
					 Absyn.Program) 
	 => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(ident) => Absyn.IDENT(name) &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_map(comps,get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_select_1(compelts',name,componentitem_named) 
	   => [Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(Absyn.CLASSMOD(mod,_))),_,_)] &
	 get_modification_names(mod) => res &
	 Util.string_delimit_list(res,", ") => res' &
	 Util.string_append_list(["{",res',"}"]) => res''
	 ------------------------------------------------
	 get_component_modifier_names(class,ident,p) => res''

   axiom	get_component_modifier_names(_,_,_) => "{}"
end


(**relation: get_modification_names
 **
 ** Helperrelation to get_component_modifier_names
 **)
relation get_modification_names:(Absyn.ElementArg list) 
	   => string list  =

   axiom	get_modification_names([]) => []

   rule	get_modification_names(rest) => names
	 ---------------
	 get_modification_names(Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,_),NONE,cmt)::rest)
	   => name::names

   rule	Dump.print_component_ref_str(cr) => name &
	 get_modification_names(rest) => names 
	 ---------------
	 get_modification_names(Absyn.MODIFICATION(f,each,cr ,SOME(Absyn.CLASSMOD([],_)),cmt)::rest)
	   => name::names

   rule	Dump.print_component_ref_str(cr) => name &		       
	 get_modification_names(args) => names2 &
	 Util.list_map_1r(names2,string_append,".") => names2' &
	 Util.list_map_1r(names2',string_append,name) => names2'' &
	 get_modification_names(rest) => names &
	 list_append(names2'',names) => res
	 ---------------
	 get_modification_names(Absyn.MODIFICATION(f,each,cr,SOME(Absyn.CLASSMOD(args,_)),cmt)::rest)
	   => res

   rule	get_modification_names(rest) => names
	 ---------------
	 get_modification_names(_::rest)
	   => names
end


 (**relation: get_parameter_value
  **
  ** Returns the value of a parameter in a class.
  **
  ** inputs: (Absyn.ComponentRef, /* class */
              Absyn.ComponentRef, /* variable name */
              Absyn.Program)
  ** outputs: string
  **)
relation get_parameter_value: (Absyn.ComponentRef,
			       Absyn.ComponentRef,
				Absyn.Program) => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(name) => Absyn.IDENT(name) &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_select(comps,is_parameter_element) => comps' &
	 Util.list_map(comps',get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_select_1(compelts',name,componentitem_named) => [compitem] &
	 get_variable_binding_in_componentitem(compitem) => exp &
	 Dump.print_exp_str(exp) => res 
	 ----------------------------------------------------
	 get_parameter_value(class,name,p) => res

   axiom	get_parameter_value(_,_,_) => "Error"
end


 (**relation: get_variable_binding_in_componenitem
  **
  ** Retrieve the variable binding from an ComponentItem
  **)
relation get_variable_binding_in_componentitem: (Absyn.ComponentItem) 
	   => Absyn.Exp =

   axiom	get_variable_binding_in_componentitem(Absyn.COMPONENTITEM(
								   Absyn.COMPONENT(_,_,SOME(Absyn.CLASSMOD(_,SOME(e)))),_,_)) => e
end


 (**relation: set_parameter_value
  **
  ** Sets the parameter value of a class and returns the updated program.
  **
  ** inputs:  (Absyn.ComponentRef, /* class */
               Absyn.ComponentRef, /* ident */
               Absyn.Exp,          /* exp */
               Absyn.Program) 
  ** outputs: (Absyn.Program,string) 
  **)
relation set_parameter_value:(Absyn.ComponentRef,
			      Absyn.ComponentRef,
			      Absyn.Exp,
			      Absyn.Program) 
	   => (Absyn.Program,string)	=

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(name) => Absyn.IDENT(varname) &
	 build_within(p_class) => within &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 set_variable_binding_in_class(cdef,varname,exp) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 ------------------------------------------------------
	 set_parameter_value(class,name,exp,p) => (newp,"Ok")

   axiom	set_parameter_value(_,_,_,p) => (p,"Error")
end


 (**relation: set_variable_binding_in_class
  **
  ** Takes a class and an identifier and value an sets the variable binding to 
  ** the passed expression.
  **)
relation set_variable_binding_in_class:(Absyn.Class,Absyn.Ident,Absyn.Exp) 
	   => (Absyn.Class) =

   rule	set_variable_binding_in_classparts(parts,id2,exp) => parts'
	 ---------------------------------------------------------
	 set_variable_binding_in_class(Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts,cmt),file_info),
				       id2,exp)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file_info)
end


 (**relation: set_variable_binding_in_classparts
  **
  ** Sets a binding of a variable in a ClassPart list, named by the passed 
  ** argument.
  **)
relation set_variable_binding_in_classparts: (Absyn.ClassPart list, Absyn.Ident, 
					       Absyn.Exp)	
	   => Absyn.ClassPart list =

   axiom	set_variable_binding_in_classparts([],_,_) => []

   rule	set_variable_binding_in_classparts(rest,id,exp) => res &
	 set_variable_binding_in_elementitems(elts,id,exp) => elts'
	 -------------------------------------
	 set_variable_binding_in_classparts(Absyn.PUBLIC(elts)::rest,id,exp)
	   => (Absyn.PUBLIC(elts')::res)

   rule	set_variable_binding_in_classparts(rest,id,exp) => res &
	 set_variable_binding_in_elementitems(elts,id,exp) => elts'
	 -------------------------------------
	 set_variable_binding_in_classparts(Absyn.PROTECTED(elts)::rest,id,exp)
	   => (Absyn.PROTECTED(elts')::res)

   rule	set_variable_binding_in_classparts(rest,id,exp) => res 
	 -------------------------------------
	 set_variable_binding_in_classparts(elt::rest,id,exp)
	   => (elt::res)
end


 (**relation: set_variable_binding_in_elementitems
  **
  ** Sets a variable binding in a list of ElementItems
  **)
relation set_variable_binding_in_elementitems: (Absyn.ElementItem list, Absyn.Ident,
						 Absyn.Exp) 
	   => Absyn.ElementItem list =

  axiom	set_variable_binding_in_elementitems([],_,_) => [] 

   rule	set_variable_binding_in_elementitems(rest,id,exp) => res &
	 set_variable_binding_in_element(elt,id,exp) => elt'
	 -------------------------------------------------
	 set_variable_binding_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,id,exp)
	   => Absyn.ELEMENTITEM(elt')::res

   rule	set_variable_binding_in_elementitems(rest,id,exp) => res 
	 -------------------------------------------------
	 set_variable_binding_in_elementitems(elt::rest,id,exp)
	   => elt::res
end


 (**relation: set_variable_binding_in_element
  **
  ** Sets a variable binding in an Element.
  **)
relation set_variable_binding_in_element: (Absyn.Element, Absyn.Ident, 
					    Absyn.Exp)
	 => Absyn.Element =

   rule	set_variable_binding_in_compitems(compitems,id,exp) => compitems'
	 --------------------------
	 set_variable_binding_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems),info,constr),id,exp) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems'),info,constr)

   axiom	set_variable_binding_in_element(elt,id,exp) => elt
end


 (**relation: set_variable_binding_in_compitems
  **
  ** Sets a variable binding in a ComponentItem list
  **)
relation set_variable_binding_in_compitems: (Absyn.ComponentItem list, 
					      Absyn.Ident,
					      Absyn.Exp) 
	   => (Absyn.ComponentItem list) = 

   axiom	set_variable_binding_in_compitems([],_,_) => []

   rule	id = id2
	 -------------------------------
	 set_variable_binding_in_compitems(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,
							       SOME(Absyn.CLASSMOD(arg,_))),cond,cmt)::rest,
					   id2,exp)
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,SOME(Absyn.CLASSMOD(arg,SOME(exp)))),cond,cmt)::rest
   rule	id = id2
	 -------------------------------
	 set_variable_binding_in_compitems(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,
							       NONE),cond,cmt)::rest,
					   id2,exp)
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,
						  SOME(Absyn.CLASSMOD([],SOME(exp)))),cond,cmt)::rest

   rule	set_variable_binding_in_compitems(rest,id,exp) => res
	 -------------------------------
	 set_variable_binding_in_compitems(item::rest,id,exp)
	   => item::res							      
end


 (**relation: build_within
  **
  ** From a fully qualified model name, build a suitable within clause
  **)
relation build_within: Absyn.Path => Absyn.Within =

   axiom	build_within(Absyn.IDENT(_)) => Absyn.TOP

   rule	Absyn.strip_last(path) => w_path 	
	 -------------------------------------
	 build_within(path) => Absyn.WITHIN(w_path)
end


 (**relation: componentitem_named
  **
  ** Returns true if the component item has the name matching the second 
  ** argument.
  **)
relation componentitem_named: (Absyn.ComponentItem, Absyn.Ident) => bool =

   rule	id = id2 
	 -------------------------
	 componentitem_named(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_,_),id2) => true

   axiom	componentitem_named(_,_) => false
end


 (**relation: get_componentitem_name
  **
  ** Returns the name of a ComponentItem
  **)
relation get_componentitem_name: Absyn.ComponentItem => Absyn.Ident =

   axiom	get_componentitem_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_,_)) => id
end


 (**relation: get_componentitems_in_element
  **
  ** Retrieves the ComponentItems of a component Element.
  ** If Element is not a component, empty list is returned.
  **)
relation get_componentitems_in_element:(Absyn.Element) => Absyn.ComponentItem list =

   axiom	get_componentitems_in_element(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,l),_,_)) 
				       => l 
   axiom	get_componentitems_in_element(_) => []
end


 (**relation: rename_class
  **
  ** Thisrelation renames a class (given as a qualified path name) to a 
  ** new name -in the same scope-. All references to the class name in the
  ** program is updated to the new name. Therelation does not allow a 
  ** renaming that will move the class to antoher package. To do this, the 
  ** class must be copied.
  **
  ** inputs:  (Absyn.Program, 
               Absyn.ComponentRef, /* old class as qualified name A.B.C */
               Absyn.ComponentRef) /* new class, as identifier D */
  ** outputs:  Absyn.Program
  **)
relation rename_class: (Absyn.Program, 
			 Absyn.ComponentRef, 
			 Absyn.ComponentRef) 
	   => (string, Absyn.Program) =

   rule	(* class in package *)
	Absyn.cref_to_path(new_name) => new_path &
        Absyn.path_string(new_path) => tmp_str & print tmp_str & print "\n" 
        (*the path is qualified so it cannot be renamed*)
	------------------------
	rename_class(p,old_class,new_name as Absyn.CREF_QUAL(_,_,_))
	  => ("error",p)

  rule	(* class in package *)
	Absyn.cref_to_path(old_class) => old_path &
	Absyn.cref_to_path(new_name) => new_path &
        
	traverse_classes(p,NONE,rename_class_visitor,(old_path,new_path,p),
			 true (* traverse protected*)) => ((p',_,_))
	------------------------
	rename_class(p,old_class as Absyn.CREF_IDENT(_,_),new_name)
	  => ("OK",p')

  rule	(* class in package *)
	Absyn.cref_to_path(old_class) => old_path &
	Absyn.cref_to_path(new_name) => new_path' &
        Absyn.strip_last(old_path) => old_path_no_last &
        Absyn.join_paths(old_path_no_last,new_path') => new_path &

	traverse_classes(p,NONE,rename_class_visitor,(old_path,new_path,p),
			 true (* traverse protected*)) => ((p',_,_))
	------------------------
	rename_class(p,old_class as Absyn.CREF_QUAL(_,_,_),new_name)
	  => ("OK",p')
end


 (**relation: rename_class_visitor
  **
  ** This visitor renames a class given a new name
  **)
relation rename_class_visitor: ((Absyn.Class* Absyn.Path option *(Absyn.Path*Absyn.Path*Absyn.Program)))
	   => ((Absyn.Class*Absyn.Path option *(Absyn.Path*Absyn.Path*Absyn.Program))) =

      

  rule  Absyn.join_paths(pa,Absyn.IDENT(id)) => path' &
        ModUtil.path_equal(old_class_path,path') => true &
        Absyn.path_last_ident(new_class_path) => new_name 
	----------------
	rename_class_visitor((Absyn.CLASS(id,a,b,c,d,e,file_info),SOME(pa),
                              (old_class_path,new_class_path,p)))
	  => ((Absyn.CLASS(new_name,a,b,c,d,e,file_info),SOME(pa),
               (old_class_path,new_class_path,p)))
          
  rule  let path' = Absyn.IDENT(id) &
        ModUtil.path_equal(old_class_path,path') => true &
        Absyn.path_last_ident(new_class_path) => new_name
	----------------
	rename_class_visitor((Absyn.CLASS(id,a,b,c,d,e,file_info),NONE,
                              (old_class_path,new_class_path,p)))
	  => ((Absyn.CLASS(new_name,a,b,c,d,e,file_info),NONE,
               (old_class_path,new_class_path,p)))
          
  rule  Absyn.join_paths(pa,Absyn.IDENT(id)) => path' &
        get_class_env(p,path') => cenv &
        rename_class_in_class(class,old_class_path,new_class_path,cenv) => class'
	----------------
	rename_class_visitor((class as Absyn.CLASS(id,a,b,c,d,e,file_info),SOME(pa),
                              (old_class_path,new_class_path,p)))
	  => ((class',SOME(pa),(old_class_path,new_class_path,p)))
          
  rule  let path' = Absyn.IDENT(id) &
        get_class_env(p,path') => cenv &
        rename_class_in_class(class,old_class_path,new_class_path,cenv) => class'
	----------------
	rename_class_visitor((class as Absyn.CLASS(id,a,b,c,d,e,file_info),NONE,
                              (old_class_path,new_class_path,p)))
	  => ((class',NONE,(old_class_path,new_class_path,p)))

  axiom  rename_class_visitor((class,pa,args)) => ((class,pa,args))

end


(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_class_visitor
 **)
                   
 relation rename_class_in_class: (Absyn.Class, (*the class with the component*)
                                  Absyn.Path, (* the old name for the component *)
                                  Absyn.Path,
                                        Env.Env) => Absyn.Class =
         
  rule  rename_class_in_parts(parts,old_comp,new_comp,env) => parts'
        -------------------------------
        rename_class_in_class(Absyn.CLASS(id,partial,final,encapsulated,restriction,
                                             Absyn.PARTS(parts,a),
                                              file_info),
                                  old_comp,new_comp,env) 
          => Absyn.CLASS(id,partial,final,encapsulated,restriction,
                         Absyn.PARTS(parts',a),
                         file_info)
        

  rule  rename_class_in_parts(parts,old_comp,new_comp,env) => parts'
        -------------------------------
        rename_class_in_class(Absyn.CLASS(id,partial,final,encapsulated,restriction,
                                             Absyn.CLASS_EXTENDS(a,b,c,parts),
                                              file_info),
                                  old_comp,new_comp,env) 
          =>  Absyn.CLASS(id,partial,final,encapsulated,restriction,
                          Absyn.CLASS_EXTENDS(a,b,c,parts'),
                          file_info)
        
  rule  Lookup.lookup_class(env,path',false) => (SCode.CLASS(id,_,_,_,_),cenv) &
        let path' = Absyn.IDENT(id) &
        Inst.make_fully_qualified(cenv,path') => path &
        ModUtil.path_equal(path,old_comp) => true &
        change_last_ident(path',new_comp) => new_path
    
        -------------------------------
         rename_class_in_class(Absyn.CLASS(id,partial,final,encapsulated,restriction,
                                           Absyn.DERIVED(path',a,b,elementarg,co),
                                              file_info),
                                  old_comp,new_comp,env) 
          =>  Absyn.CLASS(id,partial,final,encapsulated,restriction,
                          Absyn.DERIVED(new_path,a,b,elementarg,co),
                          file_info)
        
        
  rule  
        -------------------------------
        rename_class_in_class(class,
                                  old_comp,new_comp,env) => class

end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_class_visitor
 **)
                   

relation rename_class_in_parts:(Absyn.ClassPart list,
                                Absyn.Path, (* the old name for the component *)
                                Absyn.Path,
                                Env.Env) =>
        Absyn.ClassPart list =
        
  rule  
        --------------------------------------
        rename_class_in_parts([],_,_,env) => []

  rule  rename_class_in_parts(res,old_comp,new_comp,env) => res' &
        rename_class_in_elements(elements,old_comp,new_comp,env) => elements'
        --------------------------------------
        rename_class_in_parts(Absyn.PUBLIC(elements)::res,old_comp,new_comp,env)
          => Absyn.PUBLIC(elements')::res'

  rule  rename_class_in_parts(res,old_comp,new_comp,env) => res' &
        rename_class_in_elements(elements,old_comp,new_comp,env) => elements'
        --------------------------------------
        rename_class_in_parts(Absyn.PROTECTED(elements)::res,old_comp,new_comp,env)
          => Absyn.PROTECTED(elements')::res'

  rule  rename_class_in_parts(res,old_comp,new_comp,env) => res' 
        --------------------------------------
        rename_class_in_parts(a::res,old_comp,new_comp,env) => a::res'
 end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_class_visitor
 **)
                   

relation rename_class_in_elements:(Absyn.ElementItem list,
                                       Absyn.Path, (* the old name for the component *)
                                   Absyn.Path,
                                        Env.Env) =>
        Absyn.ElementItem list =

  rule  
        -------------------------------------
        rename_class_in_elements([],_,_,_) => []

  rule  rename_class_in_elements(res,old_comp,new_comp,env) => res' &
        rename_class_in_element_spec(elementspec,old_comp,new_comp,env) => elementspec' &
        let element' = Absyn.ELEMENTITEM(Absyn.ELEMENT(final,redeclare,inner_outer,name,elementspec',info,constraint))
        -------------------------------------
        rename_class_in_elements((element as Absyn.ELEMENTITEM(Absyn.ELEMENT(final,redeclare,inner_outer,name,elementspec,info,constraint)))
                                     ::res,old_comp,new_comp,env) => element'::res'


  rule  rename_class_in_elements(res,old_comp,new_comp,env) => res' &
        let element' = element 
        -------------------------------------
        rename_class_in_elements(element::res,old_comp,new_comp,env) => element'::res'


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_class_visitor
 **)
                   

relation rename_class_in_element_spec:(Absyn.ElementSpec,      
                                           Absyn.Path, (* the old name for the component *)
                                          Absyn.Path,
                                        Env.Env) =>
        Absyn.ElementSpec =

  rule Lookup.lookup_class(env,path',false) => (SCode.CLASS(id,_,_,_,_),cenv) &
        let path' = Absyn.IDENT(id) &
        Inst.make_fully_qualified(cenv,path') => path &
        ModUtil.path_equal(path,old_comp) => true &
        change_last_ident(path',new_comp) => new_path
        -------------------------------
        rename_class_in_element_spec(Absyn.COMPONENTS(a,path',comp_items),old_comp,new_comp,env) 
          => Absyn.COMPONENTS(a,new_path,comp_items)

  rule  (* print "rename_class_in_element_spec Absyn.EXTENDS(path,_) not implemented yet" *)
        
        Lookup.lookup_class(env,path',false) => (_,cenv) &
        Inst.make_fully_qualified(cenv,path') => path &
         ModUtil.path_equal(path,old_comp) => true &
        change_last_ident(path',new_comp) => new_path
       -------------------------------
        rename_class_in_element_spec(Absyn.EXTENDS(path',a),old_comp,new_comp,env) 
          => Absyn.EXTENDS(new_path,a)

  rule  (* print "rename_class_in_element_spec Absyn.EXTENDS(path,_) not implemented yet" *)
        rename_class_in_import(import,old_comp,new_comp,env) => import'
        -------------------------------
        rename_class_in_element_spec(Absyn.IMPORT(import,a),old_comp,new_comp,env) 
          => Absyn.IMPORT(import',a)


  rule  
        -------------------------------
        rename_class_in_element_spec(a,_,comps,env) => a


end

(** 
 ** author: x02lucpo
 **
 ** helper relation to rename_class_visitor
 **)
                   


relation rename_class_in_import:(Absyn.Import,      
                                           Absyn.Path, (* the old name for the component *)
                                          Absyn.Path,
                                        Env.Env) =>
        Absyn.Import =

  rule  Lookup.lookup_class(env,path',false) => (_,cenv) &
        Inst.make_fully_qualified(cenv,path') => path &
        ModUtil.path_equal(path,old_comp) => true &
        change_last_ident(path',new_comp) => new_path
        --------------------------
        rename_class_in_import(Absyn.NAMED_IMPORT(id,path'),old_comp,new_comp,env) 
          => Absyn.NAMED_IMPORT(id,new_path)


  rule  Lookup.lookup_class(env,path',false) => (_,cenv) &
        Inst.make_fully_qualified(cenv,path') => path &
        ModUtil.path_equal(path,old_comp) => true &
        change_last_ident(path',new_comp) => new_path
        --------------------------
        rename_class_in_import(Absyn.QUAL_IMPORT(path'),old_comp,new_comp,env) 
          => Absyn.QUAL_IMPORT(new_path)

  rule  Lookup.lookup_class(env,path',false) => (_,cenv) &
        Inst.make_fully_qualified(cenv,path') => path &
        ModUtil.path_equal(path,old_comp) => true &
        change_last_ident(path',new_comp) => new_path
        --------------------------
        rename_class_in_import(Absyn.NAMED_IMPORT(id,path'),old_comp,new_comp,env) 
          => Absyn.UNQUAL_IMPORT(new_path)

  rule  
        --------------------------
        rename_class_in_import(import,old_comp,new_comp,env) 
          => import


end

(** relation change_last_ident
 ** author: x02lucpo
 **
 ** chages the last ident of the first path to the last path ident ie:
 ** (A.B.CC,C.DD) => (A.B.DD)
 **)

relation change_last_ident:(Absyn.Path,
                            Absyn.Path)
          => Absyn.Path =

  axiom change_last_ident(Absyn.IDENT(a),Absyn.IDENT(b)) 
          => Absyn.IDENT(b)

  rule  Absyn.path_last_ident(b) => b' 
        -------------------------
        change_last_ident(a as Absyn.IDENT(_),b as Absyn.QUALIFIED(_,_)) 
          => Absyn.IDENT(b')

  rule  Absyn.strip_last(a) => a' &
        Absyn.join_paths(a',b) => res
        -------------------------
        change_last_ident(a as Absyn.QUALIFIED(_,_),b as Absyn.IDENT(_)) 
          => res

  rule  Absyn.strip_last(a) => a' &
        Absyn.path_last_ident(b) => b' &
        Absyn.join_paths(a',Absyn.IDENT(b')) => res
        -------------------------
        change_last_ident(a as Absyn.QUALIFIED(_,_),b as Absyn.QUALIFIED(_,_)) 
          => res


end


 (**relation: traverse_classes
  ** 
  ** Thisrelation traverses all classes of a program and applies arelation 
  ** to each class. Therelation takes the Absyn.Class, Absyn.Path option 
  ** and an additional argument and returns an updated class and the 
  ** additional values. The Absyn.Path option contains the path to the class
  ** that is traversed.
  **
  ** inputs:  (Absyn.Program, 
               Absyn.Path option,
               ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)),  /* rel-ation to apply */
			      'a, /* extra value passed to re-lation */
			      bool) /* true = traverse protected elements */
  ** outputs: (Absyn.Program *  Absyn.Path option * 'a)
  **)
relation traverse_classes: (Absyn.Program, 
			     Absyn.Path option,
			      ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)),
			      'a, 
			      bool)
	   => (Absyn.Program *  Absyn.Path option * 'a) =

   rule	traverse_classes2(lst,pa,visitor,args,traverse_prot) => ((lst',pa',args'))
	 -------------------------------------------------------------------------
	  traverse_classes(Absyn.PROGRAM(lst,within),pa,visitor,args,traverse_prot) 
	   => ((Absyn.PROGRAM(lst',within),pa',args'))
end


 (**relation: traverse_classes2
  **
  ** Helperrelation to traverse_classes.
  **
  ** inputs: (Absyn.Class list,
              Absyn.Path option,
              ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)),  /* rel-ation to apply */
	   'a, /* extra value passed to re-lation */
	   bool) /* true = traverse protected elements */
  ** outputs: (Absyn.Class list * Absyn.Path option * 'a)
  **)
relation traverse_classes2:(Absyn.Class list,
			     Absyn.Path option,
  ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)),  
			      'a, 
			      bool)
	   => (Absyn.Class list * Absyn.Path option * 'a) =

   axiom	traverse_classes2([],pa,visitor,args,_) => (([],pa,args))

   rule	visitor((class,pa,args)) => ((class',pa',args')) &
	 traverse_inner_class(class',pa,visitor,args',traverse_prot) => ((class'',pa'',args'')) &
	 traverse_classes2(classes,pa,visitor,args'',traverse_prot) => ((classes',pa''',args'''))
	 ------------------------
	 traverse_classes2(class::classes,pa,visitor,args,traverse_prot)
	 => ((class''::classes',pa''',args'''))

   rule	print "-traverse_classes2 failed\n" 
	 ---------------------
	 traverse_classes2(_,_,_,_,_) => fail
end


 (**relation: traverse_inner_class
  **
  ** Helperrelation to traverse_classes2. Thisrelation traverses all 
  ** inner classes of a class.
  ** 
  ** inputs:  (Absyn.Class, /* class to traverse inner classes in */
               Absyn.Path option,
               ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)), /* visitor rlation */
               'a /* extra argument */,
               bool ) /* true = traverse protected elts */
  ** outputs: (Absyn.Class * Absyn.Path option * 'a)
  **)
relation traverse_inner_class:(Absyn.Class, 
				 Absyn.Path option,
				 ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)),
				  'a,
				 bool )
	   => (Absyn.Class * Absyn.Path option * 'a) =

   rule  Absyn.join_paths(pa,Absyn.IDENT(name))  => tmp_pa &
	  traverse_inner_class_parts(parts,SOME(tmp_pa),visitor,args,visit_prot) => ((parts',pa',args'))
	  --------------------------------------------------------------
	  traverse_inner_class(Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts,str_opt),file_info),SOME(pa),visitor,args,visit_prot)  
	   => ((Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts',str_opt),file_info),pa',args'))

   rule  traverse_inner_class_parts(parts,SOME(Absyn.IDENT(name)),visitor,args,visit_prot) => ((parts',pa',args'))
	  --------------------------------------------------------------
	  traverse_inner_class(Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts,str_opt),file_info),NONE,visitor,args,visit_prot) 
	   => ((Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts',str_opt),file_info),pa',args'))

   rule  traverse_inner_class_parts(parts,pa,visitor,args,visit_prot) => ((parts',pa',args'))

	  --------------------------------------------------------------
	  traverse_inner_class(Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts,str_opt),file_info),pa,visitor,args,visit_prot) 
	   => ((Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts',str_opt),file_info),pa',args'))

   axiom	traverse_inner_class(cl,pa,_,args,_) => ((cl,pa,args))

end


 (**relation: traverse_inner_class_parts
  **
  ** Helperrelation to traverse_inner_class
  **
  ** inputs:  (Absyn.ClassPart list,
               Absyn.Path option,
               ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)), /* visitor */
               'a,
               bool) /* true = visit protected elements */
  ** outputs: (Absyn.ClassPart list * Absyn.Path option * 'a)
  **)
relation traverse_inner_class_parts: (Absyn.ClassPart list,
				       Absyn.Path option,
				       ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)),
				       'a,
				       bool)
	 => (Absyn.ClassPart list * Absyn.Path option * 'a) =

   axiom	traverse_inner_class_parts([],pa,_,args,_) => (([],pa,args))

   rule	traverse_inner_class_elements(elts,pa,visitor,args,visit_prot) => ((elts',pa',args')) &
	 traverse_inner_class_parts(parts,pa,visitor,args',visit_prot) => ((parts',pa'',args''))
	 ------------------------------------------------------------------
	 traverse_inner_class_parts(Absyn.PUBLIC(elts)::parts,pa,visitor,args,visit_prot)
	   => ((Absyn.PUBLIC(elts')::parts',pa'',args''))

   rule	traverse_inner_class_elements(elts,pa,visitor,args,true) => ((elts',pa',args')) &
	 traverse_inner_class_parts(parts,pa,visitor,args',true) => ((parts',pa'',args''))
	 ------------------------------------------------------------------
	 traverse_inner_class_parts(Absyn.PROTECTED(elts)::parts,pa,visitor,args,true)
	   => ((Absyn.PROTECTED(elts')::parts',pa'',args''))

   rule	traverse_inner_class_parts(parts,pa,visitor,args,true) => ((parts',pa',args'))
	 ------------------------------------------------------------------
	 traverse_inner_class_parts(part::parts,pa,visitor,args,true)
	   => ((part::parts',pa',args'))
end


 (**relation traverse_inner_class_elements
  **
  ** Helperrelation to traverse_inner_class_parts.
  ** 
  ** inputs:  (Absyn.ElementItem list,
               Absyn.Path option,
               ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)), /* visitor */
               'a,
               bool)  /* visit protected elts */
  ** outputs: (Absyn.ElementItem list * Absyn.Path option * 'a)
  **)
relation traverse_inner_class_elements:(Absyn.ElementItem list,
				       Absyn.Path option,
				       ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)),
				       'a,
				        bool)
	   => (Absyn.ElementItem list * Absyn.Path option * 'a) =

   axiom	traverse_inner_class_elements([],pa,_,args,_) => (([],pa,args))

   rule	traverse_inner_class_elementspec(elt_spec,pa,visitor,args,visit_prot) 
	   => ((elt_spec',pa',args')) &
	 traverse_inner_class_elements(elts,pa,visitor,args',visit_prot) 
	   => ((elts',pa'',args''))
	 -------------------------------------------------------------
	 traverse_inner_class_elements(Absyn.ELEMENTITEM(Absyn.ELEMENT(f,r,io,n,elt_spec,info,constr))::elts,pa,visitor,args,visit_prot)
	   => ((Absyn.ELEMENTITEM(Absyn.ELEMENT(f,r,io,n,elt_spec',info,constr))::elts',
		pa'',
	       args''))

   rule	traverse_inner_class_elements(elts,pa,visitor,args,visit_prot) 
	   => ((elts',pa',args'))
	 ----------------------------------------------------------------
	 traverse_inner_class_elements(elt::elts,pa,visitor,args,visit_prot) 
	   => ((elt::elts',pa',args'))
end


 (**relation: traverse_inner_class_elementspec
  **
  ** Helperrelation to traverse_inner_class_elements
  **
  ** inputs:  (Absyn.ElementSpec,
               Absyn.Path option,
               ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option *  'a)), /* visitor */
               'a,
               bool) /* visit protected elts */
  ** outputs: (Absyn.ElementSpec * Absyn.Path option * 'a)
  **)
relation traverse_inner_class_elementspec: ( Absyn.ElementSpec,
				       Absyn.Path option,
					     ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option *  'a)),
					     'a,
					     bool)
	   => (Absyn.ElementSpec * Absyn.Path option * 'a) =

   rule	visitor((class,pa,args)) => ((class',pa',args')) &
	 traverse_inner_class(class',pa,visitor,args',visit_prot) => ((class'',pa'',args'')) 
	 -------------------------------------
	 traverse_inner_class_elementspec(Absyn.CLASSDEF(repl,class),pa,visitor,args,visit_prot)
	 => ((Absyn.CLASSDEF(repl,class''),pa'',args''))

   axiom	traverse_inner_class_elementspec(elt_spec,pa,_,args,_) => ((elt_spec,pa,args))

end


(**relation: is_primitive 
 **
 ** Thisrelation takes a component reference and a program. 
 ** It returns the true if the refrenced type is a primitive type, otherwise 
 ** it returns false.
 **)
relation is_primitive: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => class &
	 is_primitive_class(class,p) => res
	 ----------------------------
	 is_primitive(cr,p) => res

 (* Instead of elaborating and lookup these in env, we optimize a bit and just return true for these *)
   axiom	is_primitive(Absyn.CREF_IDENT("Real",_),_) => true
   axiom	is_primitive(Absyn.CREF_IDENT("Integer",_),_) => true
   axiom	is_primitive(Absyn.CREF_IDENT("String",_),_) => true
   axiom	is_primitive(Absyn.CREF_IDENT("Boolean",_),_) => true
   axiom	is_primitive(_,_) => false
end


 (**relation: delete_class
  **
  ** Thisrelation takes a component reference and a program. 
  ** It deletes the class specified by the component reference from the 
  ** given program.
  **)
relation delete_class: (Absyn.ComponentRef, Absyn.Program) 
	  => (string, Absyn.Program) =

   rule	(* Class inside another class, inside another class *)
	 Absyn.cref_to_path(class) => cpath &
	 Absyn.strip_last(cpath) => parentcpath &
	 Absyn.strip_last(parentcpath) => parentparentcpath &
	 get_pathed_class_in_program(cpath, p) => cdef &
	 get_pathed_class_in_program(parentcpath, p) => parentcdef &
	 remove_inner_class(cdef, parentcdef) => parentcdef' &
	 update_program(Absyn.PROGRAM([parentcdef'], Absyn.WITHIN(parentparentcpath)), p) => newp
	 ----------------------------------------------------------------------------
	 delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", newp)

   rule	(* Class inside other class *)
	 Absyn.cref_to_path(class) => cpath &
	 Absyn.strip_last(cpath) => parentcpath &
	 get_pathed_class_in_program(cpath, p) => cdef &
	 get_pathed_class_in_program(parentcpath, p) => parentcdef &
	 remove_inner_class(cdef, parentcdef) => parentcdef' &
	 update_program(Absyn.PROGRAM([parentcdef'], Absyn.TOP), p) => newp
	 ----------------------------------------------------------------------------
	 delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", newp)

   rule	(* Top level class *)
	 Absyn.cref_to_path(class) => cpath &
	 get_pathed_class_in_program(cpath, p) => cdef &
	 delete_class_from_list(cdef, clist) => clist'
	 ---------------------------------------------------------------------------------------
	 delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", Absyn.PROGRAM(clist', w))

   axiom	delete_class(_, p) => ("false",p)	
end


(**relation: delete_class_from_list
 **
 ** Helperrelation to delete_class.
 **)
relation delete_class_from_list: (Absyn.Class, Absyn.Class list)
	  => Absyn.Class list =

	 
   axiom	 (* Empty list *)
            delete_class_from_list(_,[]) => []

   rule name = name2
	 -------------------------------------------------------------------------------------------
   delete_class_from_list(Absyn.CLASS(name,_,_,_,_,_,_), Absyn.CLASS(name2,_,_,_,_,_,_)::xs) => xs

   rule not name = name2 &
   delete_class_from_list(cdef, xs) => res
	 --------------------------------------
   delete_class_from_list(cdef as Absyn.CLASS(name,_,_,_,_,_,_), (x as Absyn.CLASS(name2,_,_,_,_,_,_))::xs) => x::res

   rule delete_class_from_list(cdef, xs) => res
	 --------------------------------------
   delete_class_from_list(cdef as Absyn.CLASS(name,_,_,_,_,_,_), x::xs) => x::res
end

(**relation: set_class_comment
 ** author: PA
 **
 ** Sets the class comment.
 **)
relation set_class_comment:(Absyn.ComponentRef,string,Absyn.Program) 
	  => (Absyn.Program, string) =


  rule	Absyn.cref_to_path(class) => p_class &
	build_within(p_class) => within &
	get_pathed_class_in_program(p_class,p) => cdef &
	set_class_comment_in_class(cdef,str) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	------------------
	set_class_comment(class,str,p) 
	  => (newp,"Ok")

  axiom	set_class_comment(_,_,p) => (p,"Error")
end

(**relation: set_class_comment_in_class
 ** author: PA
 ** 
 ** Helperrelation to set_class_comment
 **)
relation set_class_comment_in_class: (Absyn.Class,string) => Absyn.Class =

  rule	set_class_comment_in_classdef(cdef,cmt) => cdef' 
	------------------
	set_class_comment_in_class(Absyn.CLASS(id,p,f,e,r,cdef,info),cmt)
	=> Absyn.CLASS(id,p,f,e,r,cdef',info)
end

(**relation: set_class_comment_in_classdef
 ** author: PA
 ** 
 ** Helperrelation to set_class_comment_in_class
 **)
relation set_class_comment_in_classdef:(Absyn.ClassDef,string) 
	  => Absyn.ClassDef =
  axiom	set_class_comment_in_classdef(Absyn.PARTS(p,_),"") => Absyn.PARTS(p,NONE)

  axiom	set_class_comment_in_classdef(Absyn.PARTS(p,_),cmt) => Absyn.PARTS(p,SOME(cmt))

  rule	set_class_comment_in_comment_opt(cmt,strcmt) => cmt' 
	---------------
	set_class_comment_in_classdef(Absyn.DERIVED(p,ad,attr,arg,cmt),strcmt)
	  => Absyn.DERIVED(p,ad,attr,arg,cmt') 

  rule	set_class_comment_in_comment_opt(cmt,strcmt) => cmt' 
	---------------
	set_class_comment_in_classdef(Absyn.ENUMERATION(edef,cmt),strcmt)
	  => Absyn.ENUMERATION(edef,cmt')

  rule	set_class_comment_in_comment_opt(cmt,strcmt) => cmt' 
	---------------
	set_class_comment_in_classdef(Absyn.OVERLOAD(plst,cmt),strcmt)
	  => Absyn.OVERLOAD(plst,cmt')

  axiom	set_class_comment_in_classdef(Absyn.CLASS_EXTENDS(id,args,_,p),"")
	  => Absyn.CLASS_EXTENDS(id,args,NONE,p)

  axiom	set_class_comment_in_classdef(Absyn.CLASS_EXTENDS(id,args,_,p),cmt)
	  => Absyn.CLASS_EXTENDS(id,args,SOME(cmt),p)

  axiom	set_class_comment_in_classdef(c,_) => c

end

(**relation: set_class_comment_in_comment_opt
 ** author: PA
 ** 
 ** Sets the string comment in an Comment option.
 **)
relation set_class_comment_in_comment_opt: (Absyn.Comment option, string) 
	  => Absyn.Comment option =

axiom	set_class_comment_in_comment_opt(SOME(Absyn.COMMENT(ann,_)),"") 
	  => SOME(Absyn.COMMENT(ann,NONE))

  axiom	set_class_comment_in_comment_opt(SOME(Absyn.COMMENT(ann,_)),cmt) 
	  => SOME(Absyn.COMMENT(ann,SOME(cmt)))

  axiom	set_class_comment_in_comment_opt(NONE,cmt) 
	  => SOME(Absyn.COMMENT(NONE,SOME(cmt)))
end

(**relation: get_class_information
 ** author: PA
 **
 ** Returns the class restriction, class comment and source file of a class.
 **)
relation get_class_information:(Absyn.ComponentRef,
				Absyn.Program) => string =

  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,restr,cdef,Absyn.INFO(file,_,_,_,_,_)) &
	Dump.unparse_restriction_str(restr) => res &
	get_class_comment(cdef) => cmt &
	Util.string_append_list(["{\"",res,"\", ",cmt,", \"",file,"\"}"]) => res'
	----------------------------
	get_class_information(cr,p) => res'
end

(**relation: get_class_comment
 ** author: PA
 **
 ** Returns the class comment of a Absyn.ClassDef
 **)
relation get_class_comment: Absyn.ClassDef => string =

  rule	get_class_comment2(cdef) => s &
	Util.string_append_list(["\"",s,"\""]) => res
	-------------------
	get_class_comment(cdef) => res

end

(**relation: get_class_comment2
 ** 
 ** Helperrelation to get_class_comment.
 **)
relation get_class_comment2: Absyn.ClassDef => string =

  axiom	get_class_comment2(Absyn.PARTS(_,SOME(str))) => str

  rule	get_string_comment2(cmt) => res
	-----------------------------
	get_class_comment2(Absyn.DERIVED(_,_,_,_,cmt)) => res 
	
  rule	get_string_comment2(cmt) => res
	-----------------------------
	get_class_comment2(Absyn.ENUMERATION(_,cmt)) => res 

  rule	get_string_comment2(cmt) => res
	-----------------------------
	get_class_comment2(Absyn.ENUMERATION(_,cmt)) => res 

  rule	get_string_comment2(cmt) => res
	-----------------------------
	get_class_comment2(Absyn.OVERLOAD(_,cmt)) => res 

  axiom	get_class_comment2(Absyn.CLASS_EXTENDS(_,_,SOME(str),_)) => str 


  axiom	get_class_comment2(_) => ""

end

(**relation: get_class_restriction
 ** author: PA
 **
 ** Returns the class restriction of a class as a string.
 **)
relation get_class_restriction:(Absyn.ComponentRef,
				Absyn.Program) => string =

  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,restr,_,_) &
	Dump.unparse_restriction_str(restr) => res &
	Util.string_append_list(["\"",res,"\""]) => res'
	----------------------------
	get_class_restriction(cr,p) => res'
end


(**relation: is_type 
 **
 ** Thisrelation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "type", 
 ** otherwise it returns false.
 **)
relation is_type: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_TYPE,_,_) 
	 ----------------------------
	 is_type(cr,p) => true

   axiom	is_type(cr,p) => false
end


 (**relation: is_connector
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "connector", 
  ** otherwise it returns false.
  **)
relation is_connector: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_) 
	 ----------------------------
	 is_connector(cr,p) => true

   axiom	is_connector(cr,p) => false
end


 (**relation: is_model
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "model", 
  ** otherwise it returns false.
  **)
relation is_model: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_MODEL,_,_) 
	 ----------------------------
	 is_model(cr,p) => true

   axiom	is_model(cr,p) => false
end


 (**relation: is_record
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "record", 
  ** otherwise it returns false.
  **)
relation is_record: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_RECORD,_,_) 
	 ----------------------------
	 is_record(cr,p) => true

   axiom	is_record(cr,p) => false
end


 (**relation: is_block
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "block", 
  ** otherwise it returns false.
  **)
relation is_block: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_BLOCK,_,_) 
	 ----------------------------
	 is_block(cr,p) => true

   axiom	is_block(cr,p) => false
end


 (**relation: is_function
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "function", 
  ** otherwise it returns false.
  **)
relation is_function: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_FUNCTION,_,_) 
	 ----------------------------
	 is_function(cr,p) => true

   axiom	is_function(cr,p) => false
end

 (**relation: is_package
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "package", otherwise it returns 
  ** false.
  **)
relation is_package: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_PACKAGE,_,_) 
	 ----------------------------
	 is_package(cr,p) => true

   axiom	is_package(cr,p) => false
end


 (**relation: is_class
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "class", 
  ** otherwise it returns  false.
  **)
relation is_class: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_CLASS,_,_) 
	 ----------------------------
	 is_class(cr,p) => true

   axiom	is_class(cr,p) => false
end


 (**relation: is_parameter
  **
  ** Thisrelation takes a class and a component reference and a program
  ** and returns true if the component referenced is a parameter.
  **)
relation is_parameter: (Absyn.ComponentRef, Absyn.ComponentRef, 
			 Absyn.Program) 
	  => bool =

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(cr,publst) => Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.PARAM,_,_),_,_) 
	 ------------------------
	 is_parameter (cr,classname,p) => true

   axiom	is_parameter (_,_,_) => false
end


 (**relation: is_protected
  **
  ** Thisrelation takes a class and a component reference and a program
  ** and returns true if the component referenced is in a protected section.
  **)
relation is_protected: (Absyn.ComponentRef, Absyn.ComponentRef, 
			 Absyn.Program) 
	  => bool =

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(cr,publst) => _
	 ------------------------
	 is_protected (cr,classname,p) => false

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_protected_list(parts) => protlst &
	 get_components_contains_name(cr,protlst) => _
	 ---------------------------------------------
	 is_protected (cr,classname,p) => true

   axiom	is_protected (_,_,_) => false
end


 (**relation: is_constant
  **
  ** Thisrelation takes a class and a component reference and a program
  ** and returns true if the component referenced is a constant.
  **)
relation is_constant: (Absyn.ComponentRef, Absyn.ComponentRef, 
			Absyn.Program) 
	  => bool =

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(cr,publst) => Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.CONST,_,_),_,_) 
	 ------------------------
	 is_constant (cr,classname,p) => true

  axiom	is_constant (_,_,_) => false
end


(**relation: get_elementitem_contains_name
 **
 ** Returns the element that has the component name given as argument.
 **)
relation get_elementitem_contains_name: (Absyn.ComponentRef, Absyn.ElementItem list)
	=> Absyn.ElementItem =

  rule  get_components_contains_name(cr,[elt]) => _ 
	---------------------------------
	get_elementitem_contains_name(cr,elt::_) => elt 

  rule	get_elementitem_contains_name(cr,rest) => res
	-------------------------
	get_elementitem_contains_name(cr,_::rest) => res
end 


(**relation: get_components_contains_name
 **
 ** Return the ElementSpec containing the name given as argument from a list
 ** of ElementItems
 **)
relation get_components_contains_name: (Absyn.ComponentRef, Absyn.ElementItem list) 
	   => Absyn.ElementSpec =

   rule	get_compitem_named(cr,ellst) => _
	 -------------------
	 get_components_contains_name (cr,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,res as Absyn.COMPONENTS(_,_,ellst),_,_))::xs) => res

   rule	get_components_contains_name(cr,xs) => res
	 -----------------------------------------
	 get_components_contains_name (cr,x::xs) => res
end


(**relation: get_element_contains_name
 **
 ** Return the Element containing the component name given as argument from
 ** a list of ElementItems.
 **)
relation get_element_contains_name: (Absyn.ComponentRef, 
				      Absyn.ElementItem list) 
	   => Absyn.Element =

   rule	get_compitem_named(cr,ellst) => _
	 -------------------
	 get_element_contains_name (cr,Absyn.ELEMENTITEM(res as Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,ellst),_,_))::xs) => res

   rule	get_element_contains_name(cr,xs) => res
	 -----------------------------------------
	 get_element_contains_name (cr,x::xs) => res
end


(**relation: get_compitem_named
 **
 ** Helperrelation to get_components_contains_name.
 **)
relation get_compitem_named: (Absyn.ComponentRef, Absyn.ComponentItem list)
	   => Absyn.ComponentItem =

   rule	id1 = id2 
	 ---------
	 get_compitem_named(Absyn.CREF_IDENT(id1,_), (x as Absyn.COMPONENTITEM(Absyn.COMPONENT(id2,_,_),_,_))::xs) => x

   rule	get_compitem_named(cr,xs) => res
	 --------------------------------
	 get_compitem_named(cr, x::xs) => res
end


 (**relation: exist_class
  **
  ** Thisrelation takes a component reference and a program. 
  ** It returns true if the refrenced class exists in the symbol table, 
  ** otherwise it returns false.
  **)
relation exist_class: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => _
	 ----------------------------
	 exist_class(cr,p) => true

   axiom	exist_class(cr,p) => false
end


(**relation: is_primitive_class
 **
 ** Return true of a class is a primitive class, i.e. one of the builtin 
 ** classes or the 'type' restricted class. It also checks derived classes
 ** using short class definition.
 **)
relation is_primitive_class: (Absyn.Class,Absyn.Program) => bool =

   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_INT,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_REAL,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_STRING,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_BOOL,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_TYPE,_,_),_) => true

   rule	Absyn.cref_to_path(Absyn.CREF_IDENT(cname,[])) => inmodel &
	 lookup_classdef(path,inmodel,p)=> (cdef,_) &
	 is_primitive_class(cdef,p) => res
	 -------------------------------
	 is_primitive_class(Absyn.CLASS(cname,_,_,_,Absyn.R_CLASS,Absyn.DERIVED(path,_,_,_,_),_),p) => res

end


 (**relation: remove_compiled_functions
  **
  ** A Compiled function should be removed if its definition is updated.
  **)
relation remove_compiled_functions: (Absyn.Program, (Absyn.Path * Types.Type) list)
	     => (Absyn.Path * Types.Type) list =
   rule	remove_cf(id,cfs) => cfs'
	 -----------------
	 remove_compiled_functions(Absyn.PROGRAM([Absyn.CLASS(id,_,_,_,Absyn.R_FUNCTION,_,_)],_),cfs) => cfs'
   axiom	remove_compiled_functions(_,cfs) => cfs
end


(**relation: remove_cf
 **
 ** Helperrelation to remove_compiled_functions.
 **)
relation remove_cf: (Absyn.Ident, (Absyn.Path * Types.Type) list)
	     => (Absyn.Path * Types.Type) list =

   axiom	remove_cf(_,[]) => []

   rule	id1 = id2 &
	 remove_cf(id1,rest) => res
	 --------------------------
	 remove_cf(id1,(Absyn.IDENT(id2),t)::rest) => res 
   rule	not id1 = id2 &
	 remove_cf(id1,rest) => res
	 --------------------------
	 remove_cf(id1,(Absyn.IDENT(id2),t)::rest) => ((Absyn.IDENT(id2),t)::res)
end


 (**relation: update_program
  **
  ** Thisrelation takes an old program (second argument), i.e. the old 
  ** symboltable, and a new program (first argument), i.e. a new set of
  ** classes and updates the old program with the definitions in the new one.
  **)     
relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program =

  axiom	update_program (Absyn.PROGRAM([],_),prg) => prg

   rule	(* For split definitions at top, when introducing new model, eg. "package A" *)
	 let newclass = Absyn.CLASS(name,p,false,e,restr,Absyn.PARTS([Absyn.PUBLIC([])],NONE),Absyn.INFO("",false,0,0,0,0)) &
	 update_program(Absyn.PROGRAM([newclass],Absyn.TOP),oldp) => newp
	 -------------------------------------------------------
	 update_program(Absyn.BEGIN_DEFINITION(Absyn.IDENT(name),restr,p,e),oldp) => newp

   rule	(* For split definitions not at top,  eg. "package A.B" *)
	 Absyn.strip_last(path) => w &
	 Absyn.path_last_ident(path) => name &
	 let newclass = Absyn.CLASS(name,p,false,e,restr,Absyn.PARTS([Absyn.PUBLIC([])],NONE),Absyn.INFO("",false,0,0,0,0)) &
	 update_program(Absyn.PROGRAM([newclass],Absyn.WITHIN(w)),oldp) => newp
	 -------------------------------------------------------
	 update_program(Absyn.BEGIN_DEFINITION(path as Absyn.QUALIFIED(_,_),
					       restr,p,e),oldp) 
	   => newp

   rule	class_in_program(name,p2) => false &
	 update_program(Absyn.PROGRAM(c2,w),Absyn.PROGRAM((c1::c3),w2)) => pnew
	 ---------------------------------------------------------
	 update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_,_,_))::c2,w as Absyn.TOP),p2 as Absyn.PROGRAM(c3,w2)) => pnew

   rule	class_in_program(name,p2) => true &
	 update_program(Absyn.PROGRAM(c2,w),p2) => pnew &
	 replace_class_in_program(c1,pnew) => pnew' 
	 ------------------------------------------
	 update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_,_,_))::c2,w as Absyn.TOP),p2) => pnew'

   rule	insert_class_in_program(c1,w,p2) => pnew &
	 update_program(Absyn.PROGRAM(c2,w),pnew) => pnew' 
	 ---------------------------------------------
	 update_program(Absyn.PROGRAM(c1::c2,w as Absyn.WITHIN(path)),p2) => pnew'

   rule	(* nested packages (of form A.B) *)
	 get_pathed_class_in_program(path,p) => cdef &
	 Absyn.strip_last(path) => modelwithin &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       NONE, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,Absyn.INFO("",false,0,0,0,0),NONE)))
	   => newcdef &	
	  update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.COMP_DEFINITION(elt,SOME(path as Absyn.QUALIFIED(_,_))),p) 
	   => newp

   rule	(* top package *)
	  get_pathed_class_in_program(path,p) => cdef &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       NONE, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,Absyn.INFO("",false,0,0,0,0),NONE)))
	   => newcdef &	
	  update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.COMP_DEFINITION(elt,SOME(path as Absyn.IDENT(_))),p) 
	   => newp

   rule	(* nested packages ( e.g. A.B ) *)
	 get_pathed_class_in_program(path,p) => cdef &
	 Absyn.strip_last(path) => modelwithin &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       NONE, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,Absyn.INFO("",false,0,0,0,0),NONE)))
	   => newcdef &	
	   update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.IMPORT_DEFINITION(elt,SOME(path as Absyn.QUALIFIED(_,_))),p) 
	   => newp

   rule	(* top level package e.g. A *)
	 get_pathed_class_in_program(path,p) => cdef &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       NONE, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,Absyn.INFO("",false,0,0,0,0),NONE)))
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.IMPORT_DEFINITION(elt,SOME(path as Absyn.IDENT(_))),p) 
	   => newp	

   rule	Print.print_buf "Further program merging not implemented yet\n"
	 ------------------------
	 update_program (a,b) => b
end


 (**relation: add_scope
  **
  **  Thisrelation adds the scope of the scope variable to the program,
  ** so it can be inserted at the correct place.
  ** It also adds the scope to BEGIN_DEFINITION, COMP_DEFINITION and 
  ** IMPORT_DEFINITION so an empty class definition
  ** can be inserted at the correct place.
  **)
relation add_scope: (Absyn.Program, InteractiveVariable list) 
	   => Absyn.Program =

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path))
	 --------------------------------------
	 add_scope(Absyn.PROGRAM(cls,Absyn.TOP),vars) 
	   => Absyn.PROGRAM(cls,Absyn.WITHIN(path))

   rule	not get_variable_value("scope",vars) => _
	 --------------------------------------
	 add_scope(Absyn.PROGRAM(cls,w),vars) 
	   => Absyn.PROGRAM(cls,w)

   rule	(* This should probably be forbidden. *)
	 get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	   Absyn.join_paths(path,path2) => newpath 
	 --------------------------------------
	 add_scope(Absyn.PROGRAM(cls,Absyn.WITHIN(path2)),vars)
	   => Absyn.PROGRAM(cls,Absyn.WITHIN(newpath))

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	 Absyn.join_paths(path,path2) => newpath  
	 --------------------
	 add_scope(Absyn.BEGIN_DEFINITION(path2,restr,p,e),vars)
	 => Absyn.BEGIN_DEFINITION(newpath,restr,p,e)

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) 
	   --------------------
	 add_scope(Absyn.COMP_DEFINITION(elt,NONE),vars)
	   => Absyn.COMP_DEFINITION(elt,SOME(path))

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) 
	   --------------------
	 add_scope(Absyn.IMPORT_DEFINITION(elt,NONE),vars)
	   => Absyn.IMPORT_DEFINITION(elt,SOME(path))

   axiom	add_scope(p,_) => p
end


 (**relation: update_scope
  ** Thisrelation takes a PROGRAM and updates the variable scope to according
  ** to the value of program:
  ** 1. BEGIN_DEFINITION ident appends ident to scope
  ** 2.END_DEFINITION ident removes ident from scope
  **)
relation update_scope: (Absyn.Program, InteractiveVariable list) 
	   => InteractiveVariable list =

   rule	(* If not top scope *)
	 get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	 Absyn.join_paths(path,Absyn.IDENT(id)) => newscope &
	 let newscope' = Values.CODE(Absyn.C_TYPENAME(newscope)) &
	 add_var_to_varlist(
			    "scope",
			    newscope',
			    ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[],NONE),NONE)),
			    vars)
	   => vars'
	 -------------------------------------------------------------
	 update_scope(Absyn.BEGIN_DEFINITION(Absyn.IDENT(id),_,_,_),vars) => vars'

   rule	(* If top scope *)
	 let newscope' = Values.CODE(Absyn.C_TYPENAME(Absyn.IDENT(id))) &
	 add_var_to_varlist(
			    "scope",
			    newscope',
			    ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[],NONE),NONE)),
			    vars)
	   => vars'
	 -----------
	 update_scope(Absyn.BEGIN_DEFINITION(Absyn.IDENT(id),_,_,_),vars) => vars'

   rule	(* If not top scope *)
	 get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	 Absyn.path_last_ident(path) => id2 &
	 id1 = id2 &
	 Absyn.strip_last(path) => newscope &
	 let newscope' = Values.CODE(Absyn.C_TYPENAME(newscope)) &
	 Absyn.strip_last(path) => path' &
	 add_var_to_varlist(
			    "scope",
			    newscope',
			    ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[],NONE),NONE)),
			    vars)
	   => vars'
	 ----------------------
	 update_scope(Absyn.END_DEFINITION(id1),vars) => vars'

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(Absyn.IDENT(id2))) &
	 id1 = id2 &  
	 remove_var_from_varlist("scope",vars) => vars' 
	 ------------------------
	 update_scope(Absyn.END_DEFINITION(id1),vars) => vars'

  axiom update_scope(_,vars) => vars
end


(**relation: remove_var_from_varlist
 **
 ** Helperrelation to update_scope.
 **)
relation remove_var_from_varlist: (Absyn.Ident,InteractiveVariable list) 
	 => InteractiveVariable list =

   axiom	remove_var_from_varlist(_,[]) => []

   rule	id1 = id2 
	 ---------
	 remove_var_from_varlist(id1, IVAR(id2,_,_)::rest) => rest

   rule	not id1 = id2 &
	 remove_var_from_varlist(id1,rest) => rest'
	 -----------------------------------------
	 remove_var_from_varlist(id1,(v as IVAR(id2,_,_))::rest)
	   => v::rest'
end


(**relation: get_variable_value
 **
 ** Return the value of an interactive variable from a list of 
 ** InteractiveVariable.
 **)
relation get_variable_value: (Absyn.Ident, InteractiveVariable list) => 
	 (Values.Value) =

   rule	id1 = id2
	 -------
	 get_variable_value(id1,IVAR(id2,v,_)::_) => v

   rule	not id1 = id2 &
	 get_variable_value(id1,rest) => v
	 ---------------------------------
	 get_variable_value(id1,IVAR(id2,v,_)::rest) => v
end


 (**relation: lookup_classdef
  **
  ** Thisrelation takes a Path of a class to lookup and a Path as a 
  ** starting point for the lookup rules and a Program.
  ** It returns the Class definition and the complete Path to the class.
  **)
relation lookup_classdef: (Absyn.Path, Absyn.Path, Absyn.Program) 
	  => (Absyn.Class, Absyn.Path) =

   rule	(* Look first inside 'inmodel' *)
	 get_pathed_class_in_program(inmodel,p) => inmodeldef &
	 get_pathed_class_in_program(path,Absyn.PROGRAM([inmodeldef],Absyn.TOP)) => cdef &
	 Absyn.join_paths(inmodel,path) => newpath
	 --------------------------------
	 lookup_classdef(path, inmodel,p) => (cdef,newpath)

	 (* Then look inside next level *)
   rule	Absyn.strip_last(inmodel) => innewpath &
	 lookup_classdef(path,innewpath,p) => (cdef,respath)
	 ------------------------------
	 lookup_classdef(path,inmodel,p) => (cdef,respath)

   rule	(* Finally look in top level *)
	 get_pathed_class_in_program(path,p) => cdef
	 ------------------------------------------
	 lookup_classdef(path,_,p) => (cdef,path)

   axiom	lookup_classdef(Absyn.IDENT("Real"),_,_) => 
	 (Absyn.CLASS("Real",false,false,false,Absyn.R_PREDEFINED_REAL,Absyn.PARTS([],NONE),Absyn.INFO("",false,0,0,0,0)), 
	  Absyn.IDENT("Real"))

   axiom	lookup_classdef(Absyn.IDENT("Integer"),_,_) => 
	 (Absyn.CLASS("Integer",false,false,false,Absyn.R_PREDEFINED_INT,Absyn.PARTS([],NONE),Absyn.INFO("",false,0,0,0,0)), 
	  Absyn.IDENT("Integer"))

   axiom	lookup_classdef(Absyn.IDENT("String"),_,_) => 
	 (Absyn.CLASS("String",false,false,false,Absyn.R_PREDEFINED_STRING,Absyn.PARTS([],NONE),Absyn.INFO("",false,0,0,0,0)), 
	  Absyn.IDENT("String"))

   axiom	lookup_classdef(Absyn.IDENT("Boolean"),_,_) => 
	 (Absyn.CLASS("Boolean",false,false,false,Absyn.R_PREDEFINED_BOOL,Absyn.PARTS([],NONE),Absyn.INFO("",false,0,0,0,0)), 
	  Absyn.IDENT("Boolean"))

  rule	Absyn.path_string path => s1 &
	 Absyn.path_string inpath => s2 &
	 Error.add_message(Error.LOOKUP_ERROR,[s1,s2])
	 ---------------------
	 lookup_classdef(path,inpath,_) => fail
end


 (**relation: delete_component
  **
  ** Thisrelation deletes a component from a class given the name of the 
  ** component instance, the model in which the component is instantiated in, 
  ** and the Program.
  **
  ** Both public and protected lists are searched.
  **)
relation delete_component: (string, Absyn.ComponentRef, Absyn.Program) 
	  => (Absyn.Program ,string) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 not get_pathed_class_in_program(modelpath,p) => _
	 ---------------------------------
	 delete_component (name,model,p) => (p,"false\n") 

   rule	Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_component_from_class(name, cdef) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	 ------------------------------------------------
	 delete_component(name, model as Absyn.CREF_QUAL(_,_,_),p as Absyn.PROGRAM(_,w)) => (newp,"true\n")

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_component_from_class(name, cdef) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ------------------------------------------------
	 delete_component( name, model as Absyn.CREF_IDENT(_,_), p as Absyn.PROGRAM(_,w)) => (newp,"true\n")

   axiom	delete_component(_,_,p) => (p,"false\n") 
end


 (**relation: delete_component_from_class
  **
  ** Thisrelation deletes a component from a class given the name of the component instance, and a 'Class'.
  ** 
  ** Both public and protected lists are searched.
  **)
relation delete_component_from_class: (string, Absyn.Class)
	  => Absyn.Class =

	 
   rule	 (* Search in public list *)
	 get_public_list(parts) => publst &
	 delete_component_from_elementitems(name,publst) => publst2 &
	 list_length(publst2) => l2 &
	 list_length(publst) => l1 &
	 int_sub(l1,1) => l1' &
	 l1' = l2 &
	 replace_public_list(parts,publst2) => parts2 
	 --------------------------------------------
	 delete_component_from_class(name, Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info)) 
	 => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)

	 (* Search in protected list *)
   rule	get_protected_list(parts) => protlst &
	 delete_component_from_elementitems(name,protlst) => protlst2 &
	 list_length(protlst2) => l2 &
	 list_length(protlst) => l1 &
	 int_sub(l1,1) => l1' &
	 l1' = l2 &
	 replace_protected_list(parts,protlst2) => parts2 
	 --------------------------------------------
	 delete_component_from_class(name, Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info)) 
	 => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)
end	


(**relation: delete_component_from_elementitems
 **
 ** Helperrelation to delete_component_from_class.
 **)
relation delete_component_from_elementitems: (string, Absyn.ElementItem list) 
	   => Absyn.ElementItem list =

   axiom	 delete_component_from_elementitems (_,[]) => []

   rule	name = name2 
	 -------------
	 delete_component_from_elementitems(name,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,[Absyn.COMPONENTITEM(Absyn.COMPONENT(name2,_,_),_,_)]),_,_))::xs) => xs

   rule	not name = name2 &
	 delete_component_from_elementitems(name, xs) => res
	 -------------------------
	 delete_component_from_elementitems(name, (x as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,[Absyn.COMPONENTITEM(Absyn.COMPONENT(name2,_,_),_,_)]),_,_)))::xs) => x::res

   rule	delete_component_from_elementitems(name, xs) => res
	 ---------------------------------------------------
	 delete_component_from_elementitems(name,x::xs) => x::res 
end


 (**relation add_component
  **
  ** Thisrelation takes:  
  ** arg1 - string giving the instancename, 
  ** arg2 - `ComponentRef' giving the component type
  ** arg3 - ComponentRef giving the model to instantiate the component within,
  ** arg4 - `NamedArg' list of annotations 
  ** arg5 - a Program. 
  *** The result is an updated program with the component and its annotations 
  ** inserted, and a string "OK" for success. If the insertion fails, a
  ** suitable error string is given along with the input Program.
  **)
relation add_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,
			  Absyn.NamedArg list, Absyn.Program) 
	  => (Absyn.Program ,string) =

   rule	 Absyn.cref_to_path(model) => modelpath &
	 not get_pathed_class_in_program(modelpath,p) => _
	 ---------------------------------
	 add_component (name,tp,model,nargs,p) => (p,"false\n") 


	 (* Adding component to model that resides inside package *)
   rule	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 annotation_list_to_absyn_comment(nargs,NONE) => annotation &
	 modification_to_absyn(nargs,NONE) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),NONE,annotation)]),Absyn.INFO("",false,0,0,0,0),NONE))) => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	 ------------------------------------------------
	 add_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")

	 (* Adding component to model that resides on top level *)
   rule	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 annotation_list_to_absyn_comment(nargs,NONE) => annotation &
	 modification_to_absyn(nargs,NONE) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),NONE,annotation)]),Absyn.INFO("",false,0,0,0,0),NONE))) => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)=> newp
	 ------------------------------------------------
	 add_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")

   axiom	add_component (_,_,_,_,p) => (p,"Error")

end


 (**relation: update_component
  **
  ** Thisrelation updates a component in a class. The reason for having 
  ** thisrelation is that a deletion followed by an addition would mean that 
  ** all optional arguments must be present to the add_componentrelation 
  ** in order to get the same component attributes,etc. as previous. 
  **) 
relation update_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,
			     Absyn.NamedArg list,
			     Absyn.Program) 
	  => (Absyn.Program ,string) =

   rule	(* Updating a public component to model that resides inside package *)
	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_public_list(parts) => publst &
	 get_element_contains_name(Absyn.CREF_IDENT(name,[]),publst) 
	  => Absyn.ELEMENT(final,repl,inout,id,Absyn.COMPONENTS(attr,tp,items),info,constr) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),cond,ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(final,repl,inout,id,
	     Absyn.COMPONENTS(attr,tp,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),cond,annotation)]),info,constr)))
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p) => newp
	 --------------------------
	 update_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp, "true")

   rule	(* Updating a protected component to model that resides inside package*)
	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_protected_list(parts) => protlst &
	 get_element_contains_name(Absyn.CREF_IDENT(name,[]),protlst) 
	  => Absyn.ELEMENT(final,repl,inout,id,Absyn.COMPONENTS(attr,tp,items),info,constr) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),cond,ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_protected(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(final,repl,
							       inout,id,
	     Absyn.COMPONENTS(attr,tp,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),cond,annotation)]),info,constr)))
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p) => newp
	 --------------------------
	 update_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp, "true")

   rule	(* Updating a public component to model that resides on top level *)
	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_element_contains_name(Absyn.CREF_IDENT(name,[]),publst) 
	  => Absyn.ELEMENT(final,repl,inout,id,Absyn.COMPONENTS(attr,tp,items),info,constr) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),cond,ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(final,repl,inout,id,
	     Absyn.COMPONENTS(attr,tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),cond,annotation)]),info,constr))) 
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ------------------------------------------------
	 update_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp,"true")

   rule	(* Updating a protected component to model that resides on top level *)
	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_protected_list(parts) => protlst &
	 get_element_contains_name(Absyn.CREF_IDENT(name,[]),protlst) 
	  => Absyn.ELEMENT(final,repl,inout,id,Absyn.COMPONENTS(attr,tp,items),info,constr) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),cond,ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_protected(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(final,repl,inout,id,
	     Absyn.COMPONENTS(attr,tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),cond,annotation)]),info,constr))) 
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ------------------------------------------------
	 update_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp,"true")

end


 (**relation:add_class_annotation 
  **
  ** Thisrelation takes a `ComponentRef' and an `Exp' expression and a 
  ** `Program' and adds the expression as a annotation to the specified 
  ** model in the program, returning the updated program.
  **)
relation add_class_annotation:(Absyn.ComponentRef,Absyn.NamedArg list,
				Absyn.Program) 
	  => Absyn.Program =

   rule	(* Class inside other class *)
	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 add_class_annotation_to_class(cdef,nargs) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'], Absyn.WITHIN(modelwithin)),p) => newp
	 -----------------------------
	 add_class_annotation(model as Absyn.CREF_QUAL(_,_,_),nargs,p) => newp

   rule	(* Class on top level *)
	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 add_class_annotation_to_class(cdef,nargs) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'], Absyn.TOP),p) => newp
	 -----------------------------
	 add_class_annotation(model as Absyn.CREF_IDENT(_,_),nargs,p) => newp
end


 (**relation: add_class_annotation_to_class
  *
  * Thisrelation adds an annotation on element level to a `Class´.
  **)
relation add_class_annotation_to_class: ( Absyn.Class, Absyn.NamedArg list) 
	   => Absyn.Class =

   rule	(* No annotation element found in class *)
	 get_public_list(parts) => publst &
	 not get_element_annotation_in_elements(publst) => _ &
	 annotation_list_to_absyn(nargs) => annotation &
	 add_to_public(cdef,Absyn.ANNOTATIONITEM(annotation)) => cdef' 
	 ------------------------------------------------------------
	 add_class_annotation_to_class(cdef as Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_),nargs) => cdef'

   rule	get_public_list(parts) => publst &
	 get_element_annotation_in_elements(publst) => Absyn.ANNOTATIONITEM(oldann) &
	 annotation_list_to_absyn(nargs) => newann &
	 merge_annotations(oldann,newann) => newann' &
	 replace_element_annotation_in_elements(publst,newann') => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 --------------------------------
	 add_class_annotation_to_class(cdef as Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info),nargs)
	 => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)
end


 (**relation: replace_element_annotation_in_elements
  *
  * Thisrelation takes an element list and replaces the first annotation 
  ** with the one given as argument.
  **)
relation replace_element_annotation_in_elements: (Absyn.ElementItem list,
						   Absyn.Annotation)
	   => Absyn.ElementItem list =

  axiom	replace_element_annotation_in_elements(Absyn.ANNOTATIONITEM(_)::xs,a) 
	   => Absyn.ANNOTATIONITEM(a)::xs

   rule	replace_element_annotation_in_elements(xs,a2) => res
	 -----------------------
	 replace_element_annotation_in_elements(a::xs,a2) 
	   => a::res

   axiom	replace_element_annotation_in_elements([],_) => []
end


 (**relation: get_element_annotation_in_elements
  **
  ** Thisrelation retrieves the forst Annotation among the elements 
  ** taken as argument
  **)
relation get_element_annotation_in_elements: (Absyn.ElementItem list) 
	   => Absyn.ElementItem =

  axiom	get_element_annotation_in_elements((a as Absyn.ANNOTATIONITEM(_))::xs) => a

   rule	get_element_annotation_in_elements(xs) => a
	 -------------------------------------------
	 get_element_annotation_in_elements(_::xs) => a
end


 (**relation: merge_annotations
  **
  ** Thisrelation takes an old annotation as first argument and a new 
  ** annotation as  second argument and merges the two.
  ** Annotation "parts" that exist in both the old and the new annotation 
  ** will be changed according to the new definition. For instance,
  ** merge_annotations(annotation(x=1,y=2),annotation(x=3)) 
  ** => annotation(x=3,y=2)
  **)
relation merge_annotations:(Absyn.Annotation, Absyn.Annotation) 
	  => Absyn.Annotation =

   rule	not remove_modification_in_elementargs(eltargs,cr) => _ &
	 merge_annotations(Absyn.ANNOTATION(oldrest),Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(neweltargs) 
	   ----------------------------
	 merge_annotations(Absyn.ANNOTATION((mod as Absyn.MODIFICATION(_,_,cr,_,_))::oldrest),
			   Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(mod::neweltargs)

   rule	remove_modification_in_elementargs(eltargs,cr) => eltargs' &
	 merge_annotations(Absyn.ANNOTATION(oldrest),Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(neweltargs) 
	 -----------------------------------------------------------------------
	 merge_annotations(Absyn.ANNOTATION((mod as Absyn.MODIFICATION(_,_,cr,_,_))::oldrest),
			   Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(neweltargs)

   axiom	merge_annotations(Absyn.ANNOTATION([]),a) => a
end


 (**relation: remove_modification_in_elementargs
  **
  ** Thisrelation removes the class modification named by the second argument.
  ** If no such class modification is found therelation fails.
  ** Currently, only identifiers are allowed as class modifiers, 
  ** i.e. a(...) and not a.b(...)
  **)
relation remove_modification_in_elementargs:(Absyn.ElementArg list, 
					      Absyn.ComponentRef )
	 => Absyn.ElementArg list = 

   rule	id = id2 
	 ---------------------------------------------
	 remove_modification_in_elementargs([Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_)],cr as Absyn.CREF_IDENT(id2,_))
	   => []
   rule	not id = id2 
	 ---------------------------------------------
	 remove_modification_in_elementargs([(m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))],cr as Absyn.CREF_IDENT(id2,_))
	   => fail

   rule	id = id2 &
	 remove_modification_in_elementargs(xs,cr) => res 
	 ---------------------------------------------
	 remove_modification_in_elementargs(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_)::xs,cr as Absyn.CREF_IDENT(id2,_))
	   => res
   rule	not id = id2 &
	 remove_modification_in_elementargs(xs, cr) => res 
	 ---------------------------------------------
	 remove_modification_in_elementargs((m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))::xs,cr as Absyn.CREF_IDENT(id2,_))
	   => m::res

   rule	remove_modification_in_elementargs(xs, cr) => res 
	 ---------------------------------------------
	 remove_modification_in_elementargs((m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))::xs,cr as Absyn.CREF_IDENT(id2,_))
	   => m::res 
end


(**relation: get_inheritance_count
 **
 ** Thisrelation takes a `ComponentRef' and a `Program' and returns the 
 ** number of inherited classes in the class referenced by the 
 ** `ComponentRef'.
 **)
relation get_inheritance_count: (Absyn.ComponentRef,Absyn.Program) => int = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &

	 count_base_classes(cdef) => count
	 -------------------------------------------------
	 get_inheritance_count( model,p) => count

  axiom	get_inheritance_count (_,_) => 0
end


(**relation: get_inheritance_count
 ** Thisrelation takes a `ComponentRef' and a `Program' and returns the 
 ** number of inherited classes in the class referenced by the `ComponentRef'.
 **)
relation get_nth_inherited_class: (Absyn.ComponentRef,int,Absyn.Program) 
	  => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,modelpath,false) 
	   => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	   get_nth_inherited_class2(c,cdef,n,env') => str 
	 -------------------------------------------------
	 get_nth_inherited_class( model,n,p) => str

	(* if above fails, baseclass not defined. return its name*)
  rule	
	
	-------------------------
	get_nth_inherited_class(model,n,p) => "Error"
	
  axiom	get_nth_inherited_class (_,_,_) => "Error"
end


(**relation: get_nth_inherited_class2
 **
 ** Helperrelation to get_nth_inherited_class.
 **)
relation get_nth_inherited_class2: (SCode.Class, Absyn.Class,int, Env.Env) 
	   => string =

   rule	(* First try without instantiating, if class is in parents*)
	 get_base_classes(cdef,env) => lst &  
	 int_sub(n,1) => n' &
	 list_nth(lst,n') => cref &
	 Absyn.cref_to_path(cref) => path &
	 Absyn.path_string(path) => str
	 -----------------------
	 get_nth_inherited_class2(c as SCode.CLASS(_,_,_,_,_),cdef,n,env)
	   => str

   rule	(* If that fails, instantiate, which takes more time*)
	 Env.open_scope(env,encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,Connect.empty_set,ci_state,c,false,[]) 
	   => (env'',_) &
	 get_base_classes(cdef,env'') => lst &  
	 int_sub(n,1) => n' &
	 list_nth(lst,n') => cref &
	 Absyn.cref_to_path(cref) => path &
	 Absyn.path_string(path) => str
	 --------------------------
	 get_nth_inherited_class2(c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	   => str
end


 (**relation: get_component_count
  **
  ** Thisrelation takes a `ComponentRef' and a `Program' and returns the 
  ** number of public components in the class referenced by the `ComponentRef'.
  **)
relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int = 

   rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_components(cdef) => count
	-------------------------------------------------
	get_component_count( model,p) => count
end


 (**relation: count_components
  **
  ** Thisrelation takes a `Class' and returns the number of components 
  ** in that class
  **)
relation count_components: Absyn.Class => int =

   rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info) => c1 &
	 count_components_in_elts(elt) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file_info) 
	     => res

   rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info) => c1 &
	 count_components_in_elts(elt) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt),file_info) 
	     => res
   rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info) => res
	 -----------------------------------------------------
	 count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file_info) => res

   axiom count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],_),_) => 0
   axiom count_components Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(_,_,_,_,_),_) => -1
end


(**relation: count_components_in_elts
 **
 ** Helperrelation to count_components
 **) 
relation count_components_in_elts: Absyn.ElementItem list => int =

   rule	count_components_in_elts(lst) => c1 &
	 list_length(complst) => ncomps &
	 int_add(c1,ncomps) => res
	 --------------------------
	 count_components_in_elts(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,complst),_,NONE))::lst) => res

   rule	count_components_in_elts(lst) => res
	 ----------------------------
	 count_components_in_elts(_::lst) => res

   axiom	count_components_in_elts([]) => 0
end


 (**relation: get_nth_component
  **
  ** Thisrelation takes a `ComponentRef', a `Program' and an int and 
  ** returns a comma separated string of names containing the name, type 
  ** and comment of that component.
  **)
relation get_nth_component: (Absyn.ComponentRef,Absyn.Program, int) 
	  => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,modelpath,false) 
	   => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_component2(c,cdef,n,env') => str 
	 -------------------------------------------------
	 get_nth_component( model,p,n) => str

	 axiom get_nth_component(_,_,_) => "Error"
end


(**relation: get_nth_component2
 **
 ** Helperrelation to get_nth_component.
 **)
relation get_nth_component2: (SCode.Class,Absyn.Class, int, Env.Env) 
	   => string =


  rule	Env.open_scope(env,encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,Connect.empty_set,ci_state,c,false,[]) 
	   => (env'',_) &
	 get_nth_component_in_class(cdef,n) => comp &
	 get_component_info_old (comp,env'') => [s1] &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str
	 --------------------------
	 get_nth_component2 (c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	   => str
   rule	print "get_nth_component2 failed\n" 
	 -----------------------
	 get_nth_component2(_,_,_,_) => fail

end


 (**relation: get_components
  **
  ** Thisrelation takes a `ComponentRef', a `Program' and an int and  returns 
  ** a list of all components, as returned by get_nth_component.
  **)
relation get_components: (Absyn.ComponentRef,Absyn.Program) => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,modelpath,false) 
	   => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	 Env.open_scope(env',encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,Connect.empty_set,ci_state,c,false,[]) 
	   => (env'',_) &
	 get_public_components_in_class(cdef) => comps1 &
	 get_components_info (comps1,"\"public\"",env'') => s1 &
	 get_protected_components_in_class(cdef) => comps2 &
	 get_components_info(comps2,"\"protected\"",env'') => s2 &
	 Util.string_delimit_list_no_empty([s1,s2],",") => str &
	 Util.string_append_list(["{",str,"}"]) => res
	 -------------------------------------------------
	 get_components(model,p) => res

	 axiom get_components(_,_) => "Error"
end


 (**relation: get_component_annotations
  **
  ** Thisrelation takes a `ComponentRef', a `Program' and
  ** returns a list of all component annotations, as returned by 
  ** get_nth_component_annotation.
  ** Both public and protected components are returned, but they need to
  ** be in the same order as get_componentsrelations, i.e. first public 
  ** components then protected ones.
  **)
relation get_component_annotations: (Absyn.ComponentRef,
				       Absyn.Program) 
	   => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_public_components_in_class(cdef) => comps1 &
	 get_protected_components_in_class(cdef) => comps2 &
	 list_append(comps1,comps2) => comps &
	 get_component_annotations_from_elts(comps) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str
	 -------------------------------------------------
	 get_component_annotations( model,p) => str

	 axiom get_component_annotations(_,_) => "Error"
end


 (**relation: get_nth_component_annotation
  **
  ** Thisrelation takes a `ComponentRef', a `Program' and an int and  
  ** returns a comma separated string of values corresponding to the flat 
  ** record for component annotations.
  **)
relation get_nth_component_annotation: (Absyn.ComponentRef,Absyn.Program,int) 
	  => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_component_in_class(cdef,n) => comp &
	 get_component_annotation(comp) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str
	 ---------------------------------------------- 
	 get_nth_component_annotation( model,p,n) => str

	 axiom get_nth_component_annotation(_,_,_) => "Error"
end


(**relation: get_nth_component_modification
 **
 ** Thisrelation takes a `ComponentRef', a `Program' and an int and 
 ** returns a comma separated string of values corresponding to the 
 ** flat record for component annotations.
 **)
relation get_nth_component_modification: (Absyn.ComponentRef,Absyn.Program, int) 
	   => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_component_in_class(cdef,n) => comp &
	 get_component_modification(comp) => str &
	 Util.string_append_list(["{",str,"}"]) => str'
	 ---------------------------------------------- 
	 get_nth_component_modification( model,p,n) => str'

	 axiom get_nth_component_modification(_,_,_) => "Error"
end


(**relation: get_connection_count
 **
 ** Thisrelation takes a `ComponentRef' and a `Program' and returns a 
 ** string containing the number of connections in the model identified by 
 ** the `ComponentRef'.
 **)
relation get_connection_count: (Absyn.ComponentRef, Absyn.Program) => string =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_connections cdef => numconn &
	int_string numconn => res
	-------------------------
	get_connection_count (model,p) => res
	
  axiom get_connection_count(_,_) => "Error"
end


(**relation: get_nth_connection
 **
 ** Thisrelation takes a `ComponentRef' and a `Program' and an int and 
 ** returns a comma separated string for the nth connection, e.g. "R1.n,C.p".
 **)		 
relation get_nth_connection: (Absyn.ComponentRef, Absyn.Program, int) 
	  => string =

   rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => Absyn.EQUATIONITEM(eq,cmt) &
	get_string_comment(cmt) => str2 &
	get_connection_str eq => str &
	Util.string_append_list(["{",str,", ",str2,"}"]) => res
	----------------------------
	get_nth_connection (model,p,n) => res
	
  axiom get_nth_connection(_,_,_) => "Error"
end


(**relation: get_string_comment
 **
 ** Returns the string comment or empty string from a Comment option.
 **)
relation get_string_comment:( Absyn.Comment option) => string =

  rule	get_string_comment2(cmt) => s &
	Util.string_append_list(["\"",s,"\""]) => res
	-----------------
	get_string_comment(cmt) => res
end

relation get_string_comment2: ( Absyn.Comment option) => string =

  axiom	get_string_comment2(SOME(Absyn.COMMENT(_,SOME(str)))) => str 

  axiom	get_string_comment2(_) => ""
end

(**relation: add_connection
 **
 ** Adds a connect equation to the model, i..e connect(c1,c2)
 **
 ** inputs: (Absyn.ComponentRef, /* model name */
             Absyn.ComponentRef, /* c1 */
             Absyn.ComponentRef, /* c2 */
             Absyn.NamedArg list, /* annotations */
             Absyn.Program) => 
 ** outputs: (string, Absyn.Program)
 **)
relation add_connection: (Absyn.ComponentRef, 
			   Absyn.ComponentRef, 
			   Absyn.ComponentRef, 
			   Absyn.NamedArg list,
			   Absyn.Program) => 
	 (string, Absyn.Program) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_IDENT(_,_),c1,c2,[],p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.strip_last(modelpath) => package &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],Absyn.WITHIN(package)),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_QUAL(_,_,_),c1,c2,[],p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 annotation_list_to_absyn_comment(nargs,NONE) => cmt &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),cmt))
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_IDENT(_,_),c1,c2,nargs,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.strip_last(modelpath) => package &
	 annotation_list_to_absyn_comment(nargs,NONE) => cmt &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),cmt)) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],Absyn.WITHIN(package)),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_QUAL(_,_,_),c1,c2,nargs,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)	
end


(**relation: delete_connection
 **
 ** Delete the connection connect(c1,c2) from a model.
 **
 ** inputs:  (Absyn.ComponentRef, /* model name */
              Absyn.ComponentRef, /* c1 */
              Absyn.ComponentRef, /* c2 */
              Absyn.Program)
 ** outputs:  (string,Absyn.Program) 
 **)
relation delete_connection: (Absyn.ComponentRef, 
			      Absyn.ComponentRef, 
			      Absyn.ComponentRef, 
			      Absyn.Program)
	   => (string,Absyn.Program) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_equation_in_class(cdef,c1,c2) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	 ---------------------------------------------------
	 delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_equation_in_class(cdef,c1,c2) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ---------------------------------------------------
	 delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   axiom	delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Error",p)	
end


(**relation: delete_equation_in_class
 **
 ** Helperrelation to delete_connection.
 **)
relation delete_equation_in_class: (Absyn.Class, 
				     Absyn.ComponentRef, 
				     Absyn.ComponentRef)
	   => Absyn.Class =  

   rule	get_equation_list(parts) => eqlst &
	 delete_equation_in_eqlist(eqlst,c1,c2) => eqlst' &
	 replace_equation_list(parts,eqlst') => parts2 
	 ----------------------------
	 delete_equation_in_class(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info),c1,c2)
	   => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)
end


(**relation: delete_equation_in_eqlist
 **
 ** Helperrelation to delete_connection.
 **)
relation delete_equation_in_eqlist: (Absyn.EquationItem list, Absyn.ComponentRef,Absyn.ComponentRef) => Absyn.EquationItem list =

   axiom	delete_equation_in_eqlist([],_,_) => []

   rule	Absyn.cref_to_path(c1) => p1 & Absyn.path_string(p1) => s1 &
	 Absyn.cref_to_path(c2) => p2 & Absyn.path_string(p2) => s2 &
	 Absyn.cref_to_path(cn1) => pn1 & Absyn.path_string(pn1) => sn1 &
	 Absyn.cref_to_path(cn2) => pn2 & Absyn.path_string(pn2) => sn2 &
	 s1 = sn1 & s2 = sn2 &
	 delete_equation_in_eqlist(xs,c1,c2) => res
	 ---------------------
	 delete_equation_in_eqlist(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(cn1,cn2),_)::xs,c1,c2) => res

   rule	delete_equation_in_eqlist(xs,c1,c2) => res
	 ------------------------------------
	 delete_equation_in_eqlist(x::xs,c1,c2) => x::res
end

(**relation: set_component_comment
 ** author :PA
 **
 ** Sets the component commment given by class name and ComponentRef.
 **)
relation set_component_comment: (Absyn.ComponentRef,
				  Absyn.ComponentRef,
				  string,
				  Absyn.Program)
	  => (string, Absyn.Program) =

  rule	Absyn.cref_to_path(class) => p_class &
	build_within(p_class) => within &
	get_pathed_class_in_program(p_class,p) => cdef &
	set_component_comment_in_class(cdef,cr1,cmt) => cdef' &
	update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	----------------------------------------
	set_component_comment(class,cr1,cmt,p) => ("Ok",newp)

  axiom	set_component_comment(class,cr1,cmt,p) => ("Error",p)

end

(**relation: set_component_comment_in_class
 ** author: PA
 ** 
 ** Helperrelation to set_component_comment. 
 **)
relation set_component_comment_in_class: (Absyn.Class, 
					   Absyn.ComponentRef,
					   string) 
	  => Absyn.Class =


  rule	set_component_comment_in_parts(parts,cr1,cmt) => parts'
	-------------------------------
	set_component_comment_in_class(Absyn.CLASS(name,p,f,e,restr,
						    Absyn.PARTS(parts,pcmt),info),
					cr1,cmt)
	  => Absyn.CLASS(name,p,f,e,restr,Absyn.PARTS(parts',pcmt),info)
	  
end

(**relation: set_component_comment_in_parts
 ** author: PA
 ** 
 ** Helperrelation to set_component_comment_in_class.
 **)
relation set_component_comment_in_parts:(Absyn.ClassPart list,
					   Absyn.ComponentRef,
					   string)
	  => Absyn.ClassPart list =

  rule	set_component_comment_in_elementitems(elts,cr1,cmt) => elts' 
	-----------------------------------------------
	set_component_comment_in_parts(Absyn.PUBLIC(elts)::xs,cr1,cmt)
	  => Absyn.PUBLIC(elts')::xs

	  (* rule above failed *)
  rule	set_component_comment_in_parts(xs,cr1,cmt) => xs'
	-------------------------------
	set_component_comment_in_parts(Absyn.PUBLIC(e)::xs,cr1,cmt)
	  => (Absyn.PUBLIC(e)::xs')

  rule	set_component_comment_in_elementitems(elts,cr1,cmt) => elts' 
	-----------------------------------------------
	set_component_comment_in_parts(Absyn.PUBLIC(elts)::xs,cr1,cmt)
	  => Absyn.PROTECTED(elts')::xs

	  (* rule above failed *)
  rule	set_component_comment_in_parts(xs,cr1,cmt) => xs'
	-------------------------------
	set_component_comment_in_parts(Absyn.PUBLIC(e)::xs,cr1,cmt)
	  => (Absyn.PROTECTED(e)::xs')

  rule	set_component_comment_in_parts(xs,cr1,cmt) => xs'
	-------------------------------------------
	set_component_comment_in_parts(p::xs,cr1,cmt) => p::xs'
end

(**relation: set_component_comment_in_elementitems
 ** author: PA
 ** 
 ** Helperrelation to set_component_parts. 
 **)
relation set_component_comment_in_elementitems: (Absyn.ElementItem list,
						 Absyn.ComponentRef,
						 string)
	=> Absyn.ElementItem list =
 
  rule	set_component_comment_in_elementspec(spec,cr1,cmt) => spec'
	----------------------
	set_component_comment_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(f,r,inout,n,spec,info,constr))::es,cr1,cmt) 
	  => Absyn.ELEMENTITEM(Absyn.ELEMENT(f,r,inout,n,spec',info,constr))::es

  rule	set_component_comment_in_elementitems(es,cr1,cmt) => es'
	----------------------
	set_component_comment_in_elementitems(e::es,cr1,cmt) 
	  => e::es'
end

(**relation: set_component_comment_in_elementspec
 ** author: PA
 ** 
 ** Helperrelation to set_component_elementitems. 
 **)
relation set_component_comment_in_elementspec: (Absyn.ElementSpec,
						 Absyn.ComponentRef,
						 string) 
	=> Absyn.ElementSpec =

  rule	set_component_comment_in_compitems(citems,cr,cmt) => citems' 
	-----------------------------
	set_component_comment_in_elementspec(Absyn.COMPONENTS(attr,tp,citems)
					     ,cr,cmt) 
	  => Absyn.COMPONENTS(attr,tp,citems')
end

(**relation: set_component_comment_in_compitems
 ** author: PA
 ** 
 ** Helperrelation to set_component_elementspec. 
 **)
relation set_component_comment_in_compitems: (Absyn.ComponentItem list,
					      Absyn.ComponentRef,
					      string) 
	  => Absyn.ComponentItem list =

  rule	Absyn.cref_equal(Absyn.CREF_IDENT(id,[]),cr) => true &
	set_class_comment_in_comment_opt(compcmt,cmt) => compcmt'
	--------------------------
	set_component_comment_in_compitems(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad,mod),cond,compcmt)::cs,cr,cmt)
	  => Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad,mod),cond,compcmt')::cs

  rule	set_component_comment_in_compitems(cs,cr,cmt) => cs' 
	--------------------------
	set_component_comment_in_compitems(c::cs,cr,cmt)
	  => c::cs'
end


(**relation: set_connection_comment
 ** author: PA
 **
 ** Sets the nth connection comment.
 **)
relation set_connection_comment: (Absyn.ComponentRef, 
				  Absyn.ComponentRef,
				  Absyn.ComponentRef, 
				  string, 
				  Absyn.Program)
	  => (Absyn.Program, string) =

  rule	Absyn.cref_to_path(class) => p_class &
	build_within(p_class) => within &
	get_pathed_class_in_program(p_class,p) => cdef &
	set_connection_comment_in_class(cdef,cr1,cr2,cmt) => cdef' &
	update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	-----------------------------
	set_connection_comment(class,cr1,cr2,cmt,p)
	  => (newp,"Ok")
	
  axiom	set_connection_comment(_,_,_,_,p) => (p,"Error")

end

(**relation: set_connection_comment_in_class
 ** author: PA
 **
 ** Sets a connection comment in a Absyn.Class given two Absyn,ComponentRef
 **)
relation set_connection_comment_in_class: (Absyn.Class, 
					   Absyn.ComponentRef,
					   Absyn.ComponentRef, 
					   string) 
	  => Absyn.Class =


  rule	set_connection_comment_in_parts(parts,cr1,cr2,cmt) => parts'
	-------------------------------
	set_connection_comment_in_class(Absyn.CLASS(name,p,f,e,restr,
						    Absyn.PARTS(parts,pcmt),info),
					cr1,cr2,cmt)
	  => Absyn.CLASS(name,p,f,e,restr,Absyn.PARTS(parts',pcmt),info)
	  
end

(**relation: set_connection_comment_in_parts
 ** author: PA
 **
 ** Helperrelation to set_connection_comment_in_class.
 **)
relation set_connection_comment_in_parts:(Absyn.ClassPart list,
					   Absyn.ComponentRef,
					   Absyn.ComponentRef,  
					   string)
	  => Absyn.ClassPart list =

  rule	set_connection_comment_in_equations(e,cr1,cr2,cmt) => e' 
	-----------------------------------------------
	set_connection_comment_in_parts(Absyn.EQUATIONS(e)::xs,cr1,cr2,cmt)
	  => Absyn.EQUATIONS(e')::xs

	  (* rule above failed *)
  rule	set_connection_comment_in_parts(xs,cr1,cr2,cmt) => xs'
	-------------------------------
	set_connection_comment_in_parts(Absyn.EQUATIONS(e)::xs,cr1,cr2,cmt)
	  => (Absyn.EQUATIONS(e)::xs')

  rule	set_connection_comment_in_parts(xs,cr1,cr2,cmt) => xs'
	-------------------------------------------
	set_connection_comment_in_parts(p::xs,cr1,cr2,cmt) => p::xs'
end

(**relation: set_connection_comment_in_equations
 ** author: PA
 **
 ** Helperrelation to set_connection_comment_in_parts
 **)
relation set_connection_comment_in_equations: (Absyn.EquationItem list , 
					       Absyn.ComponentRef,
					       Absyn.ComponentRef,
					       string) 
	  => Absyn.EquationItem list =

  rule	Absyn.cref_equal(cr1,c1) => true &
	Absyn.cref_equal(cr2,c2) => true &
	set_class_comment_in_comment_opt(eqcmt,cmt) => eqcmt' 
	---------------------------------------------
	set_connection_comment_in_equations(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),eqcmt)::es,cr1,cr2,cmt)
	  => Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),eqcmt')::es

  rule	set_connection_comment_in_equations(es,cr1,cr2,cmt) => es' 
	---------------------------------------------
	set_connection_comment_in_equations(e::es,cr1,cr2,cmt)
	  => e::es'
end


(**relation: get_nth_connection_annotation
 **
 ** Thisrelation takes a `ComponentRef' and a `Program' and an int and 
 ** returns a comma separated string  of values for the annotation of the 
 ** nth connection.
 **)
relation get_nth_connection_annotation: (Absyn.ComponentRef,Absyn.Program,int) 
	  => string =
	
   rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => citem &
	get_connection_annotation_str (citem) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	--------------
	get_nth_connection_annotation(model,p,n) => str
	
  axiom	get_nth_connection_annotation(_,_,_) => "{}"
end


(**relation: get_connector_count
 **
 ** Thisrelation takes a ComponentRef and a Program and returns the number
 ** of connector components in the class given by the classname in the 
 ** ComponentRef. A partial instantiation of the inheritance structure is 
 ** performed in order to find all connectors of the class.
 **
 ** inputs:  (/* Env.Env, */ Absyn.ComponentRef, 
              Absyn.Program) 
 ** outputs: string
 **)
relation get_connector_count: (Absyn.ComponentRef, 
                               Absyn.Program) 
	  => string =

  rule	(** A complete instantiation is far too expensive. Instead we only 
	 ** look through the components of the class for types declared using 
	 ** the "connector" restricted class keyword. We also look in
	 ** base classes  (recursively)  
	 **)
	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_public_connectors(modelpath,p,cdef) => count &
	int_string(count) => countstr
	-------------------
	get_connector_count (model,p) => countstr
	
  axiom get_connector_count(_,_) => "Error"
end


(**relation: get_nth_connector
 ** Thisrelation takes a ComponentRef and a Program and an int and returns 
 ** a string with the name of the nth
 ** connector component in the class given by ComponentRef in the Program.
 **)		 
relation get_nth_connector: (Absyn.ComponentRef, Absyn.Program, int) 
	  => string =

  rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_public_connector_str(modelpath,cdef,p,n) => (str,tp) &
	 Absyn.path_string tp => tpstr &
	 string_append(str,",") => s1 &
	 string_append(s1,tpstr) => resstr
	 -----------------
	 get_nth_connector(model,p,n)=> resstr

   axiom get_nth_connector(_,_,_) => "Error"
end


 (**relation: get_nth_connector
  **
  ** Thisrelation takes a ComponentRef and a Program and an int and returns 
  ** a string with the name of the nth connectors icon annotation in the 
  ** class given by ComponentRef in the Program.
  **)
relation get_nth_connector_icon_annotation: (Absyn.ComponentRef, 
					     Absyn.Program, int) 
	  => string =

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_public_connector_str(modelpath,cdef,p,n) => (resstr,tp) &
	 get_icon_annotation(tp,p) => resstr
	 --------------------------
	 get_nth_connector_icon_annotation(model,p,n)=> resstr

   axiom get_nth_connector_icon_annotation(_,_,_) => "Error"	
end


(**relation: get_diagram_annotation
 **
 ** Thisrelation takes a Path and a Program and returns a comma separated 
 ** string of values for the diagram annotation for the class named by the 
 ** first argument.
 **)
relation get_diagram_annotation: (Absyn.Path, Absyn.Program) => string =
	 
   rule	get_pathed_class_in_program (modelpath,p) => cdef &
	get_diagram_annotation_in_class(cdef) => str
	 ---------------------------
	 get_diagram_annotation(modelpath,p) => str
	 
  axiom	get_diagram_annotation(_,_) => "get_diagram_annotation failed!"
end


(**relation: get_icon_annotation
 ** Thisrelation takes a Path and a Program and returns a comma separated
 ** string of values for the icon annotation for the class named by the 
 ** first argument. 	
 **)
relation get_icon_annotation: (Absyn.Path, Absyn.Program) => string =

    rule	get_pathed_class_in_program(modelpath,p) => cdef &
	 get_icon_annotation_in_class(cdef) => str
	 -----------------------------------------
	 get_icon_annotation(modelpath,p) => str
   axiom get_icon_annotation(_,_) => ""
end


 (**relation: get_packages_in_path
  **
  ** Thisrelation takes a Path and a Program and returns a list of the 
  ** names of the packages found in the Path.
  **)
relation get_packages_in_path: (Absyn.Path,Absyn.Program) => string =

   rule	get_pathed_class_in_program(modelpath,p) => cdef &
	 get_packages_in_class(modelpath,p,cdef) => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 ----------------------
	 get_packages_in_path (modelpath,p) => res
   axiom	 get_packages_in_path(_,_) => "Error"
end


 (**relation: get_top_packages 
  **
  ** Thisrelation takes a Path and a Program and returns a list of the 
  ** names of the packages found in the Path.
  **)
relation get_top_packages: (Absyn.Program) => string =

   rule	get_top_packages_in_program(p) => strlist &
	 Util.string_delimit_list(strlist,",") => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 -------------------------
	 get_top_packages(p) => res

   axiom	get_top_packages(_) => "Error"
end


(**relation: get_top_packages_in_program
 **
 ** Helperrelation to get_top_packages.
 **)
relation get_top_packages_in_program: Absyn.Program => string list =

   axiom	get_top_packages_in_program Absyn.PROGRAM([],_) => []

   rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	 -----------------------------------------
	 get_top_packages_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,Absyn.R_PACKAGE,_,_)::rest,w)) => id::res

   rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	 ------------------------------------------
	 get_top_packages_in_program (Absyn.PROGRAM(_::rest,w)) => res
end


 (**relation: get_packages_in_class
  **
  ** Thisrelation takes a `Class' definition and a Path identifying 
  ** the class. It returns a string containing comma separated package
  ** names found in the class definition.
  **)
relation get_packages_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) 
	  => string =

   rule	get_packages_in_parts(parts) => strlist &
	 Util.string_delimit_list(strlist,",") => res
	 -------------------------------------
	 get_packages_in_class(_,_,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,cmt),_)) => res

   rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	 get_packages_in_class(newpath,p,cdef) => res 
	 --------------------------------------------
	 get_packages_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_),_)) => res
end


(**relation: get_packages_in_parts
 **
 ** Helperrelation to get_packages_in_class.
 **)
relation get_packages_in_parts:(Absyn.ClassPart list ) => string list =

  axiom	get_packages_in_parts [] => []
	 
  rule	get_packages_in_elts(elts) => l1 &
	 get_packages_in_parts(rest) => l2 &
	 list_append(l1,l2) => res
	 -------------------------
	 get_packages_in_parts(Absyn.PUBLIC(elts)::rest) => res	
	 
  rule	get_packages_in_parts(rest) => res
	 -----------------------------------
	 get_packages_in_parts(_::rest) => res
end


(**relation: get_packages_in_elts
 **
 ** Helperrelation to get_packages_in_parts.
 **)
relation get_packages_in_elts: (Absyn.ElementItem list) => string list =
   axiom	 get_packages_in_elts [] => []

   rule	get_packages_in_elts(rest) => res
	 --------------------------------
	 get_packages_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,_,Absyn.R_PACKAGE,_,_)),_,NONE))::rest) => id::res

   rule	get_packages_in_elts(rest) => res
	 --------------------------------
	 get_packages_in_elts (_::rest) => res
end


(**relation: get_classnames_in_path
 **
 ** Return a comma separated list of classes in a given Path.
 **)
relation get_classnames_in_path: (Absyn.Path,Absyn.Program) 
	  => string =

   rule	get_pathed_class_in_program(modelpath,p) => cdef &
	 get_classnames_in_class(modelpath,p,cdef) => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 ----------------------
	 get_classnames_in_path (modelpath,p) => res

  axiom	get_classnames_in_path(_,_) => "Error"
end


 (**relation: get_top_classnames
  **
  ** Thisrelation takes a Path and a Program and returns a list of
  ** the names of the packages found at the top scope.
  **)
relation get_top_classnames: (Absyn.Program) => string =

  rule	get_top_classnames_in_program(p) => strlist &
	 Util.string_delimit_list(strlist,",") => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 -------------------------
	 get_top_classnames(p) => res

  axiom	get_top_classnames(_) => "Error"
end


(**relation: get_top_classnames_in_program
 **
 ** Helperrelation to get_top_classnames.
 **)
relation get_top_classnames_in_program: Absyn.Program => string list =

  axiom	get_top_classnames_in_program Absyn.PROGRAM([],_) => []

  rule	get_top_classnames_in_program (Absyn.PROGRAM(rest,w)) => res 
	-----------------------------------------
	get_top_classnames_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,_,_,_)::rest,w)) => id::res
	
  rule	get_top_classnames_in_program (Absyn.PROGRAM(rest,w)) => res
	------------------------------------------
	get_top_classnames_in_program (Absyn.PROGRAM(_::rest,w)) => res
end


(* adrpo added 2005-12-16 *)
 (**relation: get_top_qualified_classnames
  **
  ** Thisrelation takes a Program and returns a list of
  ** the fully top_qualified names of the packages found at the top scope.
  ** ex. within X.Y class Z -> X.Y.Z;
  **)
relation get_top_qualified_classnames: (Absyn.Program) => string =

  rule	 get_top_qualified_classnames_in_program(p) => strlist &
		 Util.string_delimit_list(strlist,",") => str &
		 string_append("{",str) => s1 &
		 string_append(s1,"}") => res
		 -------------------------
		 get_top_qualified_classnames(p) => res

  axiom	get_top_qualified_classnames(_) => "Error"
end


(* adrpo added 2005-12-16 *)
(**relation: get_top_qualified_classnames_in_program
 **
 ** Helperrelation to get_top_qualified_classnames.
 **)
relation get_top_qualified_classnames_in_program: Absyn.Program => string list =

  axiom	get_top_qualified_classnames_in_program Absyn.PROGRAM([],_) => []

  rule	get_qualified(id, w) => str_path &
  		get_top_qualified_classnames_in_program (Absyn.PROGRAM(rest,w)) => res &
  		list_append([str_path],res) => result        
		-----------------------------------------------------------------------
		get_top_qualified_classnames_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,_,_,_)::rest,w)) => result
	
  rule	get_top_qualified_classnames_in_program (Absyn.PROGRAM(rest,w)) => res
		-------------------------------------------------------------------------
		get_top_qualified_classnames_in_program (Absyn.PROGRAM(_::rest,w)) => res
end


(* adrpo added 2005-12-16 *)
(**relation: get_qualified
 **
 ** Helperrelation to get_top_qualified_classnames_in_program.
 **)
relation get_qualified: (string, Absyn.Within) => string =

  axiom	get_qualified(id, Absyn.TOP) => id

  rule	Absyn.path_string(path) => str_path &
  		string_append(str_path, ".") => str_path1 &
        string_append(str_path1, id) => result
		-----------------------------------------------
		get_qualified(id, Absyn.WITHIN(path)) => result	
end


 (**relation: get_classnames_in_class
  **
  ** Thisrelation takes a `Class' definition and a Path identifying the
  ** class. 
  ** It returns a string containing comma separated package names found 
  ** in the class definition.
  **)
relation get_classnames_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) 
	  => string =

   rule	get_classnames_in_parts(parts) => strlist &
	 Util.string_delimit_list(strlist,",") => res
	 -------------------------------------
	 get_classnames_in_class(_,_,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => res
	 
   rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	 get_classnames_in_class(newpath,p,cdef) => res 
	 --------------------------------------------
	 get_classnames_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_),_)) => res
end


(**relation: get_classnames_in_parts
 ** 
 ** Helperrelation to get_classnames_in_class.
 **)
relation get_classnames_in_parts:(Absyn.ClassPart list ) => string list =

   axiom	get_classnames_in_parts [] => []

   rule	get_classnames_in_elts(elts) => l1 &
	 get_classnames_in_parts(rest) => l2 &
	 list_append(l1,l2) => res
	 -------------------------
	 get_classnames_in_parts(Absyn.PUBLIC(elts)::rest) => res	

   rule	get_classnames_in_parts(rest) => res
	 -----------------------------------
	 get_classnames_in_parts(_::rest) => res
end


(**relation: get_classnames_in_elts
 **
 ** Helperrelation to get_classnames_in_parts.
 **)
relation get_classnames_in_elts: (Absyn.ElementItem list) 
	  => string list =
  
  axiom	 get_classnames_in_elts [] => []

  rule	get_classnames_in_elts(rest) => res
	 --------------------------------
	 get_classnames_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,_,_,_,_)),_,NONE))::rest) => id::res

   rule	get_classnames_in_elts(rest) => res
 	 --------------------------------
	 get_classnames_in_elts (_::rest) => res
end


 (**relation: get_base_classes
  **
  ** Thisrelation gets all base classes of a class, NOT Recursive.
  ** It uses the environment to get the fully qualified names of the classes.
  **)
relation get_base_classes : (Absyn.Class, Env.Env) 
	   => Absyn.ComponentRef list =

   rule	get_base_classes_from_parts(parts, env) => res 
	 -----------------------------------------
	 get_base_classes (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_),env) 
	   => res

  axiom	get_base_classes (_,_) => []
end


(**relation: get_base_classes_from_parts
 **
 ** Helperrelation to get_base_classes.
 **)
relation get_base_classes_from_parts: (Absyn.ClassPart list, Env.Env) 
	   => Absyn.ComponentRef list =

   rule	get_base_classes_from_elts(elts, env) => c1 &
	 get_base_classes_from_parts(rest, env) => c2 &
	 list_append(c1,c2) => res 
	 ----------------------------
	 get_base_classes_from_parts(Absyn.PUBLIC(elts)::rest, env) => res

   rule	get_base_classes_from_parts(rest, env) => res
	 ----------------------------------------
	 get_base_classes_from_parts(_::rest, env) => res

   axiom	get_base_classes_from_parts([], env) => []
end


(**relation: get_base_classes_from_elts
 **
 ** Helperrelation to get_base_classes_from_parts.
 **)
relation get_base_classes_from_elts : (Absyn.ElementItem list, Env.Env) 
	   => Absyn.ComponentRef list =

   axiom	get_base_classes_from_elts([], env) => []

   rule	(* Inherited class is defined inside package *)
	 get_base_classes_from_elts(rest,env) => cl &
	 Lookup.lookup_class(env,path,true) => (c,env') &
	 Env.get_env_path(env') => SOME(envpath) &
	 Absyn.path_last_ident(path) => tpname &
	 Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	 Absyn.path_to_cref(p') => cref
	 ------------------------
	 get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_))::rest, env )
	     => cref::cl

   rule	(* Inherited class defined on top level scope*)
	 get_base_classes_from_elts(rest,env) => cl &
	 Lookup.lookup_class(env,path,true) => (c,env') &
	 Env.get_env_path(env') => NONE &
	 Absyn.path_to_cref(path) => cref
	 --------------------------------
	 get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_))::rest, env )
	     => cref::cl

   rule	get_base_classes_from_elts(rest, env) => cl
	 --------------------------------------
	 get_base_classes_from_elts (_::rest, env) => cl
end


 (**relation: count_base_classes
  **
  ** Thisrelation counts the number of base classes of a class
  **)
relation count_base_classes : (Absyn.Class) 
	   => int =

   rule	count_base_classes_from_parts(parts) => res 
	 -----------------------------------------
	 count_base_classes (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) 
	   => res

   axiom	count_base_classes (_) => 0
end


(**relation: count_base_classes_from_parts
 **
 ** Helperrelation to count_base_classes.
 **)
relation count_base_classes_from_parts: (Absyn.ClassPart list) 
	   => int =

   rule	count_base_classes_from_elts(elts) => c1 &
	 count_base_classes_from_parts(rest) => c2 &
	 int_add(c1,c2) => res
	 ----------------------------
	 count_base_classes_from_parts(Absyn.PUBLIC(elts)::rest) => res

   rule	count_base_classes_from_parts(rest) => res
	 ----------------------------------------
	 count_base_classes_from_parts(_::rest) => res

   axiom	count_base_classes_from_parts([]) => 0
end


(**relation: count_base_classes_from_elts
 **
 ** Helperrelation to count_base_classes_from_parts.
 **)
relation count_base_classes_from_elts : (Absyn.ElementItem list) 
	   => int =

   axiom	count_base_classes_from_elts([]) => 0

   rule	(* Inherited class *)
	 count_base_classes_from_elts(rest) => cl &
	 int_add(cl,1) => res
	 ------------------------
	 count_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_))::rest )
	     => res

   rule	count_base_classes_from_elts(rest) => cl
	 --------------------------------------
	 count_base_classes_from_elts (_::rest) => cl
end


(**relation: get_icon_annotation_in_class
 **
 ** Helperrelation to get_icon_annotation.
 **)
relation get_icon_annotation_in_class : (Absyn.Class) => string =

	
   rule	 (* class definitions *)
	 get_icon_annotation_from_parts(parts) => annlst &
	 get_icon_annotation_str(annlst) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str 
	 ------------------------
	 get_icon_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) 
	   => str	

	   (* short class definitions *)
  rule	get_icon_annotation_str(annlst) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str 
	 ------------------------
	 get_icon_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(_,_,_,_,SOME(Absyn.COMMENT(SOME(Absyn.ANNOTATION(annlst)),_))),_)) => str 
end


(**relation: get_icon_annotation_from_parts
 **
 ** Helperrelation to get_icon_annotation_in_class.
 **)
relation get_icon_annotation_from_parts: Absyn.ClassPart list 
	   => Absyn.ElementArg list =

   axiom	get_icon_annotation_from_parts [] => []

   rule	get_icon_annotation_from_elts(elts) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.PUBLIC(elts)::rest) => res

   rule	get_icon_annotation_from_elts(elts) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.PROTECTED(elts)::rest) => res

   rule	get_icon_annotation_from_eqns(eqns) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.EQUATIONS(eqns)::rest) => res

   rule	get_icon_annotation_from_eqns(eqns) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.INITIALEQUATIONS(eqns)::rest) => 
	 res

   rule	get_icon_annotation_from_algs(algs) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.ALGORITHMS(algs)::rest) => res

   rule	get_icon_annotation_from_algs(algs) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.INITIALALGORITHMS(algs)::rest) => res
   rule	get_icon_annotation_from_parts(rest) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(_::rest) => res
end


(**relation: get_icon_annotation_from_elts
 **
 ** Helperrelation to get_icon_annotation_from_parts.
 **)
relation get_icon_annotation_from_elts: (Absyn.ElementItem list) 
	   => Absyn.ElementArg list =

   rule	contain_icon_annotation(lst)
	 -----------------------------
	 get_icon_annotation_from_elts(Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(lst))::rest)
	   => lst
   rule	get_icon_annotation_from_elts(rest) => res
	 -----------------------------
	 get_icon_annotation_from_elts(_::rest)
	   => res
end


(**relation: contain_icon_annotation
 ** 
 ** Helperrelation to get_icon_annotation_from_elts.
 **)
relation contain_icon_annotation: Absyn.ElementArg list => () =

   axiom	contain_icon_annotation(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),_,_)::_) => ()

   rule	contain_icon_annotation(lst)
	 -----------------------------
	 contain_icon_annotation(_::lst) 
end


(**relation: get_icon_annotation_from_eqns
 **
 ** Helperrelation to get_icon_annotation_from_parts.
 **)
relation get_icon_annotation_from_eqns: (Absyn.EquationItem list) 
	   => Absyn.ElementArg list =

   axiom	get_icon_annotation_from_eqns [] => []

   rule	contain_icon_annotation(lst)
	 --------------------------------------
	 get_icon_annotation_from_eqns(Absyn.EQUATIONITEMANN(Absyn.ANNOTATION(lst))::rest)
	   => lst

   rule	get_icon_annotation_from_eqns(rest) => res
	 --------------------------------------
	 get_icon_annotation_from_eqns(_::rest) => res
end


(**relation: get_icon_annotation_from_algs
 **
 ** Helperrelation to get_icon_annotation_from_parts
 **)
relation get_icon_annotation_from_algs: Absyn.AlgorithmItem list 
	   => Absyn.ElementArg list =

   axiom	get_icon_annotation_from_algs [] => []

   rule	contain_icon_annotation(lst)
	 -----------------------------
	 get_icon_annotation_from_algs(Absyn.ALGORITHMITEMANN(Absyn.ANNOTATION(lst))::rest) 
	 => lst
   rule	get_icon_annotation_from_algs(rest) => res
	 -----------------------------
	 get_icon_annotation_from_algs(_::rest) => res
end


(**relation: get_icon_annotation_str
 **
 ** Helperrelation to get_icon_annotation_in_class.
 **)
relation get_icon_annotation_str: (Absyn.ElementArg list) => string =

  rule	get_annotation_string (Icon_program,Absyn.ANNOTATION([ann])) => str 
	 -----------------------------------------------
	 get_icon_annotation_str ( (ann as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),mod,_))::_) => str

   rule	get_icon_annotation_str (xs) => str
	 -------------------------------
	 get_icon_annotation_str( _::xs) => str
end


(**relation: get_diagram_annotation_in_class
 **
 ** Retrieve the diagram annotation as a string from the class passed as 
 ** argument.
 **)
relation get_diagram_annotation_in_class : (Absyn.Class) => string =
	
   rule	 (* class def. *)
	 get_public_list(parts) => publst &
	 get_protected_list(parts) => protlst &
	 list_append(publst,protlst) => lst &
	 get_diagram_annotation_in_elementitemlist(lst) => str
	 ----------------------------
	 get_diagram_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => str	

   rule	get_diagram_annotation_str(annlst) => str &
	 Util.string_append_list(["{",str,"}"]) => res
	----------------------------
	get_diagram_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(_,_,_,_,SOME(Absyn.COMMENT(SOME(Absyn.ANNOTATION(annlst)),_))),_)) => res

  axiom get_diagram_annotation_in_class (_) => ""
end


(**relation: get_diagram_annotation_in_elementitemlist
 **
 ** Retrieve the diagram annotation from an element item list passed as
 ** argument.
 **)
relation get_diagram_annotation_in_elementitemlist: (Absyn.ElementItem list) => string =

   axiom	get_diagram_annotation_in_elementitemlist [] => ""

   rule	get_diagram_annotation_str(annlst) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str	
	 ----------------------------
	 get_diagram_annotation_in_elementitemlist (Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(annlst))::_) => str

   rule	get_diagram_annotation_in_elementitemlist(xs) => str
	 ------------------------------------------------
	 get_diagram_annotation_in_elementitemlist(_::xs) => str
end


(**relation: get_diagram_annotation_str
 **
 ** Helperrelation to get_diagram_anonotation_in_elementitemlist.
 **)
relation get_diagram_annotation_str: (Absyn.ElementArg list) => string =

  rule	get_annotation_string (Diagram_program,Absyn.ANNOTATION([ann])) => str 
	 -----------------------------------------------
	 get_diagram_annotation_str ( (ann as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Diagram",_),mod,_))::_) => str

   rule	get_diagram_annotation_str (xs) => str
	 -------------------------------
	 get_diagram_annotation_str( _::xs) => str
end


(**relation: get_nth_public_connector_str
 **
 ** Helperrelation to get_nth_connector.
 **)
relation get_nth_public_connector_str: (Absyn.Path, Absyn.Class, Absyn.Program,  int) => (string,Absyn.Path) =

   rule	get_nth_connector_str (p, modelpath, elt, n) => (str,tp)
	------------------------------------------
	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,_),_), p, n)  
	   => (str,tp)

	 (** The rule above failed, count the number of connectors in the first public list, subtract the number 
	  ** and try the rest of the list **)
   rule	count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([Absyn.PUBLIC(elt)],cmt),file_info)) => c1 &
	int_sub(n,c1) => c2 &
	get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info),p,c2) => (str,tp)
	--------------------------------------------------
	get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file_info), p, n) => (str,tp)

   rule	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info), p, n) => (str,tp)
	-----------------------------------------------------
	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file_info), p, n) => (str,tp)

end


 (**relation: get_nth_connector_str
  **
  ** Thisrelation takes an ElementItem list and an int and  returns the name of the nth connector component
  ** in that list. 
  **)
relation get_nth_connector_str: (Absyn.Program, Absyn.Path, Absyn.ElementItem list
				  ,int)
	   => (string, Absyn.Path) =

   rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	 get_nth_public_connector_str(newmodelpath,cdef,p,n) => (str,tp)
	 -----------------
	 get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,NONE))::lst,n) => (str,tp)

   rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	 count_public_connectors(newmodelpath,p,cdef) => c1 &
	 int_sub(n,c1) => c2 &
	 get_nth_connector_str(p,modelpath,lst,c2) => (str,tp)
	 -----------------
	 get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,NONE))::lst,n) => (str,tp) 

   rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_), newmodelpath) &
	 get_nth_compname(complst,n) => str 
	 ----------------------------------
	 get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,NONE))::lst, n) 
	   => (str,tp)

   rule	(** Not so fast, since we lookup and instantiate two times just because this was not 
	  ** the connector we were looking for. **)
	 lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_), newmodelpath) &
	 list_length(complst) => c1 &
	 int_sub(n,c1) => newn &
	 get_nth_connector_str(p,modelpath,lst,newn) => (str,tp)
	 ---------------------------------------
	 get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,NONE))::lst, n)
	   => (str,tp)

   rule	get_nth_connector_str(p,modelpath,lst,n) => (str,tp)
	 ---------------------------------------
	 get_nth_connector_str(p,modelpath,_::lst,n) => (str,tp)

   axiom	get_nth_connector_str(p,modelpath,[],n) => fail
end


(**relation: get_nth_compname
 ** 
 ** Returns the nth component name from a list of ComponentItem's.
 ** Index is from 1..n.
 **)
relation get_nth_compname: (Absyn.ComponentItem list, int) => string =

   axiom	get_nth_compname (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_,_)::lst,1) => id

   rule	int_sub(n,1) => n1 &
	 get_nth_compname (xs, n1) => res
	 --------------------------------
	 get_nth_compname (_::xs,n ) => res
   axiom	get_nth_compname ([],_) => fail
end


(**relation: count_public_connectors
 ** Thisrelation takes a Class and counts the number of connector 
 ** components in the class. This also includes counting in inherited classes.
 **)
relation count_public_connectors: (Absyn.Path, Absyn.Program, Absyn.Class) 
	  => int =

   rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => c1 &
	 count_connectors(modelpath,p,elt) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_public_connectors (modelpath, p,  Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file_info)) 
	     => res

   rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => res
	 -----------------------------------------------------
	 count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file_info)) => res

   axiom count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),file_info)) => 0

   rule	lookup_classdef(cname,modelpath,p) => (cdef,newmodelpath) &
	 count_public_connectors (newmodelpath,p,cdef) => res
	 --------------------------------------------------
	 count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(cname,_,_,_,_),_)) => res
end


(**relation: count_connectors
 **
 ** Thisrelation takes a Path to the current model and a ElementItem list 
 ** and returns the number of connector components in that list.
 **)
relation count_connectors: (Absyn.Path,Absyn.Program,Absyn.ElementItem list) 
	  => int =

   rule	lookup_classdef(tp, modelpath,p) => (cdef,newmodelpath) &
	 count_public_connectors(newmodelpath,p,cdef) => c1 &
	 count_connectors(modelpath,p,lst) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,NONE))::lst) => res

   rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_), newmodelpath) &
	 list_length(complst) => c1 &
	 count_connectors(modelpath,p,lst) => c2 &
	 int_add(c1,c2) => res
	 --------------------
	 count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,NONE))::lst) => res


	 (* Rule above didn't match => element not connector components, try rest of list*)
   rule	count_connectors(modelpath, p, lst) => res 
	 ---------------------
	 count_connectors(modelpath, p, _::lst) => res

   axiom	count_connectors(_, _, []) => 0
end


 (**relation: get_connection_annotation_str
  **
  ** Thisrelation takes an `EquationItem' and returns a comma separated 
  ** string of values  from the flat record of a connection annotation that 
  ** is found in the `EquationItem'.
  **)
relation get_connection_annotation_str: Absyn.EquationItem => string =

   rule	create_funcargs_from_elementargs(elts) => fargs &
	 SCode.elaborate(Line_program) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Static.elab_graphics_exp(env,Absyn.CALL(Absyn.CREF_IDENT("Line",[]),fargs), false (*impl*)) => (newexp,_) &	
	 (* this is to clear the error-msg generated by the annotations. *)
	 Print.clear_error_buf() &
	 Exp.print_exp_str(newexp) => gexpstr 
	 -------------------------------------------------
	 get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_), SOME(Absyn.COMMENT(SOME(Absyn.ANNOTATION([Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Line",_),SOME(Absyn.CLASSMOD(elts,NONE)),_)])),_))))
	   => gexpstr

   axiom	get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),NONE)) => fail

end


(**relation: create_functionargs_from_elementargs
 **
 ** Trasform an ElementArg list to function argments. This is used when
 ** translating a graphical annotation to a record constructor.
 **)
relation create_funcargs_from_elementargs: Absyn.ElementArg list 
	  => Absyn.FunctionArgs =

   axiom	create_funcargs_from_elementargs([]) => Absyn.FUNCTIONARGS([],[])

   rule	create_funcargs_from_elementargs(xs) => Absyn.FUNCTIONARGS(expl,narg)
	 ----------------
	 create_funcargs_from_elementargs(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),SOME(Absyn.CLASSMOD(_,SOME(exp))),_)::xs)
	   => Absyn.FUNCTIONARGS(expl,Absyn.NAMEDARG(id,exp)::narg)

   rule	create_funcargs_from_elementargs(xs) => Absyn.FUNCTIONARGS(expl,narg)
	 ----------------
	 create_funcargs_from_elementargs(_::xs)
	   => Absyn.FUNCTIONARGS(expl,narg)
end


 (**relation: get_nth_connectionitem_in_class
  **
  ** Thisrelation takes a `Class' and  an int ane returns the nth 
  ** `EquationItem' containing a connect statement in that class.
  **)
relation get_nth_connectionitem_in_class: (Absyn.Class, int) => Absyn.EquationItem =

   rule	get_nth_connectionitem_in_classparts(parts,n) => eq
	 -------------------------
	 get_nth_connectionitem_in_class ( Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_),n) => eq
end


(**relation: get_nth_connectionitem_in_classparts
 **
 ** Thisrelation takes a `ClassPart' list and an int and returns 
 ** the nth connections as an `EquationItem'.
 **)
relation get_nth_connectionitem_in_classparts: (Absyn.ClassPart list, int) => Absyn.EquationItem =

   rule	get_nth_connectionitem_in_equations(e,n) => eq
	 -------------------------------------
	 get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

	 (* The rule above failed, subtract the number of connections in the first equation section *)
	 (* and try with the rest of the classparts*)
   rule	count_connections_in_equations(e) => c1 &
	 int_sub(n,c1)=> newn &
	 get_nth_connectionitem_in_classparts(xs,newn) => eq
	 -----------------------------------------------
	 get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

   rule	get_nth_connectionitem_in_classparts(xs,n) => eq
	 --------------------------------------------
	 get_nth_connectionitem_in_classparts(_::xs,n) => eq

end


 (**relation: get_nth_connection_in_equations
  **
  ** Thisrelation takes  an `Equation' list and an int and 
  ** returns the nth connection as an `Equation'. If the number is 
  ** larger than the number of connections in the list, therelation fails.
  **)
relation get_nth_connectionitem_in_equations: (Absyn.EquationItem list, int) => Absyn.EquationItem =

 axiom	get_nth_connectionitem_in_equations ((eq as Absyn.EQUATIONITEM((Absyn.EQ_CONNECT(_,_)),_))::xs,1) => eq

   rule	int_sub (n,1) => newn &
	 get_nth_connectionitem_in_equations (xs,newn) => eq
	 -----------------------------------------------
	 get_nth_connectionitem_in_equations (Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs,n) => eq

   rule	get_nth_connectionitem_in_equations (xs,n) => eq
	 --------------------------------------------
	 get_nth_connectionitem_in_equations (_::xs,n) => eq

   axiom get_nth_connectionitem_in_equations([],_) => fail
end

 (**relation: get_connection_str
  **
  ** Thisrelation takes an `Equation' assumed to contain a connection and 
  ** returns a comma separated string of componentreferences, e.g "R1.n,C.p" 
  ** for  connect(R1.n,C.p).
  **)
relation get_connection_str:  Absyn.Equation => string =

  rule	Absyn.cref_to_path cr1 => p1 &
	 Absyn.cref_to_path cr2 => p2 &
	 Absyn.path_string p1 => s1 &
	 Absyn.path_string p2 => s2 &
	 string_append(s1,",") => s3 &
	 string_append(s3,s2) => str
	 ---------------------------
	 get_connection_str Absyn.EQ_CONNECT(cr1,cr2) => str
end 


(**relation: count_connections
 **
 ** Thisrelation takes a `Class' and returns an int with the number of 
 ** connections in the `Class'.
 **)		 
relation count_connections: Absyn.Class => int =

  rule	count_connections_in_classparts(parts) => count
	 -----------------------------------------------
	 count_connections Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) 
	  => count

  axiom  count_connections Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(_,_,_,_,_),_) => 0
end


 (**relation: count_connections_in_classparts
  **
  ** Thisrelation takes a `ClassPart' list and returns an int with the 
  ** number of connections in that list.
  **)
relation count_connections_in_classparts: Absyn.ClassPart list => int =

   rule	count_connections_in_equations(eqlist) => r1 &
	 count_connections_in_classparts(xs) => r2 &
	 int_add (r1,r2) => res
	 ----------------------
	 count_connections_in_classparts( Absyn.EQUATIONS(eqlist)::xs) => res

   rule	count_connections_in_classparts(xs) => res
	 ------------------------------------------
	 count_connections_in_classparts( _::xs) => res

	 axiom count_connections_in_classparts([]) => 0
end


 (**relation: count_connections_in_equations
  **
  ** Thisrelation takes an `Equation' list and returns  an int 
  ** with the number of connect statements in that list.
  **)
relation count_connections_in_equations: Absyn.EquationItem list => int =

   rule	count_connections_in_equations(xs) => r1 &
	 int_add(r1,1)  => res 
	 ---------------------
	 count_connections_in_equations(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs) => res

   rule	count_connections_in_equations(xs) => res
	 -----------------------------------------
	 count_connections_in_equations(_::xs) => res

   axiom	count_connections_in_equations([]) => 0
end


(**relation: get_component_annotations_from_elts
 **
 ** Helperrelation to get_component_annotations.
 **)
relation get_component_annotations_from_elts: (Absyn.Element list) 
	  => string =

  rule	SCode.elaborate(Placement_program) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	 get_componentitems_annotations(comps,env) => res &
	 Util.string_delimit_list(res,",") => res'
	 ------------------------------------------------
	 get_component_annotations_from_elts(comps) => res'
end


(**relation: get_componentitems_annotations
 **
 ** Helperrelation to get_component_annotations_from_elts
 **)		   
relation get_componentitems_annotations: (Absyn.Element list, Env.Env) 
	   => string list =

  axiom	get_componentitems_annotations([],_) => []

  rule	get_componentitems_annotations_from_items(items,env)
	  => res1 &
	   get_componentitems_annotations(rest,env) => res2 &
	 list_append(res1,res2) => res
	 ------------------------
	 get_componentitems_annotations(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,items),_,_)::rest,env) 
	  => res
  rule	get_componentitems_annotations(rest,env) => res2 &
	 list_append(["{}"],res2) => res
	 ------------------------
	 get_componentitems_annotations(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,_),_,_)::rest,env) 
	  => res
	   
  rule	get_componentitems_annotations(rest,env) => res 
	 ------------------------
	 get_componentitems_annotations(_::rest,env) => res
end


(**relation: get_componentitems_annotations_from_items
 **
 ** Helperrelation to get_componentitems_annotations.
 **)
relation get_componentitems_annotations_from_items: (Absyn.ComponentItem list,
					   Env.Env) 
	   => string list =

   axiom	get_componentitems_annotations_from_items ([],env) => []

  rule	Lookup.lookup_class(env,Absyn.IDENT("Placement"),false) => (c,env') &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false,Absyn.NON_EACH) => mod' &
	 Mod.elab_mod(env',Prefix.NOPRE,mod',false) => mod'' &
	 SCode.class_set_partial(c,false) => c' &
	 Inst.inst_class(env', mod'', Prefix.NOPRE, Connect.empty_set, c',
		 	 [], false,Inst.TOP_CALL) 
 	  => (dae, _, cs, t, state) &
	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => gexpstr &
	 Util.string_append_list(["{",gexpstr,"}"]) => gexpstr' &

	 get_componentitems_annotations_from_items(rest,env) => res
	 -----------------------------------------------
	 get_componentitems_annotations_from_items(Absyn.COMPONENTITEM(_,_,SOME(Absyn.COMMENT(SOME(
		 Absyn.ANNOTATION(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Placement",_),SOME(Absyn.CLASSMOD(mod,NONE)),_)::_)
	 ),_)))::rest,env)
	   => gexpstr'::res

   rule	get_componentitems_annotations_from_items(rest,env) => res 
	 -----------------------
	 get_componentitems_annotations_from_items (Absyn.COMPONENTITEM(_,_,NONE)::(rest as _::_),env) => "{}"::res

   axiom	get_componentitems_annotations_from_items ([Absyn.COMPONENTITEM(_,_,NONE)],env) => ["{}"]

end


(**relation: get_component_annotation
 **
 ** Thisrelation takes an `Element' and returns a comma separated string 
 ** of values corresponding to the flat record for a component annotation. 
 ** If several components are declared within the eleement, a list of values
 ** is given for each of them.
 **) 
relation get_component_annotation: Absyn.Element => string =

   rule	get_componentitems_annotation(lst) => str
	 -----------------------------------------
	 get_component_annotation(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,NONE)) => str
	 axiom get_component_annotation _ => ""
end 


(**relation: get_componentitems_annotation
 **
 ** Helperrelation to get_component_annotation.
 **)
relation get_componentitems_annotation: Absyn.ComponentItem list => string =

   rule	get_annotation_string(Placement_program, Absyn.ANNOTATION(mod)) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"},") => s3 &
	 get_componentitems_annotation(rest) => str &
	 string_append(s3,str) => res
	 ----------------------------
	 get_componentitems_annotation (Absyn.COMPONENTITEM(_,_,SOME(Absyn.COMMENT(SOME(
		 Absyn.ANNOTATION(mod as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Placement",_),_,_)::_)
	 ),_)))::(rest as (_::_))) => res

   rule	get_annotation_string(Placement_program, Absyn.ANNOTATION(mod)) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => res 
	 ----------------------------
	 get_componentitems_annotation ([Absyn.COMPONENTITEM(_,_,SOME(Absyn.COMMENT(SOME(
	 Absyn.ANNOTATION(mod as Absyn.MODIFICATION(_,_, Absyn.CREF_IDENT("Placement",_),_,_)::_)
	 ),_)))]) => res

   rule	get_componentitems_annotation(rest) => str &
	 string_append("{nada},",str) => res
	 -----------------------
	 get_componentitems_annotation (Absyn.COMPONENTITEM(_,_,SOME(Absyn.COMMENT(NONE,_)))::(rest as (_::_))) => res

   rule	get_componentitems_annotation(rest) => str &
	 string_append("{},",str) => res
	 -----------------------
	 get_componentitems_annotation (Absyn.COMPONENTITEM(_,_,NONE)::(rest as (_::_))) => res

   rule	let res = "{}"
	 -----------------------
	 get_componentitems_annotation ([Absyn.COMPONENTITEM(_,_,NONE)]) => res
end


 (**relation: get_component_modification
  **
  ** Thisrelation takes an `Element' and returns a comma separated list of 
  ** Code expression for the modification of the component.
  **)
relation get_component_modification: Absyn.Element => string =

   rule	get_componentitems_modification(lst) => str
	 -----------------------------------------
	 get_component_modification(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,NONE)) => str
	 axiom get_component_modification _ => ""
end


(**relation: get_componentitems_modification
 **
 ** Helperrelation to get_component_modification.
 **)
relation get_componentitems_modification: Absyn.ComponentItem list => string =

   rule	Dump.print_exp_str Absyn.CODE(Absyn.C_MODIFICATION(mod)) => s1 &
	 get_componentitems_modification(rest) => s2 &
	 Util.string_append_list([s1,",",s2]) => res
	 -------------------------------------------
	 get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(mod)),_,_)::(rest as (_::_))) => res

   rule	Dump.print_exp_str Absyn.CODE(Absyn.C_MODIFICATION(mod)) => res
	 -------------------------------------------------------------
	 get_componentitems_modification ([Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(mod)),_,_)]) => res

   rule	get_componentitems_modification(rest) => str &
	 string_append("Code(),",str) => res
	 -----------------------
	 get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,NONE),_,_)::(rest as (_::_))) => res

   rule	get_componentitems_modification(rest) => str &
	 string_append("Code(),",str) => res
	 -----------------------
	 get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,NONE),_,_)::(rest as (_::_))) => res

   rule	let res = "Code()"
	 -----------------------
	 get_componentitems_modification ([Absyn.COMPONENTITEM(_,_,NONE)]) => res
end


 (**relation_ get_annotation_string
  **
  ** Thisrelation takes an annotation and returns a comma separates string 
  ** of values representing the flat record of the specific annotation.
  ** Therelation as two special rules for handling of Icon and Diagram 
  ** annotations since these two contain graphic primitives, which must be
  ** handled specially because Modelica does not have the possibility to store 
  ** polymorphic values (e.g. different record classes with the same baseclass)
  ** in for instance an array.
  **)
relation get_annotation_string: (Absyn.Program,Absyn.Annotation) => string =

   rule	 strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(_,SOME(graphicexp))),_)]) &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false,Absyn.NON_EACH) => mod' &

	 SCode.elaborate(p) => p' &
	 Inst.make_simple_env_from_program(p',Absyn.IDENT("Icon")) => env  & 
	 get_class_in_program("Icon",p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',false) => mod'' &	
	 Inst.inst_class(env, mod'', Prefix.NOPRE, Connect.empty_set, placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _, cs, t, state) &

	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str  &
	 Static.elab_graphics_exp(env,graphicexp,false (*impl*) ) => (graphicexp2,prop) &
	 (* this is to clear the error-msg generated by the annotations. *)
	 Print.clear_error_buf() &

	 Exp.print_exp_str(graphicexp2) => gexpstr &
	 string_append(str,",") => s1 &
	 string_append(s1,gexpstr) => totstr
	 -----------------------------------
	 get_annotation_string(p,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => totstr

	 (* First line in the first rule above fails if return value from strip_graphics_modification doesn't match the rhs of => *)
   rule	 strip_graphics_modification(mod) => (stripmod, gxmods) &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false,Absyn.NON_EACH) => mod' &
	 SCode.elaborate(p) => p' &
	 Inst.make_simple_env_from_program(p',Absyn.IDENT("Icon")) => env  & 
	 get_class_in_program("Icon",p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',true) => mod'' &	
	 Inst.inst_class(env, mod'', Prefix.NOPRE, Connect.empty_set, placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _, cs, t, state) &
	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str 
	 -----------------------------------
	 get_annotation_string(p,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => str


   rule	 strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(_,SOME(graphicexp))),_)]) &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false,Absyn.NON_EACH) => mod' &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("Diagram")) => env  & 
	 get_class_in_program("Diagram",p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',false) => mod'' &
	 Inst.inst_class(env, mod'', Prefix.NOPRE, Connect.empty_set, placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _,cs, t, state) &

	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str  &

	 Static.elab_graphics_exp(env,graphicexp,false (*impl*)) => (graphicexp2,prop) &
	 (* this is to clear the error-msg generated by the annotations. *)
	 Print.clear_error_buf() &
	 Exp.print_exp_str(graphicexp2) => gexpstr &
	 string_append(str,",") => s1 &
	 string_append(s1,gexpstr) => totstr
	 -----------------------------------
	 get_annotation_string(p,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Diagram",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => totstr

   rule	 SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false,Absyn.NON_EACH) => mod' & 
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT(anncname)) => env  & 
	 get_class_in_program(anncname,p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',false) => mod'' &
	 Inst.inst_class(env, mod'', Prefix.NOPRE, Connect.empty_set, placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _, cs, t, state) &
	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str 
	 -----------------------------------------
	 get_annotation_string(p, Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(anncname,_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => str

   rule	 Print.print_buf "get_annotation_string failed!\n"
	 ---------------------------------------
	 get_annotation_string(_,_) => fail
end


 (**relation: strip_graphics_modification
  ** 
  ** Thisrelation strips out the `graphics' modification from an ElementArg 
  ** list and return two lists, one with the other modifications and the 
  ** second with the `graphics' modification
  **)
relation strip_graphics_modification: (Absyn.ElementArg list) => (Absyn.ElementArg list, Absyn.ElementArg list) =

   axiom	strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("graphics",_),_,_))::rest) => (rest, [mod])

   rule	strip_graphics_modification(rest) => (l1,l2) 
	 ------------------------------------------
	 strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,_,_,_))::rest) => (mod::l1,l2)

   axiom	strip_graphics_modification([]) => ([],[])
end


 (**relation: get_components_in_class
  ** 
  ** Both public and protected lists are searched.
  **)
relation get_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

   (* Search in public list *)
   rule	get_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => lst1 &
	 get_components_in_elementitems(elts) => lst2 &
	 list_append(lst2,lst1) => res
	 ------------------------------
	 get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt),file_info)) => res

   (* Search in protected list *)
   rule	get_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt),file_info)) => res

  axiom	get_components_in_class(_) => []
end


 (**relation: get_public_components_in_class
  ** 
  ** Public lists are searched.
  **)
relation get_public_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_public_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

   (* Search in public list *)
   rule	get_public_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	 get_public_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt),file_info)) => res

   rule	get_public_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) 
	  => res
	------------------------------
	get_public_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file_info)) => res

  axiom	get_public_components_in_class(_) => []
end


 (**relation: get_protected_components_in_class
  ** 
  ** Protected lists are searched.
  **)
relation get_protected_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_protected_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

   (* Search in protected list *)
   rule	get_protected_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	 get_protected_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt),file_info)) => res

   rule	get_protected_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) 
	  => res
	------------------------------
	get_protected_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file_info)) => res

  axiom	get_protected_components_in_class(_) => []
end


(**relation: get_components_in_elementitems
 **
 ** Helperrelation to get_components_in_class.
 **)		   
relation get_components_in_elementitems: (Absyn.ElementItem list) 
	   => Absyn.Element list =

   axiom	get_components_in_elementitems([]) => []

   rule	get_components_in_elementitems(rest) => res
	 -------------------------------------------
	 get_components_in_elementitems(Absyn.ELEMENTITEM(elt)::rest) 
	   => elt::res

   rule	get_components_in_elementitems(rest) => res
	 -------------------------------------------
	 get_components_in_elementitems(_::rest) => res
end


(**relation: get_nth_component_in_class
 **
 ** Returns the nth Component of a class. Indexed from 1..n.
 **)
relation get_nth_component_in_class:  (Absyn.Class,int) => Absyn.Element =

   rule	count_components_in_elts(elt) => count &
	 int_le(n,count) => true &
	 get_nth_component_in_elementitems(elt,n) => res
	 -----------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file_info),n) 
	     => res

	     (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	     (* subtract and try next public list *)
   rule	count_components_in_elts(elt) => c1 &
	 int_sub(n,c1) => newn &
	 int_string(newn) => newnstr &
	 int_gt(newn,0) =>  true &
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt),file_info),newn) => res
	 ------------------------------------------------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::rest,cmt),file_info),n) => res

   rule	get_nth_component_in_elementitems(elt,n) => res
	 -----------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt),file_info),n) 
	     => res

	     (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	     (* subtract and try next public list *)
   rule	count_components_in_elts(elt) => c1 &
	 int_sub(n,c1) => newn &
	 int_gt(newn,0) => true &
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt),file_info),newn) => res
	 ------------------------------------------------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::rest,cmt),file_info),n) => res

   rule	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info),n) => res
	 -----------------------------------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file_info),n) => res

   axiom get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),file_info),_) => fail
   axiom get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(_,_,_,_,_),file_info),_) => fail

end


 (**relation: get_elementitems_in_class
  ** 
  ** Both public and protected lists are searched.
  **)
relation get_elementitems_in_class: (Absyn.Class) => Absyn.ElementItem list =

   axiom	 get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

	 (* Search in public list *)
   rule	get_elementitems_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => lst1 &
	 list_append(elts,lst1) => lst 
		 ------------------------------
	     get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt),file_info)) => lst

	 (* Search in protected list *)
   rule	get_elementitems_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file_info)) => lst1 &
	 list_append(elts,lst1) => lst 
	     ------------------------------
	     get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt),file_info)) => lst

   axiom get_elementitems_in_class(_) => []
end


 (**relation: get_nth_component_in_elementintems 
  **
  ** Thisrelation takes an `ElementItem' list and and integer and returns 
  ** the nth component in the list, indexed from 1..n.
  **)
relation get_nth_component_in_elementitems: (Absyn.ElementItem list, int) 
	   => Absyn.Element =

   axiom	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,elt::_),info,i))::_,1) 
	   => Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,[elt]),info,i)

   rule	list_length(lst) => numcomps &
	 int_gt(n,numcomps) => true &
	 int_sub(n,numcomps) => newn &
	 get_nth_component_in_elementitems(rest,newn) => res
	 ---------------------------------------------------
	 get_nth_component_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_))::rest,n) => res

   rule	list_length(lst) => numcomps &
	 int_le(n,numcomps) => true &
	 int_sub(n,1) => n' &
	 list_nth(lst,n') => elt
	 -----------------------------
	 get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt as Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,lst),info,i))::rest,n) 
	   => Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,[elt]),info,i)

   rule	get_nth_component_in_elementitems(rest,n) => res
	 ------------------------------------------------
	 get_nth_component_in_elementitems(_::rest,n) => res

  axiom	get_nth_component_in_elementitems([],_) => fail
end


(**relation: get_components_info
 **
 ** Helperrelation to get_components.
 ** Return all the info as a comma separated list of values.
 ** get_component_info => {{name, type, comment, access, final, flow, 
 ** replaceable, variability,innerouter,vardirection},..}
 ** where access is one of: "public", "protected"
 ** where final is one of: true, false
 ** where flow is one of: true, false
 ** where replaceable is one of: true, false
 ** where variability is one of: "constant", "parameter", "discrete" 
 **  or "unspecified"
 ** where innerouter is one of: "inner", "outer", ("innerouter") or "none"
 ** where vardirection is one of: "input", "output" or "unspecified".
 **
 ** inputs:  (Absyn.Element list,
              string, /* "public" or "protected" */
              Env.Env)
 ** outputs:  string
 **)
relation get_components_info: (Absyn.Element list,
				string, 
				Env.Env)
	  => string =

 rule	get_components_info2(elts,access,env) => (lst as _::_) &
	 Util.string_delimit_list(lst,"},{") => lst' &
	 Util.string_append_list(["{",lst',"}"]) => res
	 -----------------------------------------------
	 get_components_info(elts,access,env) => res
  axiom	get_components_info(_,_,_) => ""
end


(**relation: get_components_info2
 **
 ** Helperrelation to get_components_info
 **
 ** inputs: (Absyn.Element list, 
             string, /* "public" or "protected" */
             Env.Env)  
 ** outputs: string list 
 **)
relation get_components_info2: (Absyn.Element list, 
				 string,
				 Env.Env) => string list =

   axiom	get_components_info2([],_,_) => []

   rule	get_component_info(elt,access,env) => lst1 &
	 get_components_info2(rest,access,env) => lst2 &
	 list_append(lst1,lst2) => res
	 ----------------------------------------------------------
	 get_components_info2(elt::rest,access,env) => res
end


 (**relation: get_component_info
  **
  ** Thisrelation takes an `Element' and returns a list of strings 
  ** of comma separated values of the 
  ** type and name and comment, and attributes of  of the component, 
  ** If Element is not a component, the empty string is returned
  **
  ** inputs: (Absyn.Element,
              string, /* "public" or "protected" */
              Env.Env) 
  ** outputs: string list
  **)
relation get_component_info: (Absyn.Element,
			       string,
			       Env.Env) 
	   => string list =

   rule	 Lookup.lookup_class(env,p,true) => (c,env') &
	 Env.get_env_path(env') => SOME(envpath) &
	 Absyn.path_last_ident(p) => tpname &
	 Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	 Absyn.path_string(p') => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst &
	 Util.bool_string(f) => final &
	 keyword_replaceable(r) => r' &
	 Util.bool_string(r') => repl &
	 inner_outer_str(inout) => inout_str &
	 attr_flow_str(attr) => flow_str &
	 attr_variability_str(attr) => variability_str &
	 attr_direction_str(attr) => dir_str &
	 Util.string_delimit_list([access,final,flow_str,repl,variability_str,
				   inout_str,dir_str],", ") => str &
	 suffix_infos(lst,str) => lst' 
	 --------------------------------------
	 get_component_info(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_),access,env) => lst'

   rule	 Absyn.path_string(p) => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst &
	 Util.bool_string(f) => final &
	 keyword_replaceable(r) => r' &
	 Util.bool_string(r') => repl &
	 inner_outer_str(inout) => inout_str &
	 attr_flow_str(attr) => flow_str &
	 attr_variability_str(attr) => variability_str &
	 attr_direction_str(attr) => dir_str &
	 Util.string_delimit_list([access,final,flow_str,repl,variability_str,
				   inout_str,dir_str],", ") => str &
	 suffix_infos(lst,str) => lst' 
	 -------------------------------------------
	 get_component_info(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_),access,env) => lst'

   axiom	 get_component_info(_,_,env) => []

   rule	 print "get_component_info failed\n"
	 -------------------------------------------
	 get_component_info(_,_,_) => fail
end


(**relation: keyword_replaceable 
 **
 ** Returns true if RedeclareKeywords contains replaceable.
 **)
relation keyword_replaceable: Absyn.RedeclareKeywords option => bool =

  axiom	keyword_replaceable(SOME(Absyn.REPLACEABLE)) => true
  axiom	keyword_replaceable(SOME(Absyn.REDECLARE_REPLACEABLE)) => true
  axiom	keyword_replaceable(_) => false

end


 (**relation: get_component_info_old
  **
  ** Thisrelation takes an `Element' and returns a list of strings 
  ** of comma separated values of the 
  **  type and name and comment of the component, e.g. 'Resistor,R1, "comment"' 
  ** or 'Resistor,R1,"comment1",R2,"comment2"'
  ** If Element is not a component, the empty string is returned
  **)
relation get_component_info_old: (Absyn.Element,
			       Env.Env) 
	   => string list =

   rule	Lookup.lookup_class(env,p,true) => (c,env') &
	 Env.get_env_path(env') => SOME(envpath) &
	 Absyn.path_last_ident(p) => tpname &
	 Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	 Absyn.path_string(p') => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst 
	 --------------------------------------
	 get_component_info_old(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_),env) => lst

	 rule	Absyn.path_string(p) => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst 
	 -------------------------------------------
	 get_component_info_old(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_),env) => lst

	 axiom	get_component_info_old(_,env) => []

   rule	print "get_component_info_old failed\n"
	 -------------------------------------------
	 get_component_info_old(_,_) => fail
end


(**relation: inner_outer_str
 **
 ** Helperrelation to get_component_info, retrieve the inner outer string.
 **)
relation inner_outer_str: Absyn.InnerOuter => string =

  axiom	inner_outer_str (Absyn.INNER) =>  "\"inner\""
  axiom	inner_outer_str (Absyn.OUTER) => "\"outer\""
  axiom	inner_outer_str (Absyn.UNSPECIFIED) => "\"none\""
  axiom	inner_outer_str (Absyn.INNEROUTER) => "\"innerouter\""
end

	
(**relation: attr_flow_str
 **
 ** Helperrelation to get_component_info, retrieve flow attribite as bool 
 ** string.
 **)
relation attr_flow_str: (Absyn.ElementAttributes) => string =
	 
  rule	Util.bool_string(f) => res
	----------------------
	 attr_flow_str(Absyn.ATTR(f,_,_,_)) => res
end


(**relation: attr_variability_str
 **
 ** Helperrelation to get_component_info, retrieve variability as a 
 ** string.
 **)		   
relation attr_variability_str: (Absyn.ElementAttributes) => string =

  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.VAR,_,_)) => "\"unspecified\""
  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.DISCRETE,_,_)) 
	  => "\"discrete\""  
  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.PARAM,_,_)) 
	  => "\"parameter\"" 
  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.CONST,_,_)) 
	  => "\"constant\""
end


(**relation: attr_direction_str
 **
 ** Helperrelation to get_component_info, retrieve direction as a 
 ** string.
 **)		   
relation attr_direction_str: (Absyn.ElementAttributes) => string =

  axiom	attr_direction_str(Absyn.ATTR(_,_,Absyn.INPUT,_)) => "\"input\""
  axiom	attr_direction_str(Absyn.ATTR(_,_,Absyn.OUTPUT,_)) => "\"output\""
  axiom	attr_direction_str(Absyn.ATTR(_,_,Absyn.BIDIR,_)) => "\"unspecified\""

end


(**relation: suffix_infos
 **
 ** Helperrelation to get_component_info. Add suffix info to 
 ** element names, etc.
 **)	   
relation suffix_infos: (string list ,string) => string list =

  axiom	suffix_infos ([],_) => []
	 
  rule	suffix_infos(rest,suffix) => res &
	 Util.string_append_list([str,", ",suffix]) => str'
	 ---------------------
	 suffix_infos(str::rest,suffix) => str'::res 
end


(**relation: prefix_typename 
 **
 ** Helperrelation to get_component_info. Add a prefix typename to each
 ** string in the list.
 **)
relation prefix_typename: (string, string list) => string list =

   axiom	prefix_typename (_,[]) => []

   rule	prefix_typename(tp,rest) => res &
	 Util.string_append_list([tp,",",str]) => str'
	 ---------------------
	 prefix_typename(tp,str::rest) => str'::res
end


 (**relation_get_componentitems_name
  **
  ** Thisrelation takes a `ComponentItems' list and returns a 
  ** comma separated list of all
  ** component names and comments (if any).
  **)
relation get_componentitems_name: Absyn.ComponentItem list => string list =

   rule	string_append(c1,",") => s1 &
	 get_componentitems_name(c2::rest) => lst &
	 Util.string_append_list([s1,"\"",s2,"\""]) => str
	 ----------------------------
	 get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_,SOME(Absyn.COMMENT(_,SOME(s2))))::(c2::rest)) => str::lst

   rule	string_append(c1,",") => s1 &
	 get_componentitems_name(c2::rest) => lst &
	 Util.string_append_list([s1,"\"\""]) => str
	 ----------------------------
	 get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_,NONE)::(c2::rest)) => str::lst

   rule	get_componentitems_name(rest) => res
	 ------------------------------------
	 get_componentitems_name(_::rest) => res

   rule	Util.string_append_list([c1,",\"",s2,"\""]) => res
	 ----------------------
	 get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_,SOME(Absyn.COMMENT(_,SOME(s2))))]) => [res]

   rule  Util.string_append_list([c1,",\"\""]) => res
	 ---------------------------------------
	 get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_,_)]) => [res]

  axiom	get_componentitems_name([_]) => []

end


 (**relation: add_to_public
  **
  ** Thisrelation takes a 'Class' definition and adds an `ElementItem' to the first public list in the class.
  ** If no public list is available in the class one is created.
  **)
relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

   rule	get_public_list(parts) => publst &
	 list_append(publst,[eitem]) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 --------------------------------------------
	 add_to_public ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info), eitem) 
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)

   axiom	add_to_public ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_),file_info),eitem) => fail

   axiom	add_to_public(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info),eitem)
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(Absyn.PUBLIC([eitem])::parts,cmt),file_info)

end


 (**relation: add_to_protected
  **
  ** Thisrelation takes a 'Class' definition and adds an `ElementItem' to 
  ** the first protected list in the class.
  ** If no protected list is available in the class one is created.
  **)
relation add_to_protected: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

   rule	get_protected_list(parts) => protlst &
	 list_append(protlst,[eitem]) => protlst2 &
	 replace_protected_list(parts,protlst2) => parts2 
	 --------------------------------------------
	 add_to_protected ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info), eitem) 
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)

   axiom	add_to_protected ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_),file_info),eitem) => fail

   axiom	add_to_protected(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info),eitem)
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(Absyn.PROTECTED([eitem])::parts,cmt),file_info)

end


 (**relation: add_to_equation
  ** Thisrelation takes a 'Class' definition and adds an `EquationItem' to 
  ** the first equation list in the class.
  ** If no public list is available in the class one is created.
  **)
relation add_to_equation: (Absyn.Class, Absyn.EquationItem) => Absyn.Class = 

   rule	get_equation_list(parts) => eqlst &
	 let eqlst2 = eitem::eqlst &
	 replace_equation_list(parts,eqlst2) => parts2 
	 --------------------------------------------
	 add_to_equation ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info), eitem) 
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file_info)

   axiom	add_to_equation ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_),file_info),eitem) => fail

   rule	(* Add the equations last, to make nicer output if public section present *)
	 list_append(parts,[Absyn.EQUATIONS([eitem])]) => newparts
	 ------------------
	 add_to_equation(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file_info),eitem)
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(newparts,cmt),file_info)
end


 (**relation: replace_class_in_program
  **
  ** Thisrelation takes a `Class' and a `Program' and replaces the class 
  ** definition at the top level in the program by the class definition of 
  ** the `Class'.
  **)
relation replace_class_in_program: (Absyn.Class, Absyn.Program) => Absyn.Program =
   axiom replace_class_in_program(c, Absyn.PROGRAM([],w)) => Absyn.PROGRAM([c],w)
   rule	name1 = name2
	 -------------
	 replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_,_,_),Absyn.PROGRAM(Absyn.CLASS(name2,_,_,_,_,_,_)::clst,w))
	     => Absyn.PROGRAM(c::clst,w)

   rule	not name1 = name2 &
	 replace_class_in_program(c, Absyn.PROGRAM(clst,w)) => Absyn.PROGRAM(newclst,w)
	 -------------------------------------------------------
	 replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_,_,_),
	     Absyn.PROGRAM((c1 as Absyn.CLASS(name2,_,_,_,_,_,_))::clst,w)) 
	     => Absyn.PROGRAM(c1::newclst,w)

   rule	Print.print_buf "replace_class_in_program failed \n class:" &
	 Debug.fcall ("dump", Dump.dump, Absyn.PROGRAM([c],Absyn.TOP)) &
	 Print.print_buf "\nprogram: \n" &
	 Debug.fcall ("dump", Dump.dump, p)
	 ----------------------------
	 replace_class_in_program(c,p) => fail
end


 (**relation: insert_class_in_program 
  **
  ** Thisrelation inserts the class into the Program at the scope given by the
  ** within argument. If the class referenced by the within argument is not 
  ** defined, therelation prints an error message and fails.
  **)
relation insert_class_in_program: (Absyn.Class, Absyn.Within, Absyn.Program) => Absyn.Program =

   rule	get_class_in_program(n1,p) => c2 &
	 insert_class_in_class(c1,w,c2) => c3 &
	 update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	 -------------------------------------------------
	 insert_class_in_program(c1,w as Absyn.WITHIN(Absyn.QUALIFIED(n1,_)),p) => pnew

   rule	get_class_in_program(n1,p) => c2 &
	 insert_class_in_class(c1,w,c2) => c3 &
	 update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	 -------------------------------------------------
	 insert_class_in_program(c1, w as Absyn.WITHIN(Absyn.IDENT(n1)),p) => pnew

   rule	print "Error inserting in class. (" & Dump.unparse_within(0, w) => s1 & print s1 
	 & print ") program = \n" (*& Dump.unparse_str p => pstr & print pstr & print "\n"  *)
	 -------------------
	 insert_class_in_program(c1 as Absyn.CLASS(name,_,_,_,_,_,_),w,p) => fail	
end


 (**relation: insert_class_in_class
  ** 
  ** Thisrelation takes a class to update (the first argument)  and an inner 
  ** class (which is either replacing
  ** an earlier class or is a new inner definition) and a within statement
  ** pointing inside the class (including the class itself in the reference), 
  ** and updates the class with the inner class.
  **)
relation insert_class_in_class: (Absyn.Class, Absyn.Within, Absyn.Class) 
	  => Absyn.Class =

   rule	replace_inner_class(c1,c2) => cnew  
	 ----------------------------------
	 insert_class_in_class(c1,Absyn.WITHIN(Absyn.IDENT(name)),c2) => cnew

   rule  get_first_ident_from_path(path) => name2 &
	 get_inner_class(c2,name2) => cinner &
	 insert_class_in_class(c1,Absyn.WITHIN(path),cinner) => cnew &
	 replace_inner_class(cnew,c2) => cnew' 
	 ---------------------------------------------
	 insert_class_in_class(c1,Absyn.WITHIN(Absyn.QUALIFIED(name,path)),c2) => cnew'

   rule	Print.print_buf "insert_class_in_class failed\n" 
	 -------------------------------------
	 insert_class_in_class(_,_,_) => fail
end


 (**relation: get_first_ident_from_path
  **
  ** Thisrelation takes a `Path` as argument and returns the first `Ident' 
  ** of the path.
  **)
relation get_first_ident_from_path: Absyn.Path => Absyn.Ident =
      axiom get_first_ident_from_path (Absyn.IDENT(name)) => name
      axiom get_first_ident_from_path (Absyn.QUALIFIED(name,path)) => name
end


 (**relation: remove_inner_class 
  **
  ** Thisrelation takes two class definitions. The first one is the local 
  ** class that should be removed from the second one.
  **)
relation remove_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

   rule	get_public_list(parts) => publst &
	 remove_class_in_elementitemlist(publst,c1) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 -----------------------------------------------
	 remove_inner_class (c1,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt),file_info)) 
	     => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt),file_info)

   rule	Print.print_buf "Failed in remove_inner_class\n"
	 ---------------------------------------
	 remove_inner_class (_,_) => fail
end


 (**relation: remove_class_in_elementitemlist
  **
  ** Thisrelation takes an Element list and a Class and returns a modified 
  ** element list where the class definition of the class is removed.
  **)
relation remove_class_in_elementitemlist: (Absyn.ElementItem list, Absyn.Class) => Absyn.ElementItem list =

   rule	remove_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 remove_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

   rule	not name1 = name &
	 remove_class_in_elementitemlist(xs,c) => res
	 ------------------------------------------
	 remove_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,NONE)))::xs,c as Absyn.CLASS(name,_,_,_,_,_,_)) => e1::res

   rule name1 = name 
	 -----------------------------
	 remove_class_in_elementitemlist(
	     (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, Absyn.CLASS(name1,_,_,_,_,_,_)),info,h)))::xs,
	     c2 as Absyn.CLASS(name,_,_,_,_,_,_))
	     => xs

   rule	remove_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 remove_class_in_elementitemlist(c1::xs,c) => c1::res

   axiom	 remove_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,NONE,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c),Absyn.INFO("",false,0,0,0,0),NONE))]
end


(**relation: replace_inner_class 
 **
 ** Thisrelation takes two class definitions. The first one is 
 ** inserted/replaced as a local class inside the second one.
 **)
relation replace_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

   rule	get_public_list(parts) => publst &
	 replace_class_in_elementitemlist(publst,c1) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 -----------------------------------------------
	 replace_inner_class (c1,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt),file_info)) 
	     => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt),file_info)
   rule	Print.print_buf "Failed in replace_inner_class\n"
	 ---------------------------------------
	 replace_inner_class (_,_) => fail
end


(**relation: replace_class_in_elementitemlist
 **
 ** Thisrelation takes an Element list and a Class and returns a modified 
 ** element list where the class definition of the class is updated or added.
 **)
relation replace_class_in_elementitemlist: (Absyn.ElementItem list, 
					     Absyn.Class) 
	  => Absyn.ElementItem list =

   rule	replace_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 replace_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

   rule	not name1 = name &
	 replace_class_in_elementitemlist(xs,c) => res
	 ------------------------------------------
	 replace_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,NONE)))::xs,c as Absyn.CLASS(name,_,_,_,_,_,_)) => e1::res

   rule name1 = name 
	 -----------------------------
	 replace_class_in_elementitemlist(
	     (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, Absyn.CLASS(name1,_,_,_,_,_,_)),info,h)))::xs,
	     c2 as Absyn.CLASS(name,_,_,_,_,_,_))
	     => Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e,c2),info,h))::xs

   rule	replace_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 replace_class_in_elementitemlist(c1::xs,c) => c1::res

   axiom	 replace_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,NONE,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c),Absyn.INFO("",false,0,0,0,0),NONE))]
end


(**relation: get_inner_class
 **
 ** Thisrelation takes a class name and a class and return the inner class 
 ** definition having that name.
 **)
relation get_inner_class: (Absyn.Class, Absyn.Ident) => Absyn.Class =
   rule	get_public_list(parts) => publst &
	 get_class_from_elementitemlist(publst,name) => c1
	 -----------------------------------------------
	 get_inner_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_), name) => c1

   rule	Print.get_string => str &
	 Print.clear_buf &
	 Print.print_buf "get_inner_class failed, c:" &
	 Dump.dump Absyn.PROGRAM([c],Absyn.TOP) &
	 Print.print_buf "name :" & Print.print_buf name & 
	 Print.get_string => s1 & (*print s1 &*) Print.clear_buf & Print.print_buf str 
	 --------------
	 get_inner_class (c,name) => fail
end


 (**relation: replace_public_list
  **
  ** Thisrelation replaces the `ElementItem' list in the `ClassPart' list, 
  ** and returns the updated list.
  ** If no public list is available, one is created.
  **)
relation replace_public_list: (Absyn.ClassPart list,Absyn.ElementItem list) 
	  => Absyn.ClassPart list =

   rule	delete_public_list(rest) => rest'
	 ---------------------------------
	 replace_public_list ((lst as Absyn.PUBLIC(_))::rest,newpublst) 
	   => Absyn.PUBLIC(newpublst)::rest'

   rule	replace_public_list(xs,new) => ys
	 ---------------------------------
	 replace_public_list(x::xs,new) => x::ys

   axiom replace_public_list([],newpublist) => [Absyn.PUBLIC(newpublist)]
end


(**relation: replace_protected_list
 **
 ** Thisrelation replaces the `ElementItem' list in the `ClassPart' list, 
 ** and returns the updated list.
 ** If no protected list is available, one is created.
 **)		 
relation replace_protected_list: (Absyn.ClassPart list,
				   Absyn.ElementItem list) 
	  => Absyn.ClassPart list =
	 
   rule	delete_protected_list(rest) => rest'
	 ---------------------------------
	 replace_protected_list ((lst as Absyn.PROTECTED(_))::rest,newprotlist) 
	   => Absyn.PROTECTED(newprotlist)::rest'

   rule	replace_protected_list(xs,new) => ys
	 ---------------------------------
	 replace_protected_list(x::xs,new) => x::ys

   axiom replace_protected_list([],newprotlist) => [Absyn.PROTECTED(newprotlist)]
end


(**relation: delete_public_list
 **
 ** Deletes all PULIC classparts from the list.
 **)
relation delete_public_list:(Absyn.ClassPart list) 
	   => Absyn.ClassPart list =

   axiom	delete_public_list([]) => []

   rule	delete_public_list(xs) => res
	 -----------------------------
	 delete_public_list(Absyn.PUBLIC(_)::xs) => res

   rule	delete_public_list(xs) => res
	 -----------------------------
	 delete_public_list(x::xs) => x::res
end


(**relation: delete_protected_list
 **
 ** Deletes all PROTECTED classparts from the list.
 **)
relation delete_protected_list:(Absyn.ClassPart list) 
	   => Absyn.ClassPart list =

   axiom	delete_protected_list([]) => []

   rule	delete_protected_list(xs) => res
	 -----------------------------
	 delete_protected_list(Absyn.PROTECTED(_)::xs) => res

   rule	delete_protected_list(xs) => res
	 -----------------------------
	 delete_protected_list(x::xs) => x::res
end

 (**relation: replace_equation_list
  **
  ** Thisrelation replaces the `EquationItem' list in the `ClassPart' list, 
  ** and returns the updated list.
  **)
relation replace_equation_list: (Absyn.ClassPart list,
				  Absyn.EquationItem list) 
	  => Absyn.ClassPart list =

   axiom replace_equation_list ((lst as Absyn.EQUATIONS(_))::rest,newpublst) 
	   => Absyn.EQUATIONS(newpublst)::rest

   rule	replace_equation_list(xs,new) => ys
	 ---------------------------------
	 replace_equation_list(x::xs,new) => x::ys

   axiom replace_equation_list([],_) => []
end


(**relation: get_public_list
 **
 ** Thisrelation takes a ClassPart List and returns an appended list of 
 ** all public lists.
 **)		 
relation get_public_list: Absyn.ClassPart list => Absyn.ElementItem list =

  axiom	get_public_list([]) => []

   rule	get_public_list(rest) => res2 &
	 list_append(res1,res2) => res
	 -----------------------------
	 get_public_list Absyn.PUBLIC(res1)::rest => res

   rule	get_public_list(xs) => ys
	 ---------------------------
	 get_public_list(x::xs) => ys

end


 (**relation: get_protected_list
  ** Thisrelation takes a ClassPart List and returns an appended list of 
  ** all protected lists.
  **)
relation get_protected_list: Absyn.ClassPart list => Absyn.ElementItem list =

   axiom	get_protected_list([]) => []

   rule	get_protected_list(rest) => res2 &
	 list_append(res1,res2) => res
	 -----------------------------
	 get_protected_list Absyn.PROTECTED(res1)::rest => res

   rule	get_protected_list(xs) => ys
	 ---------------------------
	 get_protected_list(x::xs) => ys
end


(**relation: get_equation_list
 **
 ** Thisrelation takes a ClassPart List and returns the first EquationItem 
 ** list of the class.
 **)		 
relation get_equation_list: Absyn.ClassPart list => Absyn.EquationItem list =

   axiom get_equation_list Absyn.EQUATIONS(lst)::rest => lst

   rule	get_equation_list(xs) => ys
	 ---------------------------
	 get_equation_list(x::xs) => ys

   axiom get_equation_list(_) => fail
end


(**relation: get_class_from_elementitemlist
 **
 ** Thisrelation takes an ElementItem list and an Ident and returns the 
 ** class definition among the element list having that identifier.
 **)
relation get_class_from_elementitemlist: (Absyn.ElementItem list, 
					   Absyn.Ident) 
	  => Absyn.Class =

   rule	get_class_from_elementitemlist(xs,name) => res
	 ----------------------------------------------
	 get_class_from_elementitemlist(Absyn.ANNOTATIONITEM(_)::xs,name) => res

   rule	name1 = name2
	 ------------------------------
	 get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,NONE))::xs,name2) => c1

   rule	not name1 = name &
	 get_class_from_elementitemlist(xs,name) => res
	 ------------------------------------------
	 get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,NONE))::xs,name) => res

   rule	get_class_from_elementitemlist(xs,name) => res
	 ----------------------------------------------
	 get_class_from_elementitemlist(_::xs,name) => res

   axiom	 get_class_from_elementitemlist([],_) => fail
end


(**relation: class_in_program
 **
 ** Thisrelation takes a name and a Program and returns true if the name 
 ** exists as a top class in the program.
 **)
relation class_in_program:(string,Absyn.Program) => bool = 

   axiom class_in_program (str,Absyn.PROGRAM([],_)) => false

   rule	not str = c1 &
	 class_in_program(str,Absyn.PROGRAM(p,w)) => res
	 -----------------------
	 class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_,_,_)::p,w)) => res

   axiom class_in_program (_,_) => true
end


(**relation: get_pathed_class_in_program
 **
 ** Thisrelation takes a `Path' and a `Program` and retrieves the class 
 ** definition referenced by the `Path' from the `Program'.
 **)
relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) 
	  => Absyn.Class =

   rule	get_class_in_program(str,p) => c1 
	 ---------------------------------
	 get_pathed_class_in_program (Absyn.IDENT(str),p) => c1

   rule	get_class_in_program(c1,p) => c1def &
	 get_classes_in_class(Absyn.IDENT(c1),p,c1def) => classes &
	 get_pathed_class_in_program(prest,Absyn.PROGRAM(classes,w)) => res
	 ------------------------------------------------------------
	 get_pathed_class_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res

  rule  print "-get_pathed_class_in_program failed\n"
	 ---------------------------------
	 get_pathed_class_in_program (_,_) => fail
         
end


(**relation: get_classes_in_class
 ** Thisrelation takes a `Class' definition and returns a list of local 
 ** `Class' definitions of that class.
 **)		 
relation get_classes_in_class: (Absyn.Path, Absyn.Program,Absyn.Class) 
	  => Absyn.Class list =

   rule	get_classes_in_parts(parts)  => res
	 --------------------------
	 get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => res

   rule	lookup_classdef(path, modelpath,p) => (cdef,newpath) &
	 get_classes_in_class(newpath,p,cdef) => res
	 --------------------------------------------
	 get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_),_)) => res
end


(**relation: get_classes_in_parts
 **
 ** Helperrelation to get_classes_in_class.
 **)
relation get_classes_in_parts: Absyn.ClassPart list => Absyn.Class list =

   axiom	 get_classes_in_parts [] => []	

   rule	get_classes_in_parts(rest) => l1 &
	 get_classes_in_elts(elts) => l2 &
	 list_append(l1,l2) => res
	 ------------------------
	 get_classes_in_parts (Absyn.PUBLIC(elts)::rest) => res

   rule	get_classes_in_parts(rest) => l1 &
	 get_classes_in_elts(elts) => l2 &
	 list_append(l1,l2) => res
	 ------------------------
	 get_classes_in_parts (Absyn.PROTECTED(elts)::rest) => res

   rule	get_classes_in_parts(rest) => res
	 ---------------------------------
	 get_classes_in_parts(_::rest) => res
end


(**relation: get_classes_in_elts
 **
 ** Helperrelation to get_classes_in_parts.
 **)
relation get_classes_in_elts: Absyn.ElementItem list => Absyn.Class list =

   axiom	get_classes_in_elts [] => []

   rule	get_classes_in_elts (rest) => res
	 ---------------------------------
	 get_classes_in_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,class),_,NONE))::rest)
	     => class::res
   rule	get_classes_in_elts (rest) => res
	 ---------------------------------
	 get_classes_in_elts (_::rest)
	     => res
end


 (**relation: get_class_in_program
  **
  ** Thisrelation takes a Path and a Program and returns the class with 
  ** the name `Path'.
  ** If that class does not exist, therelation fail
  **)
relation get_class_in_program:(string, Absyn.Program) => Absyn.Class = 

   axiom get_class_in_program (str,Absyn.PROGRAM([],_)) => fail

   rule	not str = c1 &
	 get_class_in_program(str,Absyn.PROGRAM(p,w)) => res
	 -----------------------------------------
	 get_class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_,_,_)::p,w)) => res

   rule  str = c1name
	 ------------
	 get_class_in_program (str, Absyn.PROGRAM((c1 as Absyn.CLASS(c1name,_,_,_,_,_,_))::p,w)) => c1
end


 (**relation: modification_to_absyn
  **
  ** Thisrelation takes a list of `NamedArg' and returns an absyn 
  ** `Modification option'. It collects binding equation from the named 
  ** argument binding=<expr> and creates
  ** corresponding Modification option Absyn node.
  ** Future extension: add general modifiers. Problem: how to express this using named 
  ** arguments. This is not possible. Instead we need a new data type for storing AST, 
  ** and a constructor function for AST, 
  ** e.g. AST x = ASTModification(redeclare R2 r, x=4.2); // new datatype AST
  **					 // new constructor operator ASTModification
  **)
relation modification_to_absyn: (Absyn.NamedArg list,
				  Absyn.Modification option) 
	   => Absyn.Modification option =

   rule	modification_to_absyn2(nargs) => SOME(mod)
	 --------------------------------
	 modification_to_absyn(nargs,oldmod) => SOME(mod)

   axiom	modification_to_absyn(nargs,oldmod) => oldmod
end


(**relation: modification_to_absyn2
 **
 ** Helperrelation to modification_to_absyn.
 **)
relation modification_to_absyn2: (Absyn.NamedArg list ) 
	   => Absyn.Modification option =

   axiom	modification_to_absyn2([]) => NONE

   axiom	modification_to_absyn2(Absyn.NAMEDARG("binding",exp)::xs) 
	   => SOME(Absyn.CLASSMOD([],SOME(exp)))

   axiom	modification_to_absyn2(Absyn.NAMEDARG("modification",
					      Absyn.CODE(Absyn.C_MODIFICATION(mod)))::xs)
	   => SOME(mod)

   rule	modification_to_absyn2(xs) => res
	 --------------------------------
	 modification_to_absyn2(x::xs) => res
end


 (**relation: annotation_list_to_absyn_comment
  **
  ** Thisrelation takes a list of `NamedArg' and returns an absyn Comment.
  ** for instance [annotation = Placement( ...), comment="stringcomment" ] 
  ** is converted to SOME(COMMENT(ANNOTATION(Placement(...),
  **					      SOME("stringcomment")))) 
  **)
relation annotation_list_to_absyn_comment: (Absyn.NamedArg list,
					      Absyn.Comment option) 
	   => Absyn.Comment option =

   rule	annotation_list_to_absyn_comment2(nargs) => SOME(ann)
	 ----------------
	 annotation_list_to_absyn_comment(nargs,oldann) => SOME(ann)

   axiom	annotation_list_to_absyn_comment(nargs,oldann) => oldann
end


(**relation: annotation_list_to_absyn_comment2
 **
 ** Helperrelation to annotation_list_to_absyn_comment2.
 **)
relation annotation_list_to_absyn_comment2: (Absyn.NamedArg list) 
	  => Absyn.Comment option =
	
   rule	 (*special case for empty string *)
	 annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	 comment_to_absyn(nargs) => SOME("")
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => NONE

   rule	 annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	 comment_to_absyn(nargs) => SOME(strcmt)
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => SOME(Absyn.COMMENT(NONE,SOME(strcmt)))

   rule	 annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	 comment_to_absyn(nargs) => NONE
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => NONE

   rule	 annotation_list_to_absyn(nargs) => annotation &
	 comment_to_absyn(nargs) => strcmt
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => SOME(Absyn.COMMENT(SOME(annotation),strcmt))

   axiom annotation_list_to_absyn_comment2(_) => NONE

end


(**relation: comment_to_absyn
 **
 ** Helperrelation to annotation_list_to_absyn_comment2.
 **)
relation comment_to_absyn: (Absyn.NamedArg list) => string option =

  rule	not str = "" 
	------------------------
	comment_to_absyn(Absyn.NAMEDARG("comment",Absyn.STRING(str))::_) 
	   => SOME(str)

   rule	comment_to_absyn(rest) => res
	 --------------------
	 comment_to_absyn(_::rest) => res

   axiom	comment_to_absyn(_) => NONE
end


(**relation: annotation_list_to_absyn
 **
 ** Thisrelation takes a list of `NamedArg' and returns an absyn `Annotation'.
 ** for instance [annotation = Placement( ...) ] is converted to 
 ** ANNOTATION(Placement(...)) 
 **)
relation annotation_list_to_absyn: (Absyn.NamedArg list) => Absyn.Annotation =

  axiom annotation_list_to_absyn( [] ) => Absyn.ANNOTATION([])

   rule	record_constructor_to_modification(e) => eltarg
	 ------------------------------------
	 annotation_list_to_absyn(Absyn.NAMEDARG("annotate",e)::_) => Absyn.ANNOTATION([eltarg])

   rule	annotation_list_to_absyn(al) => annres
	 --------------------------------------
	 annotation_list_to_absyn(a::al) => annres
end


 (**relation:record_constructor_to_modification
  **
  ** Thisrelation takes a record constructor expression and translates it 
  ** into a `ElementArg'. Since modifications must be named, only named 
  ** arguments are treated in the record constructor.
  **)
relation record_constructor_to_modification: (Absyn.Exp ) 
	  => Absyn.ElementArg =

   rule	 (* Covers the case annotate=Diagram(x=1,y=2) *)
	 Util.list_map(nargs,namedarg_to_modification) => eltarglst &
	 let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,cr,SOME(Absyn.CLASSMOD(eltarglst,NONE)),NONE)
	 -----------------------------------
	 record_constructor_to_modification(Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs))) => res	

   rule	 (* Covers the case annotate=Diagram(SOMETHING(x=1,y=2)) *)
	 Util.list_map(nargs,namedarg_to_modification) => eltarglst &
	 record_constructor_to_modification(e) => emod &
	 let res = Absyn.MODIFICATION(false, Absyn.NON_EACH,
				      cr, SOME(Absyn.CLASSMOD(emod::eltarglst, NONE)), NONE)
	 -----------------------------------
	 record_constructor_to_modification(Absyn.CALL(cr,
						       Absyn.FUNCTIONARGS([e as Absyn.CALL(_,_)],nargs))) => res	


   rule	 Print.print_buf "record_constructor_to_modification failed, exp=" & 
	 Absyn.print_absyn_exp e & Print.print_buf "\n" 
	 -------------------------
	 record_constructor_to_modification(e) => fail
end


(**relation: namedarg_to_modification
 **
 ** Thisrelation takes a `NamedArg' and translates it into a `ElementArg'.
 **)		 
relation namedarg_to_modification: (Absyn.NamedArg) => Absyn.ElementArg = 
	 
  rule	record_constructor_to_modification(c) => Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(elts,_)),NONE) &
	 let cr' = Absyn.CREF_IDENT(id,[]) &
	 let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,cr',SOME(Absyn.CLASSMOD(elts,NONE)),NONE)
	 ----------------------------
	 namedarg_to_modification( Absyn.NAMEDARG(id,c as Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs)))) => res

   rule	let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,Absyn.CREF_IDENT(id,[]),SOME(Absyn.CLASSMOD([],SOME(e))),NONE)
	 ----------------------------------------------------------------
	 namedarg_to_modification( Absyn.NAMEDARG(id,e)) => res

   rule	Print.print_buf "- namedarg_to_modification failed\n" 
	 ----------------
	 namedarg_to_modification(_) => fail
end


 (**relation: add_instantiated_class
  **
  ** Thisrelation adds an instantiated class to the list of instantiated 
  ** classes. If the class path already exists, the class is replaced. 
  **)
relation add_instantiated_class: (InstantiatedClass list, InstantiatedClass) 
	  => InstantiatedClass list =

   axiom	add_instantiated_class ([],cl) => [cl]

   rule	ModUtil.path_equal(path,path2) => true
	 ---------------------------
	 add_instantiated_class(INSTCLASS(path,dae,env)::xs, newc as INSTCLASS(path2,dae',env')) 
	   => newc::xs

   rule	ModUtil.path_equal(path,path2) => false &
	 add_instantiated_class(xs, newc) => res 
	 ---------------------------
	 add_instantiated_class((x as INSTCLASS(path,_,_))::xs, newc as INSTCLASS(path2,_,_)) 
	   => x::res
end


(**relation: get_instantiated_class
 **
 ** Thisrelation get an instantiated class from the list of instantiated 
 ** classes.
 **)		 
relation get_instantiated_class: (InstantiatedClass list, Absyn.Path) 
	  => InstantiatedClass =

   rule	ModUtil.path_equal(path,path2) => true
	 ---------------------------
	 get_instantiated_class((x as INSTCLASS(path,dae,env))::xs, path2) 
	   => x

   rule	ModUtil.path_equal(path,path2) => false &
	 get_instantiated_class(xs, path2) => res 
	 ---------------------------
	 get_instantiated_class((x as INSTCLASS(path,_,_))::xs, path2) 
	   => res
end


 (**relation: get_contained_class_and_file
  ** author: PA
  ** 
  ** Returns the package or class in which the model is saved and the file 
  ** name it is saved in. This is used to save a model in a package when the 
  ** whole package is saved in a file.
  **
  ** inputs:   (Absyn.Path, 
                Absyn.Program)
  ** outputs:  (Absyn.Program,
                string) /* filename */
  **)
relation get_contained_class_and_file: (Absyn.Path,
					 Absyn.Program)
	   => (Absyn.Program, 
	       string) = 

   rule	 get_pathed_class_in_program(classname,p) => cdef &
	 Absyn.class_filename(cdef) => filename &
	 get_surrounding_package(classname,p) => p' &
	 remove_inner_diff_filed_classes(p') => p''
	 ---------------------------------------------------
	 get_contained_class_and_file(classname,p) => (p'',filename)
end


 (**relation remove_inner_diff_filed_classes
  ** author: PA
  **
  ** Removes all inner classes that have different file name than the class 
  ** itself. The filename of the class is passed as argument.
  **
  ** inputs: (Absyn.Program) /* package as program. */
  ** outputs: Absyn.Program =
  **)
relation remove_inner_diff_filed_classes: (Absyn.Program)
	   => Absyn.Program =

   rule	Util.list_map(classlst,remove_inner_diff_filed_class) => classlst'
	 ------------------------
	 remove_inner_diff_filed_classes(Absyn.PROGRAM(classlst,within)) 
	   =>  Absyn.PROGRAM(classlst',within)
end


 (**relation: remove_inner_diff_filed_class
  ** author: PA
  ** 
  ** Helperrelation to remove_inner_diff_filed_classes, removes all local classes in class
  ** that does not have the same filename as the class iteself.
  **)
relation remove_inner_diff_filed_class: (Absyn.Class) => Absyn.Class =


   rule	get_public_list(parts) => publst &
	 remove_class_diff_filed_in_elementitemlist(publst,file) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 ----------------------------
	 remove_inner_diff_filed_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt),file_info as Absyn.INFO(file, _, _, _, _, _))) 
	     => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt),file_info)
end


(**relation: remove_class_diff_filed_in_elementitemlist
 ** author: PA 
 **
 ** Thisrelation takes an Element list and a filename and returns a 
 ** modified element list where the elements not stored in filename are 
 ** removed.
 **
 ** inputs: (Absyn.ElementItem list, 
             string /* filename */)
 ** outputs: Absyn.ElementItem list 
 **)
relation remove_class_diff_filed_in_elementitemlist: (Absyn.ElementItem list, 
					    string)
	   => Absyn.ElementItem list =

   rule	(* annotations are kept *)
	 remove_class_diff_filed_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 remove_class_diff_filed_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

   rule	not filename1 = filename2 &
	 remove_class_diff_filed_in_elementitemlist(xs,filename1) => res
	 ------------------------------------------
	 remove_class_diff_filed_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(_,_,_,_,_,_,Absyn.INFO(filename2,_,_,_,_,_))),_,_)))::xs,filename1) => res

   rule  filename1 = filename2 &
	 remove_class_diff_filed_in_elementitemlist(xs,filename1) => res
	 -----------------------------
	 remove_class_diff_filed_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(_,_,_,_,_,_,Absyn.INFO(filename2,_,_,_,_,_))),_,_)))::xs,filename1)
	   => e1::res

   rule	remove_class_diff_filed_in_elementitemlist(xs,filename) => res
	 -----------------------------------------
	 remove_class_diff_filed_in_elementitemlist(c1::xs,filename) => c1::res

   axiom	 remove_class_diff_filed_in_elementitemlist([],filename) => []
end


 (**relation: get_surrounding_package
  ** author: PA
  **
  ** Thisrelation investigates the surrounding packages and returns the outermost package
  ** that has the same filename as the class
  **)
relation get_surrounding_package: (Absyn.Path, Absyn.Program) => Absyn.Program =

   rule	get_pathed_class_in_program(classpath,p) => cdef &
	 Absyn.class_filename(cdef) => filename1 &
	 Absyn.strip_last(classpath) => ppath &
	 get_pathed_class_in_program(ppath,p) => pdef &
	 Absyn.class_filename(pdef) => filename2 &
	 filename1 = filename2  &
	 get_surrounding_package(ppath,p) => res
	 -----------------------------------------
	 get_surrounding_package(classpath,p) => res

   rule	(* No package with same filename *)
	 get_pathed_class_in_program(classpath,p) => cdef &
	 build_within(classpath) => within 
	 ----------------------------------	
	 get_surrounding_package(classpath,p) 
	   => Absyn.PROGRAM([cdef],within)
end


 (* AST for the builtin graphical classes *)
 val Graphics_program = Absyn.PROGRAM([
 Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)]), NONE),Absyn.INFO("graphics.mo",true,0,0,0,0))
 , Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)]), NONE),Absyn.INFO("graphics.mo",true,0,0,0,0))
 , Absyn.CLASS("FillPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Horizontal",NONE), Absyn.ENUMLITERAL("Vertical",NONE), Absyn.ENUMLITERAL("Cross",NONE), Absyn.ENUMLITERAL("Forward",NONE), Absyn.ENUMLITERAL("Backward",NONE), Absyn.ENUMLITERAL("CrossDiag",NONE), Absyn.ENUMLITERAL("HorizontalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("Sphere",NONE)]), NONE),Absyn.INFO("graphics.mo",true,0,0,0,0))
 , Absyn.CLASS("BorderPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Raised",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Engraved",NONE)]), NONE),Absyn.INFO("graphics.mo",true,0,0,0,0))
 , Absyn.CLASS("TextStyle", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("Bold",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Underline",NONE)]), NONE),Absyn.INFO("graphics.mo",true,0,0,0,0))
 , Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE,NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE, NONE)]), Absyn.INFO("graphics.mo", true, 6, 0, 6, 0),NONE))])], NONE),Absyn.INFO("graphics.mo",true, 0, 0, 0, 0))
 , Absyn.CLASS("Polygon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 7, 0, 7, 0),NONE))])], NONE),Absyn.INFO("graphics.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("Rectangle", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("BorderPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("borderPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("BorderPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("radius",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 8, 0, 8, 0),NONE))])], NONE),Absyn.INFO("graphics.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("Ellipse", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 9, 0, 9, 0),NONE))])], NONE),Absyn.INFO("graphics.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("Text", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textString",[], NONE), NONE,NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE,NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("TextStyle"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textStyle",[Absyn.NOSUB], NONE), NONE,NONE)]), Absyn.INFO("graphics.mo", true, 10, 0, 10, 0),NONE))])], NONE),Absyn.INFO("graphics.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("Bitmap", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fileName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("imageSource",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("graphics.mo", true, 11, 0, 11, 0),NONE))])], NONE),Absyn.INFO("graphics.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),Absyn.INFO("graphics.mo", true, 0, 0, 0, 0))
 ],Absyn.TOP)


 val Icon_program = 
Absyn.PROGRAM([
Absyn.CLASS("GraphicItem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 1, 0, 1, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("CoordinateSystem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 1, 0, 1, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Icon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("CoordinateSystem"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("coordinateSystem",[], SOME(Absyn.CLASSMOD([(Absyn.MODIFICATION(false, Absyn.NON_EACH, Absyn.CREF_IDENT("extent", []), SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.ARRAY([Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(10.0)),Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(10.0))]),Absyn.ARRAY([Absyn.REAL(10.0),Absyn.REAL(10.0)])])))), NONE))], NONE))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 1, 0, 1, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)]), NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)]), NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("FillPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Horizontal",NONE), Absyn.ENUMLITERAL("Vertical",NONE), Absyn.ENUMLITERAL("Cross",NONE), Absyn.ENUMLITERAL("Forward",NONE), Absyn.ENUMLITERAL("Backward",NONE), Absyn.ENUMLITERAL("CrossDiag",NONE), Absyn.ENUMLITERAL("HorizontalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("Sphere",NONE)]), NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("BorderPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Raised",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Engraved",NONE)]), NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("TextStyle", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("Bold",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Underline",NONE)]), NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 8, 0, 8, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Polygon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 9, 0, 9, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Rectangle", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("BorderPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("borderPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("BorderPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("radius",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 10, 0, 10, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Ellipse", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 11, 0, 11, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Text", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textString",[], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("TextStyle"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textStyle",[Absyn.NOSUB], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 12, 0, 12, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Bitmap", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 13, 0, 13, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("icon.mo", true, 13, 0, 13, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fileName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 13, 0, 13, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("imageSource",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("icon.mo", true, 13, 0, 13, 0),NONE))])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),Absyn.INFO("icon.mo", true, 0, 0, 0, 0))
],Absyn.TOP)


 val Diagram_program = Absyn.PROGRAM([
Absyn.CLASS("GraphicItem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 1 ,0, 1, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("CoordinateSystem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 1, 0, 1, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Diagram", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("CoordinateSystem"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("coordinateSystem",[], SOME(Absyn.CLASSMOD([(Absyn.MODIFICATION(false, Absyn.NON_EACH, Absyn.CREF_IDENT("extent", []), SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.ARRAY([Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(100.0)),Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(100.0))]),Absyn.ARRAY([Absyn.REAL(100.0),Absyn.REAL(100.0)])])))), NONE))], NONE))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 1, 0, 1, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)]), NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)]), NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("FillPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Horizontal",NONE), Absyn.ENUMLITERAL("Vertical",NONE), Absyn.ENUMLITERAL("Cross",NONE), Absyn.ENUMLITERAL("Forward",NONE), Absyn.ENUMLITERAL("Backward",NONE), Absyn.ENUMLITERAL("CrossDiag",NONE), Absyn.ENUMLITERAL("HorizontalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("Sphere",NONE)]), NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("BorderPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Raised",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Engraved",NONE)]), NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("TextStyle", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("Bold",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Underline",NONE)]), NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 8, 0, 8, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Polygon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE, NONE)]), Absyn.INFO("diagram.mo", true, 9, 0, 9, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Rectangle", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("BorderPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("borderPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("BorderPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("radius",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 10, 0, 10, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Ellipse", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 11, 0, 11, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Text", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textString",[], NONE), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("TextStyle"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textStyle",[Absyn.NOSUB], NONE), NONE,NONE)]), Absyn.INFO("diagram.mo", true, 12, 0, 12, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Bitmap", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 13, 0, 13, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 13, 0, 13, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fileName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 13, 0, 13, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("imageSource",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))),NONE, NONE)]), Absyn.INFO("diagram.mo", true, 13, 0, 13, 0),NONE))])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),Absyn.INFO("diagram.mo", true, 0, 0, 0, 0))
],Absyn.TOP)

 val Line_program = Absyn.PROGRAM([
 Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)]), NONE),Absyn.INFO("line.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION(Absyn.ENUMLITERALS([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)]), NONE),Absyn.INFO("line.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE),NONE, NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))),NONE, NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE,NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))),NONE, NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE,NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE,NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE,NONE)]), Absyn.INFO("line.mo", true, 1, 0, 1, 0),NONE))])], NONE),Absyn.INFO("line.mo", true, 0, 0, 0, 0))
 , Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),Absyn.INFO("line.mo", true, 0, 0, 0, 0))
 ],Absyn.TOP)


 val Placement_program = Absyn.PROGRAM([
Absyn.CLASS("Transformation", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("x",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("y",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("scale",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(1.0))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("aspectRatio",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(1.0))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("flipHorizontal",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("flipVertical",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("rotation",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE))])], NONE),Absyn.INFO("placement.mo", true, 0, 0, 0, 0))
, Absyn.CLASS("Placement", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Transformation"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("transformation",[], NONE),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, NONE, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Transformation"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("iconTransformation",[], NONE),NONE, NONE)]), Absyn.INFO("placement.mo", true, 2, 0, 2, 0),NONE))])], NONE),Absyn.INFO("placement.mo", true, 0, 0, 0, 0))
],Absyn.TOP)





