(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

(* This module is responsible for the lookup mechanism in Modelica.
 ** It is responsible for looking up classes, variables, etc. in the
 ** environment 'Env' by following the lookup rules.
 ** The most important relations are:
 ** lookup_class - to find a class 
 ** lookup_type - to find types (e.g. functions, types, etc.)
 ** lookup_var - to find a variable in the instance hierarchy.
 **)

module Lookup:

  with "ClassInf.rml"
  with "Types.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "Env.rml"
  with "SCode.rml"

  relation lookup_type       : (Env.Env, Absyn.Path, bool (* msg flag *)) 
	  => (Types.Type,Env.Env)
  relation lookup_class      : (Env.Env, Absyn.Path,bool) 
	  => (SCode.Class, Env.Env)
  relation complete_path     : (Env.Env, Absyn.Path) => Absyn.Path
  relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) 
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) 
	  => (Types.Var,(SCode.Element*Types.Mod) option,bool,Env.Env)
  relation lookup_ident : (Env.Env, SCode.Ident) 
	  => (Types.Var,(SCode.Element*Types.Mod) option,bool)
  relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list)
  relation is_in_builtin_env: Absyn.Path => bool

end

with "Parser.rml"
with "Debug.rml"
with "Dump.rml"
with "Inst.rml"
with "Mod.rml"
with "Prefix.rml"
with "Print.rml"
with "Builtin.rml"
with "Util.rml"
with "ModUtil.rml"
with "Static.rml"
with "Connect.rml"
with "Error.rml"


(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 ** 
 ** This relation finds a specified type in the environment. 
 ** If it finds a function instead, this will be implicitly instantiated 
 ** and lookup will start over. 
 **
 ** Arg1: Env.Env is the environment which to perform the lookup in
 ** Arg2: Absyn.Path is the type to look for
 **)
relation lookup_type: (Env.Env,Absyn.Path,bool (* msg flag *)) 
	  => (Types.Type, Env.Env) =

	(* Lookup of simple names *)
  rule	
	(*Debug.fprint ("lotype","lookup_type(") &
	Debug.fcall ("lotype",Env.print_env, env) &
	Debug.fprint ("lotype",", ") & 
	Debug.fcall ("lotype",Dump.print_path,path) &
	Debug.fprint ("lottype",")\n") &*)
	lookup_type_in_env(env,path) => (t,env') 
	(*Debug.fprint ("lotype", "found type:") &
	Debug.fcall ("lotype",Types.print_type, t) *)
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env')

  rule	 (* If we didn't find the type, but found a class definition 
	  * that is a function with the same name then we implicitly instantiate that
	  function, and try again. *)
	lookup_class(env, path, false) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_FUNCTION,_),env') &
	Inst.implicit_function_type_instantiation(env', c) => env'' &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env3)


  rule	 (* If we didn't find the type, but found a class definition 
	  * that is an external function with the same name then we implicitly 
	  * instantiate that function, and try again. *)
	lookup_class(env, path, msg) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_EXT_FUNCTION,_),env') &
	Inst.implicit_function_type_instantiation(env', c) => env'' &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env3)

	(* Lookup of qualified name *)
  rule	lookup_class(env, Absyn.IDENT(pack), false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	(* Instantiate implicit (last argument = true) *)
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
			   Connect.empty_set, ci_state, c, false, [], 
			   true,false (*true*)) 
	  => (_,env'',_,cistate1,_,_) &
        not ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has to do additional check for encapsulated classes, see rule below *)
	lookup_type_in_class(env'', c, path, true) => (t, env''') 
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack, path),msg) => (t, env''')


  rule	lookup_class(env, Absyn.IDENT(pack), msg) 
	  => (c as SCode.CLASS(id, _, encflag, restr, _), env') &	
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
			   Connect.empty_set, ci_state, c, false, [], 
			   true,false(*true*))
	  => (_, env'', _, cistate1, _,_) &
        ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has NOT to do additional check for encapsulated classes, see rule above *)
	lookup_type_in_class(env'', c, path, false) => (c', env''') 
	--------------------------------------
	lookup_type(env, p as Absyn.QUALIFIED(pack, path), msg) => (c', env''')

  rule	Absyn.path_string path => classname & 
	Env.print_env_path_str(env) => scope &
	Error.add_message(Error.LOOKUP_ERROR,[classname,scope])
	---------------------
	lookup_type(env,path,true) => fail
end

(** relation: is_primitive
 ** author: PA
 **
 ** Returns true if classname is any of the builtin classes:
 ** Real, Integer, String, Boolean
**)
relation is_primitive: Absyn.Path => bool =

  axiom	is_primitive(Absyn.IDENT("Integer")) => true
  axiom	is_primitive(Absyn.IDENT("Real")) => true
  axiom	is_primitive(Absyn.IDENT("Boolean")) => true
  axiom	is_primitive(Absyn.IDENT("String")) => true
  axiom	is_primitive(_) => false
end

(** relation: lookup_class
 ** 
 ** Tries to find a specified class in an environment
 ** 
 ** Arg1: The enviroment where to look
 ** Arg2: The path for the class
 ** Arg3: A Bool to control the output of error-messages. If it is true
 **       then it outputs a error message if the class is not found.
 **)
relation lookup_class: (Env.Env, Absyn.Path, bool) => (SCode.Class, Env.Env) =

	(* Builtin classes Integer, Real, String, Boolean can not be overridden
	 search top environment directly. *)
  rule	 is_primitive(path) => true &
	Env.top_frame(env) => f &
	 lookup_class_in_frame(f,[f],id,msg) => (c,env) 
	-----------------------------------
	lookup_class(env,path as Absyn.IDENT(id),msg) => (c,env)

  rule	 is_primitive(path) => true &
	print "ERROR, primitive class not found on top env: "&
	Env.print_env_str(env) => s &
	 print s 
	-------------------------------
	lookup_class(env,path,msg) => fail

  rule	 lookup_class_in_env(env,path,msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_), env') 
	--------------------------------------
	lookup_class(env, path as Absyn.IDENT(name),msgflag) 
	  => (c, env')


  rule	(* If we search for A1.A2....An.x while in scope A1.A2...An
	 , just search for x. Must do like this to ensure finite recursion *)
	 Env.get_env_path(env) => SOME(ep) &
	Absyn.strip_last(p) => packp & 
	ModUtil.path_equal(ep,packp) => true &
	Absyn.path_last_ident(p) => id &
	 lookup_class(env,Absyn.IDENT(id),msgflag) => (c,env')
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(_,_),msgflag) 
	  => (c, env')

	  (* Qualified name in non package*)
  rule	 lookup_class(env,Absyn.IDENT(pack),msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	Env.open_scope(env',encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,
				   Connect.empty_set,ci_state,c,false,[]) 
	  => (env'',cistate1) &
        not ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has to do additional check for encapsulated classes, see rule below *)

	 lookup_class(env'',path,msgflag) => (c',env''')
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path),msgflag) 
	  => (c', env''')

	  (* Qualified names in package*)
  rule	 lookup_class(env,Absyn.IDENT(pack),msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env1) &
	Env.open_scope(env1,encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &

	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,
				   Connect.empty_set,ci_state,c,false,[]) 
	  => (env4,cistate1) &
         ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has NOT to do additional check for encapsulated classes, see rule above *)
	  lookup_class(env4,path,msgflag) => (c',env5)
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path), msgflag) 
	  => (c', env5)

  rule	print "-lookup_class failed " &
 	Absyn.path_string path => s & 
        print s & print "\n" &
(* 	Env.print_env env & *)
(* 	Print.get_string => str & print "Env: " & print str & print "\n" & *)
(* 	Print.print_buf "#Error, class " & Print.print_buf s &  *)
(* 	Print.print_buf " not found.\n" & *)
	Debug.fprint("failtrace", "- lookup_class failed\n  - looked for ") &
 	Debug.fprint("failtrace",  s) &
	Debug.fprint("failtrace", "\n env:") &
	Debug.fcall("failtrace", Env.print_env, env) &
	Debug.fprint("failtrace", "\n")
	--------------
	lookup_class(env,path,true)=> fail 
end

(** relation: lookup_qualified_imported_class_in_env
 ** 
 ** This relation looks up imported class names on the qualified form: 
 ** import A.B;
 **)

relation lookup_qualified_imported_class_in_env:(Env.Env, Env.Env,
						 Absyn.Path) 
	  => (SCode.Class, Env.Env) =

	  (* Simple name *)
  rule	lookup_qualified_imported_class_in_frame(items,totenv,name) 
	  => (c,env') 
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,items,_,_,_)::fs),totenv,Absyn.IDENT(name)) 
	  => (c, env')

	  (* Qualified name *)
  rule	lookup_qualified_imported_class_in_frame(imps, totenv, pack) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_), env') &
       	Env.open_scope(env',encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
				   Connect.empty_set, ci_state,
			   c, false, []) 
	  => (env4,_) &  
	  lookup_class(env4,path,false) => (c',env'')
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,imps,_,_,_)::fs),totenv, Absyn.QUALIFIED(pack,path)) 
	  => (c', env'')

	  (* Search next scope *)
  rule	lookup_qualified_imported_class_in_env(fs, env, id) => (c, env')
	---------------------------------------------
	lookup_qualified_imported_class_in_env(f::fs, env, id) => (c, env')
end

(** relation: lookup_qualified_imported_var_in_frame
 ** author: PA
 ** 
 ** Looking up variables (constants) imported using qualified imports, 
 ** i.e. import Modelica.Constants.PI;
 **)
relation lookup_qualified_imported_var_in_frame: ( Env.Item list,Env.Env,
    SCode.Ident)
	  => (Types.Attributes, Types.Type, Types.Binding) =
	  (** For imported simple name, e.g. A, not possible to assert 
	   ** sub-path package **)
  rule	id = ident &
	Env.top_frame(env) => fr & 
	lookup_var([fr],Exp.CREF_IDENT(ident,[])) => (attr,ty,bind)
	------------------------------------------
	lookup_qualified_imported_var_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(Absyn.IDENT(id)))::fs,env,ident)
	    => (attr,ty,bind)

	  (* For imported qualified name, e.g. A.B.C, assert A.B is package*)
  rule	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	Exp.path_to_cref(path) => cref &
	lookup_var_in_packages([fr],cref) => (attr,ty,bind) &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath,true) =>  (c2, _) &
	assert_package(c2) 
	----------------------------------
	lookup_qualified_imported_var_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => (attr,ty,bind)

	  (* importing qualified name, If not package, error *)
  rule	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	Exp.path_to_cref(path) => cref &
	lookup_var_in_packages([fr],cref) => (attr,ty,bind) &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2,_) &
	not assert_package(c2) &
	Absyn.path_string strippath => str & 
	Error.add_message(Error.IMPORT_PACKAGES_ONLY,[str])
	----------------------------------
	lookup_qualified_imported_var_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => fail

	  (* Named imports*)
  rule	id = ident &
	Env.top_frame(env) => fr & 
	Exp.path_to_cref(path) => cref &
	lookup_var_in_packages([fr],cref) => (attr,ty,bind) &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	assert_package(c2) 
	---------------------------------- 
	lookup_qualified_imported_var_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => (attr,ty,bind)

	  (* Assert package for Named imports *)
  rule	id = ident &
	Env.top_frame(env) => fr & 
	Exp.path_to_cref(path) => cref &
	lookup_var_in_packages([fr],cref) => (attr,ty,bind) &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	not assert_package(c2) &
	Absyn.path_string strippath => str & 
	Error.add_message(Error.IMPORT_PACKAGES_ONLY,[str])
	---------------------------------- 
	lookup_qualified_imported_var_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => fail

	  (* Check next frame. *)
  rule	lookup_qualified_imported_var_in_frame(fs, env, ident) 
	  => (attr,ty,bind)
	-----------------------
	lookup_qualified_imported_var_in_frame(_::fs,env,ident) 
	  => (attr,ty,bind)
end

(** relation: more_lookup_unqualified_imported_var_in_frame
 ** 
 ** Helper relation for lookup_unqualified_imported_var_in_frame. Returns 
 ** true if there are unqualified imports that matches a sought constant.
 **)

relation more_lookup_unqualified_imported_var_in_frame: (Env.Item list, 
							 Env.Env, 
							 SCode.Ident)
	    => bool =

  rule	Env.top_frame(env) => fr & 
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
				   Connect.empty_set, ci_state, c, false, []) 
	  => (f::_,_) &
	  
	lookup_var_in_packages([f],Exp.CREF_IDENT(ident,[])) => (_,_,_)  
	-----------------------------------------------------
	more_lookup_unqualified_imported_var_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident) => true

  rule	more_lookup_unqualified_imported_var_in_frame(fs, env, ident) => res
	----------------------------------------------------------------------
	more_lookup_unqualified_imported_var_in_frame(_::fs, env, ident) => res

  axiom  more_lookup_unqualified_imported_var_in_frame([],_,_) => false
end

(** relation: lookup_unqualified_imported_var_in_frame
 ** 
 ** Find a variable from an unqualified import locally in a frame
 **)

relation lookup_unqualified_imported_var_in_frame: (Env.Item list, 
						    Env.Env, 
						    SCode.Ident)
	    => (Types.Attributes, Types.Type, 
		Types.Binding, bool (* unique*)) =
	    
  rule	Env.top_frame(env) => fr & 
	Exp.path_to_cref(path) => cref &
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, Connect.empty_set,
			   ci_state, c, false, [],false,false) 
	  => (_,f::_,_,_,_,_) &
	lookup_var_in_packages([f],Exp.CREF_IDENT(ident,[])) => (attr,ty,bind)  & 
	more_lookup_unqualified_imported_var_in_frame(fs, env, ident) => more &
	bool_not more => unique
	-------------------------------------------
	lookup_unqualified_imported_var_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident)
	    => (attr,ty,bind, unique)


  rule	lookup_unqualified_imported_var_in_frame(fs, env, ident) 
	  => (attr,ty,bind, unique)
	-----------------------
	lookup_unqualified_imported_var_in_frame(_::fs, env, ident) 
	  => (attr,ty,bind, unique)
end


(** relation: lookup_qualified_imported_class_in_frame
 ** 
 ** Helper relation to lookup_qualified_imported_class_in_env.
 **)

relation lookup_qualified_imported_class_in_frame: ( Env.Item list,Env.Env,
						    SCode.Ident)
	    => (SCode.Class, Env.Env) =

  rule	(* For imported paths A, not possible to assert sub-path package*)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],Absyn.IDENT(id),true) => (c, env') 
	------------------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(Absyn.IDENT(id)))::fs,env,ident)
	    => (c, env')
	    
  rule	(* For imported path A.B.C, assert A.B is package*)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath,true) =>  (c2, _) &
	assert_package(c2) 
	----------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => (c, env')

  rule	(* If not package, error *)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2,_) &
	not assert_package(c2) &
	Absyn.path_string strippath => str & 
	Error.add_message(Error.IMPORT_PACKAGES_ONLY,[str])
	----------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => fail

  rule	(* Named imports*)
	id = ident &
	Env.top_frame(env) => fr & 
(*	Print.print_buf "NAMED IMPORT, top frame:" & 
	Env.print_env [fr] &*)
	lookup_class([fr], path, true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	assert_package(c2) 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => (c, env')

  rule	(* Assert package for Named imports *)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	not assert_package(c2) &
	Absyn.path_string strippath => str & 
	Error.add_message(Error.IMPORT_PACKAGES_ONLY,[str])
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => fail
	    
  rule	lookup_qualified_imported_class_in_frame(fs, env, ident) 
	  => (c, env')
	-----------------------
	lookup_qualified_imported_class_in_frame(_::fs,env,ident) 
	  => (c, env')
end


(** relation: more_lookup_unqualified_imported_class_in_frame
 ** 
 ** Helper relation for lookup_unqualified_imported_class_in_frame
 **)

relation more_lookup_unqualified_imported_class_in_frame: (Env.Item list,
							   Env.Env, 
							   SCode.Ident)
	    => bool =

  rule	Env.top_frame(env) => fr & 
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
				   Connect.empty_set, ci_state, c, false, []) 
	  => (f::_,_) &
	lookup_class([f],Absyn.IDENT(ident),false) => (_,_)
	-----------------------------------------------------
	more_lookup_unqualified_imported_class_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident) => true

  rule	more_lookup_unqualified_imported_class_in_frame(fs, env, ident) => res
	----------------------------------------------------------------------
	more_lookup_unqualified_imported_class_in_frame(_::fs, env, ident) => res

  axiom  more_lookup_unqualified_imported_class_in_frame([],_,_) => false
end

(** relation: lookup_unqualified_imported_class_in_frame
 ** 
 ** Finds a class from an unqualified import locally in a frame
 **)

relation lookup_unqualified_imported_class_in_frame: (Env.Item list, 
						      Env.Env, 
						      SCode.Ident)
	    => (SCode.Class, Env.Env, bool (*unique*) ) =

  rule	Env.top_frame(env) => fr & 
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE,
				   Connect.empty_set, ci_state, c, false, []) 
	  => (f::fs',cistate1) &
	  (* Restrict import to the imported scope only, not its parents...*)
	lookup_class([f],Absyn.IDENT(ident),false) => (c',f'::_)  & 
	more_lookup_unqualified_imported_class_in_frame(fs, env, ident) => more &
	bool_not more => unique
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident)
	(* ...but return all parent scopes. *)
	    => (c', f'::fs', unique)


  rule	lookup_unqualified_imported_class_in_frame(fs, env, ident) 
	  => (c, env', unique)
	-----------------------
	lookup_unqualified_imported_class_in_frame(_::fs, env, ident) 
	  => (c, env', unique)
end

(** relation: lookup_record_constructor_class
 ** 
 ** Searches for a record constructor implicitly 
 ** defined by a record class.
 **)

relation lookup_record_constructor_class: (Env.Env,Absyn.Path) 
	  => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_env(env,path) => (c, env') 
	--------------------------------------
	lookup_record_constructor_class(env, path) => (c, env')

end

(** relation: complete_path
 **
 ** This relation takes a type name and an env and looks up the class.
 ** Then it determines the full path for the type, such that it can be 
 ** looked up from any environment.
 **)

relation complete_path: (Env.Env, Absyn.Path) => Absyn.Path =

  rule	(* Class found on top level. Nothing to complete. *)
	lookup_class(env,path,true) => (_,Env.FRAME(NONE,_,_,_,_,_,_)::_)
	----------------------------------------------
	complete_path(env,path) => path

  rule	lookup_class(env, path, true) 
	  => (SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,path) => path' 
	------------------
	complete_path(env,path as Absyn.IDENT(_)) => path'

  rule	lookup_class(env, Absyn.IDENT(pack), true) 
	  => (_,Env.FRAME(NONE,_,_,_,_,_,_)::_)
	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path 

  rule	lookup_class(env,(*Absyn.IDENT(pack)*)path,true) 
	  => (SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,Absyn.IDENT(id)) => path' 
	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path'

  rule	(*Debug.fprint("failtrace", "-complete_path failed\n env=") &
	Debug.fcall("failtrace", Env.print_env, env) & 
	Debug.fprint("failtrace", "\ntype: ")  &
	Absyn.path_string path => str & 
	Debug.fprint("failtrace", str )&
	Debug.fprint("failtrace", "\n" )*)
	--------------------
	complete_path(env,path) => fail

end

(* LS: when looking up qualified component reference, lookup_var only
checks variables when looking for the prefix, i.e. for Constants.PI
where Constants is a package and is implicitly instantiated, PI is not
found since Constants is not a variable (it is a type and/or class).

1) One option is to make it a variable and put it in the global frame.
2) Another option is to add a lookup rule that also looks in types.

Now implicitly instantiated packages exists both as a class and as a
type (see implicit_instantiation in Inst.rml). Is this correct?

lookup_var is modified to implement 2. Is this correct?

old lookup_var is changed to lookup_var_internal and a new lookup_var
is written, that first tests the old lookup_var, and if not found
looks in the types
 *)

(** relation: lookup_var
 **
 ** This relation tries to finds a variable in the environment
 ** 
 ** Arg1: The environment to search in
 ** Arg2: The variable to search for
 **)
relation lookup_var : (Env.Env, Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

	  (* try the old lookup_var *)
  rule	lookup_var_internal (env,cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr, ty, binding)

	(* then look in classes (implicitly instantiated packages)
	 *)
  rule	lookup_var_in_packages (env, cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr,ty,binding)

  rule	(*Debug.fprint("failtrace",  "- lookup_var failed\n")*)
	--------------------
	lookup_var(_,_) => fail
end

(** relation: lookup_var_internal
 **
 ** Helper relation to lookup_var. Searches the frames for variables.
 **)

relation lookup_var_internal : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(ht,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_internal (Env.FRAME(sid,ht,_,imps,_,_,_)::fs,ref) => (attr,ty,binding)

  rule	lookup_var_internal (fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var_internal (_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_in_packages
 **
 ** This relation is called when a lookup of a variable with qualified names
 ** does not have the first element as a component, e.g. A.B.C is looked up 
 ** where A is not a component. This implies that A is a class, and this 
 ** class should be temporary instantiated, and the lookup should 
 ** be performed within that class. I.e. the relation performs lookup of 
 ** variables in the class hierarchy.
 **
 ** Arg1: The environment to search in
 ** Arg2: The variable to search for
 **)

relation lookup_var_in_packages : (Env.Env, Exp.ComponentRef) 
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	(* Special case for looking up enumerations *)
	lookup_class(env, Absyn.IDENT(id1),false) 
	  => (c as SCode.CLASS(n,_,encflag,r as SCode.R_ENUMERATION,_), env2) &
	Env.open_scope(env2,encflag,SOME(n)) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env3,Types.NOMOD,Prefix.NOPRE,
			    Connect.empty_set,ci_state,c,false,[],
			    false,false) 
	  => (_,env5,_,_,types,_) &
	lookup_var_in_packages(env5,id2) => (attr,ty,bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id1, [], id2 as Exp.CREF_IDENT(_,_))) => (attr,ty,bind)

	(* First part of name is a class. *)
  rule	lookup_class(env, Absyn.IDENT(id),false) => (c as SCode.CLASS(n,_,encflag,r,_), env2) &
	Env.open_scope(env2,encflag,SOME(n)) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env3,Types.NOMOD,Prefix.NOPRE,
			    Connect.empty_set,ci_state,c,false,[],
			    true,false) 
	  => (_,env5,_,_,types,_) &
	lookup_var_in_packages(env5,cref) => (attr,ty,bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id, [], cref)) => (attr,ty,bind)

  rule	lookup_var_local(env,cr) => (attr,ty,bind)
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => (attr,ty,bind)

  rule	lookup_qualified_imported_var_in_frame(items,env,id) => (attr,ty,bind)
	--------------------------------------------------
	lookup_var_in_packages (env as (Env.FRAME(sid,_,_,items,_,_,_)::_), cr as Exp.CREF_IDENT(id, sb)) => (attr,ty,bind)
	
  rule	lookup_unqualified_imported_var_in_frame(items,env,id) => (attr,ty,bind,true)
	--------------------------------------------------
	lookup_var_in_packages (env as (Env.FRAME(sid,_,_,items,_,_,_)::_), cr as Exp.CREF_IDENT(id, sb)) => (attr,ty,bind)

  rule	lookup_unqualified_imported_var_in_frame(items,env,id) => (attr,ty,bind,false) &
	Error.add_message(Error.IMPORT_SEVERAL_NAMES,[id]) 
	--------------------------------------------------
	lookup_var_in_packages (env as (Env.FRAME(sid,_,_,items,_,_,_)::_), cr as Exp.CREF_IDENT(id, sb)) => fail

	(* Search parent scopes *)
  rule	lookup_var_in_packages(fs,cr) => (attr,ty,bind)
	------------------------------
	lookup_var_in_packages(f::fs,cr) => (attr,ty,bind)

  rule	(*Debug.fprint("failtrace",  "lookup_var_in_packages failed\n exp:" ) &
	Debug.fcall("failtrace", Exp.print_component_ref, cr) &
	Debug.fprint("failtrace", "\n")*)
	--------------------------------------------------
	lookup_var_in_packages (env, cr) => fail
end


(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **
 ** ----EXCEPTION---: When the topmost scope is the scope of a for loop, the lookup
 ** continues on the next scope. This to allow variables in the local scope to 
 ** also be found even if inside a for scope.
 **
 ** Arg1: The environment to search in
 ** Arg2: The variable to search for
 **)
relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(ht,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(sid,ht,_,_,_,_,_)::fs,ref) => (attr,ty,binding)

  rule	(* Exception, when in for loop scope allow search of next scope *)
	lookup_var_local(env,ref) => (attr,ty,binding)
	------------------------------
	lookup_var_local(Env.FRAME(SOME("$for loop scope$"),_,_,_,_,_,_)::env,ref) 
	  => (attr,ty,binding)
end


(** relation: lookup_ident_local
 **
 ** Searches for a variable in the local scope.
 **)
relation lookup_ident_local : (Env.Env, SCode.Ident) 
	  => (Types.Var,
	      (SCode.Element*Types.Mod) option,
	      bool,
	      Env.Env) (* component environment *)
	=

  rule  lookup_var2(ht, id) => (fv,c,i,env)
	----------------------------
	lookup_ident_local(Env.FRAME(sid,ht,_,_,_,_,_)::_, id) => (fv,c,i,env)

end

(** relation: lookup_ident
 **
 ** Same as lookup_ident_local, except check all frames 
 **
 **)
relation lookup_ident : (Env.Env, SCode.Ident) 
	  => (Types.Var,(SCode.Element*Types.Mod) option,bool) =

  rule	lookup_var2(ht, id) => (fv,c,i,_) 
	----------------------------
	lookup_ident(Env.FRAME(sid,ht,_,_,_,_,_)::_, id) => (fv,c,i)

  rule	lookup_ident(rest,id) => (fv,c,i)
	---------------------------------
	lookup_ident(_::rest,id) => (fv,c,i)

end


(**  Function lookup *)

(** relation: lookup_functions_in_env
 **
 ** Returns a list of types that the function has. 
 **
 **)
relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) =

  axiom	lookup_functions_in_env([],id) => []

  rule	(* Check for builtin operators*)
	Static.elab_builtin_handler id => _ &
	Env.top_frame(env) => Env.FRAME(sid,ht,httypes,_,_,_,_) &
	lookup_functions_in_frame(ht,httypes,env,id) => reslist
	----------------------------------
	lookup_functions_in_env(env, iid as Absyn.IDENT(id)) => reslist

  rule	(* Check for special builtin operators that can not be represented
	  in environment like for instance cardinality. *)
	Static.elab_builtin_handler_generic id => _ &
	create_generic_builtin_functions(env,id) => reslist 
	----------------------------------
	lookup_functions_in_env(env, iid as Absyn.IDENT(id)) => reslist

  rule	lookup_functions_in_frame(ht,httypes,env,id) => c1 &
	lookup_functions_in_env(fs,iid) => c2 &
	list_append(c1,c2) => reslist
	---------------------
	lookup_functions_in_env(env as (Env.FRAME(sid,ht,httypes,_,_,_,_)::fs), iid as Absyn.IDENT(id)) => reslist

  rule	(* For qualified function names, e.g. Modelica.Math.sin *)
	lookup_class(env, Absyn.IDENT(pack), false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	(* Instantiate implicit (last argument = true) *)
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
			   Connect.empty_set, ci_state, c, false, 
			   [], true,false) 
	  => (_,env'',_,cistate1,_,_) &
	  lookup_functions_in_env(env'',path) => reslist
	-------------------------------
	lookup_functions_in_env(env as (Env.FRAME(sid,ht,httypes,_,_,_,_)::fs), iid as Absyn.QUALIFIED(pack,path)) 
	  => reslist

  rule	(* If we find class that is function. *)
	lookup_class(env(*[f]*), path, false) 
	  => (c as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),env') &
	Inst.implicit_function_type_instantiation(env',c) 
	  => (env as (Env.FRAME(sid,ht,httypes,_,_,_,_)::_)) &
	lookup_functions_in_frame(ht,httypes,env,id) => res
	---------------------------
	lookup_functions_in_env(env (*f::_*),path as Absyn.IDENT(id)) => res
	  
	(* Did not match. Continue*)
  rule	lookup_functions_in_env(fs,id) => c
	---------------------
	lookup_functions_in_env(f::fs,id) => c

  rule	Debug.fprintln("failtrace", "lookup_functions_in_env failed")
	-------------------------------------------------------------
	lookup_functions_in_env (_,_) => fail
end

(** relation: create_generic_builtin_functions
 ** author: PA
 **
 ** This relation creates function types on-the-fly for special builtin 
 ** operators/functions which can not be represented in the builtin 
 ** environment.
 **)
relation create_generic_builtin_functions: (Env.Env, string (* function_name*)) => Types.Type list =

	(* cardinality *)
  axiom	create_generic_builtin_functions(env,"cardinality") => [ (Types.T_FUNCTION([("x",(Types.T_COMPLEX(ClassInf.CONNECTOR("$$"),[],NONE),NONE))],(Types.T_INTEGER([]),NONE)),NONE) ]

end

(** - Internal relations *)

(** Type lookup *)

(** relation: lookup_type_in_env
 ** 
 **
 **)
relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type,Env.Env) =

  rule	lookup_type_in_frame(ht,httypes,env,id) => (c,env')
	---------------------
	lookup_type_in_env(env as (Env.FRAME(sid,ht,httypes,_,_,_,_)::fs),Absyn.IDENT(id)) => (c,env')

  rule	lookup_type_in_env(fs,id) => (c,env')
	-------------------------------------
	lookup_type_in_env(f::fs,id) => (c,f::env')

end

(** relation: lookup_type_in_frame
 ** 
 ** Searches a frame for a type.
 **)
relation lookup_type_in_frame: (Env.BinTree, (* Classes and vars*)
				Env.BinTree, (* types *)
				 Env.Env,
				 SCode.Ident)
	  => (Types.Type, Env.Env) =

  rule	Env.tree_get(httypes,id,Env.myhash) => Env.TYPE(t::_)
	---------------------------------------------------------
	lookup_type_in_frame(ht,httypes,env, id) => (t,env)

  rule	Env.tree_get(ht,id,Env.myhash) => Env.VAR(_,_,_,_) &
	Error.add_message(Error.LOOKUP_TYPE_FOUND_COMP,[id])
	------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => fail

  rule	(* Each time a record constructor function is looked up, this rule will create the function.*)
	(* An improvement (perhaps needing lot of code) is to add the function to the environment, which is *)
	(* returned from this relation.*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(n,_,_,SCode.R_RECORD,_),_) &
	Inst.make_fully_qualified(env,Absyn.IDENT(n)) => fpath &
	build_record_constructor_varlst (cdef,env) => varlst &
	Types.make_function_type(fpath,varlst) => ftype 
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) 
	    => (ftype,env)

  rule	(* If we found class that is function *)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),cenv) &
	Inst.implicit_function_instantiation(cenv,Types.NOMOD,Prefix.NOPRE,
					     Connect.empty_set,cdef,[],false) 
	  => (env',_) &
	lookup_type_in_env(env',Absyn.IDENT(id)) => (ty,env'')
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => (ty,env'')

  rule	(* If we found class that is external function *)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_EXT_FUNCTION,_),cenv) &
	Inst.implicit_function_type_instantiation(cenv,cdef) => env' &
	lookup_type_in_env(env',Absyn.IDENT(id)) => (ty,env'')
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => (ty,env'')
end
(**)


(** relation: lookup_functions_in_frame
 ** 
 ** This actually only looks up the function name and find all
 ** corresponding types that have this function name.
 ** 
 **)
relation lookup_functions_in_frame: (Env.BinTree, (*Classes and vars*)
				     Env.BinTree, (*Types *)
				     Env.Env,
				     SCode.Ident)
	  => Types.Type list =

  rule	Env.tree_get(httypes, id, Env.myhash) => Env.TYPE(tps)
	---------------------------------------------------------
	lookup_functions_in_frame(ht,httypes, env, id) => tps

  rule	Env.tree_get(ht, id, Env.myhash) => Env.VAR(_,_,_,_) &
	Error.add_message(Error.LOOKUP_TYPE_FOUND_COMP,[id])
	------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => fail

  rule	Env.tree_get(ht, id, Env.myhash) => Env.CLASS(cdef as SCode.CLASS(n,_,_,SCode.R_RECORD,_),cenv) &
	build_record_constructor_varlst (cdef,env) => varlst &
	Inst.make_fully_qualified(cenv,Absyn.IDENT(n)) => fpath &
	Types.make_function_type(fpath,varlst) => ftype
	----------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => [ftype]

  rule	(* If found class that is function.*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),cenv) &
	Inst.implicit_function_type_instantiation(cenv,cdef)  => env' &
	lookup_functions_in_env(env',Absyn.IDENT(id)) => tps
	----------------------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => tps

  rule	(* If found class that is external function.*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_EXT_FUNCTION,_),cenv) &
	Inst.implicit_function_type_instantiation(cenv,cdef) => env' &
	lookup_functions_in_env(env',Absyn.IDENT(id)) => tps
	----------------------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => tps
end

(** relation: lookup_recconst_in_env
 ** 
 ** Helper relation to lookup_record_constructor_class. Searches
 ** The environment for record constructors.
 ** 
 **)
relation lookup_recconst_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_frame(ht,env,id) => (c, _) 
	---------------------
	lookup_recconst_in_env(env as (Env.FRAME(sid,ht,_,imps,_,_,_)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_recconst_in_env(fs,id) => (c, _)
	---------------------
	lookup_recconst_in_env(f::fs,id) => (c, f::fs)
end

(** relation: lookup_recconst_in_frame
 **
 ** This relation lookups the implicit record constructor class (function) 
 ** of a record in a frame
 **)
relation lookup_recconst_in_frame: (Env.BinTree, Env.Env, SCode.Ident)
	  => (SCode.Class, Env.Env) =
	  
  rule	Env.tree_get(ht,id,Env.myhash) => Env.VAR(_,_,_,_) &
	Error.add_message(Error.LOOKUP_TYPE_FOUND_COMP,[id])
	------------------------------------
	lookup_recconst_in_frame(ht,env,id) => fail

  rule	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_RECORD,_),_) &
	build_record_constructor_class (cdef,env) => cdef 
	----------------------------------------
	lookup_recconst_in_frame(ht,env,id) => (cdef,env)
end

(** relation: build_record_constructor_class
 ** 
 ** Creates the record constructor class, i.e. a function, from the record
 ** class given as argument.
 **)

relation build_record_constructor_class :(SCode.Class (* record class *), 
					  Env.Env) 
	  => SCode.Class (* function class *) =

  rule	build_record_constructor_elts(elts,env) => funcelts &
	build_record_constructor_result_elt(elts,id,env) => reselt
	---------------------------------------------------
	build_record_constructor_class (cl as SCode.CLASS(id,_,_,restr,SCode.PARTS(elts,_,_,_,_,_)),env) 
	    => SCode.CLASS(id,false,false,SCode.R_FUNCTION,SCode.PARTS(reselt::funcelts,[],[],[],[],NONE))
end
	
(** relation: build_record_constructor_elts
 ** 
 ** Helper relation to build_record_constructor_class. Creates the elements
 ** of the function class.
 **)

relation build_record_constructor_elts: (SCode.Element list, Env.Env) 
	  => SCode.Element list =

  rule	build_record_constructor_elts (rest,env) => res
	-------------------------------------------
	build_record_constructor_elts((comp as SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,dir),tp,mod,bc,comment))::rest,env)
	    => SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,Absyn.INPUT),tp,mod,bc,comment)::res
  axiom	build_record_constructor_elts([],_) => []
end
	
(** relation: build_record_constructor_result_elt
 ** 
 ** This relation builds the result element of a record constructor function, 
 ** i.e. the returned variable
 ** 
 **)
relation build_record_constructor_result_elt: (SCode.Element list, SCode.Ident, Env.Env) => SCode.Element =
	
  rule	build_record_constructor_result_mod(elts) => submodlst
	-------------------------------------------------
	build_record_constructor_result_elt (elts,id,env) 
	    => SCode.COMPONENT("result",false,false,false,SCode.ATTR([],false,SCode.RW,SCode.VAR,Absyn.OUTPUT),Absyn.IDENT(id),SCode.MOD(false,Absyn.NON_EACH,submodlst,NONE),NONE,NONE)
end
	
(** relation: build_record_constructor_result_mod
 **
 ** This relation builds up the modification list for the output element of a record constructor.
 ** Example: 
 **   record foo
 **      Real x;
 **      String y;
 **      end foo;
 **  => modifier list become 'result.x=x, result.y=y'
 **)

relation build_record_constructor_result_mod: (SCode.Element list) 
	  => SCode.SubMod list =
	
  rule	build_record_constructor_result_mod(rest) => restmod
	---------------------------------------------------
	build_record_constructor_result_mod (SCode.COMPONENT(id,_,_,_,_,_,_,_,_)::rest) 
	    => SCode.NAMEMOD("result",SCode.MOD(false,Absyn.NON_EACH,[SCode.NAMEMOD(id,SCode.MOD(false,Absyn.NON_EACH,[],SOME(Absyn.CREF(Absyn.CREF_IDENT(id,[])))))],NONE))::restmod

  axiom	build_record_constructor_result_mod([]) => []
end

(** relation: build_record_constructor_varlst
 **
 ** This relation takes a class  (`SCode.Class') which holds a definition 
 ** of a record and builds a list of variables of the record used for 
 ** constructing a record constructor function.
 **)

relation build_record_constructor_varlst : (SCode.Class,Env.Env) 
	  => Types.Var list =

  rule	build_varlst_from_elts(elts,env) => inputvarlst &
	Inst.inst_class(env, Types.NOMOD, Prefix.NOPRE, 
			Connect.empty_set, cl, [], 
			true (* FIXME: impl*),Inst.TOP_CALL) 
	  => (_,_,_,ty,_) 
	--------------------------------------
	build_record_constructor_varlst (cl as SCode.CLASS(_,_,_,_,SCode.PARTS(elts,_,_,_,_,_)),env) 
	(* Add the return type of the record constructor *)
	    => Types.VAR("result",Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.OUTPUT),false,ty,Types.UNBOUND)::inputvarlst

  rule	Debug.fprint("failtrace","build_record_constructor_varlst failed\n")
	-----------------------
	build_record_constructor_varlst(_,_) => fail
end

(** relation: build_varlst_from_elts
 ** 
 ** Helper relation to build_record_constructor_varlst
 **)

relation build_varlst_from_elts: (SCode.Element list,Env.Env ) 
=> Types.Var list =

  rule	build_varlst_from_elts(rest,env) => vars &
  (*P.A Here we need to do a lookup of the type. Therefore we need the env passed along from lookup_xxxx function. *)
	Inst.inst_record_constructor_elt(env,comp, true (* FIXME: impl*) ) => var
	-------------------------------------
	build_varlst_from_elts ((comp as SCode.COMPONENT(_,_,_,_ ,_,_,_,_,_))::rest,env) 
	    => var::vars

  axiom	build_varlst_from_elts ([],_) => []

  rule	(*Debug.fprint("failtrace", "- build_varlst_from_elts failed!\n")*)
	----------------------------------------------
	build_varlst_from_elts(_,_) => fail
end

(**  Class lookup *)

(** relation: is_in_builtin_env
 **
 ** Returns true if function can be found in the builtin environment.
 **)

relation is_in_builtin_env: Absyn.Path => bool =

  rule	Builtin.initial_env() => i_env &
	lookup_functions_in_env(i_env, path) => []
	-----------------------------------------------
	is_in_builtin_env(path) => false

  rule	Builtin.initial_env() => i_env &
	lookup_functions_in_env(i_env, path) => _
	------------------------------------------------
	is_in_builtin_env(path) => true

  rule	Debug.fprintln("failtrace", "is_in_builtin_env failed")
	-------------------------------------------------------
	is_in_builtin_env(path) => fail
end
(** relation: lookup_class_in_env
 ** 
 ** Helper relation to lookup_class. Searches the environment for the class.
 **)

relation lookup_class_in_env: (Env.Env,Absyn.Path,bool) 
	  => (SCode.Class, Env.Env) =

  rule	(*print "looking in env for " & print id &*)
	  lookup_class_in_frame(frame,frame::fs,id,msg) => (c,env')  
	---------------------
	lookup_class_in_env(env as (frame::fs),Absyn.IDENT(id),msg)
	    => (c,env')
	
  rule	(* Special case if looking up the class that -is- encapsulated. That must be allowed. *)
         id = sid &
	lookup_class_in_env(fs,aid,true) => (c,env)
	---------------------
	lookup_class_in_env(env as Env.FRAME(SOME(sid),_,_,_,_,_,true)::fs, aid as Absyn.IDENT(id),_) 
	  => (c,env)

  rule	 Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_) &
	Env.print_env_path_str(env) => scope &
	 Error.add_message(Error.LOOKUP_ERROR,[id,scope])
	---------------------
	lookup_class_in_env(env as Env.FRAME(SOME(sid),_,_,_,_,_,true)::fs, aid as Absyn.IDENT(id),true) => fail

  rule	 Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_)
	---------------------
	lookup_class_in_env(Env.FRAME(sid,_,_,_,_,_,true)::fs, 
			    aid as Absyn.IDENT(id),false) => fail

 rule	 Builtin.initial_env() => i_env & 
        lookup_class_in_env(  i_env, aid,msgflag)=> (c,env')
       	---------------------------------------------------
	lookup_class_in_env(Env.FRAME(sid,_,_,_,_,_,true)::fs, 
			    aid as Absyn.IDENT(id),msgflag ) => (c,env')

  rule	 lookup_class_in_env(fs,id,msgflag) => (c, env')
	-----------------------------------------------
	lookup_class_in_env((f as Env.FRAME(sid,_,_,_,_,_,false))::fs,
			    id ,msgflag ) 
	  => (c, env')
end


(** relation: lookup_type_in_class
 **
 ** This relation looks up an type inside a class. The outer class can be 
 ** a package. Environment is passed along in case it needs to be modified.
 ** bool determines whether we restrict lookup for encapsulated class (true).
 **  
 **)
relation lookup_type_in_class: (Env.Env, SCode.Class, Absyn.Path, bool) 
	  => (Types.Type, Env.Env) =

  rule	lookup_type_in_env(env, classname(*, true*)) => (tp, env')
        (* encapsulated does not matter, _ *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (tp, env')

  rule	(* If not found, look for classdef that is function and instantiate. *)
	lookup_class_in_env(env, classname, false) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_FUNCTION, _), env') &
	Inst.implicit_function_type_instantiation(env', c)  => env'' &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* If not found, look for classdef that is external function and instantiate. *)
	lookup_class_in_env(env, classname, false) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_EXT_FUNCTION, _), env') &
	Inst.implicit_function_type_instantiation(env', c) => env'' &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env(env, Absyn.IDENT(c1),false) 
	  => (c as SCode.CLASS(id,_,encflag as true,restr,_) ,env) &
       	Env.open_scope(env, encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, 
			   Connect.empty_set, ci_state, c, false, [], 
			   true,false) 
	  => (_,env3,_,_,_,_) &
  	lookup_type_in_class (env3, c, p1, false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => (t, env5)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) 
	  => (c as SCode.CLASS(id,_,encflag as false,restr,_) ,env) &
	  Absyn.path_string(path) => str &
	Error.add_message(Error.LOOKUP_ENCAPSULATED_RESTRICTION_VIOLATION,[str])
	-------------------------------------------
	lookup_type_in_class (env, cdef, path as Absyn.QUALIFIED(c1,p1),true) 
	  => fail

  rule	(* Lookup not restricted to encapsulated elts. only *)
	lookup_class_in_env (env, Absyn.IDENT(c1), false) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_) ,env1) &
       	Env.open_scope(env1,encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env2') &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,
			   Connect.empty_set,ci_state,c,false,[],true,false) 
	  => (_,env4,_,_,_,_) &
  	lookup_type_in_class (env4,c,p1,false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),false) => (t, env5)

  rule	(*Debug.fprint("failtrace",cname) &
	Debug.fprint("failtrace", "\n  - looked for: ") & Absyn.path_string path => s & 
	Debug.fprint("failtrace", s) & 
	Debug.fprint("failtrace", "\n")*)
	-------------------------------
	lookup_type_in_class(_, SCode.CLASS(cname,_,_,_,_), path, _) => fail
end
	
(** relation: lookup_class_in_frame
 ** 
 ** Search for a class within one frame. 
 **)

relation lookup_class_in_frame: (Env.Frame,Env.Env,
				 SCode.Ident,bool)
	  => (SCode.Class, Env.Env) =


  rule	(*print "looking for class " & print id & print " in frame\n" &*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(c,env) 
	(*& print "found " & print id & print "\n" *)
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,ht,_,_,_,_,_),totenv,id,_) 
	  => (c, totenv)


  rule	Env.tree_get(ht,id,Env.myhash) => Env.VAR(_,_,_,_) &
	Error.add_message(Error.LOOKUP_TYPE_FOUND_COMP,[id]) 
	------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,ht,_,_,_,_,_),_,id,true) => fail

	(* Search base classes *)
  rule	lookup_class(bcframes,Absyn.IDENT(name),false) => (c,env)
	--------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(_,_,_,_,bcframes,_,_),totenv, name,_) 
	  => (c, env)

  rule	lookup_qualified_imported_class_in_frame(items,totenv,name) 
	  => (c,env') 
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,_,_,items,_,_,_),totenv, name,_) 
	  => (c, env')

  rule	lookup_unqualified_imported_class_in_frame(items, totenv, name) 
	  => (c, env', true (*unique*) )
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,_,_,items,_,_,_),totenv, name,_) 
	  => (c, env')

  rule	lookup_unqualified_imported_class_in_frame(items, totenv, name) 
	  => (c, env', false (*unique*) ) &
	Error.add_message(Error.IMPORT_SEVERAL_NAMES,[name]) 
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,_,_,items,_,_,_),totenv, name,_) 
	  => fail
end

(** relation: lookup_var2
 ** 
 ** Helper relation to lookup_var_f and lookup_ident.
 ** 
 **)
relation lookup_var2 : (Env.BinTree, SCode.Ident)
	  => (Types.Var, (SCode.Element*Types.Mod) option, bool, Env.Env) =

  rule	Env.tree_get(ht, id, Env.myhash) => Env.VAR(fv,c,i,env)
	--------------------------------------------
	lookup_var2(ht,id) => (fv,c,i,env)
end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)
relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(dim,t),p),
			 Exp.WHOLEDIM::ys)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),p),
			 Exp.SLICE(Exp.ARRAY(_,_,se))::ys)
	  => ((Types.T_ARRAY(Types.DIM(SOME(dim)),t'),p))

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

	(* HJ: Subscrits needn't be constant. No range-checking can
	       be done *)

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.SLICE(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.SLICE(_)::ys) => t'

  rule	Debug.fprint("failtrace", "- check_subscripts failed ( ") &
	Debug.fcall("failtrace", Types.print_type, t) & 
	Debug.fprint("failtrace", ")\n")
	-----------------------------------
	check_subscripts(t,s) => fail

end

(** relation: lookup_in_var
 ** 
 ** Searches for the rest of a qualified variable when first part of
 ** variable name has been found.
 **)

relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_)) &
	Error.add_message(Error.REFERENCE_PROTECTED,[id])
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	(*Debug.fprint("failtrace", "- lookup_in_var failed\n")*)
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)
relation lookup_var_f : (Env.BinTree,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var2(ht, id)
	  => (Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind),_,_,_) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(ht,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

	(* Qualified variables looked up through component environment. *)
  rule  lookup_var2(ht,id) 
	  => (Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind),_,_,compenv) &
	  lookup_var(compenv,ids) => (attr,ty,binding) 
	----------------------------------------------
	lookup_var_f(ht,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty,binding)

(*  rule	lookup_var2(ht, id) 
	  => (Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_),_,_) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(ht,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)
 *)

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,_,SCode.R_PACKAGE,_)

end

















