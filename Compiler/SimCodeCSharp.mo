package SimCodeCSharp

public import Tpl;

public import SimCode;
public import BackendDAE;
public import System;
public import Absyn;
public import DAE;
public import ClassInf;
public import Util;
public import ComponentReference;
public import Expression;
public import RTOpts;
public import Settings;

public function translateModel
  input Tpl.Text in_txt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_simCode)
    local
      Tpl.Text txt;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = SimCode.MODELINFO(name = i_modelInfo_name))) )
      local
        Absyn.Path i_modelInfo_name;
        SimCode.SimCode i_simCode;
        Tpl.Text txt_1;
        Tpl.Text txt_0;
      equation
        txt_0 = simulationFile(Tpl.emptyTxt, i_simCode);
        txt_1 = dotPath(Tpl.emptyTxt, i_modelInfo_name);
        txt_1 = Tpl.writeTok(txt_1, Tpl.ST_STRING(".cs"));
        Tpl.textFile(txt_0, Tpl.textString(txt_1));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end translateModel;

protected function fun_14
  input Tpl.Text in_txt;
  input String in_it;
  input Tpl.Text in_i_fbody;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it, in_i_fbody)
    local
      Tpl.Text txt;
      Tpl.Text i_fbody;

    case ( txt,
           "",
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//** No functions **"));
      then txt;

    case ( txt,
           _,
           i_fbody )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("#region Functions\n"));
        txt = Tpl.writeText(txt, i_fbody);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("#endregion"));
      then txt;
  end matchcontinue;
end fun_14;

public function simulationFile
  input Tpl.Text in_txt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_simCode)
    local
      Tpl.Text txt;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = (i_modelInfo as SimCode.MODELINFO(name = i_modelInfo_name)), nonStateContEquations = i_nonStateContEquations, removedEquations = i_removedEquations, nonStateDiscEquations = i_nonStateDiscEquations, zeroCrossings = i_zeroCrossings, allEquations = i_allEquations, helpVarInfo = i_helpVarInfo, allEquationsPlusWhen = i_allEquationsPlusWhen, stateContEquations = i_stateContEquations, initialEquations = i_initialEquations, residualEquations = i_residualEquations, parameterEquations = i_parameterEquations)) )
      local
        list<SimCode.SimEqSystem> i_parameterEquations;
        list<SimCode.SimEqSystem> i_residualEquations;
        list<SimCode.SimEqSystem> i_initialEquations;
        list<SimCode.SimEqSystem> i_stateContEquations;
        list<SimCode.SimEqSystem> i_allEquationsPlusWhen;
        list<SimCode.HelpVarInfo> i_helpVarInfo;
        list<SimCode.SimEqSystem> i_allEquations;
        list<BackendDAE.ZeroCrossing> i_zeroCrossings;
        list<SimCode.SimEqSystem> i_nonStateDiscEquations;
        list<SimCode.SimEqSystem> i_removedEquations;
        list<SimCode.SimEqSystem> i_nonStateContEquations;
        Absyn.Path i_modelInfo_name;
        SimCode.ModelInfo i_modelInfo;
        SimCode.SimCode i_simCode;
        String str_1;
        Tpl.Text i_fbody;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("// Simulation code for "));
        txt = dotPath(txt, i_modelInfo_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    " generated by the OpenModelica Compiler.\n",
                                    "\n",
                                    "using System;\n",
                                    "using Bodylight.Solvers;\n",
                                    "namespace Bodylight.Models"
                                }, false));
        txt = modelNameSpace(txt, i_modelInfo_name);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("{\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("public partial class "));
        txt = lastIdentOfPath(txt, i_modelInfo_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    " : DAESystem\n",
                                    "{\n",
                                    "\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = modelDataMembers(txt, i_modelInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        i_fbody = simulationFunctionsBody(Tpl.emptyTxt, i_simCode);
        str_1 = Tpl.textString(i_fbody);
        txt = fun_14(txt, str_1, i_fbody);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionDaeOutput(txt, i_nonStateContEquations, i_removedEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionDaeOutput2(txt, i_nonStateDiscEquations, i_removedEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInput(txt, i_modelInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionOutput(txt, i_modelInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionZeroCrossing(txt, i_zeroCrossings, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionHandleZeroCrossing(txt, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionUpdateDependents(txt, i_allEquations, i_helpVarInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionUpdateDepend(txt, i_allEquationsPlusWhen, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionOnlyZeroCrossing(txt, i_zeroCrossings, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionStoreDelayed(txt, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionWhen(txt, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionOde(txt, i_stateContEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInitial(txt, i_initialEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInitialResidual(txt, i_residualEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionExtraResiduals(txt, i_allEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionBoundParameters(txt, i_parameterEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionCheckForDiscreteVarChanges(txt, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end simulationFile;

public function modelNameSpace
  input Tpl.Text in_txt;
  input Absyn.Path in_i_modelName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_modelName)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      local
        Absyn.Path i_path;
        Absyn.Ident i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = Tpl.writeStr(txt, i_name);
        txt = modelNameSpace(txt, i_path);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      local
        Absyn.Path i_path;
      equation
        txt = modelNameSpace(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end modelNameSpace;

public function lastIdentOfPath
  input Tpl.Text in_txt;
  input Absyn.Path in_i_modelName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_modelName)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.QUALIFIED(path = i_path) )
      local
        Absyn.Path i_path;
      equation
        txt = lastIdentOfPath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name) )
      local
        Absyn.Ident i_name;
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      local
        Absyn.Path i_path;
      equation
        txt = lastIdentOfPath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end lastIdentOfPath;

protected function lm_18
  input Tpl.Text in_txt;
  input list<SimCode.RecordDeclaration> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_rd :: rest,
           i_simCode )
      local
        list<SimCode.RecordDeclaration> rest;
        SimCode.RecordDeclaration i_rd;
      equation
        txt = recordDeclaration(txt, i_rd, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_18(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.RecordDeclaration> rest;
      equation
        txt = lm_18(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_18;

protected function fun_19
  input Tpl.Text in_txt;
  input SimCode.Function in_i_fn;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_fn, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_fn as SimCode.FUNCTION(recordDecls = i_recordDecls)),
           i_simCode )
      local
        list<SimCode.RecordDeclaration> i_recordDecls;
        SimCode.Function i_fn;
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_18(txt, i_recordDecls, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = functionBodyRegularFunction(txt, i_fn, i_simCode);
      then txt;

    case ( txt,
           SimCode.EXTERNAL_FUNCTION(name = i_name),
           _ )
      local
        Absyn.Path i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EXTERNAL_FUN_NOT_IMPLEMETED(name="));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           SimCode.RECORD_CONSTRUCTOR(name = i_name),
           _ )
      local
        Absyn.Path i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RECORD_CONSTRUCTOR_NOT_IMPLEMENTED(name="));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_FUNCTION"));
      then txt;
  end matchcontinue;
end fun_19;

protected function lm_20
  input Tpl.Text in_txt;
  input list<SimCode.Function> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_fn :: rest,
           i_simCode )
      local
        list<SimCode.Function> rest;
        SimCode.Function i_fn;
      equation
        txt = fun_19(txt, i_fn, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_20(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.Function> rest;
      equation
        txt = lm_20(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_20;

public function simulationFunctionsBody
  input Tpl.Text in_txt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_simCode)
    local
      Tpl.Text txt;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = SimCode.MODELINFO(name = _), functions = i_functions)) )
      local
        list<SimCode.Function> i_functions;
        SimCode.SimCode i_simCode;
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_20(txt, i_functions, i_simCode);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end simulationFunctionsBody;

protected function lm_22
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_var as SimCode.VARIABLE(name = i_var_name)) :: rest,
           i_simCode )
      local
        list<SimCode.Variable> rest;
        DAE.ComponentRef i_var_name;
        SimCode.Variable i_var;
      equation
        txt = varType(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = crefStr(txt, i_var_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_22(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.Variable> rest;
      equation
        txt = lm_22(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_22;

public function recordDeclaration
  input Tpl.Text in_txt;
  input SimCode.RecordDeclaration in_i_recDecl;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_recDecl, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.RECORD_DECL_FULL(name = i_name, variables = i_variables),
           i_simCode )
      local
        list<SimCode.Variable> i_variables;
        String i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("struct "));
        txt = Tpl.writeStr(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_22(txt, i_variables, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("};"));
      then txt;

    case ( txt,
           SimCode.RECORD_DECL_DEF(path = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RECORD_DECL_DEF_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_RECORD_DECL_"));
      then txt;
  end matchcontinue;
end recordDeclaration;

protected function fun_24
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_i_outVars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_outVars)
    local
      Tpl.Text txt;

    case ( txt,
           i_fv :: _ )
      local
        SimCode.Variable i_fv;
      equation
        txt = varType(txt, i_fv);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("void"));
      then txt;
  end matchcontinue;
end fun_24;

protected function fun_25
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_i_outVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_outVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_fv as SimCode.VARIABLE(name = i_fv_name)) :: _,
           i_simCode )
      local
        DAE.ComponentRef i_fv_name;
        SimCode.Variable i_fv;
      equation
        txt = crefStr(txt, i_fv_name, i_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_25;

protected function lm_26
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           i_simCode )
      local
        list<SimCode.Variable> rest;
        SimCode.Variable i_var;
      equation
        txt = varInit(txt, i_var, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_26(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.Variable> rest;
      equation
        txt = lm_26(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_26;

protected function lm_27
  input Tpl.Text in_txt;
  input list<SimCode.Statement> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           i_simCode )
      local
        list<SimCode.Statement> rest;
        SimCode.Statement i_stmt;
      equation
        txt = funStatement(txt, i_stmt, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_27(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.Statement> rest;
      equation
        txt = lm_27(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_27;

protected function lm_28
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           i_simCode )
      local
        list<SimCode.Variable> rest;
        SimCode.Variable i_var;
      equation
        txt = funArgDefinition(txt, i_var, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_28(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.Variable> rest;
      equation
        txt = lm_28(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_28;

protected function fun_29
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_i_outVars;
  input Tpl.Text in_i_retVar;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_outVars, in_i_retVar)
    local
      Tpl.Text txt;
      Tpl.Text i_retVar;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           _,
           i_retVar )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("return "));
        txt = Tpl.writeText(txt, i_retVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;
  end matchcontinue;
end fun_29;

public function functionBodyRegularFunction
  input Tpl.Text in_txt;
  input SimCode.Function in_i_fn;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_fn, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.FUNCTION(name = i_name, outVars = i_outVars, variableDeclarations = i_variableDeclarations, body = i_body, functionArguments = i_functionArguments),
           i_simCode )
      local
        list<SimCode.Variable> i_functionArguments;
        list<SimCode.Statement> i_body;
        list<SimCode.Variable> i_variableDeclarations;
        list<SimCode.Variable> i_outVars;
        Absyn.Path i_name;
        Tpl.Text i_bodyPart;
        Tpl.Text i_varInits;
        Tpl.Text i_retVar;
        Tpl.Text i_retType;
        Tpl.Text i_fname;
      equation
        System.tmpTickReset(1);
        i_fname = underscorePath(Tpl.emptyTxt, i_name);
        i_retType = fun_24(Tpl.emptyTxt, i_outVars);
        i_retVar = fun_25(Tpl.emptyTxt, i_outVars, i_simCode);
        i_varInits = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(1, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        i_varInits = lm_26(i_varInits, i_variableDeclarations, i_simCode);
        i_varInits = Tpl.popIter(i_varInits);
        i_bodyPart = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        i_bodyPart = lm_27(i_bodyPart, i_body, i_simCode);
        i_bodyPart = Tpl.popIter(i_bodyPart);
        txt = Tpl.writeText(txt, i_retType);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" _"));
        txt = Tpl.writeText(txt, i_fname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_28(txt, i_functionArguments, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ")\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_varInits);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, i_bodyPart);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "_return:\n"
                                }, true));
        txt = fun_29(txt, i_outVars, i_retVar);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "\n"
                                }, true));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionBodyRegularFunction;

protected function lm_31
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preDimsExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preDimsExp;
algorithm
  (out_txt, out_i_preDimsExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preDimsExp)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preDimsExp;

    case ( txt,
           {},
           _,
           i_preDimsExp )
      then (txt, i_preDimsExp);

    case ( txt,
           i_exp :: rest,
           i_simCode,
           i_preDimsExp )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_exp;
      equation
        (txt, i_preDimsExp) = daeExp(txt, i_exp, SimCode.contextFunction, i_preDimsExp, i_simCode);
        txt = Tpl.nextIter(txt);
        (txt, i_preDimsExp) = lm_31(txt, rest, i_simCode, i_preDimsExp);
      then (txt, i_preDimsExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preDimsExp )
      local
        list<DAE.Exp> rest;
      equation
        (txt, i_preDimsExp) = lm_31(txt, rest, i_simCode, i_preDimsExp);
      then (txt, i_preDimsExp);
  end matchcontinue;
end lm_31;

protected function fun_32
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_i_var_value;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_varName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_var_value, in_i_simCode, in_i_varName)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_varName;

    case ( txt,
           SOME(DAE.CREF(componentRef = i_cr)),
           i_simCode,
           i_varName )
      local
        DAE.ComponentRef i_cr;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, i_varName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".CopyFrom("));
        txt = crefStr(txt, i_cr, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_32;

protected function fun_33
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_i_instDims;
  input Option<DAE.Exp> in_i_var_value;
  input DAE.ExpType in_i_var_ty;
  input list<DAE.Exp> in_i_var_instDims;
  input SimCode.SimCode in_i_simCode;
  input DAE.ComponentRef in_i_var_name;
  input SimCode.Variable in_i_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_instDims, in_i_var_value, in_i_var_ty, in_i_var_instDims, in_i_simCode, in_i_var_name, in_i_var)
    local
      Tpl.Text txt;
      Option<DAE.Exp> i_var_value;
      DAE.ExpType i_var_ty;
      list<DAE.Exp> i_var_instDims;
      SimCode.SimCode i_simCode;
      DAE.ComponentRef i_var_name;
      SimCode.Variable i_var;

    case ( txt,
           {},
           _,
           _,
           _,
           i_simCode,
           i_var_name,
           i_var )
      equation
        txt = varType(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = crefStr(txt, i_var_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           i_instDims,
           i_var_value,
           i_var_ty,
           i_var_instDims,
           i_simCode,
           i_var_name,
           _ )
      local
        list<DAE.Exp> i_instDims;
        Integer ret_3;
        Tpl.Text i_instDimsInit;
        Tpl.Text i_preDimsExp;
        Tpl.Text i_varName;
      equation
        i_varName = crefStr(Tpl.emptyTxt, i_var_name, i_simCode);
        i_preDimsExp = Tpl.emptyTxt;
        i_instDimsInit = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_instDimsInit, i_preDimsExp) = lm_31(i_instDimsInit, i_var_instDims, i_simCode, i_preDimsExp);
        i_instDimsInit = Tpl.popIter(i_instDimsInit);
        txt = Tpl.writeText(txt, i_preDimsExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var "));
        txt = Tpl.writeText(txt, i_varName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new "));
        ret_3 = listLength(i_instDims);
        txt = expTypeArray(txt, i_var_ty, ret_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_instDimsInit);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = fun_32(txt, i_var_value, i_simCode, i_varName);
      then txt;
  end matchcontinue;
end fun_33;

public function varInit
  input Tpl.Text in_txt;
  input SimCode.Variable in_i_var;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_var, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_var as SimCode.VARIABLE(instDims = (i_var_instDims as i_instDims), name = i_var_name, ty = i_var_ty, value = i_var_value)),
           i_simCode )
      local
        Option<DAE.Exp> i_var_value;
        DAE.ExpType i_var_ty;
        DAE.ComponentRef i_var_name;
        list<DAE.Exp> i_instDims;
        list<DAE.Exp> i_var_instDims;
        SimCode.Variable i_var;
      equation
        txt = fun_33(txt, i_instDims, i_var_value, i_var_ty, i_var_instDims, i_simCode, i_var_name, i_var);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNSUPPORTED_VARIABLE_vatInit"));
      then txt;
  end matchcontinue;
end varInit;

public function funArgDefinition
  input Tpl.Text in_txt;
  input SimCode.Variable in_i_var;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_var, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_var as SimCode.VARIABLE(name = i_name)),
           i_simCode )
      local
        DAE.ComponentRef i_name;
        SimCode.Variable i_var;
      equation
        txt = varType(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = crefStr(txt, i_name, i_simCode);
      then txt;

    case ( txt,
           SimCode.FUNCTION_PTR(name = i_name),
           _ )
      local
        String i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("funArgDefinition_UNSUPPORTED_fnptr "));
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNSUPPORTED_VARIABLE_funArgDefinition"));
      then txt;
  end matchcontinue;
end funArgDefinition;

protected function lm_36
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           i_simCode )
      local
        list<DAE.Statement> rest;
        DAE.Statement i_stmt;
      equation
        txt = algStatement(txt, i_stmt, SimCode.contextFunction, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_36(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<DAE.Statement> rest;
      equation
        txt = lm_36(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_36;

public function funStatement
  input Tpl.Text in_txt;
  input SimCode.Statement in_i_stmt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_stmt, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.ALGORITHM(statementLst = i_statementLst),
           i_simCode )
      local
        list<DAE.Statement> i_statementLst;
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_36(txt, i_statementLst, i_simCode);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT IMPLEMENTED FUN STATEMENT"));
      then txt;
  end matchcontinue;
end funStatement;

public constant Tpl.StringToken c_localRepresentationArrayDefines = Tpl.ST_STRING_LIST({
                                                                        "var X = states; var Xd = statesDerivatives; var Y = algebraics; var P = parameters; var H = helpVars;\n",
                                                                        "var preX = savedStates; var preXd = savedStatesDerivatives; var preY = savedAlgebraics; var preH = savedHelpVars;\n",
                                                                        "var preYI = savedAlgebraicsInt; var preYB = savedAlgebraicsBool; var YI = algebraicsInt; var YB = algebraicsBool; var PI = parametersInt; var PB = parametersBool; "
                                                                    }, false);

protected function smf_39
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_39;

protected function smf_40
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_40;

protected function smf_41
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_41;

protected function smf_42
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_42;

protected function smf_43
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_43;

protected function smf_44
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_44;

protected function smf_45
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_45;

protected function smf_46
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_46;

protected function fun_47
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_stateVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_stateVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_stateVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_stateVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//states\n"));
        txt = initFixed(txt, i_vars_stateVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_47;

protected function fun_48
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_derivativeVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_derivativeVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_derivativeVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_derivativeVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//derivatives\n"));
        txt = initFixed(txt, i_vars_derivativeVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_48;

protected function fun_49
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_algVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_algVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_algVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_algVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//algebraics\n"));
        txt = initFixed(txt, i_vars_algVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_49;

protected function fun_50
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_intAlgVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_intAlgVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_intAlgVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_intAlgVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//algebraicsInt\n"));
        txt = initFixed(txt, i_vars_intAlgVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_50;

protected function fun_51
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_boolAlgVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_boolAlgVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_boolAlgVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_boolAlgVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//algebraicsBool\n"));
        txt = initFixed(txt, i_vars_boolAlgVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_51;

protected function fun_52
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_paramVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_paramVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_paramVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_paramVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//parameters\n"));
        txt = initFixed(txt, i_vars_paramVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_52;

protected function fun_53
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_intParamVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_intParamVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_intParamVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_intParamVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//parametersInt\n"));
        txt = initFixed(txt, i_vars_intParamVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_53;

protected function fun_54
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_vars_boolParamVars;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_vars_boolParamVars, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_boolParamVars,
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_boolParamVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//parametersBool\n"));
        txt = initFixed(txt, i_vars_boolParamVars, i_simCode);
      then txt;
  end matchcontinue;
end fun_54;

protected function smf_55
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_55;

protected function smf_56
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_56;

protected function smf_57
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_57;

protected function smf_58
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_58;

protected function smf_59
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_59;

protected function smf_60
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_60;

protected function smf_61
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_61;

protected function smf_62
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           i_it )
      local
        Tpl.Text i_it;
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_62;

public function modelDataMembers
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_i_modelInfo;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_modelInfo, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.MODELINFO(varInfo = SimCode.VARINFO(numHelpVars = i_varInfo_numHelpVars, numZeroCrossings = i_varInfo_numZeroCrossings, numStateVars = i_varInfo_numStateVars, numAlgVars = i_varInfo_numAlgVars, numParams = i_varInfo_numParams, numIntAlgVars = i_varInfo_numIntAlgVars, numBoolAlgVars = i_varInfo_numBoolAlgVars, numIntParams = i_varInfo_numIntParams, numBoolParams = i_varInfo_numBoolParams, numOutVars = i_varInfo_numOutVars, numInVars = i_varInfo_numInVars, numResiduals = i_varInfo_numResiduals, numExternalObjects = i_varInfo_numExternalObjects, numStringAlgVars = i_varInfo_numStringAlgVars, numStringParamVars = i_varInfo_numStringParamVars), vars = SimCode.SIMVARS(stateVars = i_vars_stateVars, derivativeVars = i_vars_derivativeVars, algVars = i_vars_algVars, intAlgVars = i_vars_intAlgVars, boolAlgVars = i_vars_boolAlgVars, paramVars = i_vars_paramVars, intParamVars = i_vars_intParamVars, boolParamVars = i_vars_boolParamVars), name = i_name),
           i_simCode )
      local
        Absyn.Path i_name;
        list<SimCode.SimVar> i_vars_boolParamVars;
        list<SimCode.SimVar> i_vars_intParamVars;
        list<SimCode.SimVar> i_vars_paramVars;
        list<SimCode.SimVar> i_vars_boolAlgVars;
        list<SimCode.SimVar> i_vars_intAlgVars;
        list<SimCode.SimVar> i_vars_algVars;
        list<SimCode.SimVar> i_vars_derivativeVars;
        list<SimCode.SimVar> i_vars_stateVars;
        Integer i_varInfo_numStringParamVars;
        Integer i_varInfo_numStringAlgVars;
        Integer i_varInfo_numExternalObjects;
        Integer i_varInfo_numResiduals;
        Integer i_varInfo_numInVars;
        Integer i_varInfo_numOutVars;
        Integer i_varInfo_numBoolParams;
        Integer i_varInfo_numIntParams;
        Integer i_varInfo_numBoolAlgVars;
        Integer i_varInfo_numIntAlgVars;
        Integer i_varInfo_numParams;
        Integer i_varInfo_numAlgVars;
        Integer i_varInfo_numStateVars;
        Integer i_varInfo_numZeroCrossings;
        Integer i_varInfo_numHelpVars;
        Tpl.Text txt_15;
        Tpl.Text txt_14;
        Tpl.Text txt_13;
        Tpl.Text txt_12;
        Tpl.Text txt_11;
        Tpl.Text txt_10;
        Tpl.Text txt_9;
        Tpl.Text txt_8;
        Tpl.Text txt_7;
        Tpl.Text txt_6;
        Tpl.Text txt_5;
        Tpl.Text txt_4;
        Tpl.Text txt_3;
        Tpl.Text txt_2;
        Tpl.Text txt_1;
        Tpl.Text txt_0;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("const int\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NHELP = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numHelpVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NG = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numZeroCrossings));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NX = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStateVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NY = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NP = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numParams));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NYI = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numIntAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NYB = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numBoolAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NPI = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numIntParams));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NPB = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numBoolParams));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NO = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numOutVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NI = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numInVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NR = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numResiduals));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NEXT = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numExternalObjects));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NYSTR = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStringAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NPSTR = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStringParamVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("public override string ModelName        { get { return \""));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\"; }}\n",
                                    "public override int HelpVarsCount       { get { return NHELP; } }\n",
                                    "public override int ZeroCrossingsCount  { get { return NG; } }\n",
                                    "public override int StatesCount         { get { return NX; } }\n",
                                    "public override int AlgebraicsCount     { get { return NY; } }\n",
                                    "public override int AlgebraicsIntCount  { get { return NYI; } }\n",
                                    "public override int AlgebraicsBoolCount { get { return NYB; } }\n",
                                    "public override int ParametersCount     { get { return NP; } }\n",
                                    "public override int ParametersIntCount  { get { return NPI; } }\n",
                                    "public override int ParametersBoolCount { get { return NPB; } }\n",
                                    "\n",
                                    "public override int OutputsCount   { get { return NO; } }\n",
                                    "public override int InputsCount    { get { return NI; } }\n",
                                    "public override int ResidualsCount { get { return NR; } }\n",
                                    "//public int ExternalObjectsCount { get { return NEXT; } }\n",
                                    "public override int MaximumOrder { get { return 5; } }\n",
                                    "public override int StringVarsCount { get { return NYSTR; } }\n",
                                    "public override int StringParametersCount { get { return NPSTR; } }\n",
                                    "\n",
                                    "\n",
                                    "\n",
                                    "#region VariableInfos\n",
                                    "public static readonly SimVarInfo[] VariableInfosStatic = new[] {\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt_0 = varInfos(Tpl.emptyTxt, "State", i_vars_stateVars, false, i_simCode);
        txt_1 = varInfos(Tpl.emptyTxt, "StateDer", i_vars_derivativeVars, false, i_simCode);
        txt_2 = varInfos(Tpl.emptyTxt, "Algebraic", i_vars_algVars, false, i_simCode);
        txt_3 = varInfos(Tpl.emptyTxt, "AlgebraicInt", i_vars_intAlgVars, false, i_simCode);
        txt_4 = varInfos(Tpl.emptyTxt, "AlgebraicBool", i_vars_boolAlgVars, false, i_simCode);
        txt_5 = varInfos(Tpl.emptyTxt, "Parameter", i_vars_paramVars, true, i_simCode);
        txt_6 = varInfos(Tpl.emptyTxt, "ParameterInt", i_vars_intParamVars, true, i_simCode);
        txt_7 = varInfos(Tpl.emptyTxt, "ParameterBool", i_vars_boolParamVars, true, i_simCode);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                     ",\n",
                                                                     "\n"
                                                                 }, true)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = smf_39(txt, txt_0);
        txt = smf_40(txt, txt_1);
        txt = smf_41(txt, txt_2);
        txt = smf_42(txt, txt_3);
        txt = smf_43(txt, txt_4);
        txt = smf_44(txt, txt_5);
        txt = smf_45(txt, txt_6);
        txt = smf_46(txt, txt_7);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "};\n",
                                    "public override SimVarInfo[] VariableInfos { get { return VariableInfosStatic; } }\n",
                                    "#endregion\n",
                                    "\n",
                                    "#region InitialFixed\n",
                                    "private static readonly bool[] InitialFixedStatic = new bool[NX + NX + NY + NYI +NYB + NP + NPI + NPB] {\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt_8 = fun_47(Tpl.emptyTxt, i_vars_stateVars, i_simCode);
        txt_9 = fun_48(Tpl.emptyTxt, i_vars_derivativeVars, i_simCode);
        txt_10 = fun_49(Tpl.emptyTxt, i_vars_algVars, i_simCode);
        txt_11 = fun_50(Tpl.emptyTxt, i_vars_intAlgVars, i_simCode);
        txt_12 = fun_51(Tpl.emptyTxt, i_vars_boolAlgVars, i_simCode);
        txt_13 = fun_52(Tpl.emptyTxt, i_vars_paramVars, i_simCode);
        txt_14 = fun_53(Tpl.emptyTxt, i_vars_intParamVars, i_simCode);
        txt_15 = fun_54(Tpl.emptyTxt, i_vars_boolParamVars, i_simCode);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = smf_55(txt, txt_8);
        txt = smf_56(txt, txt_9);
        txt = smf_57(txt, txt_10);
        txt = smf_58(txt, txt_11);
        txt = smf_59(txt, txt_12);
        txt = smf_60(txt, txt_13);
        txt = smf_61(txt, txt_14);
        txt = smf_62(txt, txt_15);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "};\n",
                                    "public override bool[] InitialFixed { get { return InitialFixedStatic; } }\n",
                                    "#endregion\n",
                                    "\n",
                                    "#region Constructor - Init Data\n",
                                    "public "
                                }, false));
        txt = lastIdentOfPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "() {\n",
                                    "    CreateData();\n",
                                    "\n",
                                    "    //**** states *****\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = initVals(txt, "states", i_vars_stateVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** state derivatives *****\n",
                                    "//all are default values ... 0.0\n",
                                    "\n",
                                    "//**** algebraics *****\n"
                                }, true));
        txt = initVals(txt, "algebraics", i_vars_algVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** algebraics Int *****\n"
                                }, true));
        txt = initVals(txt, "algebraicsInt", i_vars_intAlgVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** algebraics Bool *****\n"
                                }, true));
        txt = initVals(txt, "algebraicsBool", i_vars_boolAlgVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** parameters *****\n"
                                }, true));
        txt = initVals(txt, "parameters", i_vars_paramVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** parameters Int *****\n"
                                }, true));
        txt = initVals(txt, "parametersInt", i_vars_intParamVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** parameters Bool *****\n"
                                }, true));
        txt = initVals(txt, "parametersBool", i_vars_boolParamVars, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "#endregion"
                                }, false));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end modelDataMembers;

protected function lm_64
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input Boolean in_i_isMInd;
  input String in_i_typeName;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_isMInd, in_i_typeName, in_i_simCode)
    local
      Tpl.Text txt;
      Boolean i_isMInd;
      String i_typeName;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name, comment = i_comment, index = i_index) :: rest,
           i_isMInd,
           i_typeName,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        Integer i_index;
        String i_comment;
        DAE.ComponentRef i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("new SimVarInfo( \""));
        txt = crefStr(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", \""));
        txt = Tpl.writeStr(txt, i_comment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", SimVarType."));
        txt = Tpl.writeStr(txt, i_typeName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, Tpl.booleanString(i_isMInd));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        txt = Tpl.nextIter(txt);
        txt = lm_64(txt, rest, i_isMInd, i_typeName, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_isMInd,
           i_typeName,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_64(txt, rest, i_isMInd, i_typeName, i_simCode);
      then txt;
  end matchcontinue;
end lm_64;

protected function fun_65
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_i_varsLst;
  input String in_i_typeName;
  input Boolean in_i_isMInd;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_varsLst, in_i_typeName, in_i_isMInd, in_i_simCode)
    local
      Tpl.Text txt;
      String i_typeName;
      Boolean i_isMInd;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_varsLst,
           i_typeName,
           i_isMInd,
           i_simCode )
      local
        list<SimCode.SimVar> i_varsLst;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("#region "));
        txt = Tpl.writeStr(txt, i_typeName);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" variable infos\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_64(txt, i_varsLst, i_isMInd, i_typeName, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("#endregion"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then txt;
  end matchcontinue;
end fun_65;

public function varInfos
  input Tpl.Text txt;
  input String i_typeName;
  input list<SimCode.SimVar> i_varsLst;
  input Boolean i_isMInd;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_65(txt, i_varsLst, i_typeName, i_isMInd, i_simCode);
end varInfos;

protected function fun_67
  input Tpl.Text in_txt;
  input String in_it;
  input SimCode.SimCode in_i_simCode;
  input DAE.ComponentRef in_i_sv_name;
  input Integer in_i_sv_index;
  input String in_i_arrName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it, in_i_simCode, in_i_sv_name, in_i_sv_index, in_i_arrName)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      DAE.ComponentRef i_sv_name;
      Integer i_sv_index;
      String i_arrName;

    case ( txt,
           (i_vStr as "0"),
           i_simCode,
           i_sv_name,
           i_sv_index,
           i_arrName )
      local
        String i_vStr;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, i_sv_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           (i_vStr as "0.0"),
           i_simCode,
           i_sv_name,
           i_sv_index,
           i_arrName )
      local
        String i_vStr;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, i_sv_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           (i_vStr as "(0)"),
           i_simCode,
           i_sv_name,
           i_sv_index,
           i_arrName )
      local
        String i_vStr;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, i_sv_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           i_vStr,
           i_simCode,
           i_sv_name,
           i_sv_index,
           i_arrName )
      local
        String i_vStr;
      equation
        txt = Tpl.writeStr(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, i_sv_name, i_simCode);
      then txt;
  end matchcontinue;
end fun_67;

protected function fun_68
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_i_initialValue;
  input DAE.ComponentRef in_i_sv_name;
  input Integer in_i_sv_index;
  input String in_i_arrName;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_initialValue, in_i_sv_name, in_i_sv_index, in_i_arrName, in_i_simCode)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_sv_name;
      Integer i_sv_index;
      String i_arrName;
      SimCode.SimCode i_simCode;

    case ( txt,
           SOME(i_v),
           i_sv_name,
           i_sv_index,
           i_arrName,
           i_simCode )
      local
        DAE.Exp i_v;
        String str_2;
        Tpl.Text txt_1;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (txt_1, i_preExp) = daeExp(Tpl.emptyTxt, i_v, SimCode.contextOther, i_preExp, i_simCode);
        str_2 = Tpl.textString(txt_1);
        txt = fun_67(txt, str_2, i_simCode, i_sv_name, i_sv_index, i_arrName);
      then txt;

    case ( txt,
           _,
           i_sv_name,
           i_sv_index,
           i_arrName,
           i_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = 0.0; //"));
        txt = crefStr(txt, i_sv_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> default val"));
      then txt;
  end matchcontinue;
end fun_68;

protected function lm_69
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input String in_i_arrName;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_arrName, in_i_simCode)
    local
      Tpl.Text txt;
      String i_arrName;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           (i_sv as SimCode.SIMVAR(initialValue = i_initialValue, index = i_sv_index, name = i_sv_name)) :: rest,
           i_arrName,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_sv_name;
        Integer i_sv_index;
        Option<DAE.Exp> i_initialValue;
        SimCode.SimVar i_sv;
      equation
        txt = fun_68(txt, i_initialValue, i_sv_name, i_sv_index, i_arrName, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_69(txt, rest, i_arrName, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_arrName,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_69(txt, rest, i_arrName, i_simCode);
      then txt;
  end matchcontinue;
end lm_69;

public function initVals
  input Tpl.Text txt;
  input String i_arrName;
  input list<SimCode.SimVar> i_varsLst;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_69(out_txt, i_varsLst, i_arrName, i_simCode);
  out_txt := Tpl.popIter(out_txt);
end initVals;

protected function lm_71
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(isFixed = i_isFixed, name = i_name) :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
        Boolean i_isFixed;
      equation
        txt = Tpl.writeStr(txt, Tpl.booleanString(i_isFixed));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" /* "));
        txt = crefStr(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" */"));
        txt = Tpl.nextIter(txt);
        txt = lm_71(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_71(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_71;

public function initFixed
  input Tpl.Text txt;
  input list<SimCode.SimVar> i_simVarLst;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_71(out_txt, i_simVarLst, i_simCode);
  out_txt := Tpl.popIter(out_txt);
end initFixed;

protected function lm_73
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationNonDiscrete, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_73(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_73(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_73;

protected function lm_74
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationNonDiscrete, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_74(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_74(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_74;

public function functionDaeOutput
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_nonStateContEquations;
  input list<SimCode.SimEqSystem> i_removedEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "/* for continuous time variables */\n",
                                   "public override void FunDAEOutput()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_73(out_txt, i_nonStateContEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_74(out_txt, i_removedEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionDaeOutput;

protected function lm_76
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationDiscrete, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_76(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_76(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_76;

protected function lm_77
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationDiscrete, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_77(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_77(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_77;

public function functionDaeOutput2
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_nonStateDiscEquations;
  input list<SimCode.SimEqSystem> i_removedEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "/* for discrete time variables */\n",
                                   "public override void FunDAEOutput2()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_76(out_txt, i_nonStateDiscEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_77(out_txt, i_removedEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionDaeOutput2;

protected function lm_79
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = inputVars["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("];"));
        txt = Tpl.nextIter(txt);
        txt = lm_79(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_79(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_79;

public function functionInput
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_i_modelInfo;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_modelInfo, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.MODELINFO(varInfo = SimCode.VARINFO(numHelpVars = _), vars = SimCode.SIMVARS(inputVars = i_vars_inputVars)),
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_inputVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override void InputFun()\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_79(txt, i_vars_inputVars, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionInput;

protected function lm_81
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//outputVars["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_81(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_81(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_81;

public function functionOutput
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_i_modelInfo;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_modelInfo, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.MODELINFO(varInfo = SimCode.VARINFO(numHelpVars = _), vars = SimCode.SIMVARS(outputVars = i_vars_outputVars)),
           i_simCode )
      local
        list<SimCode.SimVar> i_vars_outputVars;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override void OutputFun()\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("// * not yet\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_81(txt, i_vars_outputVars, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionOutput;

protected function lm_83
  input Tpl.Text in_txt;
  input list<BackendDAE.ZeroCrossing> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           BackendDAE.ZERO_CROSSING(relation_ = i_relation__) :: rest,
           i_simCode )
      local
        list<BackendDAE.ZeroCrossing> rest;
        DAE.Exp i_relation__;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = zeroCrossing(txt, i_relation__, i_i0, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_83(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<BackendDAE.ZeroCrossing> rest;
      equation
        txt = lm_83(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_83;

public function functionZeroCrossing
  input Tpl.Text txt;
  input list<BackendDAE.ZeroCrossing> i_zeroCrossingLst;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunZeroCrossing(double time, double[] x, double[] xd, double[] gout)\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "var timeBackup = this.time;\n",
                                       "this.time = time;\n",
                                       "\n",
                                       "FunODE();\n",
                                       "FunDAEOutput();\n",
                                       "\n"
                                   }, true));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_83(out_txt, i_zeroCrossingLst, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "\n",
                                       "this.time = timeBackup;\n"
                                   }, true));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionZeroCrossing;

protected function lm_85
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
      equation
        txt = preCref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //save()"));
        txt = Tpl.nextIter(txt);
        txt = lm_85(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_85(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_85;

protected function lm_86
  input Tpl.Text in_txt;
  input list<list<SimCode.SimVar>> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_toSaveLst :: rest,
           i_simCode )
      local
        list<list<SimCode.SimVar>> rest;
        list<SimCode.SimVar> i_toSaveLst;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("case "));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(":\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_85(txt, i_toSaveLst, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("break;"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.nextIter(txt);
        txt = lm_86(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<list<SimCode.SimVar>> rest;
      equation
        txt = lm_86(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_86;

public function functionHandleZeroCrossing
  input Tpl.Text in_txt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_simCode)
    local
      Tpl.Text txt;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(zeroCrossingsNeedSave = i_zeroCrossingsNeedSave)) )
      local
        list<list<SimCode.SimVar>> i_zeroCrossingsNeedSave;
        SimCode.SimCode i_simCode;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override void FunHandleZeroCrossing(int index)\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("switch(index) {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_86(txt, i_zeroCrossingsNeedSave, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "default:\n",
                                    "   break;\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end functionHandleZeroCrossing;

protected function lm_88
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationDiscrete, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_88(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_88(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_88;

protected function lm_89
  input Tpl.Text in_txt;
  input list<SimCode.HelpVarInfo> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_in1, i_exp, _) :: rest,
           i_simCode )
      local
        list<SimCode.HelpVarInfo> rest;
        DAE.Exp i_exp;
        Integer i_in1;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, SimCode.contextSimulationDiscrete, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("helpVars["));
        txt = Tpl.writeStr(txt, intString(i_in1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" ? 1.0 : 0.0;"));
        txt = Tpl.nextIter(txt);
        txt = lm_89(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.HelpVarInfo> rest;
      equation
        txt = lm_89(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_89;

public function functionUpdateDependents
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_allEquations;
  input list<SimCode.HelpVarInfo> i_helpVarInfoLst;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunUpdateDependents()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "//inUpdate=initial()?0:1;\n",
                                       "isInUpdate = ! isInit;\n",
                                       "\n"
                                   }, true));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_88(out_txt, i_allEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_89(out_txt, i_helpVarInfoLst, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "\n",
                                       "isInUpdate = false;\n"
                                   }, true));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionUpdateDependents;

protected function lm_91
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationDiscrete, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_91(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_91(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_91;

public function functionUpdateDepend
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_allEquationsPlusWhen;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunUpdateDepend()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "isInUpdate = ! isInit;\n",
                                       "\n"
                                   }, true));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_91(out_txt, i_allEquationsPlusWhen, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "\n",
                                       "isInUpdate = false;\n"
                                   }, true));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionUpdateDepend;

protected function lm_93
  input Tpl.Text in_txt;
  input list<BackendDAE.ZeroCrossing> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           BackendDAE.ZERO_CROSSING(relation_ = i_relation__) :: rest,
           i_simCode )
      local
        list<BackendDAE.ZeroCrossing> rest;
        DAE.Exp i_relation__;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = zeroCrossing(txt, i_relation__, i_i0, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_93(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<BackendDAE.ZeroCrossing> rest;
      equation
        txt = lm_93(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_93;

public function functionOnlyZeroCrossing
  input Tpl.Text txt;
  input list<BackendDAE.ZeroCrossing> i_zeroCrossingLst;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunOnlyZeroCrossings(double time, double[] gout) //TODO:??time in original is *t only ... how is it called?\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_93(out_txt, i_zeroCrossingLst, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionOnlyZeroCrossing;

protected function fun_95
  input Tpl.Text in_txt;
  input DAE.Operator in_i_operator;
  input Tpl.Text in_i_e2;
  input Tpl.Text in_i_e1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_operator, in_i_e2, in_i_e1)
    local
      Tpl.Text txt;
      Tpl.Text i_e2;
      Tpl.Text i_e1;

    case ( txt,
           DAE.LESS(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-"));
        txt = Tpl.writeText(txt, i_e2);
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-"));
        txt = Tpl.writeText(txt, i_e2);
      then txt;

    case ( txt,
           DAE.GREATER(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-"));
        txt = Tpl.writeText(txt, i_e1);
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-"));
        txt = Tpl.writeText(txt, i_e1);
      then txt;

    case ( txt,
           DAE.EQUAL(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, i_e1);
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, i_e1);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!unsupported ZC operator!!!"));
      then txt;
  end matchcontinue;
end fun_95;

public function zeroCrossing
  input Tpl.Text in_txt;
  input DAE.Exp in_i_it;
  input Integer in_i_index;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_index, in_i_simCode)
    local
      Tpl.Text txt;
      Integer i_index;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.RELATION(exp1 = i_exp1, exp2 = i_exp2, operator = i_operator),
           i_index,
           i_simCode )
      local
        DAE.Operator i_operator;
        DAE.Exp i_exp2;
        DAE.Exp i_exp1;
        Tpl.Text i_e2;
        Tpl.Text i_e1;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_e1, i_preExp) = daeExp(Tpl.emptyTxt, i_exp1, SimCode.contextOther, i_preExp, i_simCode);
        (i_e2, i_preExp) = daeExp(Tpl.emptyTxt, i_exp2, SimCode.contextOther, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("{"));
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var _zen = zeroCrossingEnabled["));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //ZEROCROSSING("));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = zeroCrossingOpFunc(txt, i_operator);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "));\n",
                                    "gout["
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = (_zen != 0) ? _zen * ("));
        txt = fun_95(txt, i_operator, i_e2, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") : 1.0; }"));
      then txt;

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "sample"), expLst = {i_start, i_interval}),
           i_index,
           i_simCode )
      local
        DAE.Exp i_interval;
        DAE.Exp i_start;
        Tpl.Text i_eInterval;
        Tpl.Text i_eStart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_eStart, i_preExp) = daeExp(Tpl.emptyTxt, i_start, SimCode.contextOther, i_preExp, i_simCode);
        (i_eInterval, i_preExp) = daeExp(Tpl.emptyTxt, i_interval, SimCode.contextOther, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("{"));
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var _zen = zeroCrossingEnabled["));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //ZEROCROSSING("));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", Sample(*t, "));
        txt = Tpl.writeText(txt, i_eStart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_eInterval);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "));\n",
                                    "gout["
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = (_zen != 0) ? _zen * Sample(time, "));
        txt = Tpl.writeText(txt, i_eStart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_eInterval);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") : 1.0; }"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ZERO_CROSSING_ERROR"));
      then txt;
  end matchcontinue;
end zeroCrossing;

public function zeroCrossingOpFunc
  input Tpl.Text in_txt;
  input DAE.Operator in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.LESS(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Less"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Greater"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LessEq"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GreaterEq"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!Equal"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!NEqual"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!unsupported ZC operator!!!"));
      then txt;
  end matchcontinue;
end zeroCrossingOpFunc;

public function functionStoreDelayed
  input Tpl.Text txt;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunStoreDelayed()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionStoreDelayed;

protected function lm_99
  input Tpl.Text in_txt;
  input list<BackendDAE.WhenOperator> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           BackendDAE.REINIT(value = i_value, stateVar = i_stateVar) :: rest,
           i_simCode )
      local
        list<BackendDAE.WhenOperator> rest;
        DAE.ComponentRef i_stateVar;
        DAE.Exp i_value;
        Tpl.Text i_valueExp;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_valueExp, i_preExp) = daeExp(Tpl.emptyTxt, i_value, SimCode.contextSimulationDiscrete, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_stateVar, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_valueExp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_99(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<BackendDAE.WhenOperator> rest;
      equation
        txt = lm_99(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_99;

protected function lm_100
  input Tpl.Text in_txt;
  input list<SimCode.SimWhenClause> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIM_WHEN_CLAUSE(whenEq = i_whenEq, reinits = i_reinits) :: rest,
           i_simCode )
      local
        list<SimCode.SimWhenClause> rest;
        list<BackendDAE.WhenOperator> i_reinits;
        Option<BackendDAE.WhenEquation> i_whenEq;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("case "));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(":\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = functionWhen_caseEquation(txt, i_whenEq, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_99(txt, i_reinits, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("break;"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.nextIter(txt);
        txt = lm_100(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimWhenClause> rest;
      equation
        txt = lm_100(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_100;

protected function fun_101
  input Tpl.Text in_txt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_simCode)
    local
      Tpl.Text txt;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(whenClauses = i_whenClauses)) )
      local
        list<SimCode.SimWhenClause> i_whenClauses;
        SimCode.SimCode i_simCode;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override void FunWhen(int i)\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("switch(i) {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_100(txt, i_whenClauses, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "default:\n",
                                    "  break;\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_101;

public function functionWhen
  input Tpl.Text txt;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := fun_101(txt, i_simCode);
end functionWhen;

public function functionWhen_caseEquation
  input Tpl.Text in_txt;
  input Option<BackendDAE.WhenEquation> in_i_it;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           SOME((i_weq as BackendDAE.WHEN_EQ(right = i_weq_right, left = i_weq_left))),
           i_simCode )
      local
        DAE.ComponentRef i_weq_left;
        DAE.Exp i_weq_right;
        BackendDAE.WhenEquation i_weq;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_weq_right, SimCode.contextSimulationDiscrete, i_preExp, i_simCode);
        txt = preCref(txt, i_weq_left, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = cref(txt, i_weq_left, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("; //save()\n"));
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_weq_left, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionWhen_caseEquation;

protected function lm_104
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_it;
      equation
        txt = equation_(txt, i_it, SimCode.contextOther, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_104(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_104(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_104;

public function functionOde
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_stateContEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunODE()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_104(out_txt, i_stateContEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionOde;

protected function lm_106
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (it as SimCode.SES_SIMPLE_ASSIGN(cref = _)) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem it;
      equation
        txt = equation_(txt, it, SimCode.contextOther, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_106(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_106(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_106;

protected function lm_107
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(cref = i_cref) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        DAE.ComponentRef i_cref;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//Debug.WriteLine(\"Setting variable start value: {0}(start={1})\", \""));
        txt = cref(txt, i_cref, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = cref(txt, i_cref, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_107(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_107(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_107;

public function functionInitial
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_initialEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void InitialFun()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_106(out_txt, i_initialEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "\n",
                                       "//if (sim_verbose) {\n"
                                   }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_107(out_txt, i_initialEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE("//}\n"));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionInitial;

protected function fun_109
  input Tpl.Text in_txt;
  input DAE.Exp in_i_exp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_exp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.SCONST(string = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("initialResiduals[_i++] = 0;"));
      then txt;

    case ( txt,
           i_exp,
           i_simCode )
      local
        DAE.Exp i_exp;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, SimCode.contextSimulationNonDiscrete, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("initialResiduals[_i++] = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;
  end matchcontinue;
end fun_109;

protected function lm_110
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_RESIDUAL(exp = i_exp) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        DAE.Exp i_exp;
      equation
        txt = fun_109(txt, i_exp, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_110(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_110(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_110;

public function functionInitialResidual
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_residualEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void InitialResidual()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "int _i = 0;\n",
                                       "\n"
                                   }, true));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_110(out_txt, i_residualEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionInitialResidual;

protected function lm_112
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_saeq as SimCode.SES_SIMPLE_ASSIGN(cref = _)) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem i_saeq;
      equation
        txt = equation_(txt, i_saeq, SimCode.contextOther, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_112(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_112(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_112;

protected function lm_113
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_RESIDUAL(exp = i_exp) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        DAE.Exp i_exp;
        Integer i_i0;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, SimCode.contextSimulationDiscrete, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("res["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_113(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_113(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_113;

protected function lm_114
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_NONLINEAR(index = i_index, eqs = i_eqs) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        list<SimCode.SimEqSystem> i_eqs;
        Integer i_index;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int ResidualFun"));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "(int n, double[] xloc, double[] res, int iflag)\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(3));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_112(txt, i_eqs, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_113(txt, i_eqs, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("return 0;\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
        txt = Tpl.nextIter(txt);
        txt = lm_114(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_114(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_114;

public function functionExtraResiduals
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_allEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_114(out_txt, i_allEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
end functionExtraResiduals;

protected function lm_116
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (it as SimCode.SES_SIMPLE_ASSIGN(cref = _)) :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
        SimCode.SimEqSystem it;
      equation
        txt = equation_(txt, it, SimCode.contextOther, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_116(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        txt = lm_116(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_116;

public function functionBoundParameters
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> i_parameterEquations;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void BoundParameters()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_116(out_txt, i_parameterEquations, i_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionBoundParameters;

protected function fun_118
  input Tpl.Text in_txt;
  input Integer in_i_id2;
  input Integer in_i_id1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_id2, in_i_id1)
    local
      Tpl.Text txt;
      Integer i_id1;

    case ( txt,
           -1,
           _ )
      then txt;

    case ( txt,
           i_id2,
           i_id1 )
      local
        Integer i_id2;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if (H["));
        txt = Tpl.writeStr(txt, intString(i_id1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]!=0.0 && preH["));
        txt = Tpl.writeStr(txt, intString(i_id1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]==0.0) EventQueue.Add("));
        txt = Tpl.writeStr(txt, intString(i_id2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" + NG);"));
      then txt;
  end matchcontinue;
end fun_118;

protected function lm_119
  input Tpl.Text in_txt;
  input list<SimCode.HelpVarInfo> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_id1, i_exp, i_id2) :: rest )
      local
        list<SimCode.HelpVarInfo> rest;
        Integer i_id2;
        DAE.Exp i_exp;
        Integer i_id1;
      equation
        txt = fun_118(txt, i_id2, i_id1);
        txt = Tpl.nextIter(txt);
        txt = lm_119(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      local
        list<SimCode.HelpVarInfo> rest;
      equation
        txt = lm_119(txt, rest);
      then txt;
  end matchcontinue;
end lm_119;

protected function lm_120
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode )
      local
        list<DAE.ComponentRef> rest;
        DAE.ComponentRef i_it;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = preCref(txt, i_it, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = cref(txt, i_it, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") return true; /*needToIterate = true; */"));
        txt = Tpl.nextIter(txt);
        txt = lm_120(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<DAE.ComponentRef> rest;
      equation
        txt = lm_120(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_120;

public function functionCheckForDiscreteVarChanges
  input Tpl.Text in_txt;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_simCode)
    local
      Tpl.Text txt;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(helpVarInfo = i_helpVarInfo, discreteModelVars = i_discreteModelVars)) )
      local
        list<DAE.ComponentRef> i_discreteModelVars;
        list<SimCode.HelpVarInfo> i_helpVarInfo;
        SimCode.SimCode i_simCode;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override bool CheckForDiscreteVarChanges()\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "//var needToIterate = false;\n",
                                    "\n",
                                    "//edge(H[i])\n"
                                }, true));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_119(txt, i_helpVarInfo);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//TODO: changeDiscreteVar(i) and to get the i from ComponentRef\n",
                                    "//if change()\n"
                                }, true));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_120(txt, i_discreteModelVars, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "for (int i = 0; i < H.Length; i++) {\n",
                                    "  //change(H[i]) ?? TODO: not sure if it can be only 1.0 or 0.0\n",
                                    "  if (H[i] != preH[i])\n",
                                    "    return true; //needToIterate=true;\n",
                                    "}\n",
                                    "\n",
                                    "return false; //needToIterate;\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end functionCheckForDiscreteVarChanges;

protected function fun_122
  input Tpl.Text in_txt;
  input String in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           "bool" )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" ?1.0:0.0"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_122;

public function daeExpToReal
  input Tpl.Text txt;
  input DAE.Exp i_exp;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  String str_1;
  Tpl.Text txt_0;
algorithm
  (out_txt, out_i_preExp) := daeExp(txt, i_exp, i_context, i_preExp, i_simCode);
  txt_0 := expTypeFromExp(Tpl.emptyTxt, i_exp);
  str_1 := Tpl.textString(txt_0);
  out_txt := fun_122(out_txt, str_1);
end daeExpToReal;

protected function lm_124
  input Tpl.Text in_txt;
  input list<tuple<Integer, Integer, SimCode.SimEqSystem>> in_items;
  input Tpl.Text in_i_size;
  input Tpl.Text in_i_aname;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_size, in_i_aname, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      Tpl.Text i_size;
      Tpl.Text i_aname;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _,
           _,
           _ )
      then txt;

    case ( txt,
           (i_row, i_col, (i_eq as SimCode.SES_RESIDUAL(exp = i_eq_exp))) :: rest,
           i_size,
           i_aname,
           i_simCode,
           i_context )
      local
        list<tuple<Integer, Integer, SimCode.SimEqSystem>> rest;
        DAE.Exp i_eq_exp;
        SimCode.SimEqSystem i_eq;
        Integer i_col;
        Integer i_row;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExpToReal(Tpl.emptyTxt, i_eq_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.writeText(txt, i_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_row));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("+"));
        txt = Tpl.writeStr(txt, intString(i_col));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*"));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //set_matrix_elt("));
        txt = Tpl.writeText(txt, i_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_row));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_col));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_124(txt, rest, i_size, i_aname, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_size,
           i_aname,
           i_simCode,
           i_context )
      local
        list<tuple<Integer, Integer, SimCode.SimEqSystem>> rest;
      equation
        txt = lm_124(txt, rest, i_size, i_aname, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_124;

protected function lm_125
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input Tpl.Text in_i_bname;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_bname, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      Tpl.Text i_bname;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_bname,
           i_simCode,
           i_context )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_it;
        Integer i_i0;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExpToReal(Tpl.emptyTxt, i_it, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //set_vector_elt("));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_125(txt, rest, i_bname, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_bname,
           i_simCode,
           i_context )
      local
        list<DAE.Exp> rest;
      equation
        txt = lm_125(txt, rest, i_bname, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_125;

protected function fun_126
  input Tpl.Text in_txt;
  input Boolean in_i_partOfMixed;
  input Tpl.Text in_i_uid;
  input Tpl.Text in_i_size;
  input Tpl.Text in_i_bname;
  input Tpl.Text in_i_aname;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_partOfMixed, in_i_uid, in_i_size, in_i_bname, in_i_aname)
    local
      Tpl.Text txt;
      Tpl.Text i_uid;
      Tpl.Text i_size;
      Tpl.Text i_bname;
      Tpl.Text i_aname;

    case ( txt,
           false,
           i_uid,
           i_size,
           i_bname,
           i_aname )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SolveLinearSystem("));
        txt = Tpl.writeText(txt, i_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
      then txt;

    case ( txt,
           _,
           i_uid,
           i_size,
           i_bname,
           i_aname )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if(SolveLinearSystemMixed("));
        txt = Tpl.writeText(txt, i_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") != 0) found_solution = -1;"));
      then txt;
  end matchcontinue;
end fun_126;

protected function lm_127
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input Tpl.Text in_i_bname;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_bname, in_i_simCode)
    local
      Tpl.Text txt;
      Tpl.Text i_bname;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           i_bname,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //get_vector_elt("));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_127(txt, rest, i_bname, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_bname,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_127(txt, rest, i_bname, i_simCode);
      then txt;
  end matchcontinue;
end lm_127;

protected function lm_128
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preDisc;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preDisc;
algorithm
  (out_txt, out_i_preDisc) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preDisc, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preDisc;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preDisc,
           _ )
      then (txt, i_preDisc);

    case ( txt,
           (i_discEq as SimCode.SES_SIMPLE_ASSIGN(exp = i_discEq_exp, cref = i_discEq_cref)) :: rest,
           i_simCode,
           i_preDisc,
           i_context )
      local
        list<SimCode.SimEqSystem> rest;
        DAE.ComponentRef i_discEq_cref;
        DAE.Exp i_discEq_exp;
        SimCode.SimEqSystem i_discEq;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double discrete_loc2_"));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        (txt, i_preDisc) = daeExpToReal(txt, i_discEq_exp, i_context, i_preDisc, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = cref(txt, i_discEq_cref, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = discrete_loc2_"));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        (txt, i_preDisc) = lm_128(txt, rest, i_simCode, i_preDisc, i_context);
      then (txt, i_preDisc);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preDisc,
           i_context )
      local
        list<SimCode.SimEqSystem> rest;
      equation
        (txt, i_preDisc) = lm_128(txt, rest, i_simCode, i_preDisc, i_context);
      then (txt, i_preDisc);
  end matchcontinue;
end lm_128;

protected function lm_129
  input Tpl.Text in_txt;
  input list<Integer> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_it :: rest )
      local
        list<Integer> rest;
        Integer i_it;
      equation
        txt = Tpl.writeStr(txt, intString(i_it));
        txt = Tpl.nextIter(txt);
        txt = lm_129(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      local
        list<Integer> rest;
      equation
        txt = lm_129(txt, rest);
      then txt;
  end matchcontinue;
end lm_129;

protected function lm_130
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double discrete_loc_"));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_130(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_130(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_130;

protected function lm_131
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = _) :: rest )
      local
        list<SimCode.SimVar> rest;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ( Math.Abs(discrete_loc_"));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - discrete_loc2_"));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") > 1e-12) found_solution = 0;"));
        txt = Tpl.nextIter(txt);
        txt = lm_131(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_131(txt, rest);
      then txt;
  end matchcontinue;
end lm_131;

protected function lm_132
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = values[curValOffset+"));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("];"));
        txt = Tpl.nextIter(txt);
        txt = lm_132(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<SimCode.SimVar> rest;
      equation
        txt = lm_132(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_132;

protected function lm_133
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_name :: rest,
           i_simCode )
      local
        list<DAE.ComponentRef> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("nls_x["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = /*extraPolate("));
        txt = crefStr(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")*/ oldTimeDelta == 0.0 ? "));
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" : (time * ("));
        txt = oldCref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = old2Cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") + (oldTime * "));
        txt = old2Cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - oldTime2 * "));
        txt = oldCref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ")) / oldTimeDelta;\n",
                                    "nls_xold["
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = oldCref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_133(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<DAE.ComponentRef> rest;
      equation
        txt = lm_133(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_133;

protected function lm_134
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_name :: rest,
           i_simCode )
      local
        list<DAE.ComponentRef> rest;
        DAE.ComponentRef i_name;
        Integer i_i0;
      equation
        i_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = nls_x["));
        txt = Tpl.writeStr(txt, intString(i_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("];"));
        txt = Tpl.nextIter(txt);
        txt = lm_134(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<DAE.ComponentRef> rest;
      equation
        txt = lm_134(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_134;

protected function lm_135
  input Tpl.Text in_txt;
  input list<tuple<DAE.Exp, Integer>> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           (i_e, i_hidx) :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<tuple<DAE.Exp, Integer>> rest;
        Integer i_hidx;
        DAE.Exp i_e;
        Tpl.Text i_hInit;
      equation
        (i_hInit, i_preExp) = daeExp(Tpl.emptyTxt, i_e, i_context, i_preExp, i_simCode);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("H["));
        i_preExp = Tpl.writeStr(i_preExp, intString(i_hidx));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("] = "));
        i_preExp = Tpl.writeText(i_preExp, i_hInit);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(" ? 1.0 : 0.0;"));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*edge(H["));
        txt = Tpl.writeStr(txt, intString(i_hidx));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("])*/(H["));
        txt = Tpl.writeStr(txt, intString(i_hidx));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]!=0.0 && preH["));
        txt = Tpl.writeStr(txt, intString(i_hidx));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]==0.0)"));
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_135(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<tuple<DAE.Exp, Integer>> rest;
      equation
        (txt, i_preExp) = lm_135(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_135;

public function equation_
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_i_eq;
  input SimCode.Context in_i_context;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_eq, in_i_context, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(exp = i_exp, cref = i_cref),
           i_context,
           i_simCode )
      local
        DAE.ComponentRef i_cref;
        DAE.Exp i_exp;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExpToReal(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_cref, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           SimCode.SES_ARRAY_CALL_ASSIGN(componentRef = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SES_ARRAY_CALL_ASSIGN"));
      then txt;

    case ( txt,
           SimCode.SES_ALGORITHM(statements = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SES_ALGORITHM"));
      then txt;

    case ( txt,
           SimCode.SES_LINEAR(vars = i_vars, simJac = i_simJac, beqs = i_beqs, partOfMixed = i_partOfMixed),
           i_context,
           i_simCode )
      local
        Boolean i_partOfMixed;
        list<DAE.Exp> i_beqs;
        list<tuple<Integer, Integer, SimCode.SimEqSystem>> i_simJac;
        list<SimCode.SimVar> i_vars;
        Tpl.Text i_bname;
        Tpl.Text i_aname;
        Integer ret_3;
        Tpl.Text i_size;
        Integer ret_1;
        Tpl.Text i_uid;
      equation
        ret_1 = System.tmpTick();
        i_uid = Tpl.writeStr(Tpl.emptyTxt, intString(ret_1));
        ret_3 = listLength(i_vars);
        i_size = Tpl.writeStr(Tpl.emptyTxt, intString(ret_3));
        i_aname = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("A"));
        i_aname = Tpl.writeText(i_aname, i_uid);
        i_bname = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("b"));
        i_bname = Tpl.writeText(i_bname, i_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var "));
        txt = Tpl.writeText(txt, i_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new double["));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*"));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //declare_matrix("));
        txt = Tpl.writeText(txt, i_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ");\n",
                                    "var "
                                }, false));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new double["));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //declare_vector("));
        txt = Tpl.writeText(txt, i_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(");\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_124(txt, i_simJac, i_size, i_aname, i_simCode, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_125(txt, i_beqs, i_bname, i_simCode, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = fun_126(txt, i_partOfMixed, i_uid, i_size, i_bname, i_aname);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_127(txt, i_vars, i_bname, i_simCode);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           SimCode.SES_MIXED(cont = i_cont, discVars = i_discVars, values = i_values, discEqs = i_discEqs),
           i_context,
           i_simCode )
      local
        list<SimCode.SimEqSystem> i_discEqs;
        list<Integer> i_values;
        list<SimCode.SimVar> i_discVars;
        SimCode.SimEqSystem i_cont;
        Tpl.Text i_discLoc2;
        Tpl.Text i_preDisc;
        Integer ret_6;
        Tpl.Text i_valuesLenStr;
        Integer ret_4;
        Tpl.Text i_numDiscVarsStr;
        Tpl.Text i_contEqs;
        Integer ret_1;
        Tpl.Text i_uid;
      equation
        ret_1 = System.tmpTick();
        i_uid = Tpl.writeStr(Tpl.emptyTxt, intString(ret_1));
        i_contEqs = equation_(Tpl.emptyTxt, i_cont, i_context, i_simCode);
        ret_4 = listLength(i_discVars);
        i_numDiscVarsStr = Tpl.writeStr(Tpl.emptyTxt, intString(ret_4));
        ret_6 = listLength(i_values);
        i_valuesLenStr = Tpl.writeStr(Tpl.emptyTxt, intString(ret_6));
        i_preDisc = Tpl.emptyTxt;
        i_discLoc2 = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_discLoc2, i_preDisc) = lm_128(i_discLoc2, i_discEqs, i_simCode, i_preDisc, i_context);
        i_discLoc2 = Tpl.popIter(i_discLoc2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("// *** mixed_equation_system("));
        txt = Tpl.writeText(txt, i_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ") ***\n",
                                    "{ int found_solution = 0;\n",
                                    "  int cur_value_indx = -1;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var values = new double[]{"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_129(txt, i_values);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "};\n",
                                    "do {\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_130(txt, i_discVars, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("{\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_contEqs);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.writeText(txt, i_preDisc);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, i_discLoc2);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("{\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("// check_discrete_values("));
        txt = Tpl.writeText(txt, i_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_valuesLenStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ");\n",
                                    "if (found_solution == -1) { /*system of equations failed*/\n",
                                    "    found_solution = 0;\n",
                                    "} else {\n",
                                    "    found_solution = 1;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                     "\n",
                                                                     "else "
                                                                 }, false)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_131(txt, i_discVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "if (found_solution == 0) { //!found_solution\n",
                                    "    cur_value_indx++;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if (cur_value_indx >= "));
        txt = Tpl.writeText(txt, i_valuesLenStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/"));
        txt = Tpl.writeText(txt, i_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ") {\n",
                                    "    found_solution = -1; //?? failed ??\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("System.Diagnostics.Debug.WriteLine(\"Mixed system id=\" + "));
        txt = Tpl.writeText(txt, i_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" + \"failed.\");\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("} else {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var curValOffset = cur_value_indx*"));
        txt = Tpl.writeText(txt, i_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_132(txt, i_discVars, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("} while (found_solution == 0);\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} // *** mixed_equation_system_end("));
        txt = Tpl.writeText(txt, i_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") ***"));
      then txt;

    case ( txt,
           SimCode.SES_NONLINEAR(crefs = i_crefs, index = i_index),
           _,
           i_simCode )
      local
        Integer i_index;
        list<DAE.ComponentRef> i_crefs;
        Integer ret_1;
        Tpl.Text i_size;
      equation
        ret_1 = listLength(i_crefs);
        i_size = Tpl.writeStr(Tpl.emptyTxt, intString(ret_1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//start_nonlinear_system("));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ");\n",
                                    "{ var oldX = oldStates; var oldXd = oldStatesDerivatives;  var old2X = oldStates2; var old2Xd = oldStatesDerivatives2;\n",
                                    "  var oldY = oldAlgebraics; var old2Y = oldAlgebraics2; var oldTimeDelta = oldTime - oldTime2;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var nls_x = new double["));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; var nls_xold = new double["));
        txt = Tpl.writeText(txt, i_size);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("];\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_133(txt, i_crefs, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SolveNonlinearSystem(ResidualFun"));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", nls_x, nls_xold, "));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(");\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_134(txt, i_crefs, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} //end_nonlinear_system();"));
      then txt;

    case ( txt,
           SimCode.SES_WHEN(conditions = i_conditions, right = i_right, left = i_left),
           i_context,
           i_simCode )
      local
        DAE.ComponentRef i_left;
        DAE.Exp i_right;
        list<tuple<DAE.Exp, Integer>> i_conditions;
        Tpl.Text i_rightExp;
        Tpl.Text i_preExp2;
        Tpl.Text i_helpIf;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        i_helpIf = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(" || ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_helpIf, i_preExp) = lm_135(i_helpIf, i_conditions, i_simCode, i_preExp, i_context);
        i_helpIf = Tpl.popIter(i_helpIf);
        i_preExp2 = Tpl.emptyTxt;
        (i_rightExp, i_preExp2) = daeExp(Tpl.emptyTxt, i_right, i_context, i_preExp2, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, i_helpIf);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_preExp2);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_left, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_rightExp);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("} else {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = cref(txt, i_left, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = preCref(txt, i_left, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_equation"));
      then txt;
  end matchcontinue;
end equation_;

public function cref
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_i_cr;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_cr, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_cr as DAE.CREF_IDENT(ident = "xloc")),
           i_simCode )
      local
        DAE.ComponentRef i_cr;
      equation
        txt = crefStr(txt, i_cr, i_simCode);
      then txt;

    case ( txt,
           DAE.CREF_IDENT(ident = "time"),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("time"));
      then txt;

    case ( txt,
           i_cr,
           i_simCode )
      local
        DAE.ComponentRef i_cr;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*"));
        txt = crefStr(txt, i_cr, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
        txt = representationCref(txt, i_cr, i_simCode);
      then txt;
  end matchcontinue;
end cref;

protected function smf_138
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;

    case ( txt,
           SimCode.SIMVAR(varKind = i_varKind, type_ = i_type__, index = i_index) )
      local
        Integer i_index;
        DAE.ExpType i_type__;
        BackendDAE.VarKind i_varKind;
      equation
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end smf_138;

public function representationCref
  input Tpl.Text txt;
  input DAE.ComponentRef i_inCref;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
protected
  SimCode.SimVar ret_0;
algorithm
  ret_0 := SimCode.cref2simvar(i_inCref, i_simCode);
  out_txt := smf_138(txt, ret_0);
end representationCref;

public function representationArrayName
  input Tpl.Text in_txt;
  input BackendDAE.VarKind in_i_varKind;
  input DAE.ExpType in_i_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_varKind, in_i_type__)
    local
      Tpl.Text txt;
      DAE.ExpType i_type__;

    case ( txt,
           BackendDAE.VARIABLE(),
           i_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
        txt = representationArrayNameTypePostfix(txt, i_type__);
      then txt;

    case ( txt,
           BackendDAE.STATE(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("X"));
      then txt;

    case ( txt,
           BackendDAE.STATE_DER(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Xd"));
      then txt;

    case ( txt,
           BackendDAE.DUMMY_DER(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
      then txt;

    case ( txt,
           BackendDAE.DUMMY_STATE(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
      then txt;

    case ( txt,
           BackendDAE.DISCRETE(),
           i_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
        txt = representationArrayNameTypePostfix(txt, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*d*/"));
      then txt;

    case ( txt,
           BackendDAE.PARAM(),
           i_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("P"));
        txt = representationArrayNameTypePostfix(txt, i_type__);
      then txt;

    case ( txt,
           i_CONST,
           _ )
      local
        BackendDAE.VarKind i_CONST;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONST_VAR_KIND"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BAD_VARKIND"));
      then txt;
  end matchcontinue;
end representationArrayName;

public function representationArrayNameTypePostfix
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_type__)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ET_INT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("I"));
      then txt;

    case ( txt,
           DAE.ET_BOOL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("B"));
      then txt;

    case ( txt,
           DAE.ET_REAL() )
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BAD_ARRAY_NAME_POSTFIX"));
      then txt;
  end matchcontinue;
end representationArrayNameTypePostfix;

public function preCref
  input Tpl.Text txt;
  input DAE.ComponentRef i_cr;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*pre("));
  out_txt := crefStr(out_txt, i_cr, i_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/pre"));
  out_txt := representationCref(out_txt, i_cr, i_simCode);
end preCref;

public function derCref
  input Tpl.Text txt;
  input DAE.ComponentRef i_cr;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
protected
  DAE.ComponentRef ret_0;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*derCall!!("));
  out_txt := crefStr(out_txt, i_cr, i_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/"));
  ret_0 := SimCode.derComponentRef(i_cr);
  out_txt := representationCref(out_txt, ret_0, i_simCode);
end derCref;

public function oldCref
  input Tpl.Text txt;
  input DAE.ComponentRef i_cr;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*old("));
  out_txt := crefStr(out_txt, i_cr, i_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/old"));
  out_txt := representationCref(out_txt, i_cr, i_simCode);
end oldCref;

public function old2Cref
  input Tpl.Text txt;
  input DAE.ComponentRef i_cr;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*old2("));
  out_txt := crefStr(out_txt, i_cr, i_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/old2"));
  out_txt := representationCref(out_txt, i_cr, i_simCode);
end old2Cref;

protected function fun_146
  input Tpl.Text in_txt;
  input SimCode.Context in_i_context;
  input DAE.ComponentRef in_i_cr;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_context, in_i_cr, in_i_simCode)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_cr;
      SimCode.SimCode i_simCode;

    case ( txt,
           SimCode.FUNCTION_CONTEXT(),
           i_cr,
           i_simCode )
      equation
        txt = crefStr(txt, i_cr, i_simCode);
      then txt;

    case ( txt,
           _,
           i_cr,
           i_simCode )
      equation
        txt = cref(txt, i_cr, i_simCode);
      then txt;
  end matchcontinue;
end fun_146;

public function contextCref
  input Tpl.Text txt;
  input DAE.ComponentRef i_cr;
  input SimCode.Context i_context;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_146(txt, i_context, i_cr, i_simCode);
end contextCref;

public function crefStr
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_i_cr;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_cr, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.CREF_IDENT(ident = i_ident, subscriptLst = i_subscriptLst),
           i_simCode )
      local
        list<DAE.Subscript> i_subscriptLst;
        DAE.Ident i_ident;
      equation
        txt = Tpl.writeStr(txt, i_ident);
        txt = subscriptsStr(txt, i_subscriptLst, i_simCode);
      then txt;

    case ( txt,
           DAE.CREF_QUAL(ident = "$DER", componentRef = i_componentRef),
           i_simCode )
      local
        DAE.ComponentRef i_componentRef;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("der("));
        txt = crefStr(txt, i_componentRef, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.CREF_QUAL(ident = i_ident, subscriptLst = i_subscriptLst, componentRef = i_componentRef),
           i_simCode )
      local
        DAE.ComponentRef i_componentRef;
        list<DAE.Subscript> i_subscriptLst;
        DAE.Ident i_ident;
      equation
        txt = Tpl.writeStr(txt, i_ident);
        txt = subscriptsStr(txt, i_subscriptLst, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = crefStr(txt, i_componentRef, i_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CREF_NOT_IDENT_OR_QUAL"));
      then txt;
  end matchcontinue;
end crefStr;

protected function fun_149
  input Tpl.Text in_txt;
  input DAE.Subscript in_i_s;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_s, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.INDEX(exp = i_exp),
           i_simCode )
      local
        DAE.Exp i_exp;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (txt, i_preExp) = daeExp(txt, i_exp, SimCode.contextFunction, i_preExp, i_simCode);
      then txt;

    case ( txt,
           DAE.SLICE(exp = i_exp),
           i_simCode )
      local
        DAE.Exp i_exp;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (txt, i_preExp) = daeExp(txt, i_exp, SimCode.contextFunction, i_preExp, i_simCode);
      then txt;

    case ( txt,
           DAE.WHOLEDIM(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("WHOLEDIM"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_SUBSCRIPT"));
      then txt;
  end matchcontinue;
end fun_149;

protected function lm_150
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_items;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_s :: rest,
           i_simCode )
      local
        list<DAE.Subscript> rest;
        DAE.Subscript i_s;
      equation
        txt = fun_149(txt, i_s, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_150(txt, rest, i_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode )
      local
        list<DAE.Subscript> rest;
      equation
        txt = lm_150(txt, rest, i_simCode);
      then txt;
  end matchcontinue;
end lm_150;

public function subscriptsStr
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_i_subscripts;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_subscripts, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_subscripts,
           i_simCode )
      local
        list<DAE.Subscript> i_subscripts;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_150(txt, i_subscripts, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then txt;
  end matchcontinue;
end subscriptsStr;

public function dotPath
  input Tpl.Text in_txt;
  input Absyn.Path in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      local
        Absyn.Path i_path;
        Absyn.Ident i_name;
      equation
        txt = Tpl.writeStr(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = dotPath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name) )
      local
        Absyn.Ident i_name;
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      local
        Absyn.Path i_path;
      equation
        txt = dotPath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dotPath;

public function underscorePath
  input Tpl.Text in_txt;
  input Absyn.Path in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      local
        Absyn.Path i_path;
        Absyn.Ident i_name;
        String ret_0;
      equation
        ret_0 = System.stringReplace(i_name, "_", "__");
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_"));
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name) )
      local
        Absyn.Ident i_name;
        String ret_0;
      equation
        ret_0 = System.stringReplace(i_name, "_", "__");
        txt = Tpl.writeStr(txt, ret_0);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      local
        Absyn.Path i_path;
      equation
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end underscorePath;

protected function lm_154
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
        DAE.Statement i_it;
      equation
        txt = algStatement(txt, i_it, i_context, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_154(txt, rest, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
      equation
        txt = lm_154(txt, rest, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_154;

protected function lm_155
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
        DAE.Statement i_stmt;
      equation
        txt = algStatement(txt, i_stmt, i_context, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_155(txt, rest, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
      equation
        txt = lm_155(txt, rest, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_155;

protected function lm_156
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
        DAE.Statement i_stmt;
      equation
        txt = algStatement(txt, i_stmt, i_context, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_156(txt, rest, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
      equation
        txt = lm_156(txt, rest, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_156;

public function algStatement
  input Tpl.Text in_txt;
  input DAE.Statement in_i_it;
  input SimCode.Context in_i_context;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_context, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.STMT_ASSIGN(exp1 = DAE.CREF(componentRef = DAE.WILD()), exp = i_e),
           i_context,
           i_simCode )
      local
        DAE.Exp i_e;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_e, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, i_expPart);
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN(exp1 = (i_exp1 as DAE.CREF(componentRef = _)), exp = i_exp),
           i_context,
           i_simCode )
      local
        DAE.Exp i_exp;
        DAE.Exp i_exp1;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        (txt, i_preExp) = scalarLhsCref(txt, i_exp1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN(exp1 = i_exp1, exp = i_exp),
           i_context,
           i_simCode )
      local
        DAE.Exp i_exp;
        DAE.Exp i_exp1;
        Tpl.Text i_expPart2;
        Tpl.Text i_expPart1;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart1, i_preExp) = daeExp(Tpl.emptyTxt, i_exp1, i_context, i_preExp, i_simCode);
        (i_expPart2, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, i_expPart1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_expPart2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN_ARR(componentRef = DAE.CREF_IDENT(subscriptLst = (i_subs as _ :: _), ident = i_componentRef_ident), exp = i_exp),
           i_context,
           i_simCode )
      local
        DAE.Exp i_exp;
        DAE.Ident i_componentRef_ident;
        list<DAE.Subscript> i_subs;
        Tpl.Text i_spec;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        (i_spec, i_preExp) = daeExpCrefRhsIndexSpec(Tpl.emptyTxt, i_subs, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeStr(txt, i_componentRef_ident);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".AssignSpec("));
        txt = Tpl.writeText(txt, i_spec);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".A);"));
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN_ARR(exp = i_exp, componentRef = i_componentRef),
           i_context,
           i_simCode )
      local
        DAE.ComponentRef i_componentRef;
        DAE.Exp i_exp;
        Tpl.Text i_expPart;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ArrayCopy("));
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".A, "));
        txt = contextCref(txt, i_componentRef, i_context, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".A);"));
      then txt;

    case ( txt,
           DAE.STMT_IF(exp = i_exp, statementLst = i_statementLst, else_ = i_else__),
           i_context,
           i_simCode )
      local
        DAE.Else i_else__;
        list<DAE.Statement> i_statementLst;
        DAE.Exp i_exp;
        Tpl.Text i_condExp;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_condExp, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, i_condExp);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_154(txt, i_statementLst, i_simCode, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = elseExpr(txt, i_else__, i_context, i_simCode);
      then txt;

    case ( txt,
           DAE.STMT_FOR(range = (i_rng as DAE.RANGE(ty = _)), type_ = i_type__, iterIsArray = i_iterIsArray, statementLst = i_statementLst, iter = i_iter),
           i_context,
           i_simCode )
      local
        DAE.Ident i_iter;
        list<DAE.Statement> i_statementLst;
        Boolean i_iterIsArray;
        DAE.ExpType i_type__;
        DAE.Exp i_rng;
        Tpl.Text i_stmtStr;
        Tpl.Text i_identTypeShort;
        Tpl.Text i_identType;
      equation
        i_identType = expType(Tpl.emptyTxt, i_type__, i_iterIsArray);
        i_identTypeShort = expTypeShort(Tpl.emptyTxt, i_type__);
        i_stmtStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        i_stmtStr = lm_155(i_stmtStr, i_statementLst, i_simCode, i_context);
        i_stmtStr = Tpl.popIter(i_stmtStr);
        (txt, i_stmtStr) = algStmtForRange_impl(txt, i_rng, i_iter, Tpl.textString(i_identType), Tpl.textString(i_identTypeShort), i_stmtStr, i_context, i_simCode);
      then txt;

    case ( txt,
           (i_s as DAE.STMT_FOR(type_ = _)),
           _,
           _ )
      local
        DAE.Statement i_s;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("algStmtForGeneric_NOT_IMPLEMENTED"));
      then txt;

    case ( txt,
           DAE.STMT_WHILE(exp = i_exp, statementLst = i_statementLst),
           i_context,
           i_simCode )
      local
        list<DAE.Statement> i_statementLst;
        DAE.Exp i_exp;
        Tpl.Text i_var;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_var, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("for(;;) {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if (!"));
        txt = Tpl.writeText(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") break;\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_156(txt, i_statementLst, i_simCode, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_IMPLEMENTED_ALG_STATEMENT"));
      then txt;
  end matchcontinue;
end algStatement;

protected function fun_158
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_i_expOption;
  input Tpl.Text in_i_body;
  input Tpl.Text in_i_startValue;
  input Tpl.Text in_i_iterName;
  input Tpl.Text in_i_stopValue;
  input Tpl.Text in_i_stopVar;
  input String in_i_type;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_stopVar;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_stopVar, out_i_preExp) :=
  matchcontinue(in_txt, in_i_expOption, in_i_body, in_i_startValue, in_i_iterName, in_i_stopValue, in_i_stopVar, in_i_type, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      Tpl.Text i_body;
      Tpl.Text i_startValue;
      Tpl.Text i_iterName;
      Tpl.Text i_stopValue;
      Tpl.Text i_stopVar;
      String i_type;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           SOME(i_eo),
           i_body,
           i_startValue,
           i_iterName,
           i_stopValue,
           i_stopVar,
           i_type,
           i_simCode,
           i_preExp,
           i_context )
      local
        DAE.Exp i_eo;
        Tpl.Text i_stepValue;
        Tpl.Text i_stepVar;
      equation
        i_stepVar = Tpl.emptyTxt;
        (i_stepValue, i_preExp) = daeExp(Tpl.emptyTxt, i_eo, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        (txt, i_stepVar) = tempDecl(txt, i_type, i_stepVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_stepValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; "));
        (txt, i_stopVar) = tempDecl(txt, i_type, i_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_stopValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "for("
                                }, false));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_startValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";("));
        txt = Tpl.writeText(txt, i_stepVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > 0? "));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
        txt = Tpl.writeText(txt, i_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" : "));
        txt = Tpl.writeText(txt, i_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("); "));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" += "));
        txt = Tpl.writeText(txt, i_stepVar);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_body);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then (txt, i_stopVar, i_preExp);

    case ( txt,
           _,
           i_body,
           i_startValue,
           i_iterName,
           i_stopValue,
           i_stopVar,
           i_type,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        (txt, i_stopVar) = tempDecl(txt, i_type, i_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_stopValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "for("
                                }, false));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, i_startValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; "));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
        txt = Tpl.writeText(txt, i_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; "));
        txt = Tpl.writeText(txt, i_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" += 1) {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_body);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then (txt, i_stopVar, i_preExp);
  end matchcontinue;
end fun_158;

protected function fun_159
  input Tpl.Text in_txt;
  input DAE.Exp in_i_range;
  input Absyn.Ident in_i_iterator;
  input String in_i_type;
  input Tpl.Text in_i_body;
  input SimCode.Context in_i_context;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_range, in_i_iterator, in_i_type, in_i_body, in_i_context, in_i_simCode)
    local
      Tpl.Text txt;
      Absyn.Ident i_iterator;
      String i_type;
      Tpl.Text i_body;
      SimCode.Context i_context;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.RANGE(exp = i_exp, range = i_range, expOption = i_expOption),
           i_iterator,
           i_type,
           i_body,
           i_context,
           i_simCode )
      local
        Option<DAE.Exp> i_expOption;
        DAE.Exp i_range;
        DAE.Exp i_exp;
        Tpl.Text i_stopValue;
        Tpl.Text i_startValue;
        Tpl.Text i_preExp;
        Tpl.Text i_stopVar;
        Tpl.Text i_iterName;
      equation
        i_iterName = Tpl.writeStr(Tpl.emptyTxt, i_iterator);
        i_stopVar = Tpl.emptyTxt;
        i_preExp = Tpl.emptyTxt;
        (i_startValue, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        (i_stopValue, i_preExp) = daeExp(Tpl.emptyTxt, i_range, i_context, i_preExp, i_simCode);
        (txt, i_stopVar, i_preExp) = fun_158(txt, i_expOption, i_body, i_startValue, i_iterName, i_stopValue, i_stopVar, i_type, i_simCode, i_preExp, i_context);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_159;

public function algStmtForRange_impl
  input Tpl.Text txt;
  input DAE.Exp i_range;
  input Absyn.Ident i_iterator;
  input String i_type;
  input String i_shortType;
  input Tpl.Text i_body;
  input SimCode.Context i_context;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_body;
algorithm
  out_txt := fun_159(txt, i_range, i_iterator, i_type, i_body, i_context, i_simCode);
  out_i_body := i_body;
end algStmtForRange_impl;

protected function lm_161
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
        DAE.Statement i_it;
      equation
        txt = algStatement(txt, i_it, i_context, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_161(txt, rest, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
      equation
        txt = lm_161(txt, rest, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_161;

protected function lm_162
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
        DAE.Statement i_it;
      equation
        txt = algStatement(txt, i_it, i_context, i_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_162(txt, rest, i_simCode, i_context);
      then txt;

    case ( txt,
           _ :: rest,
           i_simCode,
           i_context )
      local
        list<DAE.Statement> rest;
      equation
        txt = lm_162(txt, rest, i_simCode, i_context);
      then txt;
  end matchcontinue;
end lm_162;

public function elseExpr
  input Tpl.Text in_txt;
  input DAE.Else in_i_it;
  input SimCode.Context in_i_context;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_context, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.NOELSE(),
           _,
           _ )
      then txt;

    case ( txt,
           DAE.ELSEIF(exp = i_exp, statementLst = i_statementLst, else_ = i_else__),
           i_context,
           i_simCode )
      local
        DAE.Else i_else__;
        list<DAE.Statement> i_statementLst;
        DAE.Exp i_exp;
        Tpl.Text i_condExp;
        Tpl.Text i_preExp;
      equation
        i_preExp = Tpl.emptyTxt;
        (i_condExp, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("else {\n"));
        txt = Tpl.writeText(txt, i_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, i_condExp);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_161(txt, i_statementLst, i_simCode, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = elseExpr(txt, i_else__, i_context, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           DAE.ELSE(statementLst = i_statementLst),
           i_context,
           i_simCode )
      local
        list<DAE.Statement> i_statementLst;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("else {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_162(txt, i_statementLst, i_simCode, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end elseExpr;

protected function fun_164
  input Tpl.Text in_txt;
  input Boolean in_it;
  input DAE.ComponentRef in_i_ecr_componentRef;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input DAE.Exp in_i_ecr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_ecr_componentRef, in_i_simCode, in_i_preExp, in_i_context, in_i_ecr)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_ecr_componentRef;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      DAE.Exp i_ecr;

    case ( txt,
           false,
           _,
           i_simCode,
           i_preExp,
           i_context,
           i_ecr )
      equation
        (txt, i_preExp) = daeExpCrefRhs(txt, i_ecr, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           _,
           i_ecr_componentRef,
           i_simCode,
           i_preExp,
           i_context,
           _ )
      equation
        txt = contextCref(txt, i_ecr_componentRef, i_context, i_simCode);
      then (txt, i_preExp);
  end matchcontinue;
end fun_164;

public function scalarLhsCref
  input Tpl.Text in_txt;
  input DAE.Exp in_i_ecr;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_ecr, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_ecr as DAE.CREF(componentRef = (i_ecr_componentRef as DAE.CREF_IDENT(subscriptLst = i_subs)))),
           i_context,
           i_preExp,
           i_simCode )
      local
        list<DAE.Subscript> i_subs;
        DAE.ComponentRef i_ecr_componentRef;
        DAE.Exp i_ecr;
        Boolean ret_0;
      equation
        ret_0 = SimCode.crefNoSub(i_ecr_componentRef);
        (txt, i_preExp) = fun_164(txt, ret_0, i_ecr_componentRef, i_simCode, i_preExp, i_context, i_ecr);
      then (txt, i_preExp);

    case ( txt,
           (i_ecr as DAE.CREF(componentRef = (i_ecr_componentRef as DAE.CREF_QUAL(ident = _)))),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.ComponentRef i_ecr_componentRef;
        DAE.Exp i_ecr;
      equation
        txt = contextCref(txt, i_ecr_componentRef, i_context, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ONLY_IDENT_OR_QUAL_CREF_SUPPORTED_SLHS"));
      then (txt, i_preExp);
  end matchcontinue;
end scalarLhsCref;

public function rhsCref
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_i_it;
  input DAE.ExpType in_i_ty;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_ty, in_i_simCode)
    local
      Tpl.Text txt;
      DAE.ExpType i_ty;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.CREF_IDENT(ident = i_ident),
           i_ty,
           _ )
      local
        DAE.Ident i_ident;
      equation
        txt = rhsCrefType(txt, i_ty);
        txt = replaceDollarWorkaround(txt, i_ident);
      then txt;

    case ( txt,
           DAE.CREF_QUAL(ident = i_ident, componentRef = i_componentRef),
           i_ty,
           i_simCode )
      local
        DAE.ComponentRef i_componentRef;
        DAE.Ident i_ident;
      equation
        txt = rhsCrefType(txt, i_ty);
        txt = Tpl.writeStr(txt, i_ident);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = rhsCref(txt, i_componentRef, i_ty, i_simCode);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("rhsCref:ERROR"));
      then txt;
  end matchcontinue;
end rhsCref;

public function rhsCrefType
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ET_INT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(int)"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end rhsCrefType;

public function replaceDollarWorkaround
  input Tpl.Text txt;
  input String i_ident;

  output Tpl.Text out_txt;
protected
  String ret_1;
  String ret_0;
algorithm
  ret_0 := System.stringReplace(i_ident, "$DER", "Der_");
  ret_1 := System.stringReplace(ret_0, "$", "");
  out_txt := Tpl.writeStr(txt, ret_1);
end replaceDollarWorkaround;

protected function fun_169
  input Tpl.Text in_txt;
  input Boolean in_i_bool;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_bool)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(0)"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(1)"));
      then txt;
  end matchcontinue;
end fun_169;

protected function fun_170
  input Tpl.Text in_txt;
  input SimCode.Context in_i_context;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input DAE.Exp in_i_inExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_context, in_i_simCode, in_i_preExp, in_i_inExp)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      DAE.Exp i_inExp;

    case ( txt,
           (i_context as SimCode.FUNCTION_CONTEXT()),
           i_simCode,
           i_preExp,
           i_inExp )
      local
        SimCode.Context i_context;
      equation
        (txt, i_preExp) = daeExpCrefRhs(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpRecordCrefRhs_NOT_YET"));
      then (txt, i_preExp);
  end matchcontinue;
end fun_170;

public function daeExp
  input Tpl.Text in_txt;
  input DAE.Exp in_i_inExp;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_inExp, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.ICONST(integer = i_integer),
           _,
           i_preExp,
           _ )
      local
        Integer i_integer;
      equation
        txt = Tpl.writeStr(txt, intString(i_integer));
      then (txt, i_preExp);

    case ( txt,
           DAE.RCONST(real = i_real),
           _,
           i_preExp,
           _ )
      local
        Real i_real;
      equation
        txt = Tpl.writeStr(txt, realString(i_real));
      then (txt, i_preExp);

    case ( txt,
           DAE.SCONST(string = i_string),
           _,
           i_preExp,
           _ )
      local
        String i_string;
        String ret_0;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\""));
        ret_0 = Util.escapeModelicaStringToCString(i_string);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\""));
      then (txt, i_preExp);

    case ( txt,
           DAE.BCONST(bool = i_bool),
           _,
           i_preExp,
           _ )
      local
        Boolean i_bool;
      equation
        txt = fun_169(txt, i_bool);
      then (txt, i_preExp);

    case ( txt,
           DAE.ENUM_LITERAL(index = i_index, name = i_name),
           _,
           i_preExp,
           _ )
      local
        Absyn.Path i_name;
        Integer i_index;
      equation
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*ENUM:"));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CREF(ty = DAE.ET_FUNCTION_REFERENCE_FUNC(builtin = _), componentRef = i_componentRef),
           _,
           i_preExp,
           i_simCode )
      local
        DAE.ComponentRef i_componentRef;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FUNC_REF_NOT_SUPPORTED(cr="));
        txt = crefStr(txt, i_componentRef, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.CREF(ty = DAE.ET_COMPLEX(complexClassType = ClassInf.RECORD(path = _)))),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = fun_170(txt, i_context, i_simCode, i_preExp, i_inExp);
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.CREF(componentRef = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpCrefRhs(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.LBINARY(operator = i_operator, exp1 = i_exp1, exp2 = i_exp2),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_exp2;
        DAE.Exp i_exp1;
        DAE.Operator i_operator;
      equation
        (txt, i_preExp) = daeExpBinary(txt, i_operator, i_exp1, i_exp2, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.BINARY(operator = i_operator, exp1 = i_exp1, exp2 = i_exp2),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_exp2;
        DAE.Exp i_exp1;
        DAE.Operator i_operator;
      equation
        (txt, i_preExp) = daeExpBinary(txt, i_operator, i_exp1, i_exp2, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.LUNARY(operator = i_operator, exp = i_exp),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_exp;
        DAE.Operator i_operator;
      equation
        (txt, i_preExp) = daeExpUnary(txt, i_operator, i_exp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.UNARY(operator = i_operator, exp = i_exp),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_exp;
        DAE.Operator i_operator;
      equation
        (txt, i_preExp) = daeExpUnary(txt, i_operator, i_exp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.RELATION(operator = i_operator, exp1 = i_exp1, exp2 = i_exp2),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_exp2;
        DAE.Exp i_exp1;
        DAE.Operator i_operator;
      equation
        (txt, i_preExp) = daeExpRelation(txt, i_operator, i_exp1, i_exp2, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.IFEXP(expCond = i_expCond, expThen = i_expThen, expElse = i_expElse),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_expElse;
        DAE.Exp i_expThen;
        DAE.Exp i_expCond;
      equation
        (txt, i_preExp) = daeExpIf(txt, i_expCond, i_expThen, i_expElse, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.CALL(path = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpCall(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.ARRAY(ty = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpArray(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.MATRIX(ty = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpMatrix(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.RANGE(ty = _),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RANGE_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           DAE.TUPLE(PR = _),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TUPLE_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.CAST(ty = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpCast(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.ASUB(exp = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpAsub(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           (i_inExp as DAE.SIZE(exp = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_inExp;
      equation
        (txt, i_preExp) = daeExpSize(txt, i_inExp, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.CODE(code = _),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CODE_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           DAE.REDUCTION(path = _),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REDUCTION_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           DAE.END(),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           DAE.LIST(ty = _),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LIST_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CONS(ty = _),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONS_NOT_IMPLEMENTED"));
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_EXP"));
      then (txt, i_preExp);
  end matchcontinue;
end daeExp;

protected function fun_172
  input Tpl.Text in_txt;
  input DAE.Exp in_i_dim;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_expPart;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_dim, in_i_simCode, in_i_preExp, in_i_context, in_i_expPart)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      Tpl.Text i_expPart;

    case ( txt,
           DAE.ICONST(integer = i_integer),
           _,
           i_preExp,
           _,
           i_expPart )
      local
        Integer i_integer;
      equation
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".size"));
        txt = Tpl.writeStr(txt, intString(i_integer));
      then (txt, i_preExp);

    case ( txt,
           i_dim,
           i_simCode,
           i_preExp,
           i_context,
           i_expPart )
      local
        DAE.Exp i_dim;
      equation
        txt = Tpl.writeText(txt, i_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".size("));
        (txt, i_preExp) = daeExp(txt, i_dim, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);
  end matchcontinue;
end fun_172;

public function daeExpSize
  input Tpl.Text in_txt;
  input DAE.Exp in_i_esize;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_esize, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.SIZE(exp = (i_exp as DAE.CREF(componentRef = _)), sz = SOME(i_dim)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_dim;
        DAE.Exp i_exp;
        Tpl.Text i_expPart;
      equation
        (i_expPart, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        (txt, i_preExp) = fun_172(txt, i_dim, i_simCode, i_preExp, i_context, i_expPart);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("size_X_NOT_IMPLEMENTED"));
      then (txt, i_preExp);
  end matchcontinue;
end daeExpSize;

protected function lm_174
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           DAE.INDEX(exp = i_exp) :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Subscript> rest;
        DAE.Exp i_exp;
      equation
        (txt, i_preExp) = daeExp(txt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_174(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Subscript> rest;
      equation
        (txt, i_preExp) = lm_174(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_174;

protected function fun_175
  input Tpl.Text in_txt;
  input Boolean in_it;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;
  input DAE.ComponentRef in_i_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_preExp, in_i_simCode, in_i_context, in_i_cr)
    local
      Tpl.Text txt;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;
      DAE.ComponentRef i_cr;

    case ( txt,
           false,
           i_preExp,
           i_simCode,
           i_context,
           i_cr )
      local
        list<DAE.Subscript> ret_3;
        Tpl.Text i_spec;
        DAE.ComponentRef ret_1;
        Tpl.Text i_arrName;
      equation
        ret_1 = ComponentReference.crefStripLastSubs(i_cr);
        i_arrName = contextCref(Tpl.emptyTxt, ret_1, i_context, i_simCode);
        ret_3 = ComponentReference.crefSubs(i_cr);
        (i_spec, i_preExp) = daeExpCrefRhsIndexSpec(Tpl.emptyTxt, ret_3, i_context, i_preExp, i_simCode);
        txt = Tpl.writeText(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".Array1Spec("));
        txt = Tpl.writeText(txt, i_spec);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           _,
           i_preExp,
           i_simCode,
           i_context,
           i_cr )
      local
        list<DAE.Subscript> ret_2;
        DAE.ComponentRef ret_1;
        Tpl.Text i_arrName;
      equation
        ret_1 = ComponentReference.crefStripLastSubs(i_cr);
        i_arrName = contextCref(Tpl.emptyTxt, ret_1, i_context, i_simCode);
        txt = Tpl.writeText(txt, i_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        ret_2 = ComponentReference.crefSubs(i_cr);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, i_preExp) = lm_174(txt, ret_2, i_simCode, i_preExp, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, i_preExp);
  end matchcontinue;
end fun_175;

protected function fun_176
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_ecr_ty;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;
  input DAE.ComponentRef in_i_cr;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_ecr_ty, in_i_simCode, in_i_context, in_i_cr)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;
      DAE.ComponentRef i_cr;

    case ( txt,
           DAE.ET_INT(),
           i_simCode,
           i_context,
           i_cr )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(int)"));
        txt = contextCref(txt, i_cr, i_context, i_simCode);
      then txt;

    case ( txt,
           DAE.ET_BOOL(),
           i_simCode,
           i_context,
           i_cr )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = contextCref(txt, i_cr, i_context, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" !=0.0)"));
      then txt;

    case ( txt,
           _,
           i_simCode,
           i_context,
           i_cr )
      equation
        txt = contextCref(txt, i_cr, i_context, i_simCode);
      then txt;
  end matchcontinue;
end fun_176;

protected function fun_177
  input Tpl.Text in_txt;
  input Boolean in_it;
  input DAE.ExpType in_i_ecr_ty;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;
  input DAE.ComponentRef in_i_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_ecr_ty, in_i_preExp, in_i_simCode, in_i_context, in_i_cr)
    local
      Tpl.Text txt;
      DAE.ExpType i_ecr_ty;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;
      DAE.ComponentRef i_cr;

    case ( txt,
           false,
           _,
           i_preExp,
           i_simCode,
           i_context,
           i_cr )
      local
        Boolean ret_0;
      equation
        ret_0 = SimCode.crefSubIsScalar(i_cr);
        (txt, i_preExp) = fun_175(txt, ret_0, i_preExp, i_simCode, i_context, i_cr);
      then (txt, i_preExp);

    case ( txt,
           _,
           i_ecr_ty,
           i_preExp,
           i_simCode,
           i_context,
           i_cr )
      equation
        txt = fun_176(txt, i_ecr_ty, i_simCode, i_context, i_cr);
      then (txt, i_preExp);
  end matchcontinue;
end fun_177;

protected function fun_178
  input Tpl.Text in_txt;
  input String in_it;
  input Tpl.Text in_i_box;
  input DAE.ExpType in_i_ecr_ty;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;
  input SimCode.Context in_i_context;
  input DAE.ComponentRef in_i_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_box, in_i_ecr_ty, in_i_preExp, in_i_simCode, in_i_context, in_i_cr)
    local
      Tpl.Text txt;
      Tpl.Text i_box;
      DAE.ExpType i_ecr_ty;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;
      SimCode.Context i_context;
      DAE.ComponentRef i_cr;

    case ( txt,
           "",
           _,
           i_ecr_ty,
           i_preExp,
           i_simCode,
           i_context,
           i_cr )
      local
        Boolean ret_0;
      equation
        ret_0 = SimCode.crefIsScalar(i_cr, i_context);
        (txt, i_preExp) = fun_177(txt, ret_0, i_ecr_ty, i_preExp, i_simCode, i_context, i_cr);
      then (txt, i_preExp);

    case ( txt,
           _,
           i_box,
           _,
           i_preExp,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeText(txt, i_box);
      then (txt, i_preExp);
  end matchcontinue;
end fun_178;

public function daeExpCrefRhs
  input Tpl.Text in_txt;
  input DAE.Exp in_i_ecr;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_ecr, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_ecr as DAE.CREF(componentRef = i_cr, ty = i_ecr_ty)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.ExpType i_ecr_ty;
        DAE.ComponentRef i_cr;
        DAE.Exp i_ecr;
        String str_1;
        Tpl.Text i_box;
      equation
        (i_box, i_preExp) = daeExpCrefRhsArrayBox(Tpl.emptyTxt, i_ecr, i_context, i_preExp, i_simCode);
        str_1 = Tpl.textString(i_box);
        (txt, i_preExp) = fun_178(txt, str_1, i_box, i_ecr_ty, i_preExp, i_simCode, i_context, i_cr);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_RHS_CREF"));
      then (txt, i_preExp);
  end matchcontinue;
end daeExpCrefRhs;

protected function lm_180
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_dim :: rest )
      local
        list<DAE.Dimension> rest;
        DAE.Dimension i_dim;
      equation
        txt = dimension(txt, i_dim);
        txt = Tpl.nextIter(txt);
        txt = lm_180(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      local
        list<DAE.Dimension> rest;
      equation
        txt = lm_180(txt, rest);
      then txt;
  end matchcontinue;
end lm_180;

protected function fun_181
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;
  input SimCode.SimCode in_i_simCode;
  input DAE.ComponentRef in_i_ecr_componentRef;
  input Tpl.Text in_i_dimsValuesStr;
  input Tpl.Text in_i_arrType;
  input Tpl.Text in_i_tmpArr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_tmpArr;
algorithm
  (out_txt, out_i_tmpArr) :=
  matchcontinue(in_txt, in_it, in_i_simCode, in_i_ecr_componentRef, in_i_dimsValuesStr, in_i_arrType, in_i_tmpArr)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      DAE.ComponentRef i_ecr_componentRef;
      Tpl.Text i_dimsValuesStr;
      Tpl.Text i_arrType;
      Tpl.Text i_tmpArr;

    case ( txt,
           SimCode.SIMVAR(index = i_index, varKind = i_varKind, type_ = i_type__),
           i_simCode,
           i_ecr_componentRef,
           i_dimsValuesStr,
           i_arrType,
           i_tmpArr )
      local
        DAE.ExpType i_type__;
        BackendDAE.VarKind i_varKind;
        Integer i_index;
      equation
        (txt, i_tmpArr) = tempDecl(txt, "var", i_tmpArr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new "));
        txt = Tpl.writeText(txt, i_arrType);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_dimsValuesStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-1, /*"));
        txt = crefStr(txt, i_ecr_componentRef, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then (txt, i_tmpArr);

    case ( txt,
           _,
           _,
           _,
           _,
           _,
           i_tmpArr )
      then (txt, i_tmpArr);
  end matchcontinue;
end fun_181;

protected function fun_182
  input Tpl.Text in_txt;
  input SimCode.Context in_i_context;
  input SimCode.SimCode in_i_simCode;
  input DAE.ComponentRef in_i_ecr_componentRef;
  input Tpl.Text in_i_preExp;
  input list<DAE.Dimension> in_i_dims;
  input DAE.ExpType in_i_aty;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_context, in_i_simCode, in_i_ecr_componentRef, in_i_preExp, in_i_dims, in_i_aty)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      DAE.ComponentRef i_ecr_componentRef;
      Tpl.Text i_preExp;
      list<DAE.Dimension> i_dims;
      DAE.ExpType i_aty;

    case ( txt,
           SimCode.FUNCTION_CONTEXT(),
           _,
           _,
           i_preExp,
           _,
           _ )
      then (txt, i_preExp);

    case ( txt,
           _,
           i_simCode,
           i_ecr_componentRef,
           i_preExp,
           i_dims,
           i_aty )
      local
        SimCode.SimVar ret_4;
        Tpl.Text i_dimsValuesStr;
        Integer ret_2;
        Tpl.Text i_arrType;
        Tpl.Text i_tmpArr;
      equation
        i_tmpArr = Tpl.emptyTxt;
        ret_2 = listLength(i_dims);
        i_arrType = expTypeArray(Tpl.emptyTxt, i_aty, ret_2);
        i_dimsValuesStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        i_dimsValuesStr = lm_180(i_dimsValuesStr, i_dims);
        i_dimsValuesStr = Tpl.popIter(i_dimsValuesStr);
        ret_4 = SimCode.cref2simvar(i_ecr_componentRef, i_simCode);
        (i_preExp, i_tmpArr) = fun_181(i_preExp, ret_4, i_simCode, i_ecr_componentRef, i_dimsValuesStr, i_arrType, i_tmpArr);
        txt = Tpl.writeText(txt, i_tmpArr);
      then (txt, i_preExp);
  end matchcontinue;
end fun_182;

public function daeExpCrefRhsArrayBox
  input Tpl.Text in_txt;
  input DAE.Exp in_i_exp;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_exp, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_ecr as DAE.CREF(ty = DAE.ET_ARRAY(ty = i_aty, arrayDimensions = i_dims), componentRef = i_ecr_componentRef)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.ComponentRef i_ecr_componentRef;
        list<DAE.Dimension> i_dims;
        DAE.ExpType i_aty;
        DAE.Exp i_ecr;
      equation
        (txt, i_preExp) = fun_182(txt, i_context, i_simCode, i_ecr_componentRef, i_preExp, i_dims, i_aty);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);
  end matchcontinue;
end daeExpCrefRhsArrayBox;

protected function lm_184
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_e :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_e;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = expTypeFromExp(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        (txt, i_preExp) = daeExp(txt, i_e, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-1"));
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_184(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
      equation
        (txt, i_preExp) = lm_184(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_184;

protected function fun_185
  input Tpl.Text in_txt;
  input DAE.Exp in_i_exp;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_exp, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           DAE.ARRAY(scalar = true, ty = DAE.ET_INT(), array = i_array),
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> i_array;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("new int[]{"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, i_preExp) = lm_184(txt, i_array, i_simCode, i_preExp, i_context);
        txt = Tpl.popIter(txt);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UKNOWN_SLICE_EXP"));
      then (txt, i_preExp);
  end matchcontinue;
end fun_185;

protected function fun_186
  input Tpl.Text in_txt;
  input DAE.Subscript in_i_sub;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_sub, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           DAE.INDEX(exp = i_exp),
           i_simCode,
           i_preExp,
           i_context )
      local
        DAE.Exp i_exp;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("new int[]{"));
        (txt, i_preExp) = daeExp(txt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-1}"));
      then (txt, i_preExp);

    case ( txt,
           DAE.WHOLEDIM(),
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("null"));
      then (txt, i_preExp);

    case ( txt,
           DAE.SLICE(exp = i_exp),
           i_simCode,
           i_preExp,
           i_context )
      local
        DAE.Exp i_exp;
      equation
        (txt, i_preExp) = fun_185(txt, i_exp, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);
  end matchcontinue;
end fun_186;

protected function lm_187
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_sub :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Subscript> rest;
        DAE.Subscript i_sub;
      equation
        (txt, i_preExp) = fun_186(txt, i_sub, i_simCode, i_preExp, i_context);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_187(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Subscript> rest;
      equation
        (txt, i_preExp) = lm_187(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_187;

public function daeExpCrefRhsIndexSpec
  input Tpl.Text txt;
  input list<DAE.Subscript> i_subs;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  (out_txt, out_i_preExp) := lm_187(out_txt, i_subs, i_simCode, i_preExp, i_context);
  out_txt := Tpl.popIter(out_txt);
end daeExpCrefRhsIndexSpec;

protected function smf_189
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input list<DAE.Exp> in_i_subs;
  input list<DAE.Dimension> in_i_dims;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_simCode, in_i_preExp, in_i_context, in_i_subs, in_i_dims)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      list<DAE.Exp> i_subs;
      list<DAE.Dimension> i_dims;

    case ( txt,
           SimCode.SIMVAR(index = i_index, varKind = i_varKind, type_ = i_type__),
           i_simCode,
           i_preExp,
           i_context,
           i_subs,
           i_dims )
      local
        DAE.ExpType i_type__;
        BackendDAE.VarKind i_varKind;
        Integer i_index;
        Tpl.Text i_baseSub;
        Tpl.Text i_constSum;
      equation
        i_constSum = Tpl.writeStr(Tpl.emptyTxt, intString(i_index));
        (i_baseSub, i_constSum, i_preExp) = asubSubsripts(Tpl.emptyTxt, i_dims, i_subs, i_constSum, i_context, i_preExp, i_simCode);
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeText(txt, i_constSum);
        txt = Tpl.writeText(txt, i_baseSub);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _,
           _,
           _ )
      then (txt, i_preExp);
  end matchcontinue;
end smf_189;

protected function fun_190
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_ecr_ty;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input list<DAE.Exp> in_i_subs;
  input SimCode.SimCode in_i_simCode;
  input DAE.ComponentRef in_i_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_ecr_ty, in_i_preExp, in_i_context, in_i_subs, in_i_simCode, in_i_cr)
    local
      Tpl.Text txt;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      list<DAE.Exp> i_subs;
      SimCode.SimCode i_simCode;
      DAE.ComponentRef i_cr;

    case ( txt,
           DAE.ET_ARRAY(ty = DAE.ET_REAL(), arrayDimensions = i_dims),
           i_preExp,
           i_context,
           i_subs,
           i_simCode,
           i_cr )
      local
        list<DAE.Dimension> i_dims;
        SimCode.SimVar ret_0;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*"));
        txt = crefStr(txt, i_cr, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("[]*/"));
        ret_0 = SimCode.cref2simvar(i_cr, i_simCode);
        (txt, i_preExp) = smf_189(txt, ret_0, i_simCode, i_preExp, i_context, i_subs, i_dims);
      then (txt, i_preExp);

    case ( txt,
           _,
           i_preExp,
           _,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_SIMULATION_OTHER_ERROR"));
      then (txt, i_preExp);
  end matchcontinue;
end fun_190;

protected function fun_191
  input Tpl.Text in_txt;
  input SimCode.Context in_i_context;
  input DAE.ComponentRef in_i_cr;
  input DAE.ExpType in_i_ecr_ty;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input list<DAE.Exp> in_i_subs;
  input DAE.Exp in_i_ecr;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_context, in_i_cr, in_i_ecr_ty, in_i_simCode, in_i_preExp, in_i_subs, in_i_ecr)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_cr;
      DAE.ExpType i_ecr_ty;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      list<DAE.Exp> i_subs;
      DAE.Exp i_ecr;

    case ( txt,
           (i_context as SimCode.FUNCTION_CONTEXT()),
           _,
           _,
           i_simCode,
           i_preExp,
           i_subs,
           i_ecr )
      local
        SimCode.Context i_context;
        DAE.Exp ret_0;
      equation
        ret_0 = SimCode.buildCrefExpFromAsub(i_ecr, i_subs);
        (txt, i_preExp) = daeExpCrefRhs(txt, ret_0, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           i_context,
           i_cr,
           i_ecr_ty,
           i_simCode,
           i_preExp,
           i_subs,
           _ )
      local
        SimCode.Context i_context;
      equation
        (txt, i_preExp) = fun_190(txt, i_ecr_ty, i_preExp, i_context, i_subs, i_simCode, i_cr);
      then (txt, i_preExp);
  end matchcontinue;
end fun_191;

public function daeExpAsub
  input Tpl.Text in_txt;
  input DAE.Exp in_i_aexp;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_aexp, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.ASUB(exp = DAE.RANGE(ty = i_t), sub = {i_idx}),
           _,
           i_preExp,
           _ )
      local
        DAE.Exp i_idx;
        DAE.ExpType i_t;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_EASY_CASE"));
      then (txt, i_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ASUB(exp = DAE.ASUB(exp = DAE.ASUB(exp = i_e, sub = {DAE.ICONST(integer = i_i)}), sub = {DAE.ICONST(integer = i_j)}), sub = {DAE.ICONST(integer = i_k)}), sub = {DAE.ICONST(integer = i_l)}),
           _,
           i_preExp,
           _ )
      local
        Integer i_l;
        Integer i_k;
        Integer i_j;
        Integer i_i;
        DAE.Exp i_e;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_4D"));
      then (txt, i_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ASUB(exp = DAE.ASUB(exp = i_e, sub = {DAE.ICONST(integer = i_i)}), sub = {DAE.ICONST(integer = i_j)}), sub = {DAE.ICONST(integer = i_k)}),
           _,
           i_preExp,
           _ )
      local
        Integer i_k;
        Integer i_j;
        Integer i_i;
        DAE.Exp i_e;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_3D"));
      then (txt, i_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ASUB(exp = i_e, sub = {DAE.ICONST(integer = i_i)}), sub = {DAE.ICONST(integer = i_j)}),
           i_context,
           i_preExp,
           i_simCode )
      local
        Integer i_j;
        Integer i_i;
        DAE.Exp i_e;
      equation
        (txt, i_preExp) = daeExp(txt, i_e, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_i));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeStr(txt, intString(i_j));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, i_preExp);

    case ( txt,
           DAE.ASUB(exp = i_e, sub = {DAE.ICONST(integer = i_i)}),
           _,
           i_preExp,
           _ )
      local
        Integer i_i;
        DAE.Exp i_e;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_ARRAY"));
      then (txt, i_preExp);

    case ( txt,
           DAE.ASUB(exp = (i_ecr as DAE.CREF(componentRef = i_cr, ty = i_ecr_ty)), sub = i_subs),
           i_context,
           i_preExp,
           i_simCode )
      local
        list<DAE.Exp> i_subs;
        DAE.ExpType i_ecr_ty;
        DAE.ComponentRef i_cr;
        DAE.Exp i_ecr;
      equation
        (txt, i_preExp) = fun_191(txt, i_context, i_cr, i_ecr_ty, i_simCode, i_preExp, i_subs, i_ecr);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OTHER_ASUB__ERROR"));
      then (txt, i_preExp);
  end matchcontinue;
end daeExpAsub;

protected function lm_193
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_dim :: rest )
      local
        list<DAE.Dimension> rest;
        DAE.Dimension i_dim;
      equation
        txt = dimension(txt, i_dim);
        txt = Tpl.nextIter(txt);
        txt = lm_193(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      local
        list<DAE.Dimension> rest;
      equation
        txt = lm_193(txt, rest);
      then txt;
  end matchcontinue;
end lm_193;

protected function fun_194
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_i_dimsRest;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input list<DAE.Exp> in_i_subsRest;
  input Tpl.Text in_i_subStr;
  input Tpl.Text in_i_constSum;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
  output Tpl.Text out_i_constSum;
algorithm
  (out_txt, out_i_preExp, out_i_constSum) :=
  matchcontinue(in_txt, in_i_dimsRest, in_i_simCode, in_i_preExp, in_i_context, in_i_subsRest, in_i_subStr, in_i_constSum)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      list<DAE.Exp> i_subsRest;
      Tpl.Text i_subStr;
      Tpl.Text i_constSum;

    case ( txt,
           {},
           _,
           i_preExp,
           _,
           _,
           i_subStr,
           i_constSum )
      equation
        i_constSum = Tpl.writeTok(i_constSum, Tpl.ST_STRING("-1 + "));
        i_constSum = Tpl.writeText(i_constSum, i_subStr);
      then (txt, i_preExp, i_constSum);

    case ( txt,
           i_dimsRest,
           i_simCode,
           i_preExp,
           i_context,
           i_subsRest,
           i_subStr,
           i_constSum )
      local
        list<DAE.Dimension> i_dimsRest;
        Tpl.Text i_ds;
      equation
        i_ds = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING("*")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        i_ds = lm_193(i_ds, i_dimsRest);
        i_ds = Tpl.popIter(i_ds);
        i_constSum = Tpl.writeTok(i_constSum, Tpl.ST_STRING("-("));
        i_constSum = Tpl.writeText(i_constSum, i_ds);
        i_constSum = Tpl.writeTok(i_constSum, Tpl.ST_STRING(")"));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("+"));
        txt = Tpl.writeText(txt, i_subStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*("));
        txt = Tpl.writeText(txt, i_ds);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        (txt, i_constSum, i_preExp) = asubSubsripts(txt, i_dimsRest, i_subsRest, i_constSum, i_context, i_preExp, i_simCode);
      then (txt, i_preExp, i_constSum);
  end matchcontinue;
end fun_194;

protected function fun_195
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_i_dims;
  input list<DAE.Exp> in_i_subsRest;
  input Tpl.Text in_i_constSum;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input DAE.Exp in_i_s;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_constSum;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_constSum, out_i_preExp) :=
  matchcontinue(in_txt, in_i_dims, in_i_subsRest, in_i_constSum, in_i_simCode, in_i_preExp, in_i_context, in_i_s)
    local
      Tpl.Text txt;
      list<DAE.Exp> i_subsRest;
      Tpl.Text i_constSum;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      DAE.Exp i_s;

    case ( txt,
           _ :: i_dimsRest,
           i_subsRest,
           i_constSum,
           i_simCode,
           i_preExp,
           i_context,
           i_s )
      local
        list<DAE.Dimension> i_dimsRest;
        Tpl.Text i_subStr;
      equation
        (i_subStr, i_preExp) = daeExp(Tpl.emptyTxt, i_s, i_context, i_preExp, i_simCode);
        (txt, i_preExp, i_constSum) = fun_194(txt, i_dimsRest, i_simCode, i_preExp, i_context, i_subsRest, i_subStr, i_constSum);
      then (txt, i_constSum, i_preExp);

    case ( txt,
           _,
           _,
           i_constSum,
           _,
           i_preExp,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ERROR_asubSubsripts_not_enough_dims"));
      then (txt, i_constSum, i_preExp);
  end matchcontinue;
end fun_195;

protected function fun_196
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_i_subs;
  input list<DAE.Dimension> in_i_dims;
  input Tpl.Text in_i_constSum;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_constSum;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_constSum, out_i_preExp) :=
  matchcontinue(in_txt, in_i_subs, in_i_dims, in_i_constSum, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      list<DAE.Dimension> i_dims;
      Tpl.Text i_constSum;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           i_s :: i_subsRest,
           i_dims,
           i_constSum,
           i_context,
           i_preExp,
           i_simCode )
      local
        list<DAE.Exp> i_subsRest;
        DAE.Exp i_s;
      equation
        (txt, i_constSum, i_preExp) = fun_195(txt, i_dims, i_subsRest, i_constSum, i_simCode, i_preExp, i_context, i_s);
      then (txt, i_constSum, i_preExp);

    case ( txt,
           _,
           _,
           i_constSum,
           _,
           i_preExp,
           _ )
      then (txt, i_constSum, i_preExp);
  end matchcontinue;
end fun_196;

public function asubSubsripts
  input Tpl.Text txt;
  input list<DAE.Dimension> i_dims;
  input list<DAE.Exp> i_subs;
  input Tpl.Text i_constSum;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_constSum;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_constSum, out_i_preExp) := fun_196(txt, i_subs, i_dims, i_constSum, i_context, i_preExp, i_simCode);
end asubSubsripts;

protected function lm_198
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_exp :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_exp;
      equation
        (txt, i_preExp) = daeExp(txt, i_exp, i_context, i_preExp, i_simCode);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_198(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
      equation
        (txt, i_preExp) = lm_198(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_198;

public function arrayScalarRhs
  input Tpl.Text txt;
  input DAE.ExpType i_ty;
  input list<DAE.Exp> i_subs;
  input Tpl.Text i_arrName;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_arrName;
  output Tpl.Text out_i_preExp;
protected
  Tpl.Text i_dimsValuesStr;
  Integer ret_1;
  Tpl.Text i_arrayType;
algorithm
  ret_1 := listLength(i_subs);
  i_arrayType := expTypeArray(Tpl.emptyTxt, i_ty, ret_1);
  i_dimsValuesStr := Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  (i_dimsValuesStr, out_i_preExp) := lm_198(i_dimsValuesStr, i_subs, i_simCode, i_preExp, i_context);
  i_dimsValuesStr := Tpl.popIter(i_dimsValuesStr);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("(*ASR"));
  out_txt := Tpl.writeText(out_txt, i_arrayType);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("_element_addr(&"));
  out_txt := Tpl.writeText(out_txt, i_arrName);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(", , "));
  out_txt := Tpl.writeText(out_txt, i_dimsValuesStr);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("))"));
  out_i_arrName := i_arrName;
end arrayScalarRhs;

protected function fun_200
  input Tpl.Text in_txt;
  input DAE.Operator in_i_it;
  input Tpl.Text in_i_e2;
  input Tpl.Text in_i_e1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_e2, in_i_e1)
    local
      Tpl.Text txt;
      Tpl.Text i_e2;
      Tpl.Text i_e1;

    case ( txt,
           DAE.ADD(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" + "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.SUB(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.MUL(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" * "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.DIV(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" / "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.POW(ty = _),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Pow("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.AND(),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.OR(),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" || "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpBinary:ERR"));
      then txt;
  end matchcontinue;
end fun_200;

public function daeExpBinary
  input Tpl.Text txt;
  input DAE.Operator i_it;
  input DAE.Exp i_exp1;
  input DAE.Exp i_exp2;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  Tpl.Text i_e2;
  Tpl.Text i_e1;
algorithm
  (i_e1, out_i_preExp) := daeExp(Tpl.emptyTxt, i_exp1, i_context, i_preExp, i_simCode);
  (i_e2, out_i_preExp) := daeExp(Tpl.emptyTxt, i_exp2, i_context, out_i_preExp, i_simCode);
  out_txt := fun_200(txt, i_it, i_e2, i_e1);
end daeExpBinary;

protected function fun_202
  input Tpl.Text in_txt;
  input DAE.Operator in_i_it;
  input Tpl.Text in_i_e;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it, in_i_e)
    local
      Tpl.Text txt;
      Tpl.Text i_e;

    case ( txt,
           DAE.UMINUS(ty = _),
           i_e )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(-"));
        txt = Tpl.writeText(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.UPLUS(ty = _),
           i_e )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NOT(),
           i_e )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(!"));
        txt = Tpl.writeText(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.UMINUS_ARR(ty = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UMINUS_ARR_NOT_IMPLEMENTED"));
      then txt;

    case ( txt,
           DAE.UPLUS_ARR(ty = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UPLUS_ARR_NOT_IMPLEMENTED"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpUnary:ERR"));
      then txt;
  end matchcontinue;
end fun_202;

public function daeExpUnary
  input Tpl.Text txt;
  input DAE.Operator i_it;
  input DAE.Exp i_exp;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  Tpl.Text i_e;
algorithm
  (i_e, out_i_preExp) := daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
  out_txt := fun_202(txt, i_it, i_e);
end daeExpUnary;

protected function fun_204
  input Tpl.Text in_txt;
  input DAE.Operator in_i_op;
  input Tpl.Text in_i_e2;
  input Tpl.Text in_i_e1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_op, in_i_e2, in_i_e1)
    local
      Tpl.Text txt;
      Tpl.Text i_e2;
      Tpl.Text i_e1;

    case ( txt,
           DAE.LESS(ty = DAE.ET_BOOL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(!"));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESS(ty = DAE.ET_STRING()),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.LESS(ty = DAE.ET_INT()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" < "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESS(ty = DAE.ET_REAL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" < "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.ET_BOOL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !"));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.ET_STRING()),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.ET_INT()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.ET_REAL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.ET_BOOL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(!"));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" || "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.ET_STRING()),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.ET_INT()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <= "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.ET_REAL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <= "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.ET_BOOL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" || !"));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.ET_STRING()),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.ET_INT()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" >= "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.ET_REAL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" >= "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.ET_BOOL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((!"));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !"));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") || ("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.ET_STRING()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.ET_INT()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.ET_REAL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.ET_BOOL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((!"));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") || ("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !"));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.ET_STRING()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.ET_INT()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.ET_REAL()),
           i_e2,
           i_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, i_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpRelation:ERR"));
      then txt;
  end matchcontinue;
end fun_204;

protected function fun_205
  input Tpl.Text in_txt;
  input String in_it;
  input Tpl.Text in_i_e2;
  input Tpl.Text in_i_e1;
  input DAE.Operator in_i_op;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it, in_i_e2, in_i_e1, in_i_op)
    local
      Tpl.Text txt;
      Tpl.Text i_e2;
      Tpl.Text i_e1;
      DAE.Operator i_op;

    case ( txt,
           "",
           i_e2,
           i_e1,
           i_op )
      equation
        txt = fun_204(txt, i_op, i_e2, i_e1);
      then txt;

    case ( txt,
           str_3,
           _,
           _,
           _ )
      local
        String str_3;
      equation
        txt = Tpl.writeStr(txt, str_3);
      then txt;
  end matchcontinue;
end fun_205;

public function daeExpRelation
  input Tpl.Text txt;
  input DAE.Operator i_op;
  input DAE.Exp i_exp1;
  input DAE.Exp i_exp2;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  String str_3;
  Tpl.Text txt_2;
  Tpl.Text i_e2;
  Tpl.Text i_e1;
algorithm
  (i_e1, out_i_preExp) := daeExp(Tpl.emptyTxt, i_exp1, i_context, i_preExp, i_simCode);
  (i_e2, out_i_preExp) := daeExp(Tpl.emptyTxt, i_exp2, i_context, out_i_preExp, i_simCode);
  (txt_2, i_e1, i_e2, out_i_preExp) := daeExpSimRelation(Tpl.emptyTxt, i_context, i_op, i_e1, i_e2, out_i_preExp);
  str_3 := Tpl.textString(txt_2);
  out_txt := fun_205(txt, str_3, i_e2, i_e1, i_op);
end daeExpRelation;

protected function fun_207
  input Tpl.Text in_txt;
  input DAE.Operator in_i_op;
  input Tpl.Text in_i_preExp;
  input Tpl.Text in_i_e2;
  input Tpl.Text in_i_e1;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
  output Tpl.Text out_i_e2;
  output Tpl.Text out_i_e1;
algorithm
  (out_txt, out_i_preExp, out_i_e2, out_i_e1) :=
  matchcontinue(in_txt, in_i_op, in_i_preExp, in_i_e2, in_i_e1)
    local
      Tpl.Text txt;
      Tpl.Text i_preExp;
      Tpl.Text i_e2;
      Tpl.Text i_e1;

    case ( txt,
           DAE.LESS(ty = _),
           i_preExp,
           i_e2,
           i_e1 )
      equation
        (txt, i_e1, i_e2, i_preExp) = SimRelationSimple(txt, i_e1, i_e2, " <", i_preExp);
      then (txt, i_preExp, i_e2, i_e1);

    case ( txt,
           DAE.LESSEQ(ty = _),
           i_preExp,
           i_e2,
           i_e1 )
      equation
        (txt, i_e1, i_e2, i_preExp) = SimRelationEqual(txt, i_e1, i_e2, " <", i_preExp);
      then (txt, i_preExp, i_e2, i_e1);

    case ( txt,
           DAE.GREATER(ty = _),
           i_preExp,
           i_e2,
           i_e1 )
      equation
        (txt, i_e1, i_e2, i_preExp) = SimRelationSimple(txt, i_e1, i_e2, " >", i_preExp);
      then (txt, i_preExp, i_e2, i_e1);

    case ( txt,
           DAE.GREATEREQ(ty = _),
           i_preExp,
           i_e2,
           i_e1 )
      equation
        (txt, i_e1, i_e2, i_preExp) = SimRelationEqual(txt, i_e1, i_e2, " >", i_preExp);
      then (txt, i_preExp, i_e2, i_e1);

    case ( txt,
           _,
           i_preExp,
           i_e2,
           i_e1 )
      then (txt, i_preExp, i_e2, i_e1);
  end matchcontinue;
end fun_207;

public function daeExpSimRelation
  input Tpl.Text in_txt;
  input SimCode.Context in_i_it;
  input DAE.Operator in_i_op;
  input Tpl.Text in_i_e1;
  input Tpl.Text in_i_e2;
  input Tpl.Text in_i_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_e1;
  output Tpl.Text out_i_e2;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_e1, out_i_e2, out_i_preExp) :=
  matchcontinue(in_txt, in_i_it, in_i_op, in_i_e1, in_i_e2, in_i_preExp)
    local
      Tpl.Text txt;
      DAE.Operator i_op;
      Tpl.Text i_e1;
      Tpl.Text i_e2;
      Tpl.Text i_preExp;

    case ( txt,
           SimCode.SIMULATION(genDiscrete = _),
           i_op,
           i_e1,
           i_e2,
           i_preExp )
      equation
        (txt, i_preExp, i_e2, i_e1) = fun_207(txt, i_op, i_preExp, i_e2, i_e1);
      then (txt, i_e1, i_e2, i_preExp);

    case ( txt,
           _,
           _,
           i_e1,
           i_e2,
           i_preExp )
      then (txt, i_e1, i_e2, i_preExp);
  end matchcontinue;
end daeExpSimRelation;

public function SimRelationSimple
  input Tpl.Text txt;
  input Tpl.Text i_e1;
  input Tpl.Text i_e2;
  input String i_op;
  input Tpl.Text i_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_e1;
  output Tpl.Text out_i_e2;
  output Tpl.Text out_i_preExp;
protected
  Tpl.Text i_res;
algorithm
  i_res := Tpl.emptyTxt;
  out_i_preExp := Tpl.writeTok(i_preExp, Tpl.ST_STRING("// RELATION( "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_LINE(" ) macro expansion\n"));
  (out_i_preExp, i_res) := tempDecl(out_i_preExp, "bool", i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("; if (!"));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" && isInUpdate && ("));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("= "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(")) { SwapOldVars(); double res1 = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" - "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(";  SwapOldVars12(); "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = res1"));
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("= ("));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" - "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("); SwapOldVars2(); }"));
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_NEW_LINE());
  out_txt := Tpl.writeText(txt, i_res);
  out_i_e1 := i_e1;
  out_i_e2 := i_e2;
end SimRelationSimple;

public function SimRelationEqual
  input Tpl.Text txt;
  input Tpl.Text i_e1;
  input Tpl.Text i_e2;
  input String i_op;
  input Tpl.Text i_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_e1;
  output Tpl.Text out_i_e2;
  output Tpl.Text out_i_preExp;
protected
  Tpl.Text i_res;
algorithm
  i_res := Tpl.emptyTxt;
  out_i_preExp := Tpl.writeTok(i_preExp, Tpl.ST_STRING("// RELATION( "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("= "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_LINE(" ) macro expansion\n"));
  (out_i_preExp, i_res) := tempDecl(out_i_preExp, "bool", i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(";  if (isInUpdate) { "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(";  if(!"));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" && ("));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("= "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(")) {  SwapOldVars(); double res1 = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" - "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(";  SwapOldVars12(); "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = res1"));
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("= ("));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" - "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("); SwapOldVars2(); }  } else "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_res);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e1);
  out_i_preExp := Tpl.writeStr(out_i_preExp, i_op);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("= "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_e2);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(";"));
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_NEW_LINE());
  out_txt := Tpl.writeText(txt, i_res);
  out_i_e1 := i_e1;
  out_i_e2 := i_e2;
end SimRelationEqual;

public function daeExpIf
  input Tpl.Text txt;
  input DAE.Exp i_cond;
  input DAE.Exp i_then__;
  input DAE.Exp i_else__;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  Tpl.Text txt_6;
  Tpl.Text i_eElse;
  Tpl.Text i_preExpElse;
  Tpl.Text i_eThen;
  Tpl.Text i_preExpThen;
  Tpl.Text i_resVar;
  Tpl.Text i_condExp;
algorithm
  (i_condExp, out_i_preExp) := daeExp(Tpl.emptyTxt, i_cond, i_context, i_preExp, i_simCode);
  i_resVar := Tpl.emptyTxt;
  i_preExpThen := Tpl.emptyTxt;
  (i_eThen, i_preExpThen) := daeExp(Tpl.emptyTxt, i_then__, i_context, i_preExpThen, i_simCode);
  i_preExpElse := Tpl.emptyTxt;
  (i_eElse, i_preExpElse) := daeExp(Tpl.emptyTxt, i_else__, i_context, i_preExpElse, i_simCode);
  txt_6 := expTypeFromExpArrayIf(Tpl.emptyTxt, i_then__);
  (out_i_preExp, i_resVar) := tempDecl(out_i_preExp, Tpl.textString(txt_6), i_resVar);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING_LIST({
                                                 ";\n",
                                                 "if ("
                                             }, false));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_condExp);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(") { //cond type is "));
  out_i_preExp := expTypeFromExp(out_i_preExp, i_cond);
  out_i_preExp := Tpl.softNewLine(out_i_preExp);
  out_i_preExp := Tpl.pushBlock(out_i_preExp, Tpl.BT_INDENT(2));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_preExpThen);
  out_i_preExp := Tpl.softNewLine(out_i_preExp);
  out_i_preExp := Tpl.writeText(out_i_preExp, i_resVar);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_eThen);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_LINE(";\n"));
  out_i_preExp := Tpl.popBlock(out_i_preExp);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_LINE("} else {\n"));
  out_i_preExp := Tpl.pushBlock(out_i_preExp, Tpl.BT_INDENT(2));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_preExpElse);
  out_i_preExp := Tpl.softNewLine(out_i_preExp);
  out_i_preExp := Tpl.writeText(out_i_preExp, i_resVar);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING(" = "));
  out_i_preExp := Tpl.writeText(out_i_preExp, i_eElse);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_LINE(";\n"));
  out_i_preExp := Tpl.popBlock(out_i_preExp);
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_STRING("}"));
  out_i_preExp := Tpl.writeTok(out_i_preExp, Tpl.ST_NEW_LINE());
  out_txt := Tpl.writeText(txt, i_resVar);
end daeExpIf;

protected function fun_212
  input Tpl.Text in_txt;
  input DAE.Exp in_i_e2;
  input Tpl.Text in_i_msg;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_var1;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_e2, in_i_msg, in_i_simCode, in_i_preExp, in_i_context, in_i_var1)
    local
      Tpl.Text txt;
      Tpl.Text i_msg;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      Tpl.Text i_var1;

    case ( txt,
           (i_e2 as DAE.RCONST(real = _)),
           _,
           i_simCode,
           i_preExp,
           i_context,
           i_var1 )
      local
        DAE.Exp i_e2;
      equation
        txt = Tpl.writeText(txt, i_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" / "));
        (txt, i_preExp) = daeExp(txt, i_e2, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           i_e2,
           i_msg,
           i_simCode,
           i_preExp,
           i_context,
           i_var1 )
      local
        DAE.Exp i_e2;
        Tpl.Text i_var2;
      equation
        (i_var2, i_preExp) = daeExp(Tpl.emptyTxt, i_e2, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!=0.0 ? "));
        txt = Tpl.writeText(txt, i_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" / "));
        txt = Tpl.writeText(txt, i_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" : DivBy0("));
        txt = Tpl.writeText(txt, i_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeText(txt, i_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(",\""));
        txt = Tpl.writeText(txt, i_msg);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\"))"));
      then (txt, i_preExp);
  end matchcontinue;
end fun_212;

protected function fun_213
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_arg_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_arg_ty)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ET_INT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(int)"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_213;

protected function lm_214
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_it :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_it;
      equation
        (txt, i_preExp) = daeExp(txt, i_it, i_context, i_preExp, i_simCode);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_214(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
      equation
        (txt, i_preExp) = lm_214(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_214;

protected function lm_215
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_it :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_it;
      equation
        (txt, i_preExp) = daeExp(txt, i_it, i_context, i_preExp, i_simCode);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_215(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
      equation
        (txt, i_preExp) = lm_215(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_215;

protected function fun_216
  input Tpl.Text in_txt;
  input Boolean in_i_builtin;
  input Tpl.Text in_i_funName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_builtin, in_i_funName)
    local
      Tpl.Text txt;
      Tpl.Text i_funName;

    case ( txt,
           false,
           i_funName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* !!!TODO:."));
        txt = Tpl.writeText(txt, i_funName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_rettype_1 */"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_216;

public function daeExpCall
  input Tpl.Text in_txt;
  input DAE.Exp in_i_it;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_it, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "DIVISION"), expLst = {i_e1, i_e2, DAE.SCONST(string = i_string)}),
           i_context,
           i_preExp,
           i_simCode )
      local
        String i_string;
        DAE.Exp i_e2;
        DAE.Exp i_e1;
        String ret_2;
        Tpl.Text i_msg;
        Tpl.Text i_var1;
      equation
        (i_var1, i_preExp) = daeExp(Tpl.emptyTxt, i_e1, i_context, i_preExp, i_simCode);
        ret_2 = Util.escapeModelicaStringToCString(i_string);
        i_msg = Tpl.writeStr(Tpl.emptyTxt, ret_2);
        (txt, i_preExp) = fun_212(txt, i_e2, i_msg, i_simCode, i_preExp, i_context, i_var1);
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "der"), expLst = {(i_arg as DAE.CREF(componentRef = i_arg_componentRef))}),
           _,
           i_preExp,
           i_simCode )
      local
        DAE.ComponentRef i_arg_componentRef;
        DAE.Exp i_arg;
      equation
        txt = derCref(txt, i_arg_componentRef, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "pre"), expLst = {(i_arg as DAE.CREF(ty = i_arg_ty, componentRef = i_arg_componentRef))}),
           _,
           i_preExp,
           i_simCode )
      local
        DAE.ComponentRef i_arg_componentRef;
        DAE.ExpType i_arg_ty;
        DAE.Exp i_arg;
      equation
        txt = fun_213(txt, i_arg_ty);
        txt = preCref(txt, i_arg_componentRef, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "min"), expLst = {i_e1, i_e2}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_e2;
        DAE.Exp i_e1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Min("));
        (txt, i_preExp) = daeExp(txt, i_e1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        (txt, i_preExp) = daeExp(txt, i_e2, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "max"), expLst = {i_e1, i_e2}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_e2;
        DAE.Exp i_e1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Max("));
        (txt, i_preExp) = daeExp(txt, i_e1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        (txt, i_preExp) = daeExp(txt, i_e2, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "log"), expLst = {i_s1}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_s1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Log("));
        (txt, i_preExp) = daeExp(txt, i_s1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "exp"), expLst = {i_s1}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_s1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Exp("));
        (txt, i_preExp) = daeExp(txt, i_s1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "sin"), expLst = {i_s1}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_s1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Sin("));
        (txt, i_preExp) = daeExp(txt, i_s1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "sqrt"), expLst = {i_s1}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_s1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Sqrt("));
        (txt, i_preExp) = daeExp(txt, i_s1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, builtin = true, path = Absyn.IDENT(name = "noEvent"), expLst = {i_s1}),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_s1;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(/*noEvent*/"));
        (txt, i_preExp) = daeExp(txt, i_s1, i_context, i_preExp, i_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, ty = DAE.ET_NORETCALL(), expLst = i_expLst, builtin = i_builtin, path = i_path),
           i_context,
           i_preExp,
           i_simCode )
      local
        Absyn.Path i_path;
        Boolean i_builtin;
        list<DAE.Exp> i_expLst;
        Tpl.Text i_argStr;
      equation
        i_argStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_argStr, i_preExp) = lm_214(i_argStr, i_expLst, i_simCode, i_preExp, i_context);
        i_argStr = Tpl.popIter(i_argStr);
        i_preExp = underscorePrefix(i_preExp, i_builtin);
        i_preExp = underscorePath(i_preExp, i_path);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("("));
        i_preExp = Tpl.writeText(i_preExp, i_argStr);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(");"));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* NORETCALL */"));
      then (txt, i_preExp);

    case ( txt,
           DAE.CALL(tuple_ = false, expLst = i_expLst, path = i_path, builtin = i_builtin),
           i_context,
           i_preExp,
           i_simCode )
      local
        Boolean i_builtin;
        Absyn.Path i_path;
        list<DAE.Exp> i_expLst;
        Tpl.Text i_funName;
        Tpl.Text i_argStr;
      equation
        i_argStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_argStr, i_preExp) = lm_215(i_argStr, i_expLst, i_simCode, i_preExp, i_context);
        i_argStr = Tpl.popIter(i_argStr);
        i_funName = underscorePath(Tpl.emptyTxt, i_path);
        txt = underscorePrefix(txt, i_builtin);
        txt = Tpl.writeText(txt, i_funName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, i_argStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        txt = fun_216(txt, i_builtin, i_funName);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpCall:NOT_YET_IMPLEMENTED"));
      then (txt, i_preExp);
  end matchcontinue;
end daeExpCall;

protected function lm_218
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_e :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
        DAE.Exp i_e;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = expTypeFromExp(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        (txt, i_preExp) = daeExp(txt, i_e, i_context, i_preExp, i_simCode);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_218(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<DAE.Exp> rest;
      equation
        (txt, i_preExp) = lm_218(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_218;

protected function fun_219
  input Tpl.Text in_txt;
  input Boolean in_i_scalar;
  input DAE.ExpType in_i_a_ty;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input list<DAE.Exp> in_i_a_array;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_scalar, in_i_a_ty, in_i_simCode, in_i_preExp, in_i_context, in_i_a_array)
    local
      Tpl.Text txt;
      DAE.ExpType i_a_ty;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      list<DAE.Exp> i_a_array;

    case ( txt,
           false,
           _,
           _,
           i_preExp,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NON_SCALAR_ARRAY_notYetImplemeted"));
      then (txt, i_preExp);

    case ( txt,
           _,
           i_a_ty,
           i_simCode,
           i_preExp,
           i_context,
           i_a_array )
      local
        Integer ret_2;
        Tpl.Text i_params;
        Tpl.Text i_arrayVar;
      equation
        i_arrayVar = Tpl.emptyTxt;
        i_params = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_params, i_preExp) = lm_218(i_params, i_a_array, i_simCode, i_preExp, i_context);
        i_params = Tpl.popIter(i_params);
        (i_preExp, i_arrayVar) = tempDecl(i_preExp, "var", i_arrayVar);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(" = new "));
        i_preExp = expTypeArray(i_preExp, i_a_ty, 1);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("("));
        ret_2 = listLength(i_a_array);
        i_preExp = Tpl.writeStr(i_preExp, intString(ret_2));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(",-1,new[]{"));
        i_preExp = Tpl.writeText(i_preExp, i_params);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("});"));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, i_arrayVar);
      then (txt, i_preExp);
  end matchcontinue;
end fun_219;

protected function fun_220
  input Tpl.Text in_txt;
  input DAE.Exp in_it;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_cr as DAE.CREF(componentRef = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_cr;
      equation
        (txt, i_preExp) = daeExpCrefRhs(txt, i_cr, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           (i_a as DAE.ARRAY(scalar = i_scalar, array = i_a_array, ty = i_a_ty)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.ExpType i_a_ty;
        list<DAE.Exp> i_a_array;
        Boolean i_scalar;
        DAE.Exp i_a;
      equation
        (txt, i_preExp) = fun_219(txt, i_scalar, i_a_ty, i_simCode, i_preExp, i_context, i_a_array);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);
  end matchcontinue;
end fun_220;

public function daeExpArray
  input Tpl.Text txt;
  input DAE.Exp i_aexp;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  DAE.Exp ret_0;
algorithm
  ret_0 := SimCode.hackArrayReverseToCref(i_aexp, i_context);
  (out_txt, out_i_preExp) := fun_220(txt, ret_0, i_context, i_preExp, i_simCode);
end daeExpArray;

protected function fun_222
  input Tpl.Text in_txt;
  input Boolean in_i_isScalar;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;
  input DAE.Exp in_i_elem;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_isScalar, in_i_simCode, in_i_preExp, in_i_context, in_i_elem)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;
      DAE.Exp i_elem;

    case ( txt,
           false,
           _,
           i_preExp,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MATRIX_NON_SCALAR_NYI"));
      then (txt, i_preExp);

    case ( txt,
           _,
           i_simCode,
           i_preExp,
           i_context,
           i_elem )
      equation
        (txt, i_preExp) = daeExp(txt, i_elem, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);
  end matchcontinue;
end fun_222;

protected function lm_223
  input Tpl.Text in_txt;
  input list<tuple<DAE.Exp, Boolean>> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           (i_elem, i_isScalar) :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<tuple<DAE.Exp, Boolean>> rest;
        Boolean i_isScalar;
        DAE.Exp i_elem;
      equation
        (txt, i_preExp) = fun_222(txt, i_isScalar, i_simCode, i_preExp, i_context, i_elem);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_223(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<tuple<DAE.Exp, Boolean>> rest;
      equation
        (txt, i_preExp) = lm_223(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_223;

protected function lm_224
  input Tpl.Text in_txt;
  input list<list<tuple<DAE.Exp, Boolean>>> in_items;
  input SimCode.SimCode in_i_simCode;
  input Tpl.Text in_i_preExp;
  input SimCode.Context in_i_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_items, in_i_simCode, in_i_preExp, in_i_context)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      Tpl.Text i_preExp;
      SimCode.Context i_context;

    case ( txt,
           {},
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);

    case ( txt,
           i_row :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<list<tuple<DAE.Exp, Boolean>>> rest;
        list<tuple<DAE.Exp, Boolean>> i_row;
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, i_preExp) = lm_223(txt, i_row, i_simCode, i_preExp, i_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.nextIter(txt);
        (txt, i_preExp) = lm_224(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);

    case ( txt,
           _ :: rest,
           i_simCode,
           i_preExp,
           i_context )
      local
        list<list<tuple<DAE.Exp, Boolean>>> rest;
      equation
        (txt, i_preExp) = lm_224(txt, rest, i_simCode, i_preExp, i_context);
      then (txt, i_preExp);
  end matchcontinue;
end lm_224;

protected function fun_225
  input Tpl.Text in_txt;
  input DAE.Exp in_it;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_it, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           (i_cr as DAE.CREF(componentRef = _)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.Exp i_cr;
      equation
        (txt, i_preExp) = daeExpCrefRhs(txt, i_cr, i_context, i_preExp, i_simCode);
      then (txt, i_preExp);

    case ( txt,
           DAE.MATRIX(scalar = {{}}, ty = i_ty),
           _,
           i_preExp,
           _ )
      local
        DAE.ExpType i_ty;
        Tpl.Text i_tmp;
      equation
        i_tmp = Tpl.emptyTxt;
        (i_preExp, i_tmp) = tempDecl(i_preExp, "var", i_tmp);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(" = new "));
        i_preExp = expTypeArray(i_preExp, i_ty, 2);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("(0,1);"));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, i_tmp);
      then (txt, i_preExp);

    case ( txt,
           DAE.MATRIX(scalar = {}, ty = i_ty),
           _,
           i_preExp,
           _ )
      local
        DAE.ExpType i_ty;
        Tpl.Text i_tmp;
      equation
        i_tmp = Tpl.emptyTxt;
        (i_preExp, i_tmp) = tempDecl(i_preExp, "var", i_tmp);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(" = new "));
        i_preExp = expTypeArray(i_preExp, i_ty, 2);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("(0,1);"));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, i_tmp);
      then (txt, i_preExp);

    case ( txt,
           (i_m as DAE.MATRIX(scalar = (i_m_scalar as i_row1 :: _), ty = i_m_ty)),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.ExpType i_m_ty;
        list<tuple<DAE.Exp, Boolean>> i_row1;
        list<list<tuple<DAE.Exp, Boolean>>> i_m_scalar;
        DAE.Exp i_m;
        Integer ret_3;
        Integer ret_2;
        Tpl.Text i_matArr;
        Tpl.Text i_tmp;
      equation
        i_tmp = Tpl.emptyTxt;
        i_matArr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (i_matArr, i_preExp) = lm_224(i_matArr, i_m_scalar, i_simCode, i_preExp, i_context);
        i_matArr = Tpl.popIter(i_matArr);
        (i_preExp, i_tmp) = tempDecl(i_preExp, "var", i_tmp);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(" = new "));
        i_preExp = expTypeArray(i_preExp, i_m_ty, 2);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("("));
        ret_2 = listLength(i_m_scalar);
        i_preExp = Tpl.writeStr(i_preExp, intString(ret_2));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING(","));
        ret_3 = listLength(i_row1);
        i_preExp = Tpl.writeStr(i_preExp, intString(ret_3));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_LINE(",-1, new[]{\n"));
        i_preExp = Tpl.pushBlock(i_preExp, Tpl.BT_INDENT(2));
        i_preExp = Tpl.pushBlock(i_preExp, Tpl.BT_ANCHOR(0));
        i_preExp = Tpl.writeText(i_preExp, i_matArr);
        i_preExp = Tpl.popBlock(i_preExp);
        i_preExp = Tpl.softNewLine(i_preExp);
        i_preExp = Tpl.popBlock(i_preExp);
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_STRING("});"));
        i_preExp = Tpl.writeTok(i_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, i_tmp);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);
  end matchcontinue;
end fun_225;

public function daeExpMatrix
  input Tpl.Text txt;
  input DAE.Exp i_mexp;
  input SimCode.Context i_context;
  input Tpl.Text i_preExp;
  input SimCode.SimCode i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
protected
  DAE.Exp ret_0;
algorithm
  ret_0 := SimCode.hackMatrixReverseToCref(i_mexp, i_context);
  (out_txt, out_i_preExp) := fun_225(txt, ret_0, i_context, i_preExp, i_simCode);
end daeExpMatrix;

protected function fun_227
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_ty;
  input Tpl.Text in_i_expVar;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_ty, in_i_expVar)
    local
      Tpl.Text txt;
      Tpl.Text i_expVar;

    case ( txt,
           DAE.ET_INT(),
           i_expVar )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((int)"));
        txt = Tpl.writeText(txt, i_expVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.ET_REAL(),
           i_expVar )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((double)"));
        txt = Tpl.writeText(txt, i_expVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_IMPLEMENTED_CAST"));
      then txt;
  end matchcontinue;
end fun_227;

public function daeExpCast
  input Tpl.Text in_txt;
  input DAE.Exp in_i_cexp;
  input SimCode.Context in_i_context;
  input Tpl.Text in_i_preExp;
  input SimCode.SimCode in_i_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_preExp;
algorithm
  (out_txt, out_i_preExp) :=
  matchcontinue(in_txt, in_i_cexp, in_i_context, in_i_preExp, in_i_simCode)
    local
      Tpl.Text txt;
      SimCode.Context i_context;
      Tpl.Text i_preExp;
      SimCode.SimCode i_simCode;

    case ( txt,
           DAE.CAST(exp = i_exp, ty = i_ty),
           i_context,
           i_preExp,
           i_simCode )
      local
        DAE.ExpType i_ty;
        DAE.Exp i_exp;
        Tpl.Text i_expVar;
      equation
        (i_expVar, i_preExp) = daeExp(Tpl.emptyTxt, i_exp, i_context, i_preExp, i_simCode);
        txt = fun_227(txt, i_ty, i_expVar);
      then (txt, i_preExp);

    case ( txt,
           _,
           _,
           i_preExp,
           _ )
      then (txt, i_preExp);
  end matchcontinue;
end daeExpCast;

public function underscorePrefix
  input Tpl.Text in_txt;
  input Boolean in_i_builtin;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_builtin)
    local
      Tpl.Text txt;

    case ( txt,
           true )
      then txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end underscorePrefix;

public function tempDecl
  input Tpl.Text txt;
  input String i_ty;
  input Tpl.Text i_newVar;

  output Tpl.Text out_txt;
  output Tpl.Text out_i_newVar;
protected
  Integer ret_0;
algorithm
  out_i_newVar := Tpl.writeTok(i_newVar, Tpl.ST_STRING("_tmp"));
  ret_0 := System.tmpTick();
  out_i_newVar := Tpl.writeStr(out_i_newVar, intString(ret_0));
  out_txt := Tpl.writeStr(txt, i_ty);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(" "));
  out_txt := Tpl.writeText(out_txt, out_i_newVar);
end tempDecl;

protected function fun_231
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_i_instDims;
  input DAE.ExpType in_i_var_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_instDims, in_i_var_ty)
    local
      Tpl.Text txt;
      DAE.ExpType i_var_ty;

    case ( txt,
           {},
           i_var_ty )
      equation
        txt = expTypeArrayIf(txt, i_var_ty);
      then txt;

    case ( txt,
           i_instDims,
           i_var_ty )
      local
        list<DAE.Exp> i_instDims;
        Integer ret_0;
      equation
        ret_0 = listLength(i_instDims);
        txt = expTypeArray(txt, i_var_ty, ret_0);
      then txt;
  end matchcontinue;
end fun_231;

public function varType
  input Tpl.Text in_txt;
  input SimCode.Variable in_i_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_var)
    local
      Tpl.Text txt;

    case ( txt,
           (i_var as SimCode.VARIABLE(instDims = i_instDims, ty = i_var_ty)) )
      local
        DAE.ExpType i_var_ty;
        list<DAE.Exp> i_instDims;
        SimCode.Variable i_var;
      equation
        txt = fun_231(txt, i_instDims, i_var_ty);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end varType;

public function expTypeShort
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ET_INT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int"));
      then txt;

    case ( txt,
           DAE.ET_REAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double"));
      then txt;

    case ( txt,
           DAE.ET_STRING() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("string"));
      then txt;

    case ( txt,
           DAE.ET_BOOL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.ET_OTHER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OTHER_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ET_COMPLEX(complexClassType = ClassInf.EXTERNAL_OBJ(path = _)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("COMPLEX_EXTERNAL_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_COMPLEX(name = i_name) )
      local
        Absyn.Path i_name;
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*struct*/"));
        txt = underscorePath(txt, i_name);
      then txt;

    case ( txt,
           DAE.ET_LIST(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_METATUPLE(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_METAOPTION(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_UNIONTYPE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_POLYMORPHIC() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_META_ARRAY(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_BOXED(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.ET_FUNCTION_REFERENCE_VAR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FN_PTR_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expTypeShort_ERROR"));
      then txt;
  end matchcontinue;
end expTypeShort;

protected function fun_234
  input Tpl.Text in_txt;
  input Boolean in_i_isArray;
  input DAE.ExpType in_i_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_isArray, in_i_ty)
    local
      Tpl.Text txt;
      DAE.ExpType i_ty;

    case ( txt,
           false,
           i_ty )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           _,
           i_ty )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expType_"));
        txt = expTypeArray(txt, i_ty, 0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_NOT_YET"));
      then txt;
  end matchcontinue;
end fun_234;

public function expType
  input Tpl.Text txt;
  input DAE.ExpType i_ty;
  input Boolean i_isArray;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_234(txt, i_isArray, i_ty);
end expType;

public function expTypeArray
  input Tpl.Text txt;
  input DAE.ExpType i_ty;
  input Integer i_dims;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("SimArray"));
  out_txt := Tpl.writeStr(out_txt, intString(i_dims));
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("<"));
  out_txt := expTypeShort(out_txt, i_ty);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(">"));
end expTypeArray;

public function expTypeArrayIf
  input Tpl.Text in_txt;
  input DAE.ExpType in_i_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_ty)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ET_ARRAY(ty = i_ty, arrayDimensions = i_arrayDimensions) )
      local
        list<DAE.Dimension> i_arrayDimensions;
        DAE.ExpType i_ty;
        Integer ret_0;
      equation
        ret_0 = listLength(i_arrayDimensions);
        txt = expTypeArray(txt, i_ty, ret_0);
      then txt;

    case ( txt,
           i_ty )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;
  end matchcontinue;
end expTypeArrayIf;

public function expTypeFromExpArrayIf
  input Tpl.Text txt;
  input DAE.Exp i_exp;

  output Tpl.Text out_txt;
algorithm
  out_txt := expTypeFromExp(txt, i_exp);
end expTypeFromExpArrayIf;

public function expTypeFromExp
  input Tpl.Text in_txt;
  input DAE.Exp in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ICONST(integer = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int"));
      then txt;

    case ( txt,
           DAE.RCONST(real = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double"));
      then txt;

    case ( txt,
           DAE.SCONST(string = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("string"));
      then txt;

    case ( txt,
           DAE.BCONST(bool = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.BINARY(operator = i_operator) )
      local
        DAE.Operator i_operator;
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.UNARY(operator = i_operator) )
      local
        DAE.Operator i_operator;
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.LBINARY(operator = i_operator) )
      local
        DAE.Operator i_operator;
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.LUNARY(operator = i_operator) )
      local
        DAE.Operator i_operator;
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.RELATION(exp1 = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.IFEXP(expThen = i_expThen) )
      local
        DAE.Exp i_expThen;
      equation
        txt = expTypeFromExp(txt, i_expThen);
      then txt;

    case ( txt,
           DAE.CALL(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MATRIX(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.RANGE(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.CAST(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.CREF(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.CODE(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ASUB(exp = i_exp) )
      local
        DAE.Exp i_exp;
      equation
        txt = expTypeFromExp(txt, i_exp);
      then txt;

    case ( txt,
           DAE.REDUCTION(expr = i_expr) )
      local
        DAE.Exp i_expr;
      equation
        txt = expTypeFromExp(txt, i_expr);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expTypeFromExp:ERROR"));
      then txt;
  end matchcontinue;
end expTypeFromExp;

public function expTypeFromOp
  input Tpl.Text in_txt;
  input DAE.Operator in_i_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.ADD(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.UMINUS(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.UPLUS(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.UMINUS_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.UPLUS_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ADD_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_SCALAR_ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_ARRAY_SCALAR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ADD_SCALAR_ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ADD_ARRAY_SCALAR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB_SCALAR_ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB_ARRAY_SCALAR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_SCALAR_PRODUCT(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_MATRIX_PRODUCT(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV_ARRAY_SCALAR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV_SCALAR_ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_ARRAY_SCALAR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_SCALAR_ARRAY(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_ARR(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_ARR2(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.LESS(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.GREATER(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.EQUAL(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = i_ty) )
      local
        DAE.ExpType i_ty;
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.AND() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.OR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.NOT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expTypeFromOp:ERROR"));
      then txt;
  end matchcontinue;
end expTypeFromOp;

public function dimension
  input Tpl.Text in_txt;
  input DAE.Dimension in_i_d;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_i_d)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.DIM_INTEGER(integer = i_integer) )
      local
        Integer i_integer;
      equation
        txt = Tpl.writeStr(txt, intString(i_integer));
      then txt;

    case ( txt,
           DAE.DIM_UNKNOWN() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(":"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INVALID_DIMENSION"));
      then txt;
  end matchcontinue;
end dimension;

end SimCodeCSharp;