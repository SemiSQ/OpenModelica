(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 SimCodegen.rml
 ** module:      SimCodegen
 ** description: Generate Simulation code for connecting to solver.
 ** This can be done in two different ways.
 ** 1. Generation of simulation code on residual form. This will generate 
 ** code on the form g(\dot{x},x,y,t)=0.
 ** 2. Generation of simulation code on solved form. This will generate
 ** code on ode form. \dot{x} = f(x,y,t). This means that "function" f will
 ** contain code for solving states from equations, some of them might be 
 ** system of equations, linear or non-linear.
 **
 ** Outputs: the simulation code in C/C++ to a given filename.
 ** Input: DAELow
 ** Uses: DAELow, Absyn, Exp
 **
 **
 ** RCS: $Id$
 **
 **)


module SimCodegen:

  with "DAE.rml"
  with "DAELow.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "SCode.rml"

  relation generate_simulation_code: (DAE.DAElist,
				    DAELow.DAELow, 		      
				    int vector, (* ass1 *)
				    int vector, (* ass2 *)
				    DAELow.IncidenceMatrix,
				    DAELow.IncidenceMatrixT,
				    int list list, (* blocks*)
				    Absyn.Path,  (* classname *)
				    string) => ()
	  	  
  relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
				string,real,real,real)  => ()
	  
  relation generate_makefile: (string (*filename*), 
			       Absyn.Path (* classname *)
			       ) => ()
	  
  relation print_exp_cpp_str : Exp.Exp => string 
	  
  relation cref_modelica_str : Exp.ComponentRef => string 
	  
  relation generate_functions: (SCode.Program,DAE.DAElist, DAELow.DAELow, Absyn.Path, string) => ()

  relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list
  relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list
  relation print_exp_opt_str_if_const:(Exp.Exp option) => string 
	  
end

val TAB = "    " (* TAB is four whitespaces *)

with "Util.rml"
with "RTOpts.rml"
with "Debug.rml"
with "System.rml"
with "Values.rml"
with "Codegen.rml"
with "Print.rml"
with "ModUtil.rml"
with "VarTransform.rml"
with "Dump.rml"
with "Inst.rml"

(** relation: generate_makefile
 **
 ** This relation generates a makefile for the simulation code.
 ** It uses OPENMODELICAHOME as a reference to find c_runtime with libraries.
 **)

relation generate_makefile: (string, Absyn.Path) => () =
			     
  rule	Absyn.path_string(class) => cname &
	Util.string_append_list([cname,".cpp"]) => cpp_file &
	Util.string_append_list(["#Makefile generated by OpenModelica\n\n",
				 "CXX=g++\n",
				 cname,": ",cpp_file, "\n",
				 "\t $(CXX) -o ",cname," ",cpp_file, 
				 " -L$(OPENMODELICAHOME)/c_runtime/",
				 " -I$(OPENMODELICAHOME)/c_runtime/ ",
				 " -lsim -lg2c -lc_runtime\n"
				 ]) => str &
	System.write_file(filename,str) 
	-------------------------
	generate_makefile(filename,class)
end


(** relation: generate_simulation_code
 **
 ** Outputs simulation code from a DAELow suitable for connection to DASSL.
 ** The state calculations are generated on residual form, i.e. 
 ** g(\dot{x},x,y,t) = 0.
 ** and on explicit ode form, \dot{x}=f(x,y,t)
 **)

relation generate_simulation_code: (DAE.DAElist,
				  DAELow.DAELow, 		      
				  int vector, (* ass1 *)
				  int vector, (* ass2 *)
				  DAELow.IncidenceMatrix,
				  DAELow.IncidenceMatrixT,
				  int list list, (* blocks*)
				  Absyn.Path,  (* classname *)
				  string) => () =

  rule	Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_output_function_code(dlow) => (out_str,n_o) &
	generate_input_function_code(dlow) => (in_str,n_i) &
        generate_global_data(class,dlow,n_o,n_i) => cglobal &  
        
        generate_compute_output(cname,dae,dlow,ass1,ass2,blt_no_states) 
	  => coutput &
          generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blt_states) 
	  => cstate &
	generate_ode_code(dlow,blt_states,ass1,ass2,m,mt,class) => c_ode &
        generate_initial_value_code(dlow) => s_code &
	generate_when_clauses(cname,dae,dlow,ass1,ass2,comps) => cwhen &
	string_append(cname,"_functions.cpp") => funcfilename &
	Util.string_append_list(["//Simulation code for ",cname,
				 "\n//Generated by OpenModelica.\n",
				 "\n#include \"modelica.h\"\n",
				 "\n#include \"",funcfilename,"\"\n",
				 cglobal,coutput,in_str,out_str,cstate,cwhen,c_ode, s_code]) => res &
	System.write_file(filename,res) 
	---------------------------------------------------------------------
	generate_simulation_code(dae,dlow,ass1,ass2,m,mt,comps,class,filename) => ()


  rule	print "-generate_simulation_code failed\n" 
	-----------------------
	generate_simulation_code(_,_,_,_,_,_,_,_,_) => fail
end

(** relation: generate_global_data
 **
 ** This relation generates the C-code for the global data: arrays for states,
 ** derivatives and algebraic variables, etc.
 ** arg1
 ** arg2
 ** arg3 an int which shows the number of output variables on top level
 ** arg4 an int which shows the number of input variables on top level
 **)

 relation generate_global_data:(Absyn.Path,DAELow.DAELow,int,int) => string  =

  rule	DAELow.calculate_sizes(dlow) => (nx,ny,np) &
	Absyn.path_string(class) => class_str &
	int_string(nx) => nx_str &
	int_string(ny) => ny_str &
	int_string(np) => np_str &
        int_string(no) => no_str &
        int_string(ni) => ni_str &
	generate_var_names_and_comments(dlow,nx,ny) => (varnames,comments) &
        generate_parameter_names(dlow,np) => paramnames &
	Util.string_append_list(["\n",
				 "#define NX ",nx_str,"\n",
				 "#define NY ",ny_str,"\n",
				 "#define NP ",np_str,"\n",
				 "#define NO ",no_str," // number of outputvar on topmodel\n",
				 "#define NI ",ni_str," // number of inputvar on topmodel\n",
				 "#define MAXORD 5\n",
				 "#define time (*t)\n",
				 "\n",
                                 "#if NX > 0 /* some c-compilers does not like a static array of |a|==0 */\n",
				 "double x[NX];\n",
                                 "#else\n",
				 "double *x;\n",
				 "#endif\n",
                                 "#if NX > 0\n",
				 "double xd[NX];\n",
                                 "#else\n",
				 "double *xd;\n",
                                 "#endif\n",
                                 "#if NX > 0\n",
				 "double dummy_delta[NX];\n",
                                 "#else\n",
				 "double *dummy_delta;\n",
                                 "#endif\n",
                                 "#if NY > 0\n",
				 "double y[NY];\n",
                                 "#else\n",
				 "double *y;\n",
                                 "#endif\n",
                                 "#if NP > 0\n",
				 "double p[NP];\n",
                                 "#else\n",
				 "double *p;\n",
                                 "#endif\n",
                                 "#if NO > 0\n",
				 "double out_y[NO];\n",
				 "#else\n",
				 "double *out_y;\n",
                                 "#endif\n",
                                 "#if NI > 0\n",
				 "double in_y[NI];\n",
				 "#else\n",
				 "double *in_y;\n",
                                 "#endif\n",
				 "double rwork[50+(MAXORD+4)*NX+NX*NX];\n",
				 "long iwork[20+NX];\n",
				 "long liw = 20+NX;\n", 
				 "long lrw = 50+(MAXORD+4)*NX+NX*NX;\n",
				 "long nx = NX;\n",
				 "long ny = NY;\n",
				 "long np = NP;\n",
				 "long no = NO;\n",
				 "long ni = NI;\n",
				 "char *model_name=\"",class_str,
				 "\";\n",
				 varnames,"\n",
                                 comments,"\n",
                                 paramnames,"\n"]
				 )  => str 
	---------------------------
	generate_global_data(class, dlow,no,ni) => str
	
end

(** relation: generate_var_names_and_comments
 **
 ** Generates an array of the original variable names.
 **)

relation generate_var_names_and_comments:(DAELow.DAELow,int, int) => (string,string) =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	generate_var_names_and_comments_states(var_lst) => (state_lst,state_comment_lst) &
	generate_var_names_and_comments_derivatives(var_lst) => (der_lst,der_comment_lst) &
	generate_var_names_and_comments_algvars(var_lst) => (algvar_lst,algvar_comment_lst) &
	generate_var_names_and_comments_inputvars(knvar_lst) => (inputvar_lst,inputvar_comment_lst) &
	Util.list_flatten([state_lst,der_lst,algvar_lst,inputvar_lst]) => varnames_lst &
	Util.list_flatten([state_comment_lst,der_comment_lst,algvar_comment_lst,inputvar_comment_lst]) => comments_lst &	
	Util.string_delimit_list(varnames_lst,", ") => str &
	Util.string_delimit_list(comments_lst,", ") => str2 &
	int_add(nx,nx) => nxtwo &
	int_add(ny,nxtwo) => tot_elts &
	int_string(tot_elts) => tot_elts_str & 

	Util.string_append_list(["char* varnames[",tot_elts_str,"] = {",
				 str, "};\n"]) => res &
	Util.string_append_list(["char* comments[",tot_elts_str,"] = {",
				 str2, "};\n"]) => res2
	-------------------
	generate_var_names_and_comments(DAELow.DAELOW(vars,knvars,_,_,_,_,_),nx,ny) => (res,res2)

end

(** relation: generate_parameter_names
 **
 ** This function generates a char* parameternames[]=... that contain
 ** the name of the parameters. 
 **)

relation generate_parameter_names:(DAELow.DAELow,int) => string =

  rule  (* special case if no variables *)
        DAELow.var_list(knvars) => [] 
        ------------------------------------
	generate_parameter_names(DAELow.DAELOW(vars,knvars,_,_,_,_,_),np) => ""
        
  rule  DAELow.var_list(knvars) => knvar_lst &
        generate_parameter_names2(knvar_lst) => param_str_lst &
        Util.string_delimit_list(param_str_lst,", ") => str
        &int_string(np) => np_str & 
	Util.string_append_list(["char* parameternames[",np_str,"] = {",
				 str, "};\n"]) => res

        ------------------------------------
	generate_parameter_names(DAELow.DAELOW(vars,knvars,_,_,_,_,_),np) => res
        
end

(** relation: generate_parameter_names2
 **
 ** Helper relation to generate_parameter_names
 **)

relation generate_parameter_names2:(DAELow.Var list) => string list =

  axiom	generate_parameter_names2([]) => []
	
  rule	generate_parameter_names2(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_parameter_names2(DAELow.VAR(cr,DAELow.PARAM,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> origname'::res

  rule	generate_parameter_names2(vs) => res 
	-----------------------
	generate_parameter_names2(_::vs)
	  => res
end

(** relation: generate_var_names_and_comments_states
 **
 ** Helper relation to generate_var_names_and_comments
 **)

relation generate_var_names_and_comments_states:(DAELow.Var list) => (string list,string list) =

  axiom	generate_var_names_and_comments_states([]) => ([],[])
	
  rule	generate_var_names_and_comments_states(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_states(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_states(vs) => (res,res2) 
	-----------------------
	generate_var_names_and_comments_states(_::vs)
	  => (res,res2)
end

(** relation: generate_empty_string
 **
 ** This relation adds citation chars to an empty string. Non empty strings
 ** are returned as is.
**)
		 
relation generate_empty_string: (string) => string =

  axiom	generate_empty_string("") => "\"\""

  axiom	generate_empty_string(s) => s 
end
	

(** relation: generate_var_names_and_comments_derivatives
 **
 ** Helper relation to generate_var_names_and_comments
 **)

relation generate_var_names_and_comments_derivatives:(DAELow.Var list) => (string list,string list)  =

  axiom	generate_var_names_and_comments_derivatives([]) => ([],[])
	
  rule	generate_var_names_and_comments_derivatives(vs) => (res,res2) &
	Util.string_append_list(["\"der(",origname,")\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_derivatives(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_derivatives(vs) =>(res,res2) 
	-----------------------
	generate_var_names_and_comments_derivatives(_::vs)
	  => (res,res2)
end

(** relation: generate_var_names_and_comments_algvars
 **
 ** Helper relation to generate_var_names_and_comments
 **)

relation generate_var_names_and_comments_algvars:(DAELow.Var list) => (string list,string list)  =

  axiom	generate_var_names_and_comments_algvars([]) => ([],[])
	
  rule	generate_var_names_and_comments_algvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_algvars(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_algvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_algvars(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_algvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_algvars(DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_algvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_algvars(DAELow.VAR(cr,DAELow.DUMMY_STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_algvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname' &
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_algvars(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_algvars(vs) => (res,res2)
	-----------------------
	generate_var_names_and_comments_algvars(_::vs)
	  => (res,res2)
end


(** relation: generate_input_function_code
 **
 **  Generates the input_function for all the variables
 **  that are INPUT and on top model
**)

relation generate_input_function_code:(DAELow.DAELow) => (string,int) = 

  rule  DAELow.var_list(knvars) => knvars_lst &
        generate_input_function_code2(knvars_lst,0) => res1 &
        list_length(res1) => lst_lenght &
        Util.string_delimit_list_no_empty(res1,"\n  ") => res1' &
        Util.string_append_list(["\n/*\n*/\nvoid input_function(double *in_x,double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n  ",
                                 res1',
                                 "\n}\n"]) => res
        -------------------------------------

        generate_input_function_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev)) => (res,lst_lenght)

end

(** relation: generate_input_function_code2
 **
 ** Helper relation to generate_input_function_code
 **)

relation generate_input_function_code2:(DAELow.Var list,int) => string list =

  axiom  generate_input_function_code2([],int) => []

  rule  DAELow.is_var_on_top_level_and_input(var) => true &
        int_string(i) => i_str &
        int_add(i,1) => i' &
        Exp.print_component_ref_str(cr) => cr_str &
        
        Util.string_append_list([cr_str," = in_x[",i_str,"];"]) => assign_str &
        generate_input_function_code2(rest,i') => res
        --------------------------
        generate_input_function_code2((var as DAELow.VAR(cr,_,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow))::rest,
                                       i)
          => assign_str::res

  rule generate_input_function_code2(rest,index) => res
        --------------------------------
        generate_input_function_code2(var::rest,
                                       index) => res

end

(** relation: generate_output_function_code
 **
 **  Generates the output_function for all the variables
 **  that are OUTPUT and on top model
**)

relation generate_output_function_code:(DAELow.DAELow) => (string,int) = 

  rule  DAELow.var_list(knvars) => knvars_lst &
        DAELow.var_list(vars) => vars_lst &
        list_append(knvars_lst,vars_lst) => vars_lst' &
        generate_output_function_code2(vars_lst',0) => res1 &
        list_length(res1) => lst_lenght &
        Util.string_delimit_list_no_empty(res1,"\n  ") => res1' &
        Util.string_append_list(["\n/*\n*/\nvoid output_function(double *out_x,double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n  ",
                                 res1',
                                 "\n}\n"]) => res
        -------------------------------------
        generate_output_function_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev)) => (res,lst_lenght)

end

(** relation: generate_output_function_code2
 **
 ** Helper relation to generate_output_function_code
 **)

relation generate_output_function_code2:(DAELow.Var list,int) => string list =

  axiom  generate_output_function_code2([],int) => []

  rule  DAELow.is_var_on_top_level_and_output(var) => true &
        int_string(i) => i_str &
        int_add(i,1) => i' &
        Exp.print_component_ref_str(cr) => cr_str &
        
        Util.string_append_list(["out_y[",i_str,"] =",cr_str,";"]) => assign_str &
        generate_output_function_code2(rest,i') => res
        --------------------------
        generate_output_function_code2((var as DAELow.VAR(cr,_,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow))::rest,
                                       i)
          => assign_str::res

  rule generate_output_function_code2(rest,index) => res
        --------------------------------
        generate_output_function_code2(var::rest,
                                       index) => res

end

(** relation: generate_var_names_and_comments_inputvars
 **
 ** Helper relation to generate_var_names_and_comments
 **)

relation generate_var_names_and_comments_inputvars:(DAELow.Var list) => (string list,string list) =

  axiom	generate_var_names_and_comments_inputvars([]) => ([],[])
	
  rule	generate_var_names_and_comments_inputvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname'&
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_inputvars(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_inputvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname'&
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_inputvars(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_inputvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname'&
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_inputvars(DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_inputvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname'&
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_inputvars(DAELow.VAR(cr,DAELow.DUMMY_STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_inputvars(vs) => (res,res2) &
	Util.string_append_list(["\"",origname,"\""]) => origname'&
        Dump.unparse_comment_option(comment) => comment &
	generate_empty_string(comment) => comment'
	-----------------------
	generate_var_names_and_comments_inputvars(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment,flow)::vs)
	=> (origname'::res,comment'::res2)

  rule	generate_var_names_and_comments_inputvars(vs) => (res,res2)
	-----------------------
	generate_var_names_and_comments_inputvars(_::vs)
	  => (res,res2)
end


(** relation: generate_initial_value_code
 **
 ** This relation generates the code for solving the initial value problem.
 ** Information is gathered from the start and fixed attributes of variables
 ** and from initial equations.
 **)

relation generate_initial_value_code:(DAELow.DAELow) => string =

  rule  DAELow.var_list(vars) => vars_lst &
	DAELow.equation_list(ie) => initial_eqns1 &
	generate_initial_equations_from_start(vars_lst) => initial_eqns2 &
	
	list_append(initial_eqns1,initial_eqns2) => initial_eqns &
	DAELow.list_equation(initial_eqns) => initial_eqns' &
	list_array([]) => arr &
	let empty_eqn = DAELow.EQUATION_ARRAY(0,0,arr) &

	let initial_dae = DAELow.DAELOW(vars,knvars,initial_eqns',empty_eqn,empty_eqn,al,ev) &
	(* States are no longer special, they are just a variable that 
	 * needs an initial value. *)
	DAELow.make_all_states_algebraic(initial_dae) => initial_dae' &
 	DAELow.incidence_matrix(initial_dae') => m &
 	DAELow.transpose_matrix(m) => mT &
	(* once dae has been translated, state or not should not matter *)
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.abs_incidence_matrix(mT) => mT' &
	DAELow.dump initial_dae' &
	DAELow.dump_incidence_matrix m' &
	(* index reduction for intitial equations makes no sense.. *)
	DAELow.matching_algorithm(initial_dae',m',mT',DAELow.NO_INDEX_REDUCTION) 
	  => (ass1,ass2,initial_dae',m,mT) &
	DAELow.strong_components(m',mT',ass1,ass2) => blocks &
	generate_ode_blocks(initial_dae',ass1,ass2,blocks)
	  => (block_code,extra_funcs) &
        Util.string_append_list([extra_funcs,
				 "\n/*\n*/\nvoid initial_function(double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n",
                                 block_code,
                                 "\n}\n"]) => res 
        ----------------------------------
        generate_initial_value_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev)) => res
        
  axiom generate_initial_value_code(_) => ""

end

(** relation: generate_initial_equations_from_start
 **
 ** This relation generates equations from the expressions in the start 
 ** attributes of variables. Only variables with a start value and 
 ** fixed set to true is converted by this relation. Fixed set to false
 ** means an initial guess, and is not considered here.
 **)

relation generate_initial_equations_from_start: DAELow.Var list => DAELow.Equation list =

  axiom	generate_initial_equations_from_start ([]) => []
	
	(* add equations for variables with fixed = true*)
  rule	DAELow.var_fixed(attr,kind) => true &
	generate_initial_equations_from_start(vars) => eqns 
	--------------------------
	generate_initial_equations_from_start(DAELow.VAR(cr,kind,_,_,_,_,_,SOME(startv),_,_,_,attr,_,_)::vars)
	  => DAELow.EQUATION(Exp.CREF(cr,Exp.OTHER),startv)::eqns

  rule	generate_initial_equations_from_start(vars) => eqns 
	--------------------------
	generate_initial_equations_from_start(_::vars)
	  => eqns
end

(** relation generate_ode_code
 ** Outputs simulation code from a DAELow. 
 ** The state calculations are generated on explicit ode form: 
 ** \dot{x} := f(x,y,t)
**)
relation generate_ode_code: (DAELow.DAELow, 
			     int list list, (* components*)
			     int vector, (* ass1 *)
			     int vector, (* ass2 *)
			     DAELow.IncidenceMatrix,
			     DAELow.IncidenceMatrixT,
			     Absyn.Path) => string =

  rule	Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_ode_blocks(dlow,ass1,ass2,blt_states) 
	  => (block_code, extra_funcs) &
	generate_ode_header() => cheader &
	generate_ode_footer() => cfooter &
	Util.string_append_list([extra_funcs,cheader,block_code,cfooter]) => res
	-------------------------------------------
	generate_ode_code(dlow,comps,ass1,ass2,m,mt,class) => res
end

(** relation: generate_ode_header
 ** author: PA
 **
 ** Geneates the header of the function for calcuating the explicit ode
 **)
relation generate_ode_header: () => string =
	
  rule	Util.string_append_list(
	[
	 "void functionODE(double *x, double *xd, double *y, double *p, \n",
	 "                  int nx, int ny, int np, double *t)\n",
	 "{\n"
	 ]) => res
	------------------------
	generate_ode_header() => res

end	

(** relation: generate_ode_footer
 ** author: PA
 **
 ** Geneates the footer of the function for calcuating the explicit ode
 **)
relation generate_ode_footer: () => string =
	
  rule	Util.string_append_list(
	[
	 "}\n"

	 ]) => res
	------------------------
	generate_ode_footer() => res
end	

(** relation: generate_ode_blocks
 ** author: PA
 **
 ** Generates the simulation code for the ode code.
 ** 
**)
relation generate_ode_blocks:(DAELow.DAELow, int vector, int vector, int list list) 
	  => (string, (* block code*)
	      string) (* extra functions code*) =

  axiom	generate_ode_blocks(_,_,_,[]) => ("","")

  rule	(* For system of equations *)
	generate_ode_system(dae,ass1,ass2,block) => (s1,f1)  &
	generate_ode_blocks(dae,ass1,ass2,blocks) => (s2,f2) &
	string_append(s1,s2) => res &
	string_append(f1,f2) => res2 
	-------------------------------------
	generate_ode_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks) 
	  => (res,res2)
	
  rule	(* for single equations *)
	generate_ode_equation(dae,ass1,ass2,eqn) => (s1,f1) &
	generate_ode_blocks(dae,ass1,ass2,blocks) => (s2,f2) &
	string_append(s1,s2) => res &
	string_append(f1,f2) => res2 
	-------------------------------------
	generate_ode_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => (res,res2)

  rule	print "-generate_ode_blocks failed\n" 
	-----------------
	generate_ode_blocks(_,_,_,_) => fail
end

(** relation: generate_ode_system
 ** author: PA
 **
 ** Generates code for a subsystem of equations, both linear and non-linear.
 **)
relation generate_ode_system: (DAELow.DAELow, int vector, int vector, int list) 
	  => (string, (* system code *)
	      string) = (* extra function code*) 

  rule	(** extract the variables and equations of the block.*)
	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	Util.list_map(var_lst,transform_x_to_xd) => var_lst' &  
	DAELow.list_var(var_lst') => vars' &
	DAELow.list_equation(eqn_lst) => eqns' &
	let subsystem_dae = DAELow.DAELOW(vars',knvars(* not used*),eqns',se,ie,al,ev) &
	
	DAELow.incidence_matrix(subsystem_dae) => m &
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.transpose_matrix(m') => mt' &
	(* calculate jacobian. If constant, linear system of equations. Otherwise nonlinear *)
	
	DAELow.calculate_jacobian(vars',eqns',m',mt') => jac &
	DAELow.analyze_jacobian(subsystem_dae,jac) => jac_tp &
	generate_ode_system2(subsystem_dae,jac,jac_tp) => (str,f1) &
	DAELow.jacobian_type_str jac_tp => jac_tp_str &
	Util.string_append_list(["/* system of equations of type ",jac_tp_str, "*/\n",
				 str,
				 "/* End system of equations */\n"
				 ]) 
	  => res
	-------------------------
	generate_ode_system(daelow as DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev),ass1,ass2,block) 
	  => (res,f1)
end

(** relation: generate_ode_system2
 ** author: PA
 ** 
 ** Generates the actual simulation code for the system of equation, once
 ** its jacobian and type has been given.
 **)
relation generate_ode_system2: (DAELow.DAELow, (* the daelow for the subsystem*)
				(int * int * DAELow.Equation) list, (* jacobian *)
				DAELow.JacobianType) (* Type of jacobian, constant,etc.*)
	=> (string, (* system code *)
	    string) =  (* extra functions code *)


	  (* constant jacobians. Linear system of equations (A x = b) where
	   A and b are constants. *)
  rule	DAELow.equation_size(eqn) => eqn_size &
	generate_ode_system2(d,jac,DAELow.JAC_TIME_VARYING) => (s1,f1)
	------------------------------
 	generate_ode_system2(d as DAELow.DAELOW(v,kv,eqn,_,_,_,_),jac,
			     DAELow.JAC_CONSTANT) => (s1,f1)
	

	(* Time varying jacobian. Linear system of equations that needs to 
	 * be solved during runtime. *)
  rule	DAELow.equation_size(eqn) => eqn_size &
	generate_ode_system2_declaration(eqn_size) => s1 &
	generate_ode_system2_populate_Ab(jac,v,eqn) => s2 &
	generate_ode_system2_solve_call(eqn_size) => s3 &
	generate_ode_system2_collect_results(v) => s4 &
	Util.string_append_list([s1,s2,s3,s4]) => str
	--------------------
	generate_ode_system2(d as DAELow.DAELOW(v,kv,eqn,_,_,_,_),jac,DAELow.JAC_TIME_VARYING) => (str,"")

	(* Time varying nonlinear jacobian. Non-linear system of equations*)
  rule	DAELow.equation_list(eqn) => eqn_lst &
	DAELow.var_list(v) => var_lst &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	generate_ode_system2_nonlinear_residuals(crefs,eqn_lst) => (str,f1) 
	------------------------------------------------------
	generate_ode_system2(DAELow.DAELOW(v,kv,eqn,_,_,_,_),jac,DAELow.JAC_NONLINEAR) 
	  => (str,f1)


  rule	print "-generate_ode_system2 failed\n" 
	-------------------------
	generate_ode_system2(_,_,_) => fail
end

(** relation: generate_ode_system2_nonlinear_residuals
 ** author: PA
 **
 ** Generates residual statements for nonlinear equation systems.
 **)

relation generate_ode_system2_nonlinear_residuals:  (Exp.ComponentRef list,
						     DAELow.Equation list) 
	  => (string, (* solve code *)
	      string) = (* extra functions: residual func*)

  rule	make_residual_replacements(crs) => repl &
	generate_ode_system2_nonlinear_residuals2(eqns,0,repl) => s1 &
	tick() => id &
	int_string(id) => str_id &
	list_length(eqns) => eqn_size & int_string(eqn_size) => size_str &
	Util.string_append_list(["void residualFunc",str_id,
				 "(int* n, double* xloc, double*res, int* iflag)\n",
				 "{\n",
				 s1,
				 "}\n"]) => func &
	generate_ode_system2_nonlinear_setvector(crs,0) => s2 &
	generate_ode_system2_nonlinear_call(str_id) => s3 &
	generate_ode_system2_nonlinear_store_results(crs,0) => s4 &
	Util.string_append_list([TAB,"start_nonlinear_system(",size_str,");\n",
				 s2,s3,s4,
				 TAB, "end_nonlinear_system();\n"]) => res
	-----------------------------------------------------------
	generate_ode_system2_nonlinear_residuals(crs,eqns) 
	  => (res,func)

  rule	print "generate_ode_system2_nonlinear_residuals failed\n" 
	-----------------------------------------------------------
	generate_ode_system2_nonlinear_residuals(crs,eqns) 
	  => fail
end

(** relation: make_residual_replacements
 ** author: PA
 **
 ** This relation makes replacement rules for variables occuring in a 
 ** nonlinear equation system. They should be replaced by x[index], i.e.
 ** an unique index in the x vector.
 **)

relation make_residual_replacements:(Exp.ComponentRef list) => 
	VarTransform.VariableReplacements =

  rule	VarTransform.empty_replacements() => repl &
	make_residual_replacements2(repl,crefs,0) => repl'
	---------------------
	make_residual_replacements(crefs) => repl'
end

(** relation make_residual_replacements2
 ** author: PA
 ** 
 ** Helper relation to make_residual_replacements
 **)

relation make_residual_replacements2:(VarTransform.VariableReplacements,
				      Exp.ComponentRef list,
				      int) => 
	VarTransform.VariableReplacements =

  axiom	make_residual_replacements2(repl,[],_) => repl

  rule	int_string(pos) => pstr &
	Util.string_append_list(["xloc[",pstr,"]"]) => str &
	VarTransform.add_replacement(repl,cr,Exp.CREF_IDENT(str,[])) => repl' &
	pos + 1 => pos' &
	make_residual_replacements2(repl',crs,pos') => repl''
	------------------------------
	make_residual_replacements2(repl,cr::crs,pos) => repl''
end


(** relation: generate_ode_system2_nonlinear_setvector
 ** author: PA
 **
 ** Generates code for setting the values for the x vector when solving 
 ** nonlinear equation systems.
 **)

relation generate_ode_system2_nonlinear_setvector: (Exp.ComponentRef list,
						    int (* index iterator *)) 
	  => string =

  axiom	generate_ode_system2_nonlinear_setvector([],_) => ""

  rule  Exp.print_component_ref_str(cr) => cr_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_setvector(crs,indx') => s1 &
	Util.string_append_list([TAB,"nls_x[",indx_str,"] = ",cr_str,";\n",
				 s1]) => res
	----------------------------------------
	generate_ode_system2_nonlinear_setvector(cr::crs,indx) 
	  => res
end

(** relation: generate_ode_system2_nonlinear_call
 ** author: PA
 **
 ** Generates the call to the nonlinear equation solver.
 **)

relation generate_ode_system2_nonlinear_call: (string (* residual func id *)) 
	  => string =

  rule	Util.string_append_list([TAB,"hybrd_(residualFunc",func_id,
				 ",&n, nls_x,nls_fvec,&xtol,&maxfev,&ml,&mu,",
				 "&epsfcn,\n",TAB,TAB,"nls_diag,&mode,&factor,&nprint,",
				 "&info,&nfev,nls_fjac,&ldfjac,\n",TAB,TAB,"nls_r,",
				 "&lr,nls_qtf,nls_wa1,nls_wa2,nls_wa3,",
				 "nls_wa4);\n",
				 TAB,"if (info == 0) {\n",
				 TAB,TAB,"printf(\"improper ",
				 "input parameters to nonlinear eq. syst.\\n\");\n",
				 TAB, "}\n",
				 TAB,"if (info >= 2 && info <= 5) {\n",
				 TAB,TAB,"printf(\"error solving nonlinear",
				 " system.\\n\");\n",
				 TAB,"}\n"
				 ]) => res
	---------------------------
	generate_ode_system2_nonlinear_call(func_id) => res
end


(** relation: generate_ode_system2_nonlinear_store_results
 ** author: PA
 ** 
 ** Generates the storing of the results of the solution to a nonlinear equation
 ** system.
**)
	    
relation generate_ode_system2_nonlinear_store_results: (Exp.ComponentRef list, int)
	=> string =
  axiom	generate_ode_system2_nonlinear_store_results([],_) => ""

  rule	Exp.print_component_ref_str(cr) => cr_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_store_results(crs,indx') => s1 &
	Util.string_append_list([TAB,cr_str," = nls_x[",indx_str,"];\n",s1]) 
	  => res
	--------------------------------
	generate_ode_system2_nonlinear_store_results(cr::crs,indx) =>  res
end


(** relation: generate_ode_system2_nonlinear_residuals2
 ** author: PA
 ** 
 ** Helper relation to generate_ode_system2_nonlinear_residuals
 **)

relation generate_ode_system2_nonlinear_residuals2: (DAELow.Equation list, 
						     int, (* index iterator*) 
						     VarTransform.VariableReplacements)
	  => string =

  axiom	generate_ode_system2_nonlinear_residuals2([],_,_) => ""

  rule	Exp.typeof(e1) => tp &
	let res_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	Exp.simplify(res_exp) => res_exp' &
	VarTransform.replace_exp(res_exp',repl) => res_exp'' &
        print_exp_cpp_str(res_exp'') => exp_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_residuals2(rest,indx',repl) => s1 &
	Util.string_append_list([TAB,"res[",indx_str,"] = ",exp_str, ";\n",s1])=> res
	-----------------------
	generate_ode_system2_nonlinear_residuals2(DAELow.EQUATION(e1,e2)::rest,indx,repl) 
	  => res

  rule	Exp.simplify(e) => res_exp' &
	VarTransform.replace_exp(res_exp',repl) => res_exp'' &
        print_exp_cpp_str(res_exp'') => exp_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_residuals2(rest,indx',repl) => s1 &
	Util.string_append_list([TAB,"res[",indx_str,"] = ",exp_str, ";\n",s1])=> res
	-----------------------
	generate_ode_system2_nonlinear_residuals2(DAELow.RESIDUAL_EQUATION(e)::rest,indx,repl) 
	  => res
end


(** relation: generate_ode_system2_declaration
 ** author: PA
 ** 
 ** Generates code for the declaration of A and b when
 ** solving linear systems of equations.
 **)

relation generate_ode_system2_declaration: (int) => string =

  rule	int_string(size) => size_str &
	
	Util.string_append_list([TAB,"declare_matrix(A,",size_str,",",
				 size_str,");\n",
				 TAB,"declare_vector(b,",size_str,");\n"])
	  => res
	-----------------------
	generate_ode_system2_declaration(size)  => res
end

(** relation: generate_ode_system2_populate_Ab
 ** author: PA
 ** 
 ** Generates code for the population of A and b when
 ** solving linear system of equations.
 **)
	    
relation generate_ode_system2_populate_Ab:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray)
	  => string =

  rule	generate_ode_system2_populate_A(jac,vars,eqns) => s1 &
	generate_ode_system2_populate_b(jac,vars,eqns) => s2 &
	string_append(s1,s2) => res
	---------------------------
	generate_ode_system2_populate_Ab(jac,vars,eqns) => res
end

(** relation: generate_ode_system2_populate_A
 ** author: PA
 ** 
 ** Generates code for the population of A 
 ** solving linear system of equations.
 **)
relation generate_ode_system2_populate_A:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray)
	  => string =


  rule	DAELow.equation_size(eqns) => n_rows &
	generate_ode_system2_populate_A2(jac,vars,eqns,n_rows) => res
	-----------------------------
	generate_ode_system2_populate_A(jac,vars,eqns) => res

end

(** relation: generate_ode_system2_populate_A2
 ** author: PA
 **
 ** Helper relation to generate_ode_system2_populate_A
 **)

relation generate_ode_system2_populate_A2:((int * int * DAELow.Equation) list,
					  DAELow.Variables,
					  DAELow.EquationArray,
					  int) (* n rows *)
	  => string =

  axiom	generate_ode_system2_populate_A2([],_,_,_) => ""

  rule  r - 1 => r' &
	c - 1 => c' &
	int_string(r') => rs &
	int_string(c') => rc &
	int_string(n_rows) => n_rows_str &
	print_exp_cpp_str(exp) => es &
	generate_ode_system2_populate_A(jac,vars,eqn) => s1 &
	Util.string_append_list([TAB,"set_matrix_elt(A,",rs,", ",rc,", ",
				 n_rows_str,", ",es,");\n",s1]) => res
	--------------------------------------------------------------
	generate_ode_system2_populate_A2((r,c,DAELow.RESIDUAL_EQUATION(exp))::jac,vars,eqn,n_rows) => res
end

(** relation: generate_ode_system2_populate_b
 ** author: PA
 **
 ** Generates code for the population of A 
 ** solving linear system of equations.
 **)

relation generate_ode_system2_populate_b: ((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray)
	  => string =

  rule	DAELow.equation_list(eqns) => eqn_lst &
	generate_ode_system2_populate_b2(eqn_lst,vars,0) => res
	--------------------------------
	generate_ode_system2_populate_b(jac,vars,eqns) => res
end

(** relation: generate_ode_system2_populate_b2
 ** author: PA
 ** Helper relation to generate_ode_system2_populate_b
 **)

relation generate_ode_system2_populate_b2: (DAELow.Equation list,
					    DAELow.Variables,
					    int (* index iterator*)) 
	  => string =

  axiom	generate_ode_system2_populate_b2([],_,_) => ""


  rule	Exp.typeof(e1) => tp &
	let new_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	DAELow.get_eqnsys_rhs_exp(new_exp,v) => rhs_exp &
	let rhs_exp' = Exp.UNARY(Exp.UMINUS(tp),rhs_exp) &
	Exp.simplify(rhs_exp') => rhs_exp'' &
	print_exp_cpp_str(rhs_exp'') => rhs_str &
	int_string(index) => index_str &
	index + 1 => index'  &
	generate_ode_system2_populate_b2(rest,v,index') => s1 &
	Util.string_append_list([TAB,"set_vector_elt(b,",index_str,
				 ", ",rhs_str, ");\n",s1]) => res
	--------------------------------------------------------
	generate_ode_system2_populate_b2(DAELow.EQUATION(e1,e2)::rest,v,index) 
	  => res
end


(** relation: generate_ode_system2_solve_call
 ** author: PA
 ** 
 ** Generates code for the call, including setup, for solving
 ** a linear system of equations.
 **)

relation generate_ode_system2_solve_call:(int (* size of system *)) 
	  => string =


  rule	int_string(eqn_size) => size_str &
	Util.string_append_list([TAB,"solve_linear_equation_system(A,b,",
				 size_str,");\n"]) 
 	  => res
	---------------------------
	generate_ode_system2_solve_call(eqn_size) => res
end

(** relation: generate_ode_system2_collect_results
 ** author: PA
 **
 ** Generates the code for storing the result of solving
 ** a linear system of equations into the affected variables .
 **)

relation generate_ode_system2_collect_results:(DAELow.Variables) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	list_reverse(var_lst) => var_lst' &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	Util.list_map(crefs,Exp.print_component_ref_str) => strs &
	generate_ode_system2_collect_results2(strs,0) => res
	-------------------------------
	generate_ode_system2_collect_results(vars) => res
end
(** relation: generate_ode_system2_collect_results2
 ** author: PA
 ** 
 ** Helper relation to generate_ode_system2_collect_results
**)
relation generate_ode_system2_collect_results2: (string list,int)
	  => string =
	  
  axiom	generate_ode_system2_collect_results2([],_) => "" 
	
  rule	index + 1 => index' &
	generate_ode_system2_collect_results2(strs,index') => s1 &
	int_string(index) => index_str &
	Util.string_append_list([TAB,str," = get_vector_elt(b,",index_str,");\n",s1])
	=> res
	----------------------
	generate_ode_system2_collect_results2(str::strs,index) => res    
end

(** relation transform_x_to_xd
 ** author: PA
 ** this relation transforms x variables (in the state vector)
 ** to corresponding xd variable (in the derivatives vector)
 **)

relation transform_x_to_xd: DAELow.Var => DAELow.Var =

  rule	int_string(index) => index_str &
	Util.string_append_list(["xd[",index_str, "]"]) => res
	-------------------------
	transform_x_to_xd(DAELow.VAR(cr,DAELow.STATE,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow)) 
	  => DAELow.VAR(Exp.CREF_IDENT(res,[]),DAELow.STATE,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow)

  axiom	transform_x_to_xd(v) => v 
end

(** relation: get_equation_and_solved_var
 ** author: PA
 ** Retrieves the equation and the variable solved in that equation
 ** given an equation number and the variable assignments2
 **)
relation get_equation_and_solved_var: (int, (* equation no. *)
				       DAELow.EquationArray, 
				       DAELow.Variables,
				       int vector (* assignments2*)
				       ) 
	  => (DAELow.Equation, DAELow.Var) =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => eqn &
	vector_nth(ass2,e') => v &
	DAELow.get_var_at(vars,v) => var
	-------------------------------
	get_equation_and_solved_var(e,eqns,vars,ass2) => (eqn,var)	
end

relation is_non_state: DAELow.VarKind => () =

  axiom	is_non_state (DAELow.VARIABLE) => ()
  axiom	is_non_state (DAELow.DUMMY_DER) => ()
  axiom	is_non_state (DAELow.DUMMY_STATE) => ()
end 

(** relation: generate_ode_equation
 ** author: PA
 **
 **  Generates code for a single equation for the ode code generation, see
 ** genrerate_ode_code.
 **)

relation generate_ode_equation: (DAELow.DAELow, 
				 int vector, (*assignements 1 *)
				 int vector, (* assignements 2 *)
				 int) (* equation number*)
	  => (string, (* equation code *)
	      string) = (* extra functions *)

  rule	(* Solving for non-states *)
	
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2),
	      v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &
	is_non_state kind &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	print_exp_cpp_str(expr) => expr_str &
	Exp.print_component_ref_str(cr) => cr_str &
	Util.string_append_list(["  ",cr_str,"=",expr_str,";\n"]) => res
	-----------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) 
	  => (res,"")

  rule	(* Solving the state s means solving for der(s) *)
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	int_string(indx) => indxs &
	Util.string_append_list(["xd[",indxs,"]"]) => id &
	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	print_exp_cpp_str(expr) => expr_str &
	Exp.print_component_ref_str(cr') => cr_str &
	Util.string_append_list(["  ",cr_str,"=",expr_str,";\n"]) => res
	----------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) 
	  => (res,"")

	(* state nonlinear *)
  rule	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (eqn as DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	int_string(indx) => indxs &
	Util.string_append_list(["xd[",indxs,"]"]) => id &
	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	generate_ode_system2_nonlinear_residuals([cr'],[eqn])
	  => (res,f1)
	-------------------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) 
	  => (res,f1)
end

(** relation: generate_nonlinear_equations
 ** author: PA
 ** 
 ** This relation generates a nonlinear system of equations.
 **)

relation generate_nonlinear_equations: (Exp.ComponentRef list, (* variables *)
				     Exp.Exp list) (* residuals *)
	=> string =
  axiom	generate_nonlinear_equations(_,_) 
	  => "/* Generate non-linear equations not impl. yet.*/\n"
end

(** relation generate_functions
 **
 ** Finds the called functions in daelow and generates code for them
 ** from the given DAE. Hence, the functions must exist in the DAE.Element list.
**)
relation generate_functions: (SCode.Program, (* Needed to instantiate functions*)
			      DAE.DAElist, 
			      DAELow.DAELow, 
			      Absyn.Path, 
			      string) => () =

  rule	get_called_functions(dae, dlow) => funcpaths & 
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(funcpaths, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	generate_functions_2(p,funcpaths) => funcelems &
	Print.get_string => debugstr &
	Print.clear_buf &
	Codegen.generate_functions(DAE.DAE(funcelems)) &
	Print.write_buf(filename)
	--------------------------------------------------
	generate_functions (p,dae as DAE.DAE(elements), dlow, path, filename)


  rule	print "-generate_functions failed\n" 
	-------------------------------------
	generate_functions (_, _, _, _, _) => fail

end

(** relation: generate_functions_2
 ** author: PA
 **
 ** Helper relation to generate_functions.
 **)

relation generate_functions_2: (SCode.Program, Absyn.Path list) 
	  => DAE.Element list =
  rule	generate_functions_3(p,paths,paths) => dae
	-------------------
	generate_functions_2(p,paths) => dae
end



relation generate_functions_3: (SCode.Program, 
				Absyn.Path list, (* iterated over *)
				Absyn.Path list) (* complete list *)
	  => DAE.Element list =

  axiom	generate_functions_3(_,[],allpaths) => ([])

  rule	Inst.instantiate_class_implicit(p,path) => (fdae,_) &
	let DAE.DAE([DAE.FUNCTION(_,dae,t)]) = fdae &
       let patched_dae = DAE.DAE([DAE.FUNCTION(path,dae,t)]) &
	get_called_functions_in_function(path,patched_dae) => subfuncs &
	append_nonpresent_paths(subfuncs,allpaths,paths) 
	  => (allpaths',paths') &
	generate_functions_3(p,paths',allpaths') => elts &
	list_append(elts,[DAE.FUNCTION(path,dae,t)]) => res
	---------------------------------------
	generate_functions_3(p,path::paths,allpaths) => res

  rule	Inst.instantiate_class_implicit(p,path) => (fdae,_) &
	let DAE.DAE([DAE.EXTFUNCTION(_,dae,t,extdecl)]) = fdae &
       let patched_dae = DAE.DAE([DAE.EXTFUNCTION(path,dae,t,extdecl)]) &
	get_called_functions_in_function(path,patched_dae) => subfuncs &
	append_nonpresent_paths(subfuncs,allpaths,paths) 
	  => (allpaths',paths') &
	generate_functions_3(p,paths',allpaths') => elts &
	list_append(elts,[DAE.EXTFUNCTION(path,dae,t,extdecl)]) => res
	---------------------------------------
	generate_functions_3(p,path::paths,allpaths) => res

  rule	print "generate_functions_3 failed\n" 
	--------------------------
	generate_functions_3(_,_,_) => fail
    
end

(** relation: append_nonpresent_paths
 ** 
 **
 ** Appends the paths in first argument to the two path lists given as second
 ** and third argument, given that the path is not present in the second 
 ** path list.
 **
 **)

relation append_nonpresent_paths:(Absyn.Path list, (* paths to append*)
				  Absyn.Path list, (* all paths *)
				  Absyn.Path list) (* iterated paths *)
	  => (Absyn.Path list, (* updated all paths *)
	      Absyn.Path list) = (* update iterated paths *)

  axiom	append_nonpresent_paths([],allpaths,iterpaths) => (allpaths,iterpaths)

  rule	Util.list_getmember_p(path,allpaths,ModUtil.path_equal) => _ &
	append_nonpresent_paths(paths,allpaths,iterpaths) 
	  => (allpaths,iterpaths)
	------------------------------------------
	append_nonpresent_paths(path::paths, allpaths, iterpaths)
	  => (allpaths,iterpaths)

  rule	not Util.list_getmember_p(path,allpaths,ModUtil.path_equal) => _ &
	list_append(allpaths,[path]) => allpaths' &
	list_append(iterpaths,[path]) => iterpaths' &
	append_nonpresent_paths(paths,allpaths',iterpaths') 
	  => (allpaths'',iterpaths'')
	------------------------------------------
	append_nonpresent_paths(path::paths, allpaths, iterpaths)
	  => (allpaths'',iterpaths'')
end


(** relation generate_init_data
 **
 ** This relation generates initial values for the simulation
 ** by investigating values of variables.
 **)

relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
			      string(* filename *),
			      real, (* start time*)
			      real, (* stop time *)
			      real) (* step size *)
	  => () =

   rule	real_string(start) => start_str &
	real_string(stop) => stop_str &
	real_string(step) => step_str &
 	DAELow.calculate_sizes(dlow) => (nx,ny,np) &
 	int_string(nx) => nx_str &
 	int_string(ny) => ny_str &
 	int_string(np) => np_str &
 	generate_init_data2(dlow,nx,ny,np) => init_str &
 	Util.string_append_list([start_str, " // start value\n",
				 stop_str, " // stop value\n",
 				 step_str, " // step value\n",
 				 nx_str, " // n states\n",
 				 ny_str, " // n alg vars\n",
 				 np_str, " //n parameters\n",
 				 init_str]) => str &
 	System.write_file(filename,str) 
 	--------------------------
 	generate_init_data(dlow,class,filename,start,stop,step)

  rule	print "-generate_init_data failed\n"
 	------------------------------------
	generate_init_data(_,_,_,_,_,_) => fail
end

(** relation: generate_init_data2
 **
 ** Helper relation to generate_init_data
 ** Generates init data for states, variables and parameters.
 ** nx - number of states.
 ** ny - number of alg. vars. 
 ** np - number of parameters.
 **)
relation generate_init_data2:(DAELow.DAELow,
			      int(*nx*),
			      int(*ny*),
			      int(*np*)) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	array_create(nx,"") => nxarr &
	array_create(nx,"0.0") => nxdarr &
	array_create(ny,"") => nyarr &
	array_create(np,"") => nparr &
	generate_init_data3(var_lst,nxarr,nxdarr,nyarr,nparr) 
	  =>(nxarr1,nxdarr1,nyarr1,nparr1) &
	generate_init_data3(knvar_lst,nxarr1,nxdarr1,nyarr1,nparr1)
	  =>(nxarr2,nxdarr2,nyarr2,nparr2) &
	generate_init_data4(knvar_lst,nxarr2,nxdarr2,nyarr2,nparr2)  
	  =>(nxarr3,nxdarr3,nyarr3,nparr3) &
	array_list(nxarr3) => nx_lst &
	array_list(nxdarr3) => nxd_lst &
	array_list(nyarr3) => ny_lst &
	array_list(nparr3) => np_lst &
	Util.list_flatten([nx_lst,nxd_lst,ny_lst,np_lst]) => whole_lst &
	Util.string_delimit_list(whole_lst,"\n") => res
	-----------------------------
	generate_init_data2(DAELow.DAELOW(vars,knvars,_,_,initeqn,alg,_),nx,ny,np) => res


end

(** relation: print_exp_str_opt
 **
 ** Helper relation to generate_init_data2
 ** Prints expression value that is opional for initial values.
 ** If NONE is passed. The default value 0.0 is returned.
 **)
relation print_exp_str_opt: Exp.Exp option => string =

  axiom	print_exp_str_opt NONE => "0.0"

  rule	Exp.print_exp_str e => str 
 	--------------------------
 	print_exp_str_opt SOME(e) => str 
end

(** relation: generate_init_data3
 **
 ** This relation is a help relation to generate_init_data2
 ** It Traverses Var lists and adds initial values to the specific
 ** string array depending on the type of the variable.
 ** For instance, state variables write their start value to the
 ** x array at given index.
**)

relation generate_init_data3:(DAELow.Var list,
			      string array, (* state strings *)
			      string array, (* derivative strings*)
			      string array, (* alg. var strings *)
			      string array) (* param. strings *)
	  => (string array, (* updated state strings *)
	      string array, (* updated derivative strings*)
	      string array, (* updated alg. var strings *)
	      string array) (* updated param. strings *)
	=

  axiom	generate_init_data3([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

   rule	(* State variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nxarr,indx,str) => nxarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)
	--------------------
	 generate_init_data3(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,
                                        start,indx,origname,_,dae_var_attr,comment,flow)::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* dummy derivatives => algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,
                                       start,indx,origname,_,dae_var_attr,comment,flow)::rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)

  rule	(* Dummy states => algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
 	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,
				       _,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	----------------------
	generate_init_data3(_::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr',nxdarr',nyarr',nparr')
end

(** relation: print_exp_opt_str_if_const
 **
 ** Helper relation to generate_init_data3.
 **)

relation print_exp_opt_str_if_const:(Exp.Exp option) => string =
       
  rule  Exp.is_const(e) => true &
        print_exp_str_opt(SOME(e)) => res
        --------------------
        print_exp_opt_str_if_const(SOME(e)) => res
     
  rule  print_exp_str_opt(NONE) => res
        --------------------
        print_exp_opt_str_if_const(_) => "0.0"

end

(** relation: generate_init_data4
 **
 ** Helper relation to generate_init_data2
 ** Traverses parameters.
 **)

relation generate_init_data4: (DAELow.Var list, 
			       string array,
			       string array,
			       string array,
			       string array)  
	  => (string array,
	      string array,
	      string array,
	      string array)   =
  axiom	generate_init_data4([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr) 
	
  rule	(* Parameters *)
	Values.val_string(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,SOME(value),_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Parameters without value binding. Should normally not happen *)
	Util.string_append_list(["0.0  // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,NONE,_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Skip alg. vars that are removed 
	 In future we should compare eliminated variables 
	 intial values to their aliases to detect inconsistent
	 initial values.
	 *)
	generate_init_data4(vs,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	-----------------------------------
	generate_init_data4(_::vs,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr',nxdarr',nyarr',nparr')
end

(** relation: dump_when_clauses_str
 **
 ** Prints when clauses to a string.
 **)

relation dump_when_clauses_str: (DAELow.WhenClause list) => string =

  axiom	dump_when_clauses_str [] => ""

  rule	dump_when_clause_str c => str &
	dump_when_clauses_str xs => str2 &
	string_append(str, str2) => res
	------------------------------
	dump_when_clauses_str c::xs => res
end

relation dump_when_clause_str: (DAELow.WhenClause) => string =

  rule	Exp.print_exp_str exp => str1 &
	Util.string_append_list ["when ", str1, "\n"] => res
	----------------------------------------
	dump_when_clause_str DAELow.WHEN_CLAUSE(exp) => res

end

(** relation: generate_when_clauses
 **
 ** Generate code for when clauses.
 **)

relation generate_when_clauses: (string,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list) (* blocks *) 
	  => string =
	  
  rule
	build_when_blocks(dae,dlow,ass1,ass2,blocks) => when_str &
	dump_when_clauses_str wc => wcs &
	Util.string_append_list(["/*\n",wcs,when_str,"*/\n"]) => res
	--------------------------------------------------
	generate_when_clauses(cname,dae,dlow as DAELow.DAELOW(_,_,_,_,_,_,DAELow.EVENT_INFO(wc,_)),ass1,ass2,blocks) => res

  rule	print "-generate_when_clauses failed\n"
	----------------------------------------
	generate_when_clauses(_,_,_,_,_,_) => fail
end

(** relation: build_when_blocks
 **
 ** Helper relation to build_when_clauses.
 **)

relation build_when_blocks : (DAE.DAElist,DAELow.DAELow, int vector, int vector, int list list) => string =

  axiom build_when_blocks(_,_,_,_,[]) => ""

  rule	build_when_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	build_when_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str2 &
	string_append(eqn_str, eqn_str2) => res
	----------------------------------------
	build_when_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => res

  axiom build_when_blocks(_,_,_,_,_) => ""

  rule	print "-generate_when_blocks failed\n" 
	----------------------------------------
	build_when_blocks(_,_,_,_,_) => fail
end

(** relation: build_when_equation
 **
 ** Helper relation to build_when_blocks.
 **)

relation build_when_equation: (DAE.DAElist,
			       DAELow.DAELow, 
			       int vector, (* assignments1*)
			       int vector, (* assignments2*)
			       int (* equation no. *)
			       ) => string =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e as DAELow.WHEN_EQ(_,cr,expr)) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	build_assignment(dae,cr,expr,origname) => assignment_string
	--------------------------------
	build_when_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assignment_string

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e as DAELow.WHEN_EQ(_,cr,expr)) &
	print "-build_when_equation failed\n"
	----------------------------------------
	build_when_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail

	axiom build_when_equation(_,_,_,_,_) => ""
end
	

(** relation: generate_compute_residual_state
 **
 ** This relation generates the code for the calculation of the 
 ** state variables on residual form. Called from generate_simulation_code.
 **)

relation generate_compute_residual_state:(string,
					  DAE.DAElist,
					  DAELow.DAELow,
					  int vector, (* assignments1 *) 
					  int vector, (* assignments2 *)
					  int list list) (* blocks *) 
	  => string =
          
  rule	
        build_residual_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str_list &
        Util.string_append_list(eqn_str_list) => cstate &
        Util.string_append_list(["int\nfunctionDAE_res(double *t, double *x, double *xd, double *delta, long int *ires, double *rpar, long int* ipar)\n{\n",cstate,TAB,"return 0;\n\n}\n"]) 
	  => res
        -------------------------------------------------------------
        generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blocks) => res
end


(** relation: generate_compute_output
 **
 ** This relation generates the code for the calculation of the output
 ** variables.
 **)

 relation generate_compute_output:(string,
				   DAE.DAElist,
                                   DAELow.DAELow,
                                   int vector, 
                                   int vector, 
                                   int list list) => string =
         
  rule	let func_header = "int\nfunctionDAE_output(double *t, double* x, double* xd, double* y, double* p)\n{\n" &
	 let func_footer = "return 0;\n\n}\n" &
	 build_solved_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str_lst &
	 generate_compute_removed_eqns(dlow) => eqn_str_lst2 &
	 Util.list_flatten([[func_header],eqn_str_lst, eqn_str_lst2,
			    [func_footer]]) => res &
         Util.string_append_list(res) => coutput 
         -------------------------------------------------------------
         generate_compute_output(cname,dae,dlow,ass1,ass2,blocks) => coutput
 end

(** relation: generate_compute_removed_eqns
 ** author: PA
 **
 ** Generates compute code for the removed equations
 **)
relation generate_compute_removed_eqns: (DAELow.DAELow) => string list =

  rule	DAELow.equation_list(reqns) => eqn_lst &
	generate_compute_removed_eqns_2(eqn_lst) => res
	-----------------
	generate_compute_removed_eqns(DAELow.DAELOW(_,_,_,reqns,_,_,_)) => res
end

(** relation: generate_compute_removed_eqns_2
 **
 ** Helper relation to generate_computed_remove_eqns
 **)
relation generate_compute_removed_eqns_2: DAELow.Equation list  => string list =

  axiom	generate_compute_removed_eqns_2([]) => []

  rule	generate_compute_removed_eqns_2(rest) => res &
	Exp.print_component_ref_str(cr) => cr_str &	
	print_exp_cpp_str(exp) => exp_str &
	Util.string_append_list(["  ",cr_str," = ",exp_str,";\n"]) => s1 
	------------------------------
	generate_compute_removed_eqns_2(DAELow.SOLVED_EQUATION(cr,exp)::rest)
	  => s1::res
end


(** relation: build_solved_blocks
 **
 ** This relation generates code for blocks on solved form, i.e. 
 ** \dot{x} = f(x,y,t) 
 **)

relation build_solved_blocks:(DAE.DAElist,
			      DAELow.DAELow, 
			      int vector, (* assignments1*)
			      int vector, (* assignments2*)
			      int list list (* list of blocks *)) 
	  => string list =

  axiom	build_solved_blocks(_,_,_,_,[]) => []
	     
  rule	(* for single equations *)
	 build_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	 build_solved_blocks(dae,dlow,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_solved_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res
	 

  rule	(* for blocks *)
	build_block(dae,dlow,ass1,ass1,block) => block_str &
	build_solved_blocks(dae,dlow,ass1,ass2,blocks) => res
	 ------------------
	build_solved_blocks(dae,dlow,ass1,ass2,block::blocks) => block_str::res

  rule	print "-build_solved_blocks failed\n" 
	 -----------------
	 build_solved_blocks(_,_,_,_,_) => fail
 end

(** relation: build_block
 **
 ** This relation returns the code string for solving a block of variables 
 ** in the dae, i.e. a set of coupled equations.
 ** It is used both for state variables and algebraic variables.
**)

relation build_block: (DAE.DAElist,
		       DAELow.DAELow, 
		       int vector, (* assignments1 *)
		       int vector, (* assignments2 *)
		       int list) (* block of equations*)
	  => string =

  rule	all_same_algorithm(dlow,block) => true &
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(alg,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),1) 
	  => (Codegen.CFUNCTION(_,_,_,_,_,_,stmt_strs,_),_) &
	Util.string_delimit_list(stmt_strs,"\n") => res
	---------------
	build_block(dae,dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),ass1,as2,block as e::_) 
	  => res

  rule	print "#Solving of equation systems not implemented yet.\n"
	--------------------------
	build_block(dae,dlow,ass1,ass2,block) => fail
end

(** relation: all_same_algorithm
 **
 ** Checks that a block consists only of one algorithm in different -nodes-
**)

relation all_same_algorithm: (DAELow.DAELow,
			      int list) (* blocks*)
	  => bool =

  rule	(* extract index of first algorithm and check that entire block
	 * has that index. *)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,_,_) &
	all_same_algorithm2(dlow, block,indx) => res
	----------------------
	all_same_algorithm(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),block as e::_) 
	  => res

  axiom	all_same_algorithm(_,_) => false
end

(** relation: all_same_algorithm2
 **
 ** Helper relation to all_same_algorithm. Checks all equations in the block
 ** and returns true if they all are algorithms with the same index. 
 **)

relation all_same_algorithm2:(DAELow.DAELow, 
			      int list, (* block *)
			      int (* alg. index*)) => bool =
  axiom	all_same_algorithm2(_,[],_) => true

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => true &
	all_same_algorithm2(dlow,es,indx) => b1 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),e::es,indx) => b1

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => false 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),e::es,indx) => false

  axiom	all_same_algorithm2(_,_,_) => false

end

(** relation build_equation 
 **
 ** This returns the code string for a specific equation in the dae.
 ** It is used both for state variables and regular variables
 **)

relation build_equation:(DAE.DAElist, 
			 DAELow.DAELow, 
			 int vector, (* assignments1*)
			 int vector, (* assignments2*)
			 int) (* equation no*)
	  => string =
	     
  rule  (* filter discrete variables *)
	int_sub(e,1) => e' &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (DAELow.VAR(_,kind,_,_,_,_,_,_,_,_,_,_,_,flow)) &  
	DAELow.is_discrete kind 
	--------------------------------
	build_equation(_,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_),_,ass2,e) => ""
        
  rule  (* Solving for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	DAELow.is_non_state kind => true &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	build_assignment(dae,cr,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string	
        
	
  rule	(* Solving the state s means solving for der(s) *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
	let new_varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,new_varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	build_assignment(dae,cr ,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string 
	
  rule	(* probably, solved failed in rule above. This means that we have 
	 a non-linear equation. *)
 	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
 	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail

  rule	(* Algorithms *)
	(* Each algorithm should only be genated once.*)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(algs,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),1) 
	  => (Codegen.CFUNCTION(_,_,_,_,_,_,stmt_strs,_),_) &
	Util.string_delimit_list(stmt_strs,"\n") => res
	-------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,algs,_),ass1,ass2,e) => res 
        
  rule	print "-build_equation failed\n" 
	--------------------------------
	build_equation(_,_,_,_,_) => "//build_equation failed\n" 
end

(** relation: build_residual_blocks
 **
 ** This relation generates code for blocks on residual form, i.e.
 ** g(\dot{x},x,y,t) = 0
 **)

 relation build_residual_blocks:(DAE.DAElist,DAELow.DAELow, 
				 int vector, (* ass1 *)
				 int vector, (* ass2 *)
				 int list list) (* blocks *)
	  => string list =

  axiom	build_residual_blocks(_,_,_,_,[]) => []
	 
  rule	(* For system of equations *) 
	 build_residual_system(dae,dlow,ass1,ass2,block) => eqn_str &
	 build_residual_blocks(dae,dlow,ass1,ass2,blocks) => res 
	 -------------------------------------
	 build_residual_blocks(dae,dlow,ass1,ass2,(block as (_::_::_))::blocks) 
	  => eqn_str::res
	 
  rule	(* for single equations *)
	 build_residual_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	 build_residual_blocks(dae,dlow,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_residual_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res

  rule	print "-build_residual_blocks failed\n" 
	 -----------------
	 build_residual_blocks(_,_,_,_,_) => fail
 end

(** relation build_residual_system
 **
 ** A system of equations on residual form is still only an output of each
 ** residual equation. The numerical solver will solve the system.
**)

relation build_residual_system: (DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int list (* equation no. *)
				   ) => string =

  axiom	build_residual_system(_,_,_,_,[]) => ""

  rule	build_residual_equation(dae,dlow,ass1,ass2,eqn) => s1 &
	build_residual_system(dae,dlow,ass1,ass2,eqns) => s2 &
	string_append(s1,s2) => str
	---------------------------------------------
	build_residual_system(dae,dlow,ass1,ass2,eqn::eqns) => str
end


(** relation build_residual_equation 
 **
 ** This relation generates code on residual form for one equation.
 ** It is used both for state variables and algebraic variables.
 **)

 relation build_residual_equation:(DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int (* equation no. *)
				   ) => string =
	 
  rule  (* Do not output equations for discrete variables here *)
	 int_sub(e,1) => e' &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (DAELow.VAR(_,kind,_,_,_,_,_,_,_,_,_,_,_,flow)) &  
	 DAELow.is_discrete kind 
	 --------------------------------
	 build_residual_equation(_,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_),_,ass2,e) => ""	
         
  rule  (* Solving for non-states *)
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	 DAELow.is_non_state kind => true &
	 (*print "Solving for non-states\n" &*)
	 
	 let varexp = Exp.CREF(cr,Exp.REAL) &
	 Exp.solve(e1,e2,varexp) => expr &
         Exp.simplify(expr) => simplify_exp &
	 build_assignment(dae,cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string	
         
	 
  rule  (* Solving the state s, caluate residual form. *) 
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') 
	  => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
	 int_string(indx) => indx_str &
	 let exp = Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2) &
	 Exp.simplify(exp) => simplify_exp &
	 (* Use array named 'delta' for residuals *)
	 Util.string_append_list(["delta[",indx_str,"]"]) => cr_str &
	 let new_cr = Exp.CREF_IDENT(cr_str,[]) &
	 build_assignment(dae,new_cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string 
	 
  rule	(* when-equations are not part of the residual equations *)
        int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e) 
	--------------------------------
	build_residual_equation(_,DAELow.DAELOW(_,_,eqns,_,_,_,_),_,_,e) => ""

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail
         

  rule  print "-build_residual_equation failed\n" 
	--------------------------------
	build_residual_equation(_,_,_,_,_) 
	  => "//build_residual_equation failed\n" 
end

(** relation build_assignment 
 **
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)

relation build_assignment: (DAE.DAElist,
			    Exp.ComponentRef, (* varname *)
			    Exp.Exp, (*expression*) 
			    string) (* orig. name*) 
	  => string =

  rule  Exp.print_component_ref_str(cr) => cr_str &	
        print_exp_cpp_str(exp) => exp_str &
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
	-------------------------------------------------------------------------
	build_assignment(dae as DAE.DAE(elements),cr,exp as Exp.CALL(path,args,tuple as false,builtin),origname) => eqn_str


  rule  print "-simcodegen: build_assignment: Tuple return values from functions not implemented\n"
	--------------------------------------------------------------------------
	build_assignment(dae,cr,exp as Exp.CALL(path,args,tuple as true,builtin),origname) => fail
	  
  rule  Exp.print_component_ref_str(cr) => cr_str &
        print_exp_cpp_str(exp) => exp_str & 
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
        --------------------------------
	build_assignment(dae,cr,exp,origname) => eqn_str
        
  rule	print "-build_assignment failed\n" 
	------------------------
	build_assignment(dae,cr,exp,origname) => fail
end


(** relation: print_exp_cpp_str
 **
 ** This relation prints a complete expression on a C/C++ format.
 **)

 relation print_exp_cpp_str : Exp.Exp => string =
         
  rule  print_exp2_str (e,0) => s
	--------------------
	print_exp_cpp_str e => s
         
 end

(** relation: lbinop_symbol
 **
 ** Helper relation to print_exp2_str
 **)

relation lbinop_symbol : Exp.Operator => string =
  axiom	lbinop_symbol(Exp.AND) => " && "
  axiom	lbinop_symbol(Exp.OR) => " || "
end

(** relation: lunaryop_symbol
 **
 ** Helper relation to print_exp2_str
 **)

relation lunaryop_symbol : Exp.Operator => string =
  axiom	lunaryop_symbol(Exp.NOT) => " !"
end

(** relation: relop_symbol
 **
 ** Helper relation to print_exp2_str
 **)

relation relop_symbol : Exp.Operator => string =
  axiom	relop_symbol(Exp.LESS(_))       => " < "
  axiom	relop_symbol(Exp.LESSEQ(_))     => " <= "
  axiom	relop_symbol(Exp.GREATER(_))    => " > "
  axiom	relop_symbol(Exp.GREATEREQ(_))  => " >= "
  axiom	relop_symbol(Exp.EQUAL(_))      => " = "
  axiom	relop_symbol(Exp.NEQUAL(_))     => " <> "
end


(** relation: print_exp2_str
 ** Helper relation to print_exp_str
 **)

 relation print_exp2_str : (Exp.Exp,int) => string =

  rule  print "# equation contain undefined symbols"
        --------------------------
        print_exp2_str(Exp.END,_) => fail
         
         
  rule  int_string(x) => s
	 ----------------------------
         print_exp2_str(Exp.ICONST(x),_) => s
         
  rule  real_string(x) => s
	 -----------------------------
         print_exp2_str(Exp.RCONST(x),_) => s

  rule  string_append ("\"", s) => s' &
	 string_append (s', "\"") => s''
         ---------------------------------
         print_exp2_str(Exp.SCONST(s),_) => s''
         
  axiom print_exp2_str(Exp.BCONST(false),_) => "false"

  axiom	print_exp2_str(Exp.BCONST(true),_) => "true"


  rule	Exp.print_component_ref_str c => res
        --------------------------------
        print_exp2_str(Exp.CREF(c,_),_) => res

  rule  Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority(op) => pri2' &
         int_add(pri2',1) => pri2 & (* binary minus have higher priority than itself *)
         Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
         print_exp2_str (e1,pri3) => s2 & 
         print_exp2_str (e2,pri2) => s3 &
         Exp.print_rightpar_str (pri1,pri2) => s4 &
         string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22)),pri1) => s'''

  rule	(* x^2 => x*x *)
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.ICONST(2)),pri1) => res
	 
  rule	(* x^2 => x*x *)
	 int_real(2) => two' &
	 real_eq(two,two) => true &
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.RCONST(two)),pri1) => res

  rule	Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
         string_append("pow(",s) => s' &
         string_append(s',",") => s'' &
         string_append(s'',s3) => s''' &
         string_append(s''',")") => res &
	 string_append (res, s4) => res'
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), e2),pri1) => res'

  rule	Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op, e2),pri1) => s'''

  rule	Exp.unaryop_symbol(op) => sym &
	 Exp.unaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ----------------------------
	 print_exp2_str(Exp.UNARY(op, e),pri1) => s''

  rule	 lbinop_symbol(op) => sym &
	 Exp.lbinop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ----------------------------------------------------------------
	 print_exp2_str(Exp.LBINARY(e1, op, e2),pri1) => s'''

  rule	 lunaryop_symbol(op) => sym &
 	 Exp.lunaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ---------------------------------------------------
	 print_exp2_str(Exp.LUNARY(op, e),pri1) => s''

  rule	 relop_symbol(op) => sym &
 	 Exp.relop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str(e1,pri3) => s2 & 
	 print_exp2_str(e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -----------------------------------------------------------------
	 print_exp2_str(Exp.RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	 print_exp2_str(t,0) => thenstr &
	 print_exp2_str(f,0) => elsestr &
	 string_append ("(( ", ifstr) => s &
	 string_append (s, " ) ? ( ") => s' &
	 string_append (s', thenstr) => s'' &
	 string_append (s'', " ) : ( ") => s''' &
	 string_append (s''', elsestr) => s'''' &
	 string_append (s'''', " )) ") => slast 
	 ----------------------------
	 print_exp2_str(Exp.IFEXP(c,t,f),_) => slast

  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list([fs, "(", argstr, ")"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as true),_) => s

  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list([fs, "(", argstr, ").",fs,"_rettype_1"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as false),_) => s

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("{",s) => s' &
	 string_append (s',"}") => s''
	 -----------------------------
	 print_exp2_str (Exp.ARRAY(_,_,es),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("(",s) => s' &
	 string_append (s',")") => s''
	 -----------------------------
	 print_exp2_str (Exp.TUPLE(es),_) => s''
	 
  rule	Exp.print_list_str(es, Exp.print_row_str, "},{") => s &
	 string_append ("{{",s) => s' &
	 string_append (s',"}}") => s''
	 -----------------------------
	 print_exp2_str (Exp.MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (stop,pri3) => s3 &
 	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -------------------------------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1,pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (step,pri3) => s3 &
 	 print_exp2_str (stop,pri3) => s4 &
 	 Exp.print_rightpar_str (pri1,pri2) => s5 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', ":") => s''' &
	 string_append (s''', s4) => s'''' &
	 string_append (s'''', s5) => s'''''
	 -------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res &
	 string_append("-",res) => res2
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	 print_exp_cpp_str e => s & 
	 string_append ("(float)(", s) => s' &
	 string_append (s', ")") => s''
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	 print_exp_cpp_str e => s
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s

  rule	let pri2 = 51 &
         Exp.get_cref_from_exp(e) => cref_list &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
 	 Exp.print_rightpar_str (pri1,pri2) => s3 &
 	 int_string i => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, s3) => s' &
	 string_append (s', "[") => s'' &
	 string_append (s'', s4) => s''' &
	 string_append (s''', "]") => s''''
	 ---------------------------------------
	 print_exp2_str (Exp.ASUB(e,i),pri1) => s''''

  rule	print_exp_cpp_str cr => crstr &
	 print_exp_cpp_str dim => dimstr &
	 Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_cpp_str cr => crstr &
	 Util.string_append_list(["size(",crstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	 print_exp_cpp_str exp => expstr &
	 print_exp_cpp_str iterexp => iterstr &
	 Util.string_append_list(["<reduction>",
				  fs,"(",expstr," for ",
				  id," in ",iterstr,")"]) => str
	 -------------------------------------------------------
	 print_exp2_str (Exp.REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

 end

(** relation: cref_modelica_str
 **
 ** Converts Exp.ComponentRef, i.e. variables, to Modelica friendly variables.
 ** This means that dots are converted to underscore, etc.
 **)

relation cref_modelica_str : Exp.ComponentRef => string =

  rule  Util.string_replace_char(s,#".",#"_") => res' &
        Util.string_replace_char(res',#"[",#"_") => res'' &
        Util.string_replace_char(res'',#"]",#"_") => res''' 
        (* & Util.string_append_list(["_",res,"_"]) => res'*)
        ------------------------------
        cref_modelica_str(Exp.CREF_IDENT(s,_)) => res'''
        
  rule	cref_modelica_str(n) => ns &
(*  	string_append(s,"_") => s1 &  *)
	string_append(s(*s1*),ns) => ss
	-------------------------------------
	 cref_modelica_str(Exp.CREF_QUAL(s,_,n)) => ss
end


(** relation: get_called_functions
 **
 ** Goes through the DAELow structure, finds all function calls and returns 
 ** them in a list. Removes duplicates.
 **)

relation get_called_functions : (DAE.DAElist, DAELow.DAELow) => Absyn.Path list =

  rule	DAELow.get_all_exps dlow => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res
	-------------------------------------
	get_called_functions (dae, dlow) => res
	
end

(** relation: get_called_functions_in_functions
 **
 ** Goes through the given DAE, finds the given functions and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list =

  rule	Util.list_map_1(paths, get_called_functions_in_function, dae) => pathslist &
	Util.list_flatten(pathslist) => res
	-------------------------------------
	get_called_functions_in_functions (paths,dae) => res
end

(** relation: get_called_functions_in_function 
 **
 ** Goes through the given DAE, finds the given function and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list =

	(* Don't fail here, ceval will generate the function later *)
  rule	DAE.get_named_function(path, elements) => [] &
	Print.print_error_buf("Function not found: ") &
	Absyn.path_string path => pathstr &	
	Print.print_error_buf(pathstr) &
	Print.print_error_buf("\n")
	(*debug*) & Debug.fprint("info", "Function not found: ")
	(*debug*) & Debug.fprintln("info", pathstr)
	---------------------------------------------------
	get_called_functions_in_function (path,DAE.DAE(elements)) => []


  rule	DAE.get_named_function(path, elements) => funcelems &
	DAE.get_all_exps funcelems => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res1 &
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(res1, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	get_called_functions_in_functions (res1, dae) => res2 &
	list_append(res1,res2) => res	
	---------------------------------------------------
	get_called_functions_in_function (path, dae as DAE.DAE(elements)) => res

end


(** relation: is_not_builtin_call
 **
 ** return true if the given Exp.CALL is a call but not to a builtin function.
 ** checks the builtin flag in Exp.CALL
 **)
relation is_not_builtin_call : Exp.Exp => bool =

  rule	bool_not(builtin) => res
	------------------
	is_not_builtin_call Exp.CALL(_,_,_,builtin) => res

  axiom	is_not_builtin_call e => false

end

(** relation: get_call_path
 **
 ** Retrive the function name from a CALL expression.
 **)

relation get_call_path : Exp.Exp => Absyn.Path =

  axiom	get_call_path Exp.CALL(path,_,_,_) => path

end

(** relation: remove_duplicate_paths
 **
 ** Removed duplicate Paths in a list of Path.
**)

relation remove_duplicate_paths : Absyn.Path list => Absyn.Path list =

  axiom	remove_duplicate_paths [] => []


  rule	remove_path_from_list (rest, first) => restwithoutfirst &
	remove_duplicate_paths restwithoutfirst => recresult
	----------------------------------------------------
	remove_duplicate_paths first::rest => first::recresult


end

(** relation: remove_path_from_list
 **
 ** Helper relation to remove_duplicate_paths.
 **)

relation remove_path_from_list : (Absyn.Path list, Absyn.Path) => Absyn.Path list =

  axiom	remove_path_from_list ([],_) => []

  rule	ModUtil.path_equal (first, path) => true &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => res

  rule	ModUtil.path_equal (first, path) => false &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => first::res


end

