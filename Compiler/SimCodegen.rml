(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 SimCodegen.rml
 ** module:      SimCodegen
 ** description: Generate Simulation code for connecting to solver.
 ** This can be done in two different ways.
 ** 1. Generation of simulation code on residual form. This will generate 
 ** code on the form g(\dot{x},x,y,t)=0.
 ** 2. Generation of simulation code on solved form. This will generate
 ** code on ode form. \dot{x} = f(x,y,t). This means that "function" f will
 ** contain code for solving states from equations, some of them might be 
 ** system of equations, linear or non-linear.
 **
 ** Outputs: the simulation code in C/C++ to a given filename.
 ** Input: DAELow
 ** Uses: DAELow, Absyn, Exp
 **
 **
 ** RCS: $Id$
 **
 **)
module SimCodegen:

  with "DAE.rml"
  with "DAELow.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "SCode.rml"

  relation generate_simulation_code: (DAE.DAElist,
				    DAELow.DAELow, 		      
				    int vector, (* ass1 *)
				    int vector, (* ass2 *)
				    DAELow.IncidenceMatrix,
				    DAELow.IncidenceMatrixT,
				    int list list, (* blocks*)
				    Absyn.Path,  (* classname *)
				    string,
                                      string) => ()
	  	  
  relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
                               string (* executable file name *) ,
				string,real,real,real)  => ()
	  
  relation generate_makefile:(string, (*filename*)
	                      string, (* classname *)
	                      string list, (* libs *)
                              string (* directory for mo-file *)
	                      ) => () 
	  
  relation print_exp_cpp_str : Exp.Exp => string 
	  
  relation cref_modelica_str : Exp.ComponentRef => string 
	  
  relation generate_functions: (SCode.Program,DAE.DAElist, DAELow.DAELow, Absyn.Path, string) => (string list (* libs *))

  relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list
  relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list
  relation print_exp_opt_str_if_const:(Exp.Exp option) => string 
  relation change_name_for_derivative:(string) => string 
  relation define_string_to_modelica_string : (string) => string	  
end

type CFunction = Codegen.CFunction

val TAB = "    " (* TAB is four whitespaces *)
val state_names = "state_names"
val derivative_names= "derivative_names"
val algvars_names= "algvars_names"
val input_names= "input_names"
val output_names= "output_names"
val param_names= "param_names"


val state_comments= "state_comments"
val derivative_comments= "derivative_comments"
val algvars_comments= "algvars_comments"
val input_comments= "input_comments"
val output_comments= "output_comments"
val param_comments= "param_comments"

val param_in_getName_function= "ptr"

with "Util.rml"
with "RTOpts.rml"
with "Debug.rml"
with "System.rml"
with "Values.rml"
with "Codegen.rml"
with "Print.rml"
with "ModUtil.rml"
with "VarTransform.rml"
with "Dump.rml"
with "Inst.rml"
with "Error.rml"
with "Settings.rml"
with "Algorithm.rml"
with "Types.rml"

(** relation: generate_makefile
 **
 ** This relation generates a makefile for the simulation code.
 ** It uses:
 **  - OPENMODELICAHOME/include as a reference to includes and
 **  - OPENMODELICAHOME/lib as a reference to library files 
 **)
 relation generate_makefile:(string, (*filename*)
	                     string, (* classname *)
	                     string list, (* libs *)
                             string (* directory for mo-file *)
	                     ) => () =
			      
  rule	Util.string_append_list([cname,".cpp"]) => cpp_file &
	Util.string_delimit_list(libs, " ") => libs' &
	Settings.getInstallationDirectoryPath => omhome' &
        System.trim(omhome',"\"") => omhome &
	Util.string_append_list(["#Makefile generated by OpenModelica\n\n",
				 "CXX=g++\n",
				 cname,": ",cpp_file, "\n",
				 "\t $(CXX) -o ",cname,".exe ", (* ".exe" is needed for a class that is in a package. *) 
                                 cpp_file, 
		                 " -L\"",omhome,"/lib/\"",
				 " -I\"",omhome,"/include/\" ",
				 " -lsim -lg2c -lc_runtime ",libs', "\n"
				 ]) => str &
	System.writeFile(filename,str) 
	-------------------------
	generate_makefile(filename,cname,libs,"")

  rule	Util.string_append_list([cname,".cpp"]) => cpp_file &
	Util.string_delimit_list(libs, " ") => libs' &
	Settings.getInstallationDirectoryPath => omhome' &
        System.trim(omhome',"\"") => omhome &
	Util.string_append_list(["#Makefile generated by OpenModelica\n\n",
				 "CXX=g++\n",
				 cname,": ",cpp_file, "\n",
				 "\t $(CXX) -o ",cname,".exe ", (* ".exe" is needed for a class that is in a package. *) 
                                 cpp_file, 
		                 " -L\"",omhome,"/lib/\"",
                                 " -L\"",file_dir,"\"",
				 " -I\"",omhome,"/include/\" ",
                                 " -I\"",file_dir,"\"",
				 " -lsim -lg2c -lc_runtime ",libs', "\n"
				 ]) => str &
	System.writeFile(filename,str) 
	-------------------------
	generate_makefile(filename,cname,libs,file_dir)
end


(** relation: generate_simulation_code
 **
 ** Outputs simulation code from a DAELow suitable for connection to DASSL.
 ** The state calculations are generated on residual form, i.e. 
 ** g(\dot{x},x,y,t) = 0.
 ** and on explicit ode form, \dot{x}=f(x,y,t)
 **)
relation generate_simulation_code: (DAE.DAElist,
				  DAELow.DAELow, 		      
				  int vector, (* ass1 *)
				  int vector, (* ass2 *)
				  DAELow.IncidenceMatrix,
				  DAELow.IncidenceMatrixT,
				  int list list, (* blocks*)
				  Absyn.Path,  (* classname *)
				  string,
                                    string) => () =

  rule  Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_output_function_code(dlow) => (out_str,n_o) &
	generate_input_function_code(dlow) => (in_str,n_i) &
	generate_event_checking_code(dlow,blt_states,ass1,ass2,m,mt,class) 
	  => (c_eventchecking, helpVarInfo) & 
	  list_length helpVarInfo => n_h &
	generate_initial_value_code2(dlow) => (s_code2,nres) &
	generate_initial_bound_parameter_code(dlow) => (s_code3) &
        generate_global_data(class,dlow,n_o,n_i,n_h,nres) => cglobal &  
     	  generate_compute_output(cname,dae,dlow,ass1,ass2,blt_no_states) 
	  => coutput &
         generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blt_states) 
	  => cstate &
	generate_ode_code(dlow,blt_states,ass1,ass2,m,mt,class) => c_ode &
	generate_initial_value_code(dlow) => s_code &


	generate_when_clauses(cname,dae,dlow,ass1,ass2,comps) => cwhen &
	generate_zero_crossing(cname,dae,dlow,ass1,ass2,comps,helpVarInfo) => czerocross & 
	Util.string_append_list(["//Simulation code for ",cname,
				 "\n//Generated by OpenModelica.\n",
				 "\n#include \"modelica.h\"\n",
				 "\n#include \"simulation_runtime.h\"\n",
				 "\n#include \"",funcfilename,"\"\n",
				 cglobal,coutput,in_str,out_str,cstate,czerocross,cwhen,
				 c_ode,s_code,s_code2,s_code3,c_eventchecking]) => res &
	System.writeFile(filename,res) 
	---------------------------------------------------------------------
	generate_simulation_code(dae,dlow,ass1,ass2,m,mt,comps,class,filename,funcfilename) => ()


  rule	Error.add_message(Error.INTERNAL_ERROR, ["Generation of simulation code  failed"])
	-----------------------
	generate_simulation_code(_,_,_,_,_,_,_,_,_,_) => fail
end

(** relation: filter_ng
 ** This relation sets the number of zero crossings to zero if events are disabled
 **)
relation filter_ng: int => int =

  rule	use_zerocrossing => false
	----------------------------------------
	filter_ng _ => 0

  axiom	filter_ng ng => ng

end

(** relation: generate_global_data
 **
 ** This relation generates the C-code for the global data: arrays for states,
 ** derivatives and algebraic variables, etc.
 ** arg1
 ** arg2
 ** arg3 an int which shows the number of output variables on top level
 ** arg4 an int which shows the number of input variables on top level
 ** arg5 an int which shows the number of help variables
 ** arg5 integer - number of residuals in initialization function.
 **)
 relation generate_global_data:(Absyn.Path,DAELow.DAELow,int,int,int,int) 
	  => string  =

  rule  (* DAELow.dump(dlow) & *) 
         DAELow.calculate_sizes(dlow) => (nx,ny,np,ng) &
	filter_ng ng => ng' &
	Absyn.path_string(class) => class_str &
	int_string(nx) => nx_str &
	int_string(ny) => ny_str &
	int_string(np) => np_str &
	int_string(ng') => ng_str &
        int_string(no) => no_str &
        int_string(ni) => ni_str &
        int_string(nh) => nh_str &
	 int_string(nres) => nres_str &
         
 	 generate_var_names_and_comments(dlow,nx,ny,ni,no,np) => c_code &
	 
	 generate_fixed_vector(dlow,nx,ny,np) => (c_code2_str) &
	 
         
         Util.string_delimit_list(c_code,"\n") => c_code_str &
         generate_macros() => macros_str &
	 generate_global_bufs() => global_bufs &
	 Util.string_append_list(["\n",
				  "#define NHELP ", nh_str, "\n",
				  "#define NG ",ng_str,"\n",
				  "#define NX ",nx_str,"\n",
				  "#define NY ",ny_str,"\n",
				 "#define NP ",np_str," // number of paramters\n",
				 "#define NO ",no_str," // number of outputvar on topmodel\n",
				 "#define NI ",ni_str," // number of inputvar on topmodel\n",
				  "#define NR ",nres_str," // number of residuals for initialialization function\n",
				 "#define MAXORD 5\n",
				 "#define time (*t)\n",
				 "\n",
				  global_bufs,
				 "char *model_name=\"",class_str,
				 "\";\n",
                                  c_code_str,
				  c_code2_str,
                                  "\n"]
				 )  => str1 &
         (* this is done here and not in the above Util.string_append_list VC7.1 cannot compile too complicated c-programs *)
         Util.string_append_list([str1,
                                  (*this is removed for now *)
(*                                   "typedef struct equation {\n", *)
(*                                   "  char* equation;\n", *)
(*                                   "  char* fileName;\n", *)
(*                                   "  int   lineNumber;\n", *)
(*                                   "} equation;\n", *)
                                  macros_str,"\n"]) => str
	---------------------------
	generate_global_data(class, dlow,no,ni,nh,nres) => str
	
  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_global_data failed"])
	 ---------------------
	 generate_global_data(_,_,_,_,_,_) => fail
end

(** relation: generate_fixed_vector
 **
 ** Generates a vector, fixed[nx+nx+ny+np] where the fixed attribute is stored
 ** It is collected for states, derivatives, variables and parameters.
 **)

relation generate_fixed_vector:(DAELow.DAELow, int (*nx*),
			       int (* ny *),
			       int (*np *))
	=> string =

  rule	Util.list_reduce([nx,nx,ny,np],int_add) => arr_size  &
	array_create(arr_size,"0/*default*/") => str_arr &
	generate_fixed_vector2(dae,str_arr,nx,ny,np) => str_arr' &
	array_list(str_arr') => str_lst &
	Util.string_delimit_list(str_lst,", ") => str &
	Util.string_append_list(["char init_fixed[NX+NX+NY+NP]={",str,"};"]) 
	  => res
	-----------------------------------
	generate_fixed_vector(dae,nx,ny,np) => res
rule	print "generate_fixed_vector failed\n" 
	-----------------------------------
	generate_fixed_vector(dae,nx,ny,np) => fail
end

(** relation: generate_fixed_vector2
 ** author: PA
 **
 ** Helper relation to generate_fixed_vector
 **)

relation generate_fixed_vector2: (DAELow.DAELow,
				  string array,
				  int (*nx*),
				  int (*ny*),
				  int (*np*)) 
	  => string array =

  rule	DAELow.var_list(v) => v_lst &
	DAELow.var_list(kv) => kv_lst &
	generate_fixed_vector3(v_lst,str_arr,nx,ny,np) => str_arr' &
	generate_fixed_vector3(kv_lst,str_arr',nx,ny,np) => str_arr''
	-------------------------
	generate_fixed_vector2(DAELow.DAELOW(v,kv,_,_,_,_,_,_),str_arr,
			       nx,ny,np)
	  => str_arr''
end

(** relation: generate_fixed_vector3
 ** author: PA
 **
 ** Helper relation to generate_fixed_vector2
 **)

relation generate_fixed_vector3: (DAELow.Var list, 
				  string array, 
				  int (*nx*),
				  int (*ny*), 
				  int (*np*))
	=> (string array) =

  axiom	generate_fixed_vector3([],str_arr,_,_,_) => str_arr

	(* skip constants*)
  rule	DAELow.var_kind(v) => DAELow.CONST &
	generate_fixed_vector3(vs,str_arr,nx,ny,np) => str_arr'
	-------------------------
	generate_fixed_vector3(v::vs,str_arr,nx,ny,np) => str_arr'
	
  rule	DAELow.var_kind(v) => kind &
	DAELow.var_index(v) => indx &
	int_ge(indx,0) => true &
	calc_fixed_offset(kind,nx,ny,np) => off &
	int_add(off,indx) => indx' &
	DAELow.var_fixed(v) => b &
	Util.if(b,"1", "0") => value &
	array_setnth(str_arr,indx',value) => str_arr' &
	generate_fixed_vector3(vs,str_arr',nx,ny,np) => str_arr''
	-------------------------
	generate_fixed_vector3(v::vs,str_arr,nx,ny,np) => str_arr''

  rule	print "generate_fixed_vector3 failed\n" 
	-------------------------
	generate_fixed_vector3(v::vs,str_arr,nx,ny,np) => fail
end

(** relation: calc_fixed_offset
 ** author: PA
 **
 ** Calculates the offset for a fixed attribute int the fixed vector.
 ** The attributes are stored in this order:
 ** {states, derivatives, alg. vars, parameters}.
 **)

relation calc_fixed_offset: (DAELow.VarKind, int (* nx*),
			     int (*ny*),
			     int (*np*))
	=> int =

	  (* states offset: 0 *)
  axiom	calc_fixed_offset(DAELow.STATE,_,_,_) => 0 

	(* algebraic variables offset: 2*nx *)
  rule	int_add(nx,nx) => offset
	------------------------
	calc_fixed_offset(DAELow.VARIABLE,nx,ny,np) => offset
	(* algebraic variables offset: 2*nx *)
  rule	int_add(nx,nx) => offset
	------------------------
	calc_fixed_offset(DAELow.DUMMY_DER,nx,ny,np) => offset
 	(* algebraic variables offset: 2*nx *)
  rule	int_add(nx,nx) => offset
	------------------------
	calc_fixed_offset(DAELow.DUMMY_STATE,nx,ny,np) => offset

 	(* algebraic variables offset: 2*nx *)
  rule	int_add(nx,nx) => offset
	------------------------
	calc_fixed_offset(DAELow.DISCRETE,nx,ny,np) => offset

	(* parameter offset: 2*nx+ny *)
  rule	Util.list_reduce([nx,nx,ny],int_add) => offset
	------------------------
	calc_fixed_offset(DAELow.PARAM,nx,ny,np) => offset

	(* constant offset: 2*nx+ny NOTE: should not happend *)
  rule	Util.list_reduce([nx,nx,ny],int_add) => offset
	------------------------
	calc_fixed_offset(DAELow.CONST,nx,ny,np) => offset

  rule	print "calc_fixed_offset failed\n" 
	--------------------
	calc_fixed_offset(_,_,_,_) => fail
end


(** relation: generate_global_bufs
 ** author: PA
 **
 **)
relation generate_global_bufs: () => string =

  rule	Util.string_append_list(["#if NHELP > 0 /* some c-compilers does not like a static array of |a|==0 */\n",
				 "double hbuf[NHELP];\n",
				 "double *h = &hbuf[0];\n",
                                 "#else\n",
				 "double *h;\n",
				 "#endif\n",
                                 "#if NX > 0\n",
				 "double xbuf[NX];  // STATES\n",
				 "double *x = &xbuf[0];\n",
                                 "#else\n",
				 "double *x;\n",
				 "#endif\n",
                                 "#if NX > 0\n",
				 "double xdbuf[NX]; // DERIVATIVES\n",
				 "double *xd = &xdbuf[0];\n",
                                 "#else\n",
				 "double *xd;\n",
                                 "#endif\n",
                                 "#if NX > 0\n",
				 "double dummy_deltabuf[NX];\n",
				 "double *dummy_delta = &dummy_deltabuf[0];\n",
                                 "#else\n",
				 "double *dummy_delta;\n",
                                 "#endif\n",
                                 "#if NY > 0\n",
				 "double ybuf[NY]; // ALGVARS\n",
				 "double *y = &ybuf[0];\n",
                                 "#else\n",
				 "double *y;\n",
                                 "#endif\n",
                                 "#if NP > 0\n",
				 "double pbuf[NP];  // PARAMETERS\n",
				 "double *p = &pbuf[0];\n",
                                 "#else\n",
				 "double *p;\n",
                                 "#endif\n",
                                 "#if NO > 0\n",
				 "double out_ybuf[NO]; // OUTPUTVARS\n",
				 "double *out_y = &out_ybuf[0];\n",
				 "#else\n",
				 "double *out_y;\n",
                                 "#endif\n",
                                 "#if NR > 0\n",
				 "double init_res_buf[NR];  // INIT. RESIDUALS\n",
				 "double *init_res = &init_res_buf[0];\n",
                                 "#else\n",
				 "double *init_res;\n",
				 "#endif\n",
                                 "#if NG > 0\n",
				 "long jrootbuf[NG];\n",
				 "long *jroot = &jrootbuf[0];\n",
                                 "#else\n",
				 "long *jroot;\n",
                                 "#endif\n",
				 "double rworkbuf[50+(MAXORD+4)*NX+NX*NX+3*NG];\n",
				  "double *rwork=&rworkbuf[0];\n",
                                 "#if NI > 0\n",
				 "double in_ybuf[NI]; // INPUTVARS\n",
				 "double *in_y = &in_ybuf[0];\n",
				 "#else\n",
				 "double *in_y;\n",
                                  "#endif\n",
				  "long iworkbuf[20+NX];\n",
				  "long *iwork=&iworkbuf[0];\n",
				 "long liw = 20+NX;\n", 
				 "long lrw = 50+(MAXORD+4)*NX+NX*NX+3*NG;\n",
				 "long nx = NX; // STATES\n",
				 "long ny = NY; // ALGVARS\n",
				 "long np = NP; // PARAMETERS\n",
				 "long nr = NR; // NO. OF INIT. RESIDUALS\n",
				 "long ng = NG; \n",
				 "long no = NO; // OUTPUTVARS\n",
				 "long ni = NI; // INPUTVARS \n",
				 "long nhelp = NHELP;\n"]) => res
	--------------------
	generate_global_bufs() => res
end

(**
 **relation generate_macros
 **generates the macros that are used in the code
 **author: x02lucpo
 **)
relation generate_macros:() => string =
        
  rule  Util.string_append_list(["#define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))\n",
                                 "\n",
                                 "\n",
                                 "int encounteredDivisionByZero = 0;\n",
                                 "double division_error(double b,const char* division_str)\n",
                                 "{\n",
                                 "  if(!encounteredDivisionByZero){\n",
                                 "    fprintf(stderr,\"ERROR: Division by zero in partial equation: %s.\\n\",division_str);\n", 
                                 "    encounteredDivisionByZero = 1;\n",
                                 "   }",
                                 "   return b;\n",
                                 "}\n"
                                 ]) => retString
        -----------------------
        generate_macros => retString
end



(** relation: generate_var_names_and_comments
 **
 ** Generates an array of the original variable names.
 **)
relation generate_var_names_and_comments:(DAELow.DAELow,
                                          int, (*nx*) 
                                          int, (*ny*)
                                          int, (*ni*)
                                          int, (*no*)
                                          int  (*np*)) 
	  => (string list ) =
	
  rule	


        DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
        array_create(nx,"\"state  ERROR\"") => state_arr &
	array_create(nx,"\"derivative ERROR\"") => derivative_arr &
	array_create(ny,"\"algvar ERROR\"") => algvar_arr &
        (* 	array_create(ni,"") => input_arr & *)
        (* 	array_create(no,"") => output_arr & *)
	array_create(np,"\"param ERROR\"") => param_arr &

        array_create(nx,"\" ERROR\"") => state_comment_arr &
	array_create(nx,"\" ERROR\"") => derivative_comment_arr &
	array_create(ny,"\" ERROR\"") => algvar_comment_arr &
        (* 	array_create(ni,"") => input_comment_arr & *)
        (* 	array_create(no,"") => output_comment_arr & *)
	array_create(np,"\" ERROR\"") => param_comment_arr &


        generate_var_names_and_comments2(var_lst,
                                         (*names,comments,numberof*)
                                         state_arr,state_comment_arr,0,(* state*)
                                         derivative_arr,derivative_comment_arr,0,(* derivative  *)
                                         algvar_arr,algvar_comment_arr,0,(* algvars *)
                                         [],[],0,(* input *)
                                         [],[],0,(* output *)
                                         param_arr,param_comment_arr,0, (* param *)
                                         [],
                                         [])
        
          => (state_arr,state_comment_arr,num_state'',(* state*)
              derivative_arr,derivative_comment_arr,num_derivative'',(* derivative  *)
              algvar_arr,algvar_comment_arr,num_algvars'',(* algvars *)
              input_arr,input_comment_arr,num_input'',(* input *)
              output_arr,output_comment_arr,num_output'',(* output *)
              param_arr,param_comment_arr,num_param'', (* param *)
              get_name_function_ifs,var_defines)  &
        

        generate_var_names_and_comments2(knvar_lst,
                                         (*names,comments,numberof*)
                                         state_arr,state_comment_arr,num_state'',(* state*)
                                         derivative_arr,derivative_comment_arr,num_derivative'',(* derivative  *)
                                         algvar_arr,algvar_comment_arr,num_algvars'',(* algvars *)
                                         input_arr,input_comment_arr,num_input'',(* input *)
                                         output_arr,output_comment_arr,num_output'',(* output *)
                                         param_arr,param_comment_arr,num_param'', (* param *)
                                         get_name_function_ifs,var_defines)
        
          => (state_arr,state_comment_arr,num_state'',(* state*)
              derivative_arr,derivative_comment_arr,num_derivative'',(* derivative  *)
              algvar_arr,algvar_comment_arr,num_algvars'',(* algvars *)
              input_arr,input_comment_arr,num_input'',(* input *)
              output_arr,output_comment_arr,num_output'',(* output *)
              param_arr,param_comment_arr,num_param'', (* param *) 
              get_name_function_ifs',var_defines') &
        

        (*****************************************)
        (* TODO: CHECK THE RETURN TO BE THE SAME *)
        (* INSTEAD OF SETTING WITH let           *)
        (*****************************************)
        let num_state'' = nx &
        let num_derivative'' = nx &
        let num_algvars'' = ny &
        let num_output'' = no &
        let num_input'' = ni &
        let num_param'' = np &


        array_list(state_arr) => state_str' &
        array_list(derivative_arr) => derivative_str' &
        array_list(algvar_arr) => algvars_str' &
        (*         array_list(input_arr) => input_str' & *)
        (*         array_list(output_arr) => output_str' & *)
        array_list(param_arr) => param_str' &
        
        Util.string_delimit_list(state_str',", ") => state_str'' &
        Util.string_delimit_list(derivative_str',", ") => derivative_str'' &
        Util.string_delimit_list(algvars_str',", ") => algvars_str'' &
        Util.string_delimit_list(input_arr,", ") => input_str'' &
        Util.string_delimit_list(output_arr,", ") => output_str'' &
        Util.string_delimit_list(param_str',", ") => param_str'' &
        
        array_list(state_comment_arr) => state_comment_str' &
        array_list(derivative_comment_arr) => derivative_comment_str' &
        array_list(algvar_comment_arr) => algvars_comment_str' &
        (*         array_list(input_comment_arr) => input_comment_str' & *)
        (*         array_list(output_comment_arr) => output_comment_str' & *)
        array_list(param_comment_arr) => param_comment_str' &
        
        Util.string_delimit_list(state_comment_str',", ") => state_comment_str'' &
        Util.string_delimit_list(derivative_comment_str',", ") => derivative_comment_str'' &
        Util.string_delimit_list(algvars_comment_str',", ") => algvars_comment_str'' &
        Util.string_delimit_list(input_comment_arr,", ") => input_comment_str'' &
        Util.string_delimit_list(output_comment_arr,", ") => output_comment_str'' &
        Util.string_delimit_list(param_comment_str',", ") => param_comment_str'' &

        (*this is for backwards-compatibility *)
        Util.string_delimit_list([state_str'',derivative_str'',algvars_str''],", ") => var_names &

        int_add(num_state'',num_derivative'') => num_var_names &
        int_add(num_var_names,num_algvars'') => num_var_names' &

        generate_c_decl_for_string_array("varnamesbuf",var_names,num_var_names') => var_names' &

        generate_c_decl_for_string_array(state_names,state_str'',num_state'') => state_str''' &
        generate_c_decl_for_string_array(derivative_names,derivative_str'',num_derivative'') =>der_str'''  &
        generate_c_decl_for_string_array(algvars_names,algvars_str'',num_algvars'') => algvar_str''' &
        generate_c_decl_for_string_array(input_names,input_str'',num_input'') => inputvar_str''' &
        generate_c_decl_for_string_array(output_names,output_str'',num_output'') => outputvar_str''' &
        generate_c_decl_for_string_array(param_names,param_str'',num_param'') => paramvar_str''' &
        
	Util.string_append_list([
                                 state_str''',der_str''',algvar_str''',inputvar_str''',outputvar_str''',paramvar_str'''
                                 ]) => res &

        generate_c_decl_for_string_array(state_comments,state_comment_str'',num_state'') => state_comment_lst' &
        generate_c_decl_for_string_array(derivative_comments,derivative_comment_str'',num_derivative'') =>der_comment_lst'  &
        generate_c_decl_for_string_array(algvars_comments,algvars_comment_str'',num_algvars'') => algvar_comment_lst' &
        generate_c_decl_for_string_array(input_comments,input_comment_str'',num_input'') => inputvar_comment_lst' &
        generate_c_decl_for_string_array(output_comments,output_comment_str'',num_output'') => outputvar_comment_lst' &
        generate_c_decl_for_string_array(param_comments,param_comment_str'',num_param'') => paramvar_comment_lst' &

	Util.string_append_list([
                                 state_comment_lst',der_comment_lst',algvar_comment_lst',
                                 inputvar_comment_lst',outputvar_comment_lst',paramvar_comment_lst'
                                 ]) => res2 &

        (* generate getName function *)
         Util.string_append_list(get_name_function_ifs) => get_name_function_ifs' &
         Util.string_append_list(["char* getName( double* ",param_in_getName_function,")\n",
                                  "{\n",
                                  get_name_function_ifs',
                                  "\n  return \"\";\n}\n"]) => get_name_function &
        Util.string_append_list(var_defines') => var_defines_str
        ----------------------------------------
	generate_var_names_and_comments(DAELow.DAELOW(vars,knvars,_,_,_,_,_,_),nx,ny,ni,no,np) 
	  => [res,res2,var_names',"char** varnames=&varnamesbuf[0];\n",var_defines_str,get_name_function]
        
end


(**relation generate_c_decl_for_string_array
 **author x02lucpo
 **
 **generates a static C-array with char* <name>[<number>] or only a char** depending it the int parameters is > 0
 **)
relation generate_c_decl_for_string_array:(string,string,int) => string =
        
  rule  int_eq(number_of_strings,0) => true &
        Util.string_append_list(["char* ",array_name,"[1] = {\"\"};\n"]) => res
        -----------------------------------
        generate_c_decl_for_string_array(array_name,_,number_of_strings) => res
        
        
  rule  int_string(number_of_strings) => number_of_strings_str &
        Util.string_append_list(["char* ",array_name,"[",number_of_strings_str,"]={",array_str,"};\n"]) => res
        -----------------------------------
        generate_c_decl_for_string_array(array_name,array_str,number_of_strings) => res
        
        
end

(** relation: generate_var_names_and_comments2
 **
 ** Helper relation to generate_var_names_and_comments2
 **)
 relation generate_var_names_and_comments2:(DAELow.Var list, 
                                            (*names,comments,numberof*)
                                            string array,string array,int,(* state*)
                                            string array,string array,int,(* derivative  *)
                                            string array,string array,int,(* algvars *)
                                            string list,string list,int,(* input *)
                                            string list,string list,int,(* output *)
                                            string array,string array,int, (* param *)
                                            string list,
                                            string list)  (* #define a$point x[1] *)
         
          => (
              string array,string array,int,(* state *)
              string array,string array,int,(* derivative *)
              string array,string array,int,(* algvars *)
              string list,string list,int,(* input *)
              string list,string list,int,(* output *)
              string array,string array,int, (* param *)
              string list,(* get_name_function_ifs' *)
              string list (* #define a$point x[1] *)) =
         
         
         
  rule 
         ---------------------------
         generate_var_names_and_comments2([],
                                          state_str,state_comments,num_state,(* state *)
                                          derivative_str,derivative_comments,num_derivative,(* derivative *)
                                          algvars_str,algvars_comments,num_algvars,(* algvars *)
                                          input_str,input_comments,num_input,(* input *)
                                          output_str,output_comments,num_output,(* output *)
                                          param_str,param_comments,num_param, (* param *)
                                          get_name_function_ifs,
                                          var_defines) 

          => (state_str,state_comments,num_state,(* state *)
              derivative_str,derivative_comments,num_derivative,(* derivative *)
              algvars_str,algvars_comments,num_algvars,(* algvars *)
              input_str,input_comments,num_input,(* input *)
              output_str,output_comments,num_output,(* output *)
              param_str,param_comments,num_param, (* param *)
              get_name_function_ifs,
              var_defines) 
         
  rule  
         generate_var_names_and_comments2(vs,
                                          state_str,state_comments,num_state,(* state *)
                                          derivative_str,derivative_comments,num_derivative,(* derivative *)
                                          algvars_str,algvars_comments,num_algvars,(* algvars *)
                                          input_str,input_comments,num_input,(* input *)
                                          output_str,output_comments,num_output,(* output *)
                                          param_str,param_comments,num_param, (* param *)
                                          get_name_function_ifs,
                                          var_defines)
         
          => (state_str',state_comments',num_state',(* state *)
              derivative_str',derivative_comments',num_derivative',(* derivative *)
              algvars_str',algvars_comments',num_algvars',(* algvars *)
              input_str',input_comments',num_input',(* input *)
              output_str',output_comments',num_output',(* output *)
              param_str',param_comments',num_param', (* param *)
              get_name_function_ifs',
              var_defines') &
         
         (*generate STATE names*)
         (*generate DERIVATIVES names because the same combination of var_kind and direction*)
         generate_var_names_and_comments_states_and_derivatives(var,state_str',state_comments',
                                                                derivative_str',derivative_comments',num_state',get_name_function_ifs',
                                                                var_defines') 
          =>(state_str'',state_comments'',
             derivative_str'', derivative_comments'', num_state'',get_name_function_ifs1,var_defines1) &

         let num_derivative'' = num_state'' &

         (*generate ALGVARS names*)
         generate_var_names_and_comments_algvars(var,algvars_str',algvars_comments',num_algvars',get_name_function_ifs1,var_defines1) 
          => (algvars_str'',algvars_comments'',num_algvars'',get_name_function_ifs2,var_defines2) &

         (*generate INPUTS names*)
         generate_var_names_and_comments_inputs(var,input_str',input_comments',num_input',get_name_function_ifs2,var_defines2) 
          => (input_str'',input_comments'',num_input'',get_name_function_ifs3,var_defines3) &

         (*generate OUTPUT names*)
         generate_var_names_and_comments_outputs(var,output_str',output_comments',num_output',get_name_function_ifs3,var_defines3) 
          => (output_str'',output_comments'',num_output'',get_name_function_ifs4,var_defines4) &

         (*generate PARAM names*)
         generate_var_names_and_comments_params(var,param_str',param_comments',num_param',get_name_function_ifs4,var_defines4) 
          => (param_str'',param_comments'',num_param'',get_name_function_ifs5,var_defines5) 


         -----------------------
         generate_var_names_and_comments2((var as DAELow.VAR(cr,kind,dir,_,_,_,
				                             _,value,indx,origname,_,dae_var_attr,comment,flow))::vs,
                                          state_str,state_comments,num_state,(* state *)
                                          derivative_str,derivative_comments,num_derivative,(* derivative *)
                                          algvars_str,algvars_comments,num_algvars,(* algvars *)
                                          input_str,input_comments,num_input,(* input *)
                                          output_str,output_comments,num_output,(* output *)
                                          param_str,param_comments,num_param, (* param *)
                                          get_name_function_ifs,
                                          var_defines)
         
          => (state_str'',state_comments'',num_state'',(* state *)
              derivative_str'',derivative_comments'',num_derivative'',(* derivative *)
              algvars_str'',algvars_comments'',num_algvars'',(* algvars *)
              input_str'',input_comments'',num_input'',(* input *)
              output_str'',output_comments'',num_output'',(* output *)
              param_str'',param_comments'',num_param'', (* param *)
              get_name_function_ifs5,
              var_defines5) 



  rule  print "generate_var_names_and_comments2 failed \n"
	 -----------------------
	 generate_var_names_and_comments2(_::vs, 
                                          state_str,state_comments,num_state,(* state *)
                                          derivative_str,derivative_comments,num_derivative,(* derivative *)
                                          algvars_str,algvars_comments,num_algvars,(* algvars *)
                                          input_str,input_comments,num_input,(* input *)
                                          output_str,output_comments,num_output,(* output *)
                                          param_str,param_comments,num_param, (* param *)
                                          get_name_function_ifs',var_defines) 
         
          => fail

end


relation generate_getname_function_if:(Exp.ComponentRef, 
                                       int, (* the index in c-array *)
                                       string (* name of c-array *)) => string =

  rule  Exp.print_component_ref_str(cr) => cr_str &
        int_string(index) => index_str &
        Util.string_append_list(["  if( &", cr_str," == ", param_in_getName_function, " ) return ",c_array_name,"[",index_str,"];\n"]) => ret_str
        -------------------------
        generate_getname_function_if(cr,index,c_array_name) => ret_str
                                


end
relation generate_getname_function_if_for_derivatives:(Exp.ComponentRef,
                                                       int, (* name of c-array *)
                                                       string) (* the index in c-array *)
          => string =
        
  rule  Exp.print_component_ref_str(cr) => cr_str &
        int_string(index) => index_str &
        Util.string_append_list(["  if( &",DAELow.derivative_name_prefix,cr_str," == ", param_in_getName_function, " ) return ",c_array_name,"[",index_str,"];\n"]) => ret_str
        -------------------------
        generate_getname_function_if_for_derivatives(cr,index,c_array_name) => ret_str


end


(** relation generate_var_names_and_comments_inputs
 ** Checks and generates a comment and input for a input variable
 ** author x02lucpo
 **)
 relation generate_var_names_and_comments_inputs:(DAELow.Var, (* the variable to checked *)
                                                  string list,
                                                  string list,
                                                  int, (* the old number of variables generated *)
                                                  string list, (* get_name_function_ifs' *)
                                                  string list) (* #define a$pointb x[1] *)

          => (string list, (* name of the from "a" *)
              string list, (* comment of the from "a afhalk" *)
              int, (* number of generated strings *) 
              string list,
              string list(* #define a$pointb x[1] *)) =
         
  rule  DAELow.is_var_on_top_level_and_input(var) => true &
	 Exp.print_component_ref_str(origname)=> origname_str &
         Util.string_append_list(["\"",origname_str,"\""]) => name' &
         Dump.unparse_comment_option_no_annotation(comment) => comment &
         int_add(n_vars,1) => n_vars' &
         generate_empty_string(comment) => comment' &
         generate_getname_function_if(cr,n_vars,input_names) => if_str 
        (*no defines because the outputvars is a subset of algvars*)
         --------------------------------
         generate_var_names_and_comments_inputs(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                                  _,value,indx,origname,_,dae_var_attr,comment,flow),
                                                name_arr,
                                                comment_arr,
                                                n_vars,
                                                get_name_function_ifs,var_defines) 
          => (name'::name_arr,comment'::comment_arr,n_vars,
              if_str::get_name_function_ifs,var_defines)


  axiom generate_var_names_and_comments_inputs(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                                 _,value,indx,origname,_,dae_var_attr,comment,flow),
                                               name_arr,
                                               comment_arr,
                                               n_vars,
                                               get_name_function_ifs,var_defines) 
          => (name_arr,comment_arr,n_vars,get_name_function_ifs,var_defines)


end


(** relation generate_var_names_and_comments_outputs
 ** Checks and generates a comment and input for a output variable
 ** author x02lucpo
 **)
relation generate_var_names_and_comments_outputs:(DAELow.Var, (* the variable to checked *)
                                                 string list,
                                                 string list,
                                                  int, (* the old number of variables generated *)
                                                  string list,
                                                  string list)
          => (string list, (* name of the from "a" *)
              string list, (* comment of the from "a afhalk" *)
              int, (* number of generated strings *) 
              string list,
              string list) =
                                                                           
  rule  DAELow.is_var_on_top_level_and_output(var) => true &
	Exp.print_component_ref_str(origname)=> origname_str &
        Util.string_append_list(["\"",origname_str,"\""]) => name' &
        Dump.unparse_comment_option_no_annotation(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' &
        generate_getname_function_if(cr,n_vars,output_names) => if_str 
        (*no defines because the outputvars is a subset of algvars*)
        --------------------------------
        generate_var_names_and_comments_outputs(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                               name_arr,
                                               comment_arr,
                                                n_vars,
                                                get_name_function_ifs,var_defines) 
          => (name'::name_arr,comment'::comment_arr,n_vars',
              if_str::get_name_function_ifs,var_defines)


  axiom generate_var_names_and_comments_outputs(DAELow.VAR(cr,kind,dir,_,_,_,
				                           _,value,indx,origname,_,dae_var_attr,comment,flow),
                                                name_arr,
                                                comment_arr,
                                                n_vars,
                                                get_name_function_ifs,var_defines) 
          => (name_arr,comment_arr,n_vars,get_name_function_ifs,var_defines)


end

(** relation generate_var_names_and_comments_algvars
 ** Checks and generates a comment and input for a algvar variable
 ** author x02lucpo
 **)
 relation generate_var_names_and_comments_algvars:(DAELow.Var, (* the variable to checked *)
                                                   string array,
                                                   string array,
                                                   int,  (* the old number of variables generated *)
                                                   string list,
                                                  string list) 
          => (string array, (* name of the from "a" *)
              string array, (* comment of the from "a afhalk" *)
              int, (* number of generated strings *) 
              string list,
              string list) =
                                                                           
  rule  let kind_lst =  [DAELow.VARIABLE,DAELow.DISCRETE,
                         DAELow.DUMMY_DER,DAELow.DUMMY_STATE] &
        Util.list_getmember(kind,kind_lst) => _ & (* if this fails then the var is not added to list*)
	 Exp.print_component_ref_str(origname)=> origname_str &
        Util.string_append_list(["\"",origname_str,"\""]) => name' &
        Dump.unparse_comment_option_no_annotation(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' &
        array_setnth(name_arr,indx,name') => name_arr' &
        array_setnth(comment_arr,indx,comment') => comment_arr' &
        generate_getname_function_if(cr,indx,algvars_names) => if_str &
	 int_string(indx) => is &
	 Exp.print_component_ref_str(cr) => name &
	 Util.string_append_list(["#define ",name," y[",is,"]","\n"]) => define_str &
	 generate_array_define(origname,inst_dims,indx,"y") => array_define &
	 string_append(define_str,array_define) => define_str
         --------------------------------
        generate_var_names_and_comments_algvars(DAELow.VAR(cr,kind,dir,_,_,_,
				                    inst_dims,value,indx,origname,_,dae_var_attr,comment,flow),
                                               name_arr,
                                               comment_arr,
                                                n_vars,
                                                get_name_function_ifs,var_defines)
          => (name_arr',comment_arr',n_vars',
              if_str::get_name_function_ifs,define_str::var_defines)


  axiom generate_var_names_and_comments_algvars(DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                                name_arr,
                                                comment_arr,
                                                n_vars,
                                                get_name_function_ifs,var_defines) 
          => (name_arr,comment_arr,n_vars,get_name_function_ifs,var_defines)


end

(** relation generate_var_names_and_comments_params
 ** Checks and generates a comment and input for a param variable
 ** author x02lucpo
 **)
relation generate_var_names_and_comments_params:(DAELow.Var, (* the variable to checked *)
                                                 string array,
                                                 string array,
                                                 int, (* the old number of variables generated *)
                                                 string list,
                                                 string list)
          => (string array, (* name of the from "a" *)
              string array, (* comment of the from "a afhalk" *)
              int, (* number of generated strings *) 
              string list,
              string list) =
                                                                           
  rule  DAELow.is_param(var) => true &
	Exp.print_component_ref_str(origname)=> origname_str &
        Util.string_append_list(["\"",origname_str,"\""]) => name' &
        Dump.unparse_comment_option_no_annotation(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' &
        array_setnth(name_arr,indx,name') => name_arr' &
        array_setnth(comment_arr,indx,comment') => comment_arr' &
        generate_getname_function_if(cr,indx,param_names) => if_str &
	 int_string(indx) => is &
	 Exp.print_component_ref_str(cr) => name &
	 Util.string_append_list(["#define ",name," p[",is,"]","\n"]) => define_str &
	 generate_array_define(origname,inst_dims,indx,"p") => array_define &
	 string_append(define_str,array_define) => define_str 
         
        --------------------------------
        generate_var_names_and_comments_params(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    inst_dims,value,indx,origname,_,dae_var_attr,comment,flow),
                                               name_arr,
                                               comment_arr,
                                               n_vars,
                                               get_name_function_ifs,
                                               var_defines) 
          => (name_arr',comment_arr',n_vars',
              if_str::get_name_function_ifs,define_str::var_defines)
        

  axiom generate_var_names_and_comments_params(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                               name_arr,
                                               comment_arr,
                                               n_vars,
                                               get_name_function_ifs,
                                               var_defines)
          => (name_arr,comment_arr,n_vars,get_name_function_ifs,var_defines)


end

(** relation generate_var_names_and_comments_states_and_derivatives
 ** Checks and generates a comment and input for a state and derivative variable
 ** author x02lucpo
 **)
 relation generate_var_names_and_comments_states_and_derivatives:(DAELow.Var, (* the variable to checked *)
                                                                  string array, (* name of the from "a" *)
                                                                  string array,(* comment of the from "a afhalk" *)
                                                                  string array,(* name of the from "der(a)" *)
                                                                  string array,(* comment of the from "a afhalk" *)
                                                                  int, (* the old number of variables generated *)
                                                                  string list,
                                                                  string list)
          => (string array, (* name of the form "a" *)
              string array, (* comment of the from "a afhalk" *)
              string array, (* name of the form "der(a)" *)
              string array, (* comment of the from "a afhalk" *)
              int, (* number of generated strings *) 
              string list,
              string list) =
         
  rule  DAELow.is_state_var(var) => true &
	 Exp.print_component_ref_str(origname)=> origname_str &
         Util.string_append_list(["\"",origname_str,"\""]) => name' &
         change_name_for_derivative(origname_str) => der_origname' &
         Util.string_append_list(["\"",der_origname',"\""]) => der_name' &
         Dump.unparse_comment_option_no_annotation(comment) => comment &
         int_add(n_vars,1) => n_vars' &
         generate_empty_string(comment) => comment' &
         array_setnth(name_arr,indx,name') => name_arr' &
         array_setnth(name_arr_der,indx,der_name') => name_arr_der' &
         array_setnth(comment_arr,indx,comment') => comment_arr' &
         array_setnth(comment_arr_der,indx,comment') => comment_arr_der'&
         generate_getname_function_if(cr,indx,state_names) => if_str &
         generate_getname_function_if_for_derivatives(cr,indx,derivative_names) => if_str' &
         let get_name_function_ifs' = if_str::get_name_function_ifs &
         let get_name_function_ifs'' = if_str'::get_name_function_ifs'  &
	 int_string(indx) => is &
	 Exp.print_component_ref_str(cr) => name &
	 Util.string_append_list(["#define ",name," x[",is,"]","\n"]) => define_str &
	 Util.string_append_list(["#define ",DAELow.derivative_name_prefix,name," xd[",is,"]","\n"]) => define_str_der &
	 generate_array_define(origname,inst_dims,indx,"x") => array_define &
	 string_append(define_str,array_define) => define_str 
         --------------------------------
         generate_var_names_and_comments_states_and_derivatives(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                                                  inst_dims,value,indx,origname,_,dae_var_attr,comment,flow),
                                                                name_arr,
                                                                comment_arr,
                                                                name_arr_der,
                                                                comment_arr_der,
                                                                n_vars,
                                                                get_name_function_ifs,var_defines) 
          => (name_arr',comment_arr',name_arr_der',comment_arr_der',n_vars',
              get_name_function_ifs'',define_str::define_str_der::var_defines)
           

  axiom generate_var_names_and_comments_states_and_derivatives(DAELow.VAR(cr,kind,dir,_,_,_,
				                                          _,value,indx,origname,_,dae_var_attr,comment,flow),
                                                               name_arr,
                                                               comment_arr,
                                                               name_arr_der,
                                                               comment_arr_der,
                                                               n_vars,
                                                               get_name_function_ifs,var_defines) 
          => (name_arr,comment_arr,name_arr_der,comment_arr_der,n_vars,
              get_name_function_ifs,var_defines)


end

(** relation: generate_array_define
 **
 ** Generates a define for an array variable.
 ** For an array s, each scalar value is given a define, e.g. 
 ** #define s[1,3] y[17], etc. But to also be able to treat the whole array
 ** as a value this relation generates a define to point to the first element
 ** of the array, e.g. #deine s &y[15].
 **
 **)

relation generate_array_define:(Exp.ComponentRef,DAE.InstDims,int,
				string(*vector name*)) 
	  => string =

	(* for cref with all indices 1*)
  rule	Exp.cref_is_first_array_elt(cr) => true &
	Exp.cref_strip_last_subs(cr) => cr' &
	Exp.print_component_ref_str(cr') => cr_name &	
	Util.modelica_string_to_c_str(cr_name) => cr_name' &
	int_string(indx) => indx_str &
	Util.string_append_list(["#define $",cr_name'," ",array,"[",indx_str,
				 "]\n"]) => res
	---------------------------------------
	generate_array_define(cr,_::_,indx,array) => res

  axiom	generate_array_define(_,_,_,_) => ""
end

(**relation change_name_for_derivative
 **author x02lucpo
 **
 **helper relation to generate_var_names_and_comments. 
 **Changes a string from "a.b.c" to "a.b.der(c)"
 **)
 relation change_name_for_derivative:(string) => string =
        

        (*catch the variable names a *)
        
  rule  Util.string_split_at_char(origname,#".") => [var_name] &
	Util.string_append_list(["der(",var_name,")"]) => der_var_name' 
        ------------------------------------
        change_name_for_derivative(origname) => der_var_name'

  rule  Util.string_split_at_char(origname,#".") => origname_lst &
         Util.list_last(origname_lst) => var_name &
         Util.list_strip_last(origname_lst) => origname_lst' &
	 Util.string_append_list(["der(",var_name,")"]) => der_var_name' &
         Util.string_delimit_list(origname_lst',".") => prefix &
         Util.string_append_list([prefix,".",der_var_name']) => ret_str 
        ------------------------------------
        change_name_for_derivative(origname) => ret_str

  rule  (* print "change_name_for_derivative FAILED"  *)
        --------------------------------
        change_name_for_derivative(origname') => origname'

end




(** relation: generate_empty_string
 **
 ** This relation adds citation chars to an empty string. Non empty strings
 ** are returned as is.
 **)	 
relation generate_empty_string: (string) => string =

  axiom	generate_empty_string("") => "\"\""

  axiom	generate_empty_string(s) => s 
end
	




(** relation: generate_input_function_code
 **
 **  Generates the input_function for all the variables
 **  that are INPUT and on top model
 **)
relation generate_input_function_code:(DAELow.DAELow) => (string,int) = 

  rule  DAELow.var_list(knvars) => knvars_lst &
        generate_input_function_code2(knvars_lst,0) => res1 &
        Util.list_select(res1,Util.is_not_empty_string) => res1' &
        list_length(res1') => lst_lenght &
        Util.string_delimit_list_no_empty(res1',"\n  ") => res1' &
        Util.string_append_list(["\n/*\n*/\nint input_function(double *in_x,double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n  ",
                                 res1',
                                 "return 0;\n",
                                 "\n}\n"]) => res
        -------------------------------------

        generate_input_function_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev)) => (res,lst_lenght)

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_input_function_code failed"])
	----------------------
	generate_input_function_code(_) => fail
end

(** relation: generate_input_function_code2
 **
 ** Helper relation to generate_input_function_code
 **)
relation generate_input_function_code2:(DAELow.Var list,int) => string list =

  axiom  generate_input_function_code2([],int) => []

  rule  DAELow.is_var_on_top_level_and_input(var) => true &
        int_string(i) => i_str &
        int_add(i,1) => i' &
        Exp.print_component_ref_str(cr) => cr_str &
        
        Util.string_append_list([cr_str," = in_x[",i_str,"];"]) => assign_str &
        generate_input_function_code2(rest,i') => res
        --------------------------
        generate_input_function_code2((var as DAELow.VAR(cr,_,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow))::rest,
                                       i)
          => assign_str::res

  rule generate_input_function_code2(rest,index) => res
        --------------------------------
        generate_input_function_code2(var::rest,
                                       index) => res

end

(** relation: generate_output_function_code
 **
 **  Generates the output_function for all the variables
 **  that are OUTPUT and on top model
 **)
relation generate_output_function_code:(DAELow.DAELow) => (string,int) = 

  rule  DAELow.var_list(knvars) => knvars_lst &
        DAELow.var_list(vars) => vars_lst &
        list_append(knvars_lst,vars_lst) => vars_lst' &
        generate_output_function_code2(vars_lst',0) => res1 &
        Util.list_select(res1,Util.is_not_empty_string) => res1' &
        list_length(res1') => lst_lenght &
        Util.string_delimit_list_no_empty(res1',"\n  ") => res1' &
        Util.string_append_list(["\n/*\n*/\nint output_function(double *out_x,double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n  ",
                                 res1',
                                 "return 0;\n",
                                 "\n}\n"]) => res
        -------------------------------------
        generate_output_function_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev)) 
          => (res,lst_lenght)

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_output_function_code failed"])
	-----------------------
	generate_output_function_code(_) => fail
end

(** relation: generate_output_function_code2
 **
 ** Helper relation to generate_output_function_code
 **)
relation generate_output_function_code2:(DAELow.Var list,int) => string list =

  axiom  generate_output_function_code2([],int) => []

  rule  DAELow.is_var_on_top_level_and_output(var) => true &
        int_string(i) => i_str &
        int_add(i,1) => i' &
        Exp.print_component_ref_str(cr) => cr_str &
        
        Util.string_append_list(["out_y[",i_str,"] =",cr_str,";"]) => assign_str &
        generate_output_function_code2(rest,i') => res
        --------------------------
        generate_output_function_code2((var as DAELow.VAR(cr,_,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow))::rest,
                                       i)
          => assign_str::res

  rule generate_output_function_code2(rest,index) => res
        --------------------------------
        generate_output_function_code2(var::rest,
                                       index) => res

end

(** relation: generate_initial_bound_parameter_code:
 **
 **
 ** This relation generates initial value code for bound parameters
 ** that depend on other parameters, eg. parameter Real n=1/m;
 **)
relation generate_initial_bound_parameter_code:(DAELow.DAELow) 
	  => (string(* code*)) =

  rule	Codegen.c_make_function("int","bound_parameters",[],["double *x",
							     "double *xd", 
							     "double *y",
							     "double *p",
							     "double *t",
							     "int nx",
							     "int ny",
							     "int np"])
	  => param_func &
	DAELow.var_list(knvars) => knvars_lst &
	generate_parameter_assignments(knvars_lst,0) 
	  => (param_assigns,_) &
	  add_memory_management(param_assigns) => param_assigns &
	  Codegen.c_add_statements(param_assigns,["return 0;"]) 
	  => param_assigns' &
	Codegen.c_merge_fns([param_func,param_assigns']) => cfunc &
	Codegen.c_print_functions_str([cfunc]) => str
	  ------------------------------
	generate_initial_bound_parameter_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev)) => str 

end

(** relation: generate_initial_value_code2
 **
 ** This relation generates initial value code according to the new 
 ** approach. It will be a replacement for generate_initial_value_code
 ** once it is stable.
 **)
relation generate_initial_value_code2:(DAELow.DAELow) => (string(* code*),
							  int (*n res*)) =

  rule	Codegen.c_make_function("int","initial_residual",[],["double *x",
							     "double *xd", 
							     "double *y",
							     "double *p",
							     "double *t",
							     "int nx",
							     "int ny",
							     "int np",
							     "double *res",
							     "int nr"])
	  => init_func' &
	
	DAELow.var_list(vars) => vars_lst &
	DAELow.var_list(knvars) => knvars_lst &
	DAELow.equation_list(eqns) => eqns_lst &
	DAELow.equation_list(se) => se_lst &
	DAELow.equation_list(ie) => ie_lst &
	
	(* equations from start values with fixed = true *)
	generate_initial_equations_from_start(vars_lst)  => ie2_lst &

	(* calculate total size*)
	list_length(eqns_lst) => n1 &
	list_length(se_lst) => n2 & 
	list_length(ie_lst) => n3 &
	list_length(ie2_lst) => n4 &
	Util.list_reduce([n1,n2,n3,n4],int_add) => n &
	int_string(n) => n_str &

	(* equations to residual form*)
	Util.list_map(eqns_lst,DAELow.equation_to_residual_form) => eqns_lst &
	Util.list_map(se_lst,DAELow.equation_to_residual_form) => se_lst &
	Util.list_map(ie_lst,DAELow.equation_to_residual_form) => ie_lst&
	Util.list_map(ie2_lst,DAELow.equation_to_residual_form) => ie2_lst &

	(* Generate statements for residual elements*)
	generate_initial_residual_eqn(eqns_lst,0) => (f1,cg_id) &
	generate_initial_residual_eqn(se_lst,cg_id) => (f2,cg_id) &
	generate_initial_residual_eqn(ie_lst,cg_id) => (f3,cg_id) &
	generate_initial_residual_eqn(ie2_lst,cg_id) => (f4,cg_id) &

	(* merge all parts toghether*)
	Codegen.c_merge_fns([init_func',f1,f2,f3,f4]) => cfunc &
	Codegen.c_add_variables(cfunc,["int i=0;"]) => cfunc &
	add_memory_management(cfunc) => cfunc &
	Codegen.c_add_cleanups(cfunc,["return 0;"]) => cfunc &

	Codegen.c_print_functions_str([cfunc]) => str
	------------------------------
	generate_initial_value_code2(dae as DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev))
	  => (str,n)


  axiom	generate_initial_value_code2(_) => ("/* generate_initial_value_code2 failed */",0)

end

(** relation generate_initial_residual_eqn
 **
 ** Helper relation to generate_initial_value_code2
 ** Generates code on residual form for a list of equations.
**)

relation generate_initial_residual_eqn: (DAELow.Equation list, 
					  int (*cg var_id*)) 
	  => (CFunction, 
	      int(*cg var_id*)) =

  axiom	generate_initial_residual_eqn([],cg_id) 
	  => (Codegen.c_empty_function,cg_id)

  rule	Codegen.generate_expression(e,cg_id,Codegen.SIMULATION) => (cfunc,var,cg_id) &
	Util.string_append_list(["res[i++] = ", var,";"]) => assign &
	Codegen.c_add_statements(cfunc,[assign]) => cfunc &
	generate_initial_residual_eqn(es,cg_id) => (cfunc2,cg_id) &
	Codegen.c_merge_fns([cfunc,cfunc2]) => cfn
	---------------------
	generate_initial_residual_eqn(DAELow.RESIDUAL_EQUATION(e)::es,cg_id)
	  => (cfn,cg_id)

  rule	generate_initial_residual_eqn(es,cg_id) => (cfn, cg_id) 
	---------------------
	generate_initial_residual_eqn(_::es,cg_id)
	  => (cfn,cg_id)
end

(** relation: generate_initial_value_code
 **
 ** This relation generates the code for solving the initial value problem.
 ** Information is gathered from the start and fixed attributes of variables
 ** and from initial equations.
 **)
relation generate_initial_value_code:(DAELow.DAELow) => string =

	(* Removed with initial equations. Did not work correct. And 
	 ** initial_function is deprecated anyway. *) 

	(* without initial equations *)
  rule  DAELow.var_list(vars) => vars_lst &
	DAELow.var_list(knvars) => knvars_lst &
	(*DAELow.equation_list(ie) => [] &*)
	generate_initial_equations_from_start(vars_lst) 
	  => initial_eqns2 &
	generate_initial_assignments_from_start(vars_lst,0) 
	  => (start_assigns, cg_id) &
	generate_parameter_assignments(knvars_lst,cg_id) => 
	(param_assigns,cg_id') &
	Codegen.c_make_function("int","initial_function",[],["double *x",
							       "double *xd", 
							       "double *y",
							       "double *p",
							       "double *t",
							       "int nx",
							       "int ny",
							       "int np"])
	  => init_func' &
	Codegen.c_add_cleanups(init_func', ["return 0;"]) => init_func &
        Codegen.c_merge_fns([init_func,start_assigns,param_assigns]) => res &
	Codegen.c_print_functions_str([res]) => str
        ----------------------------------
        generate_initial_value_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev)) => str
        
  rule  Codegen.c_make_function("int","initial_function",[],["double *x",
							     "double *xd", 
							     "double *y",
							     "double *p",
							     "double *t",
							     "int nx",
							     "int ny",
							     "int np"])
	  => init_func' &
	  Codegen.c_add_cleanups(init_func', ["return 0;"]) => init_func &
	Codegen.c_print_functions_str([init_func]) => str
        ----------------------------------
        generate_initial_value_code(_) => str        
end

(** relation: generate_parameter_assignments
 ** Generates code for the parameter settings that depends on other 
 ** parameters (as expressions). For instance, parameter Real m=2*n+1;
 ** Those are calculated once in the initial function.
 **)
relation generate_parameter_assignments: (DAELow.Var list,
					  int (* cg_id *)) => 
	(CFunction,
	 int (*cg var_id *))=

  axiom	generate_parameter_assignments ([],cg_id) => 
	(Codegen.c_empty_function,cg_id)


  rule	Exp.is_const(e) => false &
	Exp.print_component_ref_str(cr) => cr_str &
	Codegen.generate_expression(e,cg_id,Codegen.SIMULATION) 
	  => (exp_func,e_str,cg_id') &
	generate_parameter_assignments(vs,cg_id') => (func,cg_id'') &
	Util.string_append_list([cr_str," = ",e_str,";"]) => stmt &
	Codegen.c_add_statements(func,[stmt]) => func' &
	Codegen.c_merge_fns([exp_func,func']) => func''
	--------------------------
	generate_parameter_assignments(DAELow.VAR(cr,DAELow.PARAM,_,_,SOME(e),_,_,_,_,_,_,_,_,_)::vs,cg_id) 
	  => (func'',cg_id'')

  rule	generate_parameter_assignments(vs,cg_id) => (func,cg_id')
	--------------------------
	generate_parameter_assignments(_::vs,cg_id) => (func,cg_id')

end


(** relation: generate_initial_equations_from_start
 **
 ** This relation generates equations from the expressions in the start 
 ** attributes of variables. Only variables with a start value and 
 ** fixed set to true is converted by this relation. Fixed set to false
 ** means an initial guess, and is not considered here.
 **)
relation generate_initial_equations_from_start: DAELow.Var list 
	  => DAELow.Equation list =

  axiom	generate_initial_equations_from_start ([]) => []
	
	(* add equations for variables with fixed = true*)
  rule	DAELow.var_fixed(v) => true &
	generate_initial_equations_from_start(vars) => eqns 
	--------------------------
	generate_initial_equations_from_start((v as DAELow.VAR(cr,kind,_,_,_,_,_,SOME(startv),_,_,_,attr,_,_))::vars)
	  => DAELow.EQUATION(Exp.CREF(cr,Exp.OTHER),startv)::eqns

  rule	generate_initial_equations_from_start(vars) => eqns 
	--------------------------
	generate_initial_equations_from_start(_::vars)
	  => eqns
end

(** relation: generate_initial_assignments_from_start
 **
 **)
relation generate_initial_assignments_from_start: (DAELow.Var list,
						   int (* cg var_id*))
	  => (CFunction,
	      int (*cg var_id *))=

  axiom	generate_initial_assignments_from_start ([],cg_id) 
	  => (Codegen.c_empty_function,cg_id)
	

	  (*also add an assignment for variables that have non-constant
	   * expressions, e.g. parameter values, as start.
	   NOTE: such start attributes can then not be changed in the text
	   file, since the initial calc. will override those entries!
	   *)
  rule	Exp.is_const(startv) => false &
	generate_initial_assignments_from_start(vars,cg_id) => (func,cg_id') &
	Exp.print_component_ref_str(cr) => cr_str &
	Codegen.generate_expression(startv,cg_id',Codegen.SIMULATION) 
	  => (exp_func,startv_str,cg_id'') &
	Util.string_append_list([cr_str," = ",startv_str,";"]) => stmt &
	Codegen.c_add_statements(func,[stmt]) => func' &
	Codegen.c_merge_fns([exp_func,func']) => func''
	--------------------------
	generate_initial_assignments_from_start(DAELow.VAR(cr,kind,_,_,_,_,_,SOME(startv),_,_,_,attr,_,_)::vars,cg_id)
	  => (func'',cg_id'')

  rule	generate_initial_assignments_from_start(vars,cg_id) => (func,cg_id')
	--------------------------
	generate_initial_assignments_from_start(_::vars,cg_id)
	  => (func,cg_id')
end

(** relation generate_ode_code
 ** Outputs simulation code from a DAELow. 
 ** The state calculations are generated on explicit ode form: 
 ** \dot{x} := f(x,y,t)
 **)
relation generate_ode_code: (DAELow.DAELow, 
			     int list list, (* components*)
			     int vector, (* ass1 *)
			     int vector, (* ass2 *)
			     DAELow.IncidenceMatrix,
			     DAELow.IncidenceMatrixT,
			     Absyn.Path) => string =

  rule	Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_ode_blocks(dlow,ass1,ass2,blt_states,0) 
	  => (block_code,_, extra_funcs) &
	Codegen.c_make_function("int","functionODE",[],["double *x",
							"double *xd", 
							"double *y",
							"double *p",
							"int nx",
							"int ny", 
							"int np", 
							"double *t"]) => func' &
	add_memory_management(func') => func' &
	Codegen.c_add_cleanups(func', ["return 0;"]) => func &
	Codegen.c_merge_fns([func,block_code]) => func' &
	Codegen.c_print_functions_str([func']) => ode_func_str &
	Codegen.c_print_functions_str(extra_funcs) => extra_funcs_str &
	Util.string_append_list([extra_funcs_str,ode_func_str]) => res
	-------------------------------------------
	generate_ode_code(dlow,comps,ass1,ass2,m,mt,class) => res

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_ode_code failed"])
	-------------------------------
	generate_ode_code(dlow,comps,ass1,ass2,m,mt,class) => fail
end


(** relation: add_memory_management
 **
 ** This relation adds memory management code for a function.
 ** It consists of two calls, get_memory_state and restore_memory_state.
**)

relation add_memory_management: (CFunction) => CFunction =

  rule	Codegen.c_add_variables(cfunc,["state mem_state;"]) => cfunc &
	Codegen.c_prepend_statements(cfunc,["mem_state = get_memory_state();"])
	  => cfunc &
	  Codegen.c_add_cleanups(cfunc,["restore_memory_state(mem_state);"])
	  => cfunc
	----------------------------
	add_memory_management(cfunc) => cfunc
end

(** relation: build_when_condition_checks3
 ** Helper function to build_when_condition_checks
 **)
relation build_when_condition_checks3: (Exp.Exp list (* list of condition expressions*), 
					int (* when clause index *), 
					int (*next help var index*)) 
	  => (string, (int (* helpvar ind *) * 
		       Exp.Exp (* helpvar binding *) * 
		       int (* when clause index *) ) list ) =

  axiom	build_when_condition_checks3([],_,_) => ("",[])

  rule   int_string i => i_str &
	int_string helpVarIndex => helpVarIndexStr &
	let helpInfo = (helpVarIndex,e,i) &
	Util.string_append_list(["  if (edge(h[",helpVarIndexStr,"])) AddEvent(", i_str," + ng);\n"]) => res &
        helpVarIndex + 1 => helpVarIndex' &
         build_when_condition_checks3(el, i, helpVarIndex') => (resx, helpVarInfoList) &
	string_append(res, resx) => res' 
	----------------------------------------
	build_when_condition_checks3(e::el,i,helpVarIndex) => (res', helpInfo::helpVarInfoList)

  rule   print "-build_when_condition_checks3 failed.\n"
	----------------------------------------
	build_when_condition_checks3(_,_,_) => fail
end

(**
 ** This relation outputs checks for all when clauses that do not have equations but reinit statements
 **)
relation build_when_condition_checks2: (DAELow.WhenClause list, int (* whenClauseIndex *), int (*NextHelpVarIndex*) ) 
	  => (string,(int (* helpvar ind *) * 
		      Exp.Exp (* helpvar binding *) * 
		      int (* when clause index *) ) list ) =

  axiom  build_when_condition_checks2([],_,_) => ("",[])

	(* skip if there are no reinit statements *)
  rule	i + 1 => i' &
	build_when_condition_checks2(xs, i',nextHelpIndex) => (res,helpVarInfoList) 
	----------------------------------------
	build_when_condition_checks2((wc as DAELow.WHEN_CLAUSE(_,[]))::xs, i, nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule	i + 1 => i' &
	build_when_condition_checks2(xs, i',nextHelpIndex) => (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3(el, i, nextHelpIndex') => (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList
	----------------------------------------
	build_when_condition_checks2((wc as DAELow.WHEN_CLAUSE(Exp.ARRAY(_,_,el),_))::xs, i, nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule	i + 1 => i' &
	build_when_condition_checks2(xs, i',nextHelpIndex) => (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3([e], i,nextHelpIndex') => (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList
	----------------------------------------
	build_when_condition_checks2((wc as DAELow.WHEN_CLAUSE(e,_))::xs, i, nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule   print "-build_when_condition_checks2 failed.\n"
	----------------------------------------
	build_when_condition_checks2(_,_,_) => fail
end

(** relation: build_when_condition_checks4
 ** Helper function to build_when_condition_checks
 **)
relation build_when_condition_checks4: (int list, DAELow.Equation list, DAELow.WhenClause list, int (*NextHelpVarIndex*) ) 
	  => (string,(int (* helpvar ind *) * 
		      Exp.Exp (* helpvar binding *) * 
		      int (* when clause index *) ) list ) =

  axiom  build_when_condition_checks4([],_,_,_) => ("",[])

  rule	eqn - 1 => eqn' &
	list_nth(eqnl, eqn') => DAELow.WHEN_EQUATION(DAELow.WHEN_EQ(ind,cr,e)) &
	ind - 1 => ind' & 
	list_nth(whenClauseList,ind) => DAELow.WHEN_CLAUSE(Exp.ARRAY(_,_,el),_) &
	build_when_condition_checks4(rest,eqnl,whenClauseList,nextHelpIndex) =>  (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3(el,ind,nextHelpIndex') =>  (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList	
	--------------------------------------------------
	build_when_condition_checks4(eqn::rest,eqnl,whenClauseList,nextHelpIndex) 
	  => (res,helpVarInfoList)
	
  rule	eqn - 1 => eqn' &
	list_nth(eqnl, eqn') => DAELow.WHEN_EQUATION(DAELow.WHEN_EQ(ind,cr,e)) &
	ind - 1 => ind' & 
	list_nth(whenClauseList,ind) => DAELow.WHEN_CLAUSE(e,_) &
	build_when_condition_checks4(rest,eqnl,whenClauseList,nextHelpIndex) =>  (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3([e],ind,nextHelpIndex') =>  (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList	
	--------------------------------------------------
	build_when_condition_checks4(eqn::rest,eqnl,whenClauseList,nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule	build_when_condition_checks4(rest,eqnl,whenClauseList,nextHelpIndex) =>  (res,helpVarInfoList) 
	--------------------------------------------------
	build_when_condition_checks4(_::rest,eqnl,whenClauseList,nextHelpIndex) 
	  => (res,helpVarInfoList)
	
  rule   print "-build_when_condition_checks4 failed.\n"
	----------------------------------------
	build_when_condition_checks4(_,_,_,_) => fail

end


(** relation: add_missing_equations
 ** Helper function to build_when_condition_checks
 ** Given an integer and a list of integers completes the list with missing 
 ** integers upto the given integer.
 **)
relation add_missing_equations: (int, int list) => int list =

  axiom	add_missing_equations(0,lst) => lst

  rule	n - 1 => n' &
	add_missing_equations(n',lst) => lst' &
	Util.list_getmember(n,lst) => _
	--------------------------------------------------
	add_missing_equations(n,lst) => lst'

	(* missing equations must be added in correct order,
	 required in building when_condiriont_cheks4*)
  rule	n - 1 => n' &
	add_missing_equations(n',lst) => lst' &
	list_append(lst',[n]) => lst'' 
	--------------------------------------------------
	add_missing_equations(n,lst) => lst''
end


(** relation:  build_when_condition_checks
 **)
relation build_when_condition_checks: (DAELow.DAELow, int list list) 
	  => (string,(int (* helpvar ind *) * 
		      Exp.Exp (* helpvar binding *) * 
		      int (* when clause index  *) ) list ) =
	
  rule	generate_equation_order(blocks) => orderOfEquations &

	DAELow.equation_list(eqns) => eqnl &
         list_length(eqnl) => n &
	add_missing_equations(n, orderOfEquations) => orderOfEquations' &
	build_when_condition_checks4(orderOfEquations',eqnl, whenClauseList, 0) => (res1, helpVarInfo1) &
	list_length(helpVarInfo1) => n &
	build_when_condition_checks2(whenClauseList,0,n) => (res2,helpVarInfo2) &
	string_append(res1,res2) => res &
	list_append(helpVarInfo1,helpVarInfo2) => helpVarInfo
	----------------------------------------
	build_when_condition_checks(dlow as DAELow.DAELOW(_,_,eqns,_,_,_,_,DAELow.EVENT_INFO(whenClauseList,_)),blocks) => (res, helpVarInfo)
	
  rule   print "-build_when_condition_checks failed.\n"
	----------------------------------------
	build_when_condition_checks(_,_) => fail
end 



(** relation:  generate_event_checking_code
 ** 
 **)
relation generate_event_checking_code: (DAELow.DAELow, 
			     int list list, (* components*)
			     int vector, (* ass1 *)
			     int vector, (* ass2 *)
			     DAELow.IncidenceMatrix,
			     DAELow.IncidenceMatrixT,
			     Absyn.Path) 
	  => (string, (int (* helpvar ind *) * 
		       Exp.Exp (* helpvar binding *) * 
		       int (* when clause index *) ) list) =

  rule	use_zerocrossing => usezc &
	build_when_condition_checks(dlow,comps) => (check_code, helpVarInfo) & 
	Util.if(usezc,check_code,"") => check_code' &
	Util.string_append_list(["int checkForDiscreteVarChanges(double *t)\n{\n",
				 check_code', 
                                 "return 0;\n",
                                 "}\n"]) => res
	-------------------------------------------
	generate_event_checking_code(dlow,comps,ass1,ass2,m,mt,class) => (res, helpVarInfo)

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_event_checking_code failed"])
	----------------------------------------
	generate_event_checking_code(_,_,_,_,_,_,_) => fail
end

(** relation: generate_ode_blocks
 ** author: PA
 **
 ** Generates the simulation code for the ode code.
 ** 
 **)
relation generate_ode_blocks:(DAELow.DAELow, 
			      int vector, int vector, int list list,
			      int (* cg var_id*)) 
	  => (CFunction, (* block code*)
	      int (* cg var_id*),
	      CFunction list) (* extra functions code*) =

  axiom	generate_ode_blocks(_,_,_,[],cg_id) 
	  => (Codegen.c_empty_function,cg_id,[])

  rule	(* For system of equations *)
	generate_ode_system(dae,ass1,ass2,block,cg_id) => (s1,cg_id',f1)  &
	generate_ode_blocks(dae,ass1,ass2,blocks,cg_id') => (s2,cg_id'',f2) &
	Codegen.c_merge_fns([s1,s2]) => res &
	list_append(f1,f2) => res2
	-------------------------------------
	generate_ode_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks,cg_id) 
	  => (res,cg_id'',res2)
	
  rule	(* for single equations *)
	generate_ode_equation(dae,ass1,ass2,eqn,cg_id) => (s1,cg_id',f1) &
	generate_ode_blocks(dae,ass1,ass2,blocks,cg_id') => (s2,cg_id'',f2) &
	Codegen.c_merge_fns([s1,s2]) => res &
	list_append(f1,f2) => res2
	-------------------------------------
	generate_ode_blocks(dae,ass1,ass2,(block as [eqn])::blocks,cg_id) 
	  => (res,cg_id'',res2)

  rule	Debug.fprint("failtrace", "-generate_ode_blocks failed\n" )
	-----------------
	generate_ode_blocks(_,_,_,_,_) => fail
end

(** relation: generate_ode_system
 ** author: PA
 **
 ** Generates code for a subsystem of equations, both linear and non-linear 
 ** and mixed systems with both discrete and continuous variables.
 ** 
 ** A linear system can be written as A x = b
 ** where A is a n by n matrix and b is a vector of size n.
 ** Such a system can for instance be solved by gaussian elimination or by
 ** using numerical methods in LAPACK.
 **
 ** A non-linear system of equations is solved by the hybrd function. To solve
 ** the system a function that calculates the residuals of the equations must 
 ** be given. The hybrd function also needs to calcutate the dierivatives of 
 ** the equation system, i.e. the jacobian. Currently this is performed 
 ** numerically, but it could also be done analytically for systems which
 ** have an analytic jacobian.
 **
 ** A mixed system of equations contain both continuous and discrete time
 ** variables. Such system is solved by first guessing values on the 
 ** discrete time variables (e.g. based on previous values). Then the 
 ** continous time variables are solved. Finally, the discrete variables
 ** are checked to see if they fullfill the constraints of the system 
 ** equations. If not, a fixed point iteration over the possible values of 
 **  the discrete variables are made.
 ** Note that a mixed system can also be linear or non-linear.
 **)
relation generate_ode_system: (DAELow.DAELow, int vector, int vector, int list,
			       int (*cg var_id*)) 
	  => (CFunction, (* system code *)
	      int, (* cg var_id*)
	      CFunction list) = (* extra function code*) 

	(* Mixed system of equations*)
  rule	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	is_mixed_system(var_lst) => true &
	split_mixed_equations(eqn_lst,var_lst) => (cont_eqn,cont_var,
						   disc_eqn,disc_var) &
	DAELow.list_var(cont_var) => vars' &

	DAELow.list_equation(cont_eqn) => eqns' &
	let cont_subsystem_dae = DAELow.DAELOW(vars',knvars,eqns',se,ie,ae,al,ev) &
	DAELow.incidence_matrix(cont_subsystem_dae) => m &
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.transpose_matrix(m') => mt' &
	(* calculate jacobian. If constant, linear system of equations. Otherwise nonlinear *)
	DAELow.calculate_jacobian(vars',eqns',ae,m',mt') => jac &
	
	DAELow.analyze_jacobian(cont_subsystem_dae,jac) => jac_tp &
	DAELow.jacobian_type_str(jac_tp) => s & 
	generate_ode_system2(cont_subsystem_dae,jac,jac_tp,cg_id) 
	  => (s2,cg_id',f1) 
	------------------------
	generate_ode_system(daelow as DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev),ass1,ass2,block,cg_id) 
	  => (s2,cg_id',f1)

	  (* continuous system of equations *)
  rule	(** extract the variables and equations of the block.*)
	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	Util.list_map(var_lst,transform_x_to_xd) => var_lst' &  
	DAELow.list_var(var_lst') => vars' &
	DAELow.list_equation(eqn_lst) => eqns' &
	let subsystem_dae = DAELow.DAELOW(vars',knvars(* not used*),eqns',se,ie,ae,al,ev) &
	DAELow.incidence_matrix(subsystem_dae) => m &
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.transpose_matrix(m') => mt' &
	(* calculate jacobian. If constant, linear system of equations. Otherwise nonlinear *)
	
	DAELow.calculate_jacobian(vars',eqns',ae,m',mt') => jac &
	DAELow.analyze_jacobian(subsystem_dae,jac) => jac_tp &
(*	print "generating subsystem :" &
	DAELow.dump subsystem_dae &*)
	generate_ode_system2(subsystem_dae,jac,jac_tp,cg_id) => (s1,cg_id',f1) 
	-------------------------
	generate_ode_system(daelow as DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev),ass1,ass2,block,cg_id) 
	  => (s1,cg_id',f1)

  rule	Debug.fprint("failtrace", "-generate_ode_system failed\n" )
	-----------------
	generate_ode_system(_,_,_,_,_) => fail
end


(**relation: generate_mixed_header
 ** author: PA
 **
 ** Generates the header code for a mixed system.
 **)
relation generate_mixed_header:(DAELow.Equation list (* continous eqns*),
				DAELow.Var list (* continuous vars*),
				DAELow.Equation list (* discrete eqns*),
				DAELow.Var list (* discrete vars*), 
				int (* cg var_id *))
	=> (CFunction, int (* cg var_id *)) =

  rule	list_length(disc_vars) => len &
	int_string(len) => len_str &
	Util.string_append_list(["mixed_equation_system(",len_str,");"]) 
	  => stmt &
	generate_mixed_discrete_possible_values(cont_eqns,cont_vars,disc_eqns,disc_vars,cg_id) => (cfn1,cg_id') &
	Codegen.c_add_statements(Codegen.c_empty_function,[stmt]) => cfcn  &
	Codegen.c_merge_fns([cfcn,cfn1]) => cfcn'
	--------------------------
	generate_mixed_header(cont_eqns,cont_vars,disc_eqns,disc_vars,cg_id)
	  => (cfcn',cg_id')
end

(** relation 

**)
relation generate_mixed_discrete_possible_values:
	(DAELow.Equation list (* continous eqns*),
	 DAELow.Var list (* continuous vars*),
	 DAELow.Equation list (* discrete eqns*),
	 DAELow.Var list (* discrete vars*), 
	 int (* cg var_id *))
	  => (CFunction, int (* cg var_id *)) =
	  
  rule	mixed_collect_relations(cont_e,disc_e) => rels &
	generate_mixed_discrete_possible_values2(rels,disc_v,cg_id) 
	  => (values,value_dims) & 
	generate_mixed_discrete_combination_values(values) 
	  => values' &
	  Util.list_flatten(values') => values'' &
	Util.list_map(value_dims,int_string) => ss &
	Util.string_delimit_list(ss,", ") => s &
	Util.string_delimit_list(values'',", ") => s2 &
	list_length(disc_v) => disc_len &
	int_string(disc_len) => disc_len_str &
	list_length(values'') => values_len &
	int_string(values_len) => values_len_str & 
	Util.string_append_list(["double values[",values_len_str,"]={",s2,"};"]) 
	  => stmt1 &
	Util.string_append_list(["int value_dims[",disc_len_str,"]={",s,"};"]) 
	  => stmt2 &
	  Codegen.c_add_statements(Codegen.c_empty_function,
				   [stmt1,stmt2]) => cfn'
	---------------------------
	generate_mixed_discrete_possible_values(cont_e,cont_v,disc_e,disc_v,
						cg_id)
	  => (cfn',cg_id)

  rule	print "generate_mixed_discrete_possible_values failed\n" 
	--------------------
	generate_mixed_discrete_possible_values(_,_,_,_,_) => fail
end

(** relation: mixed_collect_relations
 ** author: PA
 ** 
 ** 
 **)

relation mixed_collect_relations: (DAELow.Equation list (* continous eqns*),
				   DAELow.Equation list (* discrete eqns*))
	=> (Exp.Exp list) =

  rule	mixed_collect_relations2(c_eqn) => l1 &
	mixed_collect_relations2(d_eqn) => l2 &
	list_append(l1,l2) => res
	----------------------
	mixed_collect_relations(c_eqn,d_eqn) => res
end

(** relation: mixed_collect_relations2
 ** author: PA
 **
 ** Helper relation to mixed_collect_relations.
 **)

relation mixed_collect_relations2:(DAELow.Equation list) => Exp.Exp list =

  axiom	mixed_collect_relations2([]) => []

  rule	Exp.get_relations(e1) => l1 &
	Exp.get_relations(e2) => l2 &
	mixed_collect_relations2(es) => l3 &
	Util.list_flatten([l1,l2,l3]) => res
	----------------------
	mixed_collect_relations2(DAELow.EQUATION(e1,e2)::es) => res

  rule	Exp.get_relations(e1) => l1 &
	mixed_collect_relations2(es) => l2 &
	list_append(l1,l2) => res
	----------------------
	mixed_collect_relations2(DAELow.SOLVED_EQUATION(cr,e1)::es) => res

  axiom	mixed_collect_relations2(_) => []

end

(** relation generate_mixed_discrete_combination_values
 ** author: PA
 **
 ** Generates all combinations of the values given as argument
**)

relation generate_mixed_discrete_combination_values:(string list list (* values *))
	  => (string list list) =

  axiom	generate_mixed_discrete_combination_values([value]) 
	  => [value]

  rule	generate_mixed_discrete_combination_values1(values) => values'(* &
	Util.list_strip_last(values') => values''*)
	--------------------------
	generate_mixed_discrete_combination_values(values) => values'
end

relation generate_mixed_discrete_combination_values1:(string list list (* values *))
	  => (string list list) =
	
  rule	Util.list_map(value,Util.list_create) => value' 
	---------------------------
	generate_mixed_discrete_combination_values1([value]) 
	  => value'

  rule	generate_mixed_discrete_combination_values1(values) => values' &
	generate_mixed_discrete_combination_values2(value,values') 
	  => values'' 
	---------------------------------------
	generate_mixed_discrete_combination_values1(value::values) 
	  => values''
end

(** relation generate_mixed_discrete_combination_values2
 ** author: PA
 ** 
 ** Helper relation to generate_mixed_discrete_combination_values.
 ** Insert a list of values producing all combinations with given list of list
 ** of values.
 **)
relation generate_mixed_discrete_combination_values2: (string list, 
						       string list list)
	  => string list list =

  axiom	generate_mixed_discrete_combination_values2([],lst) => []

	
  rule	Util.list_map_1(lst,Util.list_cons,s) => lst' &
	generate_mixed_discrete_combination_values2(ss,lst) => lst2 &
	list_append(lst',lst2) => res
	---------------------------------
	generate_mixed_discrete_combination_values2(s::ss,lst) => res

(*  rule	Util.list_list_map_1(lst,Util.list_make_2,s) => lst1 &
	Util.list_flatten(lst1) => lst1' &
	generate_mixed_discrete_combination_values2(ss,lst) => lst2 &
	list_append(lst1',lst2) => res
	---------------------------------
	generate_mixed_discrete_combination_values2(s::ss,lst) => res*)
end

(** relation: generate_mixed_discrete_possible_values2
 **
 ** Helper relation to generate_mixed_discrete_possible_values.
 **)

relation generate_mixed_discrete_possible_values2: (Exp.Exp list,
						    DAELow.Var list (* discrete vars*),
						    int (* cg var_id*))
	  => (string list list (* values *),
	      int list (* value dimension*))=

  axiom	generate_mixed_discrete_possible_values2(_,[],cg_id) 
	  => ([],[])

	  (* booleans, generate true (1.0) and false (0.0) *)
  rule	DAELow.var_type(v) => DAE.BOOL &
	generate_mixed_discrete_possible_values2(rels,vs,cg_id) 
	  => (values,dims) 
	  ----------------------------
	generate_mixed_discrete_possible_values2(rels,v::vs,cg_id)
	=> (["1.0","0.0"]::values,2::dims)

  rule	DAELow.var_type(v) => DAE.INT &
	Error.add_message(Error.INTERNAL_ERROR,["Mixed system of equations with dicrete variables of type Integer not supported. Try to rewrite using Boolean variables."])
	----------------------------
	generate_mixed_discrete_possible_values2(rels,v::vs,_)
	=> fail

end

(**relation: generate_mixed_footer
 ** author: PA
 **
 ** Generates the header code for a mixed system.
 **)
relation generate_mixed_footer:(DAELow.Equation list (* continous eqns*),
				DAELow.Var list (* continuous vars*),
				DAELow.Equation list (* discrete eqns*),
				DAELow.Var list (* discrete vars*), 
				int (* cg var_id *))
	=> (CFunction, int (* cg var_id *)) =

  rule	list_length(disc_vars) => len &
	int_string(len) => len_str &
	Util.string_append_list(["mixed_equation_system_end(",len_str,");"]) 
	  => stmt &
	Codegen.c_add_statements(Codegen.c_empty_function,[stmt]) => cfcn  
	--------------------------
	generate_mixed_footer(cont_eqns,cont_vars,disc_eqns,disc_vars,cg_id)
	  => (cfcn,cg_id)
end

(** relation: generate_mixed_system_store_discrete
 ** author: PA
 ** 
 ** Stores all discrete variables in discrite_loc variable.
 **)

relation generate_mixed_system_store_discrete: (DAELow.Var list,
						int, (* indx *)
					       int (* cg var_id*))
	=> (Codegen.CFunction, int (* cg var_id*), 
	    Codegen.CFunction list) =


  axiom	generate_mixed_system_store_discrete([],_,cg_id) 
	  => (Codegen.c_empty_function, cg_id, []) 

  rule	indx + 1 => indx' &
	generate_mixed_system_store_discrete(vs,indx',cg_id) 
	  => (cfn,cg_id',funcs) &
	DAELow.var_cref(v) => cr &
	int_string(indx) => indx_str &
	Exp.print_component_ref_str(cr) => cr_str &
	Util.string_append_list(["discrete_loc[",indx_str,"] = ",cr_str,";"]) => stmt &
	Codegen.c_add_statements(cfn,[stmt]) => cfn' 
	-----------------------------------
	generate_mixed_system_store_discrete(v::vs,indx,cg_id)
	  => (cfn',cg_id',funcs)

  rule	print "generate_mixed_system_store_discrete failed\n" 
	-------------------------------
	generate_mixed_system_store_discrete(_,_,cg_id)
	  => fail
end

(** relation: generate_mixed_system_discrete_part_check
 ** author: PA
 ** 
 ** Generates check of the discrete parts.
 **)

relation generate_mixed_system_discrete_part_check: (DAELow.Equation list,
					       DAELow.Var list,
					       int (* cg var_id*))
	=> (Codegen.CFunction, int (* cg var_id*), 
	    Codegen.CFunction list) =

  rule	generate_mixed_system_discrete_part_check2(eqn,var,0,cg_id) 
	  => (cfn,cg_id,funcs) &
	  list_length(eqn) => len &
	int_string(len) => len_str &
	Util.list_map(var,DAELow.var_cref) => crefs &
	Util.list_map(crefs,Exp.print_component_ref_str) => strs &
	Util.list_map_1r(strs,string_append,"&") => strs2 &
	Util.string_delimit_list(strs2,", ") => ptrs_str &
	Util.string_append_list(["double *loc_ptrs[",len_str,"]={",
				 ptrs_str,"};"]) 
	  => stmt1 &
	Util.string_append_list(["check_discrete_values(",len_str,");"])
 	  => stmt2 &
	  Codegen.c_add_statements(cfn,["{",stmt1,stmt2,"}"]) => cfn' 
	-------------------------
	generate_mixed_system_discrete_part_check(eqn,var,cg_id)
	  => (cfn',cg_id,funcs) 
end

relation generate_mixed_system_discrete_part_check2: (DAELow.Equation list,
						      DAELow.Var list,
						      int (* index*),
						      int (* cg var_id*))
	  => (Codegen.CFunction, int (* cg var_id*), 
	      Codegen.CFunction list) =

  axiom	generate_mixed_system_discrete_part_check2([],_,_,cg_id) 
	  => (Codegen.c_empty_function, cg_id, []) 

  rule	indx + 1 => indx' &
	generate_mixed_system_discrete_part_check2(eqns,vs,indx',cg_id) 
	  => (cfn,cg_id',funcs) &
	DAELow.var_cref(v) => cr &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	Codegen.generate_expression(expr,cg_id',Codegen.SIMULATION) => (exp_func,var,cg_id'') &
	int_string(indx) => indx_str &
	Exp.print_component_ref_str cr => cr_str &
	Util.string_append_list([cr_str," = ",var,";"]) => stmt &
	Util.string_append_list(["discrete_loc2[",indx_str,"] = ",cr_str,";"])
	  => stmt2 &
	Codegen.c_add_statements(exp_func,[stmt,stmt2]) => exp_func' &
	Codegen.c_merge_fns([exp_func',cfn]) => cfn' 
	-----------------------------------
	generate_mixed_system_discrete_part_check2(DAELow.EQUATION(e1,e2)::eqns,v::vs,indx,cg_id)
	  => (cfn',cg_id'',funcs)

  rule	print "generate_mixed_system_discrete_part_check2 failed\n" 
	-------------------------------
	generate_mixed_system_discrete_part_check2(_,_,_,cg_id)
	  => fail
end


(** relation: split_mixed_equations
 ** author: PA
 ** 
 ** Splits the equation of a mixed equation system into its continuous and
 ** discrete parts
 **)

relation split_mixed_equations: (DAELow.Equation list, DAELow.Var list) 
	  => (DAELow.Equation list, (* continous eqns*)
	      DAELow.Var list, (* continuous vars*)
	      DAELow.Equation list (* discrete eqns*),
	      DAELow.Var list (* discrete vars*)) =

  axiom	split_mixed_equations([],[]) => ([],[],[],[]) 

	(* discrete eqn*)
  rule	has_discrete_var([v]) => true  &
	split_mixed_equations(eqns,vs) => (cont_e,cont_v,disc_e,disc_v)
	-------------------------------------
	split_mixed_equations(eqn::eqns,v::vs) => (cont_e,cont_v,
						   eqn::disc_e,v::disc_v)
	
	(* continuous eqn*)
  rule	split_mixed_equations(eqns,vs) => (cont_e,cont_v,disc_e,disc_v)
	-------------------------------------
	split_mixed_equations(eqn::eqns,v::vs) => (eqn::cont_e,v::cont_v,
						   disc_e,disc_v)

  rule	print "split_mixed_equations failed\n" 
	-------------------
	split_mixed_equations(_,_) => fail
end

(** relation: is_mixed_system
 ** author: PA
 ** 
 ** Returns true if the list of variables if an equation system contains
 ** both discrete and continuous variables.
 **)
relation is_mixed_system: DAELow.Var list => bool =

  rule	has_discrete_var(vs) => true &
	has_continous_var(vs) => true
	---------------------
	is_mixed_system(vs) => true

  axiom	is_mixed_system(_) => false
end

(** relation: has_discrete_var
 ** author: PA
 **
 ** Helper relation to is_mixed_system. Returns true if var list contains 
 ** discrete time variable.
 **)

relation has_discrete_var: (DAELow.Var list) => bool =

  axiom	has_discrete_var(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true

  axiom	has_discrete_var(DAELow.VAR(cr,_,_,DAE.INT,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true
  axiom	has_discrete_var(DAELow.VAR(cr,_,_,DAE.BOOL,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true

  rule	has_discrete_var(vs) => res
	--------------------------------------
	has_discrete_var(v::vs) 
	  => res

  axiom	has_discrete_var([]) => false
end

(** relation: has_continous_var
 ** author: PA
 **
 ** Helper relation to is_mixed_system. Returns true if var list contains 
 ** discrete time variable.
 **)

relation has_continous_var: (DAELow.Var list) => bool =

  axiom	has_continous_var(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true

  axiom has_continous_var(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true

  axiom	has_continous_var(DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true

  axiom	has_continous_var(DAELow.VAR(cr,DAELow.DUMMY_STATE,_,_,_,_,_,_,_,_,_,_,_,_)::_) 
	  => true

  rule	has_continous_var(vs) => res
	--------------------------------------
	has_continous_var(v::vs) 
	  => res

  axiom	has_continous_var([]) => false
end



(** relation: generate_ode_system2
 ** author: PA
 ** 
 ** Generates the actual simulation code for the system of equation, once
 ** its jacobian and type has been given.
 **)
relation generate_ode_system2: (DAELow.DAELow, (* the daelow for the subsystem*)
				(int * int * DAELow.Equation) list option, (* jacobian *)
				DAELow.JacobianType,(* Type of jacobian, constant,etc.*)
				int) (* cg var_id *)
	=> (CFunction, (* system code *)
	    int, (* cg var_id*)
	    CFunction list) =  (* extra functions code *)


	(* A single array equation*)

  rule	single_array_equation(dae) &
	generate_single_array_eqn_code(dae,jac,cg_id) => (s1,cg_id',f1)
	-----------------------
	generate_ode_system2(dae,jac,jac_tp,cg_id) => (s1,cg_id',f1)

	  (* constant jacobians. Linear system of equations (A x = b) where
	   A and b are constants. *)
  rule	DAELow.equation_size(eqn) => eqn_size &
	(* NOTE: Not impl. yet, use time_varying... *)
	generate_ode_system2(d,SOME(jac),DAELow.JAC_TIME_VARYING,cg_id) 
	  => (s1,cg_id',f1)
	------------------------------
 	generate_ode_system2(d as DAELow.DAELOW(v,kv,eqn,_,_,_,_,_),SOME(jac),
			     DAELow.JAC_CONSTANT,cg_id) => (s1,cg_id',f1)
	

	(* Time varying jacobian. Linear system of equations that needs to 
	 * be solved during runtime. *)
  rule	DAELow.equation_size(eqn) => eqn_size &
	tick() => unique_id &
	generate_ode_system2_declaration(eqn_size,unique_id,cg_id) 
	  => (s1,cg_id1) &
	generate_ode_system2_populate_Ab(jac,v,eqn,unique_id,cg_id1) 
	  => (s2,cg_id2) &
	generate_ode_system2_solve_call(eqn_size,unique_id,cg_id2) 
	  => (s3,cg_id3) &
	generate_ode_system2_collect_results(v,unique_id,cg_id3) 
	  => (s4,cg_id4) &
	Codegen.c_merge_fns([s1,s2,s3,s4]) => s
	--------------------
	generate_ode_system2(d as DAELow.DAELOW(v,kv,eqn,_,_,_,_,_),SOME(jac),DAELow.JAC_TIME_VARYING,cg_id) => (s,cg_id4,[])

	(* Time varying nonlinear jacobian. Non-linear system of equations*)
  rule	DAELow.equation_list(eqn) => eqn_lst &
	DAELow.var_list(v) => var_lst &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	generate_ode_system2_nonlinear_residuals(crefs,eqn_lst,cg_id) 
	  => (s1,cg_id',f1) 
	------------------------------------------------------
	generate_ode_system2(DAELow.DAELOW(v,kv,eqn,_,_,_,_,_),SOME(jac),DAELow.JAC_NONLINEAR,cg_id) 
	  => (s1,cg_id',f1)
	  (* no analythic jacobian available. Generate non-linear system *)
  rule	DAELow.equation_list(eqn) => eqn_lst &
	DAELow.var_list(v) => var_lst &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	generate_ode_system2_nonlinear_residuals(crefs,eqn_lst,cg_id) 
	  => (s1,cg_id',f1)  
	---------
	generate_ode_system2(DAELow.DAELOW(v,kv,eqn,_,_,_,_,_),NONE,
			     DAELow.JAC_NO_ANALYTIC,cg_id) 
	  => (s1,cg_id',f1)

  rule	Debug.fprint("failtrace", "-generate_ode_system2 failed \n")
	-------------------------
	generate_ode_system2(_,_,_,_) => fail
end

(** relation: generate_single_array_eqn_code
 ** author: PA
 **
 ** Generates code for a system consisting of a  single array equation.
 **)
relation generate_single_array_eqn_code: (DAELow.DAELow, 
					  (int * int * DAELow.Equation) list option,
					  int (* cg var_id*)) 
	  => (CFunction (* eqn code*),
	      int (* cg var_id*),
	      CFunction list (* extra functions*) ) =
	
  rule	DAELow.equation_list(eqns) => DAELow.ARRAY_EQUATION(indx,_)::_ &
	array_nth(ae,indx) => DAELow.MULTIDIM_EQUATION(ds,e1,e2) &
	DAELow.var_list(vars) => (DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,_,_,_)::_) &
	Exp.cref_strip_last_subs(origname) => cr' &
	generate_single_array_eqn_code2(cr',cr',e1,e2,cg_id) => (s1,cg_id',f1)
	---------------------
	generate_single_array_eqn_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev),jac,cg_id)
	=> (s1,cg_id',f1)
	
  rule	Error.add_message(Error.INTERNAL_ERROR,["array equations currently only supported on form v = functioncall(...)"])
	-----------------------
	generate_single_array_eqn_code(_,_,_) => fail
end

(** relation generate_single_array_eqn_code2
 ** author: PA
 **
 ** Helper relation to generate_single_array_eqn_code. 
 ** Currenlty solves only solved equation on form v = foo(...)
 **)
relation generate_single_array_eqn_code2:(Exp.ComponentRef, (* origname*)
					  Exp.ComponentRef, (* firsteltname*)
					  Exp.Exp (* lhs*),
					  Exp.Exp (* rhs*),
					  int (*cg var_id *)) 
	  => (CFunction, int(*cg var_id*) ,CFunction list) =

  rule	Exp.cref_equal(cr,cr2) => true &
	Exp.print_component_ref_str(eltcr) => s1 &
 	Codegen.generate_expression(e2,cg_id,Codegen.SIMULATION) 
	  => (cfunc,s2,cg_id') &
	Util.string_append_list(["copy_real_array_data_mem(&",s2,", &$",s1,");"]) => stmt &
	Codegen.c_add_statements(cfunc,[stmt]) => func'
	----------------------------
	generate_single_array_eqn_code2(cr,eltcr,e1 as Exp.CREF(cr2,_),e2,cg_id) 
	  => (func',cg_id',[])

  rule	Exp.cref_equal(cr,cr2) => true &
	Exp.print_component_ref_str(eltcr) => s1 &
	Codegen.generate_expression(e1,cg_id,Codegen.SIMULATION)
 	  => (cfunc,s2,cg_id') &
	Util.string_append_list(["copy_real_array_data_mem(&",s1,", &$",s2,");"]) => stmt &
	Codegen.c_add_statements(cfunc,[stmt]) => func'
	----------------------------
	generate_single_array_eqn_code2(cr,eltcr,e1 ,e2 as Exp.CREF(cr2,_),cg_id) 
	  => (func',cg_id',[])

	  (* array of crefs, {v[1],v[2],...v[n]} *)
  rule	get_vectorized_cref_from_exp(e2) => cr2 & 
	Exp.print_component_ref_str(eltcr) => s1 &
	Codegen.generate_expression(e1,cg_id,Codegen.SIMULATION)
 	  => (cfunc,s2,cg_id') &
	Util.string_append_list(["copy_real_array_data_mem(&",s1,", &$",s2,");"]) => stmt &
	Codegen.c_add_statements(cfunc,[stmt]) => func'
	----------------------------
	generate_single_array_eqn_code2(cr,eltcr,e1 ,e2, cg_id) 
	  => (func',cg_id',[])

	  (* array of crefs, {v[1],v[2],...v[n]} *)
  rule	get_vectorized_cref_from_exp(e1) => cr2 & 
	Exp.print_component_ref_str(eltcr) => s1 &
	Codegen.generate_expression(e2,cg_id,Codegen.SIMULATION)
 	  => (cfunc,s2,cg_id') &
	Util.string_append_list(["copy_real_array_data_mem(&",s2,", &$",s1,");"]) => stmt &
	Codegen.c_add_statements(cfunc,[stmt]) => func'
	----------------------------
	generate_single_array_eqn_code2(cr,eltcr,e1 ,e2,cg_id ) 
	  => (func',cg_id',[])

  rule	Exp.print_exp_str(e1) => s1 &
	Exp.print_exp_str(e2) => s2 &
	Exp.print_component_ref_str(cr) => s3 &
	Exp.print_component_ref_str(eltcr) => s4 &
	Util.string_append_list(["generate_single_array_eqn_code2(",s3
				 ,", ",s4,", ",s1,", ",s2,") failed\n"]) => s &
	print s 
	-------------------------------
	generate_single_array_eqn_code2(cr,eltcr,e1,e2,_) => fail
end

(** relation: get_vectorized_cref_from_exp 
 ** author: PA
 **
 ** Returns the component ref v if expression is on form
 **  {v[1],v[2],...v[n]}  for some n.
 ** TODO: implement for 2D as well.
 **)
relation get_vectorized_cref_from_exp: Exp.Exp => Exp.ComponentRef =

  rule	Util.list_map(expl,Exp.exp_cref) => (crefs as cr::_) & 
	Util.list_map(crefs,Exp.cref_strip_last_subs_stringified) => crefs' &
	Util.list_map(crefs', Exp.print_component_ref_str) => strs &
	Util.string_delimit_list(strs,",") => s &
	Util.list_reduce(crefs',Exp.cref_equal_return) => _
	--------------------------------
	get_vectorized_cref_from_exp(Exp.ARRAY(_,_,expl)) => cr

end

(** relation: single_array_equation
 ** author: PA
 ** 
 ** Checks if a dae (subsystem) consists of a single array equation.
 **)
relation single_array_equation: DAELow.DAELow => () =

  rule	DAELow.equation_list(eqnarr) => eqn_lst &
	single_array_equation2(eqn_lst) 
	--------------------------
	single_array_equation(DAELow.DAELOW(vars,_,eqnarr,_,_,_,_,_)) => ()
end

relation single_array_equation2:(DAELow.Equation list) => () = 

  axiom	single_array_equation2([]) => ()

  rule	single_array_equation2(res) 
	-------------------------
	single_array_equation2(DAELow.ARRAY_EQUATION(_,_)::res) => ()

end

(** relation: generate_ode_system2_nonlinear_residuals
 ** author: PA
 **
 ** Generates residual statements for nonlinear equation systems.
 **)
relation generate_ode_system2_nonlinear_residuals:  (Exp.ComponentRef list,
						     DAELow.Equation list,
						     int) (* cg var_id*)
	  => (CFunction, (* solve code *)
	      int, (* cg var_id *)
	      CFunction list) = (* extra functions: residual func*)

  rule	make_residual_replacements(crs) => repl &
	generate_ode_system2_nonlinear_residuals2(eqns,0,repl,cg_id) => (s1,cg_id1) &
	tick() => id &
	int_string(id) => str_id &
	list_length(eqns) => eqn_size & int_string(eqn_size) => size_str &
	string_append("residualFunc",str_id) => func_name &
	Codegen.c_make_function("void",func_name,[],["int *n",
						    "double* xloc",
						    "double* res",
						    "int* iflag"]
				)=> res_func &
	Codegen.c_merge_fns([res_func,s1]) => func &

	generate_ode_system2_nonlinear_setvector(crs,0,cg_id1) 
	  => (f2,cg_id2) &
	generate_ode_system2_nonlinear_call(str_id,cg_id2) 
	  => (f3,cg_id3) &
	generate_ode_system2_nonlinear_store_results(crs,0,cg_id3) 
	  => (f4,cg_id4) &
	Util.string_append_list(["start_nonlinear_system(",size_str,");"]) 
	  => start_stmt &
	let end_stmt = "end_nonlinear_system();" &
	Codegen.c_add_statements(Codegen.c_empty_function,[start_stmt]) => f1 &
	Codegen.c_add_statements(Codegen.c_empty_function,[end_stmt]) => f5 &
	Codegen.c_merge_fns([f1,f2,f3,f4,f5]) => res
	-----------------------------------------------------------
	generate_ode_system2_nonlinear_residuals(crs,eqns,cg_id) 
	  => (res,cg_id4,[func])

  rule	print "generate_ode_system2_nonlinear_residuals failed\n" 
	-----------------------------------------------------------
	generate_ode_system2_nonlinear_residuals(crs,eqns,cg_id) 
	  => fail
end

(** relation: make_residual_replacements
 ** author: PA
 **
 ** This relation makes replacement rules for variables occuring in a 
 ** nonlinear equation system. They should be replaced by x[index], i.e.
 ** an unique index in the x vector.
 **)
relation make_residual_replacements:(Exp.ComponentRef list) => 
	VarTransform.VariableReplacements =

  rule	VarTransform.empty_replacements() => repl &
	make_residual_replacements2(repl,crefs,0) => repl'
	---------------------
	make_residual_replacements(crefs) => repl'
end

(** relation make_residual_replacements2
 ** author: PA
 ** 
 ** Helper relation to make_residual_replacements
 **)
relation make_residual_replacements2:(VarTransform.VariableReplacements,
				      Exp.ComponentRef list,
				      int) => 
	VarTransform.VariableReplacements =

  axiom	make_residual_replacements2(repl,[],_) => repl

  rule	int_string(pos) => pstr &
	Util.string_append_list(["xloc[",pstr,"]"]) => str &
	VarTransform.add_replacement(repl,cr,Exp.CREF_IDENT(str,[])) => repl' &
	pos + 1 => pos' &
	make_residual_replacements2(repl',crs,pos') => repl''
	------------------------------
	make_residual_replacements2(repl,cr::crs,pos) => repl''
end


(** relation: generate_ode_system2_nonlinear_setvector
 ** author: PA
 **
 ** Generates code for setting the values for the x vector when solving 
 ** nonlinear equation systems.
 **)
relation generate_ode_system2_nonlinear_setvector: (Exp.ComponentRef list,
						    int (* index iterator *),
						    int (* cg var_id*)) 
	  => (CFunction,int (*cg var_id*)) =

  axiom	generate_ode_system2_nonlinear_setvector([],_,cg_id) 
	  => (Codegen.c_empty_function,cg_id)

  rule  Exp.print_component_ref_str(cr) => cr_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_setvector(crs,indx',cg_id) 
	  => (func,cg_id') &
	  Util.string_append_list(["nls_x[",indx_str,"] = ",cr_str,";"])
	  => stmt &
	  Codegen.c_add_statements(func,[stmt]) => func'
	----------------------------------------
	generate_ode_system2_nonlinear_setvector(cr::crs,indx,cg_id) 
	  => (func',cg_id')
end

(** relation: generate_ode_system2_nonlinear_call
 ** author: PA
 **
 ** Generates the call to the nonlinear equation solver.
 **)
relation generate_ode_system2_nonlinear_call: (string (* residual func id *),
					       int (* cg var_id*)) 
	  => (CFunction,int (* cg var_id*)) =
  rule	Util.string_append_list(["hybrd_(residualFunc",func_id,
				 ",&n, nls_x,nls_fvec,&xtol,&maxfev,&ml,&mu,",
				 "&epsfcn,\n",TAB,TAB,"nls_diag,&mode,&factor,&nprint,",
				 "&info,&nfev,nls_fjac,&ldfjac,\n",TAB,TAB,"nls_r,",
				 "&lr,nls_qtf,nls_wa1,nls_wa2,nls_wa3,",
				 "nls_wa4);\n",
				 TAB,"if (info == 0) {\n",
				 TAB,TAB,"printf(\"improper ",
				 "input parameters to nonlinear eq. syst.\\n\");\n",
				 TAB, "}\n",
				 TAB,"if (info >= 2 && info <= 5) {\n",
				 TAB,TAB,"printf(\"error solving nonlinear",
				 " system.\\n\");\n",
				 TAB,"}"
				 ]) => stmt &
	Codegen.c_add_statements(Codegen.c_empty_function,
				 [stmt]) => func
	---------------------------
	generate_ode_system2_nonlinear_call(func_id,cg_id) => (func,cg_id)
end


(** relation: generate_ode_system2_nonlinear_store_results
 ** author: PA
 ** 
 ** Generates the storing of the results of the solution to a nonlinear equation
 ** system.
 **)    
relation generate_ode_system2_nonlinear_store_results: (Exp.ComponentRef list,
							int (*indx*),
							int (*cg var_id*))
	=> (CFunction,int (* cg var_id*)) =
  axiom	generate_ode_system2_nonlinear_store_results([],_,cg_id) 
	  => (Codegen.c_empty_function,cg_id)

  rule	Exp.print_component_ref_str(cr) => cr_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_store_results(crs,indx',cg_id) 
	      => (func,cg_id') &
	Util.string_append_list([cr_str," = nls_x[",indx_str,"];"]) 
	  => stmt &
	  Codegen.c_add_statements(func,[stmt]) => func'
	--------------------------------
	generate_ode_system2_nonlinear_store_results(cr::crs,indx,cg_id) 
	      =>  (func',cg_id')
end


(** relation: generate_ode_system2_nonlinear_residuals2
 ** author: PA
 ** 
 ** Helper relation to generate_ode_system2_nonlinear_residuals
 **)
relation generate_ode_system2_nonlinear_residuals2: (DAELow.Equation list, 
						     int, (* index iterator*) 
						     VarTransform.VariableReplacements,
						     int (* cg var_id*))
	  => (CFunction,int (* cg var_id*)) =

  axiom	generate_ode_system2_nonlinear_residuals2([],_,_,cg_id) 
	  => (Codegen.c_empty_function,cg_id)

  rule	Exp.typeof(e1) => tp &
	let res_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	Exp.simplify(res_exp) => res_exp' &
	VarTransform.replace_exp(res_exp',repl) => res_exp'' &
	Codegen.generate_expression(res_exp'',cg_id,Codegen.SIMULATION) => (exp_func,var,cg_id') &
     	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_residuals2(rest,indx',repl,cg_id') 
	      => (cfunc,cg_id'') &
	Util.string_append_list([TAB,"res[",indx_str,"] = ",var, ";"])
	  => stmt &
	Codegen.c_add_statements(exp_func,[stmt]) => exp_func' &
	Codegen.c_merge_fns([exp_func',cfunc]) => cfunc'      
	-----------------------
	generate_ode_system2_nonlinear_residuals2(DAELow.EQUATION(e1,e2)::rest,indx,repl,cg_id) 
	  => (cfunc',cg_id'')

  rule	Exp.simplify(e) => res_exp' &
	VarTransform.replace_exp(res_exp',repl) => res_exp'' &
	Codegen.generate_expression(res_exp'',cg_id,Codegen.SIMULATION) => (exp_func,var,cg_id') &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_residuals2(rest,indx',repl,cg_id') 
	      => (cfunc,cg_id'') &
	Util.string_append_list([TAB,"res[",indx_str,"] = ",var, ";"])
	  => stmt &
	  Codegen.c_add_statements(exp_func,[stmt]) => exp_func' &
	Codegen.c_merge_fns([exp_func',cfunc]) => cfunc'      
	-----------------------
	generate_ode_system2_nonlinear_residuals2(DAELow.RESIDUAL_EQUATION(e)::rest,indx,repl,cg_id) 
	  => (cfunc',cg_id'')
end


(** relation: generate_ode_system2_declaration
 ** author: PA
 ** 
 ** Generates code for the declaration of A and b when
 ** solving linear systems of equations.
 ** inputs: (size: int, unique_id: int)
 ** outputs: (fcn : CFunction)
 **)
relation generate_ode_system2_declaration: (int (*size*)
					    ,int (* unique_id*)
					    ,int(* cg var_id*)) => 
	      (CFunction, int (*cg var_id*)) =

  rule	int_string(size) => size_str &
	int_string(unique_id) => id_str &
	Util.string_append_list(["declare_matrix(A",id_str,",",size_str,",",
				 size_str,");"]) => stmt1 &
 	Util.string_append_list(["declare_vector(b",id_str,",",size_str,");"])
	  => stmt2 &
	  Codegen.c_add_variables(Codegen.c_empty_function,[stmt1,stmt2]) 
	  => res
	-----------------------
	generate_ode_system2_declaration(size,unique_id,cg_id)  => (res,cg_id)


  rule	Debug.fprint("failtrace","-generate_ode_system2_declaration failed\n")
	-----------------------
	generate_ode_system2_declaration(size,unique_id,cg_id)  => fail
end

(** relation: generate_ode_system2_populate_Ab
 ** author: PA
 ** 
 ** Generates code for the population of A and b when
 ** solving linear system of equations.
 ** inputs: ( jac : (int * int * DAELow.Equation) list, 
 **           vars: DAELow.Variables,
 ** 	      eqns: DAELow.EquationArray 
 **	      unique_id : int)
 ** outputs: cfn : CFunction
 **)         
relation generate_ode_system2_populate_Ab:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray,
					   int (*unique_id*),
					   int(* cg var_id*))
	  => (CFunction, int(*cg var_id*)) =

  rule	generate_ode_system2_populate_A(jac,vars,eqns,unique_id,cg_id) 
	      => (s1,cg_id1) &
	generate_ode_system2_populate_b(jac,vars,eqns,unique_id,cg_id1) 
	      => (s2,cg_id2) &
	Codegen.c_merge_fns([s1,s2]) => res
	---------------------------
	generate_ode_system2_populate_Ab(jac,vars,eqns,unique_id,cg_id) 
	      => (res,cg_id2)

  rule	Debug.fprint("failtrace","-generate_ode_system2_populate_Ab failed\n")
	---------------------------
	generate_ode_system2_populate_Ab(jac,vars,eqns,unique_id,cg_id) 
	      => fail
end

(** relation: generate_ode_system2_populate_A
 ** author: PA
 ** 
 ** Generates code for the population of A 
 ** solving linear system of equations.
 ** inputs ( jac : (int * int * DAELow.Equation) list, 
 **           vars: DAELow.Variables,
 ** 	      eqns: DAELow.EquationArray 
 **	      unique_id : int
 **	      cg_var_id : int)
 ** outputs: (cfn : CFunction 
 **	      cg_var_id : int)
 **)
relation generate_ode_system2_populate_A:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray,
					  int, 
					  int)
	  => (CFunction,int) =


  rule	DAELow.equation_size(eqns) => n_rows &
	generate_ode_system2_populate_A2(jac,vars,eqns,n_rows,unique_id,cg_id)
	      => (res,cg_id)
	-----------------------------
	generate_ode_system2_populate_A(jac,vars,eqns,unique_id,cg_id) 
	  => (res,cg_id)
  rule	Debug.fprint("failtrace","-generate_ode_system2_populate_A failed\n") 
	-----------------------------
	generate_ode_system2_populate_A(jac,vars,eqns,unique_id,cg_id) 
	  => fail

end

(** relation: generate_ode_system2_populate_A2
 ** author: PA
 **
 ** Helper relation to generate_ode_system2_populate_A
 **)
relation generate_ode_system2_populate_A2:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray,
					   int,(* n rows *)
					   int, (* unique_id*)
					   int) (* cg var_id*)
	  => (CFunction,int (*cg var_id*)) =

  axiom	generate_ode_system2_populate_A2([],_,_,_,unique_id,cg_id)
	      => (Codegen.c_empty_function,cg_id)

  rule  r - 1 => r' &
	c - 1 => c' &
	int_string(r') => rs &
	int_string(c') => rc &
	int_string(n_rows) => n_rows_str &
	int_string(unique_id) => id_str &
        Codegen.generate_expression(exp,cg_id,Codegen.SIMULATION) => (cfunc1,var,cg_id') &

	generate_ode_system2_populate_A(jac,vars,eqn,unique_id,cg_id') 
	  => (cfunc,cg_id'') &
	Util.string_append_list(["set_matrix_elt(A",id_str,",",rs,", ",rc,", ",
				 n_rows_str,", ",var,");"]) => stmt &
	Codegen.c_add_statements(cfunc1,[stmt]) => cfunc1' &
	Codegen.c_merge_fns([cfunc1',cfunc]) => cfunc'
	--------------------------------------------------------------
	generate_ode_system2_populate_A2((r,c,DAELow.RESIDUAL_EQUATION(exp))::jac,vars,eqn,n_rows,unique_id,cg_id) 
	  => (cfunc',cg_id'')

  rule	Debug.fprint("failtrace","-generate_ode_system2_populate_A2 failed\n") 
	--------------------------------------------------------------
	generate_ode_system2_populate_A2(_,_,_,_,_,_) 
	  => fail
end

(** relation: generate_ode_system2_populate_b
 ** author: PA
 **
 ** Generates code for the population of A 
 ** solving linear system of equations.
 **)
relation generate_ode_system2_populate_b: ((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray,
					   int, (* unique_id*)
					   int (* cg var_id*))
	  => (CFunction, int (*cg var_id*)) =

  rule	DAELow.equation_list(eqns) => eqn_lst &
	generate_ode_system2_populate_b2(eqn_lst,vars,0,unique_id,cg_id) 
	  => (res,cg_id')
	--------------------------------
	generate_ode_system2_populate_b(jac,vars,eqns,unique_id,cg_id) 
	  => (res,cg_id')

  rule	Debug.fprint("failtrace","-generate_ode_system2_populate_b failed\n")
	-------------------------------
	generate_ode_system2_populate_b(jac,vars,eqns,unique_id,cg_id) 
	  => fail
	
end

(** relation: generate_ode_system2_populate_b2
 ** author: PA
 ** Helper relation to generate_ode_system2_populate_b
 **)
relation generate_ode_system2_populate_b2: (DAELow.Equation list,
					    DAELow.Variables,
					    int (* index iterator*),
					    int (*unique_id*),
					    int (* cg var_id*))
	  => (CFunction, int (* cg var_id*)) =

  axiom	generate_ode_system2_populate_b2([],_,_,_,cg_id) => 
	(Codegen.c_empty_function,cg_id)


  rule	Exp.typeof(e1) => tp &
	let new_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	DAELow.get_eqnsys_rhs_exp(new_exp,v) => rhs_exp &
	let rhs_exp' = Exp.UNARY(Exp.UMINUS(tp),rhs_exp) &
	Exp.simplify(rhs_exp') => rhs_exp'' &
	Codegen.generate_expression(rhs_exp'',cg_id,Codegen.SIMULATION) => (exp_func,var,cg_id') &
	int_string(index) => index_str &
	int_string(unique_id) => id_str &
	index + 1 => index'  &
	generate_ode_system2_populate_b2(rest,v,index',unique_id,cg_id') 
	  => (cfunc,cg_id'') &
	Util.string_append_list(["set_vector_elt(b",id_str,",",index_str,
				 ", ",var, ");"]) => stmt &
	Codegen.c_add_statements(exp_func,[stmt]) => exp_func' &
	Codegen.c_merge_fns([exp_func',cfunc]) => cfunc' 
	--------------------------------------------------------
	generate_ode_system2_populate_b2(DAELow.EQUATION(e1,e2)::rest,v,index,unique_id,cg_id) 
	  => (cfunc',cg_id'')

  rule	DAELow.get_eqnsys_rhs_exp(res_exp,v) => rhs_exp &
	Exp.simplify(rhs_exp) => rhs_exp' &
	Codegen.generate_expression(rhs_exp',cg_id,Codegen.SIMULATION) => (exp_func,var,cg_id') &
	int_string(index) => index_str &
	int_string(unique_id) => id_str &
	index + 1 => index'  &
	generate_ode_system2_populate_b2(rest,v,index',unique_id,cg_id') 
	  => (cfunc,cg_id'') &
	Util.string_append_list(["set_vector_elt(b",id_str,",",index_str,
				 ", ",var, ");"]) => stmt &
	Codegen.c_add_statements(exp_func,[stmt]) => exp_func' &
	Codegen.c_merge_fns([exp_func',cfunc]) => cfunc' 
	--------------------------------------------------------
	generate_ode_system2_populate_b2(DAELow.RESIDUAL_EQUATION(res_exp)::rest,v,index,unique_id,cg_id) 
	  => (cfunc',cg_id'')

  rule	Debug.fprint("failtrace","generate_ode_system2_populate_b2 failed\n")
	----------------------------
	generate_ode_system2_populate_b2(DAELow.EQUATION(e1,e2)::rest,v,index,unique_id,cg_id) 
	  => fail
end


(** relation: generate_ode_system2_solve_call
 ** author: PA
 ** 
 ** Generates code for the call, including setup, for solving
 ** a linear system of equations.
 **)
relation generate_ode_system2_solve_call:(int (* size of system *),
					  int (* unique_id*),
					  int (* cg var_id*)
					  ) 
	  => (CFunction, int (*cg var_id*)) =


  rule	int_string(eqn_size) => size_str &
	int_string(unique_id) => id_str &
	Util.string_append_list(["solve_linear_equation_system(A",
				 id_str,",b",id_str,",",
 				 size_str,",",id_str,");"]) 
  	  => stmt &
	Codegen.c_add_statements(Codegen.c_empty_function,[stmt]) => cfunc
	---------------------------
	generate_ode_system2_solve_call(eqn_size,unique_id,cg_id) 
	  => (cfunc,cg_id)
end

(** relation: generate_ode_system2_collect_results
 ** author: PA
 **
 ** Generates the code for storing the result of solving
 ** a linear system of equations into the affected variables .
 **)
relation generate_ode_system2_collect_results:(DAELow.Variables,
					       int(*unique_id*),
					       int (*cg var_id*)) 
	  => (CFunction,int (*cg var_id*)) =

  rule	DAELow.var_list(vars) => var_lst &
	list_reverse(var_lst) => var_lst' &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	Util.list_map(crefs,Exp.print_component_ref_str) => strs &
	generate_ode_system2_collect_results2(strs,0,unique_id) => res
	-------------------------------
	generate_ode_system2_collect_results(vars,unique_id,cg_id) => (res,cg_id)

  rule	Debug.fprint("failtrace","-generaet_ode_system2_collect_results failed\n")
	----------
	generate_ode_system2_collect_results(vars,unique_id,cg_id) => fail
end


(** relation: generate_ode_system2_collect_results2
 ** author: PA
 ** 
 ** Helper relation to generate_ode_system2_collect_results
 **)
relation generate_ode_system2_collect_results2: (string list,
						 int(*indx*),
						 int (* inique_id*))
	  => CFunction =
	  
  axiom	generate_ode_system2_collect_results2([],_,_) 
	  => Codegen.c_empty_function
	
  rule	index + 1 => index' &
	generate_ode_system2_collect_results2(strs,index',unique_id) => cfunc &
	int_string(index) => index_str &
	int_string(unique_id) => id_str &
	Util.string_append_list([str," = get_vector_elt(b",id_str,",",index_str,");"])
	=> stmt &
	  Codegen.c_add_statements(cfunc,[stmt]) => cfunc' 
	----------------------
	generate_ode_system2_collect_results2(str::strs,index,unique_id) 
	  => cfunc'    
end

(** relation transform_x_to_xd
 ** author: PA
 ** this relation transforms x variables (in the state vector)
 ** to corresponding xd variable (in the derivatives vector)
 **)
relation transform_x_to_xd: DAELow.Var => DAELow.Var =

  rule	int_string(index) => index_str &
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list([DAELow.derivative_name_prefix,c_name]) => res

(* 	Util.string_append_list(["xd[",index_str, "]"]) => res *)
	-------------------------
	transform_x_to_xd(DAELow.VAR(cr,DAELow.STATE,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow)) 
	  => DAELow.VAR(Exp.CREF_IDENT(res,[]),DAELow.STATE,dir,tp,exp,v,dim,st,index,cr,classes,attr,comment,flow)

  axiom	transform_x_to_xd(v) => v 
end

(** relation: get_equation_and_solved_var
 ** author: PA
 ** Retrieves the equation and the variable solved in that equation
 ** given an equation number and the variable assignments2
 **)
relation get_equation_and_solved_var: (int, (* equation no. *)
				       DAELow.EquationArray, 
				       DAELow.Variables,
				       int vector (* assignments2*)
				       ) 
	  => (DAELow.Equation, DAELow.Var) =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => eqn &
	vector_nth(ass2,e') => v &
	DAELow.get_var_at(vars,v) => var
	-------------------------------
	get_equation_and_solved_var(e,eqns,vars,ass2) => (eqn,var)	
end

(** relation: is_non_state
 ** failes if the given variable kind is state
 **)
relation is_non_state: DAELow.VarKind => () =

  axiom	is_non_state (DAELow.VARIABLE) => ()
  axiom	is_non_state (DAELow.DUMMY_DER) => ()
  axiom	is_non_state (DAELow.DUMMY_STATE) => ()
  axiom	is_non_state (DAELow.DISCRETE) => ()
end 

(** relation: generate_ode_equation
 ** author: PA
 **
 **  Generates code for a single equation for the ode code generation, see
 ** genrerate_ode_code.
 **)
relation generate_ode_equation: (DAELow.DAELow, 
				 int vector, (*assignements 1 *)
				 int vector, (* assignements 2 *)
				 int, (* equation number*)
				 int) (* cg var_id *)
	  => (CFunction, (* equation code *)
	      int, (* cg var_id *)
	      CFunction list) = (* extra functions *)


	(* discrete equations not considered if event-code is produced *)
  rule	use_zerocrossing => true &
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2), v) &
	  has_discrete_var([v]) => true
	---------------------	
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) 
	  => (Codegen.c_empty_function,cg_id,[])

	  
  rule	(* Solving for non-states *)
	
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2),
	      v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &
	is_non_state kind &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	Codegen.generate_expression(expr,cg_id,Codegen.SIMULATION) => (exp_func,var,cg_id') &
	Exp.print_component_ref_str(cr) => cr_str &
	Util.string_append_list([cr_str," = ",var,";"]) => stmt &
	Codegen.c_add_statements(exp_func,[stmt]) => res
	-----------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) 
	  => (res,cg_id',[])

  rule	(* Solving the state s means solving for der(s) *)
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	int_string(indx) => indxs &

        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list([DAELow.derivative_name_prefix,c_name]) => id &

	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	Codegen.generate_expression(expr,cg_id,Codegen.SIMULATION) => (exp_func,var,cg_id') &
	Exp.print_component_ref_str(cr') => cr_str &
	Util.string_append_list([cr_str," = ",var,";"]) => stmt &
	Codegen.c_add_statements(exp_func,[stmt]) => res
	----------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) 
	  => (res,cg_id',[])

	(* state nonlinear *)
  rule	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (eqn as DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	int_string(indx) => indxs &

(* 	Util.string_append_list(["xd[",indxs,"]"]) => id & *)
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list([DAELow.derivative_name_prefix,c_name]) => id &

	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	generate_ode_system2_nonlinear_residuals([cr'],[eqn],cg_id)
	  => (res,cg_id',f1)
	-------------------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) 
	  => (res,cg_id',f1)

	  (* non-state non-linear *)
  rule	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (eqn as DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	is_non_state kind &
	int_string(indx) => indxs &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	generate_ode_system2_nonlinear_residuals([cr],[eqn],cg_id)
	  => (res,cg_id',f1)
	-------------------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) 
	  => (res,cg_id',f1)

	(* When equations ignored *)
  rule	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.WHEN_EQUATION(_),_) 
	-------------------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id)
	  => (Codegen.c_empty_function,cg_id,[])



  rule	Debug.fprint("failtrace","-generate_ode_equation failed\n") &
 	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (eqn as DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,_,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	DAELow.equation_str(eqn) => s1 &
	Exp.print_component_ref_str(cr) =>s2 &
	Util.string_append_list(["trying to solve ",s2," from eqn: ",s1,"\n"])
	  => s &
	Debug.fprint("failtrace",s)
	----------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) 
	  => fail
end

(** relation generate_functions
 **
 ** Finds the called functions in daelow and generates code for them
 ** from the given DAE. Hence, the functions must exist in the DAE.Element list.
 **)
relation generate_functions: (SCode.Program, (* Needed to instantiate functions*)
			      DAE.DAElist, 
			      DAELow.DAELow, 
			      Absyn.Path, 
			      string) => (string list (* libs *)) =

  rule	get_called_functions(dae, dlow) => funcpaths & 
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(funcpaths, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	generate_functions_2(p,funcpaths) => funcelems &
	Print.getString => debugstr &
	Print.clearBuf &
	(*debug*) Debug.fprintln("info", "Generating functions, call Codegen.\n") &
 	Codegen.generate_functions(DAE.DAE(funcelems)) => libs &
	Print.writeBuf(filename)
	--------------------------------------------------
	generate_functions (p,dae as DAE.DAE(elements), dlow, path, filename) 
	  => libs


  rule	Error.add_message(Error.INTERNAL_ERROR, ["Code generation of Modelica functions failed. "])
	-------------------------------------
	generate_functions (_, _, _, _, _) => fail

end

(** relation: generate_functions_2
 ** author: PA
 **
 ** Helper relation to generate_functions.
 **)
relation generate_functions_2: (SCode.Program, Absyn.Path list) 
	  => DAE.Element list =
  rule	generate_functions_3(p,paths,paths) => dae
	-------------------
	generate_functions_2(p,paths) => dae
end

(** relation: generate_functions_3
 **
 ** Helper relation to generate_functions_2
 **)
relation generate_functions_3: (SCode.Program, 
				Absyn.Path list, (* iterated over *)
				Absyn.Path list) (* complete list *)
	  => DAE.Element list =

  axiom	generate_functions_3(_,[],allpaths) => ([])

  rule	Inst.instantiate_class_implicit(p,path) => (fdae,_) &
	let DAE.DAE([DAE.FUNCTION(_,dae,t)]) = fdae &
	let patched_dae = DAE.DAE([DAE.FUNCTION(path,dae,t)]) &
	get_called_functions_in_function(path,patched_dae) => subfuncs &
	append_nonpresent_paths(subfuncs,allpaths,paths) 
	  => (allpaths',paths') &
	generate_functions_3(p,paths',allpaths') => elts &
	list_append(elts,[DAE.FUNCTION(path,dae,t)]) => res
	---------------------------------------
	generate_functions_3(p,path::paths,allpaths) => res

  rule	Inst.instantiate_class_implicit(p,path) => (fdae,_) &
	let DAE.DAE([DAE.EXTFUNCTION(_,dae,t,extdecl)]) = fdae &
        let patched_dae = DAE.DAE([DAE.EXTFUNCTION(path,dae,t,extdecl)]) &
	get_called_functions_in_function(path,patched_dae) => subfuncs &
	append_nonpresent_paths(subfuncs,allpaths,paths) 
	  => (allpaths',paths') &
	generate_functions_3(p,paths',allpaths') => elts &
	list_append(elts,[DAE.EXTFUNCTION(path,dae,t,extdecl)]) => res
	---------------------------------------
	generate_functions_3(p,path::paths,allpaths) => res

  rule	print "generate_functions_3 failed\n" 
	--------------------------
	generate_functions_3(_,_,_) => fail
    
end

(** relation: append_nonpresent_paths
 ** 
 **
 ** Appends the paths in first argument to the two path lists given as second
 ** and third argument, given that the path is not present in the second 
 ** path list.
 **
 **)
relation append_nonpresent_paths:(Absyn.Path list, (* paths to append*)
				  Absyn.Path list, (* all paths *)
				  Absyn.Path list) (* iterated paths *)
	  => (Absyn.Path list, (* updated all paths *)
	      Absyn.Path list) = (* update iterated paths *)

  axiom	append_nonpresent_paths([],allpaths,iterpaths) => (allpaths,iterpaths)

  rule	Util.list_getmember_p(path,allpaths,ModUtil.path_equal) => _ &
	append_nonpresent_paths(paths,allpaths,iterpaths) 
	  => (allpaths,iterpaths)
	------------------------------------------
	append_nonpresent_paths(path::paths, allpaths, iterpaths)
	  => (allpaths,iterpaths)

  rule	not Util.list_getmember_p(path,allpaths,ModUtil.path_equal) => _ &
	list_append(allpaths,[path]) => allpaths' &
	list_append(iterpaths,[path]) => iterpaths' &
	append_nonpresent_paths(paths,allpaths',iterpaths') 
	  => (allpaths'',iterpaths'')
	------------------------------------------
	append_nonpresent_paths(path::paths, allpaths, iterpaths)
	  => (allpaths'',iterpaths'')
end


(** relation generate_init_data
 **
 ** This relation generates initial values for the simulation
 ** by investigating values of variables.
 **)
relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
                               string (* executable file name *) ,
			      string(* filename *),
			      real, (* start time*)
			      real, (* stop time *)
			      real) (* íntervals *)
	  => () =

  rule  real_sub(stop,start) => delta_time &
	real_div(delta_time,intervals) => step &
	real_string(start) => start_str &
	real_string(stop) => stop_str &
	real_string(step) => step_str &
 	DAELow.calculate_sizes(dlow) => (nx,ny,np,_) &
 	int_string(nx) => nx_str &
 	int_string(ny) => ny_str &
 	int_string(np) => np_str &
 	generate_init_data2(dlow,nx,ny,np) => init_str &
 	Util.string_append_list([start_str, " // start value\n",
				 stop_str, " // stop value\n",
 				 step_str, " // step value\n",
 				 nx_str, " // n states\n",
 				 ny_str, " // n alg vars\n",
 				 np_str, " //n parameters\n",
 				 init_str]) => str &
 	System.writeFile(filename,str) 
 	--------------------------
 	generate_init_data(dlow,class,exe,filename,start,stop,intervals)

  rule	print "-generate_init_data failed\n"
 	------------------------------------
	generate_init_data(_,_,_,_,_,_,_) => fail
end

(** relation: generate_init_data2
 **
 ** Helper relation to generate_init_data
 ** Generates init data for states, variables and parameters.
 ** nx - number of states.
 ** ny - number of alg. vars. 
 ** np - number of parameters.
 **)
relation generate_init_data2:(DAELow.DAELow,
			      int(*nx*),
			      int(*ny*),
			      int(*np*)) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	array_create(nx,"") => nxarr &
	array_create(nx,"0.0") => nxdarr &
	array_create(ny,"") => nyarr &
	array_create(np,"") => nparr &
	generate_init_data3(var_lst,nxarr,nxdarr,nyarr,nparr) 
	  =>(nxarr1,nxdarr1,nyarr1,nparr1) &
	generate_init_data3(knvar_lst,nxarr1,nxdarr1,nyarr1,nparr1)
	  =>(nxarr2,nxdarr2,nyarr2,nparr2) &
	generate_init_data4(knvar_lst,nxarr2,nxdarr2,nyarr2,nparr2)  
	  =>(nxarr3,nxdarr3,nyarr3,nparr3) &
	array_list(nxarr3) => nx_lst &
	array_list(nxdarr3) => nxd_lst &
	array_list(nyarr3) => ny_lst &
	array_list(nparr3) => np_lst &
	Util.list_flatten([nx_lst,nxd_lst,ny_lst,np_lst]) => whole_lst &
	Util.string_delimit_list_no_empty(whole_lst,"\n") => res
	-----------------------------
	generate_init_data2(DAELow.DAELOW(vars,knvars,_,_,initeqn,_,alg,_),nx,ny,np) => res


end

(** relation: print_exp_str_opt
 **
 ** Helper relation to generate_init_data2
 ** Prints expression value that is opional for initial values.
 ** If NONE is passed. The default value 0.0 is returned.
 **)
relation print_exp_str_opt: Exp.Exp option => string =

  axiom	print_exp_str_opt NONE => "0.0"

  rule	Exp.print_exp_str e => str 
 	--------------------------
 	print_exp_str_opt SOME(e) => str 
end

(** relation: generate_init_data3
 **
 ** This relation is a help relation to generate_init_data2
 ** It Traverses Var lists and adds initial values to the specific
 ** string array depending on the type of the variable.
 ** For instance, state variables write their start value to the
 ** x array at given index.
 **)
relation generate_init_data3:(DAELow.Var list,
			      string array, (* state strings *)
			      string array, (* derivative strings*)
			      string array, (* alg. var strings *)
			      string array) (* param. strings *)
	  => (string array, (* updated state strings *)
	      string array, (* updated derivative strings*)
	      string array, (* updated alg. var strings *)
	      string array) (* updated param. strings *)
	=

  axiom	generate_init_data3([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v, " // ",origname_str]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v, " // ",origname_str]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

   rule	(* State variables *)
	print_exp_opt_str_if_const(start) => v &
	 Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v, " // ",origname_str]) => str &
	array_setnth(nxarr,indx,str) => nxarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)
	--------------------
	 generate_init_data3(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,
                                        start,indx,origname,_,dae_var_attr,comment,flow)::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* dummy derivatives => algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v, " // ",origname_str]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,
                                       start,indx,origname,_,dae_var_attr,comment,flow)::rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)

  rule	(* Dummy states => algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v, " // ",origname_str]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
 	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,
				       _,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	----------------------
	generate_init_data3(_::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr',nxdarr',nyarr',nparr')
end

(** relation: print_exp_opt_str_if_const
 **
 ** Helper relation to generate_init_data3.
 **)
relation print_exp_opt_str_if_const:(Exp.Exp option) => string =
       
  rule  Exp.is_const(e) => true &
        print_exp_str_opt(SOME(e)) => res
        --------------------
        print_exp_opt_str_if_const(SOME(e)) => res
     
  rule  print_exp_str_opt(NONE) => res
        --------------------
        print_exp_opt_str_if_const(_) => "0.0"

end

(** relation: generate_init_data4
 **
 ** Helper relation to generate_init_data2
 ** Traverses parameters.
 **)
relation generate_init_data4: (DAELow.Var list, 
			       string array,
			       string array,
			       string array,
			       string array)  
	  => (string array,
	      string array,
	      string array,
	      string array)   =
  axiom	generate_init_data4([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr) 
	
  rule	(* Parameters *)
	Values.val_string(value) => v &
	Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v, " // ",origname_str]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,SOME(value),_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Parameters without value binding. Investigate if it has start value*)
	print_exp_opt_str_if_const(start) => v &
	Exp.print_component_ref_str(origname)=> origname_str &
	Util.string_append_list([v," // ",origname_str]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,NONE,_,
				start,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Skip alg. vars that are removed 
	 In future we should compare eliminated variables 
	 intial values to their aliases to detect inconsistent
	 initial values.
	 *)
	generate_init_data4(vs,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	-----------------------------------
	generate_init_data4(_::vs,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr',nxdarr',nyarr',nparr')
end

(** relation: dump_when_clauses_str
 **
 ** Prints when clauses to a string.
 **)
relation dump_when_clauses_str: (DAELow.WhenClause list) => string =

  axiom	dump_when_clauses_str [] => ""

  rule	dump_when_clause_str c => str &
	dump_when_clauses_str xs => str2 &
	string_append(str, str2) => res
	------------------------------
	dump_when_clauses_str c::xs => res
end

(** relation: dump_when_clause_str
 **
 ** Prints a when clause to a string.
 **)
relation dump_when_clause_str: (DAELow.WhenClause) => string =

  rule	Exp.print_exp_str exp => str1 &
	Util.string_append_list ["when ", str1, "\n"] => res
	----------------------------------------
	dump_when_clause_str DAELow.WHEN_CLAUSE(exp,_) => res

end

(** relation: generate_helpvar_updates
 ** Gerates code for updating help variables
 **)
relation generate_helpvar_updates: ((int (*helpvar index*) * 
				     Exp.Exp (*binding expression*) * 
				     int (*when clause index using this help var*)) list) 
	  => string =
  
  axiom	generate_helpvar_updates([]) => ""
	
  rule	Exp.get_relations(e) => [] &
	print_exp_cpp_str(e) => eStr &
	int_string hindex => hindStr &
	generate_helpvar_updates(rest) => restStr &
	Util.string_append_list(["  h[",hindStr,"] = ", eStr, ";\n",restStr]) => res 
	--------------------------------------------------
	generate_helpvar_updates((helpvar as (hindex,e,_))::rest) => res

  rule	generate_helpvar_updates(rest) => restStr 
	--------------------------------------------------
	generate_helpvar_updates(_::rest) => restStr

end

(** relation: generate_zero_crossing
 ** Generates code for handling zerocrossings as well as the 
 ** zero crossing function given to the solver
 **)
relation generate_zero_crossing: (string,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list, (* blocks *) 
				  (int * Exp.Exp * int) list )
	  => string =
	  
  rule	
	generate_zero_crossing2(zc,0,dae,dlow,ass1,ass2,blocks,helpVarInfo,0,0) 
	  => (func_zc,cg_id1,func_handle_zc,cg_id2) &

	generate_ode_blocks(dlow,ass1,ass2,blocks,0) => (cfunc,_,extra_funcs) &
	Codegen.c_print_functions_str(extra_funcs) => extra_funcs_str &
	Codegen.c_make_function("int","function_updateDependents",[],
				["double*t"]) => cfunc0' &
	add_memory_management(cfunc0') => cfunc0' &
	Codegen.c_add_cleanups(cfunc0', ["return 0;"]) => cfunc0 &
        Codegen.c_merge_fns([cfunc0,cfunc]) => cfunc' &
	generate_helpvar_updates(helpVarInfo) => helpvarUpdateStr &
	Codegen.c_add_statements(cfunc',[helpvarUpdateStr]) => cfunc'' &
	Codegen.c_make_function("int","function_zeroCrossing",[],["long *neqm", "double *t", 
								  "double *x", "long *ng", 
								  "double *gout","double *rpar",
								  "long* ipar"]) => func_zc0 &
	Codegen.c_make_function("int","handleZeroCrossing",[],["long index","double *t"]) 
	  => func_handle_zc0 &
	
	Codegen.c_prepend_statements(func_handle_zc0,["switch(index) {"]) => func_handle_zc0' &
	Codegen.c_add_cleanups(func_handle_zc0',["default: break;",
						   "}"]) => func_handle_zc0'' &
	add_memory_management(func_handle_zc0'') => func_handle_zc0'' & 
	add_memory_management(func_zc0) => func_zc0 &
	Codegen.c_add_cleanups(func_handle_zc0'',["return 0;"]) => func_handle_zc0''' &
	Codegen.c_add_cleanups(func_zc0,["return 0;"]) => func_zc0' &
	Codegen.c_merge_fns([func_zc0',func_zc]) => func_zc' &
	Codegen.c_merge_fns([func_handle_zc0''',func_handle_zc]) => func_handle_zc' &
	Codegen.c_print_functions_str([func_zc',func_handle_zc',cfunc'']) => func_str &
	Util.string_append_list([extra_funcs_str,
				 func_str
				 ]) => res
	--------------------------------------------------
	generate_zero_crossing(cname,dae,dlow as DAELow.DAELOW(_,_,_,_,_,_,_,DAELow.EVENT_INFO(_,zc)),ass1,ass2,blocks,helpVarInfo) => res

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_zero_crossing failed"])
	----------------------------------------
	generate_zero_crossing(_,_,_,_,_,_,_) => fail
end

(** relation: generate_zero_crossing2
 ** Helper function to generate_zero_crossing
 **)
relation generate_zero_crossing2: (DAELow.ZeroCrossing list, int,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list, (* blocks *) 
				   (int * Exp.Exp * int) list,
				   int, (* cg var_id1*)
				   int) (* cg_var_id2 *)
	  => (CFunction,int,CFunction,int) =

  axiom	generate_zero_crossing2([],_,_,_,_,_,_,_,cg_id1,cg_id2) 
	  => (Codegen.c_empty_function,cg_id1,Codegen.c_empty_function,cg_id2)

  rule	use_zerocrossing => false 
	----------------------------------------
	generate_zero_crossing2(_,_,_,_,_,_,_,_,cg_id1,cg_id2) 
	  => (Codegen.c_empty_function,cg_id1,Codegen.c_empty_function,cg_id2)

	
  rule  dump_zero_crossing_str zc => zc_str &
	int_string index => index_str &
	index + 1 => index' &
	generate_zero_crossing2(xs,index',dae,dlow,ass1,ass2,blocks,helpVarInfo,cg_id1,cg_id2) 
	  => (cfunc1,cg_id1',cfunc2,cg_id2') &
	Util.string_append_list(["ZEROCROSSING(",index_str, ",",zc_str,");\n"]) 
	  => stmt1 &
        Util.list_select_1(helpVarInfo,(index,dlow),isZeroCrossingAffectingHelpVar)
	  => usedHelpVars &
 	build_zero_crossing_eqns (dae,dlow,ass1,ass2,eql,blocks,cg_id2') 
	  => (Codegen.CFUNCTION(rettp,fn,retrec,arg,vars,init,stmts,cleanups),cg_id2'') &
	Util.string_append_list(["case ", index_str, ":\n"]) => case_stmt &
	let stmts' = case_stmt::stmts &
        build_help_var_assignments (usedHelpVars) => help_var_str &
	list_append(stmts',[help_var_str,"break;"]) => stmts'' &
	let cfunc2' = Codegen.CFUNCTION(rettp,fn,retrec,arg,vars,init,stmts'',cleanups) &
	Codegen.c_merge_fns([cfunc2',cfunc2]) => cfunc2'' &
	Codegen.c_prepend_statements(cfunc1,[stmt1]) => cfunc1' 
	--------------------------------------------------
	generate_zero_crossing2((zc as DAELow.ZERO_CROSSING(_,eql,_))::xs,
				index,dae,dlow,ass1,ass2,blocks,
				helpVarInfo,cg_id1,cg_id2) 
	  => (cfunc1',cg_id1',cfunc2'',cg_id2'')

  rule	dump_zero_crossing_str zc => zc_str &
	Util.string_append_list(["generating zero crossing :",
				 zc_str,"\n"]) => res &
	Error.add_message(Error.INTERNAL_ERROR, [res])
	------------------------
	generate_zero_crossing2((zc as DAELow.ZERO_CROSSING(_,eql,_))::xs,
				index,dae,dlow,ass1,ass2,blocks,
				helpVarInfo,cg_id1,cg_id2) 
	  => fail
end

(** relation: is_part_of_mixed_system
 **
 ** Helper relation to generate_zero_crossing2,
 ** returns true if any equation in the equation list of a 
 ** zero-crossing is part of a mixed system.
 **)

relation is_part_of_mixed_system:(DAELow.DAELow,
				  int (* equation *),
				  int list list (* blocks*),
				  int vector (* ass2*))
	  => bool =

  rule	DAELow.get_equation_block(e,blocks) => block &
	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	is_mixed_system(var_lst) => res
	--------------------------------
	is_part_of_mixed_system(dae as DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),e,blocks,ass2) => res

  axiom	is_part_of_mixed_system(_,_,_,_) => false
end

(** relation: get_zc_mixed_system
 **
 ** Helper relation to generate_zero_crossing2,
 ** returns true if any equation in the equation list of a 
 ** zero-crossing is part of a mixed system.
 **)

relation get_zc_mixed_system:(DAELow.DAELow,
				  int  (* equation *),
				  int list list (* blocks*),
				  int vector (* ass2*))
	  => int list =

  rule	DAELow.get_equation_block(e,blocks) => block &
	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	is_mixed_system(var_lst) => true 
	--------------------------------
	get_zc_mixed_system(dae as DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),
			    e,blocks,ass2) 
	  => block

end

(** relation: dump_zero_crossing_str
** author: 
 **
 ** Dumps a ZeroCrossing to a sting. Useful for debugging.
 **)

relation dump_zero_crossing_str: (DAELow.ZeroCrossing) => string =

  rule	print_exp_cpp_str(e1) => e1_str &
	print_exp_cpp_str(e2) => e2_str &
	print_zero_crossing_op_str(op) => op_str &
	Util.string_append_list([op_str,"(",e1_str,",",e2_str,")"]) => zc_str
	----------------------------------------
	dump_zero_crossing_str (DAELow.ZERO_CROSSING(Exp.RELATION(e1,op,e2),_,_)) => zc_str

  rule	print_exp_cpp_str(start) => e1_str &
	print_exp_cpp_str(interval) => e2_str &
	Util.string_append_list(["Sample(*t,",e1_str,",",e2_str,")"]) => zc_str
	----------------------------------------
	dump_zero_crossing_str (DAELow.ZERO_CROSSING(Exp.CALL(Absyn.IDENT("sample"),[start,interval],_,_),_,_)) => zc_str

  rule  print_exp_cpp_str(e) => e_str &
	Util.string_append_list(["/*Unknown zero crossing: ",e_str," */"]) 
	  => zc_str
	-------------------
	dump_zero_crossing_str (DAELow.ZERO_CROSSING(e,_,_)) => zc_str

end

relation isZeroCrossingAffectingHelpVar: ((int * Exp.Exp * int), (int * DAELow.DAELow)) => bool =

  rule	whenClauseIndex + 1 => whenClauseIndex' &
	DAELow.get_zero_crossing_indices_from_when_clause(dlow,whenClauseIndex') => zeroCrossings &
	Util.list_getmember(zcIndex, zeroCrossings) => _
	--------------------------------------------------
	isZeroCrossingAffectingHelpVar((_,e,whenClauseIndex), (zcIndex, dlow)) => true

  axiom	isZeroCrossingAffectingHelpVar(_,_) => false
end

relation build_help_var_assignments: ( (int * Exp.Exp * int) list ) => string =

  axiom build_help_var_assignments([]) => ""

  rule	print_exp_cpp_str(e) => expr_str &
	int_string helpVarIndex => ind_str &
	Util.string_append_list(["    h[", ind_str,"] = ", expr_str, ";\n"]) => res1 &
	build_help_var_assignments(rest) => res2 &
	string_append(res1,res2) => res
	--------------------------------------------------
	build_help_var_assignments((helpVarIndex, e,_)::rest) => res

  rule	Error.add_message(Error.INTERNAL_ERROR, ["build_help_var_assignments failed"])
	--------------------------------------------------
	build_help_var_assignments(_) => fail
end

relation print_zero_crossing_op_str: (Exp.Operator) => string =
  axiom	print_zero_crossing_op_str(Exp.LESS(_)) => "Less"
  axiom	print_zero_crossing_op_str(Exp.GREATER(_)) => "Greater"
  axiom	print_zero_crossing_op_str(Exp.LESSEQ(_)) => "LessEq"
  axiom	print_zero_crossing_op_str(Exp.GREATEREQ(_)) => "GreaterEq"
end

(** relation: generate_when_clauses
 **
 ** Generate code for when clauses.
 **)
relation generate_when_clauses: (string,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list) (* blocks *) 
	  => string =
	  
  rule	generate_when_clauses2(wc,0,dae,dlow,ass1,ass2,blocks,0) => (when_fcn,_) &
	Codegen.c_make_function("int","function_when",[],["int i","double *t"]) => when_fcn0 &
	Codegen.c_merge_fns([when_fcn0,when_fcn]) => when_fcn' &
	Codegen.c_prepend_statements(when_fcn',["switch(i) {"]) => when_fcn'' &
	Codegen.c_add_statements(when_fcn'',["default: break;","}"]) => when_fcn3 &
	add_memory_management(when_fcn3) => when_fcn3 &
	Codegen.c_add_cleanups(when_fcn3,["return 0;"]) => when_fcn4 &
	Codegen.c_print_functions_str([when_fcn4]) => res
	--------------------------------------------------
	generate_when_clauses(cname,dae,dlow as DAELow.DAELOW(_,_,_,_,_,_,_,DAELow.EVENT_INFO(wc,_)),ass1,ass2,blocks) => res

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_when_clauses failed"])
	----------------------------------------
	generate_when_clauses(_,_,_,_,_,_) => fail
end

relation generate_when_clauses2: (DAELow.WhenClause list, int,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list, (* blocks *) 
				  int (* cg var_id *))
	  => (CFunction,int (* cg var_id *)) =

  axiom	generate_when_clauses2([],_,_,_,_,_,_,cg_id) 
	  => (Codegen.c_empty_function,cg_id)

  rule  dump_when_clause_str wc => wc_str &
	Exp.get_cref_from_exp(cond) => cond_cref_list &
	Util.list_map(cond_cref_list,Exp.print_component_ref_str) 
	  => cond_cref_str_list &
         Util.string_delimit_list(cond_cref_str_list,");\n    save(") 
	  => save_cond_str &
	Util.string_append_list(["    save(",save_cond_str,");\n"]) 
	  => save_cond_str &
	Util.list_map(reinit,build_reinit_str) => reinit_str &
	Util.string_append_list(reinit_str) => reinit_str' &
	int_string index => index_str &
	build_when_blocks(dae,dlow,ass1,ass2,blocks,index,cg_id) => (when_fcn,cg_id') &
	Codegen.c_print_statements(when_fcn) => when_str &
	Util.string_append_list([" case ",index_str, ": //",wc_str]) => case_stmt &
	Codegen.c_prepend_statements(when_fcn,[case_stmt]) => when_fcn' &
	Codegen.c_add_statements(when_fcn',[reinit_str',"break;"]) => when_fcn'' &
	index + 1 => index' &
 	generate_when_clauses2(xs,index',dae,dlow,ass1,ass2,blocks,cg_id') => (when_fcn2,cg_id'') &
	Codegen.c_merge_fns([when_fcn'',when_fcn2]) => when_fcn'''
	--------------------------------------------------
	generate_when_clauses2((wc as DAELow.WHEN_CLAUSE(cond,reinit))::xs,
			       index,dae,dlow,ass1,ass2,blocks,cg_id) 
	  => (when_fcn''',cg_id'')
end

relation build_reinit_str : (DAELow.ReinitStatement) => string =

  rule	Exp.print_component_ref_str(cr) => cr_str &
	print_exp_cpp_str(exp) => exp_str &
	Util.string_append_list(["    ",cr_str," = ", exp_str, ";\n"]) => eqn_str
	----------------------------------------
	build_reinit_str(DAELow.REINIT(cr,exp)) => eqn_str

end

(** relation: build_when_blocks
 **
 ** Helper relation to build_when_clauses.
 **)
relation build_when_blocks : (DAE.DAElist,DAELow.DAELow, 
			      int vector, int vector, 
			      int list list, int, int (*cg var_id *)) 
	  => (CFunction,int (* cg var_id *)) =

  axiom build_when_blocks(_,_,_,_,[],_,cg_id) =>(Codegen.c_empty_function,cg_id)

  rule	build_when_equation(dae,dlow,ass1,ass2,eqn,index,cg_id) => (cfn1,cg_id') &
	build_when_blocks(dae,dlow,ass1,ass2,blocks,index,cg_id') => (cfn2,cg_id'') &
	Codegen.c_merge_fns([cfn1,cfn2]) => cfn
	----------------------------------------
	build_when_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks,index,cg_id) 
	  => (cfn,cg_id'')

  axiom build_when_blocks(_,_,_,_,_,_,cg_id) => (Codegen.c_empty_function,cg_id)
end

(** relation: build_zero_crossing_eqns
 ** author: haklu?
 **
 ** Helper rerlation to generate_zero_crossing2. Generates code for each
 ** zero crossing.
 **)

relation build_zero_crossing_eqns : (DAE.DAElist,
				     DAELow.DAELow, 
				     int vector(*ass1*), 
				     int vector(*ass2*), 
				     int list(*eqns*),
				     int list list (* blocks*),
				     int (* cg var_id*)) => (CFunction,int(*cg var_id*))  =

  axiom build_zero_crossing_eqns(_,_,_,_,[],_,cg_id) 
	  => (Codegen.c_empty_function,cg_id)

	  (* Zero crossing for mixed system*)
  rule	is_part_of_mixed_system(dlow,eqn,blocks,ass2) => true &
	get_zc_mixed_system(dlow,eqn,blocks,ass2) => block &

	eqn - 1 => eqn' &
         vector_nth(ass2,eqn') => v &
	DAELow.get_var_at(vars,v) => (DAELow.VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,_)) &  
	Exp.print_component_ref_str(cr) => cr_str & 
	Util.string_append_list(["save(",cr_str,");"]) => save_stmt &

	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	is_mixed_system(var_lst) => true &
	split_mixed_equations(eqn_lst,var_lst) => (cont_eqn,cont_var,
						   disc_eqn,disc_var) &

	(*dump_mixed_system(cont_eqn,cont_var,disc_eqn,disc_var) &*)

	DAELow.list_var(cont_var) => vars' &

	DAELow.list_equation(cont_eqn) => eqns' &
	let cont_subsystem_dae = DAELow.DAELOW(vars',knvars,eqns',se,ie,ae,al,ev) &
	DAELow.incidence_matrix(cont_subsystem_dae) => m &
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.transpose_matrix(m') => mt' &
	(* calculate jacobian. If constant, linear system of equations. Otherwise nonlinear *)
	
	DAELow.calculate_jacobian(vars',eqns',ae,m',mt') => jac &
	DAELow.analyze_jacobian(cont_subsystem_dae,jac) => jac_tp &

	generate_mixed_header(cont_eqn,cont_var,disc_eqn,disc_var,cg_id)
	  => (s0,cg_id1) &
	Codegen.c_prepend_statements(s0,[save_stmt]) => s0 &
	generate_ode_system2(cont_subsystem_dae,jac,jac_tp,cg_id1) 
	  => (Codegen.CFUNCTION(rettp,fn,retrec,arg,vars,init,stmts,cleanups),cg_id2,_) &
	  (* initialization of e.g. matrices for linsys must be done in each
	   * iteration, create new scope and put them first.*)
	  Util.list_flatten([["{"],vars,stmts,["}"]]) => stmts' &
	let s2' = Codegen.CFUNCTION(rettp,fn,retrec,arg,[],init,stmts',cleanups) &
	generate_mixed_footer(cont_eqn,cont_var,disc_eqn,disc_var,cg_id2)
	  => (s4,cg_id3) &
	generate_mixed_system_discrete_part_check(disc_eqn,disc_var,cg_id3)
	  => (s3,cg_id4,_) &
	generate_mixed_system_store_discrete(disc_var,0,cg_id4) 
	  => (s1,cg_id5,_) &
	build_zero_crossing_eqns(dae,dlow,ass1,ass2,rest,blocks,cg_id5) 
	  => (cfn3,cg_id6) &
	Codegen.c_merge_fns([s0,s1,s2',s3,s4,cfn3]) => cfn   
	----------------------------------------
	build_zero_crossing_eqns(dae,
				 dlow as DAELow.DAELOW(vars,knvars,eqns,se,ie,ae,al,ev),
				 ass1,ass2,eqn::rest,blocks,cg_id) 
	  => (cfn,cg_id6)

	(* Zero crossing for single equation*)
  rule	build_equation(dae,dlow,ass1,ass2,eqn,cg_id) => (cfn2,cg_id') &
	eqn - 1 => eqn' &
         vector_nth(ass2,eqn') => v &
	DAELow.get_var_at(vars,v) => (DAELow.VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,_)) &  
	Exp.print_component_ref_str(cr) => cr_str &
	build_zero_crossing_eqns(dae,dlow,ass1,ass2,rest,blocks,cg_id') 
	  => (cfn3,cg_id'') &
 	Util.string_append_list(["save(",cr_str,");"]) => stmt &
 	Codegen.c_add_statements(Codegen.c_empty_function,[stmt]) => cfn1 &
	Codegen.c_merge_fns([cfn1,cfn2,cfn3]) => cfn
	----------------------------------------
	build_zero_crossing_eqns(dae,dlow as DAELow.DAELOW(vars,_,_,_,_,_,_,_),
				 ass1,ass2,eqn::rest,blocks,cg_id) 
	  => (cfn,cg_id'')

  axiom build_zero_crossing_eqns(_,_,_,_,_,_,cg_id) 
	  => (Codegen.c_empty_function,cg_id)
end

(** relation: dump_mixed_system
**
 ** dumps a mixed system of equations on stdout.
 **)
relation dump_mixed_system: (DAELow.Equation list, (* continous eqns*)
	      DAELow.Var list, (* continuous vars*)
	      DAELow.Equation list (* discrete eqns*),
	      DAELow.Var list (* discrete vars*)) => ()=


  rule	print "Mixed system\n" &
	print "============\n" &
	print "  continous eqns:\n" &
        DAELow.dump_eqns(c_e) &
	print "  continous vars:\n" &
	DAELow.dump_vars(c_v)  &
	print "  discrete eqns:\n" &
        DAELow.dump_eqns(d_e) &
	print "  discret vars:\n" &
	DAELow.dump_vars(d_v)  &
	print "\n" 
	---------------------
	dump_mixed_system(c_e,c_v,d_e,d_v) => ()

end

(** relation: build_when_equation
 **
 ** Helper relation to build_when_blocks.
 **)
relation build_when_equation: (DAE.DAElist,
			       DAELow.DAELow, 
			       int vector, (* assignments1*)
			       int vector, (* assignments2*)
			       int, (* equation no. *)
			       int,
			       int (* cg var_id *)
			       ) => (CFunction,int (* cg var_id*)) =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(DAELow.WHEN_EQ(wc_ind,cr,expr)) &
	int_eq(index,wc_ind) => true &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
         Exp.print_component_ref_str(cr) => assignedVar &
	Exp.print_component_ref_str(origname)=> origname_str &
	build_assignment(dae,cr,expr,origname_str,cg_id) => (cfn,cg_id') &
	Util.string_append_list(["save(",assignedVar,");\n"]) => save_stmt &
	Codegen.c_prepend_statements(cfn,[save_stmt]) => cfn
	------------------------------------------------------------
	build_when_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,index,cg_id) => (cfn,cg_id')

  axiom	build_when_equation(_,_,_,_,_,_,cg_id) => (Codegen.c_empty_function,cg_id)
end
	

(** relation: generate_compute_residual_state
 **
 ** This relation generates the code for the calculation of the 
 ** state variables on residual form. Called from generate_simulation_code.
 **)
relation generate_compute_residual_state:(string,
					  DAE.DAElist,
					  DAELow.DAELow,
					  int vector, (* assignments1 *) 
					  int vector, (* assignments2 *)
					  int list list) (* blocks *) 
	  => string =
          
  rule	
        (*build_residual_blocks(dae,dlow,ass1,ass2,blocks,0) => (cfn2,_) &*)
	Codegen.c_make_function("int","functionDAE_res",[],
				["double *t","double *x", "double *xd", 
				 "double *delta", "long int *ires", 
				 "double *rpar", "long int* ipar"]) => cfn1 &
	Codegen.c_add_variables(cfn1,["int i;", "double temp_xd[NX];"]) => cfn2 &
	Codegen.c_add_statements(cfn2,["functionODE(x,temp_xd,y,p,nx,ny,np,t);",
				 " for (i=0; i < nx; i++) delta[i]=temp_xd[i]-xd[i];",
				 "return 0;"]) => cfn &
	Codegen.c_print_functions_str([cfn]) => res
        -------------------------------------------------------------
        generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blocks) => res

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_compute_residual_state"])

	----------------------------
	generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blocks) => fail
end


(** relation: generate_compute_output
 **
 ** This relation generates the code for the calculation of the output
 ** variables.
 **)
 relation generate_compute_output:(string,
				   DAE.DAElist,
                                   DAELow.DAELow,
                                   int vector, 
                                   int vector, 
                                   int list list) => string =
         
  rule	Codegen.c_make_function("int","functionDAE_output",[],["double *t",
							       "double* x",
							       "double* xd", 
							       "double* y", 
							       "double* p"])
	  => cfunc' &
	 add_memory_management(cfunc') => cfunc' &
	   Codegen.c_add_cleanups(cfunc', ["return 0;"]) => cfunc &
	 build_solved_blocks(dae,dlow,ass1,ass2,blocks,0) => (body,_,extra_funcs) &
	 generate_compute_removed_eqns(dlow) => stmts2 &
	 Codegen.c_merge_fns([cfunc,body]) => cfunc' &
	 Codegen.c_add_statements(cfunc',stmts2) => cfunc'' &

	 Codegen.c_print_functions_str(cfunc''::extra_funcs) => coutput
         -------------------------------------------------------------
         generate_compute_output(cname,dae,dlow,ass1,ass2,blocks) => coutput

  rule	Error.add_message(Error.INTERNAL_ERROR, ["generate_compute_output failed"])
	 -----------------
	 generate_compute_output(_,_,_,_,_,_) => fail
 end

(** relation: generate_compute_removed_eqns
 ** author: PA
 **
 ** Generates compute code for the removed equations
 **)
relation generate_compute_removed_eqns: (DAELow.DAELow) => string list =

  rule	DAELow.equation_list(reqns) => eqn_lst &
	generate_compute_removed_eqns_2(eqn_lst) => res
	-----------------
	generate_compute_removed_eqns(DAELow.DAELOW(_,_,_,reqns,_,_,_,_)) => res
end

(** relation: generate_compute_removed_eqns_2
 **
 ** Helper relation to generate_computed_remove_eqns
 **)
relation generate_compute_removed_eqns_2: DAELow.Equation list  => string list =

  axiom	generate_compute_removed_eqns_2([]) => []

  rule	generate_compute_removed_eqns_2(rest) => res &
	Exp.print_component_ref_str(cr) => cr_str &	
	print_exp_cpp_str(exp) => exp_str &
	Util.string_append_list([cr_str," = ",exp_str,";\n"]) => s1 
	------------------------------
	generate_compute_removed_eqns_2(DAELow.SOLVED_EQUATION(cr,exp)::rest)
	  => s1::res
end


(** relation: build_solved_blocks
 **
 ** This relation generates code for blocks on solved form, i.e. 
 ** \dot{x} = f(x,y,t)
 ** It is used for the generation of the output function. If event code
 ** is generated, it does not include discrete equations in the output code.
 **)

relation build_solved_blocks:(DAE.DAElist,
			      DAELow.DAELow, 
			      int vector, (* assignments1*)
			      int vector, (* assignments2*)
			      int list list (* list of blocks *),
			      int (* cg var_id *))
	  => (CFunction,int (* cg var_id*), CFunction list)  =

  axiom	build_solved_blocks(_,_,_,_,[],cg_id) 
	  => (Codegen.c_empty_function,cg_id,[])
	     
  rule	(* for single equations *)
	use_zerocrossing => true &
	build_non_discrete_equation(dae,dlow,ass1,ass2,eqn,cg_id) 
	  => (cfn1,cg_id') &
	build_solved_blocks(dae,dlow,ass1,ass2,blocks,cg_id') => (cfn2,cg_id'',f2) &
	Codegen.c_merge_fns([cfn1,cfn2]) => cfn
	-------------------------------------
	build_solved_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks,cg_id) 
	=> (cfn,cg_id'',f2)

  rule	(* for single equations *)
	use_zerocrossing => false &
	build_equation(dae,dlow,ass1,ass2,eqn,cg_id) => (cfn1,cg_id') &
	build_solved_blocks(dae,dlow,ass1,ass2,blocks,cg_id') 
	  => (cfn2,cg_id'',f2) &
	  Codegen.c_merge_fns([cfn1,cfn2]) => cfn
	-------------------------------------
	build_solved_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks,cg_id) 
	  => (cfn,cg_id'',f2)
	 

  rule	(* for blocks *)
	generate_ode_system(dlow,ass1,ass2,block,cg_id) 
	  => (fcn1,cg_id',f1)  &
	build_solved_blocks(dae,dlow,ass1,ass2,blocks,cg_id') 
	  => (fcn2,cg_id'',f2) &
	Codegen.c_merge_fns([fcn1,fcn2]) => fcn &
	list_append(f1,f2) => f
	 ------------------
	build_solved_blocks(dae,dlow,ass1,ass2,block::blocks,cg_id) 
	  => (fcn,cg_id'',f)

  rule	print "-build_solved_blocks failed\n" 
	 -----------------
	 build_solved_blocks(_,_,_,_,_,_) => fail
 end

(** relation: build_block
 **
 ** This relation returns the code string for solving a block of variables 
 ** in the dae, i.e. a set of coupled equations.
 ** It is used both for state variables and algebraic variables.
**)

relation build_block: (DAE.DAElist,
		       DAELow.DAELow, 
		       int vector, (* assignments1 *)
		       int vector, (* assignments2 *)
		       int list) (* block of equations*)
	  => string =

  rule	all_same_algorithm(dlow,block) => true &
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(alg,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),1,Codegen.SIMULATION) 
	  => (Codegen.CFUNCTION(_,_,_,_,_,_,stmt_strs,_),_) &
	Util.string_delimit_list(stmt_strs,"\n") => res
	---------------
	build_block(dae,dlow as DAELow.DAELOW(_,_,eqns,_,_,_,alg,_),ass1,as2,block as e::_) 
	  => res

  rule	print "#Solving of equation systems not implemented yet.\n"
	--------------------------
	build_block(dae,dlow,ass1,ass2,block) => fail
end

(** relation: all_same_algorithm
 **
 ** Checks that a block consists only of one algorithm in different -nodes-
 **)
relation all_same_algorithm: (DAELow.DAELow,
			      int list) (* blocks*)
	  => bool =

  rule	(* extract index of first algorithm and check that entire block
	 * has that index. *)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,_,_) &
	all_same_algorithm2(dlow, block,indx) => res
	----------------------
	all_same_algorithm(dlow as DAELow.DAELOW(_,_,eqns,_,_,_,alg,_),block as e::_) 
	  => res

  axiom	all_same_algorithm(_,_) => false
end

(** relation: all_same_algorithm2
 **
 ** Helper relation to all_same_algorithm. Checks all equations in the block
 ** and returns true if they all are algorithms with the same index. 
 **)
relation all_same_algorithm2:(DAELow.DAELow, 
			      int list, (* block *)
			      int (* alg. index*)) => bool =
  axiom	all_same_algorithm2(_,[],_) => true

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => true &
	all_same_algorithm2(dlow,es,indx) => b1 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,_,alg,_),e::es,indx) => b1

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => false 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,_,alg,_),e::es,indx) => false

  axiom	all_same_algorithm2(_,_,_) => false

end

(** relation: build_non_discrete_equation
 **
 ** Builds code for non_discrete equations only.
 ** Used in build_solved_blocks.
 **)

relation build_non_discrete_equation:(DAE.DAElist, DAELow.DAELow, int vector, int vector, int,int (*cg var_id*)) => (CFunction,int(*cg var_id*)) =

  rule	int_sub(e,1) => e' &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (v) &  
	has_discrete_var([v]) => true 
	--------------------------------
	build_non_discrete_equation(_,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_,_),_,ass2,e,cg_id) => (Codegen.c_empty_function,cg_id)
      
  rule	build_equation(dae,dlow,ass1,ass2,eqn,cg_id) => (cfunc,cg_id')
	----------------------------------------
	build_non_discrete_equation(dae,dlow,ass1,ass2,eqn,cg_id) 
	  => (cfunc,cg_id')
end

(** relation build_equation 
 **
 ** This returns the code string for a specific equation in the dae.
 ** It is used both for state variables and regular variables
 **)
relation build_equation:(DAE.DAElist, 
			 DAELow.DAELow, 
			 int vector, (* assignments1*)
			 int vector, (* assignments2*)
			 int, (* equation no*)
			 int) (* cg var_id *)
	  => (CFunction,int (* cg var_id*)) =
	     
  rule  (* Solving for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	DAELow.is_non_state kind => true &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	Exp.print_component_ref_str(origname)=> origname_str &
	build_assignment(dae,cr,simplify_exp,origname_str,cg_id)  => (cfn,cg_id')
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) => (cfn,cg_id')
        
	
  rule	(* Solving the state s means solving for der(s) *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
	let new_varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,new_varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	Exp.print_component_ref_str(origname)=> origname_str &
	build_assignment(dae,cr ,simplify_exp,origname_str,cg_id)  => (cfn,cg_id')
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) => (cfn,cg_id')
	
  rule	(* probably, solved failed in rule above. This means that we have 
	 a non-linear equation. *)
 	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
 	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) => fail

  rule	(* Algorithms *)
	(* Each algorithm should only be genated once.*)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(algs,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),cg_id,Codegen.SIMULATION) 
	  => (cfn,cg_id') 
	-------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,algs,_),ass1,ass2,e,cg_id) => (cfn,cg_id')
        
  rule	Debug.fprint("failtrace","-build_equation failed\n")
	--------------------------------
	build_equation(_,_,_,_,_,_) => fail
end

(** relation: build_residual_blocks
 **
 ** This relation generates code for blocks on residual form, i.e.
 ** g(\dot{x},x,y,t) = 0
 **)
 relation build_residual_blocks:(DAE.DAElist,DAELow.DAELow, 
				 int vector, (* ass1 *)
				 int vector, (* ass2 *)
				 int list list,(* blocks *)
				 int) (* cg var_iter *)
	  => (CFunction,int(*cg var_iter*)) =


  rule	print "-build_residual_blocks failed\n" 
	 -----------------
	 build_residual_blocks(_,_,_,_,_,_) => fail
 end




									

(** relation build_residual_equation 
 **
 ** This relation generates code on residual form for one equation.
 ** It is used both for state variables and algebraic variables.
 **)
relation build_residual_equation:(DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int, (* equation no. *)
				   int (* cg var_id*)
				   
				   ) => (CFunction,int (*cg var_id*)) =
	 
  rule  (* Do not output equations for discrete variables here *)
	 int_sub(e,1) => e' &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (v) &  
	 has_discrete_var([v]) => true 
	 --------------------------------
	 build_residual_equation(_,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_,_),_,ass2,e,cg_id) => (Codegen.c_empty_function,cg_id)
         
  rule  (* Solving for non-states *)
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	 DAELow.is_non_state kind => true &
	 (*print "Solving for non-states\n" &*)
	 let varexp = Exp.CREF(cr,Exp.REAL) &
	 Exp.solve(e1,e2,varexp) => expr &
         Exp.simplify(expr) => simplify_exp &
	 Exp.print_component_ref_str(origname)=> origname_str &
	 build_assignment(dae,cr,simplify_exp,origname_str,cg_id)  => (cfn,cg_id')
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) => (cfn,cg_id')
         
	 
  rule  (* Solving the state s, caluate residual form. *) 
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') 
	  => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
	 int_string(indx) => indx_str &
	 let exp = Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2) &
	 Exp.simplify(exp) => simplify_exp &
	 (* Use array named 'delta' for residuals *)
	 Util.string_append_list(["delta[",indx_str,"]"]) => cr_str &
	 let new_cr = Exp.CREF_IDENT(cr_str,[]) &
	 Exp.print_component_ref_str(origname)=> origname_str &
	 build_assignment(dae,new_cr,simplify_exp,origname_str,cg_id)  => (cfn,cg_id')
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) => (cfn,cg_id')
	 
  rule	(* when-equations are not part of the residual equations *)
        int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e) 
	--------------------------------
	build_residual_equation(_,DAELow.DAELOW(_,_,eqns,_,_,_,_,_),_,_,e,cg_id) 
	  => (Codegen.c_empty_function,cg_id)

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e,cg_id) => fail
         

  rule  Debug.fprint("failtrace","-build_residual_equation failed\n")
	--------------------------------
	build_residual_equation(_,_,_,_,_,_) 
	  => fail
end

(** relation build_assignment 
 **
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)
relation build_assignment: (DAE.DAElist,
			    Exp.ComponentRef, (* varname *)
			    Exp.Exp, (*expression*) 
			    string, (* orig. name*) 
			    int) (* cg var_id *)
	  => (CFunction,int (*cg var_id *)) =

  rule  Exp.print_component_ref_str(cr) => cr_str &	
	Codegen.generate_expression(exp,cg_id,Codegen.SIMULATION) => (cfn,var,cg_id') &
        Util.string_append_list([cr_str, " = ", var, ";\n"]) => stmt &
	Codegen.c_add_statements(cfn,[stmt]) => cfn
	-------------------------------------------------------------------------
	build_assignment(dae as DAE.DAE(elements),cr,exp as Exp.CALL(path,args,tuple as false,builtin),origname,cg_id) => (cfn,cg_id')


  rule  print "-simcodegen: build_assignment: Tuple return values from functions not implemented\n"
	--------------------------------------------------------------------------
	build_assignment(dae,cr,exp as Exp.CALL(path,args,tuple as true,builtin),origname,cg_id) => fail
	  
  rule  Exp.print_component_ref_str(cr) => cr_str &
	Codegen.generate_expression(exp,cg_id,Codegen.SIMULATION) => (cfn,var,cg_id') &
        Util.string_append_list([cr_str, " = ", var, ";\n"]) => stmt &
	Codegen.c_add_statements(cfn,[stmt]) => cfn
        --------------------------------
	build_assignment(dae,cr,exp,origname,cg_id) => (cfn,cg_id')
        
  rule	print "-build_assignment failed\n" 
	------------------------
	build_assignment(dae,cr,exp,origname,cg_id) => fail
end


(** relation: print_exp_cpp_str
 **
 ** This relation prints a complete expression on a C/C++ format.
 **)
relation print_exp_cpp_str : Exp.Exp => string =
         
  rule  print_exp2_str (e,0) => s
	--------------------
	print_exp_cpp_str e => s
         
 end

(** relation: lbinop_symbol
 **
 ** Helper relation to print_exp2_str
 **)
relation lbinop_symbol : Exp.Operator => string =

  axiom	lbinop_symbol(Exp.AND) => " && "

  axiom	lbinop_symbol(Exp.OR) => " || "

end

(** relation: lunaryop_symbol
 **
 ** Helper relation to print_exp2_str
 **)
relation lunaryop_symbol : Exp.Operator => string =
  axiom	lunaryop_symbol(Exp.NOT) => " !"
end

(** relation: relop_symbol
 **
 ** Helper relation to print_exp2_str
 **)
relation relop_symbol : Exp.Operator => string =
  axiom	relop_symbol(Exp.LESS(_))       => " < "
  axiom	relop_symbol(Exp.LESSEQ(_))     => " <= "
  axiom	relop_symbol(Exp.GREATER(_))    => " > "
  axiom	relop_symbol(Exp.GREATEREQ(_))  => " >= "
  axiom	relop_symbol(Exp.EQUAL(_))      => " == "
  axiom	relop_symbol(Exp.NEQUAL(_))     => " != "
end


(**relation define_string_to_modelica_string
 **removes the $... from the string and replace the DAELow.derivative_name_prefix to "der"
 ** removes the """ and replaces with "\"" (in case of nestled divisions)
 ** author x02lucpo
 **)
relation define_string_to_modelica_string : (string) => string =

  rule  Util.c_str_to_modelica_string(part_eqn) => part_eqn0 &
        (* replace """ with ""  *)
        System.stringReplace(part_eqn0,"\"","") => part_eqn1 &
        (*replace derivative prefix with der*)
        System.stringReplace(part_eqn1,DAELow.derivative_name_prefix,"der") => part_eqn2 &
        (*replace $$ with ##. this is to be able to replace $ with ""*)
        (* there are som variables that have the name $$dummy *)
        System.stringReplace(part_eqn2,"$$","##") => part_eqn3 &
        System.stringReplace(part_eqn3,"$","") => part_eqn4 &
        (*replace back ## with $. *)
        System.stringReplace(part_eqn4,"##","$") => part_eqn'
        -----------------------------
        define_string_to_modelica_string(part_eqn) => part_eqn'

end

(** relation generate_division_macro
 ** this generates a division macro of the form:
 ** "DIVISION(1.0,a$point$b*c,"1.0/a.b*c")"
 ** author x02lucpo
 **)
relation generate_division_macro:(string, (* nominator *)
                                 string) (* denominator *)
          => string =

  rule  Util.string_append_list([s1,"/",s2]) => part_eqn &
        (* print "befor: " & print part_eqn & print "\n" & *)
        define_string_to_modelica_string(part_eqn) => part_eqn' &
        (* print "after: " & print part_eqn' & print "\n" & *)
        Util.string_append_list(["DIVISION(", s1,",",s2,",\"",part_eqn',"\")"]) => res 
        
        ----------------------------
        generate_division_macro(s1,s2) => res
end

(** relation: print_exp2_str
 ** Helper relation to print_exp_str
 **)
relation print_exp2_str : (Exp.Exp,int) => string =

  rule  print "# equation contain undefined symbols"
        --------------------------
        print_exp2_str(Exp.END,_) => fail
         
  rule  int_string(x) => s
	 ----------------------------
         print_exp2_str(Exp.ICONST(x),_) => s
         
  rule  real_string(x) => s
	 -----------------------------
         print_exp2_str(Exp.RCONST(x),_) => s

  rule  string_append ("\"", s) => s' &
	 string_append (s', "\"") => s''
         ---------------------------------
         print_exp2_str(Exp.SCONST(s),_) => s''
         
  axiom print_exp2_str(Exp.BCONST(false),_) => "false"

  axiom	print_exp2_str(Exp.BCONST(true),_) => "true"


  rule	Exp.print_component_ref_str c => res 
        --------------------------------
        print_exp2_str(Exp.CREF(c,_),_) => res

  rule  Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority(op) => pri2' &
         int_add(pri2',1) => pri2 & (* binary minus have higher priority than itself *)
         Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
         print_exp2_str (e1,pri3) => s2 & 
         print_exp2_str (e2,pri2) => s3 &
         Exp.print_rightpar_str (pri1,pri2) => s4 &
         string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22)),pri1) => s'''

  rule	(* x^2 => x*x *)
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.ICONST(2)),pri1) => res
	 
  rule	(* x^2 => x*x *)
	 int_real(2) => two' &
	 real_eq(two,two) => true &
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.RCONST(two)),pri1) => res

  rule	Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
         string_append("pow(",s) => s' &
         string_append(s',",") => s'' &
         string_append(s'',s3) => s''' &
         string_append(s''',")") => res &
	 string_append (res, s4) => res'
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), e2),pri1) => res'

  rule	Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 &
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
         generate_division_macro(s2,s3) => res'
(* 	 string_append ("DIVISION(", s2) => s & *)
(*          string_append(s1,s) => s' & *)
(*          string_append(s',",") => s'' & *)
(*          string_append(s'',s3) => s''' & *)
(*          string_append(s''',")") => res & *)
(* 	 string_append (res, s4) => res' *)
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.DIV(_)), e2),pri1) => res'

  rule	Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op, e2),pri1) => s'''

  rule	Exp.unaryop_symbol(op) => sym &
	 Exp.unaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ----------------------------
	 print_exp2_str(Exp.UNARY(op, e),pri1) => s''

  rule	 lbinop_symbol(op) => sym &
	 Exp.lbinop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ----------------------------------------------------------------
	 print_exp2_str(Exp.LBINARY(e1, op, e2),pri1) => s'''

  rule	 lunaryop_symbol(op) => sym &
 	 Exp.lunaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ---------------------------------------------------
	 print_exp2_str(Exp.LUNARY(op, e),pri1) => s''

  rule	 relop_symbol(op) => sym &
 	 Exp.relop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str(e1,pri3) => s2 & 
	 print_exp2_str(e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -----------------------------------------------------------------
	 print_exp2_str(Exp.RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	 print_exp2_str(t,0) => thenstr &
	 print_exp2_str(f,0) => elsestr &
	 string_append ("(( ", ifstr) => s &
	 string_append (s, " ) ? ( ") => s' &
	 string_append (s', thenstr) => s'' &
	 string_append (s'', " ) : ( ") => s''' &
	 string_append (s''', elsestr) => s'''' &
	 string_append (s'''', " )) ") => slast 
	 ----------------------------
	 print_exp2_str(Exp.IFEXP(c,t,f),_) => slast
	 
	 (* abs using the fabs libc function *)
  rule	Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list(["fabs(", argstr, ")"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(Absyn.IDENT("abs"), args,_,builtin as true),_) => s

  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list([fs, "(", argstr, ")"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as true),_) => s

	 (* user defined Modelica functions, incl. external starts with an
	  ** underscore, to distringuish betweeen the lib function for external
	  ** functions and the wrapper function. *)
  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list(["_",fs, "(", argstr, ").",fs,"_rettype_1"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as false),_) => s

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("{",s) => s' &
	 string_append (s',"}") => s''
	 -----------------------------
	 print_exp2_str (Exp.ARRAY(_,_,es),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("(",s) => s' &
	 string_append (s',")") => s''
	 -----------------------------
	 print_exp2_str (Exp.TUPLE(es),_) => s''
	 
  rule	Exp.print_list_str(es, Exp.print_row_str, "},{") => s &
	 string_append ("{{",s) => s' &
	 string_append (s',"}}") => s''
	 -----------------------------
	 print_exp2_str (Exp.MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (stop,pri3) => s3 &
 	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -------------------------------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1,pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (step,pri3) => s3 &
 	 print_exp2_str (stop,pri3) => s4 &
 	 Exp.print_rightpar_str (pri1,pri2) => s5 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', ":") => s''' &
	 string_append (s''', s4) => s'''' &
	 string_append (s'''', s5) => s'''''
	 -------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelicaOutput => false &
	 int_real ival => rval &
	 real_string rval => res
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.ICONST(ival)),_) => res

  rule	RTOpts.modelicaOutput => false &
	 int_real ival => rval &
	 real_string rval => res &
	 string_append("-",res) => res2
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival))),_) => res2

  rule	RTOpts.modelicaOutput => false &
	 print_exp_cpp_str e => s & 
	 string_append ("(float)(", s) => s' &
	 string_append (s', ")") => s''
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s''

  rule	RTOpts.modelicaOutput => true &
	 print_exp_cpp_str e => s
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s

  rule	let pri2 = 51 &
         Exp.get_cref_from_exp(e) => cref_list &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
 	 Exp.print_rightpar_str (pri1,pri2) => s3 &
 	 int_string i => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, s3) => s' &
	 string_append (s', "[") => s'' &
	 string_append (s'', s4) => s''' &
	 string_append (s''', "]") => s''''
	 ---------------------------------------
	 print_exp2_str (Exp.ASUB(e,i),pri1) => s''''

  rule	print_exp_cpp_str cr => crstr &
	 print_exp_cpp_str dim => dimstr &
	 Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_cpp_str cr => crstr &
	 Util.string_append_list(["size(",crstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	 print_exp_cpp_str exp => expstr &
	 print_exp_cpp_str iterexp => iterstr &
	 Util.string_append_list(["<reduction>",
				  fs,"(",expstr," for ",
				  id," in ",iterstr,")"]) => str
	 -------------------------------------------------------
	 print_exp2_str (Exp.REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

 end

(** relation: cref_modelica_str
 **
 ** Converts Exp.ComponentRef, i.e. variables, to Modelica friendly variables.
 ** This means that dots are converted to underscore, etc.
 **)
relation cref_modelica_str : Exp.ComponentRef => string =

  rule  Util.string_replace_char(s,#".",#"_") => res' &
        Util.string_replace_char(res',#"[",#"_") => res'' &
        Util.string_replace_char(res'',#"]",#"_") => res''' 
        (* & Util.string_append_list(["_",res,"_"]) => res'*)
        ------------------------------
        cref_modelica_str(Exp.CREF_IDENT(s,_)) => res'''
        
  rule	cref_modelica_str(n) => ns &
(*  	string_append(s,"_") => s1 &  *)
	string_append(s(*s1*),ns) => ss
	-------------------------------------
	 cref_modelica_str(Exp.CREF_QUAL(s,_,n)) => ss
end


(** relation: get_called_functions
 **
 ** Goes through the DAELow structure, finds all function calls and returns 
 ** them in a list. Removes duplicates.
 **)
relation get_called_functions : (DAE.DAElist, DAELow.DAELow) => Absyn.Path list =

  rule	DAELow.get_all_exps dlow => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res
	-------------------------------------
	get_called_functions (dae, dlow) => res
	
end

(** relation: get_called_functions_in_functions
 **
 ** Goes through the given DAE, finds the given functions and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list =

  rule	Util.list_map_1(paths, get_called_functions_in_function, dae) => pathslist &
	Util.list_flatten(pathslist) => res
	-------------------------------------
	get_called_functions_in_functions (paths,dae) => res
end

(** relation: get_called_functions_in_function 
 **
 ** Goes through the given DAE, finds the given function and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list =

	(* Don't fail here, ceval will generate the function later *)
  rule	DAE.get_named_function(path, elements) => [] &
	Absyn.path_string path => pathstr &	
	Error.add_message(Error.LOOKUP_ERROR,[pathstr,"global scope"])
	---------------------------------------------------
	get_called_functions_in_function (path,DAE.DAE(elements)) => []


  rule	DAE.get_named_function(path, elements) => funcelems &
	DAE.get_all_exps funcelems => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res1 &
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(res1, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	get_called_functions_in_functions (res1, dae) => res2 &
	list_append(res1,res2) => res	
	---------------------------------------------------
	get_called_functions_in_function (path, dae as DAE.DAE(elements)) => res

end


(** relation: is_not_builtin_call
 **
 ** return true if the given Exp.CALL is a call but not to a builtin function.
 ** checks the builtin flag in Exp.CALL
 **)
relation is_not_builtin_call : Exp.Exp => bool =

  rule	bool_not(builtin) => res
	------------------
	is_not_builtin_call Exp.CALL(_,_,_,builtin) => res

  axiom	is_not_builtin_call e => false

end

(** relation: get_call_path
 **
 ** Retrive the function name from a CALL expression.
 **)
relation get_call_path : Exp.Exp => Absyn.Path =

  axiom	get_call_path Exp.CALL(path,_,_,_) => path

end

(** relation: remove_duplicate_paths
 **
 ** Removed duplicate Paths in a list of Path.
 **)
relation remove_duplicate_paths : Absyn.Path list => Absyn.Path list =

  axiom	remove_duplicate_paths [] => []


  rule	remove_path_from_list (rest, first) => restwithoutfirst &
	remove_duplicate_paths restwithoutfirst => recresult
	----------------------------------------------------
	remove_duplicate_paths first::rest => first::recresult


end

(** relation: remove_path_from_list
 **
 ** Helper relation to remove_duplicate_paths.
 **)
relation remove_path_from_list : (Absyn.Path list, Absyn.Path) => Absyn.Path list =

  axiom	remove_path_from_list ([],_) => []

  rule	ModUtil.path_equal (first, path) => true &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => res

  rule	ModUtil.path_equal (first, path) => false &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => first::res

end

relation use_zerocrossing: () => bool =

  rule	RTOpts.debugFlag "noevents" => res &
	bool_not(res) => res'
	----------------------------------------
	use_zerocrossing () => res'

end

relation generate_equation_order:(int list list) 
	  => (int list) =

  axiom	generate_equation_order([]) => []

  rule	(* For system of equations skip these *)
	generate_equation_order(blocks) => res 
	-------------------------------------
        generate_equation_order((block as (_::_::_))::blocks) 
	  => (res)
	  
  rule	(* for single equations *)
	generate_equation_order(blocks) => res 
	-------------------------------------
	generate_equation_order((block as [eqn])::blocks) => eqn::res
	
  rule	print "-generate_equation_order failed\n" 
	-----------------
	generate_equation_order(_) => fail
end
