(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 SimCodegen.rml
 ** module:      SimCodegen
 ** description: Generate Simulation code for connecting to solver.
 ** This can be done in two different ways.
 ** 1. Generation of simulation code on residual form. This will generate 
 ** code on the form g(\dot{x},x,y,t)=0.
 ** 2. Generation of simulation code on solved form. This will generate
 ** code on ode form. \dot{x} = f(x,y,t). This means that "function" f will
 ** contain code for solving states from equations, some of them might be 
 ** system of equations, linear or non-linear.
 **
 ** Outputs: the simulation code in C/C++ to a given filename.
 ** Input: DAELow
 ** Uses: DAELow, Absyn, Exp
 **
 **
 ** RCS: $Id$
 **
 **)


module SimCodegen:

  with "DAE.rml"
  with "DAELow.rml"
  with "Absyn.rml"
  with "Exp.rml"

  relation generate_residual_code: (DAE.DAElist,
				    DAELow.DAELow, 		      
				    int vector, (* ass1 *)
				    int vector, (* ass2 *)
				    DAELow.IncidenceMatrix,
				    DAELow.IncidenceMatrixT,
				    int list list, (* blocks*)
				    Absyn.Path,  (* classname *)
				    string) => ()
	  
  relation generate_ode_code: (DAELow.DAELow, Absyn.Path, string) => ()
	  
  relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
				string,real,real,real)  => ()
	  
  relation generate_makefile: (string (*filename*), 
			       Absyn.Path (* classname *)
			       ) => ()
	  
  relation print_exp_cpp_str : Exp.Exp => string 
	  
  relation cref_modelica_str : Exp.ComponentRef => string 
	  
  relation generate_functions: (DAE.DAElist, DAELow.DAELow, Absyn.Path, string) => ()

  relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list
  relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list
	  
end


with "Util.rml"
with "RTOpts.rml"
with "Debug.rml"
with "System.rml"
with "Values.rml"
with "Codegen.rml"
with "Print.rml"
with "ModUtil.rml"

(** relation generate_makefile
 ** This relation generates a makefile for the simulation code.
 ** It uses OPENMODELICAHOME as a reference to find c_runtime with libraries.
 **)
relation generate_makefile: (string, Absyn.Path) => () =
			     
  rule	Absyn.path_string(class) => cname &
	Util.string_append_list([cname,".cpp"]) => cpp_file &
	Util.string_append_list(["#Makefile generated by OpenModelica\n\n",
				 "CXX=g++\n",
				 cname,": ",cpp_file, "\n",
				 "\t $(CXX) -o ",cname," ",cpp_file, 
				 " -L$(OPENMODELICAHOME)/c_runtime/",
				 " -I$(OPENMODELICAHOME)/c_runtime/ ",
				 " -lsim -lg2c -lc_runtime\n"
				 ]) => str &
	System.write_file(filename,str) 
	-------------------------
	generate_makefile(filename,class)
end


(** relation generate_residual_code
 ** Outputs simulation code from a DAELow suitable for connection to DASSL.
 ** The state calculations are generated on residual form, i.e. 
 ** g(\dot{x},x,y,t) = 0.
 **)
relation generate_residual_code: (DAE.DAElist,
				  DAELow.DAELow, 		      
				  int vector, (* ass1 *)
				  int vector, (* ass2 *)
				  DAELow.IncidenceMatrix,
				  DAELow.IncidenceMatrixT,
				  int list list, (* blocks*)
				  Absyn.Path,  (* classname *)
				  string) => () =

  rule	Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_global_data(class,dlow) => cglobal &  
        generate_compute_output(cname,dae,dlow,ass1,ass2,blt_no_states) 
	  => coutput &
        generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blt_states) 
	  => cstate &
	generate_when_clauses(cname,dae,dlow,ass1,ass2,comps) => cwhen &
	string_append(cname,"_functions.cpp") => funcfilename &
	Util.string_append_list(["//Simulation code for ",cname,
				 "\n//Generated by OpenModelica.\n",
				 "\n#include \"modelica.h\"\n",
				 "\n#include \"",funcfilename,"\"\n",
				 cglobal,coutput,cstate,cwhen]) => res &
	System.write_file(filename,res) 
	---------------------------------------------------------------------
	generate_residual_code(dae,dlow,ass1,ass2,m,mt,comps,class,filename) => ()


  rule	print "-generate_residual_code failed\n" 
	-----------------------
	generate_residual_code(_,_,_,_,_,_,_,_,_) => fail
end

(** relation: generate_global_data
 ** This relation generates the C-code for the global data: arrays for states, derivatives
 ** and algebraic variables, etc.
**)
relation generate_global_data:(Absyn.Path,DAELow.DAELow) => string  =

  rule	DAELow.calculate_sizes(dlow) => (nx,ny,np) &
	Absyn.path_string(class) => class_str &
	int_string(nx) => nx_str &
	int_string(ny) => ny_str &
	int_string(np) => np_str &
	generate_var_names(dlow,nx,ny) => varnames &
	Util.string_append_list(["\n",
				 "#define NX ",nx_str,"\n",
				 "#define NY ",ny_str,"\n",
				 "#define NP ",np_str,"\n",
				 "#define MAXORD 5\n",
				 "#define time (*t)\n",
				 "\n",
				 "double x[NX];\n",
				 "double xd[NX];\n",
				 "double dummy_delta[NX];\n",
				 "double y[NY];\n",
				 "double p[NP];\n",
				 "double rwork[50+(MAXORD+4)*NX+NX*NX];\n",
				 "long iwork[20+NX];\n",
				 "long liw = 20+NX;\n",
				 "long lrw = 50+(MAXORD+4)*NX+NX*NX;\n",
				 "long nx = NX;\n",
				 "long ny = NY;\n",
				 "long np = NP;\n",
				 "char *model_name=\"",class_str,
				 "\";\n",
				 varnames,"\n"]
				 )  => str 
	---------------------------
	generate_global_data(class, dlow) => str
	
end

(** relation: generate_var_names
 ** Generates an array of the original variable names.
 **)
relation generate_var_names:(DAELow.DAELow,int, int) => string =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	generate_var_names_states(var_lst) => state_lst &
	generate_var_names_derivatives(var_lst) => der_lst &
	generate_var_names_algvars(var_lst) => algvar_lst &
	Util.list_flatten([state_lst,der_lst,algvar_lst]) => varnames_lst &
	Util.string_delimit_list(varnames_lst,", ") => str &
	int_add(nx,nx) => nxtwo &
	int_add(ny,nxtwo) => tot_elts &
	int_string(tot_elts) => tot_elts_str & 

	Util.string_append_list(["char* varnames[",tot_elts_str,"] = {",
				 str, "};\n"]) => res
	-------------------
	generate_var_names(DAELow.DAELOW(vars,knvars,_,_,_,_,_),nx,ny) => res

end

(** relation: generate_var_names_states
 ** Helper relation to generate_var_names
 **)
relation generate_var_names_states:(DAELow.Var list) => string list =

  axiom	generate_var_names_states([]) => []
	
  rule	generate_var_names_states(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_var_names_states(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_states(vs) => res 
	-----------------------
	generate_var_names_states(_::vs)
	  => res
end

(** relation: generate_var_names_derivatives
 ** Helper relation to generate_var_names
 **)
relation generate_var_names_derivatives:(DAELow.Var list) => string list =

  axiom	generate_var_names_derivatives([]) => []
	
  rule	generate_var_names_derivatives(vs) => res &
	Util.string_append_list(["\"der(",origname,")\""]) => origname'
	-----------------------
	generate_var_names_derivatives(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_derivatives(vs) => res 
	-----------------------
	generate_var_names_derivatives(_::vs)
	  => res
end

(** relation: generate_var_names_algvars
 ** Helper relation to generate_var_names
 **)
relation generate_var_names_algvars:(DAELow.Var list) => string list =

  axiom	generate_var_names_algvars([]) => []
	
  rule	generate_var_names_algvars(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_var_names_algvars(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_algvars(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_var_names_algvars(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_algvars(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_var_names_algvars(DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_algvars(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_var_names_algvars(DAELow.VAR(cr,DAELow.DUMMY_STATE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_algvars(vs) => res &
	Util.string_append_list(["\"",origname,"\""]) => origname'
	-----------------------
	generate_var_names_algvars(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::vs)
	=> origname'::res

  rule	generate_var_names_algvars(vs) => res 
	-----------------------
	generate_var_names_algvars(_::vs)
	  => res
end

(** relation generate_ode_code
 ** Outputs simulation code from a DAELow. 
 ** The state calculations are generated on explicit ode form: 
 ** x_dot := f(x,y,t)
**)
relation generate_ode_code: (DAELow.DAELow, Absyn.Path, string) => () =

  rule	
	-------------------------------------------
	generate_ode_code(dlow,class,filename) => ()
end

(** relation generate_functions
 **
 ** Finds the called functions in daelow and generates code for them
 ** from the given DAE. Hence, the functions must exist in the DAE.Element list.
**)
relation generate_functions: (DAE.DAElist, DAELow.DAELow, Absyn.Path, string) => () =

  rule	get_called_functions(dae, dlow) => funcpaths & 
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(funcpaths, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	Util.list_map_1(funcpaths, DAE.get_named_function, elements) => funcelems &
	Util.list_flatten(funcelems) => funcelems &
	Print.get_string => debugstr &
	Print.clear_buf &
	Codegen.generate_functions(DAE.DAE(funcelems)) &
	Print.write_buf(filename)
	--------------------------------------------------
	generate_functions (dae as DAE.DAE(elements), dlow, path, filename)


  rule	print "-generate_functions failed\n" 
	-------------------------------------
	generate_functions (_, _, _, _) => fail

end


(** relation generate_init_data
 ** This relation generates initial values for the simulation
 ** by investigating values of variables.
 **)
relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
			      string(* filename *),
			      real, (* start time*)
			      real, (* stop time *)
			      real) (* step size *)
	  => () =

   rule	real_string(start) => start_str &
	real_string(stop) => stop_str &
	real_string(step) => step_str &
 	DAELow.calculate_sizes(dlow) => (nx,ny,np) &
 	int_string(nx) => nx_str &
 	int_string(ny) => ny_str &
 	int_string(np) => np_str &
 	generate_init_data2(dlow,nx,ny,np) => init_str &
 	Util.string_append_list([start_str, " // start value\n",
				 stop_str, " // stop value\n",
 				 step_str, " // step value\n",
 				 nx_str, " // n states\n",
 				 ny_str, " // n alg vars\n",
 				 np_str, " //n parameters\n",
 				 init_str]) => str &
 	System.write_file(filename,str) 
 	--------------------------
 	generate_init_data(dlow,class,filename,start,stop,step)

  rule	print "-generate_init_data failed\n"
 	------------------------------------
	generate_init_data(_,_,_,_,_,_) => fail
end

(** relation: generate_init_data2
 ** Helper relation to generate_init_data
 ** Generates init data for states, variables and parameters.
 ** nx - number of states.
 ** ny - number of alg. vars. 
 ** np - number of parameters.
 **)
relation generate_init_data2:(DAELow.DAELow,
			      int(*nx*),
			      int(*ny*),
			      int(*np*)) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	array_create(nx,"") => nxarr &
	array_create(nx,"0.0") => nxdarr &
	array_create(ny,"") => nyarr &
	array_create(np,"") => nparr &
	generate_init_data3(var_lst,nxarr,nxdarr,nyarr,nparr) 
	  =>(nxarr',nxdarr',nyarr',nparr') &
	generate_init_data4(knvar_lst,nxarr',nxdarr',nyarr',nparr')  
	  =>(nxarr'',nxdarr'',nyarr'',nparr'') &
	array_list(nxarr'') => nx_lst &
	array_list(nxdarr'') => nxd_lst &
	array_list(nyarr'') => ny_lst &
	array_list(nparr'') => np_lst &
	Util.list_flatten([nx_lst,nxd_lst,ny_lst,np_lst]) => whole_lst &
	Util.string_delimit_list(whole_lst,"\n") => res
	-----------------------------
	generate_init_data2(DAELow.DAELOW(vars,knvars,_,_,initeqn,alg,_),nx,ny,np) => res

end

(** relation: print_exp_str_opt
 ** Helper relation to generate_init_data2
 ** Prints expression value that is opional for initial values.
 ** If NONE is passed. The default value 0.0 is returned.
 **)
relation print_exp_str_opt: Exp.Exp option => string =

  axiom	print_exp_str_opt NONE => "0.0"

  rule	Exp.print_exp_str e => str 
 	--------------------------
 	print_exp_str_opt SOME(e) => str 
end

(** relation generate_init_data3
 ** This relation is a help relation to generate_init_data2
 ** It Traverses Var lists and adds initial values to the specific
 ** string array depending on the type of the variable.
 ** For instance, state variables write their start value to the
 ** x array at given index.
**)
relation generate_init_data3:(DAELow.Var list,
			      string array, (* state strings *)
			      string array, (* derivative strings*)
			      string array, (* alg. var strings *)
			      string array) (* param. strings *)
	  => (string array, (* updated state strings *)
	      string array, (* updated derivative strings*)
	      string array, (* updated alg. var strings *)
	      string array) (* updated param. strings *)
	=

  axiom	generate_init_data3([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,value,indx,origname,_,dae_var_attr,comment)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

   rule	(* State variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nxarr,indx,str) => nxarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)
	--------------------
	 generate_init_data3(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,value,indx,origname,_,dae_var_attr,comment)::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* dummy derivatives => algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,value,indx,origname,_,dae_var_attr,comment)::rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)

  rule	(* Dummy states => algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
 	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,
				       _,value,indx,origname,_,dae_var_attr,comment)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)
end

(** relation: generate_init_data4
 ** Helper relation to generate_init_data2
** Traverses parameters 
 **)
relation generate_init_data4: (DAELow.Var list, 
			       string array,
			       string array,
			       string array,
			       string array)  
	  => (string array,
	      string array,
	      string array,
	      string array)   =
  axiom	generate_init_data4([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr) 
	
  rule	(* Parameters *)
	Values.val_string(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,SOME(value),_,
				_,indx,origname,_,dae_var_attr,comment)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Parameters without value binding. Should normally not happen *)
	Util.string_append_list(["0.0  // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,NONE,_,
				_,indx,origname,_,dae_var_attr,comment)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Skip alg. vars that are removed 
	 In future we should compare eliminated variables 
	 intial values to their aliases to detect inconsistent
	 initial values.
	 *)
	generate_init_data4(vs,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	-----------------------------------
	generate_init_data4(_::vs,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr',nxdarr',nyarr',nparr')
end


relation dump_when_clauses_str: (DAELow.WhenClause list) => string =

  axiom	dump_when_clauses_str [] => ""

  rule	dump_when_clause_str c => str &
	dump_when_clauses_str xs => str2 &
	string_append(str, str2) => res
	------------------------------
	dump_when_clauses_str c::xs => res
end

relation dump_when_clause_str: (DAELow.WhenClause) => string =

  rule	Exp.print_exp_str exp => str1 &
	Util.string_append_list ["when ", str1, "\n"] => res
	----------------------------------------
	dump_when_clause_str DAELow.WHEN_CLAUSE(exp) => res

end

relation generate_when_clauses: (string,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list) (* blocks *) 
	  => string =
	  
  rule
	build_when_blocks(dae,dlow,ass1,ass2,blocks) => when_str &
	dump_when_clauses_str wc => wcs &
	Util.string_append_list(["/*\n",wcs,when_str,"*/\n"]) => res
	--------------------------------------------------
	generate_when_clauses(cname,dae,dlow as DAELow.DAELOW(_,_,_,_,_,_,wc),ass1,ass2,blocks) => res

  rule	print "-generate_when_clauses failed\n"
	----------------------------------------
	generate_when_clauses(_,_,_,_,_,_) => fail
end

relation build_when_blocks : (DAE.DAElist,DAELow.DAELow, int vector, int vector, int list list) => string =

  axiom build_when_blocks(_,_,_,_,[]) => ""

  rule	build_when_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	build_when_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str2 &
	string_append(eqn_str, eqn_str2) => res
	----------------------------------------
	build_when_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => res

  axiom build_when_blocks(_,_,_,_,_) => ""

  rule	print "-generate_when_blocks failed\n" 
	----------------------------------------
	build_when_blocks(_,_,_,_,_) => fail
end

relation build_when_equation: (DAE.DAElist,
			       DAELow.DAELow, 
			       int vector, (* assignments1*)
			       int vector, (* assignments2*)
			       int (* equation no. *)
			       ) => string =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e as DAELow.WHEN_EQ(_,cr,expr)) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment)) &  
	build_assignment(dae,cr,expr,origname) => assignment_string
	--------------------------------
	build_when_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assignment_string

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e as DAELow.WHEN_EQ(_,cr,expr)) &
	print "-build_when_equation failed\n"
	----------------------------------------
	build_when_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail

	axiom build_when_equation(_,_,_,_,_) => ""
end
	

(** relation: generate_compute_residual_state
 ** This relation generates the code for the calculation of the 
 ** state variables on residual form. Called from generate_residual_code.
 **)
relation generate_compute_residual_state:(string,
					  DAE.DAElist,
					  DAELow.DAELow,
					  int vector, (* assignments1 *) 
					  int vector, (* assignments2 *)
					  int list list) (* blocks *) 
	  => string =
          
  rule	
        build_residual_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str_list &
        Util.string_append_list(eqn_str_list) => cstate &
        Util.string_append_list(["int\nfunctionDAE_res(double *t, double *x, double *xd, double *delta, long int *ires, double *rpar, long int* ipar)\n{\n",cstate,"\n}\n"]) 
	  => res
        -------------------------------------------------------------
        generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blocks) => res
end


(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output
 ** variables.
 **)
 relation generate_compute_output:(string,
				   DAE.DAElist,
                                   DAELow.DAELow,
                                   int vector, 
                                   int vector, 
                                   int list list) => string =
         
  rule	let func_header = "int\nfunctionDAE_output(double *t, double* x, double* xd, double* y)\n{\n" &
	 let func_footer = "\n}\n" &
	 build_solved_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str_lst &
	 Util.list_flatten([[func_header],eqn_str_lst,[func_footer]]) => res &
         Util.string_append_list(res) => coutput 
         -------------------------------------------------------------
         generate_compute_output(cname,dae,dlow,ass1,ass2,blocks) => coutput
 end

(** relation: build_solved_blocks
 ** This relation generates code for blocks on solved form, i.e. 
 ** \dot{x} = f(x,y,t) 
 **)
relation build_solved_blocks:(DAE.DAElist,
			      DAELow.DAELow, 
			      int vector, (* assignments1*)
			      int vector, (* assignments2*)
			      int list list (* list of blocks *)) 
	  => string list =

  axiom	build_solved_blocks(_,_,_,_,[]) => []
	     
  rule	(* for single equations *)
	 build_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	 build_solved_blocks(dae,dlow,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_solved_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res
	 

  rule	(* for blocks *)
	build_block(dae,dlow,ass1,ass1,block) => block_str &
	build_solved_blocks(dae,dlow,ass1,ass2,blocks) => res
	 ------------------
	build_solved_blocks(dae,dlow,ass1,ass2,block::blocks) => block_str::res

  rule	print "-build_solved_blocks failed\n" 
	 -----------------
	 build_solved_blocks(_,_,_,_,_) => fail
 end

(* relation: build_block
 ** This relation returns the code string for solving a block of variables 
 ** in the dae, i.e. a set of coupled equations.
 ** It is used both for state variables and algebraic variables.
**)

relation build_block: (DAE.DAElist,
		       DAELow.DAELow, 
		       int vector, (* assignments1 *)
		       int vector, (* assignments2 *)
		       int list) (* block of equations*)
	  => string =

  rule	all_same_algorithm(dlow,block) => true &
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(alg,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),1) 
	  => (Codegen.CFUNCTION(_,_,_,_,_,_,stmt_strs,_),_) &
	Util.string_delimit_list(stmt_strs,"\n") => res
	---------------
	build_block(dae,dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),ass1,as2,block as e::_) 
	  => res

  rule	print "#Solving of equation systems not implemented yet.\n"
	--------------------------
	build_block(dae,dlow,ass1,ass2,block) => fail
end

(** relation: all_same_algorithm
 ** Checks that a block consists only of one algorithm in different -nodes-
**)
relation all_same_algorithm: (DAELow.DAELow,
			      int list) (* blocks*)
	  => bool =

  rule	(* extract index of first algorithm and check that entire block
	 * has that index. *)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,_,_) &
	all_same_algorithm2(dlow, block,indx) => res
	----------------------
	all_same_algorithm(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),block as e::_) 
	  => res

  axiom	all_same_algorithm(_,_) => false
end

(** relation: all_same_algorithm2
 ** Helper relation to all_same_algorithm. Checks all equations in the block
 ** and returns true if they all are algorithms with the same index. 
 **)
relation all_same_algorithm2:(DAELow.DAELow, 
			      int list, (* block *)
			      int (* alg. index*)) => bool =
  axiom	all_same_algorithm2(_,[],_) => true

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => true &
	all_same_algorithm2(dlow,es,indx) => b1 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),e::es,indx) => b1

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => false 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),e::es,indx) => false

  axiom	all_same_algorithm2(_,_,_) => false

end

(** relation build_equation 
 ** This returns the code string for a specific equation in the dae.
 ** It is used both for state variables and regular variables
 **)
relation build_equation:(DAE.DAElist, DAELow.DAELow, int vector, int vector, int) => string =
	     
  rule  (* Solving for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment)) &  
	DAELow.is_non_state kind &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
        
        Exp.simplify(expr) => simplify_exp &
	build_assignment(dae,cr,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string	
        
	
  rule	(* Solving the state s means solving for der(s) *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment) &
	let new_varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,new_varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	build_assignment(dae,cr ,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string 
	
  rule	(* probably, solved failed in rule above. This means that we have 
	 a non-linear equation. *)
 	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
 	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail

  rule	(* Algorithms *)
	(* Each algorithm should only be genated once.*)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(algs,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),1) 
	  => (Codegen.CFUNCTION(_,_,_,_,_,_,stmt_strs,_),_) &
	Util.string_delimit_list(stmt_strs,"\n") => res
	-------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,algs,_),ass1,ass2,e) => res 
        
  rule	print "-build_equation failed\n" 
	--------------------------------
	build_equation(_,_,_,_,_) => "//build_equation failed\n" 
end

(** relation build_residual_blocks
 ** This relation generates code for blocks on residual form, i.e.
 ** g(\dot{x},x,y,t) = 0
 **)
 relation build_residual_blocks:(DAE.DAElist,DAELow.DAELow, int vector, int vector, int list list) => string list =

  axiom	build_residual_blocks(_,_,_,_,[]) => []
	 
  rule	(* For system of equations *) 
	 build_residual_system(dae,dlow,ass1,ass2,block) => eqn_str &
	 build_residual_blocks(dae,dlow,ass1,ass2,blocks) => res 
	 -------------------------------------
	 build_residual_blocks(dae,dlow,ass1,ass2,(block as (_::_::_))::blocks) 
	  => eqn_str::res
	 
  rule	(* for single equations *)
	 build_residual_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	 build_residual_blocks(dae,dlow,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_residual_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res

  rule	print "-build_residual_blocks failed\n" 
	 -----------------
	 build_residual_blocks(_,_,_,_,_) => fail
 end

(** relation build_residual_system
 ** A system of equations on residual form is still only an output of each residual
 ** equation. The numerical solver will solve the system.
**)
relation build_residual_system: (DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int list (* equation no. *)
				   ) => string =

  axiom	build_residual_system(_,_,_,_,[]) => ""

  rule	build_residual_equation(dae,dlow,ass1,ass2,eqn) => s1 &
	build_residual_system(dae,dlow,ass1,ass2,eqns) => s2 &
	string_append(s1,s2) => str
	---------------------------------------------
	build_residual_system(dae,dlow,ass1,ass2,eqn::eqns) => str
end


(** relation build_residual_equation 
 ** This relation generates code on residual form for one equation.
 ** It is used both for state variables and algebraic variables.
 **)
 relation build_residual_equation:(DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int (* equation no. *)
				   ) => string =
	 
  rule  (* Solving for non-states *)
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment)) &  
	 DAELow.is_non_state kind &
	 (*print "Solving for non-states\n" &*)
	 
	 let varexp = Exp.CREF(cr,Exp.REAL) &
	 Exp.solve(e1,e2,varexp) => expr &
         Exp.simplify(expr) => simplify_exp &
	 build_assignment(dae,cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string	
         
	 
  rule  (* Solving the state s, caluate residual form. *) 
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') 
	  => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment) &
	 int_string(indx) => indx_str &
	 let exp = Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2) &
	 Exp.simplify(exp) => simplify_exp &
	 (* Use array named 'delta' for residuals *)
	 Util.string_append_list(["delta[",indx_str,"]"]) => cr_str &
	 let new_cr = Exp.CREF_IDENT(cr_str,[]) &
	 build_assignment(dae,new_cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string 
	 
  rule	(* when-equations are not part of the residual equations *)
        int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e) 
	--------------------------------
	build_residual_equation(_,DAELow.DAELOW(_,_,eqns,_,_,_,_),_,_,e) => ""

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail
         

  rule  print "-build_residual_equation failed\n" 
	--------------------------------
	build_residual_equation(_,_,_,_,_) 
	  => "//build_residual_equation failed\n" 
end

(** relation build_assignment 
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)
relation build_assignment: (DAE.DAElist,
			    Exp.ComponentRef, (* varname *)
			    Exp.Exp, (*expression*) 
			    string) (* orig. name*) 
	  => string =
(*
  rule  Exp.print_component_ref_str(cr) => cr_str &	
        print_exp_cpp_str(exp) => exp_str & 
	DAE.get_named_function(path, elements) => funcdae &
	DAE.get_output_vars funcdae => [outvar] &
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
	-------------------------------------------------------------------------
	build_assignment(dae as DAE.DAElist(elements),cr,exp as Exp.CALL(path,args,tuple as false,builtin),origname) => eqn_str
*)

  rule  Exp.print_component_ref_str(cr) => cr_str &	
        print_exp_cpp_str(exp) => exp_str &
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
	-------------------------------------------------------------------------
	build_assignment(dae as DAE.DAE(elements),cr,exp as Exp.CALL(path,args,tuple as false,builtin),origname) => eqn_str


  rule  print "-simcodegen: build_assignment: Tuple return values from functions not implemented\n"
	--------------------------------------------------------------------------
	build_assignment(dae,cr,exp as Exp.CALL(path,args,tuple as true,builtin),origname) => fail
	  
  rule  Exp.print_component_ref_str(cr) => cr_str &
        print_exp_cpp_str(exp) => exp_str & 
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
        --------------------------------
	build_assignment(dae,cr,exp,origname) => eqn_str
        
  rule	print "-build_assignment failed\n" 
	------------------------
	build_assignment(dae,cr,exp,origname) => fail
end


(** relation: print_exp_cpp_str
 **
 ** This relation prints a complete expression on a C/C++ format.
 **)
 relation print_exp_cpp_str : Exp.Exp => string =
         
  rule  print_exp2_str (e,0) => s
	--------------------
	print_exp_cpp_str e => s
         
 end

relation lbinop_symbol : Exp.Operator => string =
  axiom	lbinop_symbol(Exp.AND) => " && "
  axiom	lbinop_symbol(Exp.OR) => " || "
end

relation lunaryop_symbol : Exp.Operator => string =
  axiom	lunaryop_symbol(Exp.NOT) => " !"
end

relation relop_symbol : Exp.Operator => string =
  axiom	relop_symbol(Exp.LESS(_))       => " < "
  axiom	relop_symbol(Exp.LESSEQ(_))     => " <= "
  axiom	relop_symbol(Exp.GREATER(_))    => " > "
  axiom	relop_symbol(Exp.GREATEREQ(_))  => " >= "
  axiom	relop_symbol(Exp.EQUAL(_))      => " = "
  axiom	relop_symbol(Exp.NEQUAL(_))     => " <> "
end


(** relation: print_exp2_str
 ** Helper relation to print_exp_str
 **)
 relation print_exp2_str : (Exp.Exp,int) => string =

  rule  print "# equation contain undefined symbols"
        --------------------------
        print_exp2_str(Exp.END,_) => fail
         
         
  rule  int_string(x) => s
	 ----------------------------
         print_exp2_str(Exp.ICONST(x),_) => s
         
  rule  real_string(x) => s
	 -----------------------------
         print_exp2_str(Exp.RCONST(x),_) => s

  rule  string_append ("\"", s) => s' &
	 string_append (s', "\"") => s''
         ---------------------------------
         print_exp2_str(Exp.SCONST(s),_) => s''
         
  axiom print_exp2_str(Exp.BCONST(false),_) => "false"

  axiom	print_exp2_str(Exp.BCONST(true),_) => "true"


  rule	Exp.print_component_ref_str c => res
        --------------------------------
        print_exp2_str(Exp.CREF(c,_),_) => res

  rule  Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority(op) => pri2' &
         int_add(pri2',1) => pri2 & (* binary minus have higher priority than itself *)
         Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
         print_exp2_str (e1,pri3) => s2 & 
         print_exp2_str (e2,pri2) => s3 &
         Exp.print_rightpar_str (pri1,pri2) => s4 &
         string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22)),pri1) => s'''

  rule	(* x^2 => x*x *)
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.ICONST(2)),pri1) => res
	 
  rule	(* x^2 => x*x *)
	 int_real(2) => two' &
	 real_eq(two,two) => true &
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.RCONST(two)),pri1) => res

  rule	Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
         string_append("pow(",s) => s' &
         string_append(s',",") => s'' &
         string_append(s'',s3) => s''' &
         string_append(s''',")") => res &
	 string_append (res, s4) => res'
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), e2),pri1) => res'

  rule	Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op, e2),pri1) => s'''

  rule	Exp.unaryop_symbol(op) => sym &
	 Exp.unaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ----------------------------
	 print_exp2_str(Exp.UNARY(op, e),pri1) => s''

  rule	 lbinop_symbol(op) => sym &
	 Exp.lbinop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ----------------------------------------------------------------
	 print_exp2_str(Exp.LBINARY(e1, op, e2),pri1) => s'''

  rule	 lunaryop_symbol(op) => sym &
 	 Exp.lunaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ---------------------------------------------------
	 print_exp2_str(Exp.LUNARY(op, e),pri1) => s''

  rule	 relop_symbol(op) => sym &
 	 Exp.relop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str(e1,pri3) => s2 & 
	 print_exp2_str(e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -----------------------------------------------------------------
	 print_exp2_str(Exp.RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	 print_exp2_str(t,0) => thenstr &
	 print_exp2_str(f,0) => elsestr &
	 string_append ("(( ", ifstr) => s &
	 string_append (s, " ) ? ( ") => s' &
	 string_append (s', thenstr) => s'' &
	 string_append (s'', " ) : ( ") => s''' &
	 string_append (s''', elsestr) => s'''' &
	 string_append (s'''', " )) ") => slast 
	 ----------------------------
	 print_exp2_str(Exp.IFEXP(c,t,f),_) => slast

  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list([fs, "(", argstr, ")"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as true),_) => s

  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list([fs, "(", argstr, ").",fs,"_rettype_1"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as false),_) => s

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("{",s) => s' &
	 string_append (s',"}") => s''
	 -----------------------------
	 print_exp2_str (Exp.ARRAY(_,_,es),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("(",s) => s' &
	 string_append (s',")") => s''
	 -----------------------------
	 print_exp2_str (Exp.TUPLE(es),_) => s''
	 
  rule	Exp.print_list_str(es, Exp.print_row_str, "},{") => s &
	 string_append ("{{",s) => s' &
	 string_append (s',"}}") => s''
	 -----------------------------
	 print_exp2_str (Exp.MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (stop,pri3) => s3 &
 	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -------------------------------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1,pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (step,pri3) => s3 &
 	 print_exp2_str (stop,pri3) => s4 &
 	 Exp.print_rightpar_str (pri1,pri2) => s5 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', ":") => s''' &
	 string_append (s''', s4) => s'''' &
	 string_append (s'''', s5) => s'''''
	 -------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res &
	 string_append("-",res) => res2
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	 print_exp_cpp_str e => s & 
	 string_append ("(float)(", s) => s' &
	 string_append (s', ")") => s''
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	 print_exp_cpp_str e => s
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s

  rule	let pri2 = 51 &
         Exp.get_cref_from_exp(e) => cref_list &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
 	 Exp.print_rightpar_str (pri1,pri2) => s3 &
 	 int_string i => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, s3) => s' &
	 string_append (s', "[") => s'' &
	 string_append (s'', s4) => s''' &
	 string_append (s''', "]") => s''''
	 ---------------------------------------
	 print_exp2_str (Exp.ASUB(e,i),pri1) => s''''

  rule	print_exp_cpp_str cr => crstr &
	 print_exp_cpp_str dim => dimstr &
	 Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_cpp_str cr => crstr &
	 Util.string_append_list(["size(",crstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	 print_exp_cpp_str exp => expstr &
	 print_exp_cpp_str iterexp => iterstr &
	 Util.string_append_list(["<reduction>",
				  fs,"(",expstr," for ",
				  id," in ",iterstr,")"]) => str
	 -------------------------------------------------------
	 print_exp2_str (Exp.REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

 end

(** relation: cref_modelica_str
 ** Converts Exp.ComponentRef, i.e. variables, to Modelica friendly variables.
 ** This means that dots are converted to underscore, etc.
 **)
relation cref_modelica_str : Exp.ComponentRef => string =

  rule  Util.string_replace_char(s,#".",#"_") => res' &
        Util.string_replace_char(res',#"[",#"_") => res'' &
        Util.string_replace_char(res'',#"]",#"_") => res''' 
        (* & Util.string_append_list(["_",res,"_"]) => res'*)
        ------------------------------
        cref_modelica_str(Exp.CREF_IDENT(s,_)) => res'''
        
  rule	cref_modelica_str(n) => ns &
(*  	string_append(s,"_") => s1 &  *)
	string_append(s(*s1*),ns) => ss
	-------------------------------------
	 cref_modelica_str(Exp.CREF_QUAL(s,_,n)) => ss
end


(** relation: get_called_functions
 **
 ** Goes through the DAELow structure, finds all function calls and returns them
 ** in a list. Removes duplicates.
 **)

relation get_called_functions : (DAE.DAElist, DAELow.DAELow) => Absyn.Path list =

  rule	DAELow.get_all_exps dlow => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res1 &
	get_called_functions_in_functions (res1, dae) => res2 &
	list_append(res1,res2) => restemp &
	remove_duplicate_paths restemp => res
	-------------------------------------
	get_called_functions (dae, dlow) => res
	
end

(** relation: get_called_functions_in_functions
 **
 ** Goes through the given DAE, finds the given functions and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list =

  rule	Util.list_map_1(paths, get_called_functions_in_function, dae) => pathslist &
	Util.list_flatten(pathslist) => res
	-------------------------------------
	get_called_functions_in_functions (paths,dae) => res
end

(** relation: get_called_functions_in_function
 **
 ** Goes through the given DAE, finds the given function and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list =

	(* Don't fail here, ceval will generate the function later *)
  rule	DAE.get_named_function(path, elements) => [] &
	Print.print_error_buf("Function not found: ") &
	Absyn.path_string path => pathstr &	
	Print.print_error_buf(pathstr) &
	Print.print_error_buf("\n")
	(*debug*) & Debug.fprint("info", "Function not found: ")
	(*debug*) & Debug.fprintln("info", pathstr)
	---------------------------------------------------
	get_called_functions_in_function (path,DAE.DAE(elements)) => []


  rule	DAE.get_named_function(path, elements) => funcelems &
	DAE.get_all_exps funcelems => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res1 &
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(res1, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	get_called_functions_in_functions (res1, dae) => res2 &
	list_append(res1,res2) => res	
	---------------------------------------------------
	get_called_functions_in_function (path, dae as DAE.DAE(elements)) => res

end


(** relation: is_not_builtin_call
 **
 ** return true if the given Exp.CALL is a call but not to a builtin function.
 ** checks the builtin flag in Exp.CALL
 **)
relation is_not_builtin_call : Exp.Exp => bool =

  rule	bool_not(builtin) => res
	------------------
	is_not_builtin_call Exp.CALL(_,_,_,builtin) => res

  axiom	is_not_builtin_call e => false

end

relation get_call_path : Exp.Exp => Absyn.Path =

  axiom	get_call_path Exp.CALL(path,_,_,_) => path

end


relation remove_duplicate_paths : Absyn.Path list => Absyn.Path list =

  axiom	remove_duplicate_paths [] => []


  rule	remove_path_from_list (rest, first) => restwithoutfirst &
	remove_duplicate_paths restwithoutfirst => recresult
	----------------------------------------------------
	remove_duplicate_paths first::rest => first::recresult


end

relation remove_path_from_list : (Absyn.Path list, Absyn.Path) => Absyn.Path list =

  axiom	remove_path_from_list ([],_) => []

  rule	ModUtil.path_equal (first, path) => true &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => res

  rule	ModUtil.path_equal (first, path) => false &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => first::res


end

