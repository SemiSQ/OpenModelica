(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 TaskGraph.rml
 ** module:      TaskGraph
 ** description: Building of task graphs from expressions, and equation systems.
 **
 ** RCS: %W% %E%
 ** 
 **)

(**
 ** This module is used in the modpar part of OpenModelica for bulding task graphs
 ** from the BLT decomposition for automatic parallelization.
 ** The exported relation 'build_taskgraph' takes the lowered form of the DAE defined in
 ** 'DAELow' and two assignments vectors (which variable is solved in which equation) and
 ** the list of blocks given by the BLT decomposition.

 ** The module uses 'TaskGraphExt' for the task graph datastructure itself, which
 ** is implemented using Boost Graph Library in C++
 *)
module TaskGraph:
  with "Exp.rml"
  with "DAELow.rml"
  relation build_taskgraph: (DAELow.DAELow, int vector, int vector, int list list) => ()

end

with "TaskGraphExt.rml"
with "Util.rml" 
with "Absyn.rml"
with "DAE.rml"
with "Values.rml"
with "Print.rml"
with "VarTransform.rml"
with "SimCodegen.rml"

relation build_taskgraph: (DAELow.DAELow,  int vector, int vector, int list list) => () =

  rule	print "starting buildtaskgraph\n" &
	TaskGraphExt.new_task("start") => starttask &
	TaskGraphExt.new_task("end") => endtask &
	TaskGraphExt.set_execcost(starttask,1.0) &
	TaskGraphExt.set_execcost(starttask,1.0) &
	TaskGraphExt.register_startstop(starttask,endtask) &
	DAELow.vararray_list(vararr) =>  vars &
	DAELow.vararray_list(knvararr) => knvars &
	add_variables(vars,starttask) &
	add_variables(knvars,starttask) &
	add_variables([DAELow.VAR(Exp.CREF_IDENT("sim_time",[]),DAELow.VARIABLE,
                              DAE.INPUT,DAE.REAL,NONE,NONE,[],NONE,0,"time",[],NONE,NONE,DAE.NON_CONNECTOR)],starttask) &
	build_blocks(dae,ass1,ass2,blocks) &
	print "done building taskgraph, about to build inits.\n" &
	build_inits(dae) 
	& print "leaving build_taskgraph\n" 
	----------------------------------
	build_taskgraph(dae as DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),
                                         DAELow.VARIABLES(_,_,knvararr,_,_),_,_,_,_,_,_),ass1,ass2,blocks)

  rule	print "-build_taskgraph failed\n"
	-----------------------
	build_taskgraph(_,_,_,_) => fail
end

(** relation: build_inits
 * This relation traverses the DAE and calls external relations to build 
 * the initialization values for the DAE
 * This is implemented in C++ as a set of vectors
 **)
relation build_inits:(DAELow.DAELow) => () =

  rule	DAELow.vararray_list(vararr) => vars &
	DAELow.vararray_list(kvararr) => kvars &
	build_inits2(vars) &
	build_inits2(kvars)
	--------------------
	build_inits(DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),DAELow.VARIABLES(_,_,kvararr,_,_),_,_,_,_,_,_)) => ()

end


relation build_inits2:(DAELow.Var list) => () =

  axiom	build_inits2([]) => ()

  rule	Exp.print_exp_str(value) => v &
	TaskGraphExt.add_initvar(indx,v,origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.VARIABLE,_,_,_,_,
				_,SOME(value),indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	TaskGraphExt.add_initvar(indx,"0.0",origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.VARIABLE,_,_,_,_,_,NONE,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	Exp.print_exp_str(value) => v &
	TaskGraphExt.add_initstate(indx,v,origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,SOME(value),indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	TaskGraphExt.add_initstate(indx,"0.0",origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,NONE,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	Exp.print_exp_str(value) => v &
	TaskGraphExt.add_initvar(indx,v,origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,SOME(value),indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	TaskGraphExt.add_initvar(indx,"0.0",origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,NONE,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	Exp.print_exp_str(value) => v &
	TaskGraphExt.add_initvar(indx,v,origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,
				_,SOME(value),indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	TaskGraphExt.add_initvar(indx,"0.0",origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,_,
				NONE,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	Values.val_string(value) => v &
	TaskGraphExt.add_initparam(indx,v,origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.PARAM,_,_,_,SOME(value),_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	TaskGraphExt.add_initparam(indx,"0.0",origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.PARAM,_,_,_,NONE,_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	Values.val_string(value) => v &
	TaskGraphExt.add_initparam(indx,v,origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.CONST,_,_,_,SOME(value),_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest)

  rule	TaskGraphExt.add_initparam(indx,"0.0",origname) &
	build_inits2(rest)
	--------------------
	build_inits2(DAELow.VAR(_,DAELow.CONST,_,_,_,NONE,_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest)
end

relation add_variables:(DAELow.Var list,int) => () =

  axiom	add_variables([],start) => ()

rule	add_variable(v,start) &
	add_variables(vs,start) 
	-------------------
	add_variables(v::vs,start) => ()
end

relation build_blocks:(DAELow.DAELow, int vector, int vector, int list list) => () =

  axiom	build_blocks(_,_,_,[]) => ()

  rule	(* For system of equations *)
	build_system(dae,ass1,ass2,block) &
	build_blocks(dae,ass1,ass2,blocks)
	-------------------------------------
	build_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks)
	
  rule	(* for single equations *)
	build_equation(dae,ass1,ass2,eqn) &
	build_blocks(dae,ass1,ass2,blocks)
	-------------------------------------
	build_blocks(dae,ass1,ass2,(block as [eqn])::blocks)

  rule	print "-build_blocks failed\n" 
	-----------------
	build_blocks(_,_,_,_) => fail
end

relation is_non_state: DAELow.VarKind => () =

  axiom	is_non_state (DAELow.VARIABLE) => ()

  axiom	is_non_state (DAELow.DUMMY_DER) => ()

  axiom	is_non_state (DAELow.DUMMY_STATE) => ()
end

(* Build task graph for a single equation.*)
relation build_equation:(DAELow.DAELow, int vector, int vector, int) => () =
	
  rule	(* Solving for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.var_list(vars) => varlst &
	list_nth(varlst,v') => (v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	is_non_state kind &
	(*print "Solving for non-states\n" &*)
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
(*	Exp.print_exp_str e1 => e1s &
	Exp.print_exp_str e2 => e2s &
	print "Equation " & print e1s & print " = " & print e2s &
	print " solved for " & Exp.print_exp_str varexp => s &
	print s & print " giving " &
	Exp.print_exp_str expr => s2 & print s2 & print "\n" &*)
	build_assignment(cr,expr,origname)  => ()
	--------------------------------
	build_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e)	

  rule	(* Solving the state s means solving for der(s) *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.var_list(vars) => varlst &
	list_nth(varlst,v') => DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
(*	print "solving for state\n" &*)
	int_string(indx) => indxs &


(* 	Util.string_append_list(["xd[",indxs,"]"]) => id & *)
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list([DAELow.derivative_name_prefix,c_name]) => id &


	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
(*	Exp.print_exp_str e1 => e1s &
	Exp.print_exp_str e2 => e2s &
	print "Equation " & print e1s & print " = " & print e2s &
	print "solved for " & Exp.print_exp_str varexp => s &
	print s & print "giving " &
	Exp.print_exp_str expr => s2 & print s2 & print "\n" &*)
	build_assignment(cr' ,expr,origname)  => ()
	--------------------------------
	build_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e)	

(*  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e) => fail
*)
  rule	(* state nonlinear *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.var_list(vars) => varlst &
	list_nth(varlst,v') => DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,_,flow) &
	int_string(indx) => indxs &

(* 	Util.string_append_list(["xd[",indxs,"]"]) => id & *)
        Exp.print_component_ref_str(cr) => name &
        Util.modelica_string_to_c_str(name) => c_name &
        Util.string_append_list([DAELow.derivative_name_prefix,c_name]) => id &

	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	build_nonlinear_equations([varexp],[Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2)]) 
	--------------------------------
	build_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e)	

  rule	(* Solving nonlinear for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.var_list(vars) => varlst &
	list_nth(varlst,v') => (v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	is_non_state kind &
	(*print "Solving for non-states\n" &*)
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => expr &
	build_nonlinear_equations([varexp],[Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2)]) 
	--------------------------------
	build_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_,_),ass1,ass2,e)	

  rule	print "-build_equation failed\n" 
	--------------------------------
	build_equation(_,_,_,_) => fail
end

(** relation: build_nonlinear_equations
 ** builds task graph for solving non-linear equations
 **)
relation build_nonlinear_equations: (Exp.Exp list, (* variables *)
				     Exp.Exp list) (* residuals *)
	=> () =

  rule	list_length(vars) => size &
	int_string(size) => size_str &
	build_residual_code(vars,residuals) => taskname &
	TaskGraphExt.new_task(taskname) => tid &
	TaskGraphExt.set_tasktype(tid,3) & (* See TaskType in TaskGraph.hpp *)
	build_nonlinear_equations2(tid,vars,residuals) &
	Util.list_map(vars,Exp.print_exp_str) => varnames &
	store_multiple_results(varnames,tid)
	---------------------------------------------
	build_nonlinear_equations(vars,residuals) => ()

  rule	print "build_nonlinear_equatins failed\n" 
	-----------------------------------------
	build_nonlinear_equations(vars,residuals) => fail

end

(** relation: build_residual_code
 ** This relation takes a list of expressions and builds code for 
 ** calculating the residuals as a string. Used for e.g. solving non-linear equations.
 **)
relation build_residual_code:(Exp.Exp list, (* vars *)
			      Exp.Exp list) (* residuals *)
	  => string =

  rule	make_residual_replacements(vars) => repl &
	build_residual_code2(es,0,repl) => res
	-------------------
	build_residual_code(vars,es) => res

  rule	print "build_residual_code failed\n" 
	--------------------------
	build_residual_code(_,_) => fail

end

(** relation: make_residual_replacements
 ** This relation makes replacement rules for variables occuring in a 
 ** nonlinear equation system. They should be replaced by x[index], i.e.
 ** an unique index in the x vector.
 **)
relation make_residual_replacements:(Exp.Exp list) => 
	VarTransform.VariableReplacements =

  rule	VarTransform.empty_replacements() => repl &
	make_residual_replacements2(repl,expl,0) => repl'
	---------------------
	make_residual_replacements(expl) => repl'
end

relation make_residual_replacements2:(VarTransform.VariableReplacements,
				      Exp.Exp list,
				      int) => 
	VarTransform.VariableReplacements =
  axiom	make_residual_replacements2(repl,[],_) => repl

  rule	int_string(pos) => pstr &
	Util.string_append_list(["xloc[",pstr,"]"]) => str &
	VarTransform.add_replacement(repl,cr,Exp.CREF_IDENT(str,[])) => repl' &
	pos + 1 => pos' &
	make_residual_replacements2(repl',es,pos') => repl''
	------------------------------
	make_residual_replacements2(repl,Exp.CREF(cr,_)::es,pos) => repl''
end
				      

relation build_residual_code2:(Exp.Exp list, 
			       int, 
			       VarTransform.VariableReplacements) 
	  => string =

  axiom	build_residual_code2([],_,_) => "" 

  rule	VarTransform.replace_exp(e,repl) => e' &
	SimCodegen.print_exp_cpp_str(e') => s1 &
	pos + 1 => pos'  &
	build_residual_code2(es,pos',repl) => s2 &
	int_string(pos) => pstr &
	Util.string_append_list(["res[",pstr,"]=",s1,";\n",s2]) => res
	-------------------------
	build_residual_code2(e::es,pos,repl) => res

  rule	print "build_residual_code2 failed\n" 
	-------------------------
	build_residual_code2(_,_,_) => fail
end

(** relation store_multiple_results
 ** When a task calculates several values, this relation is used.
 ** It collects the names of the values into one string, separated by semicolons
 ** and uses that as the resultstring.
 **)
relation store_multiple_results: (string list, (* var names*)
				  int (* task id*)
				  )
	=> () =

  rule	Util.string_delimit_list(varnames,";") => result_str &
	TaskGraphExt.store_result(result_str,tid,true,result_str)
	-----------------------------------------
	store_multiple_results(varnames,tid) => ()

  rule	print "store_multiple_results failed\n" 
	-----------------------
	store_multiple_results(_,_) => fail
end


relation build_nonlinear_equations2: (int, (*task id *)
				      Exp.Exp list, (* vars *)
				      Exp.Exp list) (* residuals *)
	=> () =

  axiom	build_nonlinear_equations2(tid,_,[]) => ()

  rule	(* Collect all variables and construct
	 a string for the residual, that can be directly used in codegen.*)
	Exp.get_cref_from_exp(res) => vars1 &
	Util.list_map(vars,Exp.get_cref_from_exp) => vars' &
	Util.list_flatten(vars') => vars2 &
	(* No duplicate elements *)
	Util.list_union_p(vars1,vars2,Exp.cref_equal) => vars1' &
	Util.list_setdifference_p(vars1',vars2,Exp.cref_equal) => vars &
	add_edges_from_vars(vars,tid,0) 
	--------------------------------
	build_nonlinear_equations2(tid,vars,res::residuals) => ()

  rule	print "build_nonlinear_equations2 failed\n" &
	Exp.print_exp_str e => es & print "first residual :" &
	print es & print "\n" 
	----------------------------
	build_nonlinear_equations2(_,_,e::_) => fail
end

(** relation: add_edges_from_vars
 ** Adds an edge between the tasks where the variables are defined and the tasks
 ** given as second argument.
 **)
relation add_edges_from_vars: (Exp.ComponentRef list, 
			       int (* task *),
			       int (* priority*)) => () =

  axiom	add_edges_from_vars([],_,_) => ()

  rule	Exp.cref_str(v) => v_str &
	TaskGraphExt.get_task(v_str) => predt &
	TaskGraphExt.add_edge(predt,tid,v_str,prio) &
	prio + 1 => prio' &
	add_edges_from_vars(vs,tid,prio') 
	------------------------------
	add_edges_from_vars(v::vs,tid,prio)

  rule	Exp.cref_str(v) => v_str &
	not TaskGraphExt.get_task(v_str) => _ &
	print "task " & print v_str & print " not found\n" 
	------------------------------------------------
	add_edges_from_vars(v::vs,_,_) => fail

  rule	print "add_edges_from_vars failed\n" 
	----------------------
	add_edges_from_vars(_,_,_) => fail
end

(* Build task graph for a system of equations *)
relation build_system:(DAELow.DAELow, int vector, int vector, int list) => () =

  rule	print "build system\n" &
	TaskGraphExt.new_task("equation system") => tid &
	build_system2(dae,ass1,ass2,system,tid) => predtasks &
	Util.list_map(predtasks, TaskGraphExt.get_task) => predtaskids &
	add_predecessors(tid,predtaskids,predtasks,0) 
	------------------------------------------
	build_system(dae,ass1,ass2,system) => ()

  rule	print "build_system failed\n" 
	---------------
	build_system(_,_,_,_) => fail
end

relation build_system2: (DAELow.DAELow, int vector, int vector, int list,int) => (string list) =

  axiom	build_system2(dae,ass1,ass2,[],tid) => []

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (v as DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	Exp.get_cref_from_exp(e1) => cr1 &
	Exp.get_cref_from_exp(e2) => cr2 &
	list_append(cr1,cr2) => crs &
	Util.list_deletemember(crs,cr) => crs' &
	Util.list_map(crs',Exp.cref_str) => crs'' &
	Exp.cref_str cr => crstr &
	TaskGraphExt.store_result(crstr,tid,true,origname) &	
	build_system2(dae,ass1,ass2,rest,tid) => crs2 &
	Util.list_union(crs'',crs2) => res
	-------------------------------------
	build_system2(dae as DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_,_),ass1,ass2,e::rest,tid) => res

  rule	print "build_system2 failed\n" 
	------------------
	build_system2(_,_,_,_,_) => fail
end

relation add_variable: (DAELow.Var,int) => () =

  rule	Exp.cref_str(cf) => cfs &
	(*print "adding variable " & print cfs & print "\n" &*)
	TaskGraphExt.store_result(cfs,start,false,name)
	------------------------------------
	add_variable(DAELow.VAR(cf,_,_,_,_, _,_,_,_,name,_,dae_var_attr,comment,flow),start)
end
		     
relation build_assignment: (Exp.ComponentRef, (* varname *)
			    Exp.Exp, (*expression*) 
			    string) (* orig. name*) 
	  => () =

  rule	(* special rule for equation a:=b *)
	build_expression(exp) => (task,str) &
	TaskGraphExt.new_task("copy") => tid &
	Exp.cref_str(cr2) => cr2s &
	TaskGraphExt.add_edge(task,tid,cr2s,0) &
	Exp.cref_str(cr) => crs & 
	TaskGraphExt.store_result(crs,tid,true,origname) &
	TaskGraphExt.set_tasktype(tid,6) (* See TaskType in TaskGraph.hpp *)
	----------------------------------------------
	build_assignment(cr,exp as Exp.CREF(cr2,tp),origname) 
	
  rule	build_expression(exp) => (task,str) &
	Exp.cref_str(cr) => crs &
	TaskGraphExt.store_result(crs,task,true,origname)
	------------------------
	build_assignment(cr,exp,origname)

  rule	print "-build_assignment failed\n" 
	------------------------
	build_assignment(cr,exp,origname) => fail
end

(* Builds the task graph for the expression and
 returns the task no that calculates the result of the expr *)
relation build_expression:(Exp.Exp) => (int, string) =
	
  rule	int_string(i) => is &
	TaskGraphExt.new_task(is) => tid (*&
	TaskGraphExt.get_starttask() => st &
	TaskGraphExt.add_edge(st,tid,"") &
	TaskGraphExt.set_commcost(st,tid,0)*) 
	--------------------------------
	build_expression(Exp.ICONST(i)) => (tid,"")

  rule	real_string(r) => rs &
	TaskGraphExt.new_task(rs) => tid  (*&
	TaskGraphExt.get_starttask() => st &
	TaskGraphExt.add_edge(st,tid,"") &
	TaskGraphExt.set_commcost(st,tid,0) *)
	--------------------------------
	build_expression(Exp.RCONST(r)) => (tid,"")
	
  rule	(* for state variables and alg. variables*)
	Exp.cref_str(cr) => crs &
	TaskGraphExt.get_task(crs) => tid
	---------------------------------
	build_expression(Exp.CREF(cr,_)) => (tid,crs)

  rule	(* for state variables and alg. variables*)
	TaskGraphExt.get_task("sim_time") => tid
	---------------------------------
	build_expression(Exp.CREF(Exp.CREF_IDENT("time",_),_)) => (tid,"sim_time")

  rule	(* for constants and parameters, no data to send from proc0 *)
	Exp.cref_str(cr) => crs &
	TaskGraphExt.new_task(crs) => tid  
 	---------------------------------
	build_expression(Exp.CREF(cr,_)) => (tid,crs)

  rule	(* special case for pow *)
	build_expression(e1) => (t1,s1) &
	real_int(rval) => ival &
	int_string(ival) => istr &
	Util.string_append_list(["pow(%s,",istr,")"]) => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) 
	---------------------------
	build_expression(Exp.BINARY(e1,Exp.POW(_),Exp.RCONST(rval))) => (t,"")

  rule	build_expression(e1) => (t1,s1) &
	build_expression(e2) => (t2,s2) &
	Exp.binop_symbol_1(op) => ops &
	Util.string_append_list(["%s",ops,"%s"]) => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) &
	TaskGraphExt.add_edge(t2,t,s2,1)
	---------------------------
	build_expression(Exp.BINARY(e1,op,e2)) => (t,"")

  rule	build_expression(e1) => (t1,s1) &
	build_expression(e2) => (t2,s2) &
	Exp.binop_symbol_1(op) => ops &
	Util.string_append_list(["%s",ops,"%s"]) => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) &
	TaskGraphExt.add_edge(t2,t,s2,1)
	---------------------------
	build_expression(Exp.LBINARY(e1,op,e2)) => (t,"")

  rule	build_expression(e1) => (t1,s1) &
	Exp.unaryop_symbol(op) => ops &
	Util.string_append_list([ops,"%s"]) => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) 
	---------------------------
	build_expression(Exp.UNARY(op,e1)) => (t,"")

  rule	build_expression(e1) => (t1,s1) &
	Exp.lunaryop_symbol(op) => ops &
	Util.string_append_list([ops,"%s"]) => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) 
	---------------------------
	build_expression(Exp.LUNARY(op,e1)) => (t,"")
	
  rule	build_expression(e1) => (t1,s1) &
	build_expression(e2) => (t2,s2) &
	Exp.relop_symbol(relop) => ops &
	Util.string_append_list(["%s",ops,"%s"]) => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) &
	TaskGraphExt.add_edge(t2,t,s2,1)
	-------------------------
	build_expression(Exp.RELATION(e1,relop,e2)) => (t,"") 

  rule	build_expression(e1) => (t1,s1) &
	build_expression(e2) => (t2,s2) &
	build_expression(e3) => (t3,s3) &
	Util.string_append_list["%s ? %s : %s"] => ts &
	TaskGraphExt.new_task(ts) => t &
	TaskGraphExt.add_edge(t1,t,s1,0) &
	TaskGraphExt.add_edge(t2,t,s2,1) &
	TaskGraphExt.add_edge(t3,t,s3,2) 
	----------------------------
	build_expression(Exp.IFEXP(e1,e2,e3)) => (t,"")
	
  rule	Absyn.path_string func => funcstr &
	list_length(expl) => numargs &
	build_call_str(funcstr,numargs) => ts &
	Util.list_map__2(expl,build_expression) => (tasks,strs) &
	TaskGraphExt.new_task(ts) => t &
	add_predecessors(t,tasks,strs,0) 
	------------------------------
	build_expression(Exp.CALL(func,expl,_,_)) => (t,"") 

  rule	print "build_expression(ARRAY) not impl. yet\n"
	-----------------------------------------------
	build_expression(Exp.ARRAY(_,_,_)) => fail

  rule	print "build_expression(MATRIX) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.ARRAY(_,_,_)) => fail

  rule	print "build_expression(RANGE) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.RANGE(_,_,_,_)) => fail

  rule	print "build_expression(TUPLE) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.TUPLE(_)) => fail

  rule	build_expression(e) => (t,s)
	------------------------------------------------
	build_expression(Exp.CAST(t,e)) => (t,s)
	
  rule	print "build_expression(ASUB) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.ASUB(_,_)) => fail
	
  rule	print "build_expression(SIZE) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.SIZE(_,_)) => fail

  rule	print "build_expression(CODE) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.CODE(_,_)) => fail

  rule	print "build_expression(REDUCTION) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.REDUCTION(_,_,_,_)) => fail
	
  rule	print "build_expression(END) not impl. yet\n"
	------------------------------------------------
	build_expression(Exp.END) => fail

  rule	print "-build_expression failed\n Exp = " &
	Exp.print_exp_str e => es & print es & print "\n" 
	-------------------------------------------------
	build_expression(e) => fail
end

relation build_call_str:(string , int) => string =

  rule	Util.list_fill("%s",n) => ns &
	Util.string_delimit_list(ns,", ") => ns' &
	Util.string_append_list([str,"(",ns',")"]) => res
	-----------------
	build_call_str(str,n) => res
end

relation add_predecessors: (int (* task*), int list (* list of precessors *),string list,int (* prio*)) => () =

axiom add_predecessors(_,[],[],_) 

  rule	TaskGraphExt.add_edge(t1,t,s,prio) &
	int_add(prio,1) => prio' &
	add_predecessors(t,ts,strs,prio')
	---------------------
	add_predecessors(t,t1::ts,s::strs,prio)
end
