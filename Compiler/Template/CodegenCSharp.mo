encapsulated package CodegenCSharp
"
  file:        CodegenCSharp.mo
  package:     CodegenCSharp
  description: Generated by Susan.
  
  $Id$
"

public import Tpl;

public import SimCode;
public import BackendDAE;
public import System;
public import Absyn;
public import DAE;
public import ClassInf;
public import SCode;
public import Util;
public import List;
public import ComponentReference;
public import Expression;
public import ExpressionDump;
public import Config;
public import Flags;
public import Settings;
public import Patternm;
public import Error;
public import Values;
public import ValuesUtil;
public import BackendQSS;
public import BackendVariable;
public import DAEDump;
public import Algorithm;
public import DAEUtil;
public import Types;

public function translateModel
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode)
    local
      Tpl.Text txt;
      Absyn.Path i_modelInfo_name;
      SimCode.SimCode i_simCode;
      Tpl.Text txt_1;
      Tpl.Text txt_0;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = SimCode.MODELINFO(name = i_modelInfo_name))) )
      equation
        txt_0 = simulationFile(Tpl.emptyTxt, i_simCode);
        txt_1 = dotPath(Tpl.emptyTxt, i_modelInfo_name);
        txt_1 = Tpl.writeTok(txt_1, Tpl.ST_STRING(".cs"));
        Tpl.textFile(txt_0, Tpl.textString(txt_1));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end translateModel;

protected function fun_28
  input Tpl.Text in_txt;
  input Tpl.Text in_a_fbody;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_fbody)
    local
      Tpl.Text txt;
      Tpl.Text i_fbody;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//** No functions **"));
      then txt;

    case ( txt,
           i_fbody )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("#region Functions\n"));
        txt = Tpl.writeText(txt, i_fbody);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("#endregion"));
      then txt;
  end matchcontinue;
end fun_28;

public function simulationFile
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode)
    local
      Tpl.Text txt;
      list<BackendDAE.ZeroCrossing> i_zeroCrossings;
      list<SimCode.HelpVarInfo> i_helpVarInfo;
      list<SimCode.SimWhenClause> i_whenClauses;
      list<SimCode.SimEqSystem> i_removedEquations;
      list<SimCode.SimEqSystem> i_algebraicEquations;
      list<list<SimCode.SimEqSystem>> i_odeEquations;
      list<SimCode.SimEqSystem> i_parameterEquations;
      list<SimCode.SimEqSystem> i_residualEquations;
      list<SimCode.SimEqSystem> i_startValueEquations;
      list<SimCode.SimEqSystem> i_sampleEquations;
      list<SimCode.SampleCondition> i_sampleConditions;
      list<SimCode.SimEqSystem> i_allEquations;
      SimCode.ExtObjInfo i_extObjInfo;
      SimCode.SimCode i_simCode;
      SimCode.ModelInfo i_modelInfo;
      Absyn.Path i_modelInfo_name;
      Tpl.Text l_fbody;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = (i_modelInfo as SimCode.MODELINFO(name = i_modelInfo_name)), extObjInfo = i_extObjInfo, allEquations = i_allEquations, sampleConditions = i_sampleConditions, sampleEquations = i_sampleEquations, startValueEquations = i_startValueEquations, residualEquations = i_residualEquations, parameterEquations = i_parameterEquations, odeEquations = i_odeEquations, algebraicEquations = i_algebraicEquations, removedEquations = i_removedEquations, whenClauses = i_whenClauses, helpVarInfo = i_helpVarInfo, zeroCrossings = i_zeroCrossings)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("// Simulation code for "));
        txt = dotPath(txt, i_modelInfo_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    " generated by the OpenModelica Compiler.\n",
                                    "\n",
                                    "using System;\n",
                                    "using Bodylight.Solvers;\n",
                                    "namespace Bodylight.Models"
                                }, false));
        txt = modelNameSpace(txt, i_modelInfo_name);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("{\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("public partial class "));
        txt = lastIdentOfPath(txt, i_modelInfo_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    " : DAESystem\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = modelDataMembers(txt, i_modelInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        l_fbody = simulationFunctionsBody(Tpl.emptyTxt, i_simCode);
        txt = fun_28(txt, l_fbody);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionCallExternalObjectConstructors(txt, i_extObjInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionExtraResiduals(txt, i_allEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInput(txt, i_modelInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionOutput(txt, i_modelInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInitSample(txt, i_sampleConditions, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionSampleEquations(txt, i_sampleEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionStoreDelayed(txt, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInitial(txt, i_startValueEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionInitialResidual(txt, i_residualEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionBoundParameters(txt, i_parameterEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionODE(txt, i_odeEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionAlgebraic(txt, i_algebraicEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionAliasEquation(txt, i_removedEquations, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionDAE(txt, i_allEquations, i_whenClauses, i_helpVarInfo, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionOnlyZeroCrossing(txt, i_zeroCrossings, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = functionCheckForDiscreteChanges(txt, i_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end simulationFile;

public function modelNameSpace
  input Tpl.Text in_txt;
  input Absyn.Path in_a_modelName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelName)
    local
      Tpl.Text txt;
      Absyn.Path i_path;
      Absyn.Ident i_name;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = Tpl.writeStr(txt, i_name);
        txt = modelNameSpace(txt, i_path);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = modelNameSpace(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end modelNameSpace;

public function lastIdentOfPath
  input Tpl.Text in_txt;
  input Absyn.Path in_a_modelName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelName)
    local
      Tpl.Text txt;
      String i_name;
      Absyn.Path i_path;

    case ( txt,
           Absyn.QUALIFIED(path = i_path) )
      equation
        txt = lastIdentOfPath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name) )
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = lastIdentOfPath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end lastIdentOfPath;

protected function fun_32
  input Tpl.Text in_txt;
  input SimCode.Function in_a_fn;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_fn, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Absyn.Path i_name;
      SimCode.Function i_fn;

    case ( txt,
           (i_fn as SimCode.FUNCTION(name = _)),
           a_simCode )
      equation
        txt = functionBodyRegularFunction(txt, i_fn, a_simCode);
      then txt;

    case ( txt,
           (i_fn as SimCode.EXTERNAL_FUNCTION(name = _)),
           a_simCode )
      equation
        txt = functionBodyExternalFunction(txt, i_fn, a_simCode);
      then txt;

    case ( txt,
           SimCode.RECORD_CONSTRUCTOR(name = i_name),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RECORD_CONSTRUCTOR_NOT_IMPLEMENTED(name="));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_FUNCTION"));
      then txt;
  end matchcontinue;
end fun_32;

protected function lm_33
  input Tpl.Text in_txt;
  input list<SimCode.Function> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.Function> rest;
      SimCode.SimCode a_simCode;
      SimCode.Function i_fn;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_fn :: rest,
           a_simCode )
      equation
        txt = fun_32(txt, i_fn, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_33(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_33(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_33;

public function simulationFunctionsBody
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      list<SimCode.Function> i_modelInfo_functions;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = SimCode.MODELINFO(functions = i_modelInfo_functions))) )
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_33(txt, i_modelInfo_functions, i_simCode);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end simulationFunctionsBody;

protected function lm_35
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.Variable> rest;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_var_name;
      SimCode.Variable i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_var as SimCode.VARIABLE(name = i_var_name)) :: rest,
           a_simCode )
      equation
        txt = varType(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = crefStr(txt, i_var_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_35(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_35(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_35;

public function recordDeclaration
  input Tpl.Text in_txt;
  input SimCode.RecordDeclaration in_a_recDecl;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_recDecl, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.Variable> i_variables;
      String i_name;

    case ( txt,
           SimCode.RECORD_DECL_FULL(name = i_name, variables = i_variables),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("struct "));
        txt = Tpl.writeStr(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_35(txt, i_variables, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("};"));
      then txt;

    case ( txt,
           SimCode.RECORD_DECL_DEF(path = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RECORD_DECL_DEF_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_RECORD_DECL_"));
      then txt;
  end matchcontinue;
end recordDeclaration;

protected function fun_37
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_a_outVars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_outVars)
    local
      Tpl.Text txt;
      SimCode.Variable i_fv;

    case ( txt,
           i_fv :: _ )
      equation
        txt = varType(txt, i_fv);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("void"));
      then txt;
  end matchcontinue;
end fun_37;

protected function fun_38
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_a_outVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_outVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_fv_name;

    case ( txt,
           SimCode.VARIABLE(name = i_fv_name) :: _,
           a_simCode )
      equation
        txt = crefStr(txt, i_fv_name, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_38;

protected function lm_39
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.Variable> rest;
      SimCode.SimCode a_simCode;
      SimCode.Variable i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           a_simCode )
      equation
        txt = varInit(txt, i_var, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_39(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_39(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_39;

protected function lm_40
  input Tpl.Text in_txt;
  input list<SimCode.Statement> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Statement i_stmt;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode )
      equation
        txt = funStatement(txt, i_stmt, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_40(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_40(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_40;

protected function lm_41
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.Variable> rest;
      SimCode.SimCode a_simCode;
      SimCode.Variable i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           a_simCode )
      equation
        txt = funArgDefinition(txt, i_var, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_41(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_41(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_41;

protected function fun_42
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_a_outVars;
  input Tpl.Text in_a_retVar;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_outVars, in_a_retVar)
    local
      Tpl.Text txt;
      Tpl.Text a_retVar;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           _,
           a_retVar )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("return "));
        txt = Tpl.writeText(txt, a_retVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;
  end matchcontinue;
end fun_42;

public function functionBodyRegularFunction
  input Tpl.Text in_txt;
  input SimCode.Function in_a_fn;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_fn, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.Variable> i_functionArguments;
      list<SimCode.Statement> i_body;
      list<SimCode.Variable> i_variableDeclarations;
      list<SimCode.Variable> i_outVars;
      Absyn.Path i_name;
      Tpl.Text l_bodyPart;
      Tpl.Text l_varInits;
      Tpl.Text l_retVar;
      Tpl.Text l_retType;
      Tpl.Text l_fname;

    case ( txt,
           SimCode.FUNCTION(name = i_name, outVars = i_outVars, variableDeclarations = i_variableDeclarations, body = i_body, functionArguments = i_functionArguments),
           a_simCode )
      equation
        System.tmpTickReset(1);
        l_fname = underscorePath(Tpl.emptyTxt, i_name);
        l_retType = fun_37(Tpl.emptyTxt, i_outVars);
        l_retVar = fun_38(Tpl.emptyTxt, i_outVars, a_simCode);
        l_varInits = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_varInits = lm_39(l_varInits, i_variableDeclarations, a_simCode);
        l_varInits = Tpl.popIter(l_varInits);
        l_bodyPart = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_bodyPart = lm_40(l_bodyPart, i_body, a_simCode);
        l_bodyPart = Tpl.popIter(l_bodyPart);
        txt = Tpl.writeText(txt, l_retType);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" _"));
        txt = Tpl.writeText(txt, l_fname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_41(txt, i_functionArguments, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ")\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_varInits);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, l_bodyPart);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "_return:\n"
                                }, true));
        txt = fun_42(txt, i_outVars, l_retVar);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "\n"
                                }, true));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionBodyRegularFunction;

protected function fun_44
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_a_outVars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_outVars)
    local
      Tpl.Text txt;
      SimCode.Variable i_fv;

    case ( txt,
           i_fv :: _ )
      equation
        txt = varType(txt, i_fv);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("void"));
      then txt;
  end matchcontinue;
end fun_44;

protected function lm_45
  input Tpl.Text in_txt;
  input list<SimCode.SimExtArg> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp)
    local
      Tpl.Text txt;
      list<SimCode.SimExtArg> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.SimExtArg i_arg;

    case ( txt,
           {},
           _,
           a_preExp )
      then (txt, a_preExp);

    case ( txt,
           i_arg :: rest,
           a_simCode,
           a_preExp )
      equation
        (txt, a_preExp) = extArg(txt, i_arg, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_45(txt, rest, a_simCode, a_preExp);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp )
      equation
        (txt, a_preExp) = lm_45(txt, rest, a_simCode, a_preExp);
      then (txt, a_preExp);
  end matchcontinue;
end lm_45;

protected function lm_46
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.Variable> rest;
      SimCode.SimCode a_simCode;
      SimCode.Variable i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           a_simCode )
      equation
        txt = funArgDefinition(txt, i_var, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_46(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_46(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_46;

protected function fun_47
  input Tpl.Text in_txt;
  input list<SimCode.Variable> in_a_outVars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_outVars)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("return "));
      then txt;
  end matchcontinue;
end fun_47;

public function functionBodyExternalFunction
  input Tpl.Text in_txt;
  input SimCode.Function in_a_fn;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_fn, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.Variable> i_funArgs;
      String i_extName;
      list<String> i_libs;
      list<SimCode.SimExtArg> i_extArgs;
      list<SimCode.Variable> i_outVars;
      Absyn.Path i_name;
      String ret_6;
      Tpl.Text l_lib;
      Tpl.Text l_args;
      Tpl.Text l_callPart;
      Tpl.Text l_preExp;
      Tpl.Text l_retType;
      Tpl.Text l_fname;

    case ( txt,
           SimCode.EXTERNAL_FUNCTION(name = i_name, outVars = i_outVars, extArgs = i_extArgs, libs = i_libs, extName = i_extName, funArgs = i_funArgs),
           a_simCode )
      equation
        System.tmpTickReset(1);
        l_fname = underscorePath(Tpl.emptyTxt, i_name);
        l_retType = fun_44(Tpl.emptyTxt, i_outVars);
        l_preExp = Tpl.emptyTxt;
        l_args = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_args, l_preExp) = lm_45(l_args, i_extArgs, a_simCode, l_preExp);
        l_args = Tpl.popIter(l_args);
        ret_6 = SimCode.hackGetFirstExternalFunctionLib(i_libs);
        l_lib = Tpl.writeStr(Tpl.emptyTxt, ret_6);
        l_callPart = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("Bodylight.Solvers.ExternalLibraries."));
        l_callPart = Tpl.writeText(l_callPart, l_lib);
        l_callPart = Tpl.writeTok(l_callPart, Tpl.ST_STRING("."));
        l_callPart = Tpl.writeStr(l_callPart, i_extName);
        l_callPart = Tpl.writeTok(l_callPart, Tpl.ST_STRING("("));
        l_callPart = Tpl.writeText(l_callPart, l_args);
        l_callPart = Tpl.writeTok(l_callPart, Tpl.ST_STRING(");"));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("static "));
        txt = Tpl.writeText(txt, l_retType);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" _"));
        txt = Tpl.writeText(txt, l_fname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_46(txt, i_funArgs, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ")\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = fun_47(txt, i_outVars);
        txt = Tpl.writeText(txt, l_callPart);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "\n"
                                }, true));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionBodyExternalFunction;

protected function fun_49
  input Tpl.Text in_txt;
  input Integer in_a_oi;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_c;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_oi, in_a_simCode, in_a_c)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_c;
      Integer i_oi;

    case ( txt,
           0,
           a_simCode,
           a_c )
      equation
        txt = crefStr(txt, a_c, a_simCode);
      then txt;

    case ( txt,
           i_oi,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_SUPPORTED_out.targ"));
        txt = Tpl.writeStr(txt, intString(i_oi));
      then txt;
  end matchcontinue;
end fun_49;

protected function fun_50
  input Tpl.Text in_txt;
  input Integer in_a_outputIndex;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_c;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_outputIndex, in_a_simCode, in_a_c)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_c;
      Integer i_outputIndex;

    case ( txt,
           0,
           a_simCode,
           a_c )
      equation
        txt = crefStr(txt, a_c, a_simCode);
      then txt;

    case ( txt,
           i_outputIndex,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_SUPPORTED_SIZE_out.targ"));
        txt = Tpl.writeStr(txt, intString(i_outputIndex));
      then txt;
  end matchcontinue;
end fun_50;

protected function fun_51
  input Tpl.Text in_txt;
  input DAE.Exp in_a_exp;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input Tpl.Text in_a_name;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_exp, in_a_simCode, in_a_preExp, in_a_name)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      Tpl.Text a_name;
      DAE.Exp i_exp;
      Integer i_integer;

    case ( txt,
           DAE.ICONST(integer = i_integer),
           _,
           a_preExp,
           a_name )
      equation
        txt = Tpl.writeText(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".size"));
        txt = Tpl.writeStr(txt, intString(i_integer));
      then (txt, a_preExp);

    case ( txt,
           i_exp,
           a_simCode,
           a_preExp,
           a_name )
      equation
        txt = Tpl.writeText(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".size("));
        (txt, a_preExp) = daeExp(txt, i_exp, SimCode.contextFunction, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_51;

public function extArg
  input Tpl.Text in_txt;
  input SimCode.SimExtArg in_a_extArg;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_extArg, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      Integer i_outputIndex;
      DAE.Exp i_exp;
      DAE.ComponentRef i_c;
      Integer i_oi;
      Tpl.Text l_cr;
      Tpl.Text l_name;

    case ( txt,
           SimCode.SIMEXTARG(cref = i_c, outputIndex = i_oi, isArray = true, type_ = _),
           a_preExp,
           a_simCode )
      equation
        l_name = fun_49(Tpl.emptyTxt, i_oi, a_simCode, i_c);
        txt = Tpl.writeText(txt, l_name);
      then (txt, a_preExp);

    case ( txt,
           SimCode.SIMEXTARG(cref = i_c, isInput = _, outputIndex = 0, type_ = _),
           a_preExp,
           a_simCode )
      equation
        l_cr = crefStr(Tpl.emptyTxt, i_c, a_simCode);
        txt = Tpl.writeText(txt, l_cr);
      then (txt, a_preExp);

    case ( txt,
           SimCode.SIMEXTARG(cref = _, isInput = _, outputIndex = i_oi, type_ = _),
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_SUPPORTED_ext"));
        txt = Tpl.writeStr(txt, intString(i_oi));
      then (txt, a_preExp);

    case ( txt,
           SimCode.SIMEXTARGEXP(exp = i_exp),
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExp(txt, i_exp, SimCode.contextFunction, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           SimCode.SIMEXTARGSIZE(cref = i_c, outputIndex = i_outputIndex, exp = i_exp),
           a_preExp,
           a_simCode )
      equation
        l_name = fun_50(Tpl.emptyTxt, i_outputIndex, a_simCode, i_c);
        (txt, a_preExp) = fun_51(txt, i_exp, a_simCode, a_preExp, l_name);
      then (txt, a_preExp);

    case ( txt,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end extArg;

protected function lm_53
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preDimsExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preDimsExp;
algorithm
  (out_txt, out_a_preDimsExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preDimsExp)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preDimsExp;
      DAE.Exp i_exp;

    case ( txt,
           {},
           _,
           a_preDimsExp )
      then (txt, a_preDimsExp);

    case ( txt,
           i_exp :: rest,
           a_simCode,
           a_preDimsExp )
      equation
        (txt, a_preDimsExp) = daeExp(txt, i_exp, SimCode.contextFunction, a_preDimsExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preDimsExp) = lm_53(txt, rest, a_simCode, a_preDimsExp);
      then (txt, a_preDimsExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preDimsExp )
      equation
        (txt, a_preDimsExp) = lm_53(txt, rest, a_simCode, a_preDimsExp);
      then (txt, a_preDimsExp);
  end matchcontinue;
end lm_53;

protected function fun_54
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_a_var_value;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_varName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_var_value, in_a_simCode, in_a_varName)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_varName;
      DAE.ComponentRef i_cr;

    case ( txt,
           SOME(DAE.CREF(componentRef = i_cr)),
           a_simCode,
           a_varName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, a_varName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".CopyFrom("));
        txt = crefStr(txt, i_cr, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_54;

protected function fun_55
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_a_instDims;
  input Option<DAE.Exp> in_a_var_value;
  input DAE.Type in_a_var_ty;
  input list<DAE.Exp> in_a_var_instDims;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_var_name;
  input SimCode.Variable in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_instDims, in_a_var_value, in_a_var_ty, in_a_var_instDims, in_a_simCode, in_a_var_name, in_a_var)
    local
      Tpl.Text txt;
      Option<DAE.Exp> a_var_value;
      DAE.Type a_var_ty;
      list<DAE.Exp> a_var_instDims;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_var_name;
      SimCode.Variable a_var;
      list<DAE.Exp> i_instDims;
      Integer ret_3;
      Tpl.Text l_instDimsInit;
      Tpl.Text l_preDimsExp;
      Tpl.Text l_varName;

    case ( txt,
           {},
           _,
           _,
           _,
           a_simCode,
           a_var_name,
           a_var )
      equation
        txt = varType(txt, a_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = crefStr(txt, a_var_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           i_instDims,
           a_var_value,
           a_var_ty,
           a_var_instDims,
           a_simCode,
           a_var_name,
           _ )
      equation
        l_varName = crefStr(Tpl.emptyTxt, a_var_name, a_simCode);
        l_preDimsExp = Tpl.emptyTxt;
        l_instDimsInit = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_instDimsInit, l_preDimsExp) = lm_53(l_instDimsInit, a_var_instDims, a_simCode, l_preDimsExp);
        l_instDimsInit = Tpl.popIter(l_instDimsInit);
        txt = Tpl.writeText(txt, l_preDimsExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var "));
        txt = Tpl.writeText(txt, l_varName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new "));
        ret_3 = listLength(i_instDims);
        txt = expTypeArray(txt, a_var_ty, ret_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_instDimsInit);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = fun_54(txt, a_var_value, a_simCode, l_varName);
      then txt;
  end matchcontinue;
end fun_55;

public function varInit
  input Tpl.Text in_txt;
  input SimCode.Variable in_a_var;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_var, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Option<DAE.Exp> i_var_value;
      DAE.Type i_var_ty;
      list<DAE.Exp> i_var_instDims;
      DAE.ComponentRef i_var_name;
      SimCode.Variable i_var;
      list<DAE.Exp> i_instDims;

    case ( txt,
           (i_var as SimCode.VARIABLE(instDims = (i_var_instDims as i_instDims), name = i_var_name, ty = i_var_ty, value = i_var_value)),
           a_simCode )
      equation
        txt = fun_55(txt, i_instDims, i_var_value, i_var_ty, i_var_instDims, a_simCode, i_var_name, i_var);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNSUPPORTED_VARIABLE_varInit"));
      then txt;
  end matchcontinue;
end varInit;

public function funArgDefinition
  input Tpl.Text in_txt;
  input SimCode.Variable in_a_var;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_var, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      String i_name_1;
      DAE.ComponentRef i_name;
      SimCode.Variable i_var;

    case ( txt,
           (i_var as SimCode.VARIABLE(name = i_name)),
           a_simCode )
      equation
        txt = varType(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = crefStr(txt, i_name, a_simCode);
      then txt;

    case ( txt,
           SimCode.FUNCTION_PTR(name = i_name_1),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("funArgDefinition_UNSUPPORTED_fnptr "));
        txt = Tpl.writeStr(txt, i_name_1);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNSUPPORTED_VARIABLE_funArgDefinition"));
      then txt;
  end matchcontinue;
end funArgDefinition;

protected function lm_58
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      DAE.Statement i_stmt;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode )
      equation
        txt = algStatement(txt, i_stmt, SimCode.contextFunction, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_58(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_58(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_58;

public function funStatement
  input Tpl.Text in_txt;
  input SimCode.Statement in_a_stmt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_stmt, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<DAE.Statement> i_statementLst;

    case ( txt,
           SimCode.ALGORITHM(statementLst = i_statementLst),
           a_simCode )
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_58(txt, i_statementLst, a_simCode);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT IMPLEMENTED FUN STATEMENT"));
      then txt;
  end matchcontinue;
end funStatement;

public constant Tpl.StringToken c_localRepresentationArrayDefines = Tpl.ST_STRING_LIST({
                                                                        "var X = states; var Xd = statesDerivatives; var Y = algebraics; var P = parameters; var H = helpVars; var EO = externalObjects;\n",
                                                                        "var preX = savedStates; var preXd = savedStatesDerivatives; var preY = savedAlgebraics; var preH = savedHelpVars;\n",
                                                                        "var preYI = savedAlgebraicsInt; var preYB = savedAlgebraicsBool; var YI = algebraicsInt; var YB = algebraicsBool; var PI = parametersInt; var PB = parametersBool; "
                                                                    }, false);

protected function smf_61
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_61;

protected function smf_62
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_62;

protected function smf_63
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_63;

protected function smf_64
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_64;

protected function smf_65
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_65;

protected function smf_66
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_66;

protected function smf_67
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_67;

protected function smf_68
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_68;

protected function smf_69
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_69;

protected function smf_70
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_70;

protected function smf_71
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_71;

protected function fun_72
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_stateVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_stateVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_stateVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_stateVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//states\n"));
        txt = initFixed(txt, i_vars_stateVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_72;

protected function fun_73
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_derivativeVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_derivativeVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_derivativeVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_derivativeVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//derivatives\n"));
        txt = initFixed(txt, i_vars_derivativeVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_73;

protected function fun_74
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_algVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_algVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_algVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_algVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//algebraics\n"));
        txt = initFixed(txt, i_vars_algVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_74;

protected function fun_75
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_intAlgVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_intAlgVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_intAlgVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_intAlgVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//algebraicsInt\n"));
        txt = initFixed(txt, i_vars_intAlgVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_75;

protected function fun_76
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_boolAlgVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_boolAlgVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_boolAlgVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_boolAlgVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//algebraicsBool\n"));
        txt = initFixed(txt, i_vars_boolAlgVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_76;

protected function fun_77
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_paramVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_paramVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_paramVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_paramVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//parameters\n"));
        txt = initFixed(txt, i_vars_paramVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_77;

protected function fun_78
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_intParamVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_intParamVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_intParamVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_intParamVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//parametersInt\n"));
        txt = initFixed(txt, i_vars_intParamVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_78;

protected function fun_79
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_vars_boolParamVars;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_vars_boolParamVars, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_boolParamVars;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_vars_boolParamVars,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("//parametersBool\n"));
        txt = initFixed(txt, i_vars_boolParamVars, a_simCode);
      then txt;
  end matchcontinue;
end fun_79;

protected function smf_80
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_80;

protected function smf_81
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_81;

protected function smf_82
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_82;

protected function smf_83
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_83;

protected function smf_84
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_84;

protected function smf_85
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_85;

protected function smf_86
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_86;

protected function smf_87
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end matchcontinue;
end smf_87;

public function modelDataMembers
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_boolParamVars;
      list<SimCode.SimVar> i_vars_intParamVars;
      list<SimCode.SimVar> i_vars_paramVars;
      list<SimCode.SimVar> i_vars_boolAliasVars;
      list<SimCode.SimVar> i_vars_boolAlgVars;
      list<SimCode.SimVar> i_vars_intAliasVars;
      list<SimCode.SimVar> i_vars_intAlgVars;
      list<SimCode.SimVar> i_vars_aliasVars;
      list<SimCode.SimVar> i_vars_algVars;
      list<SimCode.SimVar> i_vars_derivativeVars;
      list<SimCode.SimVar> i_vars_stateVars;
      Absyn.Path i_name;
      Integer i_varInfo_numStringParamVars;
      Integer i_varInfo_numBoolParams;
      Integer i_varInfo_numIntParams;
      Integer i_varInfo_numBoolAliasVars;
      Integer i_varInfo_numBoolAlgVars;
      Integer i_varInfo_numIntAliasVars;
      Integer i_varInfo_numIntAlgVars;
      Integer i_varInfo_numStringAliasVars;
      Integer i_varInfo_numStringAlgVars;
      list<SimCode.Function> i_functions;
      Integer i_varInfo_numExternalObjects;
      Integer i_varInfo_numInitialResiduals;
      Integer i_varInfo_numInVars;
      Integer i_varInfo_numOutVars;
      Integer i_varInfo_numParams;
      Integer i_varInfo_numAlgAliasVars;
      Integer i_varInfo_numAlgVars;
      Integer i_varInfo_numStateVars;
      Integer i_varInfo_numTimeEvents;
      Integer i_varInfo_numZeroCrossings;
      Integer i_varInfo_numHelpVars;
      Tpl.Text txt_19;
      Tpl.Text txt_18;
      Tpl.Text txt_17;
      Tpl.Text txt_16;
      Tpl.Text txt_15;
      Tpl.Text txt_14;
      Tpl.Text txt_13;
      Tpl.Text txt_12;
      Tpl.Text txt_11;
      Tpl.Text txt_10;
      Tpl.Text txt_9;
      Tpl.Text txt_8;
      Tpl.Text txt_7;
      Tpl.Text txt_6;
      Tpl.Text txt_5;
      Tpl.Text txt_4;
      Tpl.Text txt_3;
      Tpl.Text txt_2;
      Tpl.Text txt_1;
      Integer ret_0;

    case ( txt,
           SimCode.MODELINFO(varInfo = SimCode.VARINFO(numHelpVars = i_varInfo_numHelpVars, numZeroCrossings = i_varInfo_numZeroCrossings, numTimeEvents = i_varInfo_numTimeEvents, numStateVars = i_varInfo_numStateVars, numAlgVars = i_varInfo_numAlgVars, numAlgAliasVars = i_varInfo_numAlgAliasVars, numParams = i_varInfo_numParams, numOutVars = i_varInfo_numOutVars, numInVars = i_varInfo_numInVars, numInitialResiduals = i_varInfo_numInitialResiduals, numExternalObjects = i_varInfo_numExternalObjects, numStringAlgVars = i_varInfo_numStringAlgVars, numStringAliasVars = i_varInfo_numStringAliasVars, numIntAlgVars = i_varInfo_numIntAlgVars, numIntAliasVars = i_varInfo_numIntAliasVars, numBoolAlgVars = i_varInfo_numBoolAlgVars, numBoolAliasVars = i_varInfo_numBoolAliasVars, numIntParams = i_varInfo_numIntParams, numBoolParams = i_varInfo_numBoolParams, numStringParamVars = i_varInfo_numStringParamVars), vars = SimCode.SIMVARS(stateVars = i_vars_stateVars, derivativeVars = i_vars_derivativeVars, algVars = i_vars_algVars, aliasVars = i_vars_aliasVars, intAlgVars = i_vars_intAlgVars, intAliasVars = i_vars_intAliasVars, boolAlgVars = i_vars_boolAlgVars, boolAliasVars = i_vars_boolAliasVars, paramVars = i_vars_paramVars, intParamVars = i_vars_intParamVars, boolParamVars = i_vars_boolParamVars), functions = i_functions, name = i_name),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "#region Model description\n",
                                    "const int\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NHELP = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numHelpVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NG = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numZeroCrossings));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NG_SAM = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numTimeEvents));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NX = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStateVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NY = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NA = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numAlgAliasVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ", // number of alias variables\n",
                                    "NP = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numParams));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NO = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numOutVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NI = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numInVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NR = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numInitialResiduals));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NEXT = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numExternalObjects));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "//NFUNC = "
                                }, false));
        ret_0 = listLength(i_functions);
        txt = Tpl.writeStr(txt, intString(ret_0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ", // number of functions used by the simulation\n",
                                    "NYSTR = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStringAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NASTR = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStringAliasVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ", // number of alias string variables\n",
                                    "NYI = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numIntAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NAI = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numIntAliasVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ", // number of alias int variables\n",
                                    "NYB = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numBoolAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NAB = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numBoolAliasVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ", // number of alias bool variables\n",
                                    "NPI = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numIntParams));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NPB = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numBoolParams));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ",\n",
                                    "NPSTR = "
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStringParamVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("public override string ModelName        { get { return \""));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\"; }}\n",
                                    "public override int HelpVarsCount       { get { return NHELP; } }\n",
                                    "public override int ZeroCrossingsCount  { get { return NG; } }\n",
                                    "public override int SampleTypesCount    { get { return NG_SAM; } }\n",
                                    "public override int StatesCount         { get { return NX; } }\n",
                                    "public override int AlgebraicsCount     { get { return NY; } }\n",
                                    "public override int AlgebraicsIntCount  { get { return NYI; } }\n",
                                    "public override int AlgebraicsBoolCount { get { return NYB; } }\n",
                                    "public override int ParametersCount     { get { return NP; } }\n",
                                    "public override int ParametersIntCount  { get { return NPI; } }\n",
                                    "public override int ParametersBoolCount { get { return NPB; } }\n",
                                    "\n",
                                    "public override int OutputsCount   { get { return NO; } }\n",
                                    "public override int InputsCount    { get { return NI; } }\n",
                                    "public override int ResidualsCount { get { return NR; } }\n",
                                    "public override int ExternalObjectsCount { get { return NEXT; } }\n",
                                    "public override int MaximumOrder { get { return 5; } }\n",
                                    "public override int StringVarsCount { get { return NYSTR; } }\n",
                                    "public override int StringParametersCount { get { return NPSTR; } }\n",
                                    "\n",
                                    "#endregion\n",
                                    "\n",
                                    "#region VariableInfos\n",
                                    "public static readonly SimVarInfo[] VariableInfosStatic = new[] {\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt_1 = varInfos(Tpl.emptyTxt, "State", i_vars_stateVars, false, a_simCode);
        txt_2 = varInfos(Tpl.emptyTxt, "StateDer", i_vars_derivativeVars, false, a_simCode);
        txt_3 = varInfos(Tpl.emptyTxt, "Algebraic", i_vars_algVars, false, a_simCode);
        txt_4 = varInfos(Tpl.emptyTxt, "alias Algebraic", i_vars_aliasVars, false, a_simCode);
        txt_5 = varInfos(Tpl.emptyTxt, "AlgebraicInt", i_vars_intAlgVars, false, a_simCode);
        txt_6 = varInfos(Tpl.emptyTxt, "alias AlgebraicInt", i_vars_intAliasVars, false, a_simCode);
        txt_7 = varInfos(Tpl.emptyTxt, "AlgebraicBool", i_vars_boolAlgVars, false, a_simCode);
        txt_8 = varInfos(Tpl.emptyTxt, "alias AlgebraicBool", i_vars_boolAliasVars, false, a_simCode);
        txt_9 = varInfos(Tpl.emptyTxt, "Parameter", i_vars_paramVars, true, a_simCode);
        txt_10 = varInfos(Tpl.emptyTxt, "ParameterInt", i_vars_intParamVars, true, a_simCode);
        txt_11 = varInfos(Tpl.emptyTxt, "ParameterBool", i_vars_boolParamVars, true, a_simCode);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                     ",\n",
                                                                     "\n"
                                                                 }, true)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = smf_61(txt, txt_1);
        txt = smf_62(txt, txt_2);
        txt = smf_63(txt, txt_3);
        txt = smf_64(txt, txt_4);
        txt = smf_65(txt, txt_5);
        txt = smf_66(txt, txt_6);
        txt = smf_67(txt, txt_7);
        txt = smf_68(txt, txt_8);
        txt = smf_69(txt, txt_9);
        txt = smf_70(txt, txt_10);
        txt = smf_71(txt, txt_11);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "};\n",
                                    "public override SimVarInfo[] VariableInfos { get { return VariableInfosStatic; } }\n",
                                    "#endregion\n",
                                    "\n",
                                    "#region InitialFixed\n",
                                    "private static readonly bool[] InitialFixedStatic = new bool[NX + NX + NY + NYI +NYB + NP + NPI + NPB] {\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt_12 = fun_72(Tpl.emptyTxt, i_vars_stateVars, a_simCode);
        txt_13 = fun_73(Tpl.emptyTxt, i_vars_derivativeVars, a_simCode);
        txt_14 = fun_74(Tpl.emptyTxt, i_vars_algVars, a_simCode);
        txt_15 = fun_75(Tpl.emptyTxt, i_vars_intAlgVars, a_simCode);
        txt_16 = fun_76(Tpl.emptyTxt, i_vars_boolAlgVars, a_simCode);
        txt_17 = fun_77(Tpl.emptyTxt, i_vars_paramVars, a_simCode);
        txt_18 = fun_78(Tpl.emptyTxt, i_vars_intParamVars, a_simCode);
        txt_19 = fun_79(Tpl.emptyTxt, i_vars_boolParamVars, a_simCode);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = smf_80(txt, txt_12);
        txt = smf_81(txt, txt_13);
        txt = smf_82(txt, txt_14);
        txt = smf_83(txt, txt_15);
        txt = smf_84(txt, txt_16);
        txt = smf_85(txt, txt_17);
        txt = smf_86(txt, txt_18);
        txt = smf_87(txt, txt_19);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "};\n",
                                    "public override bool[] InitialFixed { get { return InitialFixedStatic; } }\n",
                                    "#endregion\n",
                                    "\n",
                                    "#region Constructor - Init Data\n",
                                    "public "
                                }, false));
        txt = lastIdentOfPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "() {\n",
                                    "    CreateData();\n",
                                    "\n",
                                    "    //**** states *****\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = initVals(txt, "states", i_vars_stateVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** state derivatives *****\n",
                                    "//all are default values ... 0.0\n",
                                    "\n",
                                    "//**** algebraics *****\n"
                                }, true));
        txt = initVals(txt, "algebraics", i_vars_algVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** algebraics Int *****\n"
                                }, true));
        txt = initVals(txt, "algebraicsInt", i_vars_intAlgVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** algebraics Bool *****\n"
                                }, true));
        txt = initVals(txt, "algebraicsBool", i_vars_boolAlgVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** parameters *****\n"
                                }, true));
        txt = initVals(txt, "parameters", i_vars_paramVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** parameters Int *****\n"
                                }, true));
        txt = initVals(txt, "parametersInt", i_vars_intParamVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//**** parameters Bool *****\n"
                                }, true));
        txt = initVals(txt, "parametersBool", i_vars_boolParamVars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "#endregion"
                                }, false));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end modelDataMembers;

public function simVarTypeName
  input Tpl.Text in_txt;
  input BackendDAE.VarKind in_a_varKind;
  input DAE.Type in_a_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_varKind, in_a_type__)
    local
      Tpl.Text txt;
      DAE.Type a_type__;

    case ( txt,
           BackendDAE.VARIABLE(),
           a_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Algebraic"));
        txt = simVarTypeNamePostfix(txt, a_type__);
      then txt;

    case ( txt,
           BackendDAE.STATE(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("State"));
      then txt;

    case ( txt,
           BackendDAE.STATE_DER(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("StateDer"));
      then txt;

    case ( txt,
           BackendDAE.DUMMY_DER(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Algebraic"));
      then txt;

    case ( txt,
           BackendDAE.DUMMY_STATE(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Algebraic"));
      then txt;

    case ( txt,
           BackendDAE.DISCRETE(),
           a_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Algebraic"));
        txt = simVarTypeNamePostfix(txt, a_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*d*/"));
      then txt;

    case ( txt,
           BackendDAE.PARAM(),
           a_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Parameter"));
        txt = simVarTypeNamePostfix(txt, a_type__);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = error(txt, Tpl.sourceInfo("CodegenCSharp.tpl", 411, 14), "Unexpected simVarTypeName varKind");
      then txt;
  end matchcontinue;
end simVarTypeName;

public function simVarTypeNamePostfix
  input Tpl.Text in_txt;
  input DAE.Type in_a_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_type__)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.T_INTEGER(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Int"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _) )
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Bool"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("String"));
      then txt;

    case ( txt,
           DAE.T_ENUMERATION(index = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*Enum*/"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = error(txt, Tpl.sourceInfo("CodegenCSharp.tpl", 426, 14), "Unknown simVarTypeNamePostfix");
      then txt;
  end matchcontinue;
end simVarTypeNamePostfix;

protected function smf_91
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Integer i_index;
      DAE.Type i_type__;
      BackendDAE.VarKind i_varKind;

    case ( txt,
           SimCode.SIMVAR(varKind = i_varKind, type_ = i_type__, index = i_index) )
      equation
        txt = simVarTypeName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_index));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end smf_91;

protected function smf_92
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Integer i_index;
      DAE.Type i_type__;
      BackendDAE.VarKind i_varKind;

    case ( txt,
           SimCode.SIMVAR(varKind = i_varKind, type_ = i_type__, index = i_index) )
      equation
        txt = simVarTypeName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_index));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end smf_92;

protected function fun_93
  input Tpl.Text in_txt;
  input SimCode.AliasVariable in_a_aliasvar;
  input SimCode.SimCode in_a_simCode;
  input Integer in_a_sv_index;
  input DAE.Type in_a_sv_type__;
  input BackendDAE.VarKind in_a_sv_varKind;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_aliasvar, in_a_simCode, in_a_sv_index, in_a_sv_type__, in_a_sv_varKind)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Integer a_sv_index;
      DAE.Type a_sv_type__;
      BackendDAE.VarKind a_sv_varKind;
      DAE.ComponentRef i_varName;
      SimCode.SimVar ret_1;
      SimCode.SimVar ret_0;

    case ( txt,
           SimCode.NOALIAS(),
           _,
           a_sv_index,
           a_sv_type__,
           a_sv_varKind )
      equation
        txt = simVarTypeName(txt, a_sv_varKind, a_sv_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", 0"));
      then txt;

    case ( txt,
           SimCode.ALIAS(varName = i_varName),
           a_simCode,
           _,
           _,
           _ )
      equation
        ret_0 = SimCode.cref2simvar(i_varName, a_simCode);
        txt = smf_91(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", 1/*alias to "));
        txt = crefStr(txt, i_varName, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
      then txt;

    case ( txt,
           SimCode.NEGATEDALIAS(varName = i_varName),
           a_simCode,
           _,
           _,
           _ )
      equation
        ret_1 = SimCode.cref2simvar(i_varName, a_simCode);
        txt = smf_92(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", -1/*alias to "));
        txt = crefStr(txt, i_varName, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _ )
      equation
        txt = error(txt, Tpl.sourceInfo("CodegenCSharp.tpl", 439, 22), "Unknown alias var type");
      then txt;
  end matchcontinue;
end fun_93;

protected function lm_94
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      String i_comment;
      DAE.ComponentRef i_name;
      Integer i_sv_index;
      DAE.Type i_sv_type__;
      BackendDAE.VarKind i_sv_varKind;
      SimCode.AliasVariable i_aliasvar;
      String ret_1;
      Tpl.Text l_typeIdxAndAliasMode;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(aliasvar = i_aliasvar, varKind = i_sv_varKind, type_ = i_sv_type__, index = i_sv_index, name = i_name, comment = i_comment) :: rest,
           a_simCode )
      equation
        l_typeIdxAndAliasMode = fun_93(Tpl.emptyTxt, i_aliasvar, a_simCode, i_sv_index, i_sv_type__, i_sv_varKind);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("new SimVarInfo( \""));
        txt = crefStr(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", \""));
        ret_1 = Util.escapeModelicaStringToCString(i_comment);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", SimVarType."));
        txt = Tpl.writeText(txt, l_typeIdxAndAliasMode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        txt = Tpl.nextIter(txt);
        txt = lm_94(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_94(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_94;

protected function fun_95
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_a_varsLst;
  input String in_a_regionName;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_varsLst, in_a_regionName, in_a_simCode)
    local
      Tpl.Text txt;
      String a_regionName;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_varsLst;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_varsLst,
           a_regionName,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("#region "));
        txt = Tpl.writeStr(txt, a_regionName);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" variable infos\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_94(txt, i_varsLst, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("#endregion"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then txt;
  end matchcontinue;
end fun_95;

public function varInfos
  input Tpl.Text txt;
  input String a_regionName;
  input list<SimCode.SimVar> a_varsLst;
  input Boolean a_isMInd;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_95(txt, a_varsLst, a_regionName, a_simCode);
end varInfos;

protected function fun_97
  input Tpl.Text in_txt;
  input String in_mArg;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_sv_name;
  input Integer in_a_sv_index;
  input String in_a_arrName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_mArg, in_a_simCode, in_a_sv_name, in_a_sv_index, in_a_arrName)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_sv_name;
      Integer a_sv_index;
      String a_arrName;
      String i_vStr;

    case ( txt,
           (i_vStr as "0"),
           a_simCode,
           a_sv_name,
           a_sv_index,
           a_arrName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, a_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, a_sv_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           (i_vStr as "0.0"),
           a_simCode,
           a_sv_name,
           a_sv_index,
           a_arrName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, a_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, a_sv_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           (i_vStr as "false"),
           a_simCode,
           a_sv_name,
           a_sv_index,
           a_arrName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, a_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, a_sv_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           (i_vStr as "(0)"),
           a_simCode,
           a_sv_name,
           a_sv_index,
           a_arrName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, a_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, a_sv_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> zero val"));
      then txt;

    case ( txt,
           i_vStr,
           a_simCode,
           a_sv_name,
           a_sv_index,
           a_arrName )
      equation
        txt = Tpl.writeStr(txt, a_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeStr(txt, i_vStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //"));
        txt = crefStr(txt, a_sv_name, a_simCode);
      then txt;
  end matchcontinue;
end fun_97;

protected function fun_98
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_a_initialValue;
  input DAE.ComponentRef in_a_sv_name;
  input Integer in_a_sv_index;
  input String in_a_arrName;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_initialValue, in_a_sv_name, in_a_sv_index, in_a_arrName, in_a_simCode)
    local
      Tpl.Text txt;
      DAE.ComponentRef a_sv_name;
      Integer a_sv_index;
      String a_arrName;
      SimCode.SimCode a_simCode;
      DAE.Exp i_v;
      String str_2;
      Tpl.Text txt_1;
      Tpl.Text l_preExp;

    case ( txt,
           SOME(i_v),
           a_sv_name,
           a_sv_index,
           a_arrName,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (txt_1, l_preExp) = daeExp(Tpl.emptyTxt, i_v, SimCode.contextOther, l_preExp, a_simCode);
        str_2 = Tpl.textString(txt_1);
        txt = fun_97(txt, str_2, a_simCode, a_sv_name, a_sv_index, a_arrName);
      then txt;

    case ( txt,
           _,
           a_sv_name,
           a_sv_index,
           a_arrName,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//"));
        txt = Tpl.writeStr(txt, a_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(a_sv_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = 0.0; //"));
        txt = crefStr(txt, a_sv_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" --> default val"));
      then txt;
  end matchcontinue;
end fun_98;

protected function lm_99
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input String in_a_arrName;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_arrName, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      String a_arrName;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_sv_name;
      Integer i_sv_index;
      Option<DAE.Exp> i_initialValue;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(initialValue = i_initialValue, index = i_sv_index, name = i_sv_name) :: rest,
           a_arrName,
           a_simCode )
      equation
        txt = fun_98(txt, i_initialValue, i_sv_name, i_sv_index, a_arrName, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_99(txt, rest, a_arrName, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_arrName,
           a_simCode )
      equation
        txt = lm_99(txt, rest, a_arrName, a_simCode);
      then txt;
  end matchcontinue;
end lm_99;

public function initVals
  input Tpl.Text txt;
  input String a_arrName;
  input list<SimCode.SimVar> a_varsLst;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_99(out_txt, a_varsLst, a_arrName, a_simCode);
  out_txt := Tpl.popIter(out_txt);
end initVals;

protected function lm_101
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_name;
      Boolean i_isFixed;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(isFixed = i_isFixed, name = i_name) :: rest,
           a_simCode )
      equation
        txt = Tpl.writeStr(txt, Tpl.booleanString(i_isFixed));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" /* "));
        txt = crefStr(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" */"));
        txt = Tpl.nextIter(txt);
        txt = lm_101(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_101(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_101;

public function initFixed
  input Tpl.Text txt;
  input list<SimCode.SimVar> a_simVarLst;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_101(out_txt, a_simVarLst, a_simCode);
  out_txt := Tpl.popIter(out_txt);
end initFixed;

protected function lm_103
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_var_name;
      DAE.Exp i_exp;
      Tpl.Text l_arg;
      Tpl.Text l_preExp;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(initialValue = SOME(i_exp), name = i_var_name) :: rest,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_arg, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, SimCode.contextOther, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_var_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_arg);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = lm_103(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_103(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_103;

protected function lm_104
  input Tpl.Text in_txt;
  input list<SimCode.ExtAlias> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.ExtAlias> rest;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_var2;
      DAE.ComponentRef i_var1;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_var1, i_var2) :: rest,
           a_simCode )
      equation
        txt = cref(txt, i_var1, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = cref(txt, i_var2, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_104(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_104(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_104;

public function functionCallExternalObjectConstructors
  input Tpl.Text in_txt;
  input SimCode.ExtObjInfo in_a_extObjInfo;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_extObjInfo, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.ExtAlias> i_aliases;
      list<SimCode.SimVar> i_vars;

    case ( txt,
           SimCode.EXTOBJINFO(vars = i_vars, aliases = i_aliases),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("public override void FunCallExternalObjectConstructors() {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = lm_103(txt, i_vars, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_104(txt, i_aliases, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "\n"
                                }, true));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionCallExternalObjectConstructors;

protected function lm_106
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_it;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_it, SimCode.contextSimulationNonDiscrete, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_106(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_106(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_106;

public function functionAlgebraic
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_algebraicEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunAlgebraics()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_106(out_txt, a_algebraicEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionAlgebraic;

protected function lm_108
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_eq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_eq, SimCode.contextSimulationNonDiscrete, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_108(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_108(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_108;

public function functionAliasEquation
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_removedEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunAliasEquations()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_108(out_txt, a_removedEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionAliasEquation;

protected function lm_110
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = inputVars["));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("];"));
        txt = Tpl.nextIter(txt);
        txt = lm_110(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_110(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_110;

public function functionInput
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_inputVars;

    case ( txt,
           SimCode.MODELINFO(varInfo = SimCode.VARINFO(numHelpVars = _), vars = SimCode.SIMVARS(inputVars = i_vars_inputVars)),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override void InputFun()\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_110(txt, i_vars_inputVars, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionInput;

protected function lm_112
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//outputVars["));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_112(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_112(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_112;

public function functionOutput
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimVar> i_vars_outputVars;

    case ( txt,
           SimCode.MODELINFO(varInfo = SimCode.VARINFO(numHelpVars = _), vars = SimCode.SIMVARS(outputVars = i_vars_outputVars)),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override void OutputFun()\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("// * not yet\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_112(txt, i_vars_outputVars, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionOutput;

protected function fun_114
  input Tpl.Text in_txt;
  input list<SimCode.SampleCondition> in_a_sampleConditions;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_sampleConditions)
    local
      Tpl.Text txt;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int i = 0; // Current index"));
      then txt;
  end matchcontinue;
end fun_114;

protected function fun_115
  input Tpl.Text in_txt;
  input DAE.Exp in_a_relation;
  input SimCode.SimCode in_a_simCode;
  input Integer in_a_zcIndex;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_relation, in_a_simCode, in_a_zcIndex)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Integer a_zcIndex;
      DAE.Exp i_interval;
      DAE.Exp i_start;
      Tpl.Text l_intervalE;
      Tpl.Text l_startE;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.RELATION(exp1 = _),
           _,
           a_zcIndex )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* "));
        txt = Tpl.writeStr(txt, intString(a_zcIndex));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" Not a time event */"));
      then txt;

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "sample"), expLst = {i_start, i_interval, _}),
           a_simCode,
           a_zcIndex )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_startE, l_preExp) = daeExp(Tpl.emptyTxt, i_start, SimCode.contextOther, l_preExp, a_simCode);
        (l_intervalE, l_preExp) = daeExp(Tpl.emptyTxt, i_interval, SimCode.contextOther, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SA[i++] = new OneSample("));
        txt = Tpl.writeText(txt, l_intervalE);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_startE);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(a_zcIndex));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", false);"));
      then txt;

    case ( txt,
           _,
           _,
           a_zcIndex )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* UNKNOWN ZERO CROSSING for "));
        txt = Tpl.writeStr(txt, intString(a_zcIndex));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" */"));
      then txt;
  end matchcontinue;
end fun_115;

protected function lm_116
  input Tpl.Text in_txt;
  input list<SimCode.SampleCondition> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SampleCondition> rest;
      SimCode.SimCode a_simCode;
      Integer i_zcIndex;
      DAE.Exp i_relation;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_relation, i_zcIndex) :: rest,
           a_simCode )
      equation
        txt = fun_115(txt, i_relation, a_simCode, i_zcIndex);
        txt = lm_116(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_116(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_116;

public function functionInitSample
  input Tpl.Text txt;
  input list<SimCode.SampleCondition> a_sampleConditions;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunSampleInit()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE("var SA = Samples.SamplesArr;\n"));
  out_txt := fun_114(out_txt, a_sampleConditions);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := lm_116(out_txt, a_sampleConditions, a_simCode);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionInitSample;

protected function lm_118
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_eq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_eq, SimCode.contextSimulationDiscrete, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_118(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_118(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_118;

public function functionSampleEquations
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_sampleEqns;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunUpdateSample()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_NEW_LINE());
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_118(out_txt, a_sampleEqns, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionSampleEquations;

protected function lm_120
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_eq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_eq, SimCode.contextSimulationDiscrete, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_120(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_120(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_120;

protected function lm_121
  input Tpl.Text in_txt;
  input list<SimCode.SimWhenClause> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimWhenClause> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      SimCode.SimWhenClause i_when;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_when :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = genreinits(txt, i_when, x_i0, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_121(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_121(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_121;

public function functionDAE
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_allEquationsPlusWhen;
  input list<SimCode.SimWhenClause> a_whenClauses;
  input list<SimCode.HelpVarInfo> a_helpVarInfo;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override bool FunDAE()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "var needToIterate = false;\n",
                                       "isInUpdate = ! isInit;\n",
                                       "\n"
                                   }, true));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_120(out_txt, a_allEquationsPlusWhen, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_NEW_LINE());
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_121(out_txt, a_whenClauses, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "\n",
                                       "isInUpdate = false;\n",
                                       "return needToIterate;\n"
                                   }, true));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionDAE;

protected function lm_123
  input Tpl.Text in_txt;
  input list<tuple<DAE.Exp, Integer>> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp)
    local
      Tpl.Text txt;
      list<tuple<DAE.Exp, Integer>> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      Integer i_hidx;
      DAE.Exp i_e;
      Tpl.Text l_helpInit;

    case ( txt,
           {},
           _,
           a_preExp )
      then (txt, a_preExp);

    case ( txt,
           (i_e, i_hidx) :: rest,
           a_simCode,
           a_preExp )
      equation
        (l_helpInit, a_preExp) = daeExp(Tpl.emptyTxt, i_e, SimCode.contextSimulationDiscrete, a_preExp, a_simCode);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("H["));
        a_preExp = Tpl.writeStr(a_preExp, intString(i_hidx));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("] = "));
        a_preExp = Tpl.writeText(a_preExp, l_helpInit);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(" ?1.0:0.0;"));
        txt = edgeHelpVar(txt, intString(i_hidx));
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_123(txt, rest, a_simCode, a_preExp);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp )
      equation
        (txt, a_preExp) = lm_123(txt, rest, a_simCode, a_preExp);
      then (txt, a_preExp);
  end matchcontinue;
end lm_123;

protected function fun_124
  input Tpl.Text in_txt;
  input list<BackendDAE.WhenOperator> in_a_reinits;
  input Integer in_a_widx;
  input SimCode.SimCode in_a_simCode;
  input list<tuple<DAE.Exp, Integer>> in_a_conditions;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_reinits, in_a_widx, in_a_simCode, in_a_conditions)
    local
      Tpl.Text txt;
      Integer a_widx;
      SimCode.SimCode a_simCode;
      list<tuple<DAE.Exp, Integer>> a_conditions;
      list<BackendDAE.WhenOperator> i_reinits;
      Tpl.Text l_helpIf;
      Tpl.Text l_preExp;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_reinits,
           a_widx,
           a_simCode,
           a_conditions )
      equation
        l_preExp = Tpl.emptyTxt;
        l_helpIf = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(" || ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_helpIf, l_preExp) = lm_123(l_helpIf, a_conditions, a_simCode, l_preExp);
        l_helpIf = Tpl.popIter(l_helpIf);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "//For whenclause index: "
                                }, false));
        txt = Tpl.writeStr(txt, intString(a_widx));
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, l_helpIf);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = functionWhenReinitStatementThen(txt, i_reinits, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;
  end matchcontinue;
end fun_124;

public function genreinits
  input Tpl.Text in_txt;
  input SimCode.SimWhenClause in_a_whenClauses;
  input Integer in_a_widx;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_whenClauses, in_a_widx, in_a_simCode)
    local
      Tpl.Text txt;
      Integer a_widx;
      SimCode.SimCode a_simCode;
      list<tuple<DAE.Exp, Integer>> i_conditions;
      list<BackendDAE.WhenOperator> i_reinits;

    case ( txt,
           SimCode.SIM_WHEN_CLAUSE(reinits = i_reinits, conditions = i_conditions),
           a_widx,
           a_simCode )
      equation
        txt = fun_124(txt, i_reinits, a_widx, a_simCode, i_conditions);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end genreinits;

protected function fun_126
  input Tpl.Text in_txt;
  input BackendDAE.WhenOperator in_a_reinit;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_reinit, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Absyn.Info i_info;
      DAE.Exp i_condition;
      DAE.Exp i_message;
      DAE.ComponentRef i_stateVar;
      DAE.Exp i_value;
      Tpl.Text l_msgVar;
      Tpl.Text l_val;
      Tpl.Text l_preExp;

    case ( txt,
           BackendDAE.REINIT(value = i_value, stateVar = i_stateVar),
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_val, l_preExp) = daeExp(Tpl.emptyTxt, i_value, SimCode.contextSimulationDiscrete, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_stateVar, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_val);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "needToIterate = true;"
                                }, false));
      then txt;

    case ( txt,
           BackendDAE.TERMINATE(message = i_message),
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_msgVar, l_preExp) = daeExp(Tpl.emptyTxt, i_message, SimCode.contextSimulationDiscrete, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MODELICA_TERMINATE("));
        txt = Tpl.writeText(txt, l_msgVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
      then txt;

    case ( txt,
           BackendDAE.ASSERT(source = DAE.SOURCE(info = i_info), condition = i_condition, message = i_message),
           a_simCode )
      equation
        txt = assertCommon(txt, i_condition, i_message, i_info, SimCode.contextSimulationDiscrete, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_126;

protected function lm_127
  input Tpl.Text in_txt;
  input list<BackendDAE.WhenOperator> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<BackendDAE.WhenOperator> rest;
      SimCode.SimCode a_simCode;
      BackendDAE.WhenOperator i_reinit;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_reinit :: rest,
           a_simCode )
      equation
        txt = fun_126(txt, i_reinit, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_127(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_127(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_127;

public function functionWhenReinitStatementThen
  input Tpl.Text txt;
  input list<BackendDAE.WhenOperator> a_reinits;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_127(out_txt, a_reinits, a_simCode);
  out_txt := Tpl.popIter(out_txt);
end functionWhenReinitStatementThen;

protected function fun_129
  input Tpl.Text in_txt;
  input Boolean in_a_isReadOnly;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_isReadOnly)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("1"));
      then txt;
  end matchcontinue;
end fun_129;

public function infoArgs
  input Tpl.Text in_txt;
  input Absyn.Info in_a_info;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_info)
    local
      Tpl.Text txt;
      Boolean i_isReadOnly;
      Integer i_columnNumberEnd;
      Integer i_lineNumberEnd;
      Integer i_columnNumberStart;
      Integer i_lineNumberStart;
      String i_fileName;

    case ( txt,
           Absyn.INFO(fileName = i_fileName, lineNumberStart = i_lineNumberStart, columnNumberStart = i_columnNumberStart, lineNumberEnd = i_lineNumberEnd, columnNumberEnd = i_columnNumberEnd, isReadOnly = i_isReadOnly) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\""));
        txt = Tpl.writeStr(txt, i_fileName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\","));
        txt = Tpl.writeStr(txt, intString(i_lineNumberStart));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeStr(txt, intString(i_columnNumberStart));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeStr(txt, intString(i_lineNumberEnd));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeStr(txt, intString(i_columnNumberEnd));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = fun_129(txt, i_isReadOnly);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end infoArgs;

public function assertCommon
  input Tpl.Text txt;
  input DAE.Exp a_condition;
  input DAE.Exp a_message;
  input Absyn.Info a_info;
  input SimCode.Context a_context;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
protected
  Tpl.Text l_msgVar;
  Tpl.Text l_condVar;
  Tpl.Text l_preExpMsg;
  Tpl.Text l_preExpCond;
algorithm
  l_preExpCond := Tpl.emptyTxt;
  l_preExpMsg := Tpl.emptyTxt;
  (l_condVar, l_preExpCond) := daeExp(Tpl.emptyTxt, a_condition, a_context, l_preExpCond, a_simCode);
  (l_msgVar, l_preExpMsg) := daeExp(Tpl.emptyTxt, a_message, a_context, l_preExpMsg, a_simCode);
  out_txt := Tpl.writeText(txt, l_preExpCond);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("if (!"));
  out_txt := Tpl.writeText(out_txt, l_condVar);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE(") {\n"));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeText(out_txt, l_preExpMsg);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("//"));
  out_txt := infoArgs(out_txt, a_info);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("throw new Exception("));
  out_txt := Tpl.writeText(out_txt, l_msgVar);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE(");\n"));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end assertCommon;

protected function lm_132
  input Tpl.Text in_txt;
  input list<BackendDAE.ZeroCrossing> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<BackendDAE.ZeroCrossing> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.Exp i_relation__;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           BackendDAE.ZERO_CROSSING(relation_ = i_relation__) :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = zeroCrossing(txt, i_relation__, x_i0, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_132(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_132(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_132;

public function functionOnlyZeroCrossing
  input Tpl.Text txt;
  input list<BackendDAE.ZeroCrossing> a_zeroCrossingLst;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunOnlyZeroCrossings(double time, double[] gout) //TODO:??time in original is *t only ... how is it called?\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_132(out_txt, a_zeroCrossingLst, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionOnlyZeroCrossing;

protected function fun_134
  input Tpl.Text in_txt;
  input DAE.Operator in_a_operator;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_e1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_operator, in_a_e2, in_a_e1)
    local
      Tpl.Text txt;
      Tpl.Text a_e2;
      Tpl.Text a_e1;

    case ( txt,
           DAE.GREATER(ty = _),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, a_e2);
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = _),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, a_e2);
      then txt;

    case ( txt,
           DAE.LESS(ty = _),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, a_e1);
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = _),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, a_e1);
      then txt;

    case ( txt,
           DAE.EQUAL(ty = _),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*BE AWARE*/Math.Abs("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = _),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*BE AWARE*/Math.Abs("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!unsupported ZC operator!!!"));
      then txt;
  end matchcontinue;
end fun_134;

public function zeroCrossing
  input Tpl.Text in_txt;
  input DAE.Exp in_a_it;
  input Integer in_a_index;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it, in_a_index, in_a_simCode)
    local
      Tpl.Text txt;
      Integer a_index;
      SimCode.SimCode a_simCode;
      DAE.Exp i_interval;
      DAE.Exp i_start;
      DAE.Operator i_operator;
      Integer i_index;
      DAE.Exp i_exp2;
      DAE.Exp i_exp1;
      Tpl.Text l_eInterval;
      Tpl.Text l_eStart;
      Tpl.Text l_e2;
      Tpl.Text l_e1;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.RELATION(exp1 = i_exp1, exp2 = i_exp2, index = i_index, operator = i_operator),
           _,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_e1, l_preExp) = daeExp(Tpl.emptyTxt, i_exp1, SimCode.contextOther, l_preExp, a_simCode);
        (l_e2, l_preExp) = daeExp(Tpl.emptyTxt, i_exp2, SimCode.contextOther, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("gout["));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = fun_134(txt, i_operator, l_e2, l_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "sample"), expLst = {i_start, i_interval}),
           a_index,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_eStart, l_preExp) = daeExp(Tpl.emptyTxt, i_start, SimCode.contextOther, l_preExp, a_simCode);
        (l_eInterval, l_preExp) = daeExp(Tpl.emptyTxt, i_interval, SimCode.contextOther, l_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//ZEROCROSSING("));
        txt = Tpl.writeStr(txt, intString(a_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", Sample(*t, "));
        txt = Tpl.writeText(txt, l_eStart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_eInterval);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("));"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ZERO_CROSSING_ERROR"));
      then txt;
  end matchcontinue;
end zeroCrossing;

public function zeroCrossingOpFunc
  input Tpl.Text in_txt;
  input DAE.Operator in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.LESS(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Less"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Greater"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LessEq"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GreaterEq"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!Equal"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!NEqual"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!!!unsupported ZC operator!!!"));
      then txt;
  end matchcontinue;
end zeroCrossingOpFunc;

public function functionStoreDelayed
  input Tpl.Text txt;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunStoreDelayed()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionStoreDelayed;

protected function lm_138
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_it;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_it, SimCode.contextOther, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_138(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_138(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_138;

protected function lm_139
  input Tpl.Text in_txt;
  input list<list<SimCode.SimEqSystem>> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<list<SimCode.SimEqSystem>> rest;
      SimCode.SimCode a_simCode;
      list<SimCode.SimEqSystem> i_eqs;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eqs :: rest,
           a_simCode )
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_138(txt, i_eqs, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.nextIter(txt);
        txt = lm_139(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_139(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_139;

public function functionODE
  input Tpl.Text txt;
  input list<list<SimCode.SimEqSystem>> a_stateContEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void FunODE()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_139(out_txt, a_stateContEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionODE;

protected function lm_141
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_saeq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_saeq as SimCode.SES_SIMPLE_ASSIGN(index = _)) :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_saeq, SimCode.contextOther, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_141(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_141(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_141;

protected function lm_142
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_cref;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(cref = i_cref) :: rest,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//Debug.WriteLine(\"Setting variable start value: {0}(start={1})\", \""));
        txt = cref(txt, i_cref, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = cref(txt, i_cref, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_142(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_142(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_142;

public function functionInitial
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_startValueEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void InitialFun()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_141(out_txt, a_startValueEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "\n",
                                       "//if (sim_verbose) {\n"
                                   }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_142(out_txt, a_startValueEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE("//}\n"));
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionInitial;

protected function fun_144
  input Tpl.Text in_txt;
  input DAE.Exp in_a_exp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_exp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.Exp i_exp;
      Tpl.Text l_expPart;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.SCONST(string = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("initialResiduals[_i++] = 0;"));
      then txt;

    case ( txt,
           i_exp,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, SimCode.contextSimulationNonDiscrete, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("initialResiduals[_i++] = "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;
  end matchcontinue;
end fun_144;

protected function lm_145
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      DAE.Exp i_exp;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_RESIDUAL(exp = i_exp) :: rest,
           a_simCode )
      equation
        txt = fun_144(txt, i_exp, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_145(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_145(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_145;

public function functionInitialResidual
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_residualEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void InitialResidual()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING_LIST({
                                       "var startX = startStates; var startY = startAlgebraics; var startYB = startAlgebraicsBool; var startYI = startAlgebraicsInt;\n",
                                       "int _i = 0;\n",
                                       "const double _lambda = 1.0;\n",
                                       "\n"
                                   }, true));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_145(out_txt, a_residualEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionInitialResidual;

protected function fun_147
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_a_eq;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_eq, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_eq;
      SimCode.SimEqSystem i_cont;

    case ( txt,
           SimCode.SES_MIXED(cont = i_cont),
           a_simCode )
      equation
        txt = functionExtraResidual(txt, i_cont, a_simCode);
      then txt;

    case ( txt,
           (i_eq as SimCode.SES_NONLINEAR(index = _)),
           a_simCode )
      equation
        txt = functionExtraResidual(txt, i_eq, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_147;

protected function lm_148
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_eq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_simCode )
      equation
        txt = fun_147(txt, i_eq, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_148(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_148(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_148;

public function functionExtraResiduals
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_allEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_148(out_txt, a_allEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
end functionExtraResiduals;

protected function lm_150
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_saeq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_saeq as SimCode.SES_SIMPLE_ASSIGN(index = _)) :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_saeq, SimCode.contextOther, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_150(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_150(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_150;

protected function lm_151
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.Exp i_exp;
      Tpl.Text l_expPart;
      Tpl.Text l_preExp;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SES_RESIDUAL(exp = i_exp) :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, SimCode.contextSimulationDiscrete, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("res["));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_151(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_151(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_151;

public function functionExtraResidual
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_a_equ;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_equ, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<SimCode.SimEqSystem> i_eqs;
      Integer i_index;

    case ( txt,
           SimCode.SES_NONLINEAR(index = i_index, eqs = i_eqs),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int ResidualFun"));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "(int n, double[] xloc, double[] res, int iflag)\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(3));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_150(txt, i_eqs, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_151(txt, i_eqs, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("return 0;\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end functionExtraResidual;

protected function lm_153
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimCode a_simCode;
      SimCode.SimEqSystem i_saeq;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           (i_saeq as SimCode.SES_SIMPLE_ASSIGN(index = _)) :: rest,
           a_simCode )
      equation
        txt = equation_(txt, i_saeq, SimCode.contextOther, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_153(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_153(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_153;

public function functionBoundParameters
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_parameterEquations;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  System.tmpTickReset(1);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "public override void BoundParameters()\n",
                                   "{\n"
                               }, true));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.writeTok(out_txt, c_localRepresentationArrayDefines);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_153(out_txt, a_parameterEquations, a_simCode);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("}"));
end functionBoundParameters;

protected function fun_155
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_a_var;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_var, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_var;

    case ( txt,
           (i_var as DAE.CREF_QUAL(ident = _)),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = preCref(txt, i_var, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = cref(txt, i_var, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") return true;"));
      then txt;

    case ( txt,
           (i_var as DAE.CREF_IDENT(ident = _)),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = preCref(txt, i_var, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = cref(txt, i_var, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") return true;"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_155;

protected function lm_156
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> rest;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           a_simCode )
      equation
        txt = fun_155(txt, i_var, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_156(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_156(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_156;

public function functionCheckForDiscreteChanges
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode i_simCode;
      list<DAE.ComponentRef> i_discreteModelVars;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(discreteModelVars = i_discreteModelVars)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "public override bool CheckForDiscreteChanges()\n",
                                    "{\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, c_localRepresentationArrayDefines);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "//var needToIterate = false;\n",
                                    "//if change()\n"
                                }, true));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_156(txt, i_discreteModelVars, i_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("return false; //needToIterate;\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end functionCheckForDiscreteChanges;

public function edgeHelpVar
  input Tpl.Text txt;
  input String a_idx;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("(/*edge(h["));
  out_txt := Tpl.writeStr(out_txt, a_idx);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("])*/H["));
  out_txt := Tpl.writeStr(out_txt, a_idx);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("]!=0.0 && preH["));
  out_txt := Tpl.writeStr(out_txt, a_idx);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("]==0.0)"));
end edgeHelpVar;

protected function fun_159
  input Tpl.Text in_txt;
  input String in_mArg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_mArg)
    local
      Tpl.Text txt;

    case ( txt,
           "bool" )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" ?1.0:0.0"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_159;

public function daeExpToReal
  input Tpl.Text txt;
  input DAE.Exp a_exp;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
protected
  String str_1;
  Tpl.Text txt_0;
algorithm
  (out_txt, out_a_preExp) := daeExp(txt, a_exp, a_context, a_preExp, a_simCode);
  txt_0 := expTypeFromExp(Tpl.emptyTxt, a_exp);
  str_1 := Tpl.textString(txt_0);
  out_txt := fun_159(out_txt, str_1);
end daeExpToReal;

protected function lm_161
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_stmt;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_stmt, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_161(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_161(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_161;

protected function lm_162
  input Tpl.Text in_txt;
  input list<tuple<Integer, Integer, SimCode.SimEqSystem>> in_items;
  input Tpl.Text in_a_size;
  input Tpl.Text in_a_aname;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_size, in_a_aname, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> rest;
      Tpl.Text a_size;
      Tpl.Text a_aname;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      Integer i_col;
      Integer i_row;
      DAE.Exp i_eq_exp;
      Tpl.Text l_expPart;
      Tpl.Text l_preExp;

    case ( txt,
           {},
           _,
           _,
           _,
           _ )
      then txt;

    case ( txt,
           (i_row, i_col, SimCode.SES_RESIDUAL(exp = i_eq_exp)) :: rest,
           a_size,
           a_aname,
           a_simCode,
           a_context )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExpToReal(Tpl.emptyTxt, i_eq_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.writeText(txt, a_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_row));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("+"));
        txt = Tpl.writeStr(txt, intString(i_col));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*"));
        txt = Tpl.writeText(txt, a_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //set_matrix_elt("));
        txt = Tpl.writeText(txt, a_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_row));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_col));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_162(txt, rest, a_size, a_aname, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_size,
           a_aname,
           a_simCode,
           a_context )
      equation
        txt = lm_162(txt, rest, a_size, a_aname, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_162;

protected function lm_163
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input Tpl.Text in_a_bname;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_bname, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      Tpl.Text a_bname;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      Integer x_i0;
      DAE.Exp i_it;
      Tpl.Text l_expPart;
      Tpl.Text l_preExp;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           a_bname,
           a_simCode,
           a_context )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExpToReal(Tpl.emptyTxt, i_it, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.writeText(txt, a_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; //set_vector_elt("));
        txt = Tpl.writeText(txt, a_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_163(txt, rest, a_bname, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_bname,
           a_simCode,
           a_context )
      equation
        txt = lm_163(txt, rest, a_bname, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_163;

protected function fun_164
  input Tpl.Text in_txt;
  input Boolean in_a_partOfMixed;
  input Tpl.Text in_a_uid;
  input Tpl.Text in_a_size;
  input Tpl.Text in_a_bname;
  input Tpl.Text in_a_aname;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_partOfMixed, in_a_uid, in_a_size, in_a_bname, in_a_aname)
    local
      Tpl.Text txt;
      Tpl.Text a_uid;
      Tpl.Text a_size;
      Tpl.Text a_bname;
      Tpl.Text a_aname;

    case ( txt,
           false,
           a_uid,
           a_size,
           a_bname,
           a_aname )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SolveLinearSystem("));
        txt = Tpl.writeText(txt, a_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
      then txt;

    case ( txt,
           _,
           a_uid,
           a_size,
           a_bname,
           a_aname )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if(SolveLinearSystemMixed("));
        txt = Tpl.writeText(txt, a_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") != 0) found_solution = -1;"));
      then txt;
  end matchcontinue;
end fun_164;

protected function lm_165
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input Tpl.Text in_a_bname;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_bname, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      Tpl.Text a_bname;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           a_bname,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //get_vector_elt("));
        txt = Tpl.writeText(txt, a_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_165(txt, rest, a_bname, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_bname,
           a_simCode )
      equation
        txt = lm_165(txt, rest, a_bname, a_simCode);
      then txt;
  end matchcontinue;
end lm_165;

protected function lm_166
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input Tpl.Text in_a_preDisc;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preDisc;
algorithm
  (out_txt, out_a_preDisc) :=
  matchcontinue(in_txt, in_items, in_a_preDisc, in_a_context, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      Tpl.Text a_preDisc;
      SimCode.Context a_context;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.Exp i_discEq_exp;
      DAE.ComponentRef i_discEq_cref;

    case ( txt,
           {},
           a_preDisc,
           _,
           _ )
      then (txt, a_preDisc);

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(cref = i_discEq_cref, exp = i_discEq_exp) :: rest,
           a_preDisc,
           a_context,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_discEq_cref, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        (txt, a_preDisc) = daeExp(txt, i_discEq_exp, a_context, a_preDisc, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "double discrete_loc2_"
                                }, false));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = crefToReal(txt, i_discEq_cref, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        (txt, a_preDisc) = lm_166(txt, rest, a_preDisc, a_context, a_simCode);
      then (txt, a_preDisc);

    case ( txt,
           _ :: rest,
           a_preDisc,
           a_context,
           a_simCode )
      equation
        (txt, a_preDisc) = lm_166(txt, rest, a_preDisc, a_context, a_simCode);
      then (txt, a_preDisc);
  end matchcontinue;
end lm_166;

protected function lm_167
  input Tpl.Text in_txt;
  input list<Integer> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Integer> rest;
      Integer i_it;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_it :: rest )
      equation
        txt = Tpl.writeStr(txt, intString(i_it));
        txt = Tpl.nextIter(txt);
        txt = lm_167(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_167(txt, rest);
      then txt;
  end matchcontinue;
end lm_167;

protected function lm_168
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double discrete_loc_"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = crefToReal(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_168(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_168(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_168;

protected function lm_169
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      Integer x_i0;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = _) :: rest )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ( Math.Abs(discrete_loc_"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - discrete_loc2_"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") > 1e-12) found_solution = 0;"));
        txt = Tpl.nextIter(txt);
        txt = lm_169(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_169(txt, rest);
      then txt;
  end matchcontinue;
end lm_169;

protected function lm_170
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;
      Tpl.Text txt_0;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = i_name) :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt_0 = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("values[curValOffset+"));
        txt_0 = Tpl.writeStr(txt_0, intString(x_i0));
        txt_0 = Tpl.writeTok(txt_0, Tpl.ST_STRING("]"));
        (txt, txt_0) = convertRealExpForCref(txt, txt_0, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_170(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_170(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_170;

protected function lm_171
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_name :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("nls_x["));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = /*extraPolate("));
        txt = crefStr(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")*/ oldTimeDelta == 0.0 ? "));
        txt = cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" : (time * ("));
        txt = oldCref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - "));
        txt = old2Cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") + (timeOld * "));
        txt = old2Cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" - timeOld2 * "));
        txt = oldCref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ")) / oldTimeDelta;\n",
                                    "nls_xold["
                                }, false));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = oldCref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_171(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_171(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_171;

protected function lm_172
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> rest;
      SimCode.SimCode a_simCode;
      Integer x_i0;
      DAE.ComponentRef i_name;
      Tpl.Text txt_0;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_name :: rest,
           a_simCode )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = cref(txt, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt_0 = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("nls_x["));
        txt_0 = Tpl.writeStr(txt_0, intString(x_i0));
        txt_0 = Tpl.writeTok(txt_0, Tpl.ST_STRING("]"));
        (txt, txt_0) = convertRealExpForCref(txt, txt_0, i_name, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_172(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_172(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_172;

protected function lm_173
  input Tpl.Text in_txt;
  input list<tuple<DAE.Exp, Integer>> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<tuple<DAE.Exp, Integer>> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      Integer i_hidx;
      DAE.Exp i_e;
      Tpl.Text l_hInit;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           (i_e, i_hidx) :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (l_hInit, a_preExp) = daeExp(Tpl.emptyTxt, i_e, a_context, a_preExp, a_simCode);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("H["));
        a_preExp = Tpl.writeStr(a_preExp, intString(i_hidx));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("] = "));
        a_preExp = Tpl.writeText(a_preExp, l_hInit);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(" ? 1.0 : 0.0;"));
        txt = edgeHelpVar(txt, intString(i_hidx));
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_173(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_173(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_173;

public function equation_
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_a_eq;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_eq, in_a_context, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_left;
      DAE.Exp i_right;
      list<tuple<DAE.Exp, Integer>> i_conditions;
      Integer i_index;
      list<DAE.ComponentRef> i_crefs;
      list<SimCode.SimEqSystem> i_discEqs;
      list<Integer> i_values;
      list<SimCode.SimVar> i_discVars;
      SimCode.SimEqSystem i_cont;
      Boolean i_partOfMixed;
      list<DAE.Exp> i_beqs;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> i_simJac;
      list<SimCode.SimVar> i_vars;
      list<DAE.Statement> i_statements;
      DAE.ComponentRef i_cref;
      DAE.Exp i_exp;
      Tpl.Text l_rightExp;
      Tpl.Text l_preExp2;
      Tpl.Text l_helpIf;
      Integer ret_16;
      Tpl.Text l_discLoc2;
      Tpl.Text l_preDisc;
      Integer ret_13;
      Tpl.Text l_valuesLenStr;
      Integer ret_11;
      Tpl.Text l_numDiscVarsStr;
      Tpl.Text l_contEqs;
      Integer ret_8;
      Tpl.Text l_bname;
      Tpl.Text l_aname;
      Integer ret_5;
      Tpl.Text l_size;
      Integer ret_3;
      Tpl.Text l_uid;
      Tpl.Text l_expPart;
      Tpl.Text l_preExp;

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(exp = i_exp, cref = i_cref),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_cref, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           SimCode.SES_ARRAY_CALL_ASSIGN(index = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SES_ARRAY_CALL_ASSIGN"));
      then txt;

    case ( txt,
           SimCode.SES_ALGORITHM(statements = i_statements),
           a_context,
           a_simCode )
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_161(txt, i_statements, a_simCode, a_context);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           SimCode.SES_LINEAR(vars = i_vars, simJac = i_simJac, beqs = i_beqs, partOfMixed = i_partOfMixed),
           a_context,
           a_simCode )
      equation
        ret_3 = System.tmpTick();
        l_uid = Tpl.writeStr(Tpl.emptyTxt, intString(ret_3));
        ret_5 = listLength(i_vars);
        l_size = Tpl.writeStr(Tpl.emptyTxt, intString(ret_5));
        l_aname = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("A"));
        l_aname = Tpl.writeText(l_aname, l_uid);
        l_bname = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("b"));
        l_bname = Tpl.writeText(l_bname, l_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var "));
        txt = Tpl.writeText(txt, l_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new double["));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*"));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //declare_matrix("));
        txt = Tpl.writeText(txt, l_aname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ");\n",
                                    "var "
                                }, false));
        txt = Tpl.writeText(txt, l_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new double["));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; //declare_vector("));
        txt = Tpl.writeText(txt, l_bname);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(");\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_162(txt, i_simJac, l_size, l_aname, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_163(txt, i_beqs, l_bname, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = fun_164(txt, i_partOfMixed, l_uid, l_size, l_bname, l_aname);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_165(txt, i_vars, l_bname, a_simCode);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           SimCode.SES_MIXED(cont = i_cont, discVars = i_discVars, values = i_values, discEqs = i_discEqs),
           a_context,
           a_simCode )
      equation
        ret_8 = System.tmpTick();
        l_uid = Tpl.writeStr(Tpl.emptyTxt, intString(ret_8));
        l_contEqs = equation_(Tpl.emptyTxt, i_cont, a_context, a_simCode);
        ret_11 = listLength(i_discVars);
        l_numDiscVarsStr = Tpl.writeStr(Tpl.emptyTxt, intString(ret_11));
        ret_13 = listLength(i_values);
        l_valuesLenStr = Tpl.writeStr(Tpl.emptyTxt, intString(ret_13));
        l_preDisc = Tpl.emptyTxt;
        l_discLoc2 = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_discLoc2, l_preDisc) = lm_166(l_discLoc2, i_discEqs, l_preDisc, a_context, a_simCode);
        l_discLoc2 = Tpl.popIter(l_discLoc2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("// *** mixed_equation_system("));
        txt = Tpl.writeText(txt, l_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ") ***\n",
                                    "{ int found_solution = 0;\n",
                                    "  int cur_value_indx = -1;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var values = new double[]{"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_167(txt, i_values);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "};\n",
                                    "do {\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_168(txt, i_discVars, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("{\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_contEqs);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.writeText(txt, l_preDisc);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, l_discLoc2);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("{\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("// check_discrete_values("));
        txt = Tpl.writeText(txt, l_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_valuesLenStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ");\n",
                                    "if (found_solution == -1) { /*system of equations failed*/\n",
                                    "    found_solution = 0;\n",
                                    "} else {\n",
                                    "    found_solution = 1;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                     "\n",
                                                                     "else "
                                                                 }, false)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_169(txt, i_discVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "}\n",
                                    "if (found_solution == 0) { //!found_solution\n",
                                    "    cur_value_indx++;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if (cur_value_indx >= "));
        txt = Tpl.writeText(txt, l_valuesLenStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/"));
        txt = Tpl.writeText(txt, l_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ") {\n",
                                    "    found_solution = -1; //?? failed ??\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(4));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("System.Diagnostics.Debug.WriteLine(\"Mixed system id=\" + "));
        txt = Tpl.writeText(txt, l_uid);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" + \"failed.\");\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("} else {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var curValOffset = cur_value_indx*"));
        txt = Tpl.writeText(txt, l_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_170(txt, i_discVars, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("} while (found_solution == 0);\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} // *** mixed_equation_system_end("));
        txt = Tpl.writeText(txt, l_numDiscVarsStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") ***"));
      then txt;

    case ( txt,
           SimCode.SES_NONLINEAR(crefs = i_crefs, index = i_index),
           _,
           a_simCode )
      equation
        ret_16 = listLength(i_crefs);
        l_size = Tpl.writeStr(Tpl.emptyTxt, intString(ret_16));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("//start_nonlinear_system("));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ");\n",
                                    "{ var oldX = statesOld; var oldXd = statesDerivativesOld;  var old2X = statesOld2; var old2Xd = statesDerivativesOld2;\n",
                                    "  var oldY = algebraicsOld; var old2Y = algebraicsOld2; var oldTimeDelta = timeOld - timeOld2;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("var nls_x = new double["));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]; var nls_xold = new double["));
        txt = Tpl.writeText(txt, l_size);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("];\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_171(txt, i_crefs, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SolveNonlinearSystem(ResidualFun"));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", nls_x, nls_xold, "));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(");\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_172(txt, i_crefs, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} //end_nonlinear_system();"));
      then txt;

    case ( txt,
           SimCode.SES_WHEN(conditions = i_conditions, right = i_right, left = i_left),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        l_helpIf = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(" || ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_helpIf, l_preExp) = lm_173(l_helpIf, i_conditions, a_simCode, l_preExp, a_context);
        l_helpIf = Tpl.popIter(l_helpIf);
        l_preExp2 = Tpl.emptyTxt;
        (l_rightExp, l_preExp2) = daeExp(Tpl.emptyTxt, i_right, a_context, l_preExp2, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, l_helpIf);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_preExp2);
        txt = Tpl.softNewLine(txt);
        txt = cref(txt, i_left, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_rightExp);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("} else {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = cref(txt, i_left, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = preCref(txt, i_left, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_equation"));
      then txt;
  end matchcontinue;
end equation_;

public function cref
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_a_cr;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_cr, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_cr;

    case ( txt,
           (i_cr as DAE.CREF_IDENT(ident = "xloc")),
           a_simCode )
      equation
        txt = crefStr(txt, i_cr, a_simCode);
      then txt;

    case ( txt,
           DAE.CREF_IDENT(ident = "time"),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("time"));
      then txt;

    case ( txt,
           DAE.CREF_IDENT(ident = "$_lambda"),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_lambda"));
      then txt;

    case ( txt,
           i_cr,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*"));
        txt = crefStr(txt, i_cr, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
        txt = representationCref(txt, i_cr, a_simCode);
      then txt;
  end matchcontinue;
end cref;

protected function smf_176
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Integer i_index;
      DAE.Type i_type__;
      BackendDAE.VarKind i_varKind;

    case ( txt,
           SimCode.SIMVAR(varKind = i_varKind, type_ = i_type__, index = i_index) )
      equation
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end smf_176;

public function representationCref
  input Tpl.Text txt;
  input DAE.ComponentRef a_inCref;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
protected
  SimCode.SimVar ret_0;
algorithm
  ret_0 := SimCode.cref2simvar(a_inCref, a_simCode);
  out_txt := smf_176(txt, ret_0);
end representationCref;

public function representationArrayName
  input Tpl.Text in_txt;
  input BackendDAE.VarKind in_a_varKind;
  input DAE.Type in_a_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_varKind, in_a_type__)
    local
      Tpl.Text txt;
      DAE.Type a_type__;

    case ( txt,
           BackendDAE.VARIABLE(),
           a_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
        txt = representationArrayNameTypePostfix(txt, a_type__);
      then txt;

    case ( txt,
           BackendDAE.STATE(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("X"));
      then txt;

    case ( txt,
           BackendDAE.STATE_DER(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Xd"));
      then txt;

    case ( txt,
           BackendDAE.DUMMY_DER(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
      then txt;

    case ( txt,
           BackendDAE.DUMMY_STATE(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
      then txt;

    case ( txt,
           BackendDAE.DISCRETE(),
           a_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Y"));
        txt = representationArrayNameTypePostfix(txt, a_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*d*/"));
      then txt;

    case ( txt,
           BackendDAE.PARAM(),
           a_type__ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("P"));
        txt = representationArrayNameTypePostfix(txt, a_type__);
      then txt;

    case ( txt,
           BackendDAE.EXTOBJ(fullClassName = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EO"));
      then txt;

    case ( txt,
           BackendDAE.CONST(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONST_VAR_KIND"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BAD_VARKIND"));
      then txt;
  end matchcontinue;
end representationArrayName;

public function representationArrayNameTypePostfix
  input Tpl.Text in_txt;
  input DAE.Type in_a_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_type__)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.T_INTEGER(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("I"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("B"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _) )
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BAD_ARRAY_NAME_POSTFIX"));
      then txt;
  end matchcontinue;
end representationArrayNameTypePostfix;

protected function fun_180
  input Tpl.Text in_txt;
  input SimCode.SimVar in_mArg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_mArg)
    local
      Tpl.Text txt;

    case ( txt,
           SimCode.SIMVAR(type_ = DAE.T_BOOL(varLst = _)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("?1.0:0.0"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_180;

public function daeExpRealConversionPostfix
  input Tpl.Text in_txt;
  input DAE.Exp in_a_exp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_exp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_componentRef;
      SimCode.SimVar ret_0;

    case ( txt,
           DAE.CREF(componentRef = i_componentRef),
           a_simCode )
      equation
        ret_0 = SimCode.cref2simvar(i_componentRef, a_simCode);
        txt = fun_180(txt, ret_0);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end daeExpRealConversionPostfix;

protected function fun_182
  input Tpl.Text in_txt;
  input DAE.Type in_a_type__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_type__)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.T_BOOL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("?1.0:0.0"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_182;

protected function smf_183
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it)
    local
      Tpl.Text txt;
      Integer i_index;
      DAE.Type i_type__;
      BackendDAE.VarKind i_varKind;

    case ( txt,
           SimCode.SIMVAR(varKind = i_varKind, type_ = i_type__, index = i_index) )
      equation
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
        txt = fun_182(txt, i_type__);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end smf_183;

public function crefToReal
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
protected
  SimCode.SimVar ret_0;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*(double)"));
  out_txt := crefStr(out_txt, a_cr, a_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("*/"));
  ret_0 := SimCode.cref2simvar(a_cr, a_simCode);
  out_txt := smf_183(out_txt, ret_0);
end crefToReal;

protected function fun_185
  input Tpl.Text in_txt;
  input DAE.Type in_a_type__;
  input Tpl.Text in_a_realExp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_type__, in_a_realExp)
    local
      Tpl.Text txt;
      Tpl.Text a_realExp;

    case ( txt,
           DAE.T_BOOL(varLst = _),
           a_realExp )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_realExp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") != 0.0"));
      then txt;

    case ( txt,
           DAE.T_INTEGER(varLst = _),
           a_realExp )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(int)("));
        txt = Tpl.writeText(txt, a_realExp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           a_realExp )
      equation
        txt = Tpl.writeText(txt, a_realExp);
      then txt;
  end matchcontinue;
end fun_185;

protected function smf_186
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;
  input Tpl.Text in_a_realExp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_it, in_a_realExp)
    local
      Tpl.Text txt;
      Tpl.Text a_realExp;
      DAE.Type i_type__;

    case ( txt,
           SimCode.SIMVAR(type_ = i_type__),
           a_realExp )
      equation
        txt = fun_185(txt, i_type__, a_realExp);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end smf_186;

public function convertRealExpForCref
  input Tpl.Text txt;
  input Tpl.Text a_realExp;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_realExp;
protected
  SimCode.SimVar ret_0;
algorithm
  ret_0 := SimCode.cref2simvar(a_cr, a_simCode);
  out_txt := smf_186(txt, ret_0, a_realExp);
  out_a_realExp := a_realExp;
end convertRealExpForCref;

public function preCref
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*pre("));
  out_txt := crefStr(out_txt, a_cr, a_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/pre"));
  out_txt := representationCref(out_txt, a_cr, a_simCode);
end preCref;

public function derCref
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
protected
  DAE.ComponentRef ret_0;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*derCall!!("));
  out_txt := crefStr(out_txt, a_cr, a_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/"));
  ret_0 := SimCode.derComponentRef(a_cr);
  out_txt := representationCref(out_txt, ret_0, a_simCode);
end derCref;

public function oldCref
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*old("));
  out_txt := crefStr(out_txt, a_cr, a_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/old"));
  out_txt := representationCref(out_txt, a_cr, a_simCode);
end oldCref;

public function old2Cref
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*old2("));
  out_txt := crefStr(out_txt, a_cr, a_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/old2"));
  out_txt := representationCref(out_txt, a_cr, a_simCode);
end old2Cref;

public function startCref
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("/*start("));
  out_txt := crefStr(out_txt, a_cr, a_simCode);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")*/start"));
  out_txt := representationCref(out_txt, a_cr, a_simCode);
end startCref;

protected function fun_193
  input Tpl.Text in_txt;
  input SimCode.Context in_a_context;
  input DAE.ComponentRef in_a_cr;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_context, in_a_cr, in_a_simCode)
    local
      Tpl.Text txt;
      DAE.ComponentRef a_cr;
      SimCode.SimCode a_simCode;

    case ( txt,
           SimCode.FUNCTION_CONTEXT(),
           a_cr,
           a_simCode )
      equation
        txt = crefStr(txt, a_cr, a_simCode);
      then txt;

    case ( txt,
           _,
           a_cr,
           a_simCode )
      equation
        txt = cref(txt, a_cr, a_simCode);
      then txt;
  end matchcontinue;
end fun_193;

public function contextCref
  input Tpl.Text txt;
  input DAE.ComponentRef a_cr;
  input SimCode.Context a_context;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_193(txt, a_context, a_cr, a_simCode);
end contextCref;

public function crefStr
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_a_cr;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_cr, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_componentRef;
      list<DAE.Subscript> i_subscriptLst;
      DAE.Ident i_ident;

    case ( txt,
           DAE.CREF_IDENT(ident = i_ident, subscriptLst = i_subscriptLst),
           a_simCode )
      equation
        txt = csharpIdent(txt, i_ident);
        txt = subscriptsStr(txt, i_subscriptLst, a_simCode);
      then txt;

    case ( txt,
           DAE.CREF_QUAL(ident = "$DER", componentRef = i_componentRef),
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("der("));
        txt = crefStr(txt, i_componentRef, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.CREF_QUAL(ident = i_ident, subscriptLst = i_subscriptLst, componentRef = i_componentRef),
           a_simCode )
      equation
        txt = Tpl.writeStr(txt, i_ident);
        txt = subscriptsStr(txt, i_subscriptLst, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = crefStr(txt, i_componentRef, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CREF_NOT_IDENT_OR_QUAL"));
      then txt;
  end matchcontinue;
end crefStr;

public function csharpIdent
  input Tpl.Text in_txt;
  input String in_a_ident;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_ident)
    local
      Tpl.Text txt;
      String i_ident;

    case ( txt,
           "string" )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("@string"));
      then txt;

    case ( txt,
           "int" )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("@int"));
      then txt;

    case ( txt,
           i_ident )
      equation
        txt = Tpl.writeStr(txt, i_ident);
      then txt;
  end matchcontinue;
end csharpIdent;

protected function fun_197
  input Tpl.Text in_txt;
  input DAE.Subscript in_a_s;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_s, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.Exp i_exp;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.INDEX(exp = i_exp),
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (txt, l_preExp) = daeExp(txt, i_exp, SimCode.contextFunction, l_preExp, a_simCode);
      then txt;

    case ( txt,
           DAE.SLICE(exp = i_exp),
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (txt, l_preExp) = daeExp(txt, i_exp, SimCode.contextFunction, l_preExp, a_simCode);
      then txt;

    case ( txt,
           DAE.WHOLEDIM(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("WHOLEDIM"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_SUBSCRIPT"));
      then txt;
  end matchcontinue;
end fun_197;

protected function lm_198
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.Subscript> rest;
      SimCode.SimCode a_simCode;
      DAE.Subscript i_s;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_s :: rest,
           a_simCode )
      equation
        txt = fun_197(txt, i_s, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_198(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_198(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_198;

public function subscriptsStr
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_a_subscripts;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_subscripts, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      list<DAE.Subscript> i_subscripts;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_subscripts,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_198(txt, i_subscripts, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then txt;
  end matchcontinue;
end subscriptsStr;

public function dotPath
  input Tpl.Text in_txt;
  input Absyn.Path in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;
      String i_name_1;
      Absyn.Path i_path;
      Absyn.Ident i_name;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      equation
        txt = Tpl.writeStr(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = dotPath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name_1) )
      equation
        txt = Tpl.writeStr(txt, i_name_1);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = dotPath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dotPath;

public function underscorePath
  input Tpl.Text in_txt;
  input Absyn.Path in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;
      String i_name_1;
      Absyn.Path i_path;
      Absyn.Ident i_name;
      String ret_1;
      String ret_0;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      equation
        ret_0 = System.stringReplace(i_name, "_", "__");
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_"));
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name_1) )
      equation
        ret_1 = System.stringReplace(i_name_1, "_", "__");
        txt = Tpl.writeStr(txt, ret_1);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end underscorePath;

protected function lm_202
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_it;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_it, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_202(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_202(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_202;

protected function lm_203
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_stmt;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_stmt, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_203(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_203(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_203;

protected function lm_204
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_stmt;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_stmt, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_204(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_204(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_204;

public function algStatement
  input Tpl.Text in_txt;
  input DAE.Statement in_a_stmt;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_stmt, in_a_context, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      SimCode.SimCode a_simCode;
      DAE.Statement i_stmt;
      Absyn.Info i_info;
      DAE.Exp i_msg;
      DAE.Exp i_cond;
      DAE.Ident i_iter;
      DAE.Exp i_rng;
      Boolean i_iterIsArray;
      DAE.Type i_type__;
      DAE.Else i_else__;
      list<DAE.Statement> i_statementLst;
      DAE.ComponentRef i_componentRef;
      DAE.Ident i_componentRef_ident;
      list<DAE.Subscript> i_subs;
      DAE.Exp i_exp1;
      DAE.Exp i_exp;
      DAE.Exp i_e;
      Tpl.Text l_var;
      Tpl.Text l_stmtStr;
      Tpl.Text l_identTypeShort;
      Tpl.Text l_identType;
      Tpl.Text l_condExp;
      Tpl.Text l_spec;
      Tpl.Text l_expPart2;
      Tpl.Text l_expPart1;
      Tpl.Text l_expPart;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.STMT_ASSIGN(exp1 = DAE.CREF(componentRef = DAE.WILD()), exp = i_e),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_e, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, l_expPart);
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN(exp1 = (i_exp1 as DAE.CREF(componentRef = _)), exp = i_exp),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        (txt, l_preExp) = scalarLhsCref(txt, i_exp1, a_context, l_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN(exp1 = i_exp1, exp = i_exp),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart1, l_preExp) = daeExp(Tpl.emptyTxt, i_exp1, a_context, l_preExp, a_simCode);
        (l_expPart2, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, l_expPart1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_expPart2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN_ARR(componentRef = DAE.CREF_IDENT(subscriptLst = (i_subs as _ :: _), ident = i_componentRef_ident), exp = i_exp),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        (l_spec, l_preExp) = daeExpCrefRhsIndexSpec(Tpl.emptyTxt, i_subs, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeStr(txt, i_componentRef_ident);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".AssignSpec("));
        txt = Tpl.writeText(txt, l_spec);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".A);"));
      then txt;

    case ( txt,
           DAE.STMT_ASSIGN_ARR(exp = i_exp, componentRef = i_componentRef),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_expPart, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ArrayCopy("));
        txt = Tpl.writeText(txt, l_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".A, "));
        txt = contextCref(txt, i_componentRef, a_context, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".A);"));
      then txt;

    case ( txt,
           DAE.STMT_IF(exp = i_exp, statementLst = i_statementLst, else_ = i_else__),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_condExp, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, l_condExp);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_202(txt, i_statementLst, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = elseExpr(txt, i_else__, a_context, a_simCode);
      then txt;

    case ( txt,
           DAE.STMT_FOR(range = (i_rng as DAE.RANGE(ty = _)), type_ = i_type__, iterIsArray = i_iterIsArray, statementLst = i_statementLst, iter = i_iter),
           a_context,
           a_simCode )
      equation
        l_identType = expType(Tpl.emptyTxt, i_type__, i_iterIsArray);
        l_identTypeShort = expTypeShort(Tpl.emptyTxt, i_type__);
        l_stmtStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_stmtStr = lm_203(l_stmtStr, i_statementLst, a_simCode, a_context);
        l_stmtStr = Tpl.popIter(l_stmtStr);
        (txt, l_stmtStr) = algStmtForRange_impl(txt, i_rng, i_iter, Tpl.textString(l_identType), Tpl.textString(l_identTypeShort), l_stmtStr, a_context, a_simCode);
      then txt;

    case ( txt,
           DAE.STMT_FOR(type_ = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("algStmtForGeneric_NOT_IMPLEMENTED"));
      then txt;

    case ( txt,
           DAE.STMT_WHILE(exp = i_exp, statementLst = i_statementLst),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_var, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("for(;;) {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if (!"));
        txt = Tpl.writeText(txt, l_var);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") break;\n"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_204(txt, i_statementLst, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           DAE.STMT_TUPLE_ASSIGN(type_ = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_TUPLE_ASSIGN_NI"));
      then txt;

    case ( txt,
           DAE.STMT_ASSERT(source = DAE.SOURCE(info = i_info), cond = i_cond, msg = i_msg),
           a_context,
           a_simCode )
      equation
        txt = assertCommon(txt, i_cond, i_msg, i_info, a_context, a_simCode);
      then txt;

    case ( txt,
           DAE.STMT_TERMINATE(msg = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_TERMINATE_NI"));
      then txt;

    case ( txt,
           (i_stmt as DAE.STMT_WHEN(exp = _)),
           a_context,
           a_simCode )
      equation
        txt = algStmtWhen(txt, i_stmt, a_context, a_simCode);
      then txt;

    case ( txt,
           DAE.STMT_BREAK(source = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("break; //break stmt"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then txt;

    case ( txt,
           DAE.STMT_FAILURE(body = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_FAILURE_NI"));
      then txt;

    case ( txt,
           DAE.STMT_TRY(tryBody = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_TRY_NI"));
      then txt;

    case ( txt,
           DAE.STMT_CATCH(catchBody = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_CATCH_NI"));
      then txt;

    case ( txt,
           DAE.STMT_THROW(source = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_THROW_NI"));
      then txt;

    case ( txt,
           DAE.STMT_RETURN(source = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_RETURN_NI"));
      then txt;

    case ( txt,
           DAE.STMT_NORETCALL(exp = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_NORETCALL_NI"));
      then txt;

    case ( txt,
           DAE.STMT_REINIT(var = _),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STMT_REINIT_NI"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_IMPLEMENTED_ALG_STATEMENT"));
      then txt;
  end matchcontinue;
end algStatement;

protected function fun_206
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_a_step;
  input Tpl.Text in_a_body;
  input Tpl.Text in_a_startValue;
  input Tpl.Text in_a_iterName;
  input Tpl.Text in_a_stopValue;
  input Tpl.Text in_a_stopVar;
  input String in_a_type;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_stopVar;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_stopVar, out_a_preExp) :=
  matchcontinue(in_txt, in_a_step, in_a_body, in_a_startValue, in_a_iterName, in_a_stopValue, in_a_stopVar, in_a_type, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      Tpl.Text a_body;
      Tpl.Text a_startValue;
      Tpl.Text a_iterName;
      Tpl.Text a_stopValue;
      Tpl.Text a_stopVar;
      String a_type;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_eo;
      Tpl.Text l_stepValue;
      Tpl.Text l_stepVar;

    case ( txt,
           SOME(i_eo),
           a_body,
           a_startValue,
           a_iterName,
           a_stopValue,
           a_stopVar,
           a_type,
           a_simCode,
           a_preExp,
           a_context )
      equation
        l_stepVar = Tpl.emptyTxt;
        (l_stepValue, a_preExp) = daeExp(Tpl.emptyTxt, i_eo, a_context, a_preExp, a_simCode);
        txt = Tpl.writeText(txt, a_preExp);
        txt = Tpl.softNewLine(txt);
        (txt, l_stepVar) = tempDecl(txt, a_type, l_stepVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, l_stepValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; "));
        (txt, a_stopVar) = tempDecl(txt, a_type, a_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_stopValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "for("
                                }, false));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_startValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";("));
        txt = Tpl.writeText(txt, l_stepVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > 0? "));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
        txt = Tpl.writeText(txt, a_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" : "));
        txt = Tpl.writeText(txt, a_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("); "));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" += "));
        txt = Tpl.writeText(txt, l_stepVar);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, a_body);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then (txt, a_stopVar, a_preExp);

    case ( txt,
           _,
           a_body,
           a_startValue,
           a_iterName,
           a_stopValue,
           a_stopVar,
           a_type,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeText(txt, a_preExp);
        txt = Tpl.softNewLine(txt);
        (txt, a_stopVar) = tempDecl(txt, a_type, a_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_stopValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "for("
                                }, false));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_startValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; "));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
        txt = Tpl.writeText(txt, a_stopVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("; "));
        txt = Tpl.writeText(txt, a_iterName);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" += 1) {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, a_body);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then (txt, a_stopVar, a_preExp);
  end matchcontinue;
end fun_206;

protected function fun_207
  input Tpl.Text in_txt;
  input DAE.Exp in_a_range;
  input Absyn.Ident in_a_iterator;
  input String in_a_type;
  input Tpl.Text in_a_body;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_range, in_a_iterator, in_a_type, in_a_body, in_a_context, in_a_simCode)
    local
      Tpl.Text txt;
      Absyn.Ident a_iterator;
      String a_type;
      Tpl.Text a_body;
      SimCode.Context a_context;
      SimCode.SimCode a_simCode;
      Option<DAE.Exp> i_step;
      DAE.Exp i_stop;
      DAE.Exp i_start;
      Tpl.Text l_stopValue;
      Tpl.Text l_startValue;
      Tpl.Text l_preExp;
      Tpl.Text l_stopVar;
      Tpl.Text l_iterName;

    case ( txt,
           DAE.RANGE(start = i_start, stop = i_stop, step = i_step),
           a_iterator,
           a_type,
           a_body,
           a_context,
           a_simCode )
      equation
        l_iterName = Tpl.writeStr(Tpl.emptyTxt, a_iterator);
        l_stopVar = Tpl.emptyTxt;
        l_preExp = Tpl.emptyTxt;
        (l_startValue, l_preExp) = daeExp(Tpl.emptyTxt, i_start, a_context, l_preExp, a_simCode);
        (l_stopValue, l_preExp) = daeExp(Tpl.emptyTxt, i_stop, a_context, l_preExp, a_simCode);
        (txt, l_stopVar, l_preExp) = fun_206(txt, i_step, a_body, l_startValue, l_iterName, l_stopValue, l_stopVar, a_type, a_simCode, l_preExp, a_context);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_207;

public function algStmtForRange_impl
  input Tpl.Text txt;
  input DAE.Exp a_range;
  input Absyn.Ident a_iterator;
  input String a_type;
  input String a_shortType;
  input Tpl.Text a_body;
  input SimCode.Context a_context;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_body;
algorithm
  out_txt := fun_207(txt, a_range, a_iterator, a_type, a_body, a_context, a_simCode);
  out_a_body := a_body;
end algStmtForRange_impl;

protected function lm_209
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_it;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_it, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_209(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_209(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_209;

protected function lm_210
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_it;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_it :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_it, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_210(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_210(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_210;

public function elseExpr
  input Tpl.Text in_txt;
  input DAE.Else in_a_it;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it, in_a_context, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      SimCode.SimCode a_simCode;
      DAE.Else i_else__;
      list<DAE.Statement> i_statementLst;
      DAE.Exp i_exp;
      Tpl.Text l_condExp;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.NOELSE(),
           _,
           _ )
      then txt;

    case ( txt,
           DAE.ELSEIF(exp = i_exp, statementLst = i_statementLst, else_ = i_else__),
           a_context,
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_condExp, l_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, l_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("else {\n"));
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.writeText(txt, l_condExp);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_209(txt, i_statementLst, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = elseExpr(txt, i_else__, a_context, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           DAE.ELSE(statementLst = i_statementLst),
           a_context,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("else {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_210(txt, i_statementLst, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end elseExpr;

protected function lm_212
  input Tpl.Text in_txt;
  input list<Integer> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Integer> rest;
      Integer i_idx;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_idx :: rest )
      equation
        txt = edgeHelpVar(txt, intString(i_idx));
        txt = Tpl.nextIter(txt);
        txt = lm_212(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_212(txt, rest);
      then txt;
  end matchcontinue;
end lm_212;

protected function lm_213
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.Statement i_stmt;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode,
           a_context )
      equation
        txt = algStatement(txt, i_stmt, a_context, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_213(txt, rest, a_simCode, a_context);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode,
           a_context )
      equation
        txt = lm_213(txt, rest, a_simCode, a_context);
      then txt;
  end matchcontinue;
end lm_213;

protected function fun_214
  input Tpl.Text in_txt;
  input DAE.Statement in_a_when;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_when, in_a_context, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      SimCode.SimCode a_simCode;
      Option<DAE.Statement> i_elseWhen;
      list<DAE.Statement> i_statementLst;
      list<Integer> i_helpVarIndices;
      DAE.Statement i_when;

    case ( txt,
           (i_when as DAE.STMT_WHEN(helpVarIndices = i_helpVarIndices, statementLst = i_statementLst, elseWhen = i_elseWhen)),
           a_context,
           a_simCode )
      equation
        txt = algStatementWhenPre(txt, i_when, a_simCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("if ("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(" || ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_212(txt, i_helpVarIndices);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_213(txt, i_statementLst, a_simCode, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = algStatementWhenElse(txt, i_elseWhen, a_simCode);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_214;

protected function fun_215
  input Tpl.Text in_txt;
  input SimCode.Context in_a_context;
  input DAE.Statement in_a_when;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_context, in_a_when, in_a_simCode)
    local
      Tpl.Text txt;
      DAE.Statement a_when;
      SimCode.SimCode a_simCode;
      SimCode.Context i_context;

    case ( txt,
           (i_context as SimCode.SIMULATION(genDiscrete = true)),
           a_when,
           a_simCode )
      equation
        txt = fun_214(txt, a_when, i_context, a_simCode);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_215;

public function algStmtWhen
  input Tpl.Text txt;
  input DAE.Statement a_when;
  input SimCode.Context a_context;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_215(txt, a_context, a_when, a_simCode);
end algStmtWhen;

protected function fun_217
  input Tpl.Text in_txt;
  input Option<DAE.Statement> in_a_elseWhen;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_elseWhen, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.Statement i_ew;

    case ( txt,
           SOME(i_ew),
           a_simCode )
      equation
        txt = algStatementWhenPre(txt, i_ew, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_217;

protected function fun_218
  input Tpl.Text in_txt;
  input Option<DAE.Statement> in_a_when_elseWhen;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_when_elseWhen, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.Statement i_ew;

    case ( txt,
           SOME(i_ew),
           a_simCode )
      equation
        txt = algStatementWhenPre(txt, i_ew, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_218;

protected function fun_219
  input Tpl.Text in_txt;
  input list<Integer> in_a_helpVarIndices;
  input Option<DAE.Statement> in_a_when_elseWhen;
  input SimCode.SimCode in_a_simCode;
  input DAE.Exp in_a_when_exp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_helpVarIndices, in_a_when_elseWhen, in_a_simCode, in_a_when_exp)
    local
      Tpl.Text txt;
      Option<DAE.Statement> a_when_elseWhen;
      SimCode.SimCode a_simCode;
      DAE.Exp a_when_exp;
      Integer i_i;
      Tpl.Text l_res;
      Tpl.Text l_preExp;

    case ( txt,
           {i_i},
           a_when_elseWhen,
           a_simCode,
           a_when_exp )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_res, l_preExp) = daeExp(Tpl.emptyTxt, a_when_exp, SimCode.contextSimulationDiscrete, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("H["));
        txt = Tpl.writeStr(txt, intString(i_i));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, l_res);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" ? 1.0 : 0.0;\n"));
        txt = fun_218(txt, a_when_elseWhen, a_simCode);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_219;

public function algStatementWhenPre
  input Tpl.Text in_txt;
  input DAE.Statement in_a_stmt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_stmt, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Option<DAE.Statement> i_when_elseWhen;
      DAE.Exp i_when_exp;
      Option<DAE.Statement> i_elseWhen;
      list<Integer> i_helpVarIndices;
      list<DAE.Exp> i_el;
      Tpl.Text l_assignments;
      Tpl.Text l_preExp;

    case ( txt,
           DAE.STMT_WHEN(exp = DAE.ARRAY(array = i_el), helpVarIndices = i_helpVarIndices, elseWhen = i_elseWhen),
           a_simCode )
      equation
        l_preExp = Tpl.emptyTxt;
        (l_assignments, l_preExp) = algStatementWhenPreAssigns(Tpl.emptyTxt, i_el, i_helpVarIndices, l_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_preExp);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeText(txt, l_assignments);
        txt = Tpl.softNewLine(txt);
        txt = fun_217(txt, i_elseWhen, a_simCode);
      then txt;

    case ( txt,
           DAE.STMT_WHEN(helpVarIndices = i_helpVarIndices, exp = i_when_exp, elseWhen = i_when_elseWhen),
           a_simCode )
      equation
        txt = fun_219(txt, i_helpVarIndices, i_when_elseWhen, a_simCode, i_when_exp);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end algStatementWhenPre;

protected function lm_221
  input Tpl.Text in_txt;
  input list<Integer> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Integer> rest;
      Integer i_idx;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_idx :: rest )
      equation
        txt = edgeHelpVar(txt, intString(i_idx));
        txt = Tpl.nextIter(txt);
        txt = lm_221(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_221(txt, rest);
      then txt;
  end matchcontinue;
end lm_221;

protected function lm_222
  input Tpl.Text in_txt;
  input list<DAE.Statement> in_items;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.Statement> rest;
      SimCode.SimCode a_simCode;
      DAE.Statement i_stmt;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_simCode )
      equation
        txt = algStatement(txt, i_stmt, SimCode.contextSimulationDiscrete, a_simCode);
        txt = Tpl.nextIter(txt);
        txt = lm_222(txt, rest, a_simCode);
      then txt;

    case ( txt,
           _ :: rest,
           a_simCode )
      equation
        txt = lm_222(txt, rest, a_simCode);
      then txt;
  end matchcontinue;
end lm_222;

public function algStatementWhenElse
  input Tpl.Text in_txt;
  input Option<DAE.Statement> in_a_stmt;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_stmt, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Option<DAE.Statement> i_when_elseWhen;
      list<DAE.Statement> i_when_statementLst;
      list<Integer> i_when_helpVarIndices;
      Tpl.Text l_elseCondStr;

    case ( txt,
           SOME(DAE.STMT_WHEN(helpVarIndices = i_when_helpVarIndices, statementLst = i_when_statementLst, elseWhen = i_when_elseWhen)),
           a_simCode )
      equation
        l_elseCondStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(" || ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_elseCondStr = lm_221(l_elseCondStr, i_when_helpVarIndices);
        l_elseCondStr = Tpl.popIter(l_elseCondStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("else if ("));
        txt = Tpl.writeText(txt, l_elseCondStr);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(") {\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_222(txt, i_when_statementLst, a_simCode);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("}\n"));
        txt = algStatementWhenElse(txt, i_when_elseWhen, a_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end algStatementWhenElse;

protected function fun_224
  input Tpl.Text in_txt;
  input list<Integer> in_a_ints;
  input list<DAE.Exp> in_a_restExps;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input DAE.Exp in_a_firstExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_ints, in_a_restExps, in_a_simCode, in_a_preExp, in_a_firstExp)
    local
      Tpl.Text txt;
      list<DAE.Exp> a_restExps;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      DAE.Exp a_firstExp;
      list<Integer> i_restInts;
      Integer i_firstInt;

    case ( txt,
           i_firstInt :: i_restInts,
           a_restExps,
           a_simCode,
           a_preExp,
           a_firstExp )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("H["));
        txt = Tpl.writeStr(txt, intString(i_firstInt));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        (txt, a_preExp) = daeExp(txt, a_firstExp, SimCode.contextSimulationDiscrete, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        (txt, a_preExp) = algStatementWhenPreAssigns(txt, a_restExps, i_restInts, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end fun_224;

public function algStatementWhenPreAssigns
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_a_exps;
  input list<Integer> in_a_ints;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_exps, in_a_ints, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      list<Integer> a_ints;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      list<DAE.Exp> i_restExps;
      DAE.Exp i_firstExp;

    case ( txt,
           i_firstExp :: i_restExps,
           a_ints,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = fun_224(txt, a_ints, i_restExps, a_simCode, a_preExp, i_firstExp);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end algStatementWhenPreAssigns;

protected function fun_226
  input Tpl.Text in_txt;
  input Boolean in_mArg;
  input DAE.ComponentRef in_a_ecr_componentRef;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input DAE.Exp in_a_ecr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_mArg, in_a_ecr_componentRef, in_a_simCode, in_a_preExp, in_a_context, in_a_ecr)
    local
      Tpl.Text txt;
      DAE.ComponentRef a_ecr_componentRef;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp a_ecr;

    case ( txt,
           false,
           _,
           a_simCode,
           a_preExp,
           a_context,
           a_ecr )
      equation
        (txt, a_preExp) = daeExpCrefRhs(txt, a_ecr, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           _,
           a_ecr_componentRef,
           a_simCode,
           a_preExp,
           a_context,
           _ )
      equation
        txt = contextCref(txt, a_ecr_componentRef, a_context, a_simCode);
      then (txt, a_preExp);
  end matchcontinue;
end fun_226;

public function scalarLhsCref
  input Tpl.Text in_txt;
  input DAE.Exp in_a_ecr;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_ecr, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.Exp i_ecr;
      DAE.ComponentRef i_ecr_componentRef;
      Boolean ret_0;

    case ( txt,
           (i_ecr as DAE.CREF(componentRef = (i_ecr_componentRef as DAE.CREF_IDENT(subscriptLst = _)))),
           a_context,
           a_preExp,
           a_simCode )
      equation
        ret_0 = SimCode.crefNoSub(i_ecr_componentRef);
        (txt, a_preExp) = fun_226(txt, ret_0, i_ecr_componentRef, a_simCode, a_preExp, a_context, i_ecr);
      then (txt, a_preExp);

    case ( txt,
           DAE.CREF(componentRef = (i_ecr_componentRef as DAE.CREF_QUAL(ident = _))),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = contextCref(txt, i_ecr_componentRef, a_context, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ONLY_IDENT_OR_QUAL_CREF_SUPPORTED_SLHS"));
      then (txt, a_preExp);
  end matchcontinue;
end scalarLhsCref;

public function rhsCref
  input Tpl.Text in_txt;
  input DAE.ComponentRef in_a_it;
  input DAE.Type in_a_ty;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it, in_a_ty, in_a_simCode)
    local
      Tpl.Text txt;
      DAE.Type a_ty;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_componentRef;
      DAE.Ident i_ident;

    case ( txt,
           DAE.CREF_IDENT(ident = i_ident),
           a_ty,
           _ )
      equation
        txt = rhsCrefType(txt, a_ty);
        txt = replaceDollarWorkaround(txt, i_ident);
      then txt;

    case ( txt,
           DAE.CREF_QUAL(ident = i_ident, componentRef = i_componentRef),
           a_ty,
           a_simCode )
      equation
        txt = rhsCrefType(txt, a_ty);
        txt = Tpl.writeStr(txt, i_ident);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("."));
        txt = rhsCref(txt, i_componentRef, a_ty, a_simCode);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("rhsCref:ERROR"));
      then txt;
  end matchcontinue;
end rhsCref;

public function rhsCrefType
  input Tpl.Text in_txt;
  input DAE.Type in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.T_INTEGER(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(int)"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end rhsCrefType;

public function replaceDollarWorkaround
  input Tpl.Text txt;
  input String a_ident;

  output Tpl.Text out_txt;
protected
  String ret_1;
  String ret_0;
algorithm
  ret_0 := System.stringReplace(a_ident, "$DER", "Der_");
  ret_1 := System.stringReplace(ret_0, "$", "");
  out_txt := Tpl.writeStr(txt, ret_1);
end replaceDollarWorkaround;

protected function fun_231
  input Tpl.Text in_txt;
  input Boolean in_a_bool;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_bool)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end matchcontinue;
end fun_231;

protected function fun_232
  input Tpl.Text in_txt;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input DAE.Exp in_a_inExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_context, in_a_simCode, in_a_preExp, in_a_inExp)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      DAE.Exp a_inExp;
      SimCode.Context i_context;

    case ( txt,
           (i_context as SimCode.FUNCTION_CONTEXT()),
           a_simCode,
           a_preExp,
           a_inExp )
      equation
        (txt, a_preExp) = daeExpCrefRhs(txt, a_inExp, i_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpRecordCrefRhs_NOT_YET"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_232;

public function daeExp
  input Tpl.Text in_txt;
  input DAE.Exp in_a_inExp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_inExp, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.Exp i_expElse;
      DAE.Exp i_expThen;
      DAE.Exp i_expCond;
      DAE.Exp i_exp;
      DAE.Exp i_exp2;
      DAE.Exp i_exp1;
      DAE.Operator i_operator;
      DAE.Exp i_inExp;
      DAE.ComponentRef i_componentRef;
      Absyn.Path i_name;
      Integer i_index;
      Boolean i_bool;
      String i_string;
      Real i_real;
      Integer i_integer;
      String ret_0;

    case ( txt,
           DAE.ICONST(integer = i_integer),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeStr(txt, intString(i_integer));
      then (txt, a_preExp);

    case ( txt,
           DAE.RCONST(real = i_real),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeStr(txt, realString(i_real));
      then (txt, a_preExp);

    case ( txt,
           DAE.SCONST(string = i_string),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\""));
        ret_0 = Util.escapeModelicaStringToCString(i_string);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\""));
      then (txt, a_preExp);

    case ( txt,
           DAE.BCONST(bool = i_bool),
           _,
           a_preExp,
           _ )
      equation
        txt = fun_231(txt, i_bool);
      then (txt, a_preExp);

    case ( txt,
           DAE.ENUM_LITERAL(index = i_index, name = i_name),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*ENUM:"));
        txt = dotPath(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CREF(ty = DAE.T_FUNCTION_REFERENCE_FUNC(builtin = _), componentRef = i_componentRef),
           _,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FUNC_REF_NOT_SUPPORTED(cr="));
        txt = crefStr(txt, i_componentRef, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.CREF(ty = DAE.T_COMPLEX(complexClassType = ClassInf.RECORD(path = _)))),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = fun_232(txt, a_context, a_simCode, a_preExp, i_inExp);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.CREF(componentRef = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpCrefRhs(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.LBINARY(operator = i_operator, exp1 = i_exp1, exp2 = i_exp2),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpBinary(txt, i_operator, i_exp1, i_exp2, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.BINARY(operator = i_operator, exp1 = i_exp1, exp2 = i_exp2),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpBinary(txt, i_operator, i_exp1, i_exp2, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.LUNARY(operator = i_operator, exp = i_exp),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpUnary(txt, i_operator, i_exp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.UNARY(operator = i_operator, exp = i_exp),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpUnary(txt, i_operator, i_exp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.RELATION(exp1 = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpRelation(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.IFEXP(expCond = i_expCond, expThen = i_expThen, expElse = i_expElse),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpIf(txt, i_expCond, i_expThen, i_expElse, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.CALL(path = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpCall(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.ARRAY(ty = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpArray(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.MATRIX(ty = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpMatrix(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.RANGE(ty = _),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RANGE_NOT_IMPLEMENTED"));
      then (txt, a_preExp);

    case ( txt,
           DAE.TUPLE(PR = _),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TUPLE_NOT_IMPLEMENTED"));
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.CAST(ty = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpCast(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.ASUB(exp = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpAsub(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           (i_inExp as DAE.SIZE(exp = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpSize(txt, i_inExp, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.CODE(code = _),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CODE_NOT_IMPLEMENTED"));
      then (txt, a_preExp);

    case ( txt,
           DAE.REDUCTION(reductionInfo = _),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REDUCTION_NOT_IMPLEMENTED"));
      then (txt, a_preExp);

    case ( txt,
           DAE.LIST(valList = _),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LIST_NOT_IMPLEMENTED"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CONS(car = _),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONS_NOT_IMPLEMENTED"));
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_EXP"));
      then (txt, a_preExp);
  end matchcontinue;
end daeExp;

protected function fun_234
  input Tpl.Text in_txt;
  input DAE.Exp in_a_dim;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_expPart;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_dim, in_a_simCode, in_a_preExp, in_a_context, in_a_expPart)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      Tpl.Text a_expPart;
      DAE.Exp i_dim;
      Integer i_integer;

    case ( txt,
           DAE.ICONST(integer = i_integer),
           _,
           a_preExp,
           _,
           a_expPart )
      equation
        txt = Tpl.writeText(txt, a_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".size"));
        txt = Tpl.writeStr(txt, intString(i_integer));
      then (txt, a_preExp);

    case ( txt,
           i_dim,
           a_simCode,
           a_preExp,
           a_context,
           a_expPart )
      equation
        txt = Tpl.writeText(txt, a_expPart);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".size("));
        (txt, a_preExp) = daeExp(txt, i_dim, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_234;

public function daeExpSize
  input Tpl.Text in_txt;
  input DAE.Exp in_a_esize;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_esize, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.Exp i_dim;
      DAE.Exp i_exp;
      Tpl.Text l_expPart;

    case ( txt,
           DAE.SIZE(exp = (i_exp as DAE.CREF(componentRef = _)), sz = SOME(i_dim)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_expPart, a_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, a_preExp, a_simCode);
        (txt, a_preExp) = fun_234(txt, i_dim, a_simCode, a_preExp, a_context, l_expPart);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("size_X_NOT_IMPLEMENTED"));
      then (txt, a_preExp);
  end matchcontinue;
end daeExpSize;

protected function lm_236
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Subscript> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_exp;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           DAE.INDEX(exp = i_exp) :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = daeExp(txt, i_exp, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_236(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_236(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_236;

protected function fun_237
  input Tpl.Text in_txt;
  input Boolean in_mArg;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;
  input DAE.ComponentRef in_a_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_mArg, in_a_preExp, in_a_simCode, in_a_context, in_a_cr)
    local
      Tpl.Text txt;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.ComponentRef a_cr;
      list<DAE.Subscript> ret_5;
      DAE.ComponentRef ret_4;
      list<DAE.Subscript> ret_3;
      Tpl.Text l_spec;
      DAE.ComponentRef ret_1;
      Tpl.Text l_arrName;

    case ( txt,
           false,
           a_preExp,
           a_simCode,
           a_context,
           a_cr )
      equation
        ret_1 = ComponentReference.crefStripLastSubs(a_cr);
        l_arrName = contextCref(Tpl.emptyTxt, ret_1, a_context, a_simCode);
        ret_3 = ComponentReference.crefSubs(a_cr);
        (l_spec, a_preExp) = daeExpCrefRhsIndexSpec(Tpl.emptyTxt, ret_3, a_context, a_preExp, a_simCode);
        txt = Tpl.writeText(txt, l_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(".Array1Spec("));
        txt = Tpl.writeText(txt, l_spec);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           _,
           a_preExp,
           a_simCode,
           a_context,
           a_cr )
      equation
        ret_4 = ComponentReference.crefStripLastSubs(a_cr);
        l_arrName = contextCref(Tpl.emptyTxt, ret_4, a_context, a_simCode);
        txt = Tpl.writeText(txt, l_arrName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        ret_5 = ComponentReference.crefSubs(a_cr);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, a_preExp) = lm_236(txt, ret_5, a_simCode, a_preExp, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_237;

protected function fun_238
  input Tpl.Text in_txt;
  input Boolean in_mArg;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;
  input DAE.ComponentRef in_a_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_mArg, in_a_preExp, in_a_simCode, in_a_context, in_a_cr)
    local
      Tpl.Text txt;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.ComponentRef a_cr;
      Boolean ret_0;

    case ( txt,
           false,
           a_preExp,
           a_simCode,
           a_context,
           a_cr )
      equation
        ret_0 = SimCode.crefSubIsScalar(a_cr);
        (txt, a_preExp) = fun_237(txt, ret_0, a_preExp, a_simCode, a_context, a_cr);
      then (txt, a_preExp);

    case ( txt,
           _,
           a_preExp,
           a_simCode,
           a_context,
           a_cr )
      equation
        txt = contextCref(txt, a_cr, a_context, a_simCode);
      then (txt, a_preExp);
  end matchcontinue;
end fun_238;

protected function fun_239
  input Tpl.Text in_txt;
  input Tpl.Text in_a_box;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;
  input SimCode.Context in_a_context;
  input DAE.ComponentRef in_a_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_box, in_a_preExp, in_a_simCode, in_a_context, in_a_cr)
    local
      Tpl.Text txt;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      SimCode.Context a_context;
      DAE.ComponentRef a_cr;
      Tpl.Text i_box;
      Boolean ret_0;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}),
           a_preExp,
           a_simCode,
           a_context,
           a_cr )
      equation
        ret_0 = SimCode.crefIsScalar(a_cr, a_context);
        (txt, a_preExp) = fun_238(txt, ret_0, a_preExp, a_simCode, a_context, a_cr);
      then (txt, a_preExp);

    case ( txt,
           i_box,
           a_preExp,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeText(txt, i_box);
      then (txt, a_preExp);
  end matchcontinue;
end fun_239;

public function daeExpCrefRhs
  input Tpl.Text in_txt;
  input DAE.Exp in_a_ecr;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_ecr, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_cr;
      DAE.Exp i_ecr;
      Tpl.Text l_box;

    case ( txt,
           (i_ecr as DAE.CREF(componentRef = i_cr)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_box, a_preExp) = daeExpCrefRhsArrayBox(Tpl.emptyTxt, i_ecr, a_context, a_preExp, a_simCode);
        (txt, a_preExp) = fun_239(txt, l_box, a_preExp, a_simCode, a_context, i_cr);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_RHS_CREF"));
      then (txt, a_preExp);
  end matchcontinue;
end daeExpCrefRhs;

protected function lm_241
  input Tpl.Text in_txt;
  input DAE.Dimensions in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      DAE.Dimensions rest;
      DAE.Dimension i_dim;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_dim :: rest )
      equation
        txt = dimension(txt, i_dim);
        txt = Tpl.nextIter(txt);
        txt = lm_241(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_241(txt, rest);
      then txt;
  end matchcontinue;
end lm_241;

protected function fun_242
  input Tpl.Text in_txt;
  input SimCode.SimVar in_mArg;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_ecr_componentRef;
  input Tpl.Text in_a_dimsValuesStr;
  input Tpl.Text in_a_arrType;
  input Tpl.Text in_a_tmpArr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_tmpArr;
algorithm
  (out_txt, out_a_tmpArr) :=
  matchcontinue(in_txt, in_mArg, in_a_simCode, in_a_ecr_componentRef, in_a_dimsValuesStr, in_a_arrType, in_a_tmpArr)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_ecr_componentRef;
      Tpl.Text a_dimsValuesStr;
      Tpl.Text a_arrType;
      Tpl.Text a_tmpArr;
      DAE.Type i_type__;
      BackendDAE.VarKind i_varKind;
      Integer i_index;

    case ( txt,
           SimCode.SIMVAR(index = i_index, varKind = i_varKind, type_ = i_type__),
           a_simCode,
           a_ecr_componentRef,
           a_dimsValuesStr,
           a_arrType,
           a_tmpArr )
      equation
        (txt, a_tmpArr) = tempDecl(txt, "var", a_tmpArr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = new "));
        txt = Tpl.writeText(txt, a_arrType);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_dimsValuesStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-1, /*"));
        txt = crefStr(txt, a_ecr_componentRef, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*/"));
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then (txt, a_tmpArr);

    case ( txt,
           _,
           _,
           _,
           _,
           _,
           a_tmpArr )
      then (txt, a_tmpArr);
  end matchcontinue;
end fun_242;

protected function fun_243
  input Tpl.Text in_txt;
  input SimCode.Context in_a_context;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_ecr_componentRef;
  input Tpl.Text in_a_preExp;
  input DAE.Dimensions in_a_dims;
  input DAE.Type in_a_aty;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_context, in_a_simCode, in_a_ecr_componentRef, in_a_preExp, in_a_dims, in_a_aty)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_ecr_componentRef;
      Tpl.Text a_preExp;
      DAE.Dimensions a_dims;
      DAE.Type a_aty;
      SimCode.SimVar ret_4;
      Tpl.Text l_dimsValuesStr;
      Integer ret_2;
      Tpl.Text l_arrType;
      Tpl.Text l_tmpArr;

    case ( txt,
           SimCode.FUNCTION_CONTEXT(),
           _,
           _,
           a_preExp,
           _,
           _ )
      then (txt, a_preExp);

    case ( txt,
           _,
           a_simCode,
           a_ecr_componentRef,
           a_preExp,
           a_dims,
           a_aty )
      equation
        l_tmpArr = Tpl.emptyTxt;
        ret_2 = listLength(a_dims);
        l_arrType = expTypeArray(Tpl.emptyTxt, a_aty, ret_2);
        l_dimsValuesStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_dimsValuesStr = lm_241(l_dimsValuesStr, a_dims);
        l_dimsValuesStr = Tpl.popIter(l_dimsValuesStr);
        ret_4 = SimCode.cref2simvar(a_ecr_componentRef, a_simCode);
        (a_preExp, l_tmpArr) = fun_242(a_preExp, ret_4, a_simCode, a_ecr_componentRef, l_dimsValuesStr, l_arrType, l_tmpArr);
        txt = Tpl.writeText(txt, l_tmpArr);
      then (txt, a_preExp);
  end matchcontinue;
end fun_243;

public function daeExpCrefRhsArrayBox
  input Tpl.Text in_txt;
  input DAE.Exp in_a_exp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_exp, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef i_ecr_componentRef;
      DAE.Dimensions i_dims;
      DAE.Type i_aty;

    case ( txt,
           DAE.CREF(ty = DAE.T_ARRAY(ty = i_aty, dims = i_dims), componentRef = i_ecr_componentRef),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = fun_243(txt, a_context, a_simCode, i_ecr_componentRef, a_preExp, i_dims, i_aty);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end daeExpCrefRhsArrayBox;

protected function lm_245
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_e;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_e :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = expTypeFromExp(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        (txt, a_preExp) = daeExp(txt, i_e, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-1"));
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_245(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_245(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_245;

protected function fun_246
  input Tpl.Text in_txt;
  input DAE.Exp in_a_exp;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_exp, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      list<DAE.Exp> i_array;

    case ( txt,
           DAE.ARRAY(scalar = true, ty = DAE.T_INTEGER(varLst = _), array = i_array),
           a_simCode,
           a_preExp,
           a_context )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("new int[]{"));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, a_preExp) = lm_245(txt, i_array, a_simCode, a_preExp, a_context);
        txt = Tpl.popIter(txt);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UKNOWN_SLICE_EXP"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_246;

protected function fun_247
  input Tpl.Text in_txt;
  input DAE.Subscript in_a_sub;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_sub, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_exp;

    case ( txt,
           DAE.INDEX(exp = i_exp),
           a_simCode,
           a_preExp,
           a_context )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("new int[]{"));
        (txt, a_preExp) = daeExp(txt, i_exp, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-1}"));
      then (txt, a_preExp);

    case ( txt,
           DAE.WHOLEDIM(),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("null"));
      then (txt, a_preExp);

    case ( txt,
           DAE.SLICE(exp = i_exp),
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = fun_246(txt, i_exp, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end fun_247;

protected function lm_248
  input Tpl.Text in_txt;
  input list<DAE.Subscript> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Subscript> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Subscript i_sub;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_sub :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = fun_247(txt, i_sub, a_simCode, a_preExp, a_context);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_248(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_248(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_248;

public function daeExpCrefRhsIndexSpec
  input Tpl.Text txt;
  input list<DAE.Subscript> a_subs;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  (out_txt, out_a_preExp) := lm_248(out_txt, a_subs, a_simCode, a_preExp, a_context);
  out_txt := Tpl.popIter(out_txt);
end daeExpCrefRhsIndexSpec;

protected function smf_250
  input Tpl.Text in_txt;
  input SimCode.SimVar in_it;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input list<DAE.Exp> in_a_subs;
  input DAE.Dimensions in_a_dims;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_it, in_a_simCode, in_a_preExp, in_a_context, in_a_subs, in_a_dims)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      list<DAE.Exp> a_subs;
      DAE.Dimensions a_dims;
      DAE.Type i_type__;
      BackendDAE.VarKind i_varKind;
      Integer i_index;
      Tpl.Text l_baseSub;
      Tpl.Text l_constSum;

    case ( txt,
           SimCode.SIMVAR(index = i_index, varKind = i_varKind, type_ = i_type__),
           a_simCode,
           a_preExp,
           a_context,
           a_subs,
           a_dims )
      equation
        l_constSum = Tpl.writeStr(Tpl.emptyTxt, intString(i_index));
        (l_baseSub, l_constSum, a_preExp) = asubSubsripts(Tpl.emptyTxt, a_dims, a_subs, l_constSum, a_context, a_preExp, a_simCode);
        txt = representationArrayName(txt, i_varKind, i_type__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeText(txt, l_constSum);
        txt = Tpl.writeText(txt, l_baseSub);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _,
           _,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end smf_250;

protected function fun_251
  input Tpl.Text in_txt;
  input DAE.Type in_a_ecr_ty;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input list<DAE.Exp> in_a_subs;
  input SimCode.SimCode in_a_simCode;
  input DAE.ComponentRef in_a_cr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_ecr_ty, in_a_preExp, in_a_context, in_a_subs, in_a_simCode, in_a_cr)
    local
      Tpl.Text txt;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      list<DAE.Exp> a_subs;
      SimCode.SimCode a_simCode;
      DAE.ComponentRef a_cr;
      DAE.Dimensions i_dims;
      SimCode.SimVar ret_0;

    case ( txt,
           DAE.T_ARRAY(ty = DAE.T_REAL(varLst = _), dims = i_dims),
           a_preExp,
           a_context,
           a_subs,
           a_simCode,
           a_cr )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*"));
        txt = crefStr(txt, a_cr, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("[]*/"));
        ret_0 = SimCode.cref2simvar(a_cr, a_simCode);
        (txt, a_preExp) = smf_250(txt, ret_0, a_simCode, a_preExp, a_context, a_subs, i_dims);
      then (txt, a_preExp);

    case ( txt,
           _,
           a_preExp,
           _,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_SIMULATION_OTHER_ERROR"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_251;

protected function fun_252
  input Tpl.Text in_txt;
  input SimCode.Context in_a_context;
  input DAE.ComponentRef in_a_cr;
  input DAE.Type in_a_ecr_ty;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input list<DAE.Exp> in_a_subs;
  input DAE.Exp in_a_ecr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_context, in_a_cr, in_a_ecr_ty, in_a_simCode, in_a_preExp, in_a_subs, in_a_ecr)
    local
      Tpl.Text txt;
      DAE.ComponentRef a_cr;
      DAE.Type a_ecr_ty;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      list<DAE.Exp> a_subs;
      DAE.Exp a_ecr;
      SimCode.Context i_context;
      DAE.Exp ret_0;

    case ( txt,
           (i_context as SimCode.FUNCTION_CONTEXT()),
           _,
           _,
           a_simCode,
           a_preExp,
           a_subs,
           a_ecr )
      equation
        ret_0 = SimCode.buildCrefExpFromAsub(a_ecr, a_subs);
        (txt, a_preExp) = daeExpCrefRhs(txt, ret_0, i_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           i_context,
           a_cr,
           a_ecr_ty,
           a_simCode,
           a_preExp,
           a_subs,
           _ )
      equation
        (txt, a_preExp) = fun_251(txt, a_ecr_ty, a_preExp, i_context, a_subs, a_simCode, a_cr);
      then (txt, a_preExp);
  end matchcontinue;
end fun_252;

protected function lm_253
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_index;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_index :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = daeExp(txt, i_index, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_253(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_253(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_253;

public function daeExpAsub
  input Tpl.Text in_txt;
  input DAE.Exp in_a_aexp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_aexp, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      list<DAE.Exp> i_indexes;
      DAE.ComponentRef i_cr;
      DAE.Type i_ecr_ty;
      list<DAE.Exp> i_subs;
      DAE.Exp i_ecr;
      Integer i_j;
      Integer i_i;
      DAE.Exp i_e;

    case ( txt,
           DAE.ASUB(exp = DAE.RANGE(ty = _), sub = {_}),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_EASY_CASE"));
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ASUB(exp = DAE.ASUB(exp = DAE.ASUB(exp = _, sub = {DAE.ICONST(integer = _)}), sub = {DAE.ICONST(integer = _)}), sub = {DAE.ICONST(integer = _)}), sub = {DAE.ICONST(integer = _)}),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_4D"));
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ASUB(exp = DAE.ASUB(exp = _, sub = {DAE.ICONST(integer = _)}), sub = {DAE.ICONST(integer = _)}), sub = {DAE.ICONST(integer = _)}),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_3D"));
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ASUB(exp = i_e, sub = {DAE.ICONST(integer = i_i)}), sub = {DAE.ICONST(integer = i_j)}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExp(txt, i_e, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.writeStr(txt, intString(i_i));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeStr(txt, intString(i_j));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = _, sub = {DAE.ICONST(integer = _)}),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_ARRAY"));
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = (i_ecr as DAE.CREF(componentRef = i_cr, ty = i_ecr_ty)), sub = i_subs),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = fun_252(txt, a_context, i_cr, i_ecr_ty, a_simCode, a_preExp, i_subs, i_ecr);
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = DAE.ARRAY(scalar = true), sub = {_}),
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ASUB_FAST_ONE"));
      then (txt, a_preExp);

    case ( txt,
           DAE.ASUB(exp = i_e, sub = i_indexes),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExp(txt, i_e, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, a_preExp) = lm_253(txt, i_indexes, a_simCode, a_preExp, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OTHER_ASUB__ERROR"));
      then (txt, a_preExp);
  end matchcontinue;
end daeExpAsub;

protected function lm_255
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<DAE.Dimension> rest;
      DAE.Dimension i_dim;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_dim :: rest )
      equation
        txt = dimension(txt, i_dim);
        txt = Tpl.nextIter(txt);
        txt = lm_255(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_255(txt, rest);
      then txt;
  end matchcontinue;
end lm_255;

protected function fun_256
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_a_dimsRest;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input list<DAE.Exp> in_a_subsRest;
  input Tpl.Text in_a_subStr;
  input Tpl.Text in_a_constSum;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
  output Tpl.Text out_a_constSum;
algorithm
  (out_txt, out_a_preExp, out_a_constSum) :=
  matchcontinue(in_txt, in_a_dimsRest, in_a_simCode, in_a_preExp, in_a_context, in_a_subsRest, in_a_subStr, in_a_constSum)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      list<DAE.Exp> a_subsRest;
      Tpl.Text a_subStr;
      Tpl.Text a_constSum;
      list<DAE.Dimension> i_dimsRest;
      Tpl.Text l_ds;

    case ( txt,
           {},
           _,
           a_preExp,
           _,
           _,
           a_subStr,
           a_constSum )
      equation
        a_constSum = Tpl.writeTok(a_constSum, Tpl.ST_STRING("-1 + "));
        a_constSum = Tpl.writeText(a_constSum, a_subStr);
      then (txt, a_preExp, a_constSum);

    case ( txt,
           i_dimsRest,
           a_simCode,
           a_preExp,
           a_context,
           a_subsRest,
           a_subStr,
           a_constSum )
      equation
        l_ds = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING("*")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_ds = lm_255(l_ds, i_dimsRest);
        l_ds = Tpl.popIter(l_ds);
        a_constSum = Tpl.writeTok(a_constSum, Tpl.ST_STRING("-("));
        a_constSum = Tpl.writeText(a_constSum, l_ds);
        a_constSum = Tpl.writeTok(a_constSum, Tpl.ST_STRING(")"));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("+"));
        txt = Tpl.writeText(txt, a_subStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*("));
        txt = Tpl.writeText(txt, l_ds);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        (txt, a_constSum, a_preExp) = asubSubsripts(txt, i_dimsRest, a_subsRest, a_constSum, a_context, a_preExp, a_simCode);
      then (txt, a_preExp, a_constSum);
  end matchcontinue;
end fun_256;

protected function fun_257
  input Tpl.Text in_txt;
  input list<DAE.Dimension> in_a_dims;
  input list<DAE.Exp> in_a_subsRest;
  input Tpl.Text in_a_constSum;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input DAE.Exp in_a_s;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_constSum;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_constSum, out_a_preExp) :=
  matchcontinue(in_txt, in_a_dims, in_a_subsRest, in_a_constSum, in_a_simCode, in_a_preExp, in_a_context, in_a_s)
    local
      Tpl.Text txt;
      list<DAE.Exp> a_subsRest;
      Tpl.Text a_constSum;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp a_s;
      list<DAE.Dimension> i_dimsRest;
      Tpl.Text l_subStr;

    case ( txt,
           _ :: i_dimsRest,
           a_subsRest,
           a_constSum,
           a_simCode,
           a_preExp,
           a_context,
           a_s )
      equation
        (l_subStr, a_preExp) = daeExp(Tpl.emptyTxt, a_s, a_context, a_preExp, a_simCode);
        (txt, a_preExp, a_constSum) = fun_256(txt, i_dimsRest, a_simCode, a_preExp, a_context, a_subsRest, l_subStr, a_constSum);
      then (txt, a_constSum, a_preExp);

    case ( txt,
           _,
           _,
           a_constSum,
           _,
           a_preExp,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ERROR_asubSubsripts_not_enough_dims"));
      then (txt, a_constSum, a_preExp);
  end matchcontinue;
end fun_257;

protected function fun_258
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_a_subs;
  input list<DAE.Dimension> in_a_dims;
  input Tpl.Text in_a_constSum;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_constSum;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_constSum, out_a_preExp) :=
  matchcontinue(in_txt, in_a_subs, in_a_dims, in_a_constSum, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      list<DAE.Dimension> a_dims;
      Tpl.Text a_constSum;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      list<DAE.Exp> i_subsRest;
      DAE.Exp i_s;

    case ( txt,
           i_s :: i_subsRest,
           a_dims,
           a_constSum,
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_constSum, a_preExp) = fun_257(txt, a_dims, i_subsRest, a_constSum, a_simCode, a_preExp, a_context, i_s);
      then (txt, a_constSum, a_preExp);

    case ( txt,
           _,
           _,
           a_constSum,
           _,
           a_preExp,
           _ )
      then (txt, a_constSum, a_preExp);
  end matchcontinue;
end fun_258;

public function asubSubsripts
  input Tpl.Text txt;
  input list<DAE.Dimension> a_dims;
  input list<DAE.Exp> a_subs;
  input Tpl.Text a_constSum;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_constSum;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_constSum, out_a_preExp) := fun_258(txt, a_subs, a_dims, a_constSum, a_context, a_preExp, a_simCode);
end asubSubsripts;

protected function lm_260
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_exp;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_exp :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = daeExp(txt, i_exp, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_260(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_260(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_260;

public function arrayScalarRhs
  input Tpl.Text txt;
  input DAE.Type a_ty;
  input list<DAE.Exp> a_subs;
  input Tpl.Text a_arrName;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_arrName;
  output Tpl.Text out_a_preExp;
protected
  Tpl.Text l_dimsValuesStr;
  Integer ret_1;
  Tpl.Text l_arrayType;
algorithm
  ret_1 := listLength(a_subs);
  l_arrayType := expTypeArray(Tpl.emptyTxt, a_ty, ret_1);
  l_dimsValuesStr := Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  (l_dimsValuesStr, out_a_preExp) := lm_260(l_dimsValuesStr, a_subs, a_simCode, a_preExp, a_context);
  l_dimsValuesStr := Tpl.popIter(l_dimsValuesStr);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("(*ASR"));
  out_txt := Tpl.writeText(out_txt, l_arrayType);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("_element_addr(&"));
  out_txt := Tpl.writeText(out_txt, a_arrName);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(", , "));
  out_txt := Tpl.writeText(out_txt, l_dimsValuesStr);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("))"));
  out_a_arrName := a_arrName;
end arrayScalarRhs;

protected function fun_262
  input Tpl.Text in_txt;
  input DAE.Operator in_a_it;
  input SimCode.SimCode in_a_simCode;
  input DAE.Exp in_a_exp1;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_e1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it, in_a_simCode, in_a_exp1, in_a_e2, in_a_e1)
    local
      Tpl.Text txt;
      SimCode.SimCode a_simCode;
      DAE.Exp a_exp1;
      Tpl.Text a_e2;
      Tpl.Text a_e1;
      Tpl.Text l_boolConv;

    case ( txt,
           DAE.ADD(ty = _),
           _,
           _,
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" + "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.SUB(ty = _),
           a_simCode,
           a_exp1,
           a_e2,
           a_e1 )
      equation
        l_boolConv = daeExpRealConversionPostfix(Tpl.emptyTxt, a_exp1, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeText(txt, l_boolConv);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") - ("));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeText(txt, l_boolConv);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           DAE.MUL(ty = _),
           _,
           _,
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" * "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.DIV(ty = _),
           _,
           _,
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" / "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.POW(ty = _),
           _,
           _,
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Pow("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.AND(ty = _),
           _,
           _,
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.OR(ty = _),
           _,
           _,
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" || "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpBinary:ERR"));
      then txt;
  end matchcontinue;
end fun_262;

public function daeExpBinary
  input Tpl.Text txt;
  input DAE.Operator a_it;
  input DAE.Exp a_exp1;
  input DAE.Exp a_exp2;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
protected
  Tpl.Text l_e2;
  Tpl.Text l_e1;
algorithm
  (l_e1, out_a_preExp) := daeExp(Tpl.emptyTxt, a_exp1, a_context, a_preExp, a_simCode);
  (l_e2, out_a_preExp) := daeExp(Tpl.emptyTxt, a_exp2, a_context, out_a_preExp, a_simCode);
  out_txt := fun_262(txt, a_it, a_simCode, a_exp1, l_e2, l_e1);
end daeExpBinary;

protected function fun_264
  input Tpl.Text in_txt;
  input DAE.Operator in_a_it;
  input Tpl.Text in_a_e;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it, in_a_e)
    local
      Tpl.Text txt;
      Tpl.Text a_e;

    case ( txt,
           DAE.UMINUS(ty = _),
           a_e )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(-"));
        txt = Tpl.writeText(txt, a_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NOT(ty = _),
           a_e )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(!"));
        txt = Tpl.writeText(txt, a_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.UMINUS_ARR(ty = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UMINUS_ARR_NOT_IMPLEMENTED"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpUnary:ERR"));
      then txt;
  end matchcontinue;
end fun_264;

public function daeExpUnary
  input Tpl.Text txt;
  input DAE.Operator a_it;
  input DAE.Exp a_exp;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
protected
  Tpl.Text l_e;
algorithm
  (l_e, out_a_preExp) := daeExp(Tpl.emptyTxt, a_exp, a_context, a_preExp, a_simCode);
  out_txt := fun_264(txt, a_it, l_e);
end daeExpUnary;

protected function fun_266
  input Tpl.Text in_txt;
  input DAE.Operator in_a_operator;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_e1;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_operator, in_a_e2, in_a_e1)
    local
      Tpl.Text txt;
      Tpl.Text a_e2;
      Tpl.Text a_e1;

    case ( txt,
           DAE.LESS(ty = DAE.T_BOOL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(!"));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESS(ty = DAE.T_STRING(varLst = _)),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.LESS(ty = DAE.T_INTEGER(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" < "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESS(ty = DAE.T_REAL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" < "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.T_BOOL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !"));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.T_STRING(varLst = _)),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.T_INTEGER(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATER(ty = DAE.T_REAL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.T_BOOL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(!"));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" || "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.T_STRING(varLst = _)),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.T_INTEGER(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <= "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = DAE.T_REAL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <= "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.T_BOOL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" || !"));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.T_STRING(varLst = _)),
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("# string comparison not supported\n"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.T_INTEGER(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" >= "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = DAE.T_REAL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" >= "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.T_BOOL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((!"));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !"));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") || ("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.T_STRING(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.T_INTEGER(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = DAE.T_REAL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.T_BOOL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((!"));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") || ("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !"));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.T_STRING(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.T_INTEGER(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = DAE.T_REAL(varLst = _)),
           a_e2,
           a_e1 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpRelation:ERR"));
      then txt;
  end matchcontinue;
end fun_266;

protected function fun_267
  input Tpl.Text in_txt;
  input Tpl.Text in_a_simrel;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_e1;
  input DAE.Operator in_a_operator;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simrel, in_a_e2, in_a_e1, in_a_operator)
    local
      Tpl.Text txt;
      Tpl.Text a_e2;
      Tpl.Text a_e1;
      DAE.Operator a_operator;
      Tpl.Text i_simrel;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}),
           a_e2,
           a_e1,
           a_operator )
      equation
        txt = fun_266(txt, a_operator, a_e2, a_e1);
      then txt;

    case ( txt,
           i_simrel,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeText(txt, i_simrel);
      then txt;
  end matchcontinue;
end fun_267;

public function daeExpRelation
  input Tpl.Text in_txt;
  input DAE.Exp in_a_inExp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_inExp, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.Operator i_operator;
      DAE.Exp i_inExp;
      DAE.Exp i_exp2;
      DAE.Exp i_exp1;
      Tpl.Text l_simrel;
      Tpl.Text l_e2;
      Tpl.Text l_e1;

    case ( txt,
           (i_inExp as DAE.RELATION(exp1 = i_exp1, exp2 = i_exp2, operator = i_operator)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_e1, a_preExp) = daeExp(Tpl.emptyTxt, i_exp1, a_context, a_preExp, a_simCode);
        (l_e2, a_preExp) = daeExp(Tpl.emptyTxt, i_exp2, a_context, a_preExp, a_simCode);
        (l_simrel, l_e1, l_e2, a_preExp) = daeExpSimRelation(Tpl.emptyTxt, i_inExp, a_context, l_e1, l_e2, a_preExp);
        txt = fun_267(txt, l_simrel, l_e2, l_e1, i_operator);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end daeExpRelation;

protected function fun_269
  input Tpl.Text in_txt;
  input DAE.Operator in_a_operator;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_operator)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.LESS(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" < "));
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <= "));
      then txt;

    case ( txt,
           DAE.GREATER(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" > "));
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" >= "));
      then txt;

    case ( txt,
           DAE.EQUAL(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" == "));
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" != "));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" daeExpSimRelation:ERR "));
      then txt;
  end matchcontinue;
end fun_269;

protected function fun_270
  input Tpl.Text in_txt;
  input Boolean in_a_sim_genDiscrete;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_op;
  input Tpl.Text in_a_e1;
  input Integer in_a_index;
  input Tpl.Text in_a_res;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_res;
algorithm
  (out_txt, out_a_res) :=
  matchcontinue(in_txt, in_a_sim_genDiscrete, in_a_e2, in_a_op, in_a_e1, in_a_index, in_a_res)
    local
      Tpl.Text txt;
      Tpl.Text a_e2;
      Tpl.Text a_op;
      Tpl.Text a_e1;
      Integer a_index;
      Tpl.Text a_res;

    case ( txt,
           false,
           _,
           _,
           _,
           a_index,
           a_res )
      equation
        (txt, a_res) = tempDecl(txt, "bool", a_res);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = backuprelations["));
        txt = Tpl.writeStr(txt, intString(a_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("];"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then (txt, a_res);

    case ( txt,
           _,
           a_e2,
           a_op,
           a_e1,
           a_index,
           a_res )
      equation
        (txt, a_res) = tempDecl(txt, "bool", a_res);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeText(txt, a_op);
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "backuprelations["
                                }, false));
        txt = Tpl.writeStr(txt, intString(a_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] = "));
        txt = Tpl.writeText(txt, a_res);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then (txt, a_res);
  end matchcontinue;
end fun_270;

protected function fun_271
  input Tpl.Text in_txt;
  input Integer in_a_index;
  input Boolean in_a_sim_genDiscrete;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_op;
  input Tpl.Text in_a_e1;
  input Tpl.Text in_a_res;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_res;
algorithm
  (out_txt, out_a_res) :=
  matchcontinue(in_txt, in_a_index, in_a_sim_genDiscrete, in_a_e2, in_a_op, in_a_e1, in_a_res)
    local
      Tpl.Text txt;
      Boolean a_sim_genDiscrete;
      Tpl.Text a_e2;
      Tpl.Text a_op;
      Tpl.Text a_e1;
      Tpl.Text a_res;
      Integer i_index;

    case ( txt,
           -1,
           _,
           a_e2,
           a_op,
           a_e1,
           a_res )
      equation
        (txt, a_res) = tempDecl(txt, "bool", a_res);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = Tpl.writeText(txt, a_e1);
        txt = Tpl.writeText(txt, a_op);
        txt = Tpl.writeText(txt, a_e2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then (txt, a_res);

    case ( txt,
           i_index,
           a_sim_genDiscrete,
           a_e2,
           a_op,
           a_e1,
           a_res )
      equation
        (txt, a_res) = fun_270(txt, a_sim_genDiscrete, a_e2, a_op, a_e1, i_index, a_res);
      then (txt, a_res);
  end matchcontinue;
end fun_271;

protected function fun_272
  input Tpl.Text in_txt;
  input DAE.Exp in_a_inExp;
  input Boolean in_a_sim_genDiscrete;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_e1;
  input Tpl.Text in_a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_inExp, in_a_sim_genDiscrete, in_a_e2, in_a_e1, in_a_preExp)
    local
      Tpl.Text txt;
      Boolean a_sim_genDiscrete;
      Tpl.Text a_e2;
      Tpl.Text a_e1;
      Tpl.Text a_preExp;
      Integer i_index;
      DAE.Operator i_operator;
      Tpl.Text l_res;
      Tpl.Text l_op;

    case ( txt,
           DAE.RELATION(operator = i_operator, index = i_index),
           a_sim_genDiscrete,
           a_e2,
           a_e1,
           a_preExp )
      equation
        l_op = fun_269(Tpl.emptyTxt, i_operator);
        l_res = Tpl.emptyTxt;
        (a_preExp, l_res) = fun_271(a_preExp, i_index, a_sim_genDiscrete, a_e2, l_op, a_e1, l_res);
        txt = Tpl.writeText(txt, l_res);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           _,
           _,
           a_preExp )
      then (txt, a_preExp);
  end matchcontinue;
end fun_272;

protected function fun_273
  input Tpl.Text in_txt;
  input SimCode.Context in_a_it;
  input DAE.Exp in_a_inExp;
  input Tpl.Text in_a_e1;
  input Tpl.Text in_a_e2;
  input Tpl.Text in_a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_it, in_a_inExp, in_a_e1, in_a_e2, in_a_preExp)
    local
      Tpl.Text txt;
      DAE.Exp a_inExp;
      Tpl.Text a_e1;
      Tpl.Text a_e2;
      Tpl.Text a_preExp;
      Boolean i_sim_genDiscrete;

    case ( txt,
           SimCode.SIMULATION(genDiscrete = i_sim_genDiscrete),
           a_inExp,
           a_e1,
           a_e2,
           a_preExp )
      equation
        (txt, a_preExp) = fun_272(txt, a_inExp, i_sim_genDiscrete, a_e2, a_e1, a_preExp);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           _,
           _,
           a_preExp )
      then (txt, a_preExp);
  end matchcontinue;
end fun_273;

public function daeExpSimRelation
  input Tpl.Text txt;
  input DAE.Exp a_inExp;
  input SimCode.Context a_it;
  input Tpl.Text a_e1;
  input Tpl.Text a_e2;
  input Tpl.Text a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_e1;
  output Tpl.Text out_a_e2;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) := fun_273(txt, a_it, a_inExp, a_e1, a_e2, a_preExp);
  out_a_e1 := a_e1;
  out_a_e2 := a_e2;
end daeExpSimRelation;

public function SimRelationSimple
  input Tpl.Text txt;
  input Tpl.Text a_e1;
  input Tpl.Text a_e2;
  input String a_op;
  input Tpl.Text a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_e1;
  output Tpl.Text out_a_e2;
  output Tpl.Text out_a_preExp;
protected
  Tpl.Text l_res;
algorithm
  l_res := Tpl.emptyTxt;
  out_a_preExp := Tpl.writeTok(a_preExp, Tpl.ST_STRING("// RELATION( "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeStr(out_a_preExp, a_op);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING_LIST({
                                                 " ) macro expansion\n",
                                                 "\n"
                                             }, true));
  out_txt := Tpl.writeText(txt, l_res);
  out_a_e1 := a_e1;
  out_a_e2 := a_e2;
end SimRelationSimple;

public function SimRelationEqual
  input Tpl.Text txt;
  input Tpl.Text a_e1;
  input Tpl.Text a_e2;
  input String a_op;
  input Tpl.Text a_preExp;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_e1;
  output Tpl.Text out_a_e2;
  output Tpl.Text out_a_preExp;
protected
  Tpl.Text l_res;
algorithm
  l_res := Tpl.emptyTxt;
  out_a_preExp := Tpl.writeTok(a_preExp, Tpl.ST_STRING("// RELATION( "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeStr(out_a_preExp, a_op);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING("= "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_LINE(" ) macro expansion\n"));
  (out_a_preExp, l_res) := tempDecl(out_a_preExp, "bool", l_res);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(";  if (isInUpdate) { "));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_res);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" = "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeStr(out_a_preExp, a_op);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(";  if(!"));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_res);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" && ("));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeStr(out_a_preExp, a_op);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING("= "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(")) {  SwapOldVars(); double res1 = "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" - "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(";  SwapOldVars12(); "));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_res);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" = res1"));
  out_a_preExp := Tpl.writeStr(out_a_preExp, a_op);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING("= ("));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" - "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING("); SwapOldVars2(); }  } else "));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_res);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" = "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e1);
  out_a_preExp := Tpl.writeStr(out_a_preExp, a_op);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING("= "));
  out_a_preExp := Tpl.writeText(out_a_preExp, a_e2);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(";"));
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_NEW_LINE());
  out_txt := Tpl.writeText(txt, l_res);
  out_a_e1 := a_e1;
  out_a_e2 := a_e2;
end SimRelationEqual;

public function daeExpIf
  input Tpl.Text txt;
  input DAE.Exp a_cond;
  input DAE.Exp a_then__;
  input DAE.Exp a_else__;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
protected
  Tpl.Text txt_6;
  Tpl.Text l_eElse;
  Tpl.Text l_preExpElse;
  Tpl.Text l_eThen;
  Tpl.Text l_preExpThen;
  Tpl.Text l_resVar;
  Tpl.Text l_condExp;
algorithm
  (l_condExp, out_a_preExp) := daeExp(Tpl.emptyTxt, a_cond, a_context, a_preExp, a_simCode);
  l_resVar := Tpl.emptyTxt;
  l_preExpThen := Tpl.emptyTxt;
  (l_eThen, l_preExpThen) := daeExp(Tpl.emptyTxt, a_then__, a_context, l_preExpThen, a_simCode);
  l_preExpElse := Tpl.emptyTxt;
  (l_eElse, l_preExpElse) := daeExp(Tpl.emptyTxt, a_else__, a_context, l_preExpElse, a_simCode);
  txt_6 := expTypeFromExpArrayIf(Tpl.emptyTxt, a_then__);
  (out_a_preExp, l_resVar) := tempDecl(out_a_preExp, Tpl.textString(txt_6), l_resVar);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING_LIST({
                                                 ";\n",
                                                 "if ("
                                             }, false));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_condExp);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(") { //cond type is "));
  out_a_preExp := expTypeFromExp(out_a_preExp, a_cond);
  out_a_preExp := Tpl.softNewLine(out_a_preExp);
  out_a_preExp := Tpl.pushBlock(out_a_preExp, Tpl.BT_INDENT(2));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_preExpThen);
  out_a_preExp := Tpl.softNewLine(out_a_preExp);
  out_a_preExp := Tpl.writeText(out_a_preExp, l_resVar);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" = "));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_eThen);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_LINE(";\n"));
  out_a_preExp := Tpl.popBlock(out_a_preExp);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_LINE("} else {\n"));
  out_a_preExp := Tpl.pushBlock(out_a_preExp, Tpl.BT_INDENT(2));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_preExpElse);
  out_a_preExp := Tpl.softNewLine(out_a_preExp);
  out_a_preExp := Tpl.writeText(out_a_preExp, l_resVar);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING(" = "));
  out_a_preExp := Tpl.writeText(out_a_preExp, l_eElse);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_LINE(";\n"));
  out_a_preExp := Tpl.popBlock(out_a_preExp);
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_STRING("}"));
  out_a_preExp := Tpl.writeTok(out_a_preExp, Tpl.ST_NEW_LINE());
  out_txt := Tpl.writeText(txt, l_resVar);
end daeExpIf;

protected function fun_278
  input Tpl.Text in_txt;
  input DAE.Exp in_mArg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_mArg)
    local
      Tpl.Text txt;
      String i_string;

    case ( txt,
           DAE.SCONST(string = i_string) )
      equation
        txt = Tpl.writeStr(txt, i_string);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TemplErr:division msg string not recognized"));
      then txt;
  end matchcontinue;
end fun_278;

protected function fun_279
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;
  input Integer in_a_e3_index;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode, in_a_e3_index)
    local
      Tpl.Text txt;
      Integer a_e3_index;
      list<DAE.Exp> i_literals;
      DAE.Exp ret_0;

    case ( txt,
           SimCode.SIMCODE(literals = i_literals),
           a_e3_index )
      equation
        ret_0 = listNth(i_literals, a_e3_index);
        txt = fun_278(txt, ret_0);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_279;

protected function fun_280
  input Tpl.Text in_txt;
  input DAE.Exp in_a_e2;
  input Tpl.Text in_a_msg;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_var1;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_e2, in_a_msg, in_a_simCode, in_a_preExp, in_a_context, in_a_var1)
    local
      Tpl.Text txt;
      Tpl.Text a_msg;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      Tpl.Text a_var1;
      DAE.Exp i_e2;
      Tpl.Text l_var2;

    case ( txt,
           (i_e2 as DAE.RCONST(real = _)),
           _,
           a_simCode,
           a_preExp,
           a_context,
           a_var1 )
      equation
        txt = Tpl.writeText(txt, a_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" / "));
        (txt, a_preExp) = daeExp(txt, i_e2, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           i_e2,
           a_msg,
           a_simCode,
           a_preExp,
           a_context,
           a_var1 )
      equation
        (l_var2, a_preExp) = daeExp(Tpl.emptyTxt, i_e2, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!=0.0 ? "));
        txt = Tpl.writeText(txt, a_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" / "));
        txt = Tpl.writeText(txt, l_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" : DivBy0("));
        txt = Tpl.writeText(txt, a_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeText(txt, l_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(",\""));
        txt = Tpl.writeText(txt, a_msg);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\"))"));
      then (txt, a_preExp);
  end matchcontinue;
end fun_280;

protected function fun_281
  input Tpl.Text in_txt;
  input DAE.Type in_a_arg_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_arg_ty)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.T_INTEGER(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(int)"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_281;

protected function lm_282
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_it;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_it :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = daeExp(txt, i_it, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_282(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_282(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_282;

protected function lm_283
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_it;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_it :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = daeExp(txt, i_it, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_283(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_283(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_283;

protected function fun_284
  input Tpl.Text in_txt;
  input Boolean in_a_attr_builtin;
  input Tpl.Text in_a_funName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_attr_builtin, in_a_funName)
    local
      Tpl.Text txt;
      Tpl.Text a_funName;

    case ( txt,
           false,
           a_funName )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* !!!TODO:."));
        txt = Tpl.writeText(txt, a_funName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_rettype_1 */"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_284;

public function daeExpCall
  input Tpl.Text in_txt;
  input DAE.Exp in_a_it;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_it, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      Absyn.Path i_path;
      Boolean i_attr_builtin;
      list<DAE.Exp> i_expLst;
      DAE.Exp i_s1;
      DAE.Type i_attr_ty;
      DAE.Exp i_toBeCasted;
      DAE.Type i_arg_ty;
      DAE.ComponentRef i_arg_componentRef;
      DAE.Exp i_e2;
      Integer i_e3_index;
      DAE.Exp i_e1;
      Tpl.Text l_funName;
      Tpl.Text l_argStr;
      Tpl.Text l_var2;
      Tpl.Text l_castedVar;
      String ret_3;
      Tpl.Text l_msg;
      Tpl.Text l_string;
      Tpl.Text l_var1;

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "DIVISION"), expLst = {i_e1, i_e2, DAE.SHARED_LITERAL(index = i_e3_index)}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_var1, a_preExp) = daeExp(Tpl.emptyTxt, i_e1, a_context, a_preExp, a_simCode);
        l_string = fun_279(Tpl.emptyTxt, a_simCode, i_e3_index);
        ret_3 = Util.escapeModelicaStringToCString(Tpl.textString(l_string));
        l_msg = Tpl.writeStr(Tpl.emptyTxt, ret_3);
        (txt, a_preExp) = fun_280(txt, i_e2, l_msg, a_simCode, a_preExp, a_context, l_var1);
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "der"), expLst = {DAE.CREF(componentRef = i_arg_componentRef)}),
           _,
           a_preExp,
           a_simCode )
      equation
        txt = derCref(txt, i_arg_componentRef, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "pre"), expLst = {DAE.CREF(ty = i_arg_ty, componentRef = i_arg_componentRef)}),
           _,
           a_preExp,
           a_simCode )
      equation
        txt = fun_281(txt, i_arg_ty);
        txt = preCref(txt, i_arg_componentRef, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "integer"), expLst = {i_toBeCasted}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_castedVar, a_preExp) = daeExp(Tpl.emptyTxt, i_toBeCasted, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((int)"));
        txt = Tpl.writeText(txt, l_castedVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "Integer"), expLst = {i_toBeCasted}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_castedVar, a_preExp) = daeExp(Tpl.emptyTxt, i_toBeCasted, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((int)"));
        txt = Tpl.writeText(txt, l_castedVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "$_start"), expLst = {DAE.CREF(componentRef = i_arg_componentRef)}),
           _,
           a_preExp,
           a_simCode )
      equation
        txt = startCref(txt, i_arg_componentRef, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "edge"), expLst = {DAE.CREF(componentRef = i_arg_componentRef)}),
           _,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(/*edge*/"));
        txt = cref(txt, i_arg_componentRef, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" && !("));
        txt = preCref(txt, i_arg_componentRef, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "max"), expLst = {i_e1, i_e2}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Max("));
        (txt, a_preExp) = daeExp(txt, i_e1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        (txt, a_preExp) = daeExp(txt, i_e2, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "min"), expLst = {i_e1, i_e2}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Min("));
        (txt, a_preExp) = daeExp(txt, i_e1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        (txt, a_preExp) = daeExp(txt, i_e2, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "mod"), expLst = {i_e1, i_e2}, attr = DAE.CALL_ATTR(ty = i_attr_ty)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_var1, a_preExp) = daeExp(Tpl.emptyTxt, i_e1, a_context, a_preExp, a_simCode);
        (l_var2, a_preExp) = daeExp(Tpl.emptyTxt, i_e2, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Mod_"));
        txt = expTypeShort(txt, i_attr_ty);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeText(txt, l_var2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "abs"), expLst = {i_e1}, attr = DAE.CALL_ATTR(ty = DAE.T_INTEGER(varLst = _))),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_var1, a_preExp) = daeExp(Tpl.emptyTxt, i_e1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Abs_int("));
        txt = Tpl.writeText(txt, l_var1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "abs"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Abs("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "log"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Log("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "log10"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Log10("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "exp"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Exp("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "sin"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Sin("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "sqrt"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Sqrt("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "tanh"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("Math.Tanh("));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(path = Absyn.IDENT(name = "noEvent"), expLst = {i_s1}),
           a_context,
           a_preExp,
           a_simCode )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(/*noEvent*/"));
        (txt, a_preExp) = daeExp(txt, i_s1, a_context, a_preExp, a_simCode);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(attr = DAE.CALL_ATTR(tuple_ = false, ty = DAE.T_NORETCALL(source = _), builtin = i_attr_builtin), expLst = i_expLst, path = i_path),
           a_context,
           a_preExp,
           a_simCode )
      equation
        l_argStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_argStr, a_preExp) = lm_282(l_argStr, i_expLst, a_simCode, a_preExp, a_context);
        l_argStr = Tpl.popIter(l_argStr);
        a_preExp = underscorePrefix(a_preExp, i_attr_builtin);
        a_preExp = underscorePath(a_preExp, i_path);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("("));
        a_preExp = Tpl.writeText(a_preExp, l_argStr);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(");"));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* NORETCALL */"));
      then (txt, a_preExp);

    case ( txt,
           DAE.CALL(attr = DAE.CALL_ATTR(tuple_ = false, builtin = i_attr_builtin), expLst = i_expLst, path = i_path),
           a_context,
           a_preExp,
           a_simCode )
      equation
        l_argStr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_argStr, a_preExp) = lm_283(l_argStr, i_expLst, a_simCode, a_preExp, a_context);
        l_argStr = Tpl.popIter(l_argStr);
        l_funName = underscorePath(Tpl.emptyTxt, i_path);
        txt = underscorePrefix(txt, i_attr_builtin);
        txt = Tpl.writeText(txt, l_funName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_argStr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        txt = fun_284(txt, i_attr_builtin, l_funName);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("daeExpCall:NOT_YT_IMPLEMENTED"));
      then (txt, a_preExp);
  end matchcontinue;
end daeExpCall;

protected function lm_286
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_e;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_e :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = expTypeFromExp(txt, i_e);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        (txt, a_preExp) = daeExp(txt, i_e, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_286(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_286(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_286;

protected function fun_287
  input Tpl.Text in_txt;
  input Boolean in_a_scalar;
  input DAE.Type in_a_a_ty;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;
  input list<DAE.Exp> in_a_a_array;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_scalar, in_a_a_ty, in_a_simCode, in_a_preExp, in_a_context, in_a_a_array)
    local
      Tpl.Text txt;
      DAE.Type a_a_ty;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      list<DAE.Exp> a_a_array;
      Integer ret_2;
      Tpl.Text l_params;
      Tpl.Text l_arrayVar;

    case ( txt,
           false,
           _,
           _,
           a_preExp,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NON_SCALAR_ARRAY_notYetImplemeted"));
      then (txt, a_preExp);

    case ( txt,
           _,
           a_a_ty,
           a_simCode,
           a_preExp,
           a_context,
           a_a_array )
      equation
        l_arrayVar = Tpl.emptyTxt;
        l_params = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_params, a_preExp) = lm_286(l_params, a_a_array, a_simCode, a_preExp, a_context);
        l_params = Tpl.popIter(l_params);
        (a_preExp, l_arrayVar) = tempDecl(a_preExp, "var", l_arrayVar);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(" = new "));
        a_preExp = expTypeArray(a_preExp, a_a_ty, 1);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("("));
        ret_2 = listLength(a_a_array);
        a_preExp = Tpl.writeStr(a_preExp, intString(ret_2));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(",-1,new[]{"));
        a_preExp = Tpl.writeText(a_preExp, l_params);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("});"));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, l_arrayVar);
      then (txt, a_preExp);
  end matchcontinue;
end fun_287;

protected function fun_288
  input Tpl.Text in_txt;
  input DAE.Exp in_mArg;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_mArg, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.Type i_a_ty;
      list<DAE.Exp> i_a_array;
      Boolean i_scalar;
      DAE.Exp i_cr;

    case ( txt,
           (i_cr as DAE.CREF(componentRef = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpCrefRhs(txt, i_cr, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.ARRAY(scalar = i_scalar, array = i_a_array, ty = i_a_ty),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = fun_287(txt, i_scalar, i_a_ty, a_simCode, a_preExp, a_context, i_a_array);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end fun_288;

public function daeExpArray
  input Tpl.Text txt;
  input DAE.Exp a_aexp;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
protected
  DAE.Exp ret_0;
algorithm
  ret_0 := SimCode.hackArrayReverseToCref(a_aexp, a_context);
  (out_txt, out_a_preExp) := fun_288(txt, ret_0, a_context, a_preExp, a_simCode);
end daeExpArray;

protected function lm_290
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      DAE.Exp i_elem;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_elem :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = daeExp(txt, i_elem, a_context, a_preExp, a_simCode);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_290(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_290(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_290;

protected function lm_291
  input Tpl.Text in_txt;
  input list<list<DAE.Exp>> in_items;
  input SimCode.SimCode in_a_simCode;
  input Tpl.Text in_a_preExp;
  input SimCode.Context in_a_context;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_simCode, in_a_preExp, in_a_context)
    local
      Tpl.Text txt;
      list<list<DAE.Exp>> rest;
      SimCode.SimCode a_simCode;
      Tpl.Text a_preExp;
      SimCode.Context a_context;
      list<DAE.Exp> i_row;

    case ( txt,
           {},
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);

    case ( txt,
           i_row :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, a_preExp) = lm_290(txt, i_row, a_simCode, a_preExp, a_context);
        txt = Tpl.popIter(txt);
        txt = Tpl.nextIter(txt);
        (txt, a_preExp) = lm_291(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);

    case ( txt,
           _ :: rest,
           a_simCode,
           a_preExp,
           a_context )
      equation
        (txt, a_preExp) = lm_291(txt, rest, a_simCode, a_preExp, a_context);
      then (txt, a_preExp);
  end matchcontinue;
end lm_291;

protected function fun_292
  input Tpl.Text in_txt;
  input DAE.Exp in_mArg;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_mArg, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      list<DAE.Exp> i_row1;
      DAE.Type i_m_ty;
      list<list<DAE.Exp>> i_m_matrix;
      DAE.Type i_ty;
      DAE.Exp i_cr;
      Integer ret_3;
      Integer ret_2;
      Tpl.Text l_matArr;
      Tpl.Text l_tmp;

    case ( txt,
           (i_cr as DAE.CREF(componentRef = _)),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (txt, a_preExp) = daeExpCrefRhs(txt, i_cr, a_context, a_preExp, a_simCode);
      then (txt, a_preExp);

    case ( txt,
           DAE.MATRIX(matrix = {{}}, ty = i_ty),
           _,
           a_preExp,
           _ )
      equation
        l_tmp = Tpl.emptyTxt;
        (a_preExp, l_tmp) = tempDecl(a_preExp, "var", l_tmp);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(" = new "));
        a_preExp = expTypeArray(a_preExp, i_ty, 2);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("(0,1);"));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, l_tmp);
      then (txt, a_preExp);

    case ( txt,
           DAE.MATRIX(matrix = {}, ty = i_ty),
           _,
           a_preExp,
           _ )
      equation
        l_tmp = Tpl.emptyTxt;
        (a_preExp, l_tmp) = tempDecl(a_preExp, "var", l_tmp);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(" = new "));
        a_preExp = expTypeArray(a_preExp, i_ty, 2);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("(0,1);"));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, l_tmp);
      then (txt, a_preExp);

    case ( txt,
           DAE.MATRIX(matrix = (i_m_matrix as i_row1 :: _), ty = i_m_ty),
           a_context,
           a_preExp,
           a_simCode )
      equation
        l_tmp = Tpl.emptyTxt;
        l_matArr = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_LINE(",\n")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_matArr, a_preExp) = lm_291(l_matArr, i_m_matrix, a_simCode, a_preExp, a_context);
        l_matArr = Tpl.popIter(l_matArr);
        (a_preExp, l_tmp) = tempDecl(a_preExp, "var", l_tmp);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(" = new "));
        a_preExp = expTypeArray(a_preExp, i_m_ty, 2);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("("));
        ret_2 = listLength(i_m_matrix);
        a_preExp = Tpl.writeStr(a_preExp, intString(ret_2));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING(","));
        ret_3 = listLength(i_row1);
        a_preExp = Tpl.writeStr(a_preExp, intString(ret_3));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_LINE(",-1, new[]{\n"));
        a_preExp = Tpl.pushBlock(a_preExp, Tpl.BT_INDENT(2));
        a_preExp = Tpl.pushBlock(a_preExp, Tpl.BT_ANCHOR(0));
        a_preExp = Tpl.writeText(a_preExp, l_matArr);
        a_preExp = Tpl.popBlock(a_preExp);
        a_preExp = Tpl.softNewLine(a_preExp);
        a_preExp = Tpl.popBlock(a_preExp);
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_STRING("});"));
        a_preExp = Tpl.writeTok(a_preExp, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, l_tmp);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end fun_292;

public function daeExpMatrix
  input Tpl.Text txt;
  input DAE.Exp a_mexp;
  input SimCode.Context a_context;
  input Tpl.Text a_preExp;
  input SimCode.SimCode a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
protected
  DAE.Exp ret_0;
algorithm
  ret_0 := SimCode.hackMatrixReverseToCref(a_mexp, a_context);
  (out_txt, out_a_preExp) := fun_292(txt, ret_0, a_context, a_preExp, a_simCode);
end daeExpMatrix;

protected function fun_294
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input Tpl.Text in_a_expVar;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_ty, in_a_expVar)
    local
      Tpl.Text txt;
      Tpl.Text a_expVar;

    case ( txt,
           DAE.T_INTEGER(varLst = _),
           a_expVar )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((int)"));
        txt = Tpl.writeText(txt, a_expVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _),
           a_expVar )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("((double)"));
        txt = Tpl.writeText(txt, a_expVar);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_IMPLEMENTED_CAST"));
      then txt;
  end matchcontinue;
end fun_294;

public function daeExpCast
  input Tpl.Text in_txt;
  input DAE.Exp in_a_cexp;
  input SimCode.Context in_a_context;
  input Tpl.Text in_a_preExp;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_preExp) :=
  matchcontinue(in_txt, in_a_cexp, in_a_context, in_a_preExp, in_a_simCode)
    local
      Tpl.Text txt;
      SimCode.Context a_context;
      Tpl.Text a_preExp;
      SimCode.SimCode a_simCode;
      DAE.Type i_ty;
      DAE.Exp i_exp;
      Tpl.Text l_expVar;

    case ( txt,
           DAE.CAST(exp = i_exp, ty = i_ty),
           a_context,
           a_preExp,
           a_simCode )
      equation
        (l_expVar, a_preExp) = daeExp(Tpl.emptyTxt, i_exp, a_context, a_preExp, a_simCode);
        txt = fun_294(txt, i_ty, l_expVar);
      then (txt, a_preExp);

    case ( txt,
           _,
           _,
           a_preExp,
           _ )
      then (txt, a_preExp);
  end matchcontinue;
end daeExpCast;

public function underscorePrefix
  input Tpl.Text in_txt;
  input Boolean in_a_builtin;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_builtin)
    local
      Tpl.Text txt;

    case ( txt,
           true )
      then txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end underscorePrefix;

public function tempDecl
  input Tpl.Text txt;
  input String a_ty;
  input Tpl.Text a_newVar;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_newVar;
protected
  Integer ret_0;
algorithm
  out_a_newVar := Tpl.writeTok(a_newVar, Tpl.ST_STRING("_tmp"));
  ret_0 := System.tmpTick();
  out_a_newVar := Tpl.writeStr(out_a_newVar, intString(ret_0));
  out_txt := Tpl.writeStr(txt, a_ty);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(" "));
  out_txt := Tpl.writeText(out_txt, out_a_newVar);
end tempDecl;

protected function fun_298
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_a_instDims;
  input DAE.Type in_a_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_instDims, in_a_ty)
    local
      Tpl.Text txt;
      DAE.Type a_ty;
      list<DAE.Exp> i_instDims;
      Integer ret_0;

    case ( txt,
           {},
           a_ty )
      equation
        txt = expTypeArrayIf(txt, a_ty);
      then txt;

    case ( txt,
           i_instDims,
           a_ty )
      equation
        ret_0 = listLength(i_instDims);
        txt = expTypeArray(txt, a_ty, ret_0);
      then txt;
  end matchcontinue;
end fun_298;

public function varType
  input Tpl.Text in_txt;
  input SimCode.Variable in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_var)
    local
      Tpl.Text txt;
      DAE.Type i_ty;
      list<DAE.Exp> i_instDims;

    case ( txt,
           SimCode.VARIABLE(instDims = i_instDims, ty = i_ty) )
      equation
        txt = fun_298(txt, i_instDims, i_ty);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end varType;

public function expTypeShort
  input Tpl.Text in_txt;
  input DAE.Type in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;
      ClassInf.State i_complexClassType;
      DAE.Type i_ty;
      Absyn.Path ret_0;

    case ( txt,
           DAE.T_INTEGER(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("string"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.T_UNKNOWN(source = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNKNOWN_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.T_ANYTYPE(anyClassType = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ANYTYPE_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.T_ARRAY(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.T_COMPLEX(complexClassType = ClassInf.EXTERNAL_OBJ(path = _)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("object"));
      then txt;

    case ( txt,
           DAE.T_COMPLEX(complexClassType = i_complexClassType) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*struct*/"));
        ret_0 = ClassInf.getStateName(i_complexClassType);
        txt = underscorePath(txt, ret_0);
      then txt;

    case ( txt,
           DAE.T_METATYPE(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.T_METABOXED(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_TYPE_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           DAE.T_FUNCTION_REFERENCE_VAR(functionType = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FN_PTR_NOT_SUPPORTED"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expTypeShort_ERROR"));
      then txt;
  end matchcontinue;
end expTypeShort;

protected function fun_301
  input Tpl.Text in_txt;
  input Boolean in_a_isArray;
  input DAE.Type in_a_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_isArray, in_a_ty)
    local
      Tpl.Text txt;
      DAE.Type a_ty;

    case ( txt,
           false,
           a_ty )
      equation
        txt = expTypeShort(txt, a_ty);
      then txt;

    case ( txt,
           _,
           a_ty )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expType_"));
        txt = expTypeArray(txt, a_ty, 0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_NOT_YET"));
      then txt;
  end matchcontinue;
end fun_301;

public function expType
  input Tpl.Text txt;
  input DAE.Type a_ty;
  input Boolean a_isArray;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_301(txt, a_isArray, a_ty);
end expType;

public function expTypeArray
  input Tpl.Text txt;
  input DAE.Type a_ty;
  input Integer a_dims;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("SimArray"));
  out_txt := Tpl.writeStr(out_txt, intString(a_dims));
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("<"));
  out_txt := expTypeShort(out_txt, a_ty);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(">"));
end expTypeArray;

public function expTypeArrayIf
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_ty)
    local
      Tpl.Text txt;
      DAE.Dimensions i_dims;
      DAE.Type i_ty;
      Integer ret_0;

    case ( txt,
           DAE.T_ARRAY(ty = i_ty, dims = i_dims) )
      equation
        ret_0 = listLength(i_dims);
        txt = expTypeArray(txt, i_ty, ret_0);
      then txt;

    case ( txt,
           i_ty )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;
  end matchcontinue;
end expTypeArrayIf;

public function expTypeFromExpArrayIf
  input Tpl.Text txt;
  input DAE.Exp a_exp;

  output Tpl.Text out_txt;
algorithm
  out_txt := expTypeFromExp(txt, a_exp);
end expTypeFromExpArrayIf;

public function expTypeFromExp
  input Tpl.Text in_txt;
  input DAE.Exp in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;
      DAE.Exp i_expr;
      DAE.Exp i_exp;
      DAE.Type i_ty;
      DAE.Type i_attr_ty;
      DAE.Exp i_expThen;
      DAE.Operator i_operator;

    case ( txt,
           DAE.ICONST(integer = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("int"));
      then txt;

    case ( txt,
           DAE.RCONST(real = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double"));
      then txt;

    case ( txt,
           DAE.SCONST(string = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("string"));
      then txt;

    case ( txt,
           DAE.BCONST(bool = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.BINARY(operator = i_operator) )
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.UNARY(operator = i_operator) )
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.LBINARY(operator = i_operator) )
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.LUNARY(operator = i_operator) )
      equation
        txt = expTypeFromOp(txt, i_operator);
      then txt;

    case ( txt,
           DAE.RELATION(exp1 = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.IFEXP(expThen = i_expThen) )
      equation
        txt = expTypeFromExp(txt, i_expThen);
      then txt;

    case ( txt,
           DAE.CALL(attr = DAE.CALL_ATTR(ty = i_attr_ty)) )
      equation
        txt = expTypeShort(txt, i_attr_ty);
      then txt;

    case ( txt,
           DAE.ARRAY(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MATRIX(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.RANGE(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.CAST(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.CREF(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.CODE(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ASUB(exp = i_exp) )
      equation
        txt = expTypeFromExp(txt, i_exp);
      then txt;

    case ( txt,
           DAE.REDUCTION(expr = i_expr) )
      equation
        txt = expTypeFromExp(txt, i_expr);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expTypeFromExp:ERROR"));
      then txt;
  end matchcontinue;
end expTypeFromExp;

public function expTypeFromOp
  input Tpl.Text in_txt;
  input DAE.Operator in_a_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_it)
    local
      Tpl.Text txt;
      DAE.Type i_ty;

    case ( txt,
           DAE.ADD(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.UMINUS(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.UMINUS_ARR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ADD_ARR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB_ARR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_ARR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV_ARR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_ARRAY_SCALAR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.ADD_ARRAY_SCALAR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.SUB_SCALAR_ARRAY(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_SCALAR_PRODUCT(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.MUL_MATRIX_PRODUCT(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV_ARRAY_SCALAR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.DIV_SCALAR_ARRAY(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_ARRAY_SCALAR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_SCALAR_ARRAY(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_ARR(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.POW_ARR2(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.LESS(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.LESSEQ(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.GREATER(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.GREATEREQ(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.EQUAL(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.NEQUAL(ty = i_ty) )
      equation
        txt = expTypeShort(txt, i_ty);
      then txt;

    case ( txt,
           DAE.AND(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.OR(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           DAE.NOT(ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("bool"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("expTypeFromOp:ERROR"));
      then txt;
  end matchcontinue;
end expTypeFromOp;

public function dimension
  input Tpl.Text in_txt;
  input DAE.Dimension in_a_d;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_d)
    local
      Tpl.Text txt;
      Integer i_integer;

    case ( txt,
           DAE.DIM_INTEGER(integer = i_integer) )
      equation
        txt = Tpl.writeStr(txt, intString(i_integer));
      then txt;

    case ( txt,
           DAE.DIM_UNKNOWN() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(":"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INVALID_DIMENSION"));
      then txt;
  end matchcontinue;
end dimension;

public function error
  input Tpl.Text txt;
  input Absyn.Info a_srcInfo;
  input String a_errMessage;

  output Tpl.Text out_txt;
protected
  String ret_0;
algorithm
  Tpl.addSourceTemplateError(a_errMessage, a_srcInfo);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "\n",
                                   "#error "
                               }, false));
  ret_0 := Error.infoStr(a_srcInfo);
  out_txt := Tpl.writeStr(out_txt, ret_0);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("  "));
  out_txt := Tpl.writeStr(out_txt, a_errMessage);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_NEW_LINE());
end error;

public function errorMsg
  input Tpl.Text txt;
  input String a_errMessage;

  output Tpl.Text out_txt;
algorithm
  Tpl.addTemplateError(a_errMessage);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "\n",
                                   "#error "
                               }, false));
  out_txt := Tpl.writeStr(out_txt, a_errMessage);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_NEW_LINE());
end errorMsg;

end CodegenCSharp;