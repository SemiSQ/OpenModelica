encapsulated package CodegenQSS
"
  file:        CodegenQSS.mo
  package:     CodegenQSS
  description: Generated by Susan.
  
  $Id$
"

public import Tpl;

public import SimCode;
public import BackendDAE;
public import System;
public import Absyn;
public import DAE;
public import ClassInf;
public import SCode;
public import Util;
public import List;
public import ComponentReference;
public import Expression;
public import ExpressionDump;
public import Config;
public import Flags;
public import Settings;
public import Patternm;
public import Error;
public import Values;
public import ValuesUtil;
public import BackendQSS;
public import BackendVariable;
public import DAEDump;
public import Algorithm;
public import DAEUtil;
public import Types;
public import CodegenC;

protected function fun_28
  input Tpl.Text in_txt;
  input Option<SimCode.SimulationSettings> in_a_simulationSettingsOpt;
  input Tpl.Text in_a_guid;
  input SimCode.SimCode in_a_simCode;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simulationSettingsOpt, in_a_guid, in_a_simCode)
    local
      Tpl.Text txt;
      Tpl.Text a_guid;
      SimCode.SimCode a_simCode;
      Tpl.Text txt_0;

    case ( txt,
           NONE(),
           _,
           _ )
      then txt;

    case ( txt,
           _,
           a_guid,
           a_simCode )
      equation
        txt_0 = CodegenC.simulationInitFile(Tpl.emptyTxt, a_simCode, Tpl.textString(a_guid));
        Tpl.textFile(txt_0, "model_init.xml");
      then txt;
  end matchcontinue;
end fun_28;

public function translateModel
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;
  input BackendQSS.QSSinfo in_a_qssInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode, in_a_qssInfo)
    local
      Tpl.Text txt;
      BackendQSS.QSSinfo a_qssInfo;
      Option<SimCode.SimulationSettings> i_simulationSettingsOpt;
      SimCode.SimCode i_simCode;
      Tpl.Text txt_2;
      String ret_1;
      Tpl.Text l_guid;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = SimCode.MODELINFO(name = _), simulationSettingsOpt = i_simulationSettingsOpt)),
           a_qssInfo )
      equation
        ret_1 = System.getUUIDStr();
        l_guid = Tpl.writeStr(Tpl.emptyTxt, ret_1);
        txt_2 = generateQsmModel(Tpl.emptyTxt, i_simCode, Tpl.textString(l_guid), a_qssInfo);
        Tpl.textFile(txt_2, "model.umo");
        txt = fun_28(txt, i_simulationSettingsOpt, l_guid, i_simCode);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end translateModel;

protected function lm_30
  input Tpl.Text in_txt;
  input list<list<SimCode.SimEqSystem>> in_items;
  input BackendQSS.QSSinfo in_a_qssInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_qssInfo)
    local
      Tpl.Text txt;
      list<list<SimCode.SimEqSystem>> rest;
      BackendQSS.QSSinfo a_qssInfo;
      list<SimCode.SimEqSystem> i_eq;
      list<DAE.ComponentRef> ret_1;
      list<list<Integer>> ret_0;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_qssInfo )
      equation
        ret_0 = BackendQSS.getStateIndexList(a_qssInfo);
        ret_1 = BackendQSS.getStates(a_qssInfo);
        txt = generateOdeEqs(txt, i_eq, ret_0, ret_1);
        txt = Tpl.nextIter(txt);
        txt = lm_30(txt, rest, a_qssInfo);
      then txt;

    case ( txt,
           _ :: rest,
           a_qssInfo )
      equation
        txt = lm_30(txt, rest, a_qssInfo);
      then txt;
  end matchcontinue;
end lm_30;

protected function fun_31
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;
  input BackendQSS.QSSinfo in_a_qssInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode, in_a_qssInfo)
    local
      Tpl.Text txt;
      BackendQSS.QSSinfo a_qssInfo;
      list<list<SimCode.SimEqSystem>> i_odeEquations;
      Option<SimCode.SimulationSettings> i_simulationSettingsOpt;
      SimCode.ModelInfo i_modelInfo;

    case ( txt,
           SimCode.SIMCODE(modelInfo = i_modelInfo, simulationSettingsOpt = i_simulationSettingsOpt, odeEquations = i_odeEquations),
           a_qssInfo )
      equation
        txt = generateModelInfo(txt, i_modelInfo);
        txt = Tpl.softNewLine(txt);
        txt = generateAnnotation(txt, i_simulationSettingsOpt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("equation\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_30(txt, i_odeEquations, a_qssInfo);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end "));
        txt = getName(txt, i_modelInfo);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "\n"
                                }, true));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_31;

public function generateQsmModel
  input Tpl.Text txt;
  input SimCode.SimCode a_simCode;
  input String a_guid;
  input BackendQSS.QSSinfo a_qssInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_31(txt, a_simCode, a_qssInfo);
end generateQsmModel;

public function getName
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo)
    local
      Tpl.Text txt;
      Absyn.Path i_name;

    case ( txt,
           SimCode.MODELINFO(name = i_name) )
      equation
        txt = CodegenC.dotPath(txt, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end getName;

public function generateModelInfo
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo)
    local
      Tpl.Text txt;
      Integer i_varInfo_numAlgVars;
      Integer i_varInfo_numIntAlgVars;
      Integer i_varInfo_numStateVars;
      SimCode.ModelInfo i_modelInfo;

    case ( txt,
           (i_modelInfo as SimCode.MODELINFO(varInfo = SimCode.VARINFO(numStateVars = i_varInfo_numStateVars, numIntAlgVars = i_varInfo_numIntAlgVars, numAlgVars = i_varInfo_numAlgVars), name = Absyn.IDENT(name = _))) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("model "));
        txt = getName(txt, i_modelInfo);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("constant Integer N = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStateVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "Real x[N](start=xinit());\n",
                                    "//Real d["
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numIntAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "];\n",
                                    "//Real a["
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numAlgVars));
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("];\n"));
        txt = generateInitFunction(txt);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end generateModelInfo;

public function generateInitFunction
  input Tpl.Text txt;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                   "  function xinit()\n",
                                   "    output Real x[N];\n",
                                   "  algorithm\n",
                                   "    x(1):=0;\n",
                                   "    x(2):=0;\n",
                                   "    x(3):=0;\n",
                                   "    x(4):=0;\n",
                                   "  end xinit;"
                               }, false));
end generateInitFunction;

public function generateAnnotation
  input Tpl.Text in_txt;
  input Option<SimCode.SimulationSettings> in_a_simulationSettingsOpt;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simulationSettingsOpt)
    local
      Tpl.Text txt;
      String i_s_variableFilter;
      String i_s_outputFormat;
      String i_s_method;
      Real i_s_tolerance;
      Real i_s_stopTime;
      Real i_s_startTime;

    case ( txt,
           SOME(SimCode.SIMULATION_SETTINGS(startTime = i_s_startTime, stopTime = i_s_stopTime, tolerance = i_s_tolerance, method = i_s_method, outputFormat = i_s_outputFormat, variableFilter = i_s_variableFilter)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("annotation(experiment(StartTime = "));
        txt = Tpl.writeStr(txt, realString(i_s_startTime));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", StopTime = "));
        txt = Tpl.writeStr(txt, realString(i_s_stopTime));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", Tolerance = "));
        txt = Tpl.writeStr(txt, realString(i_s_tolerance));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", Solver = "));
        txt = Tpl.writeStr(txt, i_s_method);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", OutputFormat = "));
        txt = Tpl.writeStr(txt, i_s_outputFormat);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", VariableFilter = "));
        txt = Tpl.writeStr(txt, i_s_variableFilter);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("));"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end generateAnnotation;

protected function lm_37
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input list<DAE.ComponentRef> in_a_states;
  input list<list<Integer>> in_a_indexs;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_states, in_a_indexs)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      list<DAE.ComponentRef> a_states;
      list<list<Integer>> a_indexs;
      Integer x_i0;
      SimCode.SimEqSystem i_eq;
      list<Integer> ret_0;

    case ( txt,
           {},
           _,
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_states,
           a_indexs )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        ret_0 = listNth(a_indexs, x_i0);
        txt = generateOdeEq(txt, i_eq, ret_0, a_states);
        txt = Tpl.nextIter(txt);
        txt = lm_37(txt, rest, a_states, a_indexs);
      then txt;

    case ( txt,
           _ :: rest,
           a_states,
           a_indexs )
      equation
        txt = lm_37(txt, rest, a_states, a_indexs);
      then txt;
  end matchcontinue;
end lm_37;

public function generateOdeEqs
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_odeEquations;
  input list<list<Integer>> a_indexs;
  input list<DAE.ComponentRef> a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_37(out_txt, a_odeEquations, a_states, a_indexs);
  out_txt := Tpl.popIter(out_txt);
end generateOdeEqs;

protected function lm_39
  input Tpl.Text in_txt;
  input list<Integer> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Integer> rest;
      Integer i_it;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_it :: rest )
      equation
        txt = Tpl.writeStr(txt, intString(i_it));
        txt = lm_39(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_39(txt, rest);
      then txt;
  end matchcontinue;
end lm_39;

public function generateOdeEq
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_a_odeEquation;
  input list<Integer> in_a_indexEq;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_odeEquation, in_a_indexEq, in_a_states)
    local
      Tpl.Text txt;
      list<Integer> a_indexEq;
      list<DAE.ComponentRef> a_states;
      DAE.Exp i_exp;
      String ret_1;
      DAE.Exp ret_0;

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(exp = i_exp),
           a_indexEq,
           a_states )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("der(x["));
        txt = lm_39(txt, a_indexEq);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]) = "));
        ret_0 = BackendQSS.replaceVars(i_exp, a_states);
        ret_1 = ExpressionDump.printExpStr(ret_0);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateOdeEq;

end CodegenQSS;