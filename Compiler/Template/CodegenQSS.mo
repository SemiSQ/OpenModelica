encapsulated package CodegenQSS
"
  file:        CodegenQSS.mo
  package:     CodegenQSS
  description: Generated by Susan.
  
  $Id$
"

public import Tpl;

public import SimCode;
public import BackendDAE;
public import System;
public import Absyn;
public import DAE;
public import ClassInf;
public import SCode;
public import Util;
public import List;
public import ComponentReference;
public import Expression;
public import ExpressionDump;
public import Config;
public import Flags;
public import Settings;
public import Patternm;
public import Error;
public import Values;
public import ValuesUtil;
public import BackendQSS;
public import BackendVariable;
public import DAEDump;
public import Algorithm;
public import DAEUtil;
public import Types;
public import CodegenC;

public function translateModel
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;
  input BackendQSS.QSSinfo in_a_qssInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode, in_a_qssInfo)
    local
      Tpl.Text txt;
      BackendQSS.QSSinfo a_qssInfo;
      SimCode.SimCode i_simCode;
      Tpl.Text txt_0;

    case ( txt,
           (i_simCode as SimCode.SIMCODE(modelInfo = SimCode.MODELINFO(name = _))),
           a_qssInfo )
      equation
        txt_0 = generateQsmModel(Tpl.emptyTxt, i_simCode, a_qssInfo);
        Tpl.textFile(txt_0, "model.mo");
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end translateModel;

protected function lm_29
  input Tpl.Text in_txt;
  input list<list<SimCode.SimEqSystem>> in_items;
  input Tpl.Text in_a_funDecls;
  input BackendQSS.QSSinfo in_a_qssInfo;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_funDecls;
algorithm
  (out_txt, out_a_funDecls) :=
  matchcontinue(in_txt, in_items, in_a_funDecls, in_a_qssInfo)
    local
      Tpl.Text txt;
      list<list<SimCode.SimEqSystem>> rest;
      Tpl.Text a_funDecls;
      BackendQSS.QSSinfo a_qssInfo;
      list<SimCode.SimEqSystem> i_eq;
      list<DAE.ComponentRef> ret_3;
      list<DAE.ComponentRef> ret_2;
      list<DAE.ComponentRef> ret_1;
      list<list<Integer>> ret_0;

    case ( txt,
           {},
           a_funDecls,
           _ )
      then (txt, a_funDecls);

    case ( txt,
           i_eq :: rest,
           a_funDecls,
           a_qssInfo )
      equation
        ret_0 = BackendQSS.getStateIndexList(a_qssInfo);
        ret_1 = BackendQSS.getStates(a_qssInfo);
        ret_2 = BackendQSS.getDisc(a_qssInfo);
        ret_3 = BackendQSS.getAlgs(a_qssInfo);
        (txt, a_funDecls) = generateOdeEqs(txt, i_eq, ret_0, ret_1, ret_2, ret_3, a_funDecls);
        txt = Tpl.nextIter(txt);
        (txt, a_funDecls) = lm_29(txt, rest, a_funDecls, a_qssInfo);
      then (txt, a_funDecls);

    case ( txt,
           _ :: rest,
           a_funDecls,
           a_qssInfo )
      equation
        (txt, a_funDecls) = lm_29(txt, rest, a_funDecls, a_qssInfo);
      then (txt, a_funDecls);
  end matchcontinue;
end lm_29;

public function generateQsmModel
  input Tpl.Text in_txt;
  input SimCode.SimCode in_a_simCode;
  input BackendQSS.QSSinfo in_a_qssInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simCode, in_a_qssInfo)
    local
      Tpl.Text txt;
      BackendQSS.QSSinfo a_qssInfo;
      list<SimCode.SimWhenClause> i_whenClauses;
      list<BackendDAE.ZeroCrossing> i_zeroCrossings;
      Option<SimCode.SimulationSettings> i_simulationSettingsOpt;
      list<SimCode.SimEqSystem> i_parameterEquations;
      list<SimCode.SampleCondition> i_sampleConditions;
      SimCode.ModelInfo i_modelInfo;
      list<list<SimCode.SimEqSystem>> i_odeEquations;
      BackendDAE.EquationArray ret_8;
      list<DAE.ComponentRef> ret_7;
      list<DAE.ComponentRef> ret_6;
      list<DAE.ComponentRef> ret_5;
      list<DAE.ComponentRef> ret_4;
      list<DAE.ComponentRef> ret_3;
      list<DAE.ComponentRef> ret_2;
      Tpl.Text l_eqs;
      Tpl.Text l_funDecls;

    case ( txt,
           SimCode.SIMCODE(odeEquations = i_odeEquations, modelInfo = i_modelInfo, sampleConditions = i_sampleConditions, parameterEquations = i_parameterEquations, simulationSettingsOpt = i_simulationSettingsOpt, zeroCrossings = i_zeroCrossings, whenClauses = i_whenClauses),
           a_qssInfo )
      equation
        l_funDecls = Tpl.emptyTxt;
        l_eqs = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (l_eqs, l_funDecls) = lm_29(l_eqs, i_odeEquations, l_funDecls, a_qssInfo);
        l_eqs = Tpl.popIter(l_eqs);
        ret_2 = BackendQSS.getStates(a_qssInfo);
        ret_3 = BackendQSS.getDisc(a_qssInfo);
        ret_4 = BackendQSS.getAlgs(a_qssInfo);
        txt = generateModelInfo(txt, i_modelInfo, ret_2, ret_3, ret_4, i_sampleConditions, i_parameterEquations);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.writeText(txt, l_funDecls);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = generateAnnotation(txt, i_simulationSettingsOpt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "/* Equations */\n",
                                    "equation\n"
                                }, true));
        txt = Tpl.writeText(txt, l_eqs);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "algorithm\n",
                                    "/* Discontinuities */\n"
                                }, true));
        ret_5 = BackendQSS.getStates(a_qssInfo);
        ret_6 = BackendQSS.getDisc(a_qssInfo);
        ret_7 = BackendQSS.getAlgs(a_qssInfo);
        ret_8 = BackendQSS.getEqs(a_qssInfo);
        txt = generateDiscont(txt, i_zeroCrossings, ret_5, ret_6, ret_7, i_whenClauses, ret_8);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end "));
        txt = getName(txt, i_modelInfo);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateQsmModel;

public function getName
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo)
    local
      Tpl.Text txt;
      Absyn.Path i_name;

    case ( txt,
           SimCode.MODELINFO(name = i_name) )
      equation
        txt = CodegenC.dotPath(txt, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end getName;

public function generateModelInfo
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;
  input list<SimCode.SampleCondition> in_a_sampleConditions;
  input list<SimCode.SimEqSystem> in_a_parameterEquations;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo, in_a_states, in_a_disc, in_a_algs, in_a_sampleConditions, in_a_parameterEquations)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      list<SimCode.SampleCondition> a_sampleConditions;
      list<SimCode.SimEqSystem> a_parameterEquations;
      Integer i_varInfo_numStateVars;
      SimCode.ModelInfo i_modelInfo;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           (i_modelInfo as SimCode.MODELINFO(varInfo = SimCode.VARINFO(numStateVars = i_varInfo_numStateVars), name = Absyn.IDENT(name = _))),
           a_states,
           a_disc,
           a_algs,
           a_sampleConditions,
           a_parameterEquations )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("model "));
        txt = getName(txt, i_modelInfo);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("constant Integer N = "));
        txt = Tpl.writeStr(txt, intString(i_varInfo_numStateVars));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "Real x[N](start=xinit());\n",
                                    "discrete Real d["
                                }, false));
        ret_0 = listLength(a_disc);
        txt = Tpl.writeStr(txt, intString(ret_0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "](start=dinit());\n",
                                    "Real a["
                                }, false));
        ret_1 = listLength(a_algs);
        txt = Tpl.writeStr(txt, intString(ret_1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "];\n",
                                    "\n",
                                    "/* Parameters */\n"
                                }, true));
        txt = generateParameters(txt, i_modelInfo, a_parameterEquations);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "/* Init functions */\n"
                                }, true));
        txt = generateInitFunction(txt, i_modelInfo, a_states, a_disc, a_algs, a_sampleConditions);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateModelInfo;

public function OptionInitial
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_a_initialValue;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_initialValue)
    local
      Tpl.Text txt;
      DAE.Exp i_exp;

    case ( txt,
           SOME(DAE.BCONST(bool = true)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("1.0"));
      then txt;

    case ( txt,
           SOME(DAE.BCONST(bool = false)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0.0"));
      then txt;

    case ( txt,
           SOME(i_exp) )
      equation
        txt = CodegenC.initValXml(txt, i_exp);
      then txt;

    case ( txt,
           NONE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0.0"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end OptionInitial;

public function InitStateVariable
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_simVar;
  input list<DAE.ComponentRef> in_a_vars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simVar, in_a_vars)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_vars;
      Option<DAE.Exp> i_initialValue;
      DAE.ComponentRef i_name;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name, initialValue = i_initialValue),
           a_vars )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("x["));
        ret_0 = List.position(i_name, a_vars);
        ret_1 = intAdd(ret_0, 1);
        txt = Tpl.writeStr(txt, intString(ret_1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]:= "));
        txt = OptionInitial(txt, i_initialValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" /* "));
        txt = CodegenC.crefStr(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" */;"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end InitStateVariable;

public function InitAlgVariable
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_simVar;
  input list<DAE.ComponentRef> in_a_vars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simVar, in_a_vars)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_vars;
      DAE.ComponentRef i_name;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name),
           a_vars )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("a["));
        ret_0 = List.position(i_name, a_vars);
        ret_1 = intAdd(ret_0, 1);
        txt = Tpl.writeStr(txt, intString(ret_1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("] is "));
        txt = CodegenC.crefStr(txt, i_name);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end InitAlgVariable;

public function InitDiscVariable
  input Tpl.Text txt;
  input DAE.ComponentRef a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("0.0"));
end InitDiscVariable;

public function generateVarDefinition
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_var)
    local
      Tpl.Text txt;
      Option<DAE.Exp> i_initialValue;
      DAE.ComponentRef i_name;
      String ret_1;
      Tpl.Text txt_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name, initialValue = i_initialValue) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("parameter Real "));
        txt_0 = CodegenC.crefStr(Tpl.emptyTxt, i_name);
        ret_1 = System.stringReplace(Tpl.textString(txt_0), ".", "_");
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = OptionInitial(txt, i_initialValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end generateVarDefinition;

protected function lm_38
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimVar i_v;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_v :: rest )
      equation
        txt = generateVarDefinition(txt, i_v);
        txt = Tpl.nextIter(txt);
        txt = lm_38(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_38(txt, rest);
      then txt;
  end matchcontinue;
end lm_38;

protected function lm_39
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimVar i_v;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_v :: rest )
      equation
        txt = generateVarDefinition(txt, i_v);
        txt = Tpl.nextIter(txt);
        txt = lm_39(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_39(txt, rest);
      then txt;
  end matchcontinue;
end lm_39;

protected function lm_40
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimVar i_v;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_v :: rest )
      equation
        txt = generateVarDefinition(txt, i_v);
        txt = Tpl.nextIter(txt);
        txt = lm_40(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_40(txt, rest);
      then txt;
  end matchcontinue;
end lm_40;

protected function lm_41
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input SimCode.SimVars in_a_vars;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_vars)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      SimCode.SimVars a_vars;
      SimCode.SimEqSystem i_eq;
      String ret_0;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_eq :: rest,
           a_vars )
      equation
        ret_0 = BackendQSS.generateExtraParams(i_eq, a_vars);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.nextIter(txt);
        txt = lm_41(txt, rest, a_vars);
      then txt;

    case ( txt,
           _ :: rest,
           a_vars )
      equation
        txt = lm_41(txt, rest, a_vars);
      then txt;
  end matchcontinue;
end lm_41;

public function generateParameters
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;
  input list<SimCode.SimEqSystem> in_a_parameterEquations;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo, in_a_parameterEquations)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> a_parameterEquations;
      SimCode.SimVars i_vars;
      list<SimCode.SimVar> i_vars_boolParamVars;
      list<SimCode.SimVar> i_vars_intParamVars;
      list<SimCode.SimVar> i_vars_paramVars;
      SimCode.ModelInfo i_modelInfo;
      Tpl.Text txt_0;

    case ( txt,
           (i_modelInfo as SimCode.MODELINFO(vars = (i_vars as SimCode.SIMVARS(paramVars = i_vars_paramVars, intParamVars = i_vars_intParamVars, boolParamVars = i_vars_boolParamVars)))),
           a_parameterEquations )
      equation
        txt_0 = generateHeader(Tpl.emptyTxt, i_modelInfo, a_parameterEquations);
        Tpl.textFile(txt_0, "model.h");
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_38(txt, i_vars_paramVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_39(txt, i_vars_intParamVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_40(txt, i_vars_boolParamVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_41(txt, a_parameterEquations, i_vars);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateParameters;

protected function lm_43
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_states)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      list<DAE.ComponentRef> a_states;
      SimCode.SimVar i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           a_states )
      equation
        txt = InitStateVariable(txt, i_var, a_states);
        txt = Tpl.nextIter(txt);
        txt = lm_43(txt, rest, a_states);
      then txt;

    case ( txt,
           _ :: rest,
           a_states )
      equation
        txt = lm_43(txt, rest, a_states);
      then txt;
  end matchcontinue;
end lm_43;

protected function lm_44
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input list<DAE.ComponentRef> in_a_algs;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_algs)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      list<DAE.ComponentRef> a_algs;
      SimCode.SimVar i_var;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_var :: rest,
           a_algs )
      equation
        txt = InitAlgVariable(txt, i_var, a_algs);
        txt = Tpl.nextIter(txt);
        txt = lm_44(txt, rest, a_algs);
      then txt;

    case ( txt,
           _ :: rest,
           a_algs )
      equation
        txt = lm_44(txt, rest, a_algs);
      then txt;
  end matchcontinue;
end lm_44;

public function generateInitFunction
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;
  input list<SimCode.SampleCondition> in_a_sampleConditions;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo, in_a_states, in_a_disc, in_a_algs, in_a_sampleConditions)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      list<SimCode.SampleCondition> a_sampleConditions;
      list<SimCode.SimVar> i_vars_algVars;
      SimCode.SimVars i_vars;
      list<SimCode.SimVar> i_vars_stateVars;
      String ret_2;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           SimCode.MODELINFO(vars = (i_vars as SimCode.SIMVARS(stateVars = i_vars_stateVars, algVars = i_vars_algVars))),
           a_states,
           a_disc,
           a_algs,
           a_sampleConditions )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "function boolToReal\n",
                                    "  input Boolean b;\n",
                                    "  output Real r;\n",
                                    "algorithm\n",
                                    "  r:=if b then 1.0 else 0.0;\n",
                                    "end boolToReal;\n",
                                    "\n",
                                    "function xinit\n",
                                    "  output Real x[N];\n",
                                    "algorithm\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_43(txt, i_vars_stateVars, a_states);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "end xinit;\n",
                                    "\n",
                                    "function dinit\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("output Real d["));
        ret_0 = listLength(a_disc);
        txt = Tpl.writeStr(txt, intString(ret_0));
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("];\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("algorithm\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        ret_1 = listLength(a_disc);
        ret_2 = BackendQSS.generateDInit(a_disc, a_sampleConditions, i_vars, 0, ret_1, 1);
        txt = Tpl.writeStr(txt, ret_2);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "end dinit;\n",
                                    "\n",
                                    "/* Algebraic vars\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_44(txt, i_vars_algVars, a_algs);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "*/\n",
                                    "\n"
                                }, true));
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateInitFunction;

public function generateAnnotation
  input Tpl.Text in_txt;
  input Option<SimCode.SimulationSettings> in_a_simulationSettingsOpt;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_simulationSettingsOpt)
    local
      Tpl.Text txt;
      String i_s_variableFilter;
      String i_s_outputFormat;
      Real i_s_tolerance;
      Real i_s_stopTime;
      Real i_s_startTime;

    case ( txt,
           SOME(SimCode.SIMULATION_SETTINGS(startTime = i_s_startTime, stopTime = i_s_stopTime, tolerance = i_s_tolerance, outputFormat = i_s_outputFormat, variableFilter = i_s_variableFilter)) )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("annotation(experiment(StartTime = "));
        txt = Tpl.writeStr(txt, realString(i_s_startTime));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", StopTime = "));
        txt = Tpl.writeStr(txt, realString(i_s_stopTime));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", Tolerance = "));
        txt = Tpl.writeStr(txt, realString(i_s_tolerance));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", AbsTolerance = "));
        txt = Tpl.writeStr(txt, realString(i_s_tolerance));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", Solver = QSS3, Output = {x[1]},  OutputFormat = "));
        txt = Tpl.writeStr(txt, i_s_outputFormat);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", VariableFilter = \""));
        txt = Tpl.writeStr(txt, i_s_variableFilter);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\"));"));
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end generateAnnotation;

protected function lm_47
  input Tpl.Text in_txt;
  input list<SimCode.SimEqSystem> in_items;
  input Tpl.Text in_a_funDecls;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;
  input list<list<Integer>> in_a_indexs;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_funDecls;
algorithm
  (out_txt, out_a_funDecls) :=
  matchcontinue(in_txt, in_items, in_a_funDecls, in_a_algs, in_a_disc, in_a_states, in_a_indexs)
    local
      Tpl.Text txt;
      list<SimCode.SimEqSystem> rest;
      Tpl.Text a_funDecls;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      list<list<Integer>> a_indexs;
      SimCode.SimEqSystem i_eq;
      list<Integer> ret_0;

    case ( txt,
           {},
           a_funDecls,
           _,
           _,
           _,
           _ )
      then (txt, a_funDecls);

    case ( txt,
           i_eq :: rest,
           a_funDecls,
           a_algs,
           a_disc,
           a_states,
           a_indexs )
      equation
        ret_0 = listNth(a_indexs, 0);
        (txt, a_funDecls) = generateOdeEq(txt, i_eq, ret_0, a_states, a_disc, a_algs, a_funDecls);
        txt = Tpl.nextIter(txt);
        (txt, a_funDecls) = lm_47(txt, rest, a_funDecls, a_algs, a_disc, a_states, a_indexs);
      then (txt, a_funDecls);

    case ( txt,
           _ :: rest,
           a_funDecls,
           a_algs,
           a_disc,
           a_states,
           a_indexs )
      equation
        (txt, a_funDecls) = lm_47(txt, rest, a_funDecls, a_algs, a_disc, a_states, a_indexs);
      then (txt, a_funDecls);
  end matchcontinue;
end lm_47;

public function generateOdeEqs
  input Tpl.Text txt;
  input list<SimCode.SimEqSystem> a_odeEquations;
  input list<list<Integer>> a_indexs;
  input list<DAE.ComponentRef> a_states;
  input list<DAE.ComponentRef> a_disc;
  input list<DAE.ComponentRef> a_algs;
  input Tpl.Text a_funDecls;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_funDecls;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  (out_txt, out_a_funDecls) := lm_47(out_txt, a_odeEquations, a_funDecls, a_algs, a_disc, a_states, a_indexs);
  out_txt := Tpl.popIter(out_txt);
end generateOdeEqs;

protected function fun_49
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_v;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_v, in_a_algs, in_a_disc, in_a_states)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      DAE.ComponentRef i_name;
      String ret_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name),
           a_algs,
           a_disc,
           a_states )
      equation
        ret_0 = BackendQSS.replaceCref(i_name, a_states, a_disc, a_algs);
        txt = Tpl.writeStr(txt, ret_0);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end fun_49;

protected function lm_50
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_algs, in_a_disc, in_a_states)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      SimCode.SimVar i_v;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_v :: rest,
           a_algs,
           a_disc,
           a_states )
      equation
        txt = fun_49(txt, i_v, a_algs, a_disc, a_states);
        txt = Tpl.nextIter(txt);
        txt = lm_50(txt, rest, a_algs, a_disc, a_states);
      then txt;

    case ( txt,
           _ :: rest,
           a_algs,
           a_disc,
           a_states )
      equation
        txt = lm_50(txt, rest, a_algs, a_disc, a_states);
      then txt;
  end matchcontinue;
end lm_50;

protected function lm_51
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_algs, in_a_disc, in_a_states)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> rest;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      DAE.ComponentRef i_cref;
      String ret_0;

    case ( txt,
           {},
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_cref :: rest,
           a_algs,
           a_disc,
           a_states )
      equation
        ret_0 = BackendQSS.replaceCref(i_cref, a_states, a_disc, a_algs);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.nextIter(txt);
        txt = lm_51(txt, rest, a_algs, a_disc, a_states);
      then txt;

    case ( txt,
           _ :: rest,
           a_algs,
           a_disc,
           a_states )
      equation
        txt = lm_51(txt, rest, a_algs, a_disc, a_states);
      then txt;
  end matchcontinue;
end lm_51;

protected function lm_52
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> rest;
      Integer x_i0;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           _ :: rest )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("input Real i"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_52(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_52(txt, rest);
      then txt;
  end matchcontinue;
end lm_52;

protected function lm_53
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      Integer x_i0;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           _ :: rest )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("output Real o"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_53(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_53(txt, rest);
      then txt;
  end matchcontinue;
end lm_53;

protected function fun_54
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_a_odeEquation;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;
  input Tpl.Text in_a_funDecls;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_funDecls;
algorithm
  (out_txt, out_a_funDecls) :=
  matchcontinue(in_txt, in_a_odeEquation, in_a_states, in_a_disc, in_a_algs, in_a_funDecls)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      Tpl.Text a_funDecls;
      Integer i_index;
      SimCode.SimEqSystem i_e;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> i_simJac;
      list<DAE.Exp> i_beqs;
      list<SimCode.SimVar> i_vars;
      DAE.Exp i_exp;
      DAE.ComponentRef i_cref;
      list<DAE.ComponentRef> ret_7;
      Tpl.Text txt_6;
      list<DAE.ComponentRef> ret_5;
      Tpl.Text l_in__vars;
      Tpl.Text l_out__vars;
      String ret_2;
      DAE.Exp ret_1;
      String ret_0;

    case ( txt,
           SimCode.SES_SIMPLE_ASSIGN(cref = i_cref, exp = i_exp),
           a_states,
           a_disc,
           a_algs,
           a_funDecls )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        ret_0 = BackendQSS.replaceCref(i_cref, a_states, a_disc, a_algs);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        ret_1 = BackendQSS.replaceVars(i_exp, a_states, a_disc, a_algs);
        ret_2 = ExpressionDump.printExpStr(ret_1);
        txt = Tpl.writeStr(txt, ret_2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.popBlock(txt);
      then (txt, a_funDecls);

    case ( txt,
           (i_e as SimCode.SES_LINEAR(vars = i_vars, index = i_index, beqs = i_beqs, simJac = i_simJac)),
           a_states,
           a_disc,
           a_algs,
           a_funDecls )
      equation
        l_out__vars = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_out__vars = lm_50(l_out__vars, i_vars, a_algs, a_disc, a_states);
        l_out__vars = Tpl.popIter(l_out__vars);
        ret_5 = BackendQSS.getRHSVars(i_beqs, i_vars, i_simJac, a_states, a_disc, a_algs);
        l_in__vars = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_in__vars = lm_51(l_in__vars, ret_5, a_algs, a_disc, a_states);
        l_in__vars = Tpl.popIter(l_in__vars);
        txt_6 = generateLinear(Tpl.emptyTxt, i_e, a_states, a_disc, a_algs);
        Tpl.textFile(txt_6, "model.c");
        a_funDecls = Tpl.pushBlock(a_funDecls, Tpl.BT_INDENT(2));
        a_funDecls = Tpl.writeTok(a_funDecls, Tpl.ST_STRING("function fsolve"));
        a_funDecls = Tpl.writeStr(a_funDecls, intString(i_index));
        a_funDecls = Tpl.softNewLine(a_funDecls);
        a_funDecls = Tpl.pushBlock(a_funDecls, Tpl.BT_INDENT(2));
        ret_7 = BackendQSS.getRHSVars(i_beqs, i_vars, i_simJac, a_states, a_disc, a_algs);
        a_funDecls = Tpl.pushIter(a_funDecls, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        a_funDecls = lm_52(a_funDecls, ret_7);
        a_funDecls = Tpl.popIter(a_funDecls);
        a_funDecls = Tpl.softNewLine(a_funDecls);
        a_funDecls = Tpl.pushIter(a_funDecls, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        a_funDecls = lm_53(a_funDecls, i_vars);
        a_funDecls = Tpl.popIter(a_funDecls);
        a_funDecls = Tpl.softNewLine(a_funDecls);
        a_funDecls = Tpl.popBlock(a_funDecls);
        a_funDecls = Tpl.writeTok(a_funDecls, Tpl.ST_STRING_LIST({
                                                  "external \"C\" annotation(Include=\"#include \\\"model.c\\\"\");\n",
                                                  "end fsolve"
                                              }, false));
        a_funDecls = Tpl.writeStr(a_funDecls, intString(i_index));
        a_funDecls = Tpl.writeTok(a_funDecls, Tpl.ST_STRING(";"));
        a_funDecls = Tpl.popBlock(a_funDecls);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_out__vars);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")=fsolve"));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_in__vars);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.popBlock(txt);
      then (txt, a_funDecls);

    case ( txt,
           SimCode.SES_RESIDUAL(exp = _),
           _,
           _,
           _,
           a_funDecls )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("  /* Residual */"));
      then (txt, a_funDecls);

    case ( txt,
           SimCode.SES_ARRAY_CALL_ASSIGN(componentRef = _),
           _,
           _,
           _,
           a_funDecls )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("  /* Array */"));
      then (txt, a_funDecls);

    case ( txt,
           SimCode.SES_NONLINEAR(index = _),
           _,
           _,
           _,
           a_funDecls )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("  /* Non linear */"));
      then (txt, a_funDecls);

    case ( txt,
           SimCode.SES_MIXED(index = _),
           _,
           _,
           _,
           a_funDecls )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("  /* Mixed */"));
      then (txt, a_funDecls);

    case ( txt,
           SimCode.SES_WHEN(left = _),
           _,
           _,
           _,
           a_funDecls )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("  /* When */"));
      then (txt, a_funDecls);

    case ( txt,
           SimCode.SES_ALGORITHM(statements = _),
           _,
           _,
           _,
           a_funDecls )
      then (txt, a_funDecls);

    case ( txt,
           _,
           _,
           _,
           _,
           a_funDecls )
      then (txt, a_funDecls);
  end matchcontinue;
end fun_54;

public function generateOdeEq
  input Tpl.Text txt;
  input SimCode.SimEqSystem a_odeEquation;
  input list<Integer> a_indexEq;
  input list<DAE.ComponentRef> a_states;
  input list<DAE.ComponentRef> a_disc;
  input list<DAE.ComponentRef> a_algs;
  input Tpl.Text a_funDecls;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_funDecls;
algorithm
  (out_txt, out_a_funDecls) := fun_54(txt, a_odeEquation, a_states, a_disc, a_algs, a_funDecls);
end generateOdeEq;

protected function lm_56
  input Tpl.Text in_txt;
  input list<BackendDAE.ZeroCrossing> in_items;
  input BackendDAE.EquationArray in_a_eqs;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_eqs, in_a_algs, in_a_disc, in_a_states)
    local
      Tpl.Text txt;
      list<BackendDAE.ZeroCrossing> rest;
      BackendDAE.EquationArray a_eqs;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      BackendDAE.ZeroCrossing i_zc;

    case ( txt,
           {},
           _,
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_zc :: rest,
           a_eqs,
           a_algs,
           a_disc,
           a_states )
      equation
        txt = generateOneZC(txt, i_zc, a_states, a_disc, a_algs, a_eqs);
        txt = Tpl.nextIter(txt);
        txt = lm_56(txt, rest, a_eqs, a_algs, a_disc, a_states);
      then txt;

    case ( txt,
           _ :: rest,
           a_eqs,
           a_algs,
           a_disc,
           a_states )
      equation
        txt = lm_56(txt, rest, a_eqs, a_algs, a_disc, a_states);
      then txt;
  end matchcontinue;
end lm_56;

public function generateZC
  input Tpl.Text txt;
  input list<BackendDAE.ZeroCrossing> a_zcs;
  input list<DAE.ComponentRef> a_states;
  input list<DAE.ComponentRef> a_disc;
  input list<DAE.ComponentRef> a_algs;
  input BackendDAE.EquationArray a_eqs;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_56(out_txt, a_zcs, a_eqs, a_algs, a_disc, a_states);
  out_txt := Tpl.popIter(out_txt);
end generateZC;

public function generateAssigment
  input Tpl.Text txt;
  input BackendDAE.EqSystem a_eq;
  input list<DAE.ComponentRef> a_states;
  input list<DAE.ComponentRef> a_disc;
  input list<DAE.ComponentRef> a_algs;

  output Tpl.Text out_txt;
algorithm
  out_txt := txt;
end generateAssigment;

public function generateOneZC
  input Tpl.Text in_txt;
  input BackendDAE.ZeroCrossing in_a_zc;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;
  input BackendDAE.EquationArray in_a_eqs;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_zc, in_a_states, in_a_disc, in_a_algs, in_a_eqs)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      BackendDAE.EquationArray a_eqs;
      list<Integer> i_occurEquLst;
      DAE.Exp i_relation__;
      String ret_6;
      String ret_5;
      DAE.Exp ret_4;
      DAE.Exp ret_3;
      String ret_2;
      String ret_1;
      DAE.Exp ret_0;

    case ( txt,
           BackendDAE.ZERO_CROSSING(relation_ = i_relation__, occurEquLst = i_occurEquLst),
           a_states,
           a_disc,
           a_algs,
           a_eqs )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("when "));
        ret_0 = BackendQSS.replaceVars(i_relation__, a_states, a_disc, a_algs);
        ret_1 = ExpressionDump.printExpStr(ret_0);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" then\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        ret_2 = BackendQSS.generateHandler(a_eqs, i_occurEquLst, a_states, a_disc, a_algs, i_relation__, true);
        txt = Tpl.writeStr(txt, ret_2);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("elsewhen "));
        ret_3 = BackendQSS.negate(i_relation__);
        ret_4 = BackendQSS.replaceVars(ret_3, a_states, a_disc, a_algs);
        ret_5 = ExpressionDump.printExpStr(ret_4);
        txt = Tpl.writeStr(txt, ret_5);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" then\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        ret_6 = BackendQSS.generateHandler(a_eqs, i_occurEquLst, a_states, a_disc, a_algs, i_relation__, false);
        txt = Tpl.writeStr(txt, ret_6);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end when;"));
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateOneZC;

public function generateWhen
  input Tpl.Text in_txt;
  input SimCode.SimWhenClause in_a_when;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;
  input Integer in_a_index;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_when, in_a_states, in_a_disc, in_a_algs, in_a_index)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      Integer a_index;
      DAE.Exp i_right;
      DAE.ComponentRef i_left;
      list<tuple<DAE.Exp, Integer>> i_conditions;
      String ret_5;
      DAE.Exp ret_4;
      String ret_3;
      Integer ret_2;
      Integer ret_1;
      Tpl.Text l_extraCode;

    case ( txt,
           SimCode.SIM_WHEN_CLAUSE(conditions = i_conditions, whenEq = SOME(BackendDAE.WHEN_EQ(left = i_left, right = i_right, elsewhenPart = NONE()))),
           a_states,
           a_disc,
           a_algs,
           a_index )
      equation
        l_extraCode = Tpl.emptyTxt;
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("when "));
        ret_1 = listLength(a_disc);
        ret_2 = intAdd(a_index, ret_1);
        (txt, l_extraCode) = generateCond(txt, i_conditions, a_states, a_disc, a_algs, l_extraCode, ret_2);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" then\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(1));
        ret_3 = BackendQSS.replaceCref(i_left, a_states, a_disc, a_algs);
        txt = Tpl.writeStr(txt, ret_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" := "));
        ret_4 = BackendQSS.replaceVars(i_right, a_states, a_disc, a_algs);
        ret_5 = ExpressionDump.printExpStr(ret_4);
        txt = Tpl.writeStr(txt, ret_5);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(";\n"));
        txt = Tpl.writeText(txt, l_extraCode);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end when;"));
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _,
           _,
           _,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/*  NOT MATCHED WHEN */"));
      then txt;
  end matchcontinue;
end generateWhen;

public function generateCond
  input Tpl.Text in_txt;
  input list<tuple<DAE.Exp, Integer>> in_a_conds;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;
  input Tpl.Text in_a_extraCode;
  input Integer in_a_index;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_extraCode;
algorithm
  (out_txt, out_a_extraCode) :=
  matchcontinue(in_txt, in_a_conds, in_a_states, in_a_disc, in_a_algs, in_a_extraCode, in_a_index)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      Tpl.Text a_extraCode;
      Integer a_index;
      DAE.Exp i_e;
      DAE.Exp i_start;
      DAE.Exp i_interval;
      String ret_8;
      DAE.Exp ret_7;
      Integer ret_6;
      String ret_5;
      DAE.Exp ret_4;
      String ret_3;
      DAE.Exp ret_2;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           {(DAE.CALL(path = Absyn.IDENT(name = "sample"), expLst = {i_start, i_interval, _}), _)},
           a_states,
           a_disc,
           a_algs,
           a_extraCode,
           a_index )
      equation
        a_extraCode = Tpl.writeTok(a_extraCode, Tpl.ST_STRING("d["));
        ret_0 = intAdd(a_index, 1);
        a_extraCode = Tpl.writeStr(a_extraCode, intString(ret_0));
        a_extraCode = Tpl.writeTok(a_extraCode, Tpl.ST_STRING("] := pre(d["));
        ret_1 = intAdd(a_index, 1);
        a_extraCode = Tpl.writeStr(a_extraCode, intString(ret_1));
        a_extraCode = Tpl.writeTok(a_extraCode, Tpl.ST_STRING("]) + "));
        ret_2 = BackendQSS.replaceVars(i_interval, a_states, a_disc, a_algs);
        ret_3 = ExpressionDump.printExpStr(ret_2);
        a_extraCode = Tpl.writeStr(a_extraCode, ret_3);
        a_extraCode = Tpl.writeTok(a_extraCode, Tpl.ST_STRING(";"));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("time > "));
        ret_4 = BackendQSS.replaceVars(i_start, a_states, a_disc, a_algs);
        ret_5 = ExpressionDump.printExpStr(ret_4);
        txt = Tpl.writeStr(txt, ret_5);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" + d["));
        ret_6 = intAdd(a_index, 1);
        txt = Tpl.writeStr(txt, intString(ret_6));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then (txt, a_extraCode);

    case ( txt,
           {(i_e, _)},
           a_states,
           a_disc,
           a_algs,
           a_extraCode,
           _ )
      equation
        ret_7 = BackendQSS.replaceVars(i_e, a_states, a_disc, a_algs);
        ret_8 = ExpressionDump.printExpStr(ret_7);
        txt = Tpl.writeStr(txt, ret_8);
      then (txt, a_extraCode);

    case ( txt,
           _,
           _,
           _,
           _,
           a_extraCode,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("initial()"));
      then (txt, a_extraCode);
  end matchcontinue;
end generateCond;

protected function lm_62
  input Tpl.Text in_txt;
  input list<SimCode.SimWhenClause> in_items;
  input list<SimCode.SimWhenClause> in_a_whens;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items, in_a_whens, in_a_algs, in_a_disc, in_a_states)
    local
      Tpl.Text txt;
      list<SimCode.SimWhenClause> rest;
      list<SimCode.SimWhenClause> a_whens;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      Integer x_i0;
      SimCode.SimWhenClause i_w;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           {},
           _,
           _,
           _,
           _ )
      then txt;

    case ( txt,
           i_w :: rest,
           a_whens,
           a_algs,
           a_disc,
           a_states )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        ret_0 = listLength(a_whens);
        ret_1 = intSub(x_i0, ret_0);
        txt = generateWhen(txt, i_w, a_states, a_disc, a_algs, ret_1);
        txt = Tpl.nextIter(txt);
        txt = lm_62(txt, rest, a_whens, a_algs, a_disc, a_states);
      then txt;

    case ( txt,
           _ :: rest,
           a_whens,
           a_algs,
           a_disc,
           a_states )
      equation
        txt = lm_62(txt, rest, a_whens, a_algs, a_disc, a_states);
      then txt;
  end matchcontinue;
end lm_62;

public function generateDiscont
  input Tpl.Text txt;
  input list<BackendDAE.ZeroCrossing> a_zcs;
  input list<DAE.ComponentRef> a_states;
  input list<DAE.ComponentRef> a_disc;
  input list<DAE.ComponentRef> a_algs;
  input list<SimCode.SimWhenClause> a_whens;
  input BackendDAE.EquationArray a_eqs;

  output Tpl.Text out_txt;
algorithm
  out_txt := generateZC(txt, a_zcs, a_states, a_disc, a_algs, a_eqs);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), NONE(), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_62(out_txt, a_whens, a_whens, a_algs, a_disc, a_states);
  out_txt := Tpl.popIter(out_txt);
end generateDiscont;

protected function lm_64
  input Tpl.Text in_txt;
  input list<DAE.ComponentRef> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> rest;
      Integer x_i0;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           _ :: rest )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double i"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.nextIter(txt);
        txt = lm_64(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_64(txt, rest);
      then txt;
  end matchcontinue;
end lm_64;

protected function lm_65
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      Integer x_i0;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = _) :: rest )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("double *o"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.nextIter(txt);
        txt = lm_65(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_65(txt, rest);
      then txt;
  end matchcontinue;
end lm_65;

protected function lm_66
  input Tpl.Text in_txt;
  input list<DAE.Exp> in_items;
  input Tpl.Text in_a_varDecls;
  input Tpl.Text in_a_preExp;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;
  input list<tuple<Integer, Integer, SimCode.SimEqSystem>> in_a_simJac;
  input list<SimCode.SimVar> in_a_vars;
  input list<DAE.Exp> in_a_beqs;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_varDecls;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_varDecls, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_varDecls, in_a_preExp, in_a_algs, in_a_disc, in_a_states, in_a_simJac, in_a_vars, in_a_beqs)
    local
      Tpl.Text txt;
      list<DAE.Exp> rest;
      Tpl.Text a_varDecls;
      Tpl.Text a_preExp;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> a_simJac;
      list<SimCode.SimVar> a_vars;
      list<DAE.Exp> a_beqs;
      Integer x_i0;
      DAE.Exp i_exp;
      String ret_3;
      Tpl.Text txt_2;
      DAE.Exp ret_1;
      list<DAE.ComponentRef> ret_0;

    case ( txt,
           {},
           a_varDecls,
           a_preExp,
           _,
           _,
           _,
           _,
           _,
           _ )
      then (txt, a_varDecls, a_preExp);

    case ( txt,
           i_exp :: rest,
           a_varDecls,
           a_preExp,
           a_algs,
           a_disc,
           a_states,
           a_simJac,
           a_vars,
           a_beqs )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("gsl_vector_set(b,"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        ret_0 = BackendQSS.getRHSVars(a_beqs, a_vars, a_simJac, a_states, a_disc, a_algs);
        ret_1 = BackendQSS.replaceVarsInputs(i_exp, ret_0);
        (txt_2, a_preExp, a_varDecls) = CodegenC.daeExp(Tpl.emptyTxt, ret_1, SimCode.contextOther, a_preExp, a_varDecls);
        ret_3 = System.stringReplace(Tpl.textString(txt_2), "$P", "");
        txt = Tpl.writeStr(txt, ret_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        (txt, a_varDecls, a_preExp) = lm_66(txt, rest, a_varDecls, a_preExp, a_algs, a_disc, a_states, a_simJac, a_vars, a_beqs);
      then (txt, a_varDecls, a_preExp);

    case ( txt,
           _ :: rest,
           a_varDecls,
           a_preExp,
           a_algs,
           a_disc,
           a_states,
           a_simJac,
           a_vars,
           a_beqs )
      equation
        (txt, a_varDecls, a_preExp) = lm_66(txt, rest, a_varDecls, a_preExp, a_algs, a_disc, a_states, a_simJac, a_vars, a_beqs);
      then (txt, a_varDecls, a_preExp);
  end matchcontinue;
end lm_66;

protected function lm_67
  input Tpl.Text in_txt;
  input list<tuple<Integer, Integer, SimCode.SimEqSystem>> in_items;
  input Tpl.Text in_a_varDecls;
  input Tpl.Text in_a_preExp;
  input list<DAE.ComponentRef> in_a_algs;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_states;
  input list<tuple<Integer, Integer, SimCode.SimEqSystem>> in_a_simJac;
  input list<SimCode.SimVar> in_a_vars;
  input list<DAE.Exp> in_a_beqs;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_varDecls;
  output Tpl.Text out_a_preExp;
algorithm
  (out_txt, out_a_varDecls, out_a_preExp) :=
  matchcontinue(in_txt, in_items, in_a_varDecls, in_a_preExp, in_a_algs, in_a_disc, in_a_states, in_a_simJac, in_a_vars, in_a_beqs)
    local
      Tpl.Text txt;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> rest;
      Tpl.Text a_varDecls;
      Tpl.Text a_preExp;
      list<DAE.ComponentRef> a_algs;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_states;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> a_simJac;
      list<SimCode.SimVar> a_vars;
      list<DAE.Exp> a_beqs;
      DAE.Exp i_eq_exp;
      Integer i_col;
      Integer i_row;
      String ret_3;
      Tpl.Text txt_2;
      DAE.Exp ret_1;
      list<DAE.ComponentRef> ret_0;

    case ( txt,
           {},
           a_varDecls,
           a_preExp,
           _,
           _,
           _,
           _,
           _,
           _ )
      then (txt, a_varDecls, a_preExp);

    case ( txt,
           (i_row, i_col, SimCode.SES_RESIDUAL(exp = i_eq_exp)) :: rest,
           a_varDecls,
           a_preExp,
           a_algs,
           a_disc,
           a_states,
           a_simJac,
           a_vars,
           a_beqs )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("gsl_matrix_set(A, "));
        txt = Tpl.writeStr(txt, intString(i_row));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_col));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        ret_0 = BackendQSS.getRHSVars(a_beqs, a_vars, a_simJac, a_states, a_disc, a_algs);
        ret_1 = BackendQSS.replaceVarsInputs(i_eq_exp, ret_0);
        (txt_2, a_preExp, a_varDecls) = CodegenC.daeExp(Tpl.emptyTxt, ret_1, SimCode.contextOther, a_preExp, a_varDecls);
        ret_3 = System.stringReplace(Tpl.textString(txt_2), "$P", "");
        txt = Tpl.writeStr(txt, ret_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        (txt, a_varDecls, a_preExp) = lm_67(txt, rest, a_varDecls, a_preExp, a_algs, a_disc, a_states, a_simJac, a_vars, a_beqs);
      then (txt, a_varDecls, a_preExp);

    case ( txt,
           _ :: rest,
           a_varDecls,
           a_preExp,
           a_algs,
           a_disc,
           a_states,
           a_simJac,
           a_vars,
           a_beqs )
      equation
        (txt, a_varDecls, a_preExp) = lm_67(txt, rest, a_varDecls, a_preExp, a_algs, a_disc, a_states, a_simJac, a_vars, a_beqs);
      then (txt, a_varDecls, a_preExp);
  end matchcontinue;
end lm_67;

protected function lm_68
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      Integer x_i0;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           SimCode.SIMVAR(name = _) :: rest )
      equation
        x_i0 = Tpl.getIteri_i0(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*o"));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = gsl_vector_get(x, "));
        txt = Tpl.writeStr(txt, intString(x_i0));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(");"));
        txt = Tpl.nextIter(txt);
        txt = lm_68(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_68(txt, rest);
      then txt;
  end matchcontinue;
end lm_68;

public function generateLinear
  input Tpl.Text in_txt;
  input SimCode.SimEqSystem in_a_eq;
  input list<DAE.ComponentRef> in_a_states;
  input list<DAE.ComponentRef> in_a_disc;
  input list<DAE.ComponentRef> in_a_algs;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_eq, in_a_states, in_a_disc, in_a_algs)
    local
      Tpl.Text txt;
      list<DAE.ComponentRef> a_states;
      list<DAE.ComponentRef> a_disc;
      list<DAE.ComponentRef> a_algs;
      list<tuple<Integer, Integer, SimCode.SimEqSystem>> i_simJac;
      list<SimCode.SimVar> i_vars;
      list<DAE.Exp> i_beqs;
      Integer i_index;
      Integer ret_3;
      list<DAE.ComponentRef> ret_2;
      Tpl.Text l_varDecls;
      Tpl.Text l_preExp;

    case ( txt,
           SimCode.SES_LINEAR(index = i_index, beqs = i_beqs, vars = i_vars, simJac = i_simJac),
           a_states,
           a_disc,
           a_algs )
      equation
        l_preExp = Tpl.emptyTxt;
        l_varDecls = Tpl.emptyTxt;
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "#include <gsl/gsl_math.h>\n",
                                    "#include <gsl/gsl_blas.h>\n",
                                    "#include <gsl/gsl_vector.h>\n",
                                    "#include <gsl/gsl_matrix.h>\n",
                                    "#include <gsl/gsl_linalg.h>\n",
                                    "#include \"model.h\" // Parameters\n",
                                    "\n",
                                    "void fsolve"
                                }, false));
        txt = Tpl.writeStr(txt, intString(i_index));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        ret_2 = BackendQSS.getRHSVars(i_beqs, i_vars, i_simJac, a_states, a_disc, a_algs);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_64(txt, ret_2);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_65(txt, i_vars);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ")\n",
                                    "{\n",
                                    "  gsl_matrix *A;\n",
                                    "  gsl_vector *b,*x;\n",
                                    "  gsl_permutation *p;\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("const int DIM = "));
        ret_3 = listLength(i_beqs);
        txt = Tpl.writeStr(txt, intString(ret_3));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    ";\n",
                                    "\n",
                                    "/* Alloc space */\n",
                                    "A = gsl_matrix_alloc(DIM, DIM);\n",
                                    "b = gsl_vector_alloc(DIM);\n",
                                    "x = gsl_vector_alloc(DIM);\n",
                                    "p = gsl_permutation_alloc(DIM);\n",
                                    "\n",
                                    "/* Fill A and B */\n"
                                }, true));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, l_varDecls, l_preExp) = lm_66(txt, i_beqs, l_varDecls, l_preExp, a_algs, a_disc, a_states, i_simJac, i_vars, i_beqs);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        (txt, l_varDecls, l_preExp) = lm_67(txt, i_simJac, l_varDecls, l_preExp, a_algs, a_disc, a_states, i_simJac, i_vars, i_beqs);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "/* Solve system */\n",
                                    "gsl_linalg_LU_solve(A,p,b,x);\n",
                                    "\n",
                                    "/* Get x values out */\n"
                                }, true));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_68(txt, i_vars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "/* Free structures */\n",
                                    "gsl_vector_free(x);\n",
                                    "gsl_vector_free(b);\n",
                                    "gsl_permutation_free(p);\n",
                                    "gsl_matrix_free(A);\n",
                                    "\n"
                                }, true));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("}"));
      then txt;

    case ( txt,
           _,
           _,
           _,
           _ )
      then txt;
  end matchcontinue;
end generateLinear;

protected function fun_70
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_v;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_v)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_name;
      String ret_1;
      Tpl.Text txt_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("extern double "));
        txt_0 = CodegenC.crefStr(Tpl.emptyTxt, i_name);
        ret_1 = System.stringReplace(Tpl.textString(txt_0), ".", "_");
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_70;

protected function lm_71
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimVar i_v;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_v :: rest )
      equation
        txt = fun_70(txt, i_v);
        txt = Tpl.nextIter(txt);
        txt = lm_71(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_71(txt, rest);
      then txt;
  end matchcontinue;
end lm_71;

protected function fun_72
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_v;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_v)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_name;
      String ret_1;
      Tpl.Text txt_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("extern double "));
        txt_0 = CodegenC.crefStr(Tpl.emptyTxt, i_name);
        ret_1 = System.stringReplace(Tpl.textString(txt_0), ".", "_");
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_72;

protected function lm_73
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimVar i_v;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_v :: rest )
      equation
        txt = fun_72(txt, i_v);
        txt = Tpl.nextIter(txt);
        txt = lm_73(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_73(txt, rest);
      then txt;
  end matchcontinue;
end lm_73;

protected function fun_74
  input Tpl.Text in_txt;
  input SimCode.SimVar in_a_v;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_v)
    local
      Tpl.Text txt;
      DAE.ComponentRef i_name;
      String ret_1;
      Tpl.Text txt_0;

    case ( txt,
           SimCode.SIMVAR(name = i_name) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("extern double "));
        txt_0 = CodegenC.crefStr(Tpl.emptyTxt, i_name);
        ret_1 = System.stringReplace(Tpl.textString(txt_0), ".", "_");
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_74;

protected function lm_75
  input Tpl.Text in_txt;
  input list<SimCode.SimVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> rest;
      SimCode.SimVar i_v;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_v :: rest )
      equation
        txt = fun_74(txt, i_v);
        txt = Tpl.nextIter(txt);
        txt = lm_75(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_75(txt, rest);
      then txt;
  end matchcontinue;
end lm_75;

protected function fun_76
  input Tpl.Text in_txt;
  input SimCode.ModelInfo in_a_modelInfo;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_modelInfo)
    local
      Tpl.Text txt;
      list<SimCode.SimVar> i_vars_boolParamVars;
      list<SimCode.SimVar> i_vars_intParamVars;
      list<SimCode.SimVar> i_vars_paramVars;

    case ( txt,
           SimCode.MODELINFO(vars = SimCode.SIMVARS(paramVars = i_vars_paramVars, intParamVars = i_vars_intParamVars, boolParamVars = i_vars_boolParamVars)) )
      equation
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_71(txt, i_vars_paramVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_73(txt, i_vars_intParamVars);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_75(txt, i_vars_boolParamVars);
        txt = Tpl.popIter(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_76;

public function generateHeader
  input Tpl.Text txt;
  input SimCode.ModelInfo a_modelInfo;
  input list<SimCode.SimEqSystem> a_parameterEquations;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_76(txt, a_modelInfo);
end generateHeader;

end CodegenQSS;