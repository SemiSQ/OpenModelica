encapsulated package InstDumpTpl
"
  file:        InstDumpTpl.mo
  package:     InstDumpTpl
  description: Generated by Susan.
  
  $Id$
"

public import Tpl;

public import Absyn;
public import Connect2;
public import DAE;
public import Expression;
public import InstTypes;
protected import AbsynDumpTpl;
protected import ExpressionDumpTpl;

public function dumpModel
  input Tpl.Text txt;
  input String a_name;
  input InstTypes.Class a_cls;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("class "));
  out_txt := Tpl.writeStr(out_txt, a_name);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := dumpClass(out_txt, a_cls);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING("end "));
  out_txt := Tpl.writeStr(out_txt, a_name);
end dumpModel;

public function dumpComponent
  input Tpl.Text in_txt;
  input InstTypes.Component in_a_component;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_component)
    local
      Tpl.Text txt;
      Absyn.Path i_in;
      DAE.Type i_ty;
      InstTypes.Binding i_binding;
      Absyn.Path i_name;
      Tpl.Text l_inner__str;
      Tpl.Text l_outer__str;
      Tpl.Text l_ty__str;
      Tpl.Text l_bind__str;
      Tpl.Text l_name__str;

    case ( txt,
           InstTypes.UNTYPED_COMPONENT(name = i_name, binding = i_binding) )
      equation
        l_name__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        l_bind__str = dumpBinding(Tpl.emptyTxt, i_binding);
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeText(txt, l_bind__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.TYPED_COMPONENT(name = i_name, binding = i_binding, ty = i_ty) )
      equation
        l_name__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        l_bind__str = dumpBinding(Tpl.emptyTxt, i_binding);
        l_ty__str = ExpressionDumpTpl.dumpType(Tpl.emptyTxt, i_ty);
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeText(txt, l_bind__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.CONDITIONAL_COMPONENT(name = i_name) )
      equation
        l_name__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("conditional "));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.DELETED_COMPONENT(name = i_name) )
      equation
        l_name__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("deleted "));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.OUTER_COMPONENT(innerName = SOME(i_in), name = i_name) )
      equation
        l_outer__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        l_inner__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_in);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("outer "));
        txt = Tpl.writeText(txt, l_outer__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" -> "));
        txt = Tpl.writeText(txt, l_inner__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.OUTER_COMPONENT(name = i_name) )
      equation
        l_outer__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("outer "));
        txt = Tpl.writeText(txt, l_outer__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.PACKAGE(name = i_name) )
      equation
        l_name__str = AbsynDumpTpl.dumpPath(Tpl.emptyTxt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("package "));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpComponent;

protected function fun_10
  input Tpl.Text in_txt;
  input Tpl.Text in_a_cls__str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_cls__str)
    local
      Tpl.Text txt;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}) )
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_NEW_LINE());
      then txt;
  end matchcontinue;
end fun_10;

public function dumpElement
  input Tpl.Text in_txt;
  input InstTypes.Element in_a_element;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_element)
    local
      Tpl.Text txt;
      InstTypes.Class i_cls;
      InstTypes.Component i_component;
      Tpl.Text l_sep__str;
      Tpl.Text l_cls__str;
      Tpl.Text l_comp__str;

    case ( txt,
           InstTypes.ELEMENT(component = i_component, cls = i_cls) )
      equation
        l_comp__str = dumpComponent(Tpl.emptyTxt, i_component);
        l_cls__str = dumpClass(Tpl.emptyTxt, i_cls);
        l_sep__str = fun_10(Tpl.emptyTxt, l_cls__str);
        txt = Tpl.writeText(txt, l_comp__str);
        txt = Tpl.writeText(txt, l_sep__str);
        txt = Tpl.writeText(txt, l_cls__str);
      then txt;

    case ( txt,
           InstTypes.CONDITIONAL_ELEMENT(component = i_component) )
      equation
        l_comp__str = dumpComponent(Tpl.emptyTxt, i_component);
        txt = Tpl.writeText(txt, l_comp__str);
      then txt;

    case ( txt,
           InstTypes.EXTENDED_ELEMENTS(cls = i_cls) )
      equation
        l_cls__str = dumpClass(Tpl.emptyTxt, i_cls);
        txt = Tpl.writeText(txt, l_cls__str);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpElement;

protected function lm_12
  input Tpl.Text in_txt;
  input list<InstTypes.Element> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<InstTypes.Element> rest;
      InstTypes.Element i_comp;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_comp :: rest )
      equation
        txt = dumpElement(txt, i_comp);
        txt = Tpl.nextIter(txt);
        txt = lm_12(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_12(txt, rest);
      then txt;
  end matchcontinue;
end lm_12;

protected function lm_13
  input Tpl.Text in_txt;
  input list<InstTypes.Equation> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<InstTypes.Equation> rest;
      InstTypes.Equation i_ieq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_ieq :: rest )
      equation
        txt = dumpEquation(txt, i_ieq);
        txt = Tpl.nextIter(txt);
        txt = lm_13(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_13(txt, rest);
      then txt;
  end matchcontinue;
end lm_13;

protected function lm_14
  input Tpl.Text in_txt;
  input list<InstTypes.Equation> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<InstTypes.Equation> rest;
      InstTypes.Equation i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpEquation(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_14(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_14(txt, rest);
      then txt;
  end matchcontinue;
end lm_14;

protected function fun_15
  input Tpl.Text in_txt;
  input Tpl.Text in_a_comp__str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_comp__str)
    local
      Tpl.Text txt;
      Tpl.Text i_comp__str;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}) )
      then txt;

    case ( txt,
           i_comp__str )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_comp__str);
        txt = Tpl.popBlock(txt);
      then txt;
  end matchcontinue;
end fun_15;

protected function fun_16
  input Tpl.Text in_txt;
  input Tpl.Text in_a_eq__str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_eq__str)
    local
      Tpl.Text txt;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end equation"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_16;

protected function fun_17
  input Tpl.Text in_txt;
  input Tpl.Text in_a_ieq__str;
  input Tpl.Text in_a_eq__str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_ieq__str, in_a_eq__str)
    local
      Tpl.Text txt;
      Tpl.Text a_eq__str;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}),
           _ )
      then txt;

    case ( txt,
           _,
           a_eq__str )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "initial equation\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, a_eq__str);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = fun_16(txt, a_eq__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;
  end matchcontinue;
end fun_17;

protected function fun_18
  input Tpl.Text in_txt;
  input Tpl.Text in_a_eq__str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_eq__str)
    local
      Tpl.Text txt;
      Tpl.Text i_eq__str;

    case ( txt,
           Tpl.MEM_TEXT(tokens = {}) )
      then txt;

    case ( txt,
           i_eq__str )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "\n",
                                    "equation\n"
                                }, true));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, i_eq__str);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end equation;"));
      then txt;
  end matchcontinue;
end fun_18;

public function dumpClass
  input Tpl.Text in_txt;
  input InstTypes.Class in_a_cls;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_cls)
    local
      Tpl.Text txt;
      list<InstTypes.Equation> i_equations;
      list<InstTypes.Equation> i_initialEquations;
      list<InstTypes.Element> i_components;
      Tpl.Text l_eq__seq__str;
      Tpl.Text l_ieq__seq__str;
      Tpl.Text l_comp__seq__str;
      Tpl.Text l_eq__str;
      Tpl.Text l_ieq__str;
      Tpl.Text l_comp__str;

    case ( txt,
           InstTypes.COMPLEX_CLASS(components = i_components, initialEquations = i_initialEquations, equations = i_equations) )
      equation
        l_comp__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_comp__str = lm_12(l_comp__str, i_components);
        l_comp__str = Tpl.popIter(l_comp__str);
        l_ieq__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_ieq__str = lm_13(l_ieq__str, i_initialEquations);
        l_ieq__str = Tpl.popIter(l_ieq__str);
        l_eq__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_eq__str = lm_14(l_eq__str, i_equations);
        l_eq__str = Tpl.popIter(l_eq__str);
        l_comp__seq__str = fun_15(Tpl.emptyTxt, l_comp__str);
        l_ieq__seq__str = fun_17(Tpl.emptyTxt, l_ieq__str, l_eq__str);
        l_eq__seq__str = fun_18(Tpl.emptyTxt, l_eq__str);
        txt = Tpl.writeText(txt, l_comp__seq__str);
        txt = Tpl.writeText(txt, l_ieq__seq__str);
        txt = Tpl.writeText(txt, l_eq__seq__str);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpClass;

public function dumpExp
  input Tpl.Text txt;
  input DAE.Exp a_exp;

  output Tpl.Text out_txt;
algorithm
  out_txt := ExpressionDumpTpl.dumpExp(txt, a_exp, "\"");
end dumpExp;

protected function fun_21
  input Tpl.Text in_txt;
  input Option<DAE.Exp> in_a_range;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_range)
    local
      Tpl.Text txt;
      DAE.Exp i_range__exp;

    case ( txt,
           SOME(i_range__exp) )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("in "));
        txt = dumpExp(txt, i_range__exp);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end fun_21;

protected function lm_22
  input Tpl.Text in_txt;
  input list<InstTypes.Equation> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<InstTypes.Equation> rest;
      InstTypes.Equation i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpEquation(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_22(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_22(txt, rest);
      then txt;
  end matchcontinue;
end lm_22;

public function dumpEquation
  input Tpl.Text in_txt;
  input InstTypes.Equation in_a_equation;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_equation)
    local
      Tpl.Text txt;
      String i_index;
      list<InstTypes.Equation> i_body;
      Option<DAE.Exp> i_range;
      DAE.Type i_indexType;
      Connect2.Face i_rhsFace;
      Connect2.Face i_lhsFace;
      DAE.ComponentRef i_rhs_1;
      DAE.ComponentRef i_lhs_1;
      DAE.Exp i_rhs;
      DAE.Exp i_lhs;
      Tpl.Text l_eql__str;
      Tpl.Text l_range__str;
      Tpl.Text l_ty__str;
      Tpl.Text l_rhs__face__str;
      Tpl.Text l_lhs__face__str;
      DAE.Type ret_5;
      Tpl.Text l_rhs__ty__str;
      DAE.Type ret_3;
      Tpl.Text l_lhs__ty__str;
      Tpl.Text l_rhs__str;
      Tpl.Text l_lhs__str;

    case ( txt,
           InstTypes.EQUALITY_EQUATION(lhs = i_lhs, rhs = i_rhs) )
      equation
        l_lhs__str = dumpExp(Tpl.emptyTxt, i_lhs);
        l_rhs__str = dumpExp(Tpl.emptyTxt, i_rhs);
        ret_3 = Expression.typeof(i_lhs);
        l_lhs__ty__str = ExpressionDumpTpl.dumpType(Tpl.emptyTxt, ret_3);
        ret_5 = Expression.typeof(i_rhs);
        l_rhs__ty__str = ExpressionDumpTpl.dumpType(Tpl.emptyTxt, ret_5);
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" {"));
        txt = Tpl.writeText(txt, l_lhs__ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} = {"));
        txt = Tpl.writeText(txt, l_rhs__ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
      then txt;

    case ( txt,
           InstTypes.CONNECT_EQUATION(lhs = i_lhs_1, rhs = i_rhs_1, lhsFace = i_lhsFace, rhsFace = i_rhsFace) )
      equation
        l_lhs__str = ExpressionDumpTpl.dumpCref(Tpl.emptyTxt, i_lhs_1);
        l_rhs__str = ExpressionDumpTpl.dumpCref(Tpl.emptyTxt, i_rhs_1);
        l_lhs__face__str = dumpFace(Tpl.emptyTxt, i_lhsFace);
        l_rhs__face__str = dumpFace(Tpl.emptyTxt, i_rhsFace);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("connect("));
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <"));
        txt = Tpl.writeText(txt, l_lhs__face__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(">, "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <"));
        txt = Tpl.writeText(txt, l_rhs__face__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(">);"));
      then txt;

    case ( txt,
           InstTypes.FOR_EQUATION(indexType = i_indexType, range = i_range, body = i_body, index = i_index) )
      equation
        l_ty__str = ExpressionDumpTpl.dumpType(Tpl.emptyTxt, i_indexType);
        l_range__str = fun_21(Tpl.emptyTxt, i_range);
        l_eql__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_eql__str = lm_22(l_eql__str, i_body);
        l_eql__str = Tpl.popIter(l_eql__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("for {"));
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("} "));
        txt = Tpl.writeStr(txt, i_index);
        txt = Tpl.writeText(txt, l_range__str);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(" loop\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_eql__str);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("end for;"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("dumpEquation: IMPLEMENT ME"));
      then txt;
  end matchcontinue;
end dumpEquation;

public function dumpBinding
  input Tpl.Text in_txt;
  input InstTypes.Binding in_a_binding;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_binding)
    local
      Tpl.Text txt;
      DAE.Type i_bindingType;
      DAE.Exp i_bindingExp;
      Absyn.Exp i_aexp;
      Tpl.Text l_ty__str;
      Tpl.Text l_exp__str;

    case ( txt,
           InstTypes.RAW_BINDING(bindingExp = i_aexp) )
      equation
        l_exp__str = AbsynDumpTpl.dumpExp(Tpl.emptyTxt, i_aexp);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("= <RAW> "));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           InstTypes.UNTYPED_BINDING(bindingExp = i_bindingExp) )
      equation
        l_exp__str = dumpExp(Tpl.emptyTxt, i_bindingExp);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("= "));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           InstTypes.TYPED_BINDING(bindingExp = i_bindingExp, bindingType = i_bindingType) )
      equation
        l_exp__str = dumpExp(Tpl.emptyTxt, i_bindingExp);
        l_ty__str = ExpressionDumpTpl.dumpType(Tpl.emptyTxt, i_bindingType);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(1));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("= ("));
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") "));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpBinding;

protected function lm_25
  input Tpl.Text in_txt;
  input InstTypes.Prefix in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      InstTypes.Prefix rest;
      tuple<String, DAE.Dimensions> i_part;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_part :: rest )
      equation
        txt = dumpPrefixPart(txt, i_part);
        txt = Tpl.nextIter(txt);
        txt = lm_25(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_25(txt, rest);
      then txt;
  end matchcontinue;
end lm_25;

public function dumpPrefix
  input Tpl.Text txt;
  input InstTypes.Prefix a_prefix;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(".")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_25(out_txt, a_prefix);
  out_txt := Tpl.popIter(out_txt);
end dumpPrefix;

protected function fun_27
  input Tpl.Text in_txt;
  input DAE.Dimensions in_a_dims;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_dims)
    local
      Tpl.Text txt;
      DAE.Dimensions i_dims;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_dims )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("["));
        txt = ExpressionDumpTpl.dumpDimensions(txt, i_dims);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("]"));
      then txt;
  end matchcontinue;
end fun_27;

public function dumpPrefixPart
  input Tpl.Text in_txt;
  input tuple<String, DAE.Dimensions> in_a_part;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_part)
    local
      Tpl.Text txt;
      String i_name;
      DAE.Dimensions i_dims;
      Tpl.Text l_dims__str;

    case ( txt,
           (i_name, i_dims) )
      equation
        l_dims__str = fun_27(Tpl.emptyTxt, i_dims);
        txt = Tpl.writeStr(txt, i_name);
        txt = Tpl.writeText(txt, l_dims__str);
      then txt;
  end matchcontinue;
end dumpPrefixPart;

protected function lm_29
  input Tpl.Text in_txt;
  input list<Connect2.Connection> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Connect2.Connection> rest;
      Connect2.Connection i_c;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_c :: rest )
      equation
        txt = dumpConnection(txt, i_c);
        txt = Tpl.nextIter(txt);
        txt = lm_29(txt, rest);
      then txt;

    case ( txt,
           _ :: rest )
      equation
        txt = lm_29(txt, rest);
      then txt;
  end matchcontinue;
end lm_29;

public function dumpConnections
  input Tpl.Text in_txt;
  input Connect2.Connections in_a_conn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_conn)
    local
      Tpl.Text txt;
      list<Connect2.Connection> i_connections;
      Tpl.Text l_conn__str;

    case ( txt,
           Connect2.NO_CONNECTIONS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("No connections"));
      then txt;

    case ( txt,
           Connect2.CONNECTIONS(connections = i_connections) )
      equation
        l_conn__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_conn__str = lm_29(l_conn__str, i_connections);
        l_conn__str = Tpl.popIter(l_conn__str);
        txt = Tpl.writeText(txt, l_conn__str);
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpConnections;

public function dumpConnection
  input Tpl.Text in_txt;
  input Connect2.Connection in_a_connection;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_connection)
    local
      Tpl.Text txt;
      Connect2.Connector i_rhs;
      Connect2.Connector i_lhs;
      Tpl.Text l_rhs__str;
      Tpl.Text l_lhs__str;

    case ( txt,
           Connect2.CONNECTION(lhs = i_lhs, rhs = i_rhs) )
      equation
        l_lhs__str = dumpConnector(Tpl.emptyTxt, i_lhs);
        l_rhs__str = dumpConnector(Tpl.emptyTxt, i_rhs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("connect("));
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpConnection;

public function dumpConnector
  input Tpl.Text in_txt;
  input Connect2.Connector in_a_connector;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_connector)
    local
      Tpl.Text txt;
      Connect2.Face i_face;
      DAE.ComponentRef i_name;
      Tpl.Text l_face__str;
      Tpl.Text l_name__str;

    case ( txt,
           Connect2.CONNECTOR(name = i_name, face = i_face) )
      equation
        l_name__str = ExpressionDumpTpl.dumpCref(Tpl.emptyTxt, i_name);
        l_face__str = dumpFace(Tpl.emptyTxt, i_face);
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" <"));
        txt = Tpl.writeText(txt, l_face__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(">"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpConnector;

public function dumpFace
  input Tpl.Text in_txt;
  input Connect2.Face in_a_face;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  matchcontinue(in_txt, in_a_face)
    local
      Tpl.Text txt;

    case ( txt,
           Connect2.INSIDE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("inside"));
      then txt;

    case ( txt,
           Connect2.OUTSIDE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("outside"));
      then txt;

    case ( txt,
           Connect2.NO_FACE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("no_face"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end matchcontinue;
end dumpFace;

public function errorMsg
  input Tpl.Text txt;
  input String a_errMessage;

  output Tpl.Text out_txt;
algorithm
  Tpl.addTemplateError(a_errMessage);
  out_txt := Tpl.writeStr(txt, a_errMessage);
end errorMsg;

end InstDumpTpl;