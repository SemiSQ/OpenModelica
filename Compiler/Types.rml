(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Types.rml
 ** module:      Types
 ** description: Type system
 **
 ** RCS: $Id$
 **
 ** This file specifies the type system, as defined in the modelica
 ** specification. It contains an RML type called `Type' which 
 ** defines types. It also contains relations for
 ** determining subtyping etc.
 **
 ** There are a few known problems with this module.  It currently
 ** depends on `SCode.Attributes', which in turn depends on
 ** `Absyn.ArrayDim'.  However, the only things used from those
 ** modules are constants that could be moved to their own modules.
 **)

module Types :

  with "ClassInf.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "Values.rml"
  with "SCode.rml"

  (** - Identifiers *)
  type Ident = string

  (** - Variables *)
  datatype Var = VAR of Ident			  (* name *)
		      * Attributes		  (* attributes *)
		      * bool	                  (* protected *)
		      * Type			  (* type *)
		      * Binding			  (* equation modification *)

  datatype Attributes = ATTR of bool	(* flow *)
			      * SCode.Accessibility
	  		      * SCode.Variability	(* parameter *)
			      * Absyn.Direction

  datatype Binding = UNBOUND
		   | EQBOUND of Exp.Exp * 
				Values.Value option * (* evaluated exp*)
				Const (* constant *)
		   | VALBOUND of Values.Value

  (** - Types *)
  type Type = (TType * Absyn.Path option (* classname *))

	(**
	 **  A Type is a tuple of a TType (containing the actual type) and a optional classname
	 **  for the class where the type originates from.
	 **)

  datatype TType = T_INTEGER of Var list
		| T_REAL of Var list
		| T_STRING of Var list
		| T_BOOL of Var list
		| T_ENUM 
		| T_ENUMERATION of string list * Var list
		| T_ARRAY of ArrayDim * Type
		| T_COMPLEX of ClassInf.State		  (* The type of. a class *)
			     * Var list
		| T_FUNCTION of FuncArg list 
			     * Type			  (* Only single-result *)
		| T_TUPLE of Type list			  (* For functions returning 
							   multiple values. *)
		| T_NOTYPE				  (* Used when type is not yet determined *)
		| T_ANYTYPE of ClassInf.State option	  (* any_type - used for generic types. When class state present the type is assumed to be a complex type which has that restriction.*)


  datatype ArrayDim = DIM of int option

  type FuncArg = Ident * Type


  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(** The degree of constantness of an expression is determined by the Const 
 ** datatype. Variables declared as 'constant' will get C_CONST constantness.
 ** Variables declared as 'parameter' will get C_PARAM constantness and
 ** all other variables are not constant and will get C_VAR constantness.
 **)
  datatype Const = C_CONST | (* 'constant's, should always be evaluated *)
		   C_PARAM | (* 'parameter's, evaluated if structural *)
		   C_VAR     (* not constants, never evaluated *)

(* Used by split_props  *)
  datatype TupleConst = CONST of Const |
		   TUPLE_CONST  of TupleConst list 

  datatype Properties = PROP of Type * (* type *)
				 Const (* if the type is a tuple, each element 
				          have a const flag. *)

(* Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Type * TupleConst (* The elements might be 
							    tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)

  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)


  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)


  (** - Modification datatype, was originally in Mod *)

  datatype EqMod = TYPED of Exp.Exp * (* modifier as expression *)
			    Values.Value option * (* modifier as Value option*)
			    Properties 
		   | UNTYPED of Absyn.Exp
  datatype SubMod = NAMEMOD of Ident * Mod
		  | IDXMOD of int 
list * Mod
  and Mod = MOD of bool (* final *) * (SubMod list) * EqMod option
  	  | REDECL of bool (* final *) * (SCode.Element*Mod) list
	  | NOMOD


  (** - Exported relations *)
  relation basic_type : Type => bool
  relation equivtypes : (Type, Type) => bool
  relation subtype : (Type, Type) => bool
  relation lookup_component : (Type, Ident) => Var
  relation lift_array : (Type,int option) => Type
  relation unlift_array : Type => Type
  relation make_array: (Type, Absyn.ArrayDim) => Type
  relation array_element_type : Type => Type
  relation print_type : Type => ()
  relation print_prop : Properties => ()
  relation print_prop_str: Properties => string 
  relation unparse_type : Type => string
  relation unparse_var: Var => string 
  relation unparse_tupleconst : TupleConst => string
  relation unparse_const : Const => string
  relation print_var : Var => ()
  relation print_binding : Binding => ()
  relation print_binding_str : Binding => string
  relation print_params : FuncArg list => () 
  relation print_farg: FuncArg => () 
  relation make_function_type : (Absyn.Path, Var list) => Type
  relation make_enumeration_type: (Absyn.Path, Var list) => Type 
  relation is_parameter: Var => ()
  relation contain_real: Type list => bool
  relation dimensions_known: Type => bool 
  relation strip_submod: Mod => Mod
	 
  relation get_vars: (Var list, Var => () )  => Var list
  relation get_classname: (Type) => Absyn.Path
  relation get_type_name: Type => string
  relation is_array : Type => bool
  relation is_string : Type => bool
  relation is_array_or_string : Type => bool
  relation is_input_attr : Attributes => bool
  relation is_output_attr : Attributes => bool
  relation is_bidir_attr : Attributes => bool
  relation ndims : Type => int
  relation get_dimension_sizes: Type => int list
  relation type_of_value: (Values.Value) => Type

  relation values_to_mods: (Values.Value list,string list) => Mod
  relation values_to_vars:(Values.Value list,Exp.Ident list) => Var list
	  
  relation prop_any_const : Properties => Const
  relation prop_all_const : Properties => Const
  relation get_prop_type : Properties => Type
  relation is_prop_array : Properties => bool

  relation const_and: (Const, Const) => Const
  relation const_or: (Const, Const) => Const
  relation bool_const: (bool) => Const

  relation elab_type : Type => Exp.Type
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation match_type_list : (Exp.Exp, Type list, Type list) => (Exp.Exp, Type list) 
  relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list 
  relation match_with_promote : (Properties, Properties, bool (* Allow Integer => Real *)) => Properties 

  relation flatten_array_type : Type => (Type, int list)

  relation flow_variables: (Var list, Exp.ComponentRef) => Exp.ComponentRef list

  relation get_all_exps : Type => Exp.Exp list

  relation integer_or_real: Type => () 
  relation simple_type: Type => () 
  relation discrete_type: Type => () 
end


with "Dump.rml"
with "Debug.rml"
with "Print.rml"
with "Util.rml"
with "Static.rml"

(** relation: discrete_type
 ** author: PA
 ** 
 ** Succeeds for all the discrete types, Integer, String, Boolean and 
 ** enumeration.
 **)
relation discrete_type: Type => () = 

  axiom	discrete_type((T_INTEGER(_),_)) => ()
  axiom	discrete_type((T_STRING(_),_)) => ()
  axiom	discrete_type((T_BOOL(_),_)) => ()
  axiom	discrete_type((T_ENUMERATION(_,_),_)) => ()
end

(** relation: simple_type
 ** author: PA
 ** 
 ** Succeeds for all the builtin types, Integer, String, Real, Boolean
 **)
relation simple_type: Type => () = 

  axiom	simple_type((T_REAL(_),_)) => ()
  axiom	simple_type((T_INTEGER(_),_)) => ()
  axiom	simple_type((T_STRING(_),_)) => ()
  axiom	simple_type((T_BOOL(_),_)) => ()
end

(** relation: integer_or_real 
 ** author: PA
 ** 
 ** Succeeds for the builtin types Integer and Real.
 **)
relation integer_or_real: Type => () =

  axiom	integer_or_real((T_REAL(_),_)) => ()
  axiom	integer_or_real((T_INTEGER(_),_)) => ()
end

(** relation: is_array
 **
 ** Returns true if Type is an array.
 **)

relation is_array : Type => bool =

  axiom	is_array((T_ARRAY(_,_),_)) => true
  axiom	is_array((_,_)) => false

end

(** relation: is_string
 **
 ** Return true if Type is the builtin String type.
 **)

relation is_string : Type => bool =

  axiom	is_string ((T_STRING(_),_)) => true
  axiom	is_string ((_,_)) => false

end

(** relation: is_array_or_string
 **
 ** Return true if Type is array or the builtin String type.
 **)

relation is_array_or_string : Type => bool =

  rule	is_array ty => true
	-------------------
	is_array_or_string ty => true

  rule	is_string ty => true
	-------------------
	is_array_or_string ty => true

  rule -----------------	is_array_or_string _ => false

end

(** relation: ndims
 **
 ** Return the number of dimensions of a Type.
 **)

relation ndims : Type => int =

  rule	ndims t => n &
	int_add(n,1) => n'
	---
	ndims( (T_ARRAY(_,t),_) ) => n'

  axiom ndims( (_,_) ) => 0
end

(** relation: dimensions_known
 **
 ** Returns true of the dimensions of the type is known.
 **)

relation dimensions_known: Type => bool =
	
  rule	get_dimension_sizes(tp) => []
	-----------------------
	dimensions_known(tp) => false

  rule	get_dimension_sizes(tp) => _
	-----------------------
	dimensions_known(tp) => true
end

(** relation: strip_submod
 ** author: PA
 ** 
 ** Removes the sub modifiers of a modifier.
 **)

relation strip_submod: Mod => Mod =

  axiom	strip_submod(MOD(f,subs,eq)) => MOD(f,[],eq)

  axiom	strip_submod(m) => m

end

(** relation: get_dimension_sizes
 ** 
 ** Return the dimension sizes of a Type.
 **)

relation get_dimension_sizes: Type => int list =

  rule	get_dimension_sizes(tp) => res
	----------------
	get_dimension_sizes((T_ARRAY(DIM(SOME(i)),tp),_)) => i::res

  axiom	get_dimension_sizes((_,_)) => []

end

(** relation: values_to_mods
 ** author: PA
 **
 ** This relation takes a list of values and convert into a Modification.
 **  Used for record construction evaluation. PersonRecord("name",45) has a value list 
 ** { "name",45 } that needs to be converted into a modifier for the record class
 **  PersonRecord ("name,45)
 **  FIXME: How about other value types, e.g. array, enum etc 
**)

relation values_to_mods: (Values.Value list,Ident list) => Mod =

  axiom	values_to_mods([],_) => MOD(false,[],NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.INTEGER(i)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.ICONST(i),SOME(Values.INTEGER(i)),PROP((T_INTEGER([]),NONE),C_VAR)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.REAL(r)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.RCONST(r),SOME(Values.REAL(r)),PROP((T_REAL([]),NONE),C_VAR)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.STRING(s)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.SCONST(s),SOME(Values.STRING(s)),PROP((T_STRING([]),NONE),C_VAR)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.BOOL(b)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.BCONST(b),SOME(Values.BOOL(b)),PROP((T_BOOL([]),NONE),C_VAR)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_) &
	values_to_record_constructor_call(cname,vals) => rec_call &
	values_to_vars(vals,val_names) => varlst &
	Absyn.path_string(cname) => cname_str 
	----------------------------------------
	values_to_mods(Values.RECORD(cname,vals,val_names)::rest,id::ids)
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(rec_call,
							  SOME(Values.RECORD(cname,vals,val_names)),
							  PROP((T_COMPLEX(ClassInf.RECORD(cname_str),varlst),NONE),C_VAR)))))::res,NONE)

  rule	Debug.fprint("failtrace","-values_to_mods failed for value: ") &
	Values.val_string(v) => vs & 
	Debug.fprint("failtrace",vs) &
	Debug.fprint("failtrace","\n")
	--------------------------
	values_to_mods(v::_,_) => fail
end

(** relation: values_to_record_constructor_call
 ** 
 ** This relation transforms a list of values and an Absyn.Path to a function call
 ** to a record constructor.
 **)

relation values_to_record_constructor_call:(Absyn.Path, Values.Value list) 
	  => Exp.Exp =

  rule	Util.list_map(values,Static.value_exp) => expl 
	----------------------------------------------
	values_to_record_constructor_call(funcname,values) 
	  => Exp.CALL(funcname,expl,false,false)
end

(** relation values_to_vars
 ** 
 ** Translates a list of Values.Value to a Var list, using a list
 ** of identifiers as component names.
 ** Used e.g. when retrieving the type of a record value.
 **)

relation values_to_vars:(Values.Value list,Exp.Ident list) => Var list =
	
  axiom	values_to_vars([],[]) => []

  rule	type_of_value(v) => tp &
	values_to_vars(vs,ids) => rest
	------------------------
	values_to_vars(v::vs,id::ids) 
	  => VAR(id,ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),false,tp,UNBOUND)::rest

  rule	Debug.fprint("failtrace","-values_to_vars failed\n") 
	-------------------------
	values_to_vars(_,_) => fail
end
	
(** relation: type_of_value
 ** author: PA
 **
 ** Returns the type of a Values.Value.
 ** Some information is lost in the translation, like attributes
 ** of the builtin type.
 **)
relation type_of_value: (Values.Value) => Type =

  axiom	type_of_value(Values.INTEGER(_)) => ((T_INTEGER([]),NONE))
  axiom	type_of_value(Values.REAL(_)) => ((T_REAL([]),NONE))
  axiom	type_of_value(Values.STRING(_)) => ((T_STRING([]),NONE))
  axiom	type_of_value(Values.BOOL(_)) => ((T_BOOL([]),NONE))

  axiom	type_of_value (Values.ENUM(_)) => ((T_ENUM,NONE))

  rule	type_of_value(v) => tp &
	list_length(v::vs) => dim1 
	--------------------
	type_of_value(w as Values.ARRAY(v::vs)) => ((T_ARRAY(DIM(SOME(dim1)),tp),NONE))

  rule	Util.list_map(vs, type_of_value) => ts
	--------------------------------------
	type_of_value(w as Values.TUPLE(vs)) => ((T_TUPLE(ts),NONE))

  rule	values_to_vars (vl, ids) => vars &
	Absyn.path_string(cname) => cname_str
	---------------------------------------
	type_of_value Values.RECORD(cname,vl,ids) => ((T_COMPLEX(ClassInf.RECORD(cname_str),vars),NONE))

  rule	Debug.fprint("failtrace","-type_of_values failed: ") &
	Values.val_string v => vs &
	Debug.fprintln("failtrace", vs)
	----------------------------------------------------
	type_of_value(v) => fail

end


(** relation: basic_type
 **
 ** Test whether a type is one of the builtin types.
 **)

relation basic_type : Type => bool =

  axiom	basic_type( (T_INTEGER(_),_) ) => true
  axiom	basic_type( (T_REAL(_),_) ) => true
  axiom	basic_type( (T_STRING(_),_) ) => true
  axiom	basic_type( (T_BOOL(_),_) ) => true
  axiom	basic_type( (T_ENUM,_) ) => true
  axiom	basic_type( (T_ARRAY(_,_),_) ) => false
  axiom	basic_type( (T_COMPLEX(_,_),_) ) => false
  axiom	basic_type( (T_ENUMERATION(_,_),_) ) => false
end

(** relation: equivtypes
 **
 ** This is the type equivalence relation.  It is defined in terms of
 ** the subtype relation.  Two types are considered equivalent if they
 ** are subtypes of each other.
 **)

relation equivtypes : (Type, Type) => bool =

  rule	subtype(t1, t2) => true &
	subtype(t2, t1) => true
	-----------------------
	equivtypes(t1, t2) => true

	(* default *)
  axiom	equivtypes(t1, t2) => false

end

(** relation: subtype
 **
 ** Is the first type a subtype of the second type?  This relation
 ** specifies the rules for subtyping in Modelica.
 **)

relation subtype : (Type, Type) => bool =
	
  axiom	subtype ( (T_INTEGER(_),_),(T_INTEGER(_),_)) => true
  axiom	subtype ((T_REAL(_),_),(T_REAL(_),_))       => true
  axiom	subtype ((T_STRING(_),_),(T_STRING(_),_))   => true
  axiom	subtype ((T_BOOL(_),_),(T_BOOL(_),_))       => true
  axiom	subtype ((T_ENUM,_),(T_ENUM,_))	      => true

  rule	l2 = l1 &
	subtype((T_ENUMERATION(rest1,vl1),p1),(T_ENUMERATION(rest2,vl2),p2))=> res
	----------------------------------------------------------
	subtype ((T_ENUMERATION(l1::rest1,vl1),p1),(T_ENUMERATION(l2::rest2,vl2),p2))
	  => res

  axiom	subtype ((T_ENUMERATION([],_),_),(T_ENUMERATION(_,_),_))=> true
	
  rule	 subtype (t1,t2) => true
	-----------------------
	subtype((T_ARRAY(_,t1),_),(T_ARRAY(DIM(NONE),t2),_)) => true
	    
  rule  subtype (t1,t2) => true
	-----------------------
	subtype((T_ARRAY(DIM(NONE),t1),_),(T_ARRAY(_,t2),_)) => true
	    
  rule  i1 = i2 &
 	subtype (t1,t2) => true
	---------------------------------------------------------
	subtype((T_ARRAY(DIM(SOME(i1)),t1),_),(T_ARRAY(DIM(SOME(i2)),t2),_)) => true
	
  rule	subtype_varlist(els1, els2) => true
	-----------------------------------
	subtype((T_COMPLEX(st1,els1),_), (T_COMPLEX(st2,els2),_)) => true
        
	(* PR. Check of tuples, similar to complex. Just that
	     identifier name do not have to be checked. Only types are
	 checked. *)
  rule	subtype_typelist(type_list1,type_list2) => true
	-----------------------------------
	subtype((T_TUPLE(type_list1),_), (T_TUPLE(type_list2),_)) => true

  axiom subtype(t1,t2) => false

(* What? If not subtye should return false. Doesn't mean no matching rule

  rule	Debug.fprint ("tytr", "subtype: no matching subtype rule.\n") &
	Debug.fcall ("tytr", print_type, t1) &
	Debug.fprint ("tytr", " <> ") &
	Debug.fcall ("tytr", print_type, t2) &
	Debug.fprint ("tytr", "\n")
	-----------------------------------
	subtype(t1,t2) => false
*)

end


(** PR. relation: subtype_typelist
 **
 ** This relation checks if the both `Type' lists matches types, element
 ** by element.
 **)

relation subtype_typelist: (Type list,Type list) => bool =

  axiom	subtype_typelist ([], []) => true

  rule	subtype(t1,t2) => true &
	subtype_typelist(rest1,rest2) => true		
	-----------------------------
	subtype_typelist(t1::rest1,t2::rest2) => true

	(* default *)
  axiom	subtype_typelist(_,_) => false


end

(** relation: subtype_varlist
 **
 ** This relation checks if the `Var' list in the first list is a
 ** subset of the list in the second argument.  More precisely, it
 ** checks if, for each `Var' in the second list there is a `Var' in
 ** the first list with a type that is a subtype of the `Var' in the
 ** second list.
 **)

relation subtype_varlist : (Var list, Var list) => bool =

  axiom	subtype_varlist(_, []) => true

  rule	varlist_lookup(l,n) => VAR(_,_,_,t1,_) &
	subtype(t1,t2) => true &
	subtype_varlist(l,vs) => true
	-----------------------------
	subtype_varlist(l, VAR(n,_,_,t2,_)::vs) => true

	(* default *)
  axiom	subtype_varlist(_,_) => false

end

(** relation: varlist_lookup
 **
 ** Given a list of `Var' and a name, this relation finds any `Var'
 ** with the given name.
 **)

relation varlist_lookup : (Var list, Ident) => Var =

  rule	n = name
	--------
	varlist_lookup((v as VAR(n,_,_,_,_))::_, name) => v

  rule	varlist_lookup(vs, name) => v
	-----------------------------
	varlist_lookup(v::vs, name) => v

end

(** relation: lookup_component
 **
 ** This relation finds a subcomponent by name.
 **)

relation lookup_component : (Type, Ident) => Var =
	
  rule	basic_type(t) => true &
	lookup_in_builtin(t,n) => v
	-------------------------
	lookup_component(t,n) => v

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component((T_COMPLEX(st,cs),_), id) => v

  rule	lookup_component2(cs,id) => VAR(n,attr,prot,ty,bnd) &
	let ty' = ((T_ARRAY(dim,ty),NONE))
	-----------------------------
	lookup_component((T_ARRAY(dim,(T_COMPLEX(st,cs),_)),_), id) 
	  => VAR(n,attr,prot,ty',bnd)

  rule	(*Print.print_buf "- Looking up " &
	Print.print_buf id &
	Print.print_buf " in noncomplex type\n"*)
	-----------------------------------------
	lookup_component(_, id) => fail

end

(** relation: lookup_in_builtin
 **
 ** Since builtin types are not represented as T_COMPLEX, special care
 ** is needed to be able to lookup the attributes (`start' etc) in
 ** them.
 **
 ** This is not a complete solution.  The current way of mapping the
 ** both the Modelica type `Real' and the simple type `RealType' to
 ** `T_REAL' is a bit problematic, since it doesn't make a
 ** difference between `Real' and `RealType', which makes the
 ** translator accept things like `x.start.start.start'.
 **)

relation lookup_in_builtin : (Type,Ident) => Var =

	(* Real *)	
  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_REAL(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_INTEGER(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_STRING(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_BOOL(cs),_),id) => v

(*	
  axiom	lookup_in_builtin(T_REAL,"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"unit")
	  => VAR("unit",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"displayUnit")
	  => VAR("displayUnit",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, VALBOUND(Values.REAL(0.0)))

  axiom	lookup_in_builtin(T_REAL,"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_BOOL, UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_REAL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

  axiom	lookup_in_builtin((T_REAL(_),_),"nominal")
	  => VAR("nominal",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_REAL([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_REAL(_),_),"stateSelect")
	  => VAR("stateSelect",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUMERATION(["never","avoid","default","prefer","always"]),NONE),
		 VALBOUND(Values.ENUM("default")))
		 (* optimized away looking up the builtin enumeration type 'stateSelect' *)

	(* Integer *)
  axiom	lookup_in_builtin((T_INTEGER(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_INTEGER(_),_),"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_INTEGER([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_INTEGER(_),_),"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_INTEGER([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_INTEGER(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_REAL([]),NONE), VALBOUND(Values.INTEGER(0)))

  axiom	lookup_in_builtin((T_INTEGER(_),_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_INTEGER(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

	(* Boolean *)
  axiom	lookup_in_builtin((T_BOOL(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(false)))

  axiom	lookup_in_builtin((T_BOOL(_),_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_BOOL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

	(* String *)
  axiom	lookup_in_builtin((T_BOOL(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))
*)
	(* Enumeration ( type E in spec) *)
  axiom	lookup_in_builtin((T_ENUM,_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE),VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_ENUM,_),"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUM,NONE), UNBOUND) (* Should be bound to the first element of
					  T_ENUMERATION list higher up in the call chain *)
  axiom	lookup_in_builtin((T_ENUM,_),"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUM,NONE), UNBOUND) (* Should be bound to the last element of 
					  T_ENUMERATION list higher up in the call chain *)
  axiom	lookup_in_builtin((T_ENUM,_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Should be bound to the last element of 
					  T_ENUMERATION list higher up in the call chain *)

  axiom	lookup_in_builtin((T_ENUM,_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_ENUM,_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))		 
end

(** relation: lookup_component2
 **
 ** This relation finds a named `Var' in a list of `Var's, comparing
 ** the name against the second argument to this relation.
 **)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as VAR(n,_,_,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: make_array
 **  This relation makes an array type given a Type and an Absyn.ArrayDim
 **)
relation make_array: (Type, Absyn.ArrayDim) => Type =
  axiom	 make_array(t,[]) => t

  rule	list_length(l) => len
	--------------------
	make_array(t,l) => ((T_ARRAY(DIM(SOME(len)),t),NONE))
end

(** relation: lift_array
 **
 ** This relation turns a type into an array of that type.  If the
 ** type already is an array, aonther dimension is simply added.
 **)

relation lift_array : (Type,int option) => Type =

  rule	(*print("\nDebug: lifts the array.") 
*)	-------------------
	lift_array (ty,i) => ((T_ARRAY(DIM(i),ty),NONE))
(* PR  axiom	lift_array (ty,i) => T_ARRAY(DIM(i),ty) *)

end

(** relation: unlift_array
 **
 ** This relation turns an array of a type into that type.
 **)

relation unlift_array : Type => Type =

  axiom	unlift_array((T_ARRAY(DIM(_),ty),_)) => ty

end

(** relation: array_element_type
 **
 ** This relation turns an array into the element type
 ** of the array.
 **)

relation array_element_type : Type => Type =

  rule	array_element_type(ty) => ty'
	------------------------------
	array_element_type( (T_ARRAY(DIM(_),ty),_)) => ty'

  axiom	array_element_type t => t

end

(** relation: unparse_type
 **
 ** This relation prints a Modelica type as a piece of Modelica code.
**)
relation unparse_type: Type => string =

  axiom	unparse_type((T_INTEGER(_),_)) =>  "Integer"
  axiom	unparse_type((T_REAL(_),_)) =>  "Real"
  axiom	unparse_type((T_STRING(_),_)) =>  "String"
  axiom	unparse_type((T_BOOL(_),_)) =>  "Boolean"

  rule	Util.string_delimit_list(l,",") => s1 &
	Util.string_append_list(["enumeration(",s1,")"]) => str
	-----------------
	unparse_type((T_ENUMERATION(l,_),_)) =>  str

  rule  flatten_array_type t => (ty, dimlst) &
	Util.list_map(dimlst,int_string) => dimlststr &
	list_reverse(dimlststr) => dimlststr' &
	unparse_type ty => tys &
	Util.string_delimit_list(dimlststr',", ") => dims &
	Util.string_append_list([tys,"[",dims,"]"]) => res
	--------------------
	unparse_type(t as (T_ARRAY(_,_),_) ) => res

  rule	Util.list_map(vs,unparse_var) => vars &
	Util.string_append_list(vars) => vstr &
	Util.string_append_list(["record ",name,"\n",vstr,"end record;"]) => res
	---------------------------
	unparse_type((t as T_COMPLEX(ClassInf.RECORD(name),vs),_))=> res

  rule	ClassInf.get_state_name(ci_state) => res
	--------------------------------------
	unparse_type((T_COMPLEX(ci_state,vs),_)) => res

  rule  Util.list_map(params, unparse_param) => paramstrs &	
	Util.string_delimit_list(paramstrs, ", ") => paramstr &
	unparse_type restype => restypestr &
	Util.string_append_list(["/* function(", paramstr, ") => ", restypestr, "*/"]) => res 
	--------------------------------------
	unparse_type((T_FUNCTION(params,restype),_)) => res

  rule	Util.list_map(tys, unparse_type) => tystrs &
	Util.string_delimit_list(tystrs, ", ") => tystr &
	Util.string_append_list(["/* (", tystr, ") */"]) => res
	--------------------------------------------------
	unparse_type ((T_TUPLE(tys),_)) => res

  axiom	unparse_type ((T_NOTYPE,_)) => "/* #NOTYPE# */"	

  axiom	unparse_type ((T_ANYTYPE(_),_)) => "/* #ANYTYPE# */"

  axiom	unparse_type(ty) => "/* unparse_type: not implemented yet */\n"  

end	

(** relation: unparse_const
 **
 ** This relation prints a Const as a string.
 **)

relation unparse_const : Const => string =

  axiom	unparse_const C_CONST => "C_CONST"
  axiom	unparse_const C_PARAM => "C_PARAM"
  axiom	unparse_const C_VAR => "C_VAR"

end

(** relation: unparse_tupleconst
 **
 ** This relation prints a Modelica TupleConst as a string.
 **)

relation unparse_tupleconst : TupleConst => string =

  rule	unparse_const c => cstr
	--------------------------
	unparse_tupleconst CONST(c) => cstr

  rule	Util.list_map(constlist, unparse_tupleconst) => strlist &
	Util.string_delimit_list(strlist, ", ") => res &
	Util.string_append_list(["(", res, ")"]) => res'
	----------------------------------------------
	unparse_tupleconst TUPLE_CONST(constlist) => res'

end


(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `composite'.  The actual code is expluded from the report.
 **)

(*!ignorecode*)

relation print_type : Type => () =

  rule	Print.print_error_buf "Integer" 
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	---------------
	print_type((T_INTEGER(vars),_))

  rule	Print.print_error_buf "Real" 
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	------------
	print_type((T_REAL(vars),_))

  rule	Print.print_error_buf "String"
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	--------------
	print_type((T_STRING(vars),_))

  rule	Print.print_error_buf "Boolean" 
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	---------------
	print_type((T_BOOL(vars),_))

  rule	Print.print_error_buf "EnumType" 
	---------------
	print_type((T_ENUM,_))

  rule	Print.print_error_buf "enumeration((" &
	Dump.print_list(l,print, ", ") &
	Print.print_error_buf ") "  
	& Print.print_error_buf ", ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	---------------------
	print_type((T_ENUMERATION(l,vars),_))

  rule	Print.print_error_buf "composite(" &
	Print.print_error_buf ", (" &
	ClassInf.print_state(st) &
	Print.print_error_buf ", (" &
	Dump.print_list(vars, print_var, ", ") &
	Print.print_error_buf ")" 
	-----------------
	print_type((T_COMPLEX(st,vars),_))

  rule	Print.print_error_buf "array[" & print_arraydim dim & Print.print_error_buf "] of " &
	print_type t & Print.print_error_buf ")" 
	------------
	print_type((T_ARRAY(dim,t),_))

  rule	Print.print_error_buf "function(" & print_params params & Print.print_error_buf " => " &
	print_type restype &  Print.print_error_buf ")"
	------------------------------
	print_type((T_FUNCTION(params,restype),_))

  rule	Print.print_error_buf "(" & 
	Dump.print_list(tys, print_type, ", ") &
	Print.print_error_buf ")"  
	---------
	print_type((T_TUPLE(tys),_))

  rule	Print.print_error_buf "#NOTYPE#"
	----------------
	print_type((T_NOTYPE,_))

  rule	Print.print_error_buf "#T_ANYTYPE#"
	----------------
	print_type((T_ANYTYPE(_),_))

  rule	Print.print_error_buf "print_type failed!\n"
	---------------------------
	print_type( (_,_) )

end

(** relation: print_arraydim
 **
 ** Prints an ArrayDim to the Print buffer.
 **)

relation print_arraydim: ArrayDim => () =

  rule	get_arraydim_str ad => s &
	Print.print_error_buf s
	-------
	print_arraydim ad

end

(** relation: get_arraydim_str
 **
 ** Prints ArrayDim to a string.
 **)

relation get_arraydim_str: ArrayDim => string =

  axiom	get_arraydim_str DIM(NONE) => ":"

  rule	int_string i => s
	---------------------------
	get_arraydim_str DIM(SOME(i)) => s

  axiom	get_arraydim_str _ =>  "#STRANGE#"

end

(** relation: print_params
 ** 
 ** Prints function arguments to the Print buffer.
 **)

relation print_params : FuncArg list => () =

  axiom	print_params []

  rule	Print.print_error_buf n & Print.print_error_buf " :: " & print_type t
	-------------------------------------
	print_params [(n,t)]

  rule	Print.print_error_buf n & Print.print_error_buf " :: " & print_type t &
	Print.print_error_buf " * " & print_params params
	---------------------------------
	print_params ((n,t)::params)

end

(** relation: unparse_var
 **
 ** Prints a variable to a string.
 **)

relation unparse_var: Var => string =

  rule	unparse_type typ => t &
	Util.string_append_list([t," ",n,";\n"]) => res
	----------------------------
	unparse_var VAR(n, attr, prot, typ, bind) => res
end

(** relation: unparse_param
 **
 ** Prints a function argument to a string.
 **)

relation unparse_param: FuncArg => string =

  rule	unparse_type ty => tstr &
	Util.string_append_list([id, ":", tstr]) => res
	----------------------------
	unparse_param ((id, ty)) => res
end

(** relation: print_var
 ** author: LS
 **
 ** Prints a Var to the Print buffer.
 **)
relation print_var : Var => () =

  rule	print_type typ & Print.print_error_buf " " &
	Print.print_error_buf n & Print.print_error_buf " " & 
	SCode.variability_string var => vs &
	Print.print_error_buf vs & Print.print_error_buf " " &
	print_binding bind 
	-------
	print_var VAR(n, ATTR(_,_,var,_), prot, typ, bind)

end

(** relation: print_binding
 ** author: LS
 **
 ** Print a variable binding to the Print buffer.
 **)

relation print_binding : Binding => () =

  rule	Print.print_error_buf "UNBOUND"
	---------------
	print_binding UNBOUND

  rule	Print.print_error_buf "EQBOUND: " &
	Exp.print_exp exp &
	unparse_const(f) => str &
	Print.print_error_buf str 
	----------------------------------------
	print_binding EQBOUND (exp,_,f)

  rule	Print.print_error_buf "VALBOUND: " &
	Values.print_val v
	--------------------
	print_binding VALBOUND (v)

end

(** relation: pritn_binding_str
 **
 ** Print a variable binding to a string.
 **)

relation print_binding_str : Binding => string =

  axiom	print_binding_str UNBOUND => "UNBOUND" 

  rule	Exp.print_exp_str exp => str &
	unparse_const(f) => str2 &
	Util.string_append_list(["EQBOUND(", str, ",NONE ",str2, ")"]) => res
	----------------------------------------
	print_binding_str EQBOUND (exp,NONE,f) => res

  rule	Exp.print_exp_str exp => str &
	unparse_const(f) => str2 &
	Values.val_string(v) => v_str &
	Util.string_append_list(["EQBOUND(", str, ",SOME(",v_str,"), ",str2, ")"]) => res
	----------------------------------------
	print_binding_str EQBOUND (exp,SOME(v),f) => res

  rule	Values.unparse_values [v] => s &
	Util.string_append_list(["VALBOUND(",s,")"]) => res
	--------------------
	print_binding_str VALBOUND (v) => res

end

(** relation: make_function_type
 ** author: LS 
 **
 ** Creates a function type from a function name an a list of input and
 ** output variables.
 **)
	    
relation make_function_type: (Absyn.Path, Var list) => Type =

  rule	get_input_vars vl => invl &
	get_output_vars vl => outvl &
	make_fargs_list invl => fargs &
	make_return_type outvl => rettype 

(*	& Debug.fprint ("ft", " <fargs: ") & 
	Debug.fprint_list ("ft", fargs, print_farg, ", ") &
	Debug.fprint ("ft", " >") &

	Debug.fprint ("ft", " <rettype: ") & 
	Debug.fcall ("ft", print_type, rettype) &
	Debug.fprint ("ft", " >")
*)
	---------------------------------
	make_function_type(p,vl) => ((T_FUNCTION(fargs, rettype),SOME(p)))

end

(** relation: make_enumeration_type
 **
 ** Creates an enumeration type from a name and a list of variables.
 **)

relation make_enumeration_type: (Absyn.Path, Var list) => Type =

  rule	make_enumeration_type(p,xs) => ((T_ENUMERATION(strs,[]),_))
	---------------------------------
	make_enumeration_type (p,VAR(name,_,_,_,_)::xs) 
	  => ((T_ENUMERATION(name::strs,[]),SOME(p)))

  axiom	make_enumeration_type(p,[]) => ((T_ENUMERATION([],[]),SOME(p)))
end

(** relation: print_farg
 **
 ** Prints a function argument to the Print buffer.
 **)

relation print_farg: FuncArg => () =

  rule	print_type ty & Print.print_error_buf " " & Print.print_error_buf n
	-----------------------------------
	print_farg ((n,ty))

end

(** relation: get_input_vars
 ** author: LS
 ** 
 ** Retrieve all the input variables from a list of variables.
 **)

relation get_input_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_input_var) => vl'
	---------------------------------
	get_input_vars vl => vl'
end

(** relation: get_output_vars
 ** author: LS
 **
 ** Retrieve all output variables from a list of variables.
 **)

relation get_output_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_output_var) => vl'
	---------------------------------
	get_output_vars vl => vl'
end

(** relation: get_classname
 **
 ** Return the classname from a type.
 **)

relation get_classname: (Type) => Absyn.Path =

  axiom	get_classname((_,SOME(p))) => p

end

(** relation get_vars
 ** author: LS 
 ** 
 ** Select the variables from the list for which the condition relation given
 ** as second argument succeeds.
 **)
relation get_vars: (Var list, Var => () )  => Var list =

  axiom	get_vars ([],_) => []

  rule	cond(v) &
	get_vars (vl, cond) => vl'
	-------------------
	get_vars (v::vl, cond) => v::vl'

  rule	not cond(v) &
	get_vars (vl, cond) => vl'
	--------------------------
	get_vars (v::vl, cond) => vl'

end	


(** relation: is_input_var
 ** author: LS
 ** 
 ** Succeds if variable is an input variable.
**)

relation is_input_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  rule	is_input_attr attr => true
	--------------------------
	is_input_var VAR(n, attr, false, ty, bnd)

end

(** relation: is_output_var
 ** author: LS
 ** 
 ** Succeds if variable is an output variable.
**)

relation is_output_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  rule	is_output_attr attr => true
	---------------------------
	is_output_var VAR(n, attr, false, ty, bnd)

end

(** relation: is_input_attr
 ** 
 ** Returns true if the Attributes of a variable indicates
 ** that the variable is input.
 **)

relation is_input_attr : Attributes => bool =

  axiom	is_input_attr ATTR(_,_,_,Absyn.INPUT) => true

end

(** relation: is_output_attr
 ** 
 ** Returns true if the Attributes of a variable indicates
 ** that the variable is output.
 **)

relation is_output_attr : Attributes => bool =

  axiom	is_output_attr ATTR(_,_,_,Absyn.OUTPUT) => true

end

(** relation: is_bidir_attr
 **
 ** Returns true if the Attributes of a variable indicates that the variable
 ** is bidirectional, i.e. neither input nor output.
 **)
 

relation is_bidir_attr : Attributes => bool =

  axiom	is_bidir_attr ATTR(_,_,_,Absyn.BIDIR) => true

end

(** relation: make_fargs_list
 ** author: LS 
 **
 ** Makes a function argument list from a list of variables.
 **)
relation make_fargs_list: Var list => FuncArg list =

  axiom	make_fargs_list [] => []

  rule	(*is_input_var v &*)
	make_fargs_list vl => fargl
	------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd) :: vl) => ((n,ty)::fargl)

  rule	Print.print_error_buf "#-- Not an input var:" & Print.print_error_buf n
	---------------------------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd)::vl) => fail

end

(** relation: make_return_type
 ** author: LS 
 **
 ** Create a return type from a list of output variables.
 ** Depending on the length of the output variable list, different 
 ** kinds of return types are created.
 **) 

relation make_return_type: Var list => Type =

  axiom	make_return_type [] => ((T_NOTYPE,NONE))

  rule	make_return_type_single var => ty
	---------------------------------
	make_return_type [var] => ty

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type vl => ((T_TUPLE(tys),NONE))

end

(** relation: make_return_type_single
 ** author: LS 
 **
 ** Create the return type for a single return value.
 **)

relation make_return_type_single: Var => Type =

  axiom	make_return_type_single VAR(n,attr,pr,ty,bnd) => ty

end

(** relation: make_return_type_tuple
 ** author: LS
 **
 ** Create the return type for a tuple, i.e. a function returning several
 ** values.
 **)

relation make_return_type_tuple: (Var list) => Type list =

  axiom	make_return_type_tuple [] => []

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type_tuple VAR(n,attr,pr,ty,bnd)::vl => ty::tys

end

(** relation: is_parameter
 ** author: LS 
 **
 ** Succeds if a variable is a parameter.
 **)

relation is_parameter: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_parameter VAR(n, ATTR(fl, ac, SCode.PARAM, dir), false, ty, bnd)

end

(** relation: contain_real
 ** 
 ** Returns true if a buitlin type, or array-type is Real.
 **)

relation contain_real: Type list => bool =

  rule	contain_real([tp]) => r1 &
	contain_real(xs) => r2 &
	bool_or(r1,r2) => res 
	---------------
	contain_real ((T_ARRAY(d,tp),_)::xs) => res 

  axiom	contain_real ((T_REAL(_),_)::_) => true

  rule	contain_real(xs) => res
	--------------
	contain_real(_::xs) => res

  axiom	contain_real(_)=> false
end

(** relation: flatten_array_type
 **
 ** Returns the element type of a Type and the list of dimensions of the type.
 **)

relation flatten_array_type : Type => (Type, int list) =

  rule	flatten_array_type ty => (ty', dimlist')
	--------------------------------------
  	flatten_array_type((T_ARRAY(DIM(NONE),ty), _)) => (ty', dimlist')

  rule	flatten_array_type ty => (ty', dimlist) &
	list_append (dimlist,[dim]) => dimlist'
	--------------------------------------
  	flatten_array_type((T_ARRAY(DIM(SOME(dim)), ty),_)) => (ty', dimlist')

  axiom	flatten_array_type ty => (ty, [])

end

(** relation: get_type_name
 **
 ** Return the type name of a Type.
 **)

relation get_type_name: Type => string =

  axiom	get_type_name((T_INTEGER(_),_))=> "Integer"
  axiom	get_type_name((T_REAL(_),_))	=> "Real"
  axiom	get_type_name((T_STRING(_),_))=> "String"
  axiom	get_type_name((T_BOOL(_),_))	=> "Boolean"

  rule	ClassInf.get_state_name st => n
	-------------------------------
	get_type_name((T_COMPLEX(st, _),_)) => n

  rule	flatten_array_type arrayty => (ty, dims) &
	Util.list_map(dims, int_string) => dimstrs &
	Util.string_delimit_list(dimstrs,", ") => dimstr &
	get_type_name ty => tystr &
	Util.string_append_list([tystr,"[",dimstr,"]"]) => str
	------------------------------------------------------
	get_type_name(arrayty as (T_ARRAY(_,_),_) ) => str

  axiom	get_type_name( (_,_)) => "Not nameable type or no type"


end

(** relation: prop_all_const
 ** author: LS
 ** 
 ** If PROP_TUPLE, returns true if all of the flags are constant.
 **)

relation prop_all_const: Properties => Const =

  axiom	prop_all_const PROP(_,c) => c

  rule	prop_tuple_all_const constant => res
	-----------------------------------
	prop_all_const PROP_TUPLE(_,constant) => res

  rule	Debug.fprint("failtrace", "- prop_all_const failed: ") &
	print_prop_str prop => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	prop_all_const prop => fail
end

(** relation: prop_any_const
 ** author: LS
 ** 
 ** If PROP_TUPLE, returns true if any of the flags are true 
 **)

relation prop_any_const: Properties => Const =

  axiom	prop_any_const PROP(_,constant) => constant

  rule	prop_tuple_any_const constant => res
	-----------------------------------
	prop_any_const PROP_TUPLE(_,constant) => res

  rule	Debug.fprint("failtrace", "- prop_any_const failed: ") &
	print_prop_str prop => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	prop_any_const prop => fail
end

(** relation: prop_tuple_any_const
 ** author: LS
 ** 
 ** Helper relation to prop_any_const.
 **)
relation prop_tuple_any_const: TupleConst => Const =

  axiom	prop_tuple_any_const CONST(c) => c

  rule	prop_tuple_any_const first => C_CONST
	---------------------------------
	prop_tuple_any_const TUPLE_CONST(first::rest) => C_CONST

  rule	prop_tuple_any_const first => C_PARAM
	--------------------------------------------
	prop_tuple_any_const TUPLE_CONST(first::[]) => C_PARAM

  rule	prop_tuple_any_const first => C_VAR
	--------------------------------------------
	prop_tuple_any_const TUPLE_CONST(first::[]) => C_VAR

  rule	prop_tuple_any_const first => C_PARAM &
	prop_tuple_any_const TUPLE_CONST(rest) => res
	--------------------------------------------
	prop_tuple_any_const TUPLE_CONST(first::rest) => res

  rule	prop_tuple_any_const first => C_VAR &
	prop_tuple_any_const TUPLE_CONST(rest) => res
	--------------------------------------------
	prop_tuple_any_const TUPLE_CONST(first::rest) => res

  rule	Debug.fprint("failtrace", "- prop_tuple_any_const failed: ") &
	unparse_tupleconst const => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	prop_tuple_any_const const => fail
end

(** relation: prop_tuple_all_const
 ** author: LS 
 **
 ** Helper relation to prop_all_const.
 **)

relation prop_tuple_all_const: TupleConst => Const =

  axiom	prop_tuple_all_const CONST(c) => c

  rule	prop_tuple_all_const first => C_PARAM
	---------------------------------
	prop_tuple_all_const TUPLE_CONST(first::rest) => C_PARAM

  rule	prop_tuple_all_const first => C_VAR
	---------------------------------
	prop_tuple_all_const TUPLE_CONST(first::rest) => C_VAR

  rule	prop_tuple_all_const first => C_CONST
	--------------------------------------------
	prop_tuple_all_const TUPLE_CONST(first::[]) => C_CONST

  rule	prop_tuple_all_const first => C_CONST &
	prop_tuple_all_const TUPLE_CONST(rest) => res
	--------------------------------------------
	prop_tuple_all_const TUPLE_CONST(first::rest) => res

  rule	Debug.fprint("failtrace", "- prop_tuple_all_const failed: ") &
	unparse_tupleconst const => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	prop_tuple_all_const const => fail

end

(** relation: is_prop_array
 **
 ** Return true if properties contain an array type.
 **)

relation is_prop_array : Properties => bool =

  rule	get_prop_type p => t &
	is_array t => b
	----------------------
	is_prop_array p => b

end

(** relation: get_prop_type
 ** author: LS
 **
 ** Return the Type from Properties.
 **)

relation get_prop_type: Properties => Type = 

  axiom	get_prop_type PROP(ty,_) => ty
  axiom	get_prop_type PROP_TUPLE(ty,_) => ty

end


relation elab_type : Type => Exp.Type =

  axiom	elab_type((T_INTEGER(_),_)) => Exp.INT
  axiom	elab_type((T_REAL(_),_)) => Exp.REAL
  axiom	elab_type((T_BOOL(_),_)) => Exp.BOOL
  axiom	elab_type((T_STRING(_),_)) => Exp.STRING
  axiom elab_type((T_ENUM,_)) => Exp.ENUM

  rule	array_element_type t => et &
	elab_type et => t'
	----------------
	elab_type(t as (T_ARRAY(_,_),_)) => t'

  axiom	elab_type((_,_)) => Exp.OTHER

end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	Debug.print "Debug: match prop." &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

  rule	Debug.print "\nDebug: match prop (PROP TUPLE). " &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP_TUPLE(gt,_), PROP_TUPLE(et,_)) => e'

end


(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) =

  rule	subtype(e_type, expected_type) => true 
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e, e_type)

  rule	subtype(e_type, expected_type) => false &
	(*Debug.fprint("sei", "trying type convert\n") &*)
	type_convert(e, e_type, expected_type) => (e',e_type') 
	(*& Debug.fprint("sei", "Type convert succeded\n") *)
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e',e_type')
end

(** relation: match_type_list
 **
 ** This relation matches a list of types, with a list of other types.
 ** Type conversion is disredaded, but an expression is given 
 ** (the rhs of a tuple assignment) if such conversions should be implemented
 **)

relation match_type_list : (Exp.Exp, Type list, Type list ) 
	  => (Exp.Exp, Type list) =

  axiom	match_type_list(e,[],[]) => (e,[])

  rule	match_type(e,t1,t2) => (e',tp) &
	match_type_list(e',ts1,ts2) => (e'',res) 
	--------------------------------------
	match_type_list(e, t1::ts1, t2::ts2) => (e',tp::res)

  rule	Debug.fprint("failtrace","- match_type_list failed\n") 
	-----------------------------------------------------
	match_type_list(e, t1::ts1, t2::ts2) => fail
end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) =
	    
  rule	(* Array expressions *)
	int_eq (dim1, dim2) => true &
	type_convert_array (elist, ty1, ty2) => elist' &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	  => (Exp.ARRAY(at,a,elist'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	(* Range expressions *)
	int_eq (dim1, dim2) => true &
	type_convert(begin,ty1,ty2) => (begin',_) &
	type_convert(step,ty1,ty2) => (step',_) &
	type_convert(stop,ty1,ty2) => (stop',_) &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.RANGE(t,begin,SOME(step),stop), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	    => (Exp.RANGE(at,begin',SOME(step'),stop'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	(* Range expressions *)
	int_eq (dim1, dim2) => true &
	type_convert(begin,ty1,ty2) => (begin',_) &
	type_convert(stop,ty1,ty2) => (stop',_) &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.RANGE(t,begin,NONE,stop), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	    => (Exp.RANGE(at,begin',NONE,stop'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	(* Matrix expressions *)
	int_eq (dim1, dim2) => true &
	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     (T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t1),_)),_), 
		     (T_ARRAY(DIM(SOME(dim2)), (T_ARRAY(DIM(SOME(dim22)),t2),p1)),p2))
	    => (Exp.MATRIX(at,nmax,ell'),(T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t2),p1)),p2))
	    
  rule	(* Matrix expressions *)
	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     (T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t1),_)),_), 
		     (T_ARRAY(DIM(NONE), (T_ARRAY(DIM(SOME(dim22)),t2),p1)),p2))
	    => (Exp.MATRIX(at,nmax,ell'),(T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t2),p1)),p2))

  rule	(* Array expressions *)
	(* This rule is used to ensure that casts are made on each *)
	(* element, instead of on the whole array *)
	type_convert_array (elist, ty1, ty2) => (elist') &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(NONE), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
	  => (Exp.ARRAY(at,a,elist'), (T_ARRAY(DIM(NONE), ty2),p2))

	    
  rule	(* Array expressions *)
	(* This rule is used to ensure that casts are made on each *)
	(* element, instead of on the whole array *)
	type_convert_array (elist, ty1, ty2) => (elist') &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (Exp.ARRAY(at,a,elist'), (T_ARRAY(DIM(SOME(dim1)), ty2),p2))

  rule	(* Arbitrary expressions, 
	 * first dimension [dim1], 
	 * second dimension [dim2] *)
	int_eq(dim1,dim2) => true &
	type_convert (e, ty1, ty2) => (e',t') 
 	------------------------------------------
 	type_convert(e, 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
 	  => (e', (T_ARRAY(DIM(SOME(dim2)), t'),p2))

  rule	(* Arbitrary expressions, 
	 * first dimension [:], 
	 * second dimension [dim2] *)
	type_convert (e, ty1, ty2) => (e',t') 
 	------------------------------------------
 	type_convert(e, 
		     (T_ARRAY(DIM(NONE), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
 	  => (e', (T_ARRAY(DIM(NONE), t'),p2))

  rule	(* Arbitrary expressions 
	 * first dimension [:]
	 * second dimension [:]
	 *)
	type_convert (e, ty1, ty2) => (e',t') 
	--------------------
	type_convert(e,
		     (T_ARRAY(DIM(NONE), ty1),_), 
 		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (e', (T_ARRAY(DIM(NONE), t'),p2))
	    
  rule	(* Arbitrary expression 
	 * first dimension [dim1]
	 * second dimension [:]
	 *)
	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (e', (T_ARRAY(DIM(SOME(dim1)), t'),p2))

  rule	type_convert_list (elist, tys1, tys2) => (elist',tys')
	------------------------------------------
	type_convert(Exp.TUPLE(elist), 
		     (T_TUPLE(tys1),_), 
		     (T_TUPLE(tys2),p2))
	  => (Exp.TUPLE(elist'), (T_TUPLE(tys'),p2))

  axiom	type_convert(exp, 
	    (T_ENUM,_),
	    (T_ENUMERATION(l,v),p2))
	    => (exp, (T_ENUMERATION(l,v),p2))
	    
  axiom	type_convert(e, (T_INTEGER(v),_), (T_REAL(_),p)) 
	  => (Exp.CAST(Exp.REAL,e),(T_REAL(v),p))

  rule	Debug.fprint("tcvt","- type conversion failed: ") &
	Debug.fcall ("tcvt",print_type,t1) & 
	Debug.fprint("tcvt",", ") & 
	Debug.fcall ("tcvt",print_type,t2) &
	Debug.fprint("tcvt","\n")
	-------------------------------
	type_convert (_,t1,t2) => fail 
end

(** relation: type_convert_array
 **
 ** Helper relation to type_convert. Handles array expressions.
 **)

relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list =

  axiom type_convert_array ([], _, _) => []

  rule	type_convert_array (rest, ty1, ty2) => rest' &
	type_convert (first, ty1, ty2) => (first',_)
	-------------------------------------------
	type_convert_array (first::rest, ty1, ty2) => first'::rest'

(*  rule	Print.print_error_buf "- type conversion of array failed exp=" &
	Exp.print_exp e &
	Print.print_error_buf "t1 = " &
	print_type t1 & 
	Print.print_error_buf " t2 = " &
	print_type t2 &
	Print.print_error_buf "\n" 
	-------------------------------
	type_convert_array (e::_,t1,t2) => fail *)

end

(** relation: type_convert_matrix
 **
 ** Helper relation to type_convert. Handles matrix expressions.
 **)

relation type_convert_matrix : ((Exp.Exp*bool) list list, Type, Type) 
	  => (Exp.Exp*bool) list list =

  axiom type_convert_matrix ([], _, _) => []

  rule	type_convert_matrix (rest, ty1, ty2) => rest' &
	type_convert_matrix_row(first,ty1,ty2) => first'
	-------------------------------------------
	type_convert_matrix (first::rest, ty1, ty2) => first'::rest'

(*  rule	Print.print_error_buf "- type conversion of matrix failed" &
	Print.print_error_buf "t1 = " &
	print_type t1 & 
	Print.print_error_buf " t2 = " &
	print_type t2 &
	Print.print_error_buf "\n" 
	-------------------------------
	type_convert_matrix (e::_,t1,t2) => fail *)

end

(** relation: type_convert_matrix_row
 **
 ** Helper relation to type_convert_matrix.
 **)

relation type_convert_matrix_row: ((Exp.Exp*bool) list , Type, Type) 
	    => ( Exp.Exp * bool) list =
  axiom type_convert_matrix_row ([],_,_) => []

  rule	type_convert_matrix_row(rest,t1,t2) => rest &
	type_convert(exp,t1,t2) => (exp',newt) &
	is_array t2 => a
	---------------------------------
	type_convert_matrix_row((exp,_)::rest,t1,t2 )=> ((exp',a)::rest)
end

(** relation: type_convert_list
 **
 ** Helper relation to type_convert.
 **)

relation type_convert_list : (Exp.Exp list, Type list, Type list) 
	  => (Exp.Exp list, Type list) =

  axiom type_convert_list ([], _, _) => ([],[])

  rule	type_convert_list (rest, ty1rest, ty2rest) => (rest',tyrest') &
	type_convert (first, ty1, ty2) => (first',ty')
	-------------------------------------------
	type_convert_list (first::rest, ty1::ty1rest, ty2::ty2rest) => (first'::rest',ty'::tyrest')

end

(** relation: match_with_promote
 **
 ** Similar to match_prop, but having a flag indicating that Integer to Real 
 ** conversion can be used.
 **)

relation match_with_promote : (Properties, Properties, bool (* Allow Integer => Real *)) 
	  => Properties =

  rule	match_with_promote(PROP(t1,c1),PROP(t2,c2),havereal) => PROP(t,c) &
	let dim = dim1
	-----
	match_with_promote(PROP((T_ARRAY(dim1,t1),_),c1),
			   PROP((T_ARRAY(dim2,t2),p2),c2), havereal) 
	  => PROP((T_ARRAY(dim,t),p2),c)

  rule	is_array t1 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2), havereal) => PROP(t,c)
	---------------------------
	match_with_promote(PROP(t1,c1),
			   PROP((T_ARRAY(DIM(SOME(1)),t2),p2),c2), havereal) 
	  => PROP((T_ARRAY(DIM(SOME(1)),t),p2),c)

  rule	is_array t2 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2), havereal) => PROP(t,c)
	-----
	match_with_promote(PROP((T_ARRAY(DIM(SOME(1)),t1),p),c1),
			   PROP(t2,c2), havereal)
	  => PROP( (T_ARRAY(DIM(SOME(1)),t),p) ,c)


  rule	is_array t1 => false &
	is_array t2 => false &	
	t1 = t2 &
	let t = t1 &
	const_and(c1,c2) => c
	--------------
	match_with_promote(PROP(t1,c1),PROP(t2,c2), false) => PROP(t,c)


  rule	(* Have real and both Real *)
	const_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_REAL(v),_),c1),PROP((T_REAL(_),p2),c2), true) => PROP((T_REAL(v),p2),c)

  rule	(* Have real and first Integer *)
	const_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_INTEGER(_),_),c1),PROP((T_REAL(v),p2),c2), true) 
	  => PROP((T_REAL(v),p2),c)

  rule	(* Have real and second Integer *)
	const_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_REAL(v),_),c1),PROP((T_INTEGER(_),p2),c2), true) => PROP((T_REAL(v),p2),c)

  rule	(* Have real and both Integer *)
	const_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_INTEGER(_),_),c1),PROP((T_INTEGER(_),p2),c2), true) 
	  => PROP((T_REAL([]),p2),c)
end

(** relation: const_and
 **
 ** Returns the 'and' operator of two Const's. I.e. C_CONST iff. both are 
 ** C_CONST, C_PARAM iff both are C_PARAM (or one of them C_CONST),
 ** V_VAR otherwise.
 **)

relation const_and: (Const, Const) => Const =

  axiom	const_and(C_CONST, C_CONST) => C_CONST 
  axiom	const_and(C_CONST,C_PARAM) => C_PARAM
  axiom	const_and(C_PARAM,C_CONST) => C_PARAM
  axiom	const_and(C_PARAM,C_PARAM) => C_PARAM

  axiom	const_and(_,_) => C_VAR
end

(** relation: const_or
 **
 ** Returns the 'or' operator of two Const's. I.e. C_CONST if some is 
 ** C_CONST, C_PARAM if none is C_CONST but some is C_PARAM and
 ** V_VAR otherwise.
 **)

relation const_or: (Const, Const) => Const =

  axiom	const_or(C_CONST, _) => C_CONST 
  axiom	const_or(_,C_CONST) => C_CONST 
  axiom	const_or(C_PARAM,_) => C_PARAM
  axiom	const_or(_,C_PARAM) => C_PARAM

  axiom	const_or(_,_) => C_VAR
end

(** relation: bool_const
 ** author: PA
 **
 ** Creates a Const value from a bool. If true, C_CONST,
 ** if false C_VAR, i.e. there is no way to create a C_PARAM using this 
 ** relation.
 **)

relation bool_const: (bool) => Const =

  axiom	bool_const(false) => C_VAR
  axiom	bool_const(true) => C_CONST

end

(** relation: print_prop_str
 **
 ** Print the properties to a string.
 **)

relation print_prop_str: Properties => string =

  rule	unparse_type ty => ty_str &
	unparse_const const => const_str &
	Util.string_append_list(["PROP(",ty_str,const_str,")"]) => res
	-------------------
	print_prop_str PROP(ty,const) => res

  rule	unparse_type ty => ty_str &
	unparse_tupleconst const => const_str &
	Util.string_append_list(["PROP_TUPLE(",ty_str, ", ", const_str, ")"]) => res
	---------------------------------
	print_prop_str PROP_TUPLE(ty,const) => res
end



(** relation: print_prop
 **
 ** Print the Properties to the Print buffer.
 **)

relation print_prop : Properties => () =

  rule	print_prop_str p => str &
	Print.print_error_buf str 
	----------------
	print_prop (p) => ()
end


(** relation: flow_variables
 **
 ** This relation retrieves all variables names that are flow variables, and 
 ** prepends the prefix given as an 'Exp.ComponentRef'
**)

relation flow_variables: (Var list, Exp.ComponentRef) => Exp.ComponentRef list =

  axiom	flow_variables([],_) => []

  rule	Exp.join_crefs(cr,Exp.CREF_IDENT(id,[])) => cr' &
	flow_variables(vs,cr) => res
	-------------------------
	flow_variables(VAR(id,ATTR(true,_,_,_),_,_,_)::vs,cr) => cr'::res

  rule	flow_variables(vs,cr) => res
	-------------------------
	flow_variables(_::vs,cr) => res
end

(** relation: get_all_exps
 ** 
 ** This relation goes through the Type structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps : Type => Exp.Exp list =

  rule	get_all_exps_tt ttype => exps
	-----------------------------
	get_all_exps ((ttype, pathopt)) => exps

end

(** relation: get_all_exps_tt
 ** 
 ** This relation goes through the TType structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps_tt : TType => Exp.Exp list =

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_INTEGER(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_REAL(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_STRING(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_BOOL(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_ENUMERATION(strs, vars) => exps

  rule	get_all_exps ty => exps
	---------------------------------------------
	get_all_exps_tt T_ARRAY(dim, ty) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_COMPLEX(cinf, vars) => exps

  rule	Util.list_map(fargs, get_funcarg_type) => tys &
	Util.list_map(tys, get_all_exps) => explists &
	get_all_exps ty => tyexps &
	Util.list_flatten(tyexps::explists) => exps
	-------------------------------------------
	get_all_exps_tt T_FUNCTION(fargs, ty) => exps

  rule	Util.list_map(tys, get_all_exps) => explist &
	Util.list_flatten(explist) => exps
	----------------------------------
	get_all_exps_tt T_TUPLE (tys) => exps

  rule	Debug.fprintln("failtrace", "-- get_all_exps_tt failed")
	--------------------------------------------------------
	get_all_exps_tt _ => fail

end

(** relation: get_all_exps_vars
 **
 ** Helper relation to get_all_exps_tt.
 **)

relation get_all_exps_vars : Var list => Exp.Exp list =

  rule	Util.list_map(vars, get_all_exps_var) => explist &
	Util.list_flatten(explist) => exps
	----------------------------------
	get_all_exps_vars vars => exps
	
end

(** relation: get_all_exps_var
 **
 ** Helper relation to get_all_exps_vars.
 **)

relation get_all_exps_var : Var => Exp.Exp list =

  rule	get_all_exps ty => tyexps &
	get_all_exps_binding bnd => bndexp &
	list_append (tyexps,bndexp) => exps
	----------------------------
	get_all_exps_var VAR(id,attr,prot,ty,bnd) => exps
	
end

(** relation: get_all_exps_binding
 **
 ** Helper relation to get_all_exps_var.
 **)

relation get_all_exps_binding : Binding => Exp.Exp list =

  axiom	get_all_exps_binding EQBOUND(exp,_,cnst) => [exp]

  axiom	get_all_exps_binding UNBOUND => []

  axiom	get_all_exps_binding VALBOUND(v) => []

  rule	Debug.fprintln("failtrace", "-- get_all_exps_binding failed")
	-------------------------------------------------------------
	get_all_exps_binding _ => fail

end


(** relation: get_funcarg_type
 **
 ** Retrieve the type from a function argument.
 **)

relation get_funcarg_type: FuncArg => Type =

  axiom	get_funcarg_type ((id,ty)) => ty

end

