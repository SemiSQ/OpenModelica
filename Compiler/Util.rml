(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Util.rml
 ** module:      Util
 ** description: Miscellanous RML utilities
 **
 ** RCS: $Id$
 ** 
 ** This module contains various RML utilities *sigh*, mosly 
 ** related to lists.
 ** It is used pretty much everywhere. The difference between this 
 ** module and the ModUtil module is that ModUtil contains modelica 
 ** related utilities. The Util module only contains "low-level" 
 ** rml utilities, for example finding elements in lists.
 ** 
 ** This modules contains many relations that uses 'type variables' in RML.
 ** A type variable is exactly what it sounds like, a type bound to a variable.
 ** It is used for higher order functions, i.e. in RML the possibility to pass a 
 ** "pointer" to a relation into another relation. But it can also be used for 
 ** generic data types, like in  C++ templates.

 ** A type variable in RML is written as 'a
 ** For instance,
 ** relation list_fill ('a,int) => 'a list
 ** the type variable 'a is here used as a generic type for the relation list_fill, 
 ** which returns a list of n elements of a certain type.
 **)

 module Util :
   
  datatype ReplacePattern = REPLACEPATTERN of string (* from string (ie "." *)
                                            * string  (* to string (ie "$p") *)
                                                        (*))*)

  relation if : (bool,'a,'a) => 'a
  relation list_fill: ('a ,int) => 'a list
  relation list_make_2: ('a ,'a) => 'a list
  relation list_int_range: (int) => int list 
  relation list_first: 'a list => 'a
  relation list_rest: 'a list => 'a list
  relation list_last: 'a list => 'a	  
  relation list_cons: ('a list,'a) => 'a list
  relation list_create: ('a) => 'a list
  relation list_strip_last: 'a list => 'a list	  
  relation list_flatten : 'a list list => 'a list
  relation list_append_elt : ('a,'a list) => 'a list
  relation list_map_0 : ('a list, 'a => ()) => ()
  relation list_map : ('a list, 'a => 'b) => 'b list
  relation list_map__2 : ('a list, 'a => ('b,'c)) => ('b list,'c list)
  relation list_map_1: ('a list, ('a, 'b) => 'c, 'b) => 'c list
  relation list_map_1r: ('a list, ('b,'a) => 'c, 'b) => 'c list
  relation list_map_2: ('a list, ('a, 'b,'c) => 'd, 'b,'c) => 'd list 
  relation list_map_3: ('a list, ('a, 'b,'c,'d) => 'e, 'b,'c,'d) => 'e list 
  relation list_map_3_2: ('a list, ('a, 'b,'c,'d) => ('e,'f), 'b,'c,'d) => ('e list, 'f list) 
  relation list_map_1_2: ('a list, ('a, 'b) => ('c,'d), 'b) => ('c list,'d list)
  relation list_map_2_2: ('a list, ('a, 'b,'c) => ('d,'e), 'b,'c) => ('d * 'e) list
  relation list_fold: ('a list, ('a,'b)=> 'b, 'b) => 'b	  

  relation list_fold_map: ('a list, ('a*'b) => ('a*'b), 'b) => ('a list,'b)

  relation list_list_map : ('a list list, 'a => 'b) => 'b list list 
  relation list_list_map_1 : ('a list list, ('a,'b) => 'c,'b) => 'c list list 
  relation list_list_reverse: ('a list list) => 'a list list
  relation list_thread : ('a list, 'a list) => 'a list
  relation list_thread_map : ('a list, 'b list, ('a,'b) => 'c) => 'c list
  relation list_thread_tuple : ('a list, 'b list) => ('a * 'b) list
  relation list_list_thread_tuple : ('a list list, 'b list list) 
	  => ('a * 'b) list list
  relation list_select:('a list, 'a => bool) => 'a list
  relation list_select_1:('a list,'b, ('a,'b) => bool) => 'a list
  relation list_select_1_r:('a list,'b, ('b,'a) => bool) => 'a list 
  relation list_position: (''a, ''a list)  => int
  relation list_getmember: (''a, ''a list) => ''a
  relation list_deletemember: (''a list,''a) => ''a list
  relation list_deletemember_p: (''a list,''a,(''a,''a)=> bool ) => ''a list 
  relation list_getmember_p: (''a, ''a list,(''a,''a) => bool ) => ''a
  relation list_replaceat: (''a, int, ''a list) => ''a list 
  relation list_replaceat_with_fill: (''a, int, ''a list,''a) => ''a list 
  relation list_union_elt: (''a , ''a list) => ''a list
  relation list_union_elt_p: (''a , ''a list , (''a, ''a) => bool) 
	  => ''a list 
  relation list_union:  (''a list, ''a list) => ''a list
  relation list_union_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list
  relation list_intersection_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list
  relation list_setdifference_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list
  relation list_list_union:  (''a list list) => ''a list 
  relation list_list_union_p:  (''a list list, (''a,''a) => bool) => ''a list 
	  
  relation list_reduce: ('a list, ('a,'a) => 'a) => 'a
	      
  relation array_replaceat_with_fill: (''a, int, ''a array,''a) => ''a array 
  relation array_expand: (int, ''a array,''a) => ''a array 
  relation array_copy:(''a array (*src*), ''a array (*dst*)) => ''a array
  relation array_n_copy:(''a array (*src*), ''a array (*dst*), int (*n*)) 
	  => ''a array

  relation tuple2_1 : ('a * 'b) => 'a 
  relation tuple2_2 : ('a * 'b) => 'b

  relation split_tuple2_list : ('a * 'b) list => ('a list, 'b list)
  relation string_append_list : string list => string
  relation string_delimit_list : (string list, string) => string
  relation string_delimit_list_2sep : (string list, string,string,int) => string
  relation string_delimit_list_no_empty : (string list, string) => string
  relation string_replace_char : (string, char, char) => string
  relation string_split_at_char : (string, char) => string list 
  relation modelica_string_to_c_str : string => string
  relation c_str_to_modelica_string : string => string
  relation is_empty_string : string => bool 
  relation is_not_empty_string : string => bool 


  relation bool_and_list: bool list => bool
  relation bool_or_list: bool list => bool
  relation bool_string: bool => string 
  relation string_equal: (string,string) => bool
  relation list_matching : ('a list, 'a => ()) => 'a list

  relation apply_option : ('a option,'a => 'b) => 'b option

  relation make_option: 'a => 'a option

  relation string_option: string option => string 

  relation option_to_list: 'a option => 'a list
  relation flatten_option: ('a option, 'a) => 'a

  relation list_split : ('a list, int) => ('a list, 'a list)

  relation int_positive: int => bool
  relation write_file_or_error_msg:(string,(*filename*)
                                    string(*the string to be written*)) => ()

  relation system_call_with_error_msg:(string (*command*),
                                       string (*error_msg to error_buf if fail*)) => ()
  relation strncmp: (string, string, int) => bool
  relation charlistcompare: (char list, char list, int) => bool

  relation tick_str:() => string
  relation get_absolute_directory_and_file:(string) => (string,string) 
        
end

val replaceStringPatterns = [REPLACEPATTERN(".","$point"),
                             REPLACEPATTERN("[","$leftBracket"),
                             REPLACEPATTERN("]","$rightBracket"),
			     REPLACEPATTERN(",","$comma")]



with "System.rml"
with "Print.rml"
with "Debug.rml"


(** relation: list_fill
 ** Returns a list of n elements of type 'a.
 ** For example,
 ** list_fill("foo",3) => ["foo","foo","foo"]
 **)
relation list_fill: ('a ,int) => 'a list =

  axiom	list_fill (a,1) => [a]

  rule	int_sub(n,1) => n' &
	list_fill(a,n') => res
	----------------------
	list_fill (a,n) => a::res
end

(** relation list_make_2
 **
 ** Takes two arguments of same type and returns a list containing the two.
 **)

relation list_make_2: ('a ,'a) => 'a list =

  axiom	list_make_2(a,b) => [a,b]

end

(** relation: list_int_range
 ** Returns a list of n integers from 1 to N.
 ** For example,
 ** list_int_range(3) => [1,2,3]
 **)
relation list_int_range: (int) => int list =

  rule	list_int_range2(1,n) => res
	-------------------
	list_int_range(n) => res
end

relation list_int_range2:(int,int) => int list =

  rule	int_lt(i,n) => true &
	int_add(i,1) => i' &
	list_int_range2(i',n) => res
	----------------------
	list_int_range2 (i,n) => i::res

  axiom	list_int_range2 (i,n) => [i]
end

(** relation: list_first 
 ** Returns the first element of a list
 ** For example,
 ** list_first([3,5,7,11,13]) => 3
 **)
relation list_first: 'a list => 'a =	

  axiom	list_first(x::_) => x
end	  

(** relation: list_rest
 ** Returns the rest of a list.
 ** For example,
 ** list_rest([3,5,7,11,13]) => [5,7,11,13]
 **)
relation list_rest: 'a list => 'a list =
	
  axiom	list_rest (_::x) => x
end

(** relation: list_last
 ** Returns the last element of a list. If the list is the empty list, the relation 
 ** fails.
 ** For example,
 ** list_last([3,5,7,11,13]) => 13
 ** list_last([]) => fail
 **)
relation list_last: 'a list => 'a =

  axiom	list_last [] => fail

  axiom	list_last [a] => a
	
  rule	list_last(rest) => a
	-----------------
	list_last(_::rest) => a
end

(** relation: list_cons
 **
 ** Performs the cons operation, i.e. elt::list.
 **)
relation list_cons: ('a list,'a) => 'a list =

  axiom	list_cons(lst,elt) => elt::lst

end

(** relation: list_create
 **
 ** Create a list from an element.
 **)
relation list_create: ('a) => 'a list =

  axiom	list_create(a) => [a]

end

(** relation: list_strip_last
 ** Remove the last element of a list. If the list is the empty list, the relation 
 ** returns empty list
 ** For example,
 ** list_strip_last([3,5,7,11,13]) => [3,5,7,11]
 ** list_strip_last([]) => []
 **)
relation list_strip_last: 'a list => 'a list =

  axiom	list_strip_last [] => []
	
  axiom	list_strip_last [a] => []
	
  rule	list_reverse(lst) => b::rev_lst &
        list_reverse(rev_lst) => a
	-----------------
	list_strip_last(lst) => a
end

(** relation: list_flatten
 ** Takes a list of lists and flattens it out, producing one list of all 
 ** elements of the sublists.
 ** For example
 ** list_flatten([ [1,2],[3,4,5],[6],[] ]) => [1,2,3,4,5,6]
 **)
relation list_flatten : 'a list list => 'a list =

  axiom	list_flatten [] => []

  rule	list_flatten r => r' &
	list_append(f,r') => l
	-----------------------
	list_flatten f::r => l

end

(** relation: list_append_elt
 ** This relation adds an element last to the list
 ** For example
 ** list_append_elt(1,[2,3]) => [2,3,1]
 **)
relation list_append_elt : ('a,'a list) => 'a list =

  axiom	list_append_elt(elt,[]) => [elt]

  rule	list_append_elt(elt,xs) => xs'
	------------------------------
	list_append_elt(elt,x::xs) => x::xs'
end

(** relation: list_map
 ** Takes a list and a relation over the elements of the lists, which is applied
 ** for each element, producing a new list.
 ** For example
 ** list_map([1,2,3], int_string) => [ "1", "2", "3"]
 **)
relation list_map : ('a list, 'a => 'b) => 'b list =
	
  axiom	list_map ([],_) => []

  rule	fn f => f' &
	list_map(r,fn) => r'
	-------------------
	list_map (f::r,fn) => f'::r'
end

(** relation list_map__2
 ** Takes a list and a relation over the elements returning a tuple of two types,
 ** which is applied for each element producing two new lists.
 ** For example
 ** relation split_real_string (real) => (string,string)  returns the string value at 
 ** each side of the decimal point.
 ** list_map__2([1.5,2.01,3.1415], split_real_string) => (["1","2","3"],["5","01","1415"])
 **)
relation list_map__2 : ('a list, 'a => ('b,'c)) => ('b list,'c list) =

  axiom	list_map__2 ([],_) => ([],[])

  rule	fn f => (f1',f2') &
	list_map__2(r,fn) => (r1',r2')
	-------------------
	list_map__2 (f::r,fn) => (f1'::r1',f2'::r2')
end

(** relation list_map_1
 ** Takes a list and a relation over the list plus an extra argument sent to the relation.
 ** The relation produces a new value which is used for creating a new list.
 ** For example,
 ** list_map_1([1,2,3],int_add,2) => [3,4,5]
 **)
relation list_map_1: ('a list, ('a, 'b) => 'c, 'b) => 'c list =

  axiom	list_map_1 ([],_,_) => []

  rule	fn (f,extraarg) => f' &
	list_map_1(r,fn,extraarg) => r'
	-------------------
	list_map_1(f::r,fn,extraarg) => f'::r'
end

(** relation list_map_1r
 ** Same as list_map_1 but swapped arguments on relation.
 **)
relation list_map_1r: ('a list, ('b,'a) => 'c, 'b) => 'c list =

  axiom	list_map_1r ([],_,_) => []

  rule	fn (extraarg,f) => f' &
	list_map_1r(r,fn,extraarg) => r'
	-------------------
	list_map_1r(f::r,fn,extraarg) => f'::r'
end

(** relation list_map_2
 ** Takes a list and a relation and two extra arguments passed to the relation.
 ** The relation produces one new value which is used for creating a new list.
 ** For example,
 ** relation if:(bool,'a,'a) => 'a
 ** list_map_2([true,false,false],1,0,if) => [1,0,0]
 **)
relation list_map_2: ('a list, ('a, 'b,'c) => 'd, 'b,'c) => 'd list =

  axiom	list_map_2 ([],_,_,_) => []

  rule	fn (f,extraarg1,extraarg2) => f' &
	list_map_2(r,fn,extraarg1,extraarg2) => r'
	-------------------
	list_map_2(f::r,fn,extraarg1,extraarg2) => f'::r'
end

(** relation list_map_3
 ** Takes a list and a relation and three extra arguments passed to the relation.
 ** The relation produces one new value which is used for creating a new list.
 **)
relation list_map_3: ('a list, ('a, 'b,'c,'d) => 'e, 'b,'c,'d) => 'e list =

  axiom	list_map_3 ([],_,_,_,_) => []

  rule	fn (f,extraarg1,extraarg2,extraarg3) => f' &
	list_map_3(r,fn,extraarg1,extraarg2,extraarg3) => r'
	-------------------
	list_map_3(f::r,fn,extraarg1,extraarg2,extraarg3) => f'::r'
end

(** relation list_map_3_2
 ** Takes a list and a relation and three extra arguments passed to the relation.
 ** The relation produces two values which is used for creating two new lists.
 **)
relation list_map_3_2: ('a list, ('a, 'b,'c,'d) => ('e,'f), 'b,'c,'d) => ('e list, 'f list) =

  axiom	list_map_3_2 ([],_,_,_,_) => ([],[])

  rule	fn (f,extraarg1,extraarg2,extraarg3) => (f1',f2') &
	list_map_3_2(r,fn,extraarg1,extraarg2,extraarg3) => (r1',r2')
	-------------------
	list_map_3_2(f::r,fn,extraarg1,extraarg2,extraarg3) => (f1'::r1',f2'::r2')
end

(** relation: list_map_1_2
 ** Takes a list and a relation with one extra arguments passed to the relation.
 ** The relation returns a tuple of two values which are used for creating 
 ** two new lists
 **)
 relation list_map_1_2: ('a list, ('a, 'b) => ('c,'d), 'b) => ('c list,'d list) = 

  axiom	list_map_1_2 ([],_,_) => ([],[])

  rule	fn (f,extraarg1) => (f1,f2) &
	list_map_1_2(r,fn,extraarg1) => (r1,r2)
	-------------------
	list_map_1_2(f::r,fn,extraarg1) => (f1::r1,f2::r2)
end

(** relation: list_map_2_2
 ** Takes a list and a relation with two extra arguments passed to the relation.
 ** The relation returns a tuple of two values which are used for creating two new lists
 ** For example,
 ** relation foo(int,string,string) => (string,string) concatenates each string with 
 ** itself n times. foo(2,"a",b") => ("aa","bb")
 ** list_map_2_2 ([2,3],foo,"a","b") => [("aa","bb"),("aa","bbb")]
 **)
relation list_map_2_2: ('a list, ('a, 'b,'c) => ('d,'e), 'b,'c) => ('d * 'e) list =

  axiom	list_map_2_2 ([],_,_,_) => []

  rule	fn (f,extraarg1,extraarg2) => (f1,f2) &
	list_map_2_2(r,fn,extraarg1,extraarg2) => r'
	-------------------
	list_map_2_2(f::r,fn,extraarg1,extraarg2) => ((f1,f2)::r')
end

(** relation: list_map_0
 ** Takes a list and a relation which does not return a value
 ** The relation is probably a relation with side effects, like print.
 ** For example,
 ** list_map_0(["a","b","c"],print) => ()
 **)
relation list_map_0 : ('a list, 'a => ()) => () =

  axiom	list_map_0 ([],_) => ()

  rule	fn (f) => () &
	list_map_0(r,fn) => ()
	-------------------
	list_map_0(f::r,fn) => ()
end

(** relation: list_list_map 
 ** Takes a list of lists and a relation producing one value.
 ** The relation is applied to each element of the lists resulting
 ** in a new list of lists.
 ** For example,
 ** list_list_map([ [1,2],[3],[4]],int_string) => [ ["1","2"],["3"],["4"] ]
 **)
relation list_list_map : ('a list list, 'a => 'b) => 'b list list =
	
  axiom	list_list_map ([],_) => []

  rule	list_map(f,fn) => f' &
	list_list_map(r,fn) => r'
	-------------------
	list_list_map (f::r,fn) => f'::r'

end

(** relation list_list_map_1
 ** author: PA
 ** similar to list_list_map but for relations taking two arguments.
 ** The second argument is passed as an extra argument.
 **)
relation list_list_map_1 : ('a list list, ('a,'b) => 'c,'b) => 'c list list =
	
  axiom	list_list_map_1 ([],_,_) => []

  rule	list_map_1(f,fn,e) => f' &
	list_list_map_1(r,fn,e) => r'
	-------------------
	list_list_map_1 (f::r,fn,e) => f'::r'

end

(** relation: list_fold
 ** Takes a list and a relation operating on list elements having an extra argument that is 'updated'
 ** thus returned from the relation. The third argument is the startvalue for the updated value.
 ** list_fold will call the relation for each element in a sequence, updating the startvalue 
 ** For example,
 ** list_fold([1,2,3],int_add,2) =>  8
 ** int_add(1,2) => 3, int_add(2,3) => 5, int_add(3,5) => 8 
 **)
relation list_fold: ('a list, ('a,'b)=> 'b, 'b) => 'b =

  axiom	list_fold([],r,b) => b
	
  rule	r(l,b) => b' &
	list_fold(lst,r,b') => b'' 
	--------------------------
	list_fold(l::lst,r,b) => b''
end

(** relation: list_fold_map
 ** author: PA
 **
 ** For example see Exp.traverse_exp.
 **)

relation list_fold_map: ('a list, (('a*'b)=> ('a*'b)), 'b) => ('a list,'b) =

  axiom	list_fold_map([],rel,e_arg) => ([],e_arg)

  rule	rel((elt,b)) => ((elt',b')) &
	list_fold_map(elts,rel,b') => (elts',b'')
	---------------------------------
	list_fold_map(elt::elts,rel,b) 	
	  => (elt'::elts',b'')
end
	  

(** relation: list_list_reverse
 ** Takes a list of lists and reverses it at both levels, i.e. both the list itself
 ** and each sublist
 ** For example,
 ** list_list_reverse([[1,2],[3,4,5],[6] ]) => [ [6], [5,4,3], [2,1] ]
 **)
relation list_list_reverse: ('a list list) => 'a list list =

  rule	list_map(lsts, list_reverse) => lsts' &
	list_reverse(lsts') => lsts''
	-----------------------
	list_list_reverse(lsts) => lsts''
end

(** relation: list_thread
 ** Takes two lists of the same type and threads them togheter.
 ** For eample,
 ** list_thread([1,2,3],[4,5,6]) => [4,1,5,2,6,3]
 **)
relation list_thread : ('a list, 'a list) => 'a list =

  axiom	list_thread([],[]) => []

  rule	list_thread(ra,rb) => r' &
	let c = fb::r' &
	let d = fa::c
	------------------------
	list_thread(fa::ra,fb::rb) => d

end

(** relation: list_thread_map
 ** Takes two lists and a relation and threads and maps the elements of the two lists
 ** creating a new list.
 ** For example,
 ** list_thread_map([1,2],[3,4],int_add) => [1+3, 2+4]
 **)
relation list_thread_map : ('a list, 'b list, ('a,'b) => 'c) => 'c list =

  axiom	list_thread_map([],[],_) => []

  rule	fn(fa,fb) => fr &
	list_thread_map(ra,rb,fn) => res
	--------------------------------
	list_thread_map(fa::ra,fb::rb,fn) => fr::res
end 

(** relation: list_thread_tuple
 ** Takes two lists and threads the arguments into a list of tuples
 ** consisting of the two element types.
 ** For example,
 ** list_thread_tuple([1,2,3],[true,false,true]) => [(1,true),(2,false),(3,true)]
 **)
relation list_thread_tuple : ('a list, 'b list) => ('a * 'b) list =

  axiom	list_thread_tuple ([],[]) => []

  rule	list_thread_tuple(ra,rb) => r
	-----------------------------
	list_thread_tuple (fa::ra, fb::rb) => ((fa,fb)::r)

end

(** relation: list_list_thread_tuple
 ** Takes two list of lists as arguments and produces a list of lists of a two tuple
 ** of the element types of each list.
 ** For example,
 ** list_list_thread_tuple([[1],[2,3]],[["a"],["b","c"]]) => [ [(1,"a")],[(2,"b"),(3,"c")] ]
 **)
relation list_list_thread_tuple : ('a list list, 'b list list) 
	  => ('a * 'b) list list =

  axiom	list_list_thread_tuple ([],[]) => []

  rule	list_thread_tuple(fa,fb) => f &
	list_list_thread_tuple(ra,rb) => r
	-----------------------------
	list_list_thread_tuple (fa::ra, fb::rb) => f::r

end

(** relation: list_select
 ** This relation retrieves all elements of a list for which
 ** the passed relation evaluates to true. The elements that evaluates to false 
 ** are thus removed from the list.
 **)
relation list_select: ('a list, 'a => bool) => 'a list =


  axiom	list_select([],_) => []

  rule	cond(x) => true &
	list_select(xs,cond) => xs' 
	---------------------------
	list_select(x::xs,cond) => x::xs'

  rule	cond(x) => false &
	list_select(xs,cond) => xs' 
	---------------------------
	list_select(x::xs,cond) => xs'
end

(** relation list_select_1
 ** Same as list_select above, but with extra argument to testing relation.
 **)
relation list_select_1:('a list,'b, ('a,'b) => bool) => 'a list =

  axiom	list_select_1([],arg,_) => []

  rule	cond(x,arg) => true &
	list_select_1(xs,arg,cond) => xs' 
	---------------------------
	list_select_1(x::xs,arg,cond) => x::xs'

  rule	cond(x,arg) => false &
	list_select_1(xs,arg,cond) => xs' 
	---------------------------
	list_select_1(x::xs,arg,cond) => xs'
end

(** relation list_select_1_r
 ** Same as list_select_1 above, but with swapped arguments.
 **)
relation list_select_1_r:('a list,'b, ('b,'a) => bool) => 'a list =

  axiom	list_select_1_r([],arg,_) => []

  rule	cond(arg,x) => true &
	list_select_1_r(xs,arg,cond) => xs' 
	---------------------------
	list_select_1_r(x::xs,arg,cond) => x::xs'

  rule	cond(arg,x) => false &
	list_select_1_r(xs,arg,cond) => xs' 
	---------------------------
	list_select_1_r(x::xs,arg,cond) => xs'
end

(** relation: list_position
 ** Takes a value and a list of values and returns the (first) position
 ** the value has in the list. Position index start at zero, such that list_nth can
 ** be used on the resulting position directly.
 ** For example,
 ** list_position(2,[0,1,2,3]) => 2
 **)
relation list_position =
  rule	list_pos(x, ys, 0) => n
	-----------------------
	list_position(x, ys) => n
end

(** helper relation to list_position **)
relation list_pos =
  rule	x = y
	-----
	list_pos(x, y::ys, i) => i

  rule	not x = y &
	int_add(i, 1) => i' &
	list_pos(x, ys, i') => n
	------------------------
	list_pos(x, y::ys, i) => n
end

(** relation: list_getmember
 ** Takes a value and a list of values and returns the value 
 ** if present in the list. If not present, the relation will fail.
 ** For example,
 ** list_getmember(0,[1,2,3]) => fail
 ** list_getmember(1,[1,2,3]) => 1
 **)
relation list_getmember: (''a, ''a list) => ''a =

  axiom list_getmember(_,[]) => fail

  rule  x = y
	-----
	list_getmember(x,y::ys) => y 
	
  rule	not x = y & 
	list_getmember(x,ys) => res 
	----------------------
	list_getmember(x,y::ys) => res
end 

(** relation: list_deletemember
 ** Takes a list and a value and deletes the first occurence of the value in the list
 ** For example,
 ** list_deletemember([1,2,3,2],2) => [1,3,2]
 **)
relation list_deletemember: (''a list,''a) => ''a list =

  rule	list_position(elt,lst) => pos &
	list_delete(lst,pos) => lst'
	----------------------------
	list_deletemember(lst,elt) => lst'

  axiom	list_deletemember(lst,_) => lst

end

(** relation: list_deletemember_p
 ** Takes a list and a value and a comparison relation and deletes the first occurence of 
 ** the value in the list
 ** For example,
 ** list_deletemember([1,2,3,2],2,int_eq) => [1,3,2]
 **)
relation list_deletemember_p: (''a list,''a,(''a,''a)=> bool ) => ''a list =

  rule	(* A bit ugly *)
	list_getmember_p(elt,lst,cond) => elt' &
	list_position(elt',lst) => pos &
	list_delete(lst,pos) => lst'
	----------------------------
	list_deletemember_p(lst,elt,cond) => lst'

  axiom	list_deletemember_p(lst,_,_) => lst

end
(** relation list_getmember_p
 ** Takes a value and a list of values and a comparison relation over two values.
 ** If the value is present in the list (using the comparison relation returning true)
 ** the value is returned, otherwise the relation fails.
 ** For example,
 ** relation equal_lenght(string,string) returns true if the strings are of same length
 ** list_getmember_p("a",["bb","b","ccc"],equal_length) => "b"
 **)
relation list_getmember_p: (''a, ''a list,(''a,''a) => bool) => ''a =

  axiom list_getmember_p(_,[],p) => fail

  rule  p(x, y) => true
	-----
	list_getmember_p(x,y::ys,p) => y 
	
  rule	p(x, y) => false & 
	list_getmember_p(x,ys,p) => res 
	----------------------
	list_getmember_p(x,y::ys,p) => res
end 

(** relation: list_union_elt
 ** Takes a value and a list of values and inserts the value into the list if 
 ** it is not already in the list.
 ** If it is in the list it is not inserted.
 ** For example,
 ** list_union_elt(1,[2,3]) => [1,2,3]
 ** list_union_elt(0,[0,1,2]) => [0,1,2]
 **)
relation list_union_elt: (''a , ''a list) => ''a list =

  rule	list_getmember(x,lst) => _ 
	--------------------------
	list_union_elt(x,lst) => lst

  rule	not list_getmember(x,lst) => _ 
	--------------------------
	list_union_elt(x,lst) => x::lst	
end

(** relation list_union
 ** Takes two lists and returns the union of the two lists, i.e. a list of all elements combined
 ** without duplicates.
 ** For example,
 ** list_union([0,1],[2,1]) => [0,1,2]
 **)
relation list_union:  (''a list, ''a list) => ''a list =
	
  axiom	list_union([],res) => res

  rule	list_union_elt(x,lst2) => r1 &
	list_union(xs,r1) => res
	-----------------------
	list_union(x::xs,lst2) => res
end

(** relation: list_list_union
 ** Takes a list of lists and returns the union of the sublists
 ** For example,
 ** list_list_union([[1],[1,2],[3,4],[5]]) => [1,2,3,4,5]
 **)
relation list_list_union:  (''a list list) => ''a list =
  
  axiom	list_list_union([]) => []

  axiom	list_list_union([x]) => x

  rule	list_union(x1,x2) => r1 &
	list_list_union(r1::rest) => res
	-----------------------
	list_list_union(x1::x2::rest) => res
end

(** relation: list_union_elt_p
 ** Takes an elemement and a list and a comparison relation over the two values.
 ** It returns the list with the element inserted if not already present in the
 ** list, according to the comparison relation.
 ** For example,
 ** list_union_elt_p(1,[2,3],int_eq) => [1,2,3]
 **)
relation list_union_elt_p: (''a , ''a list , (''a, ''a) => bool) => ''a list =

  rule	list_getmember_p(x,lst,p) => _ 
	--------------------------
	list_union_elt_p(x,lst,p) => lst

  rule	not list_getmember_p(x,lst,p) => _ 
	--------------------------
	list_union_elt_p(x,lst,p) => x::lst	
end

(** relation: list_union_p
 ** Takes two lists and a comparison relation over two elements of the list.
 ** It returns the union of the two lists, using the comparison relation passed as argument
 ** to determine identity between two elements.
 ** For example
 ** given the relation equal_lenght(string,string) returning true if the strings are of same length
 ** list_union_p(["a","aa"],["b","bbb"],equal_length) => ["a","aa","bbb"]
 **)
relation list_union_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list =
	
  axiom	list_union_p([],res,p) => res

  rule	list_union_elt_p(x,lst2,p) => r1 &
	list_union_p(xs,r1,p) => res
	-----------------------
	list_union_p(x::xs,lst2,p) => res
end

(** relation: list_intersection_p
 ** Takes two lists and a comparison relation over two elements of the list.
 ** It returns the intersection of the two lists, using the comparison relation passed as 
 ** argument to determine identity between two elements.
 ** For example
 ** given the relation string_equal(string,string) returning true if the strings are equal
 ** list_intersection_p(["a","aa"],["b","aa"],string_equal) => ["aa"]
 **)
relation list_intersection_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list =

  axiom	list_intersection_p([],_,_) => []

  rule	list_getmember_p(x1,xs2,cond) => _ &
	list_intersection_p(xs1,xs2,cond) => res
	---------------------------------
	list_intersection_p(x1::xs1,xs2,cond) => x1::res

  rule	(* not list_getmember_p(x1,xs2,cond) => _ *)
	list_intersection_p(xs1,xs2,cond) => res
	---------------------------------
	list_intersection_p(x1::xs1,xs2,cond) => res
end

(** relation: list_setdifference_p
 ** Takes two lists and a comparison relation over two elements of the list.
 ** It returns the set difference of the two lists A-B, using the comparison relation passed as 
 ** argument to determine identity between two elements.
 ** For example
 ** given the relation string_equal(string,string) returning true if the strings are equal
 ** list_setdifference_p(["a","b","c"],["a","c"],string_equal) => ["b"]
**)
relation list_setdifference_p:  (''a list (* A *), ''a list (* B *), (''a,''a) => bool) 
	  => ''a list =

  axiom	list_setdifference_p(a,[],cond) => a

  rule	list_deletemember_p(a,x1,cond) => a' &
	list_setdifference_p(a',xs,cond) => a''
	-------------------------------
	list_setdifference_p(a,x1::xs,cond) => a''

  rule	print "-list_setdifference_p failed\n" 
	--------------------------------------
	list_setdifference_p(_,_,_) => fail
end

(** relation: list_list_union_p
 ** Takes a list of lists and a comparison relation over two elements of the lists.
 ** It returns the union of all sublists using the comparison relation for identity.
 ** For example,
 ** list_list_union_p([[1],[1,2],[3,4]],int_eq) => [1,2,3,4]
 **)
relation list_list_union_p:  (''a list list, (''a,''a) => bool) => ''a list =
  
  axiom	list_list_union_p([],p) => []

  axiom	list_list_union_p([x],p) => x

  rule	list_union_p(x1,x2,p) => r1 &
	list_list_union_p(r1::rest,p) => res
	------------------------------------
	list_list_union_p(x1::x2::rest,p) => res
end

(** relation: list_replaceat
 ** Takes an element, a position and a list and replaces the value at the given position in 
 ** the list. Position is an integer between 0 and n-1 for a list of n elements
 ** For example,
 ** list_replaceat("A", 2, ["a","b","c"]) => ["a","b","A"]
 **)
relation list_replaceat: (''a, int, ''a list) => ''a list =

  (*axiom list_replaceat(x,-1,[]) => []*)

  axiom	 list_replaceat (x,0,y::ys) => x::ys

  rule	int_ge(n,1) => true & int_sub(n,1) => nn &
	list_replaceat(x,nn,ys) => res
	-----------------------------
	list_replaceat(x,n,y::ys) => y::res

 (* rule	print "-list_replaceat failed\n" 
	-----------------------
	list_replaceat(_,_,_) => fail*)
end

(** relation: list_replaceat_with_fill
 ** Takes 
 ** - an element, 
 ** - a position 
 ** - a list and 
 ** - a fill value 
 ** The relation replaces the value at the given position in the list, if the given position is 
 ** out of range, the fill value is used to padd the list up to that element position and then
 ** insert the value at the position
 ** 
 ** For example,
 ** list_replaceat_withfill("A", 5, ["a","b","c"],"dummy") => ["a","b","c","dummy","A"]
 **)
relation list_replaceat_with_fill: (''a, int, ''a list,''a) => ''a list =

  axiom list_replaceat_with_fill(x,0,[],fillv) => [x]
	
  axiom	list_replaceat_with_fill (x,0,y::ys,fillv) => x::ys
	
  axiom	list_replaceat_with_fill(x,1,[],fillv) => [fillv,x]
	
  rule	int_gt(numfills,1) => true &
	int_sub(numfills,1) => numfills' &
	list_fill(fillv,numfills') => res &
	list_append(res,[x]) => res'
	---------------------------------
	list_replaceat_with_fill(x,numfills,[],fillv) => res'

  rule	int_ge(n,1) => true & int_sub(n,1) => nn &
	list_replaceat_with_fill(x,nn,ys,fillv) => res
	----------------------------------------------
	list_replaceat_with_fill(x,n,y::ys,fillv) => y::res

  rule	print "-list_replaceat_with_fill failed row: " & int_string p => pos &
	print pos & print "\n" 
	----------------------
	list_replaceat_with_fill(_,p,_,_) => fail
end

(** relation: list_reduce
 ** Takes a list and a relation operating on two elements of the list.
 ** The relation performs a reduction of the lists to a single value using the relation.
 ** For example,
 ** list_reduce([1,2,3],int_add) => 6
 **)
relation list_reduce: ('a list, ('a,'a) => 'a) => 'a =
  axiom	 list_reduce([e],r) => e

  rule	r(a,b) => res
	-------------
	list_reduce([a,b],r) => res

  rule	r(a,b) => res1 &
	list_reduce(xs,r) => res2 &
	r(res1,res2) => res
	-------------------
	list_reduce(a::b::(xs as _::_),r) => res
end

(** relation: array_replaceat_with_fill
 ** Takes 
 ** - an element, 
 ** - a position 
 ** - an array and 
 ** - a fill value 
 ** The relation replaces the value at the given position in the array, if the given position is 
 ** out of range, the fill value is used to padd the array up to that element position and then
 ** insert the value at the position
 ** 
 ** For example,
 ** array_replaceat_withfill("A", 5, ["a","b","c"],"dummy") => ["a","b","c","dummy","A"]
 **)
relation array_replaceat_with_fill: (''a, int, ''a array,''a) => ''a array =
	
  rule	(* Replacing element with index in range of the array*)
	array_length(arr) => alen &
	int_lt(pos,alen) => true &
	array_setnth(arr,pos,x) => res
	-----------------------------
	array_replaceat_with_fill(x,pos,arr,fillv) => res
		     

  rule	(* Replacing element out of range of array, create new array, and copy elts.*)
	int_add(pos, 1) => pos' &
	array_create(pos',fillv) => newarr &
	array_copy(arr,newarr) => res &
	array_setnth(res,pos,x) => res'
	-------------------------------
	array_replaceat_with_fill(x,pos,arr,fillv) => res'

  rule	print "-array_replaceat_with_fill failed\n" 
	-------------
	array_replaceat_with_fill(_,_,_,_) => fail
end

(** relation: array_expand
 ** Increases the number of elements of a list with n.
 ** Each of the new elements have the value v.
 **)
relation array_expand: (int (*n*), ''a array,''a (* v*)) => ''a array =

  rule	array_length(arr) => len &
	int_add(n,len) => newlen &
	array_create(newlen,v) => newarr &
	array_copy(arr,newarr) => newarr'
	--------------------------------
	array_expand(n,arr,v) => newarr'
end

(** relation array_n_copy
 ** Copeis n elements in src array into dest array
 ** The relation fails if all elements can not be fit into dest array.
 **)
relation array_n_copy:(''a array (*src*), ''a array (*dst*), int (*n*)) 
	  => ''a array =

  rule	int_sub(n, 1) => n' &
	array_copy2(src,dst,n') => dst'
	-------------------------
	array_n_copy(src,dst,n) => dst'
end

(** relation: array_copy
 ** copies all values in src array into dest array.
 ** The relation fails if all elements can not be fit into dest array.
 **) 
relation array_copy:(''a array (*src*),  ''a array (*dst*)) => ''a array =

  rule	array_length(src) => srclen &
	array_length(dst) => dstlen &
	int_gt(srclen,dstlen) => true &
	print "-array_copy failed. Can not fit elements into dest array\n" 
	-----------------------------
	array_copy(src,dst) => fail


  rule	array_length(src) => srclen &
	int_sub(srclen, 1) => srclen &
	array_copy2(src,dst,srclen) => dst'
	-----------------------
	array_copy(src,dst) => dst'
end

relation array_copy2: (''a array (*src*), ''a array (*dst*), int (*current pos*)) 
	  => ''a array =

  axiom	array_copy2(src,dst,-1) => dst

  rule	array_nth(src,pos) => elt &
	array_setnth(dst,pos,elt) => dst' &
	int_sub(pos, 1) => pos &
	array_copy2(src,dst',pos) => dst'' 
	---------------------------
	array_copy2(src,dst,pos) => dst''
end

(** relation: tuple2_1
 ** Takes a tuple of two values and returns the first value.
 ** For example,
 ** tuple2_1(("a",1)) => "a"
 **)
relation tuple2_1 : ('a * 'b) => 'a =
	
  axiom	tuple2_1 ((a,_)) => a

end

(** relation: tuple2_2
 ** Takes a tuple of two values and returns the second value.
 ** For example,
 ** tuple2_2(("a",1)) => 1
 **)
relation tuple2_2 : ('a * 'b) => 'b =
	
  axiom	tuple2_2 ((_,b)) => b

end

(** relation: split_tuple2_list
 ** Takes a list of two-tuples and splits it into two lists.
 ** For example,
 ** split_tuple2_list([("a",1),("b",2),("c",3)]) => (["a","b","c"], [1,2,3])
 **)
relation split_tuple2_list : ('a * 'b) list => ('a list, 'b list) =
  axiom	split_tuple2_list([]) => ([],[])

  rule	split_tuple2_list(rest) => (xs,ys)
	---------------------------------
	split_tuple2_list((x,y)::rest) => (x::xs, y::ys)
end

(** relation: if
 ** Takes a boolean and two values.
 ** Returns the first value (second argument) if the boolean value is true, otherwise 
 ** the second value (third argument) is returned.
 ** For example,
 ** if(true,"a","b") => "a"
 **)
relation if : (bool,'a,'a) => 'a =
	
  axiom	if (true,r,_) => r
  axiom	if (false,_,r) => r

end

(** relation string_append_list
 ** Takes a list of strings and appends them.
 ** For example,
 ** string_append_list(["foo", " ", "bar"]) => "foo bar"
 **)
relation string_append_list : string list => string =
	
  axiom string_append_list [] => ""

  axiom	string_append_list [f] => f

  rule	string_append_list r => r' &
	string_append(f,r') => str
	---------------------------
	string_append_list f::r => str
end

(** relation string_delimit_list
 ** Takes a list of strings and a string delimiter and appends all list elements with
 ** the string delimiter inserted between elements.
 ** For example,
 ** string_delimit_list(["x","y","z"], ", ") => "x, y, z"
 **)
relation string_delimit_list : (string list, string) => string =
	
  axiom string_delimit_list([],_) => ""

  axiom	string_delimit_list([f],delim) => f

  rule	string_delimit_list(r,delim) => str1 &
	string_append(f,delim) => str2 &
	string_append(str2,str1) => str
	---------------------------
	string_delimit_list(f::r,delim) => str
end

(** relation: string_delimit_list_2sep
 ** author: PA
 **
 ** This relation is similar to string_delimit_list, i.e it inserts string delimiters between 
 ** consecutive strings in a list. But it also count the lists and inserts a second string delimiter
 ** when the counter is reached. This can be used when for instance outputting large lists of values
 ** and a newline is needed after ten or so items.
 **)
relation string_delimit_list_2sep : (string list, string,string,int) => string =

  rule	string_delimit_list_2sep2(str,sep1,sep2,n,0) => res
	----------------------------
	string_delimit_list_2sep(str,sep1,sep2,n) => res
end

(** relation: string_delimit_list_2sep2
 ** author: PA
 **
 ** Helper relation to string_delimit_list_2sep
 **)
relation string_delimit_list_2sep2: (string list, string, string, int,int (* iterator*)) 
	  => string =

  axiom	string_delimit_list_2sep2([],_,_,_,_) => "" 

  axiom	string_delimit_list_2sep2([s],_,_,_,_) => s 

  rule	(* special case for first element*)
	string_delimit_list_2sep2(r,sep1,sep2,n,1) => str1 &
	string_append_list([f,sep1,str1]) => str
	---------------------------
	string_delimit_list_2sep2(f::r,sep1,sep2,n,0) => str

  rule	(* insert second delimiter*)
	int_mod(iter,n) => 0 &
	iter + 1 => iter' &
	string_delimit_list_2sep2(r,sep1,sep2,n,iter') => str1 &
	string_append_list([f,sep1,sep2,str1]) => str
	---------------------------
	string_delimit_list_2sep2(f::r,sep1,sep2,n,iter) => str

  rule	(* not inserting second delimiter*)
	iter + 1 => iter' &
	string_delimit_list_2sep2(r,sep1,sep2,n,iter') => str1 &
	string_append_list([f,sep1,str1]) => str
	---------------------------
	string_delimit_list_2sep2(f::r,sep1,sep2,n,iter) => str
	
  rule	print "string_delimit_list_2sep2 failed\n"
	-------------------------
	string_delimit_list_2sep2(_,_,_,_,_) => fail
end

(** relation string_delimit_list_no_empty
 ** Takes a list of strings and a string delimiter and appends all list elements with
 ** the string delimiter inserted between elements.
 ** For example,
 ** string_delimit_list(["x","y","z"], ", ") => "x, y, z"
 **)
relation string_delimit_list_no_empty : (string list, string) => string =
	
  rule  list_select(lst,is_not_empty_string) => lst1 &
        string_delimit_list(lst1,delim) => str 
	---------------------------
	string_delimit_list_no_empty(lst,delim) => str
end

(** relation string_replace_char
 ** Takes a string and two chars and replaces the first char to 
 ** second char:
 ** example: string_replace_char("hej.b.c",#".",#"_") => "hej_b_c"
 **)
relation string_replace_char : (string, char, char) => string =

  rule  string_list(str) => strList &
        string_replace_char2(strList,fromChar,toChar) => resList &
        list_string(resList) => res
        -------------------------------
        string_replace_char(str, fromChar, toChar) => res

  rule  print "string_replace_char failed\n"
        ---------------------------------
        string_replace_char(strList,_,_) => strList
  
end

relation string_replace_char2 : (char list, char, char) => char list =

  rule  
        ---------------------------------
        string_replace_char2([],_,_) => []

  rule  firstChar = fromChar &
        string_replace_char2(rest,fromChar,toChar) => res
        ---------------------------------
        string_replace_char2(firstChar::rest,fromChar,toChar) => toChar::res

  rule  not firstChar = fromChar &
        string_replace_char2(rest,fromChar,toChar) => res
        ---------------------------------
        string_replace_char2(firstChar::rest,fromChar,toChar) => firstChar::res

  rule  print "string_replace_char2 failed\n"
        ---------------------------------
        string_replace_char2(strList,_,_) => strList

end

(** relation string_split_at_char
 ** Takes a string and a char and split the string at the char
 ** example: string_split_at_char("hej.b.c",#".") => ["hej,"b","c"]
 **)      
relation string_split_at_char : (string, char) => string list =
 
  rule  string_list(str) => chrList &
        string_split_at_char2(chrList,chr,[]) => stringList
        (*list_string(resList) => res*)
        -------------------------------
        string_split_at_char(str, chr) => stringList

  rule  (*print "string_split_at_char failed\n"*)
        ---------------------------------
        string_split_at_char(strList,_) => [strList]
end

relation string_split_at_char2 : (char list, char,char list) => string list  =

  rule  list_reverse(chr_rest) => chr_rest' &
        list_string(chr_rest') => res
        ---------------------------------
        string_split_at_char2([],_,chr_rest) => [res]

  rule  firstChar = chr &
        (* this is needed because it returns the reversed list *)
        list_reverse(chr_rest) => chrList &
        list_string(chrList) => res &
        string_split_at_char2(rest,chr,[]) => res_str
        ---------------------------------
        string_split_at_char2(firstChar::rest,chr,chr_rest) => res::res_str

  rule  not firstChar = chr &
        string_split_at_char2(rest,chr,firstChar::chr_rest) => res
        ---------------------------------
        string_split_at_char2(firstChar::rest,chr,chr_rest) => res 

  rule  print "string_split_at_char2 failed\n"
        ---------------------------------
        string_split_at_char2(strList,_,_) => fail

end

(**relation modelica_string_to_c_str
 **this replaces symbols that are illegal in C to legal symbols
 **see replaceStringPatterns to see the format. (example: "." becomes "$p")
 ** author: x02lucpo
 **)
relation modelica_string_to_c_str : string => string =

  rule  modelica_string_to_c_str1(str,replaceStringPatterns) => res_str
        ----------------------------------
        modelica_string_to_c_str(str)  => res_str

end

relation modelica_string_to_c_str1 : (string, ReplacePattern list) => string =
        
  axiom modelica_string_to_c_str1(str,[]) => str

  rule  modelica_string_to_c_str1(str,res) => str' &
        System.string_replace(str',from,to) => res_str
        ----------------------------
        modelica_string_to_c_str1(str,REPLACEPATTERN(from,to)::res) => res_str

  rule  print "-modelica_string_to_c_str1 failed\n" 
        ----------------------------
        modelica_string_to_c_str1(_,_) => fail

       
end

(**relation c_str_to_modelica_string
 **this replaces symbols that have been replace to correct value for modelica string
 **see replaceStringPatterns to see the format. (example: "$p" becomes ".")
 ** author: x02lucpo
 **)
relation c_str_to_modelica_string : string => string =

  rule c_str_to_modelica_string1(str,replaceStringPatterns) => res_str
        ----------------------------------
        c_str_to_modelica_string(str)  => res_str

end

relation c_str_to_modelica_string1 : (string, ReplacePattern list) => string =
        
  axiom c_str_to_modelica_string1(str,[]) => str

  rule  c_str_to_modelica_string1(str,res) => str' &
        System.string_replace(str',to,from) => res_str
        ----------------------------
        c_str_to_modelica_string1(str,REPLACEPATTERN(from,to)::res) => res_str
        
end

(** relation bool_or_list
 ** Takes a list of boolean values and applies the boolean 'or' operator  to the list elements
 ** For example
 ** bool_or_list([true,false,false]) => true
 ** bool_or_list([false,false,false]) => false
 **)
relation bool_or_list: bool list => bool =

  axiom	bool_or_list([b]) => b

  rule	b = true
	---------------------
  	bool_or_list(b::rest) => true

  rule	b = false &
	bool_or_list(rest) => res
	---------------------
  	bool_or_list(b::rest) => res
end

(** relation: bool_and_list
 ** Takes a list of boolean values and applies the boolean 'and' operator on the elements
 ** For example,
 ** bool_and_list([true, true]) => true
 ** bool_and_list([false,false,true]) => false
 **)
relation bool_and_list: bool list => bool =

  axiom	bool_and_list([b]) => b

  rule	b = false
	---------------------
  	bool_and_list(b::rest) => false

  rule	b = true &
	bool_and_list(rest) => res
	---------------------
  	bool_and_list(b::rest) => res
end

(** relation: bool_string
 ** Takes a boolean value and returns a string representation of the boolean value.
 ** For example,
 ** bool_string(true) => "true"
 **)
relation bool_string: bool => string =
  axiom	bool_string true => "true"
  axiom	bool_string false => "false"
end

(** relation: string_equal
 ** Takes two strings and returns true if the strings are equal
 ** For example,
 ** string_equal("a","a") => true
 **)
relation string_equal: (string,string) => bool =
  rule	a = b
	-----
	string_equal(a,b) => true

  axiom	string_equal(_,_) => false

end

(** relation: list_matching
 ** For example,
 ** Takes a list of values and a matching relation over the values and returns a
 ** sub list of values for which the matching relation succeeds.
 ** For example,
 ** given relation is_numeric(string) => ()  which succeeds if the string is numeric.
 ** list_matching(["foo","1","bar","4"],is_numeric) => ["1","4"]
 **)
relation list_matching: ('a list, 'a => () )  => 'a list =

  axiom	list_matching ([],_) => []

  rule	cond(v) &
	list_matching (vl, cond) => vl'
	-------------------
	list_matching (v::vl, cond) => v::vl'

  rule	not cond(v) &
	list_matching (vl, cond) => vl'
	--------------------------
	list_matching (v::vl, cond) => vl'
end	

(** relation: apply_option
 ** Takes an option value and a relation over the value. 
 ** It returns in another option value, resulting 
 ** from the application of the relation on the value.
 ** For example,
 ** apply_option(SOME(1), int_string) => SOME("1")
 ** apply_option(NONE, int_string) => NONE
 **)
relation apply_option : ('a option,'a => 'b) => 'b option =

  axiom	apply_option(NONE,_) => NONE 

  rule	rel(a) => b
	-----------
	apply_option( SOME(a),rel) => SOME(b)
end

(** relation make_option
 ** Makes a value into value option, using SOME(value) 
 **)
relation make_option: 'a => 'a option =

	axiom make_option(v) => SOME(v)
end

(** relation: string_option
 ** author: PA
 **
 ** Returns string value or empty string from string option.
 **)
relation string_option: string option => string =

  axiom	string_option(NONE) => ""
  axiom	string_option(SOME(s)) => s 
end

(** relation: list_split
 ** Takes a list of values and an position value.
 ** The relation returns the list splitted into two lists at the position given as argument.
 ** For example,
 ** list_split([1,2,5,7],2) => ([1,2],[5,7])
 **)
relation list_split : ('a list, int) => ('a list, 'a list) =

  axiom list_split(a,0) => ([],a)
  
  rule	list_length(a) => length &
	int_gt(index,length) => true &
	print "Index out of bounds (greater than list length) in relation list_split\n"
	----------------
	list_split(a,index) => fail  

  rule	int_lt(index,0) => true &
	print "Index out of bounds (less than zero) in relation list_split\n"
	----------------
	list_split(a,index) => fail
	
  rule	int_ge(index,0) => true &
        list_length(a) => length &
	int_le(index,length) => true &	
	list_split2(a,[],index) => (b,c)
	----------------
	list_split(a,index) => (c,b) 
end

(** helper relation to list_split
 **)
relation list_split2 : ('a list, 'a list, int) => ('a list, 'a list) =
	
  rule	int_eq(index,0) => true
	------------------
	list_split2(a,b,index) => (a,b)


  rule	int_sub(index,1) => new_index &
	list_append(b,[a]) => c &
	list_split2(rest,c,new_index) =>(c,d)
	------------------
	list_split2(a::rest,b,index) => (c,d)
	
  rule	print "list_split2 failed\n"
	----------------
	list_split2(_,_,_) => fail 

end

(** relation: int_positive
 ** Returns true if integer value is positive (>= 0)
 **
 **)
relation int_positive: int => bool =

  rule	int_ge(v,0) => res
	--------------
	int_positive(v) => res
end

(** relation: option_to_list
 ** Returns an empty list for NONE and a list containing
 ** the one element for SOME. To use with list_append
 **)
relation option_to_list: 'a option => 'a list =

  axiom	option_to_list NONE => []

  axiom	option_to_list SOME(e) => [e]

end

(** relation: flatten_option
 ** Returns the second argument if NONE and
 ** the contents of SOME if SOME
 **)
relation flatten_option: ('a option, 'a) => 'a =

  axiom	flatten_option (NONE,n) => n

  axiom	flatten_option (SOME(c),n) => c

end

(** relation: is_empty_string
 **
 ** Returns true if string is the empty string.
 **)
relation is_empty_string : string => bool =

  axiom is_empty_string "" => true

  axiom is_empty_string _ => false

end

(** relation: is_not_empty_string
 **
 ** Returns true if string is not the empty string.
 **)
relation is_not_empty_string : string => bool =

  axiom is_not_empty_string "" => false

  axiom is_not_empty_string _ => true

end

(** relation: write_file_or_error_msg
 **
 ** This relation tries to write to a file and if it
 ** fails then it outputs "# Cannot write to file: <filename>." to 
 ** errorbuf
 **) 
relation write_file_or_error_msg:(string,(*filename*)
                                     string(*the string to be written*)
                                     ) => () =

  rule  System.write_file(filename,str) 
        --------------------------
        write_file_or_error_msg(filename,str) 
        
  rule  string_append_list(["# Cannot write to file: ",
                            filename,
                            "."]) => error_str &
        Print.print_error_buf(error_str)
        --------------------------
        write_file_or_error_msg(filename,str) 

end
   
(** this relation executes a command with System.system_call 
 ** if System.system_call does not return 0 then the msg is outputed to
 ** error_buf and the relation fails
 **)
relation system_call_with_error_msg:(string,(*command*)
                                     string)(*error_msg to error_buf if fail*) => () =

  rule  System.system_call(s_call) => 0
        ------------------------------
        system_call_with_error_msg(s_call,_) 

  rule  Print.print_error_buf(e_msg) 
        ------------------------------
        system_call_with_error_msg(_,e_msg) => fail

end

(** relation: charlistcompare
 **
 ** Compares two char lists up to the nth potision and
 ** returns true if they are equal.
 **)        
relation charlistcompare: (char list, char list, int) => bool =

  rule	a = b
	-------------------
	charlistcompare(a::_,b::_,1) => true

  rule	not a = b
	------------
	charlistcompare(a::_,b::_,1) => false

  rule	int_sub(n,1) => n1 &
	a = b &
	charlistcompare(l1,l2,n1) => true
	-------------------------------------
	charlistcompare(a::l1,b::l2,n) => true
	
  axiom	charlistcompare(_,_,_) => false

end

(** relation: strncmp
 **
 ** Comparse two strings up to the nth character
 ** Returns true if they are equal.
 **)
relation strncmp: (string,string,int)=>bool =

  rule	string_list(s1) => clst1 &
	string_list(s2) => clst2 &
	string_length(s1) => s1len &
	string_length(s2) => s2len &
	int_ge(s1len,n) => true &
	int_ge(s2len,n) => true &
	charlistcompare(clst1,clst2,n) => true
	-------------------------------------
	strncmp (s1,s2,n) => true
	axiom strncmp(_,_,_) => false
end

(** relation: tick_str
 ** author: PA
 **
 ** Returns tick as a string, i.e. an unique number.
 **)
relation tick_str:() => string =

  rule	tick() => i &
	int_string(i) => s 
	------------------
	tick_str() => s
end

(** relation get_absolute_directory_and_file
 ** author: x02lucpo
 **
 ** splits the filepath in directory and filename
 ** ("c:\programs\file.mo") => ("c:\programs","file.mo")
 ** ("..\work\file.mo") => ("c:\openmodelica123\work\", "file.mo")
 **)

relation get_absolute_directory_and_file:(string) => (string,string) =

  rule  System.path_delimiter() => pd &
        string_list(pd) => pd_chr::[] &
        (*same dir only filename as param*) 
        string_split_at_char(file,pd_chr) => list_path::[] &
        System.pwd() => res 
        -------------------------
        get_absolute_directory_and_file(file) => (res,list_path)

  rule   System.path_delimiter() => pd &
        string_list(pd) => pd_chr::[] &
        string_split_at_char(file,pd_chr) => list_path &
        list_last(list_path) => file_path &
        list_strip_last(list_path) => list_path' &
        string_delimit_list(list_path',pd) => dir_path &
        System.pwd() => current_dir &
        
        System.cd(dir_path) => 0 &
        System.pwd() => res &
        System.cd(current_dir) => 0
        -------------------------
        get_absolute_directory_and_file(file) => (res,file_path)

  rule   Debug.fprint("failtrace",  "-get_absolute_directory_and_file  failed")
        -------------------------
        get_absolute_directory_and_file(name) => fail

end


