(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 VarTransform.rml
 ** module:      VarTransform
 ** description: VarTransform contains a Binary Tree representation of variable replacements.
 **
 ** RCS: $Id$
 ** 
 **)

(** 
 ** This module contain a Binary tree representation of variable replacements
 ** along with some relations for performing replacements of variables in equations
**)

module VarTransform:
 with "Exp.rml"
 with "DAELow.rml"


 datatype VariableReplacements = REPLACEMENTS of
				BinTree * (* src -> dst, used for replacing *)
				BinTree2 (* dst->src, used for lookup to make 
					  rules transitive. A destination can 
					  have several sources, therefore 
					  another BinTree *)

 datatype BinTree = TREENODE of TreeValue option * (* Value *)
				BinTree option * (* left subtree *)
				BinTree option (* right subtree *)

 datatype BinTree2 = TREENODE2 of TreeValue2 option * (* Value *)
				BinTree2 option * (* left subtree *)
				BinTree2 option (* right subtree *)

(* Each node in the binary tree can have a value associated with it.*)

  datatype TreeValue = TREEVALUE of Key (* Key *)
				* Value (* Value *)

  datatype TreeValue2 = TREEVALUE2 of Key (* Key *)
				* Value2 (* Value *)

  type Key = Exp.ComponentRef

  type Value = Exp.ComponentRef

  type Value2 = Exp.ComponentRef list

relation empty_replacements:() => VariableReplacements

relation add_replacement:(VariableReplacements,Exp.ComponentRef, Exp.ComponentRef) 
	  => VariableReplacements

relation get_replacement:(VariableReplacements, Exp.ComponentRef) => Exp.ComponentRef

relation replace_exp:(Exp.Exp,VariableReplacements) => Exp.Exp 

relation apply_replacements: (VariableReplacements, Exp.ComponentRef, Exp.ComponentRef) 
	=> (Exp.ComponentRef, Exp.ComponentRef)

relation replace_equations:(DAELow.Equation list,VariableReplacements) => DAELow.Equation list

relation dump_replacements: (VariableReplacements) => ()

end
with "System.rml" 
with "Util.rml" 
with "Algorithm.rml"

(** relation: apply_replacements
 **
 ** This relation takes a VariableReplacements and two component references.
 ** It applies the replacements to each component reference.
 **)
relation apply_replacements: (VariableReplacements, 
			      Exp.ComponentRef, 
			      Exp.ComponentRef) 
	=> (Exp.ComponentRef, Exp.ComponentRef) =

  rule	replace_exp(Exp.CREF(cr1,Exp.REAL),repl) => (Exp.CREF(cr1',_)) &
	replace_exp(Exp.CREF(cr2,Exp.REAL),repl) => (Exp.CREF(cr2',_))	
	----------------------------------------------------------------------
	apply_replacements(repl, cr1, cr2) => (cr1', cr2') 
end


(** relation: empty_replacements
 **
 ** Returns an empty set of replacement rules
 **)

relation empty_replacements:()=> VariableReplacements =

  axiom	 empty_replacements() => REPLACEMENTS(TREENODE(NONE,NONE,NONE),
					      TREENODE2(NONE,NONE,NONE))
end

(** relation: replace_equations
 **
 ** This relation takes a list of equations ana a set of variable replacements
 ** and applies the replacements on all equations.
 ** The relation returns the updated list of equations
 **)

relation replace_equations:(DAELow.Equation list,VariableReplacements) 
	  => DAELow.Equation list =

axiom replace_equations([],_) => []

  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' &
	replace_equations(es,repl) => es'
	---------------------------------
	replace_equations(DAELow.EQUATION(e1,e2)::es,repl) 
	  => DAELow.EQUATION(e1',e2')::es'

  rule	replace_equations(es,repl) => es'
	---------------------------------
	replace_equations((a as DAELow.ALGORITHM(_,_,_))::es,repl) 
	  => a::es'

  rule	replace_exp(e,repl) => e' &
	replace_equations(es,repl) => es'
	-----------------------
	replace_equations(DAELow.SOLVED_EQUATION(cr,e)::es,repl) 
	  => DAELow.SOLVED_EQUATION(cr,e')::es'

  rule	replace_exp(e,repl) => e' &
	replace_equations(es,repl) => es'
	-----------------------
	replace_equations(DAELow.RESIDUAL_EQUATION(e)::es,repl) 
	  => DAELow.RESIDUAL_EQUATION(e')::es'

  rule	replace_equations(es,repl) => es'
	---------------------------------
	replace_equations(a::es,repl) 
	  => a::es'
end

(** relation: replace_equations_stmts
 **
 ** Helper relation to replace_equations
 **)

relation replace_equations_stmts: (Algorithm.Statement list, VariableReplacements) 
	  => Algorithm.Statement list =
  axiom	replace_equations_stmts ([],_) => []

  rule	replace_exp(e,repl) => e' &
	replace_exp(Exp.CREF(cr,Exp.OTHER),repl) => Exp.CREF(cr',_) &
	replace_equations_stmts(xs,repl) => xs'
	---------------------------------------
	replace_equations_stmts(Algorithm.ASSIGN(tp,cr,e)::xs,repl) 
	  => Algorithm.ASSIGN(tp,cr',e')::xs'

  rule	print "Warning, not implemented in replace_equations_stmts\n" &
	replace_equations_stmts(xs,repl) => xs'
	------------------
	replace_equations_stmts(x::xs,repl) => x::xs'

end

(** relation: dump_replacements 
 ** 
 ** Prints the variable replacements on form var1 -> var2
 **)

relation dump_replacements: (VariableReplacements) => () =

  rule	
	bintree_to_explist(bt) => (srcs, dsts) &
	Util.list_map(srcs,Exp.print_exp_str) => srcstrs &
	Util.list_map(dsts,Exp.print_exp_str) => dststrs &
	Util.list_map_1(dststrs,string_append,"\n") => dststrs' &
	Util.list_thread(srcstrs,dststrs') => strs &
	Util.string_delimit_list(strs," -> ") => str &
	print "Replacements: (" &
	list_length(srcs) => len &
	int_string(len) => len_str &
	print len_str & print ")\n" &
	print "=============\n" &
	print str & print "\n" 
	-------------------------------
	dump_replacements(REPLACEMENTS(bt,_)) => ()

end

(** relation: add_replacement
 **
 ** Adds a replacement rule to the set of replacement rules given as argument.
 ** If a replacement rule a->b already exists and we add a new rule b->c then
 ** the rule a->b is updated to a->c. This is done using the make_transitive
 ** relation.
 **)
	    
relation add_replacement: (VariableReplacements,
			   Exp.ComponentRef, (* source *) 
			   Exp.ComponentRef) (* dest *)
	  => VariableReplacements =

  rule	(** if rule a->b exists, fail
	 **)
	tree_get(bt,src) => olddst 
	-----------------------
	add_replacement(repl as REPLACEMENTS(bt,invbt),src,dst) 
	  => fail

  rule	make_transitive(repl,src,dst) => (REPLACEMENTS(bt,invbt),src',dst') &
	tree_add(bt,src',dst') => bt' &
	add_replacement_inv(invbt,src',dst') => invbt' 
	---------------------------
	add_replacement(repl as REPLACEMENTS(bt,invbt),src,dst) 
	  => REPLACEMENTS(bt',invbt')

  rule	print "-add_replacement failed\n" 
	---------------------------------
	add_replacement(_,_,_) => fail
end

(** relation: add_replacement_inv
 **
 ** Helper relation to add_replacement_inv
 ** Adds the inverse rule of a replacement to the second binary tree
 ** of VariableReplacements.
 **)

relation add_replacement_inv: (BinTree2, Exp.ComponentRef, Exp.ComponentRef)
	=> BinTree2 =

  rule	(* No previous elt for dst -> src *)
	not tree_get2(invbt,dst) => _ &  
	tree_add2(invbt,dst,[src]) => invbt' 
	-------------------
	add_replacement_inv(invbt,src,dst) => invbt' 
	

  rule	(* previous elt for dst -> src, append.. *)
	tree_get2(invbt,dst) => srcs &
	tree_add2(invbt,dst,src::srcs) => invbt'
	-----------------------
	add_replacement_inv(invbt,src,dst) => invbt'
end
	  

(** relation: make_transitive
 **
 ** This relation takes a set of replacement rules and a new replacement rule
 ** in the form of two ComponentRef:s and makes sure the new replacement rule
 ** is replaced with the transitive value.
 ** For example, if we have the rule a->b and a new rule c->a it is changed to c->b.
 ** Also, if we have a rule a->b and a new rule b->c then the -old- rule a->b is changed
 ** to a->c
**)

relation make_transitive: (VariableReplacements,	(* replacement rules *)
			   Exp.ComponentRef,		(*src*) 
			   Exp.ComponentRef)		(*dst*)
	  => (VariableReplacements,			(* updated replacement rules *)
	      Exp.ComponentRef,		(* src*) 
	      Exp.ComponentRef) =	(* updated dst *)   

  rule	make_transitive1(repl,src,dst) => (repl',src',dst') &
	make_transitive2(repl',src',dst') => (repl'',src'',dst'') 
	------------------
	make_transitive(repl,src,dst) => (repl'',src'',dst'')
end

(** relation: make_transitive1
 **
 ** helper relation to make_transitive
 **)

relation make_transitive1: (VariableReplacements,	(* replacement rules *)
			   Exp.ComponentRef,		(*src*) 
			   Exp.ComponentRef)		(*dst*)
	  => (VariableReplacements,			(* updated replacement rules *)
	      Exp.ComponentRef,		(* src*) 
	      Exp.ComponentRef) =	(* updated dst *)   

  rule	(* old rule a->b must be updated to a->c when new rule b->c introduced*)
	tree_get2(invbt,src) => lst &
	add_replacements(repl,lst,dst) => repl' 
	---------------------------------------
	make_transitive1(repl as REPLACEMENTS(bt,invbt),src,dst) 
	  => (repl',src,dst)

  axiom	make_transitive1(repl,src,dst) => (repl,src,dst)
end

(** relation: make_transitive2
 **
 ** Helper relation to make_transitive
**)
relation make_transitive2: (VariableReplacements,	(* replacement rules *)
			   Exp.ComponentRef,		(*src*) 
			   Exp.ComponentRef)		(*dst*)
	  => (VariableReplacements,			(* updated replacement rules *)
	      Exp.ComponentRef,		(* src*) 
	      Exp.ComponentRef) =	(* updated dst *)   
	
  rule	(* If dst has own replacement rule, change to its destintation and recurse *)
	tree_get(bt,dst) => newdst &
	make_transitive2(repl,src,newdst) => (repl',src',dst')
	-----------------------------------------------
	make_transitive2(repl as REPLACEMENTS(bt,invbt),src,dst) 
	  => (repl',src',dst')

	  (* dst has no own replacement, return *)
  axiom	make_transitive2(repl,src,dst) => (repl,src,dst)
end

(** relation: add_replacements
 **
 ** Adding of several replacements at once with common destination.
 ** Uses add_replacement
**)

relation add_replacements: (VariableReplacements, Exp.ComponentRef list, Exp.ComponentRef) 
	  => VariableReplacements =

  axiom	add_replacements(repl,[],_) => repl

  rule	add_replacement(repl,src,dst) => repl' &
	add_replacements(repl',srcs,dst) => repl''
	------------------------------------------
	add_replacements(repl,src::srcs,dst) => repl''

  rule	print "add_replacements failed\n" 
	---------------------------------
	add_replacements(_,_,_) => fail 
end

(** relation: get_replacement
 **
 ** Retrives a replacement variable given a set of replacement rules and a 
 ** source variable.
 **)

relation get_replacement:(VariableReplacements, Exp.ComponentRef) 
	  => Exp.ComponentRef =

  rule	tree_get(bt,src) => dst
	-----------------------
	get_replacement(REPLACEMENTS(bt,invbt),src) => dst
end

(** relation: replace_exp
 **
 ** Takes a set of replacement rules and an expression
 ** and replaces all variables in the expression using 
 ** the replacement rules.
 **)

relation replace_exp:(Exp.Exp,VariableReplacements) => Exp.Exp =
	 
  rule	get_replacement(repl,cr) => cr' 
	------------------------------
	replace_exp(Exp.CREF(cr,t),repl) 
	  => Exp.CREF(cr',t)

  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' 
	------------------------------------
	replace_exp(Exp.BINARY(e1,op,e2),repl) 
	  => Exp.BINARY(e1',op,e2')
	  
  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' 
	------------------------------------
	replace_exp(Exp.LBINARY(e1,op,e2),repl) 
	  => Exp.LBINARY(e1',op,e2')

  rule	replace_exp(e1,repl) => e1'
	------------------------------------
	replace_exp(Exp.UNARY(op,e1),repl) 
	  => Exp.UNARY(op,e1')

  rule	replace_exp(e1,repl) => e1'
	------------------------------------
	replace_exp(Exp.LUNARY(op,e1),repl) 
	  => Exp.LUNARY(op,e1')


  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' 
	------------------------------------
	replace_exp(Exp.RELATION(e1,op,e2),repl) 
	  => Exp.RELATION(e1',op,e2')

  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' &
	replace_exp(e3,repl) => e3' 
	------------------------------------
	replace_exp(Exp.IFEXP(e1,e2,e3),repl) 
	  => Exp.IFEXP(e1',e2',e3')

  rule  Util.list_map_1(expl,replace_exp,repl) => expl' 
	-----------------------------------------------
	replace_exp(Exp.CALL(path,expl,t,c),repl) 
	  => Exp.CALL(path,expl',t,c)

  rule	Util.list_map_1(expl,replace_exp,repl) => expl' 
	----------------------------------------------
	replace_exp(Exp.ARRAY(tp,c,expl),repl) 
	  => Exp.ARRAY(tp,c,expl')

  rule	print "replace_exp for matrix not impl." 
	-----------------------------------------------
	replace_exp(Exp.MATRIX(a,b,c),repl) 
	  => Exp.MATRIX(a,b,c)

  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' 
	-----------------------------------------------
	replace_exp(Exp.RANGE(tp,e1,NONE,e2),repl) 
	  => Exp.RANGE(tp,e1',NONE,e2')

  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' &
	replace_exp(e3,repl) => e3' 
	-----------------------------------------------
	replace_exp(Exp.RANGE(tp,e1,SOME(e3),e2),repl) 
	  => Exp.RANGE(tp,e1',SOME(e3'),e2')

  rule	Util.list_map_1(expl,replace_exp,repl) => expl'
	-----------------------------------------------
	replace_exp(Exp.TUPLE(expl),repl) 
	  => Exp.TUPLE(expl')

  rule	replace_exp(e1,repl) => e1'
	-----------------------------------------------
	replace_exp(Exp.CAST(tp,e1),repl) 
	  => Exp.CAST(tp,e1')

  rule	replace_exp(e1,repl) => e1' 
	-----------------------------------------------
	replace_exp(Exp.ASUB(e1,i),repl)
	  => Exp.ASUB(e1',i)

  rule	replace_exp(e1,repl) => e1'
	-----------------------------------------------
	replace_exp(Exp.SIZE(e1,NONE),repl) 
	  => Exp.SIZE(e1',NONE)

  rule	replace_exp(e1,repl) => e1' &
	replace_exp(e2,repl) => e2' 
	-----------------------------------------------
	replace_exp(Exp.SIZE(e1,SOME(e2)),repl) 
	  => Exp.SIZE(e1',SOME(e2'))

  rule	print "replace_exp on CODE not impl.\n" 
	-----------------------------------------------
	replace_exp(Exp.CODE(a,b),repl) 
	  => Exp.CODE(a,b)

  rule	replace_exp(e,repl) => e' &
	replace_exp(r,repl) => r' 
	-----------------------------------------------
	replace_exp(Exp.REDUCTION(p,e,id,r),repl) 
	  => Exp.REDUCTION(p,e',id,r')

 axiom	replace_exp(e,repl) => e
end

(** relation: bintree_to_list
 **
 ** This relation takes a BinTree and transform it into a list
 ** representation, i.e. two lists of keys and values
 **)

 relation bintree_to_explist: (BinTree) => (Exp.Exp list, Exp.Exp list) =

  rule	bintree_to_explist2(bt,[],[]) => (klst,vlst) 
	------------------------------------------
	bintree_to_explist(bt) => (klst,vlst)
end

(** relation: bintree_to_list2
 **
 ** helper relation to bintree_to_list
 **)

relation bintree_to_explist2: (BinTree,Exp.Exp list,Exp.Exp list ) 
	  => (Exp.Exp list, Exp.Exp list) =

 axiom	bintree_to_explist2( TREENODE(NONE,NONE,NONE),klst,vlst) => (klst,vlst)
 
  rule	bintree_to_explist_opt(left,klst,vlst) => (klst,vlst) &
	bintree_to_explist_opt(right,klst,vlst) => (klst,vlst) 
	------------------
	bintree_to_explist2(TREENODE(SOME(TREEVALUE(key,value)),left,right),klst,vlst)
	  => (Exp.CREF(key,Exp.REAL)::klst,Exp.CREF(value,Exp.REAL)::vlst) 
	  
  rule	bintree_to_explist_opt(left,klst,vlst) => (klst,vlst) &
	bintree_to_explist_opt(left,klst,vlst) => (klst,vlst) 
	--------------------------------------------------
	bintree_to_explist2(TREENODE(NONE,left,right),klst,vlst) => (klst,vlst)
end

(** relation: bintree_to_list_opt
 **
 ** helper relation to bintree_to_list
 **)

relation bintree_to_explist_opt: (BinTree option, Exp.Exp list, Exp.Exp list) 
	  => (Exp.Exp list, Exp.Exp list) =

  axiom	bintree_to_explist_opt(NONE,klst,vlst) => (klst,vlst)

  rule	bintree_to_explist2(bt,klst,vlst) => (klst,vlst) 
	---------------------------------------------
	bintree_to_explist_opt(SOME(bt),klst,vlst) => (klst,vlst)
end
	
(** relation: tree_get
 **
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string can not be uniquely mapped to an int. Therefore we need to 
 ** compare two strings to get a unique ordering.
**)

relation tree_get: (BinTree, Key) => Value =
 
 rule	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr &
	System.strcmp(rkeystr,keystr) => 0 
	----------------------------------
	tree_get (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right), key)
	   => rval

  rule	(* Search to the right*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_get(right,key) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right)),key)
	  => res

  rule	(* Search to the left*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => false &
	tree_get(left,key) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left),right),key)
	  => res
	
(*  rule	print "tree_get failed\n" 
	---------------
	tree_get(_,_,_) => fail*)
end

(** relation: tree_add
 **
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string (ComponentRef) can not be uniquely mapped to an int. 
 ** Therefore we need to compare two strings to get a unique ordering.
**)

relation tree_add: (BinTree, Key, Value) => (BinTree) =

  axiom	tree_add (TREENODE(NONE,NONE,NONE),key,value) 
	  => TREENODE(SOME(TREEVALUE(key,value)),NONE,NONE)

  rule	(* Replace this node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0
	----------------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),key,value)
	  => (TREENODE(SOME(TREEVALUE(rkey,value)),left,right))

  rule	(* Insert to right subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_add(t,key,value) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(t')))

  rule	(* Insert to right node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true & 
	tree_add(TREENODE(NONE,NONE,NONE),key,value) => right'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as NONE),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right')))

  rule	(* Insert to left subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add(t,key,value) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(t'),right))

  rule	(* Insert to left node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add(TREENODE(NONE,NONE,NONE),key,value) => left'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as NONE,right),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left'),right))

  rule	print "tree_add failed\n"
	-----------------------
	tree_add(_,_,_) => fail
 end 

(** relation: tree_get2
 **
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string can not be uniquely mapped to an int. Therefore we need 
 ** to compare two strings to get a unique ordering.
**)

relation tree_get2: (BinTree2, Key) => Value2 =
 
 rule	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr &
	System.strcmp(rkeystr,keystr) => 0 
	----------------------------------
	tree_get2 (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,right), key)
	   => rval

  rule	(* Search to the right*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_get2(right,key) => res
	--------------------
	tree_get2(TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,SOME(right)),key)
	  => res

  rule	(* Search to the left*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => false &
	tree_get2(left,key) => res
	--------------------
	tree_get2(TREENODE2(SOME(TREEVALUE2(rkey,rval)),SOME(left),right),key)
	  => res
	
(*  rule	print "tree_get failed\n" 
	---------------
	tree_get2(_,_,_) => fail*)
end

(** relation: tree_add2
 **
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string (ComponentRef) can not be uniquely mapped to an int.
 ** Therefore we need to compare two strings to get a unique ordering.
**)

relation tree_add2: (BinTree2, Key, Value2) => (BinTree2) =

  axiom	tree_add2 (TREENODE2(NONE,NONE,NONE),key,value) 
	  => TREENODE2(SOME(TREEVALUE2(key,value)),NONE,NONE)

  rule	(* Replace this node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0
	----------------------------------
	tree_add2 (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,right),key,value)
	  => (TREENODE2(SOME(TREEVALUE2(rkey,value)),left,right))

  rule	(* Insert to right subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_add2(t,key,value) => t'
	------------------------
	tree_add2 (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,right as SOME(t)),key,value) 
	  => (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,SOME(t')))

  rule	(* Insert to right node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true & 
	tree_add2(TREENODE2(NONE,NONE,NONE),key,value) => right'
	------------------------
	tree_add2 (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,right as NONE),key,value) 
	  => (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left,SOME(right')))

  rule	(* Insert to left subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add2(t,key,value) => t'
	------------------------
	tree_add2 (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left as SOME(t),right),key,value) 
	  => (TREENODE2(SOME(TREEVALUE2(rkey,rval)),SOME(t'),right))

  rule	(* Insert to left node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add2(TREENODE2(NONE,NONE,NONE),key,value) => left'
	------------------------
	tree_add2 (TREENODE2(SOME(TREEVALUE2(rkey,rval)),left as NONE,right),key,value) 
	  => (TREENODE2(SOME(TREEVALUE2(rkey,rval)),SOME(left'),right))

  rule	print "tree_add2 failed\n"
	-----------------------
	tree_add2(_,_,_) => fail
 end 
