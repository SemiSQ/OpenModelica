// Simulation code for Influenza generated by the OpenModelica Compiler.
#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
  #define DLLExport   __declspec( dllexport ) 
#else 
  #define DLLExport /* nothing */
#endif 

#include "Influenza_functions.cpp"

extern "C" {

}

#define NHELP 0
#define NG 1//number of zero crossing
#define NX 3
#define NY 55
#define NP 11 // number of parameters
#define NO 26 // number of outputvar on topmodel
#define NI 1 // number of inputvar on topmodel
#define NR 60 // number of residuals for initialialization function
#define NEXT 0 // number of external objects
#define MAXORD 5
#define NYSTR 0 // number of alg. string variables
#define NPSTR 0 // number of alg. string variables

static DATA* localData = 0;
#define time localData->timeValue
extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
  char *model_name="Influenza";
  char *model_dir="";
}
char* state_names[3]={"Non_Infected_Popul.p", "Infected_Popul.p", "Sick_Popul.p"};
char* derivative_names[3]={"der(Non_Infected_Popul.p)", "der(Infected_Popul.p)", "der(Sick_Popul.p)"};
char* algvars_names[55]={"der(Activation.out_1)", "der(Immune_Popul.p)", "Immune_Popul.in_2", "Immune_Popul.p", "Incubation.out_1", "Activation.out_1", "Perc_Infected.out_1", "Contagious_Popul.out_1", "Non_Contagious_Popul.out_1", "Total_Popul.out_1", "Temp3.out_1", "Contacts_Wk.out_1", "Temp1.out_1", "Temp2.out_1", "Infection_Rate.out_1", "Introduction", "Immune_Popul.in_1", "Immune_Popul.out_1", "Non_Infected_Popul.in_1", "Non_Infected_Popul.in_2", "Non_Infected_Popul.out_1", "Infected_Popul.in_1", "Infected_Popul.in_2", "Infected_Popul.out_1", "Sick_Popul.in_1", "Sick_Popul.in_2", "Sick_Popul.out_1", "Incubation.in_1", "Incubation.in_2", "Cure_Rate.in_1", "Cure_Rate.in_2", "Cure_Rate.out_1", "Activation.in_1", "Activation.in_2", "Perc_Infected.in_1", "Perc_Infected.in_2", "Time_to_Breakdown.out_1", "Sickness_Duration.out_1", "Contraction_Rate.out_1", "Immune_Period.out_1", "Contagious_Popul.in_1", "Contagious_Popul.in_2", "Non_Contagious_Popul.in_1", "Non_Contagious_Popul.in_2", "Total_Popul.in_1", "Total_Popul.in_2", "Temp3.in_1", "Temp3.in_2", "Contacts_Wk.in_1", "Temp1.in_1", "Temp1.in_2", "Temp2.in_1", "Temp2.in_2", "Infection_Rate.in_1", "Infection_Rate.in_2"};
char* input_names[1]={"Introduction"};
char* output_names[26]={"Immune_Period.out_1", "Contraction_Rate.out_1", "Sickness_Duration.out_1", "Time_to_Breakdown.out_1", "Cure_Rate.out_1", "Sick_Popul.out_1", "Infected_Popul.out_1", "Non_Infected_Popul.out_1", "Immune_Popul.out_1", "Infection_Rate.out_1", "Temp2.out_1", "Temp1.out_1", "Contacts_Wk.out_1", "Temp3.out_1", "Total_Popul.out_1", "Non_Contagious_Popul.out_1", "Contagious_Popul.out_1", "Perc_Infected.out_1", "Activation.out_1", "Incubation.out_1", "Sick_Popul.p", "Infected_Popul.p", "Non_Infected_Popul.p", "Immune_Popul.p", "der(Immune_Popul.p)", "der(Activation.out_1)"};
char* param_names[11]={"Incubation.c", "Cure_Rate.c", "Activation.c", "Perc_Infected.c", "Time_to_Breakdown.c", "Sickness_Duration.c", "Contraction_Rate.c", "Immune_Period.c", "Contacts_Wk.c", "Temp1.c", "Temp2.c"};
char* string_alg_names[1] = {""};
char* string_param_names[1] = {""};

char* state_comments[3]={"", "", ""};
char* derivative_comments[3]={"", "", ""};
char* algvars_comments[55]={"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""};
char* input_comments[1]={""};
char* output_comments[26]={"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""};
char* param_comments[11]={"", "", "", "", "", "", "", "", "", "", ""};
char* string_param_comments[11]={"", "", "", "", "", "", "", "", "", "", ""};
char* string_alg_comments[11]={"", "", "", "", "", "", "", "", "", "", ""};

#define $Infection_Rate$Pin_2 localData->algebraics[54]
#define $Infection_Rate$Pin_1 localData->algebraics[53]
#define $Temp2$Pin_2 localData->algebraics[52]
#define $Temp2$Pin_1 localData->algebraics[51]
#define $Temp1$Pin_2 localData->algebraics[50]
#define $Temp1$Pin_1 localData->algebraics[49]
#define $Contacts_Wk$Pin_1 localData->algebraics[48]
#define $Temp3$Pin_2 localData->algebraics[47]
#define $Temp3$Pin_1 localData->algebraics[46]
#define $Total_Popul$Pin_2 localData->algebraics[45]
#define $Total_Popul$Pin_1 localData->algebraics[44]
#define $Non_Contagious_Popul$Pin_2 localData->algebraics[43]
#define $Non_Contagious_Popul$Pin_1 localData->algebraics[42]
#define $Contagious_Popul$Pin_2 localData->algebraics[41]
#define $Contagious_Popul$Pin_1 localData->algebraics[40]
#define $Immune_Period$Pout_1 localData->algebraics[39]
#define $Contraction_Rate$Pout_1 localData->algebraics[38]
#define $Sickness_Duration$Pout_1 localData->algebraics[37]
#define $Time_to_Breakdown$Pout_1 localData->algebraics[36]
#define $Perc_Infected$Pin_2 localData->algebraics[35]
#define $Perc_Infected$Pin_1 localData->algebraics[34]
#define $Activation$Pin_2 localData->algebraics[33]
#define $Activation$Pin_1 localData->algebraics[32]
#define $Cure_Rate$Pout_1 localData->algebraics[31]
#define $Cure_Rate$Pin_2 localData->algebraics[30]
#define $Cure_Rate$Pin_1 localData->algebraics[29]
#define $Incubation$Pin_2 localData->algebraics[28]
#define $Incubation$Pin_1 localData->algebraics[27]
#define $Sick_Popul$Pout_1 localData->algebraics[26]
#define $Sick_Popul$Pin_2 localData->algebraics[25]
#define $Sick_Popul$Pin_1 localData->algebraics[24]
#define $Infected_Popul$Pout_1 localData->algebraics[23]
#define $Infected_Popul$Pin_2 localData->algebraics[22]
#define $Infected_Popul$Pin_1 localData->algebraics[21]
#define $Non_Infected_Popul$Pout_1 localData->algebraics[20]
#define $Non_Infected_Popul$Pin_2 localData->algebraics[19]
#define $Non_Infected_Popul$Pin_1 localData->algebraics[18]
#define $Immune_Popul$Pout_1 localData->algebraics[17]
#define $Immune_Popul$Pin_1 localData->algebraics[16]
#define $Temp2$Pc localData->parameters[10]
#define $Temp1$Pc localData->parameters[9]
#define $Contacts_Wk$Pc localData->parameters[8]
#define $Immune_Period$Pc localData->parameters[7]
#define $Contraction_Rate$Pc localData->parameters[6]
#define $Sickness_Duration$Pc localData->parameters[5]
#define $Time_to_Breakdown$Pc localData->parameters[4]
#define $Perc_Infected$Pc localData->parameters[3]
#define $Activation$Pc localData->parameters[2]
#define $Cure_Rate$Pc localData->parameters[1]
#define $Incubation$Pc localData->parameters[0]
#define $Introduction localData->algebraics[15]
#define $Infection_Rate$Pout_1 localData->algebraics[14]
#define $Temp2$Pout_1 localData->algebraics[13]
#define $Temp1$Pout_1 localData->algebraics[12]
#define $Contacts_Wk$Pout_1 localData->algebraics[11]
#define $Temp3$Pout_1 localData->algebraics[10]
#define $Total_Popul$Pout_1 localData->algebraics[9]
#define $Non_Contagious_Popul$Pout_1 localData->algebraics[8]
#define $Contagious_Popul$Pout_1 localData->algebraics[7]
#define $Perc_Infected$Pout_1 localData->algebraics[6]
#define $Activation$Pout_1 localData->algebraics[5]
#define $Incubation$Pout_1 localData->algebraics[4]
#define $Sick_Popul$Pp localData->states[2]
#define $DER$Sick_Popul$Pp localData->statesDerivatives[2]
#define $Infected_Popul$Pp localData->states[1]
#define $DER$Infected_Popul$Pp localData->statesDerivatives[1]
#define $Non_Infected_Popul$Pp localData->states[0]
#define $DER$Non_Infected_Popul$Pp localData->statesDerivatives[0]
#define $Immune_Popul$Pp localData->algebraics[3]
#define $Immune_Popul$Pin_2 localData->algebraics[2]
#define $DER$Immune_Popul$Pp localData->algebraics[1]
#define $DER$Activation$Pout_1 localData->algebraics[0]

char* getName( double* ptr)
{
  if( &$Infection_Rate$Pin_2 == ptr ) return algvars_names[54];
  if( &$Infection_Rate$Pin_1 == ptr ) return algvars_names[53];
  if( &$Temp2$Pin_2 == ptr ) return algvars_names[52];
  if( &$Temp2$Pin_1 == ptr ) return algvars_names[51];
  if( &$Temp1$Pin_2 == ptr ) return algvars_names[50];
  if( &$Temp1$Pin_1 == ptr ) return algvars_names[49];
  if( &$Contacts_Wk$Pin_1 == ptr ) return algvars_names[48];
  if( &$Temp3$Pin_2 == ptr ) return algvars_names[47];
  if( &$Temp3$Pin_1 == ptr ) return algvars_names[46];
  if( &$Total_Popul$Pin_2 == ptr ) return algvars_names[45];
  if( &$Total_Popul$Pin_1 == ptr ) return algvars_names[44];
  if( &$Non_Contagious_Popul$Pin_2 == ptr ) return algvars_names[43];
  if( &$Non_Contagious_Popul$Pin_1 == ptr ) return algvars_names[42];
  if( &$Contagious_Popul$Pin_2 == ptr ) return algvars_names[41];
  if( &$Contagious_Popul$Pin_1 == ptr ) return algvars_names[40];
  if( &$Immune_Period$Pout_1 == ptr ) return output_names[25];
  if( &$Immune_Period$Pout_1 == ptr ) return algvars_names[39];
  if( &$Contraction_Rate$Pout_1 == ptr ) return output_names[24];
  if( &$Contraction_Rate$Pout_1 == ptr ) return algvars_names[38];
  if( &$Sickness_Duration$Pout_1 == ptr ) return output_names[23];
  if( &$Sickness_Duration$Pout_1 == ptr ) return algvars_names[37];
  if( &$Time_to_Breakdown$Pout_1 == ptr ) return output_names[22];
  if( &$Time_to_Breakdown$Pout_1 == ptr ) return algvars_names[36];
  if( &$Perc_Infected$Pin_2 == ptr ) return algvars_names[35];
  if( &$Perc_Infected$Pin_1 == ptr ) return algvars_names[34];
  if( &$Activation$Pin_2 == ptr ) return algvars_names[33];
  if( &$Activation$Pin_1 == ptr ) return algvars_names[32];
  if( &$Cure_Rate$Pout_1 == ptr ) return output_names[21];
  if( &$Cure_Rate$Pout_1 == ptr ) return algvars_names[31];
  if( &$Cure_Rate$Pin_2 == ptr ) return algvars_names[30];
  if( &$Cure_Rate$Pin_1 == ptr ) return algvars_names[29];
  if( &$Incubation$Pin_2 == ptr ) return algvars_names[28];
  if( &$Incubation$Pin_1 == ptr ) return algvars_names[27];
  if( &$Sick_Popul$Pout_1 == ptr ) return output_names[20];
  if( &$Sick_Popul$Pout_1 == ptr ) return algvars_names[26];
  if( &$Sick_Popul$Pin_2 == ptr ) return algvars_names[25];
  if( &$Sick_Popul$Pin_1 == ptr ) return algvars_names[24];
  if( &$Infected_Popul$Pout_1 == ptr ) return output_names[19];
  if( &$Infected_Popul$Pout_1 == ptr ) return algvars_names[23];
  if( &$Infected_Popul$Pin_2 == ptr ) return algvars_names[22];
  if( &$Infected_Popul$Pin_1 == ptr ) return algvars_names[21];
  if( &$Non_Infected_Popul$Pout_1 == ptr ) return output_names[18];
  if( &$Non_Infected_Popul$Pout_1 == ptr ) return algvars_names[20];
  if( &$Non_Infected_Popul$Pin_2 == ptr ) return algvars_names[19];
  if( &$Non_Infected_Popul$Pin_1 == ptr ) return algvars_names[18];
  if( &$Immune_Popul$Pout_1 == ptr ) return output_names[17];
  if( &$Immune_Popul$Pout_1 == ptr ) return algvars_names[17];
  if( &$Immune_Popul$Pin_1 == ptr ) return algvars_names[16];
  if( &$Temp2$Pc == ptr ) return param_names[10];
  if( &$Temp1$Pc == ptr ) return param_names[9];
  if( &$Contacts_Wk$Pc == ptr ) return param_names[8];
  if( &$Immune_Period$Pc == ptr ) return param_names[7];
  if( &$Contraction_Rate$Pc == ptr ) return param_names[6];
  if( &$Sickness_Duration$Pc == ptr ) return param_names[5];
  if( &$Time_to_Breakdown$Pc == ptr ) return param_names[4];
  if( &$Perc_Infected$Pc == ptr ) return param_names[3];
  if( &$Activation$Pc == ptr ) return param_names[2];
  if( &$Cure_Rate$Pc == ptr ) return param_names[1];
  if( &$Incubation$Pc == ptr ) return param_names[0];
  if( &$Introduction == ptr ) return input_names[0];
  if( &$Introduction == ptr ) return algvars_names[15];
  if( &$Infection_Rate$Pout_1 == ptr ) return output_names[16];
  if( &$Infection_Rate$Pout_1 == ptr ) return algvars_names[14];
  if( &$Temp2$Pout_1 == ptr ) return output_names[15];
  if( &$Temp2$Pout_1 == ptr ) return algvars_names[13];
  if( &$Temp1$Pout_1 == ptr ) return output_names[14];
  if( &$Temp1$Pout_1 == ptr ) return algvars_names[12];
  if( &$Contacts_Wk$Pout_1 == ptr ) return output_names[13];
  if( &$Contacts_Wk$Pout_1 == ptr ) return algvars_names[11];
  if( &$Temp3$Pout_1 == ptr ) return output_names[12];
  if( &$Temp3$Pout_1 == ptr ) return algvars_names[10];
  if( &$Total_Popul$Pout_1 == ptr ) return output_names[11];
  if( &$Total_Popul$Pout_1 == ptr ) return algvars_names[9];
  if( &$Non_Contagious_Popul$Pout_1 == ptr ) return output_names[10];
  if( &$Non_Contagious_Popul$Pout_1 == ptr ) return algvars_names[8];
  if( &$Contagious_Popul$Pout_1 == ptr ) return output_names[9];
  if( &$Contagious_Popul$Pout_1 == ptr ) return algvars_names[7];
  if( &$Perc_Infected$Pout_1 == ptr ) return output_names[8];
  if( &$Perc_Infected$Pout_1 == ptr ) return algvars_names[6];
  if( &$Activation$Pout_1 == ptr ) return output_names[7];
  if( &$Activation$Pout_1 == ptr ) return algvars_names[5];
  if( &$Incubation$Pout_1 == ptr ) return output_names[6];
  if( &$Incubation$Pout_1 == ptr ) return algvars_names[4];
  if( &$Sick_Popul$Pp == ptr ) return output_names[5];
  if( &$DER$Sick_Popul$Pp == ptr ) return derivative_names[2];
  if( &$Sick_Popul$Pp == ptr ) return state_names[2];
  if( &$Infected_Popul$Pp == ptr ) return output_names[4];
  if( &$DER$Infected_Popul$Pp == ptr ) return derivative_names[1];
  if( &$Infected_Popul$Pp == ptr ) return state_names[1];
  if( &$Non_Infected_Popul$Pp == ptr ) return output_names[3];
  if( &$DER$Non_Infected_Popul$Pp == ptr ) return derivative_names[0];
  if( &$Non_Infected_Popul$Pp == ptr ) return state_names[0];
  if( &$Immune_Popul$Pp == ptr ) return output_names[2];
  if( &$Immune_Popul$Pp == ptr ) return algvars_names[3];
  if( &$Immune_Popul$Pin_2 == ptr ) return algvars_names[2];
  if( &$DER$Immune_Popul$Pp == ptr ) return output_names[1];
  if( &$DER$Immune_Popul$Pp == ptr ) return algvars_names[1];
  if( &$DER$Activation$Pout_1 == ptr ) return output_names[0];
  if( &$DER$Activation$Pout_1 == ptr ) return algvars_names[0];
  return "";
}

static char init_fixed[NX+NX+NY+NP]={
	1/*Non_Infected_Popul.p*/, 1/*Infected_Popul.p*/, 1/*Sick_Popul.p*/, 1/*default*/, 
	1/*default*/, 1/*default*/, 0/*der(Activation.out_1)*/, 
	0/*der(Immune_Popul.p)*/, 0/*Immune_Popul.in_2*/, 0/*Immune_Popul.p*/, 
	0/*Incubation.out_1*/, 0/*Activation.out_1*/, 0/*Perc_Infected.out_1*/, 
	0/*Contagious_Popul.out_1*/, 0/*Non_Contagious_Popul.out_1*/, 0/*Total_Popul.out_1*/, 
	0/*Temp3.out_1*/, 0/*Contacts_Wk.out_1*/, 0/*Temp1.out_1*/, 
	0/*Temp2.out_1*/, 0/*Infection_Rate.out_1*/, 0/*Introduction*/, 
	0/*Immune_Popul.in_1*/, 0/*Immune_Popul.out_1*/, 0/*Non_Infected_Popul.in_1*/, 
	0/*Non_Infected_Popul.in_2*/, 0/*Non_Infected_Popul.out_1*/, 0/*Infected_Popul.in_1*/, 
	0/*Infected_Popul.in_2*/, 0/*Infected_Popul.out_1*/, 0/*Sick_Popul.in_1*/, 
	0/*Sick_Popul.in_2*/, 0/*Sick_Popul.out_1*/, 0/*Incubation.in_1*/, 
	0/*Incubation.in_2*/, 0/*Cure_Rate.in_1*/, 0/*Cure_Rate.in_2*/, 
	0/*Cure_Rate.out_1*/, 0/*Activation.in_1*/, 0/*Activation.in_2*/, 
	0/*Perc_Infected.in_1*/, 0/*Perc_Infected.in_2*/, 0/*Time_to_Breakdown.out_1*/, 
	0/*Sickness_Duration.out_1*/, 0/*Contraction_Rate.out_1*/, 0/*Immune_Period.out_1*/, 
	0/*Contagious_Popul.in_1*/, 0/*Contagious_Popul.in_2*/, 0/*Non_Contagious_Popul.in_1*/, 
	0/*Non_Contagious_Popul.in_2*/, 0/*Total_Popul.in_1*/, 0/*Total_Popul.in_2*/, 
	0/*Temp3.in_1*/, 0/*Temp3.in_2*/, 0/*Contacts_Wk.in_1*/, 
	0/*Temp1.in_1*/, 0/*Temp1.in_2*/, 0/*Temp2.in_1*/, 
	0/*Temp2.in_2*/, 0/*Infection_Rate.in_1*/, 0/*Infection_Rate.in_2*/, 
	1/*Incubation.c*/, 1/*Cure_Rate.c*/, 1/*Activation.c*/, 
	1/*Perc_Infected.c*/, 1/*Time_to_Breakdown.c*/, 1/*Sickness_Duration.c*/, 
	1/*Contraction_Rate.c*/, 1/*Immune_Period.c*/, 1/*Contacts_Wk.c*/, 
	1/*Temp1.c*/, 1/*Temp2.c*/
};

char var_attr[NX+NY+NP]={/*Non_Infected_Popul.p:*/1+0, /*Infected_Popul.p:*/1+0, /*Sick_Popul.p:*/1+0, /*der(Activation.out_1):*/1+0, 
/*der(Immune_Popul.p):*/1+0, /*Immune_Popul.in_2:*/1+0, /*Immune_Popul.p:*/1+0, 
/*Incubation.out_1:*/1+0, /*Activation.out_1:*/1+0, /*Perc_Infected.out_1:*/1+0, 
/*Contagious_Popul.out_1:*/1+0, /*Non_Contagious_Popul.out_1:*/1+0, /*Total_Popul.out_1:*/1+0, 
/*Temp3.out_1:*/1+0, /*Contacts_Wk.out_1:*/1+0, /*Temp1.out_1:*/1+0, 
/*Temp2.out_1:*/1+0, /*Infection_Rate.out_1:*/1+0, /*Introduction:*/1+0, 
/*Immune_Popul.in_1:*/1+0, /*Immune_Popul.out_1:*/1+0, /*Non_Infected_Popul.in_1:*/1+0, 
/*Non_Infected_Popul.in_2:*/1+0, /*Non_Infected_Popul.out_1:*/1+0, /*Infected_Popul.in_1:*/1+0, 
/*Infected_Popul.in_2:*/1+0, /*Infected_Popul.out_1:*/1+0, /*Sick_Popul.in_1:*/1+0, 
/*Sick_Popul.in_2:*/1+0, /*Sick_Popul.out_1:*/1+0, /*Incubation.in_1:*/1+0, 
/*Incubation.in_2:*/1+0, /*Cure_Rate.in_1:*/1+0, /*Cure_Rate.in_2:*/1+0, 
/*Cure_Rate.out_1:*/1+0, /*Activation.in_1:*/1+0, /*Activation.in_2:*/1+0, 
/*Perc_Infected.in_1:*/1+0, /*Perc_Infected.in_2:*/1+0, /*Time_to_Breakdown.out_1:*/1+0, 
/*Sickness_Duration.out_1:*/1+0, /*Contraction_Rate.out_1:*/1+0, /*Immune_Period.out_1:*/1+0, 
/*Contagious_Popul.in_1:*/1+0, /*Contagious_Popul.in_2:*/1+0, /*Non_Contagious_Popul.in_1:*/1+0, 
/*Non_Contagious_Popul.in_2:*/1+0, /*Total_Popul.in_1:*/1+0, /*Total_Popul.in_2:*/1+0, 
/*Temp3.in_1:*/1+0, /*Temp3.in_2:*/1+0, /*Contacts_Wk.in_1:*/1+0, 
/*Temp1.in_1:*/1+0, /*Temp1.in_2:*/1+0, /*Temp2.in_1:*/1+0, 
/*Temp2.in_2:*/1+0, /*Infection_Rate.in_1:*/1+0, /*Infection_Rate.in_2:*/1+0, 
/*Incubation.c:*/1+0, /*Cure_Rate.c:*/1+0, /*Activation.c:*/1+0, 
/*Perc_Infected.c:*/1+0, /*Time_to_Breakdown.c:*/1+0, /*Sickness_Duration.c:*/1+0, 
/*Contraction_Rate.c:*/1+0, /*Immune_Period.c:*/1+0, /*Contacts_Wk.c:*/1+0, 
/*Temp1.c:*/1+0, /*Temp2.c:*/1+0};

#define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))


int encounteredDivisionByZero = 0;
double division_error(double b,const char* division_str)
{
  if(!encounteredDivisionByZero){
    fprintf(stderr,"ERROR: Division by zero in partial equation: %s.\n",division_str);
    encounteredDivisionByZero = 1;
   }
   return b;
}

void setLocalData(DATA* data)
{
   localData = data;
}

DATA* initializeDataStruc(DATA_FLAGS flags)
{
  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData->nStates = NX;
  returnData->nAlgebraic = NY;
  returnData->nParameters = NP;
  returnData->nInputVars = NI;
  returnData->nOutputVars = NO;
  returnData->nZeroCrossing = NG;
  returnData->nInitialResiduals = NR;
  returnData->nHelpVars = NHELP;
  returnData->stringVariables.nParameters = NPSTR;
  returnData->stringVariables.nAlgebraic = NYSTR;

  if(flags & STATES && returnData->nStates) {
    returnData->states = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStates = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStates2 = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->states&&returnData->oldStates&&returnData->oldStates2);
    memset(returnData->states,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStates,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStates2,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->states = 0;
    returnData->oldStates = 0;
    returnData->oldStates2 = 0;
  }

  if(flags & STATESDERIVATIVES && returnData->nStates) {
    returnData->statesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->statesDerivatives&&returnData->oldStatesDerivatives&&returnData->oldStatesDerivatives2);
    memset(returnData->statesDerivatives,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStatesDerivatives,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStatesDerivatives2,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->statesDerivatives = 0;
    returnData->oldStatesDerivatives = 0;
    returnData->oldStatesDerivatives2 = 0;
  }

  if(flags & HELPVARS && returnData->nHelpVars) {
    returnData->helpVars = (double*) malloc(sizeof(double)*returnData->nHelpVars);
    assert(returnData->helpVars);
    memset(returnData->helpVars,0,sizeof(double)*returnData->nHelpVars);
  } else {
    returnData->helpVars = 0;
  }

  if(flags & ALGEBRAICS && returnData->nAlgebraic) {
    returnData->algebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->oldAlgebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    assert(returnData->algebraics&&returnData->oldAlgebraics&&returnData->oldAlgebraics2);
    memset(returnData->algebraics,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->oldAlgebraics,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->oldAlgebraics2,0,sizeof(double)*returnData->nAlgebraic);
  } else {
    returnData->algebraics = 0;
    returnData->oldAlgebraics = 0;
    returnData->oldAlgebraics2 = 0;
    returnData->stringVariables.algebraics = 0;
  }

  if (flags & ALGEBRAICS && returnData->stringVariables.nAlgebraic) {
    returnData->stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData->stringVariables.nAlgebraic);
    assert(returnData->stringVariables.algebraics);
    memset(returnData->stringVariables.algebraics,0,sizeof(char*)*returnData->stringVariables.nAlgebraic);
  } else {
    returnData->stringVariables.algebraics=0;
  }

  if(flags & PARAMETERS && returnData->nParameters) {
    returnData->parameters = (double*) malloc(sizeof(double)*returnData->nParameters);
    assert(returnData->parameters);
    memset(returnData->parameters,0,sizeof(double)*returnData->nParameters);
  } else {
    returnData->parameters = 0;
  }

  if (flags & PARAMETERS && returnData->stringVariables.nParameters) {
  	  returnData->stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData->stringVariables.nParameters);
      assert(returnData->stringVariables.parameters);
      memset(returnData->stringVariables.parameters,0,sizeof(char*)*returnData->stringVariables.nParameters);
  } else {
      returnData->stringVariables.parameters=0;
  }

  if(flags & OUTPUTVARS && returnData->nOutputVars) {
    returnData->outputVars = (double*) malloc(sizeof(double)*returnData->nOutputVars);
    assert(returnData->outputVars);
    memset(returnData->outputVars,0,sizeof(double)*returnData->nOutputVars);
  } else {
    returnData->outputVars = 0;
  }

  if(flags & INPUTVARS && returnData->nInputVars) {
    returnData->inputVars = (double*) malloc(sizeof(double)*returnData->nInputVars);
    assert(returnData->inputVars);
    memset(returnData->inputVars,0,sizeof(double)*returnData->nInputVars);
  } else {
    returnData->inputVars = 0;
  }

  if(flags & INITIALRESIDUALS && returnData->nInitialResiduals) {
    returnData->initialResiduals = (double*) malloc(sizeof(double)*returnData->nInitialResiduals);
    assert(returnData->initialResiduals);
    memset(returnData->initialResiduals,0,sizeof(double)*returnData->nInitialResiduals);
  } else {
    returnData->initialResiduals = 0;
  }

  if(flags & INITFIXED) {
    returnData->initFixed = init_fixed;
  } else {
    returnData->initFixed = 0;
  }

  /*   names   */
  if(flags & MODELNAME) {
    returnData->modelName = model_name;
  } else {
    returnData->modelName = 0;
  }
  
  if(flags & STATESNAMES) {
    returnData->statesNames = state_names;
  } else {
    returnData->statesNames = 0;
  }

  if(flags & STATESDERIVATIVESNAMES) {
    returnData->stateDerivativesNames = derivative_names;
  } else {
    returnData->stateDerivativesNames = 0;
  }

  if(flags & ALGEBRAICSNAMES) {
    returnData->algebraicsNames = algvars_names;
  } else {
    returnData->algebraicsNames = 0;
  }

  if(flags & PARAMETERSNAMES) {
    returnData->parametersNames = param_names;
  } else {
    returnData->parametersNames = 0;
  }

  if(flags & INPUTNAMES) {
    returnData->inputNames = input_names;
  } else {
    returnData->inputNames = 0;
  }

  if(flags & OUTPUTNAMES) {
    returnData->outputNames = output_names;
  } else {
    returnData->outputNames = 0;
  }

  /*   comments  */
  if(flags & STATESCOMMENTS) {
    returnData->statesComments = state_comments;
  } else {
    returnData->statesComments = 0;
  }

  if(flags & STATESDERIVATIVESCOMMENTS) {
    returnData->stateDerivativesComments = derivative_comments;
  } else {
    returnData->stateDerivativesComments = 0;
  }

  if(flags & ALGEBRAICSCOMMENTS) {
    returnData->algebraicsComments = algvars_comments;
  } else {
    returnData->algebraicsComments = 0;
  }

  if(flags & PARAMETERSCOMMENTS) {
    returnData->parametersComments = param_comments;
  } else {
    returnData->parametersComments = 0;
  }

  if(flags & INPUTCOMMENTS) {
    returnData->inputComments = input_comments;
  } else {
    returnData->inputComments = 0;
  }

  if(flags & OUTPUTCOMMENTS) {
    returnData->outputComments = output_comments;
  } else {
    returnData->outputComments = 0;
  }

  if (flags & EXTERNALVARS) {
    returnData->extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData->extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData->extObjs,0,sizeof(void*)*NEXT);
    setLocalData(returnData); /* must be set since used by constructors*/
  }
  return returnData;
}

void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
{
  if(!data)
    return;

  if(flags & STATES && data->states) {
    free(data->states);
    data->states = 0;
  }

  if(flags & STATESDERIVATIVES && data->statesDerivatives) {
    free(data->statesDerivatives);
    data->statesDerivatives = 0;
  }

  if(flags & ALGEBRAICS && data->algebraics) {
    free(data->algebraics);
    data->algebraics = 0;
  }

  if(flags & PARAMETERS && data->parameters) {
    free(data->parameters);
    data->parameters = 0;
  }

  if(flags & OUTPUTVARS && data->inputVars) {
    free(data->inputVars);
    data->inputVars = 0;
  }

  if(flags & INPUTVARS && data->outputVars) {
    free(data->outputVars);
    data->outputVars = 0;
  }
  
  if(flags & INITIALRESIDUALS && data->initialResiduals){
    free(data->initialResiduals);
    data->initialResiduals = 0;
  }
  if (flags & EXTERNALVARS && data->extObjs) {
    free(data->extObjs);
    data->extObjs = 0;
  }
}

int functionDAE_output()
{
  state mem_state;
  mem_state = get_memory_state();
  $DER$Activation$Pout_1 = ($Cure_Rate$Pc * ($DER$Sick_Popul$Pp / $Sickness_Duration$Pc));
  $DER$Immune_Popul$Pp = ($DER$Activation$Pout_1 * ($Immune_Period$Pc / $Activation$Pc));
  $Immune_Popul$Pin_2 = ($Activation$Pout_1 - $DER$Immune_Popul$Pp);
  $Immune_Popul$Pout_1 = $Immune_Popul$Pp;
  $Non_Infected_Popul$Pout_1 = $Non_Infected_Popul$Pp;
  $Infected_Popul$Pout_1 = $Infected_Popul$Pp;
  $Sick_Popul$Pout_1 = $Sick_Popul$Pp;
  $Time_to_Breakdown$Pout_1 = $Time_to_Breakdown$Pc;
  $Sickness_Duration$Pout_1 = $Sickness_Duration$Pc;
  $Contraction_Rate$Pout_1 = $Contraction_Rate$Pc;
  $Immune_Period$Pout_1 = $Immune_Period$Pc;
  $Temp3$Pin_2 = $Introduction;
  $Non_Infected_Popul$Pin_2 = $Infection_Rate$Pout_1;
  $Infected_Popul$Pin_1 = $Infection_Rate$Pout_1;
  $Infection_Rate$Pin_2 = $Non_Infected_Popul$Pp;
  $Contacts_Wk$Pin_1 = $Non_Infected_Popul$Pp;
  $Non_Contagious_Popul$Pin_1 = $Non_Infected_Popul$Pp;
  $Infection_Rate$Pin_1 = $Temp3$Pout_1;
  $Temp3$Pin_1 = $Temp2$Pout_1;
  $Temp2$Pin_2 = $Temp1$Pout_1;
  $Temp1$Pin_2 = $Contacts_Wk$Pout_1;
  $Temp1$Pin_1 = $Perc_Infected$Pout_1;
  $Perc_Infected$Pin_2 = $Total_Popul$Pout_1;
  $Total_Popul$Pin_2 = $Non_Contagious_Popul$Pout_1;
  $Non_Contagious_Popul$Pin_2 = $Immune_Popul$Pp;
  $Activation$Pin_1 = $Immune_Popul$Pp;
  $Total_Popul$Pin_1 = $Contagious_Popul$Pout_1;
  $Perc_Infected$Pin_1 = $Contagious_Popul$Pout_1;
  $Contagious_Popul$Pin_2 = $Sick_Popul$Pp;
  $Cure_Rate$Pin_1 = $Sick_Popul$Pp;
  $Contagious_Popul$Pin_1 = $Infected_Popul$Pp;
  $Incubation$Pin_1 = $Infected_Popul$Pp;
  $Temp2$Pin_1 = $Contraction_Rate$Pc;
  $Non_Infected_Popul$Pin_1 = $Activation$Pout_1;
  $Sick_Popul$Pin_2 = $Activation$Pout_1;
  $Immune_Popul$Pin_1 = $Activation$Pout_1;
  $Cure_Rate$Pout_1 = $Activation$Pout_1;
  $Activation$Pin_2 = $Immune_Period$Pc;
  $Cure_Rate$Pin_2 = $Sickness_Duration$Pc;
  $Sick_Popul$Pin_1 = $Incubation$Pout_1;
  $Infected_Popul$Pin_2 = $Incubation$Pout_1;
  $Incubation$Pin_2 = $Time_to_Breakdown$Pc;
  restore_memory_state(mem_state);
  return 0;
}

int functionDAE_output2()
{
  state mem_state;
  mem_state = get_memory_state();
  $Immune_Popul$Pout_1 = $Immune_Popul$Pp;
  $Non_Infected_Popul$Pout_1 = $Non_Infected_Popul$Pp;
  $Infected_Popul$Pout_1 = $Infected_Popul$Pp;
  $Sick_Popul$Pout_1 = $Sick_Popul$Pp;
  $Time_to_Breakdown$Pout_1 = $Time_to_Breakdown$Pc;
  $Sickness_Duration$Pout_1 = $Sickness_Duration$Pc;
  $Contraction_Rate$Pout_1 = $Contraction_Rate$Pc;
  $Immune_Period$Pout_1 = $Immune_Period$Pc;
  $Temp3$Pin_2 = $Introduction;
  $Non_Infected_Popul$Pin_2 = $Infection_Rate$Pout_1;
  $Infected_Popul$Pin_1 = $Infection_Rate$Pout_1;
  $Infection_Rate$Pin_2 = $Non_Infected_Popul$Pp;
  $Contacts_Wk$Pin_1 = $Non_Infected_Popul$Pp;
  $Non_Contagious_Popul$Pin_1 = $Non_Infected_Popul$Pp;
  $Infection_Rate$Pin_1 = $Temp3$Pout_1;
  $Temp3$Pin_1 = $Temp2$Pout_1;
  $Temp2$Pin_2 = $Temp1$Pout_1;
  $Temp1$Pin_2 = $Contacts_Wk$Pout_1;
  $Temp1$Pin_1 = $Perc_Infected$Pout_1;
  $Perc_Infected$Pin_2 = $Total_Popul$Pout_1;
  $Total_Popul$Pin_2 = $Non_Contagious_Popul$Pout_1;
  $Non_Contagious_Popul$Pin_2 = $Immune_Popul$Pp;
  $Activation$Pin_1 = $Immune_Popul$Pp;
  $Total_Popul$Pin_1 = $Contagious_Popul$Pout_1;
  $Perc_Infected$Pin_1 = $Contagious_Popul$Pout_1;
  $Contagious_Popul$Pin_2 = $Sick_Popul$Pp;
  $Cure_Rate$Pin_1 = $Sick_Popul$Pp;
  $Contagious_Popul$Pin_1 = $Infected_Popul$Pp;
  $Incubation$Pin_1 = $Infected_Popul$Pp;
  $Temp2$Pin_1 = $Contraction_Rate$Pc;
  $Non_Infected_Popul$Pin_1 = $Activation$Pout_1;
  $Sick_Popul$Pin_2 = $Activation$Pout_1;
  $Immune_Popul$Pin_1 = $Activation$Pout_1;
  $Cure_Rate$Pout_1 = $Activation$Pout_1;
  $Activation$Pin_2 = $Immune_Period$Pc;
  $Cure_Rate$Pin_2 = $Sickness_Duration$Pc;
  $Sick_Popul$Pin_1 = $Incubation$Pout_1;
  $Infected_Popul$Pin_2 = $Incubation$Pout_1;
  $Incubation$Pin_2 = $Time_to_Breakdown$Pc;
  restore_memory_state(mem_state);
  return 0;
}

/*
*/
int input_function()
{
  $Introduction = localData->inputVars[0];return 0;
}

/*
*/
int output_function()
{
  localData->outputVars[0] =$Immune_Period$Pout_1;
  localData->outputVars[1] =$Contraction_Rate$Pout_1;
  localData->outputVars[2] =$Sickness_Duration$Pout_1;
  localData->outputVars[3] =$Time_to_Breakdown$Pout_1;
  localData->outputVars[4] =$Cure_Rate$Pout_1;
  localData->outputVars[5] =$Sick_Popul$Pout_1;
  localData->outputVars[6] =$Infected_Popul$Pout_1;
  localData->outputVars[7] =$Non_Infected_Popul$Pout_1;
  localData->outputVars[8] =$Immune_Popul$Pout_1;
  localData->outputVars[9] =$Infection_Rate$Pout_1;
  localData->outputVars[10] =$Temp2$Pout_1;
  localData->outputVars[11] =$Temp1$Pout_1;
  localData->outputVars[12] =$Contacts_Wk$Pout_1;
  localData->outputVars[13] =$Temp3$Pout_1;
  localData->outputVars[14] =$Total_Popul$Pout_1;
  localData->outputVars[15] =$Non_Contagious_Popul$Pout_1;
  localData->outputVars[16] =$Contagious_Popul$Pout_1;
  localData->outputVars[17] =$Perc_Infected$Pout_1;
  localData->outputVars[18] =$Activation$Pout_1;
  localData->outputVars[19] =$Incubation$Pout_1;
  localData->outputVars[20] =$Sick_Popul$Pp;
  localData->outputVars[21] =$Infected_Popul$Pp;
  localData->outputVars[22] =$Non_Infected_Popul$Pp;
  localData->outputVars[23] =$Immune_Popul$Pp;
  localData->outputVars[24] =$DER$Immune_Popul$Pp;
  localData->outputVars[25] =$DER$Activation$Pout_1;return 0;
}

int functionDAE_res(double *t, double *x, double *xd, double *delta, long int *ires, double *rpar, long int* ipar)
{
  int i;
  double temp_xd[NX];
  double* statesBackup;
  double* statesDerivativesBackup;
  double timeBackup;
  statesBackup = localData->states;
  statesDerivativesBackup = localData->statesDerivatives;
  timeBackup = localData->timeValue;
  localData->states = x;
  for (i=0; i<localData->nStates; i++) temp_xd[i]=localData->statesDerivatives[i];
  
  localData->statesDerivatives = temp_xd;
  localData->timeValue = *t;
  
  functionODE();
  /* get the difference between the temp_xd(=localData->statesDerivatives) and xd(=statesDerivativesBackup) */
  for (i=0; i < localData->nStates; i++) delta[i]=localData->statesDerivatives[i]-statesDerivativesBackup[i];
  
  localData->states = statesBackup;
  localData->statesDerivatives = statesDerivativesBackup;
  localData->timeValue = timeBackup;
  if (modelErrorCode) {
      if (ires) *ires = -1;
      modelErrorCode =0;
  }
  return 0;
}

int function_zeroCrossing(long *neqm, double *t, double *x, long *ng, double *gout, double *rpar, long* ipar)
{
  double timeBackup;
  state mem_state;
  mem_state = get_memory_state();
  timeBackup = localData->timeValue;
  localData->timeValue = *t;
  functionODE();
  functionDAE_output();
  ZEROCROSSING(0,Less($Temp3$Pout_1,$Non_Infected_Popul$Pp));
  restore_memory_state(mem_state);
  localData->timeValue = timeBackup;
  return 0;
}

int handleZeroCrossing(long index)
{
  state mem_state;
  mem_state = get_memory_state();
  switch(index) {
    case 0:
      save($Infection_Rate$Pout_1);
      break;

    default: break;
  }
  restore_memory_state(mem_state);
  return 0;
}

int function_updateDependents()
{
  state mem_state;
  modelica_boolean tmp0;
  modelica_boolean tmp1;
  inUpdate=initial()?0:1;
  mem_state = get_memory_state();
  $Contacts_Wk$Pout_1 = ($Contacts_Wk$Pc * $Non_Infected_Popul$Pp);
  $Contagious_Popul$Pout_1 = ($Infected_Popul$Pp + $Sick_Popul$Pp);
  $Activation$Pout_1 = ($Cure_Rate$Pc * ($Sick_Popul$Pp / $Sickness_Duration$Pc));
  $Immune_Popul$Pp = (($Activation$Pout_1 * $Immune_Period$Pc) / $Activation$Pc);
  $Non_Contagious_Popul$Pout_1 = ($Non_Infected_Popul$Pp + $Immune_Popul$Pp);
  $Total_Popul$Pout_1 = ($Contagious_Popul$Pout_1 + $Non_Contagious_Popul$Pout_1);
  $Perc_Infected$Pout_1 = ($Perc_Infected$Pc * ($Contagious_Popul$Pout_1 / $Total_Popul$Pout_1));
  $Temp1$Pout_1 = ($Temp1$Pc * ($Perc_Infected$Pout_1 * $Contacts_Wk$Pout_1));
  $Temp2$Pout_1 = ($Temp2$Pc * ($Contraction_Rate$Pc * $Temp1$Pout_1));
  $Temp3$Pout_1 = ($Temp2$Pout_1 + $Introduction);
  RELATIONLESS(tmp0,$Temp3$Pout_1,$Non_Infected_Popul$Pp);
  tmp1 = tmp0;
  if (tmp1) {
  }
  else {
  }
  $Infection_Rate$Pout_1 = ((tmp1)?$Temp3$Pout_1:$Non_Infected_Popul$Pp);
  $DER$Non_Infected_Popul$Pp = ($Activation$Pout_1 - $Infection_Rate$Pout_1);
  $Incubation$Pout_1 = ($Incubation$Pc * ($Infected_Popul$Pp / $Time_to_Breakdown$Pc));
  $DER$Sick_Popul$Pp = ($Incubation$Pout_1 - $Activation$Pout_1);
  $DER$Activation$Pout_1 = ($Cure_Rate$Pc * ($DER$Sick_Popul$Pp * pow((modelica_real)$Sickness_Duration$Pc, (modelica_real)-1.0)));
  $DER$Immune_Popul$Pp = (($DER$Activation$Pout_1 * $Immune_Period$Pc) / $Activation$Pc);
  $Immune_Popul$Pin_2 = ($Activation$Pout_1 - $DER$Immune_Popul$Pp);
  $DER$Infected_Popul$Pp = ($Infection_Rate$Pout_1 - $Incubation$Pout_1);
  restore_memory_state(mem_state);
  inUpdate=0;
  return 0;
}

int function_when(int i)
{
  state mem_state;
  mem_state = get_memory_state();
  switch(i) {
    default: break;
  }
  restore_memory_state(mem_state);
  return 0;
}

int functionODE()
{
  state mem_state;
  modelica_boolean tmp0;
  mem_state = get_memory_state();
  $Contacts_Wk$Pout_1 = ($Contacts_Wk$Pc * $Non_Infected_Popul$Pp);
  $Contagious_Popul$Pout_1 = ($Infected_Popul$Pp + $Sick_Popul$Pp);
  $Activation$Pout_1 = ($Cure_Rate$Pc * ($Sick_Popul$Pp / $Sickness_Duration$Pc));
  $Immune_Popul$Pp = (($Activation$Pout_1 * $Immune_Period$Pc) / $Activation$Pc);
  $Non_Contagious_Popul$Pout_1 = ($Non_Infected_Popul$Pp + $Immune_Popul$Pp);
  $Total_Popul$Pout_1 = ($Contagious_Popul$Pout_1 + $Non_Contagious_Popul$Pout_1);
  $Perc_Infected$Pout_1 = ($Perc_Infected$Pc * ($Contagious_Popul$Pout_1 / $Total_Popul$Pout_1));
  $Temp1$Pout_1 = ($Temp1$Pc * ($Perc_Infected$Pout_1 * $Contacts_Wk$Pout_1));
  $Temp2$Pout_1 = ($Temp2$Pc * ($Contraction_Rate$Pc * $Temp1$Pout_1));
  $Temp3$Pout_1 = ($Temp2$Pout_1 + $Introduction);
  tmp0 = ($Temp3$Pout_1 < $Non_Infected_Popul$Pp);
  if (tmp0) {
  }
  else {
  }
  $Infection_Rate$Pout_1 = ((tmp0)?$Temp3$Pout_1:$Non_Infected_Popul$Pp);
  $DER$Non_Infected_Popul$Pp = ($Activation$Pout_1 - $Infection_Rate$Pout_1);
  $Incubation$Pout_1 = ($Incubation$Pc * ($Infected_Popul$Pp / $Time_to_Breakdown$Pc));
  $DER$Sick_Popul$Pp = ($Incubation$Pout_1 - $Activation$Pout_1);
  $DER$Infected_Popul$Pp = ($Infection_Rate$Pout_1 - $Incubation$Pout_1);
  restore_memory_state(mem_state);
  return 0;
}

int initial_function()
{
  return 0;
}

int initial_residual()
{
  modelica_boolean tmp0;
  modelica_boolean tmp1;
  int i=0;
  state mem_state;
  mem_state = get_memory_state();
  localData->initialResiduals[i++] = ($Incubation$Pout_1 - ($Incubation$Pc * ($Infected_Popul$Pp / $Time_to_Breakdown$Pc)));
  localData->initialResiduals[i++] = ($Activation$Pout_1 - ($Cure_Rate$Pc * ($Sick_Popul$Pp / $Sickness_Duration$Pc)));
  localData->initialResiduals[i++] = ($Activation$Pout_1 - ($Activation$Pc * ($Immune_Popul$Pp / $Immune_Period$Pc)));
  localData->initialResiduals[i++] = ($Perc_Infected$Pout_1 - ($Perc_Infected$Pc * ($Contagious_Popul$Pout_1 / $Total_Popul$Pout_1)));
  localData->initialResiduals[i++] = ($Contagious_Popul$Pout_1 - ($Infected_Popul$Pp + $Sick_Popul$Pp));
  localData->initialResiduals[i++] = ($Non_Contagious_Popul$Pout_1 - ($Non_Infected_Popul$Pp + $Immune_Popul$Pp));
  localData->initialResiduals[i++] = ($Total_Popul$Pout_1 - ($Contagious_Popul$Pout_1 + $Non_Contagious_Popul$Pout_1));
  localData->initialResiduals[i++] = ($Temp3$Pout_1 - ($Temp2$Pout_1 + $Introduction));
  localData->initialResiduals[i++] = ($Contacts_Wk$Pout_1 - ($Contacts_Wk$Pc * $Non_Infected_Popul$Pp));
  localData->initialResiduals[i++] = ($Temp1$Pout_1 - ($Temp1$Pc * ($Perc_Infected$Pout_1 * $Contacts_Wk$Pout_1)));
  localData->initialResiduals[i++] = ($Temp2$Pout_1 - ($Temp2$Pc * ($Contraction_Rate$Pc * $Temp1$Pout_1)));
  RELATIONLESS(tmp0,$Temp3$Pout_1,$Non_Infected_Popul$Pp);
  tmp1 = tmp0;
  if (tmp1) {
  }
  else {
  }
  localData->initialResiduals[i++] = ($Infection_Rate$Pout_1 - ((tmp1)?$Temp3$Pout_1:$Non_Infected_Popul$Pp));
  localData->initialResiduals[i++] = ($DER$Immune_Popul$Pp - ($Activation$Pout_1 - $Immune_Popul$Pin_2));
  localData->initialResiduals[i++] = ($DER$Non_Infected_Popul$Pp - ($Activation$Pout_1 - $Infection_Rate$Pout_1));
  localData->initialResiduals[i++] = ($DER$Infected_Popul$Pp - ($Infection_Rate$Pout_1 - $Incubation$Pout_1));
  localData->initialResiduals[i++] = ($DER$Sick_Popul$Pp - ($Incubation$Pout_1 - $Activation$Pout_1));
  localData->initialResiduals[i++] = ($DER$Activation$Pout_1 - ($Activation$Pc * ($DER$Immune_Popul$Pp / $Immune_Period$Pc)));
  localData->initialResiduals[i++] = ($DER$Activation$Pout_1 - ($Cure_Rate$Pc * ($DER$Sick_Popul$Pp / $Sickness_Duration$Pc)));
  localData->initialResiduals[i++] = ($Immune_Popul$Pout_1 - $Immune_Popul$Pp);
  localData->initialResiduals[i++] = ($Non_Infected_Popul$Pout_1 - $Non_Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Infected_Popul$Pout_1 - $Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Sick_Popul$Pout_1 - $Sick_Popul$Pp);
  localData->initialResiduals[i++] = ($Time_to_Breakdown$Pout_1 - $Time_to_Breakdown$Pc);
  localData->initialResiduals[i++] = ($Sickness_Duration$Pout_1 - $Sickness_Duration$Pc);
  localData->initialResiduals[i++] = ($Contraction_Rate$Pout_1 - $Contraction_Rate$Pc);
  localData->initialResiduals[i++] = ($Immune_Period$Pout_1 - $Immune_Period$Pc);
  localData->initialResiduals[i++] = ($Temp3$Pin_2 - $Introduction);
  localData->initialResiduals[i++] = ($Non_Infected_Popul$Pin_2 - $Infection_Rate$Pout_1);
  localData->initialResiduals[i++] = ($Infected_Popul$Pin_1 - $Infection_Rate$Pout_1);
  localData->initialResiduals[i++] = ($Infection_Rate$Pin_2 - $Non_Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Contacts_Wk$Pin_1 - $Non_Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Non_Contagious_Popul$Pin_1 - $Non_Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Infection_Rate$Pin_1 - $Temp3$Pout_1);
  localData->initialResiduals[i++] = ($Temp3$Pin_1 - $Temp2$Pout_1);
  localData->initialResiduals[i++] = ($Temp2$Pin_2 - $Temp1$Pout_1);
  localData->initialResiduals[i++] = ($Temp1$Pin_2 - $Contacts_Wk$Pout_1);
  localData->initialResiduals[i++] = ($Temp1$Pin_1 - $Perc_Infected$Pout_1);
  localData->initialResiduals[i++] = ($Perc_Infected$Pin_2 - $Total_Popul$Pout_1);
  localData->initialResiduals[i++] = ($Total_Popul$Pin_2 - $Non_Contagious_Popul$Pout_1);
  localData->initialResiduals[i++] = ($Non_Contagious_Popul$Pin_2 - $Immune_Popul$Pp);
  localData->initialResiduals[i++] = ($Activation$Pin_1 - $Immune_Popul$Pp);
  localData->initialResiduals[i++] = ($Total_Popul$Pin_1 - $Contagious_Popul$Pout_1);
  localData->initialResiduals[i++] = ($Perc_Infected$Pin_1 - $Contagious_Popul$Pout_1);
  localData->initialResiduals[i++] = ($Contagious_Popul$Pin_2 - $Sick_Popul$Pp);
  localData->initialResiduals[i++] = ($Cure_Rate$Pin_1 - $Sick_Popul$Pp);
  localData->initialResiduals[i++] = ($Contagious_Popul$Pin_1 - $Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Incubation$Pin_1 - $Infected_Popul$Pp);
  localData->initialResiduals[i++] = ($Temp2$Pin_1 - $Contraction_Rate$Pc);
  localData->initialResiduals[i++] = ($Non_Infected_Popul$Pin_1 - $Activation$Pout_1);
  localData->initialResiduals[i++] = ($Sick_Popul$Pin_2 - $Activation$Pout_1);
  localData->initialResiduals[i++] = ($Immune_Popul$Pin_1 - $Activation$Pout_1);
  localData->initialResiduals[i++] = ($Cure_Rate$Pout_1 - $Activation$Pout_1);
  localData->initialResiduals[i++] = ($Activation$Pin_2 - $Immune_Period$Pc);
  localData->initialResiduals[i++] = ($Cure_Rate$Pin_2 - $Sickness_Duration$Pc);
  localData->initialResiduals[i++] = ($Sick_Popul$Pin_1 - $Incubation$Pout_1);
  localData->initialResiduals[i++] = ($Infected_Popul$Pin_2 - $Incubation$Pout_1);
  localData->initialResiduals[i++] = ($Incubation$Pin_2 - $Time_to_Breakdown$Pc);
  localData->initialResiduals[i++] = $Sick_Popul$Pp;
  localData->initialResiduals[i++] = ($Infected_Popul$Pp - 50.0);
  localData->initialResiduals[i++] = ($Non_Infected_Popul$Pp - 100.0);
  restore_memory_state(mem_state);
  return 0;
}

int bound_parameters()
{
  state mem_state;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  return 0;
}

int checkForDiscreteVarChanges()
{
  int needToIterate=0;
  
  for (long i = 0; i < localData->nHelpVars; i++) {
    if (change(localData->helpVars[i])) { needToIterate=1; }
  }
  return needToIterate;
}
