// Simulation code for RightHeartStarling generated by the OpenModelica Compiler.

using System;
using Physiome.Solvers;
namespace Physiome.Models
{
    public class RightHeartStarling : DAESystem
    {
    
    const int
      NHELP = 0, NG = 1,
      NX = 1, NY = 8, NP = 6,
      NO = 0, NI = 0, NR = 10,
      NEXT = 0, NYSTR = 0, NPSTR = 0;
      
    public override string ModelName  { get { return "RightHeartStarling"; }}
    public override int HelpVarsCount      { get { return NHELP; } }
    public override int ZeroCrossingsCount { get { return NG; } }
    public override int StatesCount        { get { return NX; } }
    public override int AlgebraicsCount    { get { return NY; } }
    public override int ParametersCount    { get { return NP; } }
    
    public override int OutputsCount   { get { return NO; } }
    public override int InputsCount    { get { return NI; } }
    public override int ResidualsCount { get { return NR; } }
    //public int ExternalObjectsCount { get { return NEXT; } }
    public override int MaximumOrder { get { return 5; } }
    public override int StringVarsCount { get { return NYSTR; } }
    public override int StringParametersCount { get { return NPSTR; } }
    
    
    public RightHeartStarling() {
        states = new double[NX];
        statesDerivatives = new double[NX];
        algebraics = new double[NY];
        parameters = new double[NP];
        initialResiduals = new double[NR];
        helpVars = new double[NHELP];
    
        oldStates = new double[NX];
        oldStatesDerivatives = new double[NX];
        oldAlgebraics = new double[NY];
    
        oldStates2 = new double[NX];
        oldStatesDerivatives2 = new double[NX];
        oldAlgebraics2 = new double[NY];
    
        tempStatesDerivatives = new double[NX];
    
        gout                    = new double[NG];    //array of length zerocrossingcount
        savedHelpVars           = new double[NHELP]; //array of length HelpVarsCount
        savedStates             = new double[NX];    //length StatesCount
        savedStatesDerivatives  = new double[NX];    //length StetesCount
        savedAlgebraics         = new double[NY];     //length AlgebraicsCount
    
        //TODO: ?? how many events are there ?
        eventQueue = new EventQueue(NG + NHELP);
    
        initialFixed = new bool[NX+NX+NY+NP] {
           //states
           true /* volume */,
           //derivatives
           true /* der(volume) */,
           //algebraics
           false /* bloodFlow */,
           false /* EDV */,
           false /* ESV */,
           false /* inflow */,
           false /* outflow */,
           false /* delta */,
           false /* ventricleSteadyStateVolume */,
           false /* Pi */,
           //parameters
           true /* K */,
           true /* HR */,
           true /* PericardiumPressure */,
           true /* stiffnes */,
           true /* contractility */,
           true /* Po */
        };
    }
    
    public double volume { get { return states[0]; } set { states[0] = value; }}
    public double Der_volume { get { return statesDerivatives[0]; } set { statesDerivatives[0] = value; }}

    public double bloodFlow { get { return algebraics[0]; } set { algebraics[0] = value; }}
    public double Pre_bloodFlow { get { return savedAlgebraics[0]; } set { savedAlgebraics[0] = value; }}
    public double EDV { get { return algebraics[1]; } set { algebraics[1] = value; }}
    public double Pre_EDV { get { return savedAlgebraics[1]; } set { savedAlgebraics[1] = value; }}
    public double ESV { get { return algebraics[2]; } set { algebraics[2] = value; }}
    public double Pre_ESV { get { return savedAlgebraics[2]; } set { savedAlgebraics[2] = value; }}
    public double inflow { get { return algebraics[3]; } set { algebraics[3] = value; }}
    public double Pre_inflow { get { return savedAlgebraics[3]; } set { savedAlgebraics[3] = value; }}
    public double outflow { get { return algebraics[4]; } set { algebraics[4] = value; }}
    public double Pre_outflow { get { return savedAlgebraics[4]; } set { savedAlgebraics[4] = value; }}
    public double delta { get { return algebraics[5]; } set { algebraics[5] = value; }}
    public double Pre_delta { get { return savedAlgebraics[5]; } set { savedAlgebraics[5] = value; }}
    public double ventricleSteadyStateVolume { get { return algebraics[6]; } set { algebraics[6] = value; }}
    public double Pre_ventricleSteadyStateVolume { get { return savedAlgebraics[6]; } set { savedAlgebraics[6] = value; }}
    public double Pi { get { return algebraics[7]; } set { algebraics[7] = value; }}
    public double Pre_Pi { get { return savedAlgebraics[7]; } set { savedAlgebraics[7] = value; }}
    public double K { get { return parameters[0]; } set { parameters[0] = value; }}
    public double HR { get { return parameters[1]; } set { parameters[1] = value; }}
    public double PericardiumPressure { get { return parameters[2]; } set { parameters[2] = value; }}
    public double stiffnes { get { return parameters[3]; } set { parameters[3] = value; }}
    public double contractility { get { return parameters[4]; } set { parameters[4] = value; }}
    public double Po { get { return parameters[5]; } set { parameters[5] = value; }}
    
    

    /* for continuous time variables */
    public override void FunDAEOutput()
    {
      bloodFlow = (HR * (EDV - ESV));
      // RELATION( delta < 0.0 ) macro expansion
      bool _tmp1;
      if (isInUpdate) {
         _tmp1 = delta < 0.0;
         if(!_tmp1 && (delta <= 0.0)) {
           var timeBackup = time; var statesBackup = states; var statesDerivativesBackup = statesDerivatives; var algebraicsBackup = algebraics;
           time = oldTime; states = oldStates; statesDerivatives = oldStatesDerivatives; algebraics = oldAlgebraics;
           double res1 = delta - 0.0;  time = oldTime2; states = oldStates2; statesDerivatives = oldStatesDerivatives2; algebraics = oldAlgebraics2;
           double res2 = delta - 0.0;  time = timeBackup; states = statesBackup; statesDerivatives = statesDerivativesBackup; algebraics = algebraicsBackup;
           _tmp1 = res1 <= res2;
         }
      } else
         _tmp1 = delta < 0.0;
      inflow = (_tmp1 ? bloodFlow : (bloodFlow + delta));
      outflow = (delta - inflow);
      Pi = time;
    }

    /* for discrete time variables */
     public override void FunDAEOutput2()
    {
      Pi = time;
    }

    public override void InputFun()
    {
    }

    public override void OutputFun()
    {
    }

    public override void FunZeroCrossing(double t, double[] x, double[] xd, double[] gout)
    {
      var timeBackup = time;
      time = t;
    
      FunODE();
      FunDAEOutput();
    
      {//ZEROCROSSING(0, Less(delta, 0.0));
       var _zen = zeroCrossingEnabled[0];
       gout[0] = (_zen != 0) ? _zen * (delta-0.0) : 1.0;
      }
      
      time = timeBackup;
    }

    public override void FunHandleZeroCrossing(int index)
    {
      switch(index) {
        case 0:
          Pre_inflow = inflow; //save()
          break;
        default:
           break;
      }
    }

    public override void FunUpdateDependents()
    {
      //inUpdate=initial()?0:1;
      isInUpdate = ! isInit;
    
      ESV = (0.080251025206847 * (Math.Pow(((9.0 + Po) - PericardiumPressure), 2.0) * Math.Pow((1.0 / contractility), 2.0)));
      EDV = (62.0173672946042 * (Math.Pow((time - PericardiumPressure), 0.5) * Math.Pow((1.0 / stiffnes), 0.5)));
      ventricleSteadyStateVolume = ((EDV / 2.0) + (ESV / 2.0));
      delta = ((ventricleSteadyStateVolume - volume) * K);
      Der_volume = (delta / 60.0);
      bloodFlow = (HR * (EDV - ESV));
      // RELATION( delta < 0.0 ) macro expansion
      bool _tmp1;
      if (isInUpdate) {
         _tmp1 = delta < 0.0;
         if(!_tmp1 && (delta <= 0.0)) {
           var timeBackup = time; var statesBackup = states; var statesDerivativesBackup = statesDerivatives; var algebraicsBackup = algebraics;
           time = oldTime; states = oldStates; statesDerivatives = oldStatesDerivatives; algebraics = oldAlgebraics;
           double res1 = delta - 0.0;  time = oldTime2; states = oldStates2; statesDerivatives = oldStatesDerivatives2; algebraics = oldAlgebraics2;
           double res2 = delta - 0.0;  time = timeBackup; states = statesBackup; statesDerivatives = statesDerivativesBackup; algebraics = algebraicsBackup;
           _tmp1 = res1 <= res2;
         }
      } else
         _tmp1 = delta < 0.0;
      inflow = (_tmp1 ? bloodFlow : (bloodFlow + delta));
      outflow = (delta - inflow);
      
      isInUpdate = false;
    }

    public override void FunUpdateDepend()
    {
      isInUpdate = ! isInit;
    
      ESV = (0.080251025206847 * (Math.Pow(((9.0 + Po) - PericardiumPressure), 2.0) * Math.Pow((1.0 / contractility), 2.0)));
      EDV = (62.0173672946042 * (Math.Pow((time - PericardiumPressure), 0.5) * Math.Pow((1.0 / stiffnes), 0.5)));
      ventricleSteadyStateVolume = ((EDV / 2.0) + (ESV / 2.0));
      delta = ((ventricleSteadyStateVolume - volume) * K);
      Der_volume = (delta / 60.0);
      bloodFlow = (HR * (EDV - ESV));
      // RELATION( delta < 0.0 ) macro expansion
      bool _tmp1;
      if (isInUpdate) {
         _tmp1 = delta < 0.0;
         if(!_tmp1 && (delta <= 0.0)) {
           var timeBackup = time; var statesBackup = states; var statesDerivativesBackup = statesDerivatives; var algebraicsBackup = algebraics;
           time = oldTime; states = oldStates; statesDerivatives = oldStatesDerivatives; algebraics = oldAlgebraics;
           double res1 = delta - 0.0;  time = oldTime2; states = oldStates2; statesDerivatives = oldStatesDerivatives2; algebraics = oldAlgebraics2;
           double res2 = delta - 0.0;  time = timeBackup; states = statesBackup; statesDerivatives = statesDerivativesBackup; algebraics = algebraicsBackup;
           _tmp1 = res1 <= res2;
         }
      } else
         _tmp1 = delta < 0.0;
      inflow = (_tmp1 ? bloodFlow : (bloodFlow + delta));
      outflow = (delta - inflow);
      
      isInUpdate = false;
    }

    public override void FunOnlyZeroCrossings(double t, double[] gout)
    {
      {//ZEROCROSSING(0, Less(delta, 0.0));
       var _zen = zeroCrossingEnabled[0];
       gout[0] = (_zen != 0) ? _zen * (delta-0.0) : 1.0;
      }
    }

    public override void FunWhen(int i)
    {
      switch(i) {
        default:
          break;
      }
    }

    public override void FunODE()
    {
      ESV = (0.080251025206847 * (Math.Pow(((9.0 + Po) - PericardiumPressure), 2.0) * Math.Pow((1.0 / contractility), 2.0)));
      EDV = (62.0173672946042 * (Math.Pow((time - PericardiumPressure), 0.5) * Math.Pow((1.0 / stiffnes), 0.5)));
      ventricleSteadyStateVolume = ((EDV / 2.0) + (ESV / 2.0));
      delta = ((ventricleSteadyStateVolume - volume) * K);
      Der_volume = (delta / 60.0);
    }

    public override void InitialFun()
    {
      
      //if (sim_verbose) {
      //}
    }

    public override void InitialResidual()
    {
      int _i = 0;
    
      initialResiduals[_i++] = (bloodFlow - (HR * (EDV - ESV)));
      initialResiduals[_i++] = (EDV - (62.0173672946042 * (Math.Pow((time - PericardiumPressure), 0.5) * Math.Pow((1.0 / stiffnes), 0.5))));
      initialResiduals[_i++] = (ESV - (0.080251025206847 * (Math.Pow(((9.0 + Po) - PericardiumPressure), 2.0) * Math.Pow((1.0 / contractility), 2.0))));
      initialResiduals[_i++] = (ventricleSteadyStateVolume - ((EDV / 2.0) + (ESV / 2.0)));
      initialResiduals[_i++] = (delta - ((ventricleSteadyStateVolume - volume) * K));
      initialResiduals[_i++] = ((inflow + outflow) - delta);
      // RELATION( delta < 0.0 ) macro expansion
      bool _tmp1;
      if (isInUpdate) {
         _tmp1 = delta < 0.0;
         if(!_tmp1 && (delta <= 0.0)) {
           var timeBackup = time; var statesBackup = states; var statesDerivativesBackup = statesDerivatives; var algebraicsBackup = algebraics;
           time = oldTime; states = oldStates; statesDerivatives = oldStatesDerivatives; algebraics = oldAlgebraics;
           double res1 = delta - 0.0;  time = oldTime2; states = oldStates2; statesDerivatives = oldStatesDerivatives2; algebraics = oldAlgebraics2;
           double res2 = delta - 0.0;  time = timeBackup; states = statesBackup; statesDerivatives = statesDerivativesBackup; algebraics = algebraicsBackup;
           _tmp1 = res1 <= res2;
         }
      } else
         _tmp1 = delta < 0.0;
      initialResiduals[_i++] = (inflow - (_tmp1 ? bloodFlow : (bloodFlow + delta)));
      initialResiduals[_i++] = (Der_volume - (delta / 60.0));
      initialResiduals[_i++] = (Pi - time);
      initialResiduals[_i++] = (volume - 95.7);
    }


    public override void BoundParameters()
    {
    }

    public override bool CheckForDiscreteVarChanges()
    {
      var needToIterate = false;
    
      //edge(helpVars[i])
      
      //TODO: changeDiscreteVar(i) and to get the i from ComponentRef
      //if change()
      
      var _hvs = helpVars;
      var _shvs = savedHelpVars;
      for (int i = 0; i < _hvs.Length; i++) {
        //change(helpVars[i]) ?? TODO: not sure if it can be only 1.0 or 0.0
        if (_hvs[i] != _shvs[i])
          return true; //needToIterate=true;
      }
      
      return needToIterate;
    }
    
    }
}