// Simulation code for TrapezTestTotal generated by the OpenModelica Compiler.

#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
  #define DLLExport   __declspec( dllexport )
#else
  #define DLLExport /* nothing */
#endif

#include "TrapezTestTotal_functions.cpp"

#define NHELP 3
#define NG 5
#define NX 1
#define NY 7
#define NP 11
#define NO 4
#define NI 0
#define NR 3
#define NEXT 0
#define MAXORD 5
#define NYSTR 0
#define NPSTR 0

static DATA* localData = 0;
#define time localData->timeValue
extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
  char *model_name="TrapezTestTotal";
  char *model_dir="";
}

char* state_names[1] = {"$dummy"};
char* derivative_names[1] = {"der($dummy)"};
char* algvars_names[7] = {"trapezoid.y", "trapezoid.T0", "trapezoid.counter", "trapezoid.counter2", "y", "x", "r"};
char* input_names[1] = {""};
char* output_names[4] = {"trapezoid.y", "y", "x", "r"};
char* param_names[11] = {"trapezoid.amplitude", "trapezoid.rising", "trapezoid.width", "trapezoid.falling", "trapezoid.period", "trapezoid.nperiod", "trapezoid.offset", "trapezoid.startTime", "trapezoid.T_rising", "trapezoid.T_width", "trapezoid.T_falling"};
char* string_alg_names[1] = {""};
char* string_param_names[1] = {""};

char* state_comments[1] = {""};
char* derivative_comments[1] = {""};
char* algvars_comments[7] = {"Connector of Real output signal", "Start time of current period", "Period counter", "", "", "", ""};
char* input_comments[1] = {""};
char* output_comments[4] = {"Connector of Real output signal", "", "", ""};
char* param_comments[11] = {"Amplitude of trapezoid", "Rising duration of trapezoid", "Width duration of trapezoid", "Falling duration of trapezoid", "Time for one period", "Number of periods (< 0 means infinite number of periods)", "Offset of output signal", "Output = offset for time < startTime", "End time of rising phase within one period", "End time of width phase within one period", "End time of falling phase within one period"};
char* string_alg_comments[1] = {""};
char* string_param_comments[1] = {""};

#define $$dummy localData->states[0]
#define $DER$$dummy localData->statesDerivatives[0]
#define $trapezoid$Py localData->algebraics[0]
#define $trapezoid$PT0 localData->algebraics[1]
#define $trapezoid$Pcounter localData->algebraics[2]
#define $trapezoid$Pcounter2 localData->algebraics[3]
#define $y localData->algebraics[4]
#define $x localData->algebraics[5]
#define $r localData->algebraics[6]
#define $trapezoid$Pamplitude localData->parameters[0]
#define $trapezoid$Prising localData->parameters[1]
#define $trapezoid$Pwidth localData->parameters[2]
#define $trapezoid$Pfalling localData->parameters[3]
#define $trapezoid$Pperiod localData->parameters[4]
#define $trapezoid$Pnperiod localData->parameters[5]
#define $trapezoid$Poffset localData->parameters[6]
#define $trapezoid$PstartTime localData->parameters[7]
#define $trapezoid$PT_rising localData->parameters[8]
#define $trapezoid$PT_width localData->parameters[9]
#define $trapezoid$PT_falling localData->parameters[10]

char* getName(double* ptr)
{
  if (&$$dummy == ptr) return state_names[0];
  if (&$DER$$dummy == ptr) return derivative_names[0];
  if (&$trapezoid$Py == ptr) return algebraic_names[0];
  if (&$trapezoid$PT0 == ptr) return algebraic_names[1];
  if (&$trapezoid$Pcounter == ptr) return algebraic_names[2];
  if (&$trapezoid$Pcounter2 == ptr) return algebraic_names[3];
  if (&$y == ptr) return algebraic_names[4];
  if (&$x == ptr) return algebraic_names[5];
  if (&$r == ptr) return algebraic_names[6];
  if (&$trapezoid$Pamplitude == ptr) return param_names[0];
  if (&$trapezoid$Prising == ptr) return param_names[1];
  if (&$trapezoid$Pwidth == ptr) return param_names[2];
  if (&$trapezoid$Pfalling == ptr) return param_names[3];
  if (&$trapezoid$Pperiod == ptr) return param_names[4];
  if (&$trapezoid$Pnperiod == ptr) return param_names[5];
  if (&$trapezoid$Poffset == ptr) return param_names[6];
  if (&$trapezoid$PstartTime == ptr) return param_names[7];
  if (&$trapezoid$PT_rising == ptr) return param_names[8];
  if (&$trapezoid$PT_width == ptr) return param_names[9];
  if (&$trapezoid$PT_falling == ptr) return param_names[10];
  return "";
}

static char init_fixed[NX+NX+NY+NP] = {
  1 /* $dummy */,
  1 /* der($dummy) */,
  0 /* trapezoid.y */,
  0 /* trapezoid.T0 */,
  0 /* trapezoid.counter */,
  0 /* trapezoid.counter2 */,
  0 /* y */,
  0 /* x */,
  0 /* r */,
  1 /* trapezoid.amplitude */,
  1 /* trapezoid.rising */,
  1 /* trapezoid.width */,
  1 /* trapezoid.falling */,
  1 /* trapezoid.period */,
  1 /* trapezoid.nperiod */,
  1 /* trapezoid.offset */,
  1 /* trapezoid.startTime */,
  1 /* trapezoid.T_rising */,
  1 /* trapezoid.T_width */,
  1 /* trapezoid.T_falling */
};

char var_attr[NX+NY+NP] = {
  1+0 /* $dummy */,
  1+0 /* trapezoid.y */,
  1+16 /* trapezoid.T0 */,
  4+16 /* trapezoid.counter */,
  4+16 /* trapezoid.counter2 */,
  1+0 /* y */,
  1+0 /* x */,
  1+0 /* r */,
  1+0 /* trapezoid.amplitude */,
  1+0 /* trapezoid.rising */,
  1+0 /* trapezoid.width */,
  1+0 /* trapezoid.falling */,
  1+0 /* trapezoid.period */,
  4+16 /* trapezoid.nperiod */,
  1+0 /* trapezoid.offset */,
  1+0 /* trapezoid.startTime */,
  1+0 /* trapezoid.T_rising */,
  1+0 /* trapezoid.T_width */,
  1+0 /* trapezoid.T_falling */
};

#define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))

int encounteredDivisionByZero = 0;

double division_error(double b, const char* division_str)
{
  if(!encounteredDivisionByZero) {
    fprintf(stderr, "ERROR: Division by zero in partial equation: %s.\n",division_str);
    encounteredDivisionByZero = 1;
  }
  return b;
}

void setLocalData(DATA* data)
{
  localData = data;
}

DATA* initializeDataStruc(DATA_FLAGS flags)
{
  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData->nStates = NX;
  returnData->nAlgebraic = NY;
  returnData->nParameters = NP;
  returnData->nInputVars = NI;
  returnData->nOutputVars = NO;
  returnData->nZeroCrossing = NG;
  returnData->nInitialResiduals = NR;
  returnData->nHelpVars = NHELP;
  returnData->stringVariables.nParameters = NPSTR;
  returnData->stringVariables.nAlgebraic = NYSTR;

  if(flags & STATES && returnData->nStates) {
    returnData->states = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStates = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStates2 = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->states&&returnData->oldStates&&returnData->oldStates2);
    memset(returnData->states,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStates,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStates2,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->states = 0;
    returnData->oldStates = 0;
    returnData->oldStates2 = 0;
  }

  if(flags & STATESDERIVATIVES && returnData->nStates) {
    returnData->statesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
    returnData->oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData->nStates);
    assert(returnData->statesDerivatives&&returnData->oldStatesDerivatives&&returnData->oldStatesDerivatives2);
    memset(returnData->statesDerivatives,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStatesDerivatives,0,sizeof(double)*returnData->nStates);
    memset(returnData->oldStatesDerivatives2,0,sizeof(double)*returnData->nStates);
  } else {
    returnData->statesDerivatives = 0;
    returnData->oldStatesDerivatives = 0;
    returnData->oldStatesDerivatives2 = 0;
  }

  if(flags & HELPVARS && returnData->nHelpVars) {
    returnData->helpVars = (double*) malloc(sizeof(double)*returnData->nHelpVars);
    assert(returnData->helpVars);
    memset(returnData->helpVars,0,sizeof(double)*returnData->nHelpVars);
  } else {
    returnData->helpVars = 0;
  }

  if(flags & ALGEBRAICS && returnData->nAlgebraic) {
    returnData->algebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->oldAlgebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    returnData->oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
    assert(returnData->algebraics&&returnData->oldAlgebraics&&returnData->oldAlgebraics2);
    memset(returnData->algebraics,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->oldAlgebraics,0,sizeof(double)*returnData->nAlgebraic);
    memset(returnData->oldAlgebraics2,0,sizeof(double)*returnData->nAlgebraic);
  } else {
    returnData->algebraics = 0;
    returnData->oldAlgebraics = 0;
    returnData->oldAlgebraics2 = 0;
    returnData->stringVariables.algebraics = 0;
  }

  if (flags & ALGEBRAICS && returnData->stringVariables.nAlgebraic) {
    returnData->stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData->stringVariables.nAlgebraic);
    assert(returnData->stringVariables.algebraics);
    memset(returnData->stringVariables.algebraics,0,sizeof(char*)*returnData->stringVariables.nAlgebraic);
  } else {
    returnData->stringVariables.algebraics=0;
  }

  if(flags & PARAMETERS && returnData->nParameters) {
    returnData->parameters = (double*) malloc(sizeof(double)*returnData->nParameters);
    assert(returnData->parameters);
    memset(returnData->parameters,0,sizeof(double)*returnData->nParameters);
  } else {
    returnData->parameters = 0;
  }

  if (flags & PARAMETERS && returnData->stringVariables.nParameters) {
        returnData->stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData->stringVariables.nParameters);
      assert(returnData->stringVariables.parameters);
      memset(returnData->stringVariables.parameters,0,sizeof(char*)*returnData->stringVariables.nParameters);
  } else {
      returnData->stringVariables.parameters=0;
  }

  if(flags & OUTPUTVARS && returnData->nOutputVars) {
    returnData->outputVars = (double*) malloc(sizeof(double)*returnData->nOutputVars);
    assert(returnData->outputVars);
    memset(returnData->outputVars,0,sizeof(double)*returnData->nOutputVars);
  } else {
    returnData->outputVars = 0;
  }

  if(flags & INPUTVARS && returnData->nInputVars) {
    returnData->inputVars = (double*) malloc(sizeof(double)*returnData->nInputVars);
    assert(returnData->inputVars);
    memset(returnData->inputVars,0,sizeof(double)*returnData->nInputVars);
  } else {
    returnData->inputVars = 0;
  }

  if(flags & INITIALRESIDUALS && returnData->nInitialResiduals) {
    returnData->initialResiduals = (double*) malloc(sizeof(double)*returnData->nInitialResiduals);
    assert(returnData->initialResiduals);
    memset(returnData->initialResiduals,0,sizeof(double)*returnData->nInitialResiduals);
  } else {
    returnData->initialResiduals = 0;
  }

  if(flags & INITFIXED) {
    returnData->initFixed = init_fixed;
  } else {
    returnData->initFixed = 0;
  }

  /*   names   */
  if(flags & MODELNAME) {
    returnData->modelName = model_name;
  } else {
    returnData->modelName = 0;
  }

  if(flags & STATESNAMES) {
    returnData->statesNames = state_names;
  } else {
    returnData->statesNames = 0;
  }

  if(flags & STATESDERIVATIVESNAMES) {
    returnData->stateDerivativesNames = derivative_names;
  } else {
    returnData->stateDerivativesNames = 0;
  }

  if(flags & ALGEBRAICSNAMES) {
    returnData->algebraicsNames = algvars_names;
  } else {
    returnData->algebraicsNames = 0;
  }

  if(flags & PARAMETERSNAMES) {
    returnData->parametersNames = param_names;
  } else {
    returnData->parametersNames = 0;
  }

  if(flags & INPUTNAMES) {
    returnData->inputNames = input_names;
  } else {
    returnData->inputNames = 0;
  }

  if(flags & OUTPUTNAMES) {
    returnData->outputNames = output_names;
  } else {
    returnData->outputNames = 0;
  }

  /*   comments  */
  if(flags & STATESCOMMENTS) {
    returnData->statesComments = state_comments;
  } else {
    returnData->statesComments = 0;
  }

  if(flags & STATESDERIVATIVESCOMMENTS) {
    returnData->stateDerivativesComments = derivative_comments;
  } else {
    returnData->stateDerivativesComments = 0;
  }

  if(flags & ALGEBRAICSCOMMENTS) {
    returnData->algebraicsComments = algvars_comments;
  } else {
    returnData->algebraicsComments = 0;
  }

  if(flags & PARAMETERSCOMMENTS) {
    returnData->parametersComments = param_comments;
  } else {
    returnData->parametersComments = 0;
  }

  if(flags & INPUTCOMMENTS) {
    returnData->inputComments = input_comments;
  } else {
    returnData->inputComments = 0;
  }

  if(flags & OUTPUTCOMMENTS) {
    returnData->outputComments = output_comments;
  } else {
    returnData->outputComments = 0;
  }

  if (flags & EXTERNALVARS) {
    returnData->extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData->extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData->extObjs,0,sizeof(void*)*NEXT);
    setLocalData(returnData); /* must be set since used by constructors*/
  }
  return returnData;
}

void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
{
  if(!data)
    return;

  if(flags & STATES && data->states) {
    free(data->states);
    data->states = 0;
  }

  if(flags & STATESDERIVATIVES && data->statesDerivatives) {
    free(data->statesDerivatives);
    data->statesDerivatives = 0;
  }

  if(flags & ALGEBRAICS && data->algebraics) {
    free(data->algebraics);
    data->algebraics = 0;
  }

  if(flags & PARAMETERS && data->parameters) {
    free(data->parameters);
    data->parameters = 0;
  }

  if(flags & OUTPUTVARS && data->inputVars) {
    free(data->inputVars);
    data->inputVars = 0;
  }

  if(flags & INPUTVARS && data->outputVars) {
    free(data->outputVars);
    data->outputVars = 0;
  }

  if(flags & INITIALRESIDUALS && data->initialResiduals){
    free(data->initialResiduals);
    data->initialResiduals = 0;
  }
  if (flags & EXTERNALVARS && data->extObjs) {
    free(data->extObjs);
    data->extObjs = 0;
  }
}

/* for continuous time variables */
int functionDAE_output()
{
  state mem_state;
  modelica_boolean tmp3;
  modelica_string tmp4;
  modelica_boolean tmp5;
  modelica_string tmp6;
  modelica_boolean tmp7;
  modelica_string tmp8;
  modelica_string tmp9;
  
  mem_state = get_memory_state();
  $r = #non-template-implemented expression#;
  notimplemented = 0;
  tmp3 = #non-template-implemented expression#;
  if(tmp3) {
  }
  else {
    cat_modelica_string(&tmp4,&(modelica_integer)$trapezoid$PT0,&(modelica_integer)$trapezoid$PT_rising);
    tmp5 = (!(modelica_integer)time && tmp4);
    if(tmp5) {
    }
    else {
      cat_modelica_string(&tmp6,&(modelica_integer)$trapezoid$PT0,&(modelica_integer)$trapezoid$PT_width);
      tmp7 = (!(modelica_integer)time && tmp6);
      if(tmp7) {
      }
      else {
        cat_modelica_string(&tmp8,&(modelica_integer)$trapezoid$PT0,&(modelica_integer)$trapezoid$PT_falling);
      }
    }
  }
  cat_modelica_string(&tmp9,&(modelica_integer)$trapezoid$Poffset,&((tmp3)?0.0:((tmp5)?((((modelica_integer)time - (modelica_integer)$trapezoid$PT0) * (modelica_integer)$trapezoid$Pamplitude) / (modelica_integer)$trapezoid$PT_rising):((tmp7)?(modelica_integer)$trapezoid$Pamplitude:(((tmp8 - (modelica_integer)time) * (modelica_integer)$trapezoid$Pamplitude) / ((modelica_integer)$trapezoid$PT_falling - (modelica_integer)$trapezoid$PT_width))))));
  $trapezoid$Py = tmp9;
  restore_memory_state(mem_state);
  
  return 0;
}

/* for discrete time variables */
int functionDAE_output2()
{
  state mem_state;
  
  mem_state = get_memory_state();
  notimplemented = 0;
  notimplemented = 0;
  notimplemented = 0;
  restore_memory_state(mem_state);
  
  return 0;
}

int input_function()
{
  return 0;
}

int output_function()
{
  localData->outputVars[0] = $trapezoid$Py;
  localData->outputVars[1] = $y;
  localData->outputVars[2] = $x;
  localData->outputVars[3] = $r;
  return 0;
}

int functionDAE_res(double *t, double *x, double *xd, double *delta,
                    long int *ires, double *rpar, long int* ipar)
{
  int i;
  double temp_xd[NX];
  double* statesBackup;
  double* statesDerivativesBackup;
  double timeBackup;

  statesBackup = localData->states;
  statesDerivativesBackup = localData->statesDerivatives;
  timeBackup = localData->timeValue;
  localData->states = x;

  for (i=0; i<localData->nStates; i++) {
    temp_xd[i] = localData->statesDerivatives[i];
  }

  localData->statesDerivatives = temp_xd;
  localData->timeValue = *t;

  functionODE();

  /* get the difference between the temp_xd(=localData->statesDerivatives)
     and xd(=statesDerivativesBackup) */
  for (i=0; i < localData->nStates; i++) {
    delta[i] = localData->statesDerivatives[i] - statesDerivativesBackup[i];
  }

  localData->states = statesBackup;
  localData->statesDerivatives = statesDerivativesBackup;
  localData->timeValue = timeBackup;

  if (modelErrorCode) {
    if (ires) {
      *ires = -1;
    }
    modelErrorCode =0;
  }

  return 0;
}

int function_zeroCrossing(long *neqm, double *t, double *x, long *ng,
                          double *gout, double *rpar, long* ipar)
{
  // TODO: Implement this
  fprintf(stderr, "ERROR: function_zeroCrossing not implemented\n");
  return 0;
}

int handleZeroCrossing(long index)
{
  // TODO: Implement this
  fprintf(stderr, "ERROR: handleZeroCrossing not implemented\n");
  return 0;
}

int function_updateDependents()
{
  // TODO: Implement this
  fprintf(stderr, "ERROR: function_updateDependents not implemented\n");
  return 0;
}

int function_when(int i)
{
  // TODO: Implement this
  fprintf(stderr, "ERROR: whenFunction not implemented\n");
  return 0;
}

int functionODE()
{
  state mem_state;
  
  mem_state = get_memory_state();
  $DER$$dummy = 0.0;
  restore_memory_state(mem_state);
  
  return 0;
}

int initial_function()
{
  state mem_state;
  modelica_string tmp10;
  modelica_string tmp11;
  
  mem_state = get_memory_state();
  trapezoid.counter2 = (modelica_integer)$trapezoid$Pnperiod;
  trapezoid.counter = (modelica_integer)$trapezoid$Pnperiod;
  trapezoid.T0 = (modelica_integer)$trapezoid$PstartTime;
  cat_modelica_string(&tmp10,&(modelica_integer)$trapezoid$PT_width,&(modelica_integer)$trapezoid$Pfalling);
  $trapezoid$PT_falling = tmp10;
  cat_modelica_string(&tmp11,&(modelica_integer)$trapezoid$PT_rising,&(modelica_integer)$trapezoid$Pwidth);
  $trapezoid$PT_width = tmp11;
  $trapezoid$PT_rising = (modelica_integer)$trapezoid$Prising;
  restore_memory_state(mem_state);
  
  return 0;
}

int initial_residual()
{
  int i = 0;
  state mem_state;
  modelica_boolean tmp12;
  modelica_string tmp13;
  modelica_boolean tmp14;
  modelica_string tmp15;
  modelica_boolean tmp16;
  modelica_string tmp17;
  modelica_string tmp18;
  
  mem_state = get_memory_state();
  tmp12 = #non-template-implemented expression#;
  if(tmp12) {
  }
  else {
    cat_modelica_string(&tmp13,&(modelica_integer)$trapezoid$PT0,&(modelica_integer)$trapezoid$PT_rising);
    tmp14 = (!(modelica_integer)time && tmp13);
    if(tmp14) {
    }
    else {
      cat_modelica_string(&tmp15,&(modelica_integer)$trapezoid$PT0,&(modelica_integer)$trapezoid$PT_width);
      tmp16 = (!(modelica_integer)time && tmp15);
      if(tmp16) {
      }
      else {
        cat_modelica_string(&tmp17,&(modelica_integer)$trapezoid$PT0,&(modelica_integer)$trapezoid$PT_falling);
      }
    }
  }
  cat_modelica_string(&tmp18,&(modelica_integer)$trapezoid$Poffset,&((tmp12)?0.0:((tmp14)?((((modelica_integer)time - (modelica_integer)$trapezoid$PT0) * (modelica_integer)$trapezoid$Pamplitude) / (modelica_integer)$trapezoid$PT_rising):((tmp16)?(modelica_integer)$trapezoid$Pamplitude:(((tmp17 - (modelica_integer)time) * (modelica_integer)$trapezoid$Pamplitude) / ((modelica_integer)$trapezoid$PT_falling - (modelica_integer)$trapezoid$PT_width))))));
  localData->initialResiduals[i++] = ((modelica_integer)$trapezoid$Py - tmp18);
  localData->initialResiduals[i++] = ((modelica_integer)$r - #non-template-implemented expression#);
  localData->initialResiduals[i++] = (modelica_integer)$DER$$dummy;
  restore_memory_state(mem_state);
  
  return 0;
}

int bound_parameters()
{
  // TODO: Implement this
  fprintf(stderr, "ERROR: boundParametersFunction not implemented\n");
  return 0;
}

int checkForDiscreteVarChanges()
{
  int needToIterate = 0;

  for (long i = 0; i < localData->nHelpVars; i++) {
    if (change(localData->helpVars[i])) {
      needToIterate=1;
    }
  }

  return needToIterate;
}