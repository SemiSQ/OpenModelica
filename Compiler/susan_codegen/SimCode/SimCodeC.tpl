// This file defines templates for transforming an internal representation of a
// Modelica program to C code.
//
// When compiling a model the following files will be created:
//
// Model.cpp
// Model_functions.cpp
// Model_init.txt
// Model.makefile
//
// The following template functions generate the content of these files:
//
// cppFile
// functionsFile
// initFile
// makefile

spackage SimCodeC

typeview "SimCodeTV.mo"

// Root template for simulation "target"
translateModel(SimCode simCode) ::=
  case SIMCODE(modelInfo = MODELINFO) then
    # cppFileContent = cppFile(simCode)
    # textFile(cppFileContent, '<modelInfo.name>.cpp')
    # functionsFileContent = functionsCpp('<functions>')
    # textFile(functionsFileContent, '<modelInfo.name>_functions.cpp')
    //initFile(...)
    //makefile(...)
    () // empty result

// Root template for function library "target"
//translateFunction(...) ::=
//    ...

cppFile(SimCode simCode) ::=
case SIMCODE(modelInfo = MODELINFO) then
<<
// Simulation code for <modelInfo.name> generated by the OpenModelica Compiler.

#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
  #define DLLExport   __declspec( dllexport )
#else 
  #define DLLExport /* nothing */
#endif 

#include "<modelInfo.name>_functions.cpp"

<globalData(modelInfo)>

<functionGetName(modelInfo)>

<functionDivisionError()>

<functionSetLocalData()>

<functionInitializeDataStruc()>

<functionDeInitializeDataStruc()>

<functionDaeOutput(nonStateContEquations, removedEquations)>

<functionDaeOutput2(nonStateDiscEquations, removedEquations)>

<functionInput(modelInfo)>

<functionOutput(modelInfo)>

<functionDaeRes()>

<functionZeroCrossing(zeroCrossings)>

<functionHandleZeroCrossing(zeroCrossingsNeedSave)>

<functionUpdateDependents(allEquations, helpVarInfo)>

<functionOnlyZeroCrossing(zeroCrossings)>

<functionWhen(whenClauses)>

<functionOde(stateContEquations)>

<functionInitial(initialEquations)>

<functionInitialResidual(residualEquations)>

<functionBoundParameters(parameterEquations)>

<functionCheckForDiscreteVarChanges(helpVarInfo, discreteModelVars)>
>>

globalData(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
#define NHELP <varInfo.numHelpVars>
#define NG <varInfo.numZeroCrossings>
#define NX <varInfo.numStateVars>
#define NY <varInfo.numAlgVars>
#define NP <varInfo.numParams>
#define NO <varInfo.numOutVars>
#define NI <varInfo.numInVars>
#define NR <varInfo.numResiduals>
#define NEXT <varInfo.numExternalObjects>
#define MAXORD 5
#define NYSTR <varInfo.numStringAlgVars>
#define NPSTR <varInfo.numStringParamVars>

static DATA* localData = 0;
#define time localData-\>timeValue
extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
  char *model_name="<name>";
  char *model_dir="<directory>";
}

<utilStaticStringArray("state_names", vars.stateVars)>
<utilStaticStringArray("derivative_names", vars.derivativeVars)>
<utilStaticStringArray("algvars_names", vars.algVars)>
<utilStaticStringArray("input_names", vars.inputVars)>
<utilStaticStringArray("output_names", vars.outputVars)>
<utilStaticStringArray("param_names", vars.paramVars)>
<utilStaticStringArray("string_alg_names", vars.stringAlgVars)>
<utilStaticStringArray("string_param_names", vars.stringParamVars)>

<utilStaticStringArrayComment("state_comments", vars.stateVars)>
<utilStaticStringArrayComment("derivative_comments", vars.derivativeVars)>
<utilStaticStringArrayComment("algvars_comments", vars.algVars)>
<utilStaticStringArrayComment("input_comments", vars.inputVars)>
<utilStaticStringArrayComment("output_comments", vars.outputVars)>
<utilStaticStringArrayComment("param_comments", vars.paramVars)>
<utilStaticStringArrayComment("string_alg_comments", vars.stringAlgVars)>
<utilStaticStringArrayComment("string_param_comments", vars.stringParamVars)>

<vars.stateVars of var as SIMVAR: define(it, "states") "\n">
<vars.derivativeVars of var as SIMVAR: define(it, "statesDerivatives") "\n">
<vars.algVars of var as SIMVAR: define(it, "algebraics") "\n">
<vars.paramVars of var as SIMVAR: define(it, "parameters") "\n">
<vars.extObjVars of var as SIMVAR: define(it, "extObjs") "\n">

static char init_fixed[NX+NX+NY+NP] = {
  <[(vars.stateVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.derivativeVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.algVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.paramVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n")] ",\n">
};

char var_attr[NX+NY+NP] = {
  <[(vars.stateVars of var as SIMVAR:
      '<typeAttrInt(type_)>+<discreteAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n"),
    (vars.algVars of var as SIMVAR:
      '<typeAttrInt(type_)>+<discreteAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n"),
    (vars.paramVars of var as SIMVAR:
      '<typeAttrInt(type_)>+<discreteAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n")] ",\n">
};
>>

functionGetName(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
char* getName(double* ptr)
{
  <vars.stateVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return state_names[<var.index>];' "\n">
  <vars.derivativeVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return derivative_names[<var.index>];' "\n">
  <vars.algVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return algvars_names[<var.index>];' "\n">
  <vars.paramVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return param_names[<var.index>];' "\n">
  return "";
}
>>

define(SimVar, String arrayName) ::=
case SIMVAR(arrayCref=SOME(c)) then
  <<
  #define <cref(c)> localData-\><arrayName>[<index>]
  #define <cref(name)> localData-\><arrayName>[<index>]
  >>
case SIMVAR then
  <<
  #define <cref(name)> localData-\><arrayName>[<index>]
  >>

functionDivisionError() ::=
<<
#define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))

int encounteredDivisionByZero = 0;

double division_error(double b, const char* division_str)
{
  if(!encounteredDivisionByZero) {
    fprintf(stderr, "ERROR: Division by zero in partial equation: %s.\n",division_str);
    encounteredDivisionByZero = 1;
  }
  return b;
}
>>

functionSetLocalData() ::=
<<
void setLocalData(DATA* data)
{
  localData = data;
}
>>

functionInitializeDataStruc() ::=
<<
DATA* initializeDataStruc(DATA_FLAGS flags)
{
  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData-\>nStates = NX;
  returnData-\>nAlgebraic = NY;
  returnData-\>nParameters = NP;
  returnData-\>nInputVars = NI;
  returnData-\>nOutputVars = NO;
  returnData-\>nZeroCrossing = NG;
  returnData-\>nInitialResiduals = NR;
  returnData-\>nHelpVars = NHELP;
  returnData-\>stringVariables.nParameters = NPSTR;
  returnData-\>stringVariables.nAlgebraic = NYSTR;

  if(flags & STATES && returnData-\>nStates) {
    returnData-\>states = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStates = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStates2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
    assert(returnData-\>states&&returnData-\>oldStates&&returnData-\>oldStates2);
    memset(returnData-\>states,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStates,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStates2,0,sizeof(double)*returnData-\>nStates);
  } else {
    returnData-\>states = 0;
    returnData-\>oldStates = 0;
    returnData-\>oldStates2 = 0;
  }

  if(flags & STATESDERIVATIVES && returnData-\>nStates) {
    returnData-\>statesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
    assert(returnData-\>statesDerivatives&&returnData-\>oldStatesDerivatives&&returnData-\>oldStatesDerivatives2);
    memset(returnData-\>statesDerivatives,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStatesDerivatives,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStatesDerivatives2,0,sizeof(double)*returnData-\>nStates);
  } else {
    returnData-\>statesDerivatives = 0;
    returnData-\>oldStatesDerivatives = 0;
    returnData-\>oldStatesDerivatives2 = 0;
  }

  if(flags & HELPVARS && returnData-\>nHelpVars) {
    returnData-\>helpVars = (double*) malloc(sizeof(double)*returnData-\>nHelpVars);
    assert(returnData-\>helpVars);
    memset(returnData-\>helpVars,0,sizeof(double)*returnData-\>nHelpVars);
  } else {
    returnData-\>helpVars = 0;
  }

  if(flags & ALGEBRAICS && returnData-\>nAlgebraic) {
    returnData-\>algebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    returnData-\>oldAlgebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    returnData-\>oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    assert(returnData-\>algebraics&&returnData-\>oldAlgebraics&&returnData-\>oldAlgebraics2);
    memset(returnData-\>algebraics,0,sizeof(double)*returnData-\>nAlgebraic);
    memset(returnData-\>oldAlgebraics,0,sizeof(double)*returnData-\>nAlgebraic);
    memset(returnData-\>oldAlgebraics2,0,sizeof(double)*returnData-\>nAlgebraic);
  } else {
    returnData-\>algebraics = 0;
    returnData-\>oldAlgebraics = 0;
    returnData-\>oldAlgebraics2 = 0;
    returnData-\>stringVariables.algebraics = 0;
  }

  if (flags & ALGEBRAICS && returnData-\>stringVariables.nAlgebraic) {
    returnData-\>stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
    assert(returnData-\>stringVariables.algebraics);
    memset(returnData-\>stringVariables.algebraics,0,sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
  } else {
    returnData-\>stringVariables.algebraics=0;
  }

  if(flags & PARAMETERS && returnData-\>nParameters) {
    returnData-\>parameters = (double*) malloc(sizeof(double)*returnData-\>nParameters);
    assert(returnData-\>parameters);
    memset(returnData-\>parameters,0,sizeof(double)*returnData-\>nParameters);
  } else {
    returnData-\>parameters = 0;
  }

  if (flags & PARAMETERS && returnData-\>stringVariables.nParameters) {
  	  returnData-\>stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nParameters);
      assert(returnData-\>stringVariables.parameters);
      memset(returnData-\>stringVariables.parameters,0,sizeof(char*)*returnData-\>stringVariables.nParameters);
  } else {
      returnData-\>stringVariables.parameters=0;
  }

  if(flags & OUTPUTVARS && returnData-\>nOutputVars) {
    returnData-\>outputVars = (double*) malloc(sizeof(double)*returnData-\>nOutputVars);
    assert(returnData-\>outputVars);
    memset(returnData-\>outputVars,0,sizeof(double)*returnData-\>nOutputVars);
  } else {
    returnData-\>outputVars = 0;
  }

  if(flags & INPUTVARS && returnData-\>nInputVars) {
    returnData-\>inputVars = (double*) malloc(sizeof(double)*returnData-\>nInputVars);
    assert(returnData-\>inputVars);
    memset(returnData-\>inputVars,0,sizeof(double)*returnData-\>nInputVars);
  } else {
    returnData-\>inputVars = 0;
  }

  if(flags & INITIALRESIDUALS && returnData-\>nInitialResiduals) {
    returnData-\>initialResiduals = (double*) malloc(sizeof(double)*returnData-\>nInitialResiduals);
    assert(returnData-\>initialResiduals);
    memset(returnData-\>initialResiduals,0,sizeof(double)*returnData-\>nInitialResiduals);
  } else {
    returnData-\>initialResiduals = 0;
  }

  if(flags & INITFIXED) {
    returnData-\>initFixed = init_fixed;
  } else {
    returnData-\>initFixed = 0;
  }

  /*   names   */
  if(flags & MODELNAME) {
    returnData-\>modelName = model_name;
  } else {
    returnData-\>modelName = 0;
  }
  
  if(flags & STATESNAMES) {
    returnData-\>statesNames = state_names;
  } else {
    returnData-\>statesNames = 0;
  }

  if(flags & STATESDERIVATIVESNAMES) {
    returnData-\>stateDerivativesNames = derivative_names;
  } else {
    returnData-\>stateDerivativesNames = 0;
  }

  if(flags & ALGEBRAICSNAMES) {
    returnData-\>algebraicsNames = algvars_names;
  } else {
    returnData-\>algebraicsNames = 0;
  }

  if(flags & PARAMETERSNAMES) {
    returnData-\>parametersNames = param_names;
  } else {
    returnData-\>parametersNames = 0;
  }

  if(flags & INPUTNAMES) {
    returnData-\>inputNames = input_names;
  } else {
    returnData-\>inputNames = 0;
  }

  if(flags & OUTPUTNAMES) {
    returnData-\>outputNames = output_names;
  } else {
    returnData-\>outputNames = 0;
  }

  /*   comments  */
  if(flags & STATESCOMMENTS) {
    returnData-\>statesComments = state_comments;
  } else {
    returnData-\>statesComments = 0;
  }

  if(flags & STATESDERIVATIVESCOMMENTS) {
    returnData-\>stateDerivativesComments = derivative_comments;
  } else {
    returnData-\>stateDerivativesComments = 0;
  }

  if(flags & ALGEBRAICSCOMMENTS) {
    returnData-\>algebraicsComments = algvars_comments;
  } else {
    returnData-\>algebraicsComments = 0;
  }

  if(flags & PARAMETERSCOMMENTS) {
    returnData-\>parametersComments = param_comments;
  } else {
    returnData-\>parametersComments = 0;
  }

  if(flags & INPUTCOMMENTS) {
    returnData-\>inputComments = input_comments;
  } else {
    returnData-\>inputComments = 0;
  }

  if(flags & OUTPUTCOMMENTS) {
    returnData-\>outputComments = output_comments;
  } else {
    returnData-\>outputComments = 0;
  }

  if (flags & EXTERNALVARS) {
    returnData-\>extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData-\>extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData-\>extObjs,0,sizeof(void*)*NEXT);
    setLocalData(returnData); /* must be set since used by constructors*/
  }
  return returnData;
}
>>

functionDeInitializeDataStruc() ::=
<<
void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
{
  if(!data)
    return;

  if(flags & STATES && data-\>states) {
    free(data-\>states);
    data-\>states = 0;
  }

  if(flags & STATESDERIVATIVES && data-\>statesDerivatives) {
    free(data-\>statesDerivatives);
    data-\>statesDerivatives = 0;
  }

  if(flags & ALGEBRAICS && data-\>algebraics) {
    free(data-\>algebraics);
    data-\>algebraics = 0;
  }

  if(flags & PARAMETERS && data-\>parameters) {
    free(data-\>parameters);
    data-\>parameters = 0;
  }

  if(flags & OUTPUTVARS && data-\>inputVars) {
    free(data-\>inputVars);
    data-\>inputVars = 0;
  }

  if(flags & INPUTVARS && data-\>outputVars) {
    free(data-\>outputVars);
    data-\>outputVars = 0;
  }
  
  if(flags & INITIALRESIDUALS && data-\>initialResiduals){
    free(data-\>initialResiduals);
    data-\>initialResiduals = 0;
  }
  if (flags & EXTERNALVARS && data-\>extObjs) {
    free(data-\>extObjs);
    data-\>extObjs = 0;
  }
}
>>

functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations) ::=
# varDecls = ""
# body = (nonStateContEquations of eq: '<equation_(eq, createSimulationContext(), varDecls)>' "\n")
# body2 = (removedEquations of eq: '<equation_(eq, createSimulationContext(), varDecls)>' "\n")
<<
/* for continuous time variables */
int functionDAE_output()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>
  <body2>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
# varDecls = ""
# body = (nonStateDiscEquations of eq: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
# body2 = (removedEquations of eq: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
/* for discrete time variables */
int functionDAE_output2()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>
  <body2>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionInput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
int input_function()
{
  <vars.inputVars of var as SIMVAR:
    '<cref(name)> = localData-\>inputVars[<i0>];' "\n">
  return 0;
}
>>

functionOutput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
int output_function()
{
  <vars.outputVars of var as SIMVAR:
    'localData-\>outputVars[<i0>] = <cref(name)>;' "\n">
  return 0;
}
>>

functionDaeRes() ::=
<<
int functionDAE_res(double *t, double *x, double *xd, double *delta,
                    long int *ires, double *rpar, long int* ipar)
{
  int i;
  double temp_xd[NX];
  double* statesBackup;
  double* statesDerivativesBackup;
  double timeBackup;

  statesBackup = localData-\>states;
  statesDerivativesBackup = localData-\>statesDerivatives;
  timeBackup = localData-\>timeValue;
  localData-\>states = x;

  for (i=0; i\<localData-\>nStates; i++) {
    temp_xd[i] = localData-\>statesDerivatives[i];
  }

  localData-\>statesDerivatives = temp_xd;
  localData-\>timeValue = *t;

  functionODE();

  /* get the difference between the temp_xd(=localData-\>statesDerivatives)
     and xd(=statesDerivativesBackup) */
  for (i=0; i \< localData-\>nStates; i++) {
    delta[i] = localData-\>statesDerivatives[i] - statesDerivativesBackup[i];
  }

  localData-\>states = statesBackup;
  localData-\>statesDerivatives = statesDerivativesBackup;
  localData-\>timeValue = timeBackup;

  if (modelErrorCode) {
    if (ires) {
      *ires = -1;
    }
    modelErrorCode =0;
  }

  return 0;
}
>>

functionZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
# varDecls = ""
# zeroCrossingCode = zeroCrossingsTpl(zeroCrossings, varDecls)
<<
int function_zeroCrossing(long *neqm, double *t, double *x, long *ng,
                          double *gout, double *rpar, long* ipar)
{
  double timeBackup;
  state mem_state;

  mem_state = get_memory_state();

  timeBackup = localData->timeValue;
  localData->timeValue = *t;
  <varDecls>

  functionODE();
  functionDAE_output();

  <zeroCrossingCode>

  restore_memory_state(mem_state);
  localData->timeValue = timeBackup;

  return 0;
}
>>

// This function should only save in cases. The rest is done in
// function_updateDependents.
functionHandleZeroCrossing(list<list<ComponentRef>> zeroCrossingsNeedSave) ::=
<<
int handleZeroCrossing(long index)
{
  state mem_state;

  mem_state = get_memory_state();

  switch(index) {
    <zeroCrossingsNeedSave of crefs:
      'case <i0>:<\n><crefs of cref: '  save(<cref(cref)>);' "\n"><\n>  break;' "\n">
    default:
      break;
  }

  restore_memory_state(mem_state);

  return 0;
}
>>

functionUpdateDependents(list<SimEqSystem> allEquations,
                         list<HelpVarInfo> helpVarInfo) ::=
# varDecls = ""
# eq1 = (allEquations of eq: '<equation_(eq, createSimulationContext(), varDecls)>' "\n")
# hvars = (
  helpVarInfo of (in1, exp, _):
    # preExp = ""
    # expPart = daeExp(exp, createSimulationContext(), preExp, varDecls)
    '<preExp>localData->helpVars[<in1>] = <expPart>;'
  "\n"
)
<<
int function_updateDependents()
{
  state mem_state;
  <varDecls>

  inUpdate=initial()?0:1;

  mem_state = get_memory_state();

  <eq1>
  <hvars>

  restore_memory_state(mem_state);

  inUpdate=0;

  return 0;
}
>>

functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
# varDecls = ""
# zeroCrossingCode = zeroCrossingsTpl(zeroCrossings, varDecls)
<<
int function_onlyZeroCrossings(double *gout,double *t)
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <zeroCrossingCode>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionWhen(list<SimWhenClause> whenClauses) ::=
# varDecls = ""
# cases = whenClauses of whenClause as SIM_WHEN_CLAUSE:
  <<
  case <i0>:
    <whenEqTpl(whenEq, varDecls)>
    <reinits of reinit:
      # preExp = ""
      # body = reinit(reinit, preExp, varDecls)
      '<preExp><\n><body>'
    "\n">
    break;<\n>
  >>
<<
int function_when(int i)
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  switch(i) {
    <cases>
    default:
      break;
  }

  restore_memory_state(mem_state);

  return 0;
}
>>

functionOde(list<SimEqSystem> stateContEquations) ::=
# varDecls = ""
# body = (stateContEquations of eq: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
int functionODE()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionInitial(list<SimEqSystem> initialEquations) ::=
# varDecls = ""
# body = (initialEquations of eq as SES_SIMPLE_ASSIGN: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
int initial_function()
{
  <varDecls>

  <body>

  <initialEquations of eq as SES_SIMPLE_ASSIGN:
    'if (sim_verbose) { printf("Setting variable start value: %s(start=%f)\n", "<cref(componentRef)>", <cref(componentRef)>); }' "\n">

  return 0;
}
>>

functionInitialResidual(list<SimEqSystem> residualEquations) ::=
# varDecls = ""
# body = (
  residualEquations of eq as SES_RESIDUAL:
    if exp is DAE.SCONST then
      'localData-\>initialResiduals[i++] = 0;'
    else
      # preExp = ""
      # expPart = daeExp(exp, createOtherContext(), preExp, varDecls)
      '<preExp>localData-\>initialResiduals[i++] = <expPart>;'
  "\n"
)
<<
int initial_residual()
{
  int i = 0;
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
# varDecls = ""
# body = (parameterEquations of eq as SES_SIMPLE_ASSIGN: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
int bound_parameters()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

// TODO: Is the -1 thing really correct? It seems to work.
functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfo,
                                   list<ComponentRef> discreteModelVars) ::=
<<
int checkForDiscreteVarChanges()
{
  int needToIterate = 0;

  <helpVarInfo of (id1, exp, id2):
    if id2 is not -1 then
    'if (edge(localData-\>helpVars[<id1>])) AddEvent(<id2> + localData-\>nZeroCrossing);'
  "\n">

  <discreteModelVars of var:
    'if (change(<cref(var)>)) { needToIterate = 1; }' "\n">
  
  for (long i = 0; i \< localData-\>nHelpVars; i++) {
    if (change(localData-\>helpVars[i])) {
      needToIterate=1;
    }
  }

  return needToIterate;
}
>>

//functionsFile() ::=
//<<
//#ifdef __cplusplus
//extern "C" {
//#endif
//
///* Header part */
///* End of header part */
//
///* Body */
///* End body */
//
//#ifdef __cplusplus
//}
//#endif
//>>
//
//initFile() ::=
//<<
//>>
//
//makefile() ::=
//<<
//>>

reinit(ReinitStatement, Text preExp, Text varDecls) ::=
  case REINIT then
    # val = daeExp(value, createSimulationContext(), preExp, varDecls)
    <<
    <cref(stateVar)> = <val>;
    >>

// TODO: Better name?
zeroCrossingsTpl(list<ZeroCrossing> zeroCrossings, Text varDecls) ::=
  <<
  <zeroCrossings of zeroCrossing as ZERO_CROSSING:
    '<zeroCrossingTpl(i0, relation_, varDecls)>' "\n">
  >>

zeroCrossingTpl(Integer index, Exp relation, Text varDecls) ::=
  match relation
  case RELATION then
    # preExp = ""
    # e1 = daeExp(exp1, createOtherContext(), preExp, varDecls)
    # op = zeroCrossingOpFunc(operator)
    # e2 = daeExp(exp2, createOtherContext(), preExp, varDecls)
    <<
    <preExp>
    ZEROCROSSING(<index>, <op>(<e1>, <e2>));
    >>
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = ""
    # e1 = daeExp(start, createOtherContext(), preExp, varDecls)
    # e2 = daeExp(interval, createOtherContext(), preExp, varDecls)
    <<
    <preExp>
    ZEROCROSSING(<index>, Samle(*t, <e1>, <e2>));
    >>
  case _ then
    <<
    ZERO CROSSING ERROR
    >>

zeroCrossingOpFunc(Operator) ::=
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"

utilStaticStringArray(String name, list<SimVar> items) ::=
if items then
<<
char* <name>[<listLengthSimVar(items)>] = {<items of item as SIMVAR:
  '"<cref(origName)>"' ", ">};
>>
else
<<
char* <name>[1] = {""};
>>

utilStaticStringArrayComment(String name, list<SimVar> items) ::=
if items then
<<
char* <name>[<listLengthSimVar(items)>] = {<items of item as SIMVAR:
  '"<item.comment>"' ", ">};
>>
else
<<
char* <name>[1] = {""};
>>

// Residual equations are not handled here
equation_(SimEqSystem eq, Context context, Text varDecls) ::=
case SES_SIMPLE_ASSIGN then
# preExp = ""
# expPart = daeExp(exp, context, preExp, varDecls)
<<
<preExp>
<cref(componentRef)> = <expPart>;
>>
case SES_ARRAY_CALL_ASSIGN then // cref_array = call(...)
# preExp = ""
# expPart = daeExp(exp, context, preExp, varDecls)
<<
<preExp>
copy_real_array_data_mem(&<expPart>, &<cref(componentRef)>);
>>
case SES_ALGORITHM then
# stmt = (statements : algStatement(it, context, varDecls) \n) 
<<
<stmt>
>>
case SES_NOT_IMPLEMENTED then
<<
SES_NOT_IMPLEMENTED("<msg>");
>>
case _ then
<<
notimplemented = notimplemented;
>>

whenEqTpl(Option<WhenEquation>, Text varDecls) ::=
case SOME(weq as WHEN_EQ) then
# preExp = ""
# expPart = daeExp(weq.right, createSimulationContext(), preExp, varDecls)
<<
save(<cref(weq.left)>);

<preExp>
<cref(weq.left)> = <expPart>;
>>

boolToInt(Boolean) ::=
  case true  then "1"
  case false then "0"

// TODO: Correct type? Correct value?
typeAttrInt(DAE.ExpType) ::=
  case ET_REAL   then "1"
  case ET_STRING then "2"
  case ET_INT    then "4"
  case ET_BOOL   then "8"

discreteAttrInt(Boolean isDiscrete) ::=
  case true  then "16"
  case false then "0"

cref(ComponentRef) ::=
  case CREF_IDENT then '<ident><subscriptsTpl(subscriptLst)>'
  case _ then "CREF_NOT_IDENT"

subscriptsTpl(list<Subscript> subscripts) ::=
if subscripts then '[<subscripts of s: subscriptTpl(s) ",">]'
else ""

subscriptTpl(Subscript subscript) ::=
case INDEX then (
  match exp
  case ICONST then integer
  case _ then "SUBSCRIPT_NOT_CONSTANT"
)
case _ then "SUBSCRIPT_NOT_CONSTANT"

// TODO: Check with Codegen
expType(DAE.ExpType) ::=
  case ET_INT    then "modelica_integer"
  case ET_REAL   then "modelica_real"
  case ET_BOOL   then "modelica_boolean"
  case ET_STRING then "modelica_string"
  case ET_COMPLEX(complexClassType = EXTERNAL_OBJ)  then "void *" 
  case ET_OTHER  then "modelica_complex"
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "metamodelica_type"
  case ET_ARRAY then 
    match ty
    case ET_INT    then "integer_array"
    case ET_REAL   then "real_array"
    case ET_STRING then "string_array"
    case ET_BOOL   then "boolean_array"

expTypeArray(DAE.ExpType) ::=
  case ET_INT    then "integer_array"
  case ET_REAL   then "real_array"
  case ET_STRING then "string_array"
  case ET_BOOL   then "boolean_array"

// TODO: Check with Codegen
expShortType(DAE.ExpType) ::=
  case ET_INT    then "integer"
  case ET_REAL   then "real"
  case ET_STRING then "string"
  case ET_BOOL   then "boolean"
  case ET_OTHER  then "complex"
  case ET_ARRAY then expShortType(ty)   
  case ET_COMPLEX then 'struct <name>'  
  
// TODO: Check with Codegen (expTypeStr)
expTypeA(DAE.ExpType, Boolean isArray) ::=
  case ET_COMPLEX     then expShortType() // i.e. 'struct <name>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "metamodelica_type"

dotPath(Path) ::=
  case QUALIFIED      then '<name>.<dotPath(path)>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)

underscorePath(Path) ::=
  case QUALIFIED      then '<System.stringReplace(name, "_", "__")>_<underscorePath(path)>'
  case IDENT          then System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then underscorePath(path)


recordDeclaration(RecordDeclaration) ::=
  case RECORD_DECL_FULL then
<<
struct <name> {
  <variables of var as VARIABLE :
      if expType(ty) then '<it> <cref(var.name)>;'
      else '/* <cref(var.name)> is an odd member. */'
  \n>
};
<recordDefinition( dotPath(defPath),
                   underscorePath(defPath),
                   (variables of VARIABLE : '"<cref(name)>"' ",") )>
>> 
  case RECORD_DECL_DEF then 
    recordDefinition( dotPath(path),
                      underscorePath(path),
                      (fieldNames : '"<it>"' ",") )


recordDefinition(String origName, String encName, String fieldNames) ::=
<<
const char* <encName>__desc__fields[] = {<fieldNames>};
struct record_description <encName>__desc = {
  "<encName>", /* package_record__X */
  "<origName>", /* package.record_X */
  <encName>__desc__fields
};
>>


//!! assumes the type is T_ARRAY when array, so no branching by isArray here ... see Codegen.generateReturnDecl,
// ?? initopt dump ? see Codegen.tmpPrintInit usage in generateReturnDecl
functionHeader(String fname, Variables fargs, Variables outVars) ::=
<<
<outVars of VARIABLE : 
'#define <fname>_rettype_<i1> targ<i1>' 
\n>
typedef struct <fname>_rettype_s 
{
  <outVars of VARIABLE :
  '<varType(it)> targ<i1>; /* <cref(name)><if ty is ET_ARRAY then '[<arrayDimensions : if it is SOME(d) then d else ":" ", ">]'> */'
  \n>
} <fname>_rettype;

DLLExport 
<fname>_rettype _<fname>(<fargs of VARIABLE : '<varType(it)> <cref(name)>' ", ">);

DLLExport 
int in_<fname>(type_description * inArgs, type_description * outVar);
>>


functionsCpp(list<Function> functions) ::=
<<
#ifdef __cplusplus
extern "C" {
#endif
/* header part */
<functions of FUNCTION : 
  <<
  /*recordDecls : recordDeclaration() \n*/
  <functionHeader(underscorePath(name), functionArguments, outVars)>
  >> 
\n> 
/* End of header part */

/* Body */
<functions : functionDef() \n>
/* End Body */

#ifdef __cplusplus
}
#endif

>>

varDeclaration(Variable) ::=
case VARIABLE then '<varType(it)> <cref(name)>;<\n>'

varType(Variable) ::=
case var as VARIABLE then
  if instDims then
    match var.ty
    case ET_INT    then "integer_array"
    case ET_REAL   then "real_array"
    case ET_STRING then "string_array"
    case ET_BOOL   then "boolean_array"
    case _         then "unknown array"
  else
    match var.ty
    case ET_INT    then "modelica_integer"
    case ET_REAL   then "modelica_real"
    case ET_BOOL   then "modelica_boolean"
    case ET_STRING then "modelica_string"
    case ET_COMPLEX(complexClassType = EXTERNAL_OBJ)  then "void *" 
    case ET_OTHER  then "modelica_complex"
    case ET_LIST
    case ET_METATUPLE
    case ET_METAOPTION
    case ET_UNIONTYPE
    case ET_POLYMORPHIC then "metamodelica_type"
    case ET_ARRAY then 
      match ty
      case ET_INT    then "integer_array"
      case ET_REAL   then "real_array"
      case ET_STRING then "string_array"
      case ET_BOOL   then "boolean_array"

varInit(Variable, Text varDecls, Text varInits) ::=
case var as VARIABLE then
  # varDecls += varDeclaration(var)
  # instDimsInit = (instDims of exp: daeExp(exp, createOtherContext(), varInits, varDecls) ", ")
  if instDims then
    # varInits += 'alloc_<expShortType(var.ty)>_array(&<cref(var.name)>, <listLengthExp(instDims)>, <instDimsInit>);<\n>'
    ()
  else
    ()

varOutput(Variable source, String dest, Integer i, Text varDecls, Text varInits) ::=
case var as VARIABLE then
  # instDimsInit = (instDims of exp: daeExp(exp, createOtherContext(), varInits, varDecls) ", ")
  if instDims then
    # varInits += 'alloc_<expShortType(var.ty)>_array(&<dest>.targ<i>, <listLengthExp(instDims)>, <instDimsInit>);<\n>'
    <<
    copy_<expShortType(var.ty)>_array_data(&<cref(var.name)>, &<dest>.targ<i>);
    >>
  else
    <<
    <dest>.targ<i> = <cref(var.name)>;
    >>

functionDef(Function) ::=
  case FUNCTION then
    # System.tmpTickReset(1)
    # fname = underscorePath(name)
    # retType = '<fname>_rettype'
    # varDecls = ""
    # varInits = ""
    # retVar   = tempDecl(retType, varDecls)
    # stateVar = tempDecl("state", varDecls)
    # foo = (variableDeclarations: varInit(it, varDecls, varInits))
    # bodyPart = (body of stmt : funStatement(stmt, varDecls) \n)
    # outVarsStr = (outVars: varOutput(it, retVar, i1, varDecls, varInits))
    <<
    <retType> _<fname>(<functionArguments of VARIABLE: '<expType(ty)> <cref(name)>' ", ">)
    {
      <varDecls>
      <stateVar> = get_memory_state();

      <varInits>

      <bodyPart>
      
      _return:
      <outVarsStr>
      restore_memory_state(<stateVar>);
      return <retVar>;
    }
    >>
    

funBody(list<Statement> body) ::=
  # varDecls = ""
  # bodyPart = (body of stmt : funStatement(stmt, varDecls) \n)
<<
<varDecls>
<bodyPart>
>>


funStatement(Statement, Text varDecls) ::=
  case ALGORITHM then (statementLst : algStatement(it, createOtherContext(), varDecls) \n) 
  case BLOCK then "/* not implemented fun statement */"

// Codegen.generateAlgorithmStatement
algStatement(DAE.Statement, Context context, Text varDecls) ::=
  case STMT_ASSIGN(exp1 = CREF(componentRef = WILD), exp = e) then
    # preExp = "" 
    # expPart = daeExp(e, context, preExp, varDecls)
    <<
    <preExp>
    <expPart>
    >>
  case STMT_ASSIGN(exp1 = CREF) then
    # preExp = ""
    # expPart = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    <scalarLhsCref(exp1.componentRef)> = <expPart>;
    >>
  case STMT_ASSIGN then
    # preExp = ""
    # expPart1 = daeExp(exp1, context, preExp, varDecls)
    # expPart2 = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    <expPart1> = <expPart2>;
    >>
  case STMT_ASSIGN_ARR then // TODO: this is different depending on context
    # preExp = ""
    # expPart = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    copy_<expShortType(type_)>_array_data(&<expPart>, &<cref(componentRef)>);
    >>
  case STMT_IF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    if (<condExp>) {
      <statementLst : algStatement(it, context, varDecls) \n>
    }
    <elseExpr(else_, context, varDecls)>
    >>
  case STMT_FOR(exp = rng as RANGE) then
    # stateVar = tempDecl("state", varDecls)
    # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
    # identType = expTypeA(type_, boolean)
    # r1 = tempDecl(identType, varDecls)
    # r2 = tempDecl(identType, varDecls)
    # r3 = tempDecl(identType, varDecls)
    # preExp = ""
    # er1 = daeExp(rng.exp, context, preExp, varDecls)
    # er2 = if rng.expOption is SOME(eo) 
            then daeExp(eo, context, preExp, varDecls)
            else "(1)"
    # er3 = daeExp(rng.range, context, preExp, varDecls) 
    <<
    <preExp>
    <r1> = <er1>; <r2> = <er2>; <r3> = <er3>;
    {
    <identType> <ident>;

      for (<ident> = <r1>; in_range_<expShortType(type_)>(<ident>, <r1>, <r3>); <ident> += <r2>) {
        <stateVar> = get_memory_state();
        <statementLst : algStatement(it, context, varDecls) \n /* ??CONTEXT(codeContext,expContext,IN_FOR_LOOP(loopContext)*/ >
        restore_memory_state(<stateVar>);
      }
    } /*end for*/
    >>
  case STMT_FOR then
    # stateVar = tempDecl("state", varDecls)
    # arrayType = expTypeArray(type_)
    # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
    # tvar = tempDecl("int", varDecls)
    # ivar = tempDecl(expType(type_), varDecls)
    # preExp = ""
    # evar = daeExp(exp, context, preExp, varDecls)
    # statements = (statementLst: algStatement(it, context, varDecls) \n)
    # identType = expType(type_)
    # id = '<ident>'
    # stmtStuff = if boolean
                  then 'simple_index_alloc_<identType>1(&<evar>, <tvar>, &<ivar>);'
                  else '<id> = *(<arrayType>_element_addr1(&<evar>, 1, <tvar>));'
    <<
    <preExp>
    {
    <identType> <ident>;

      for (<tvar> = 1; <tvar> \<= size_of_dimension_<arrayType>(<evar>, 1); ++<tvar>) {
        <stateVar> = get_memory_state();
        <stmtStuff>
        <statements>
        restore_memory_state(<stateVar>);
      }
    } /* end for*/
    >>
  case STMT_WHILE then
    # preExp = ""
    # var = daeExp(exp, context, preExp, varDecls)
    <<
    while (1) {
      <preExp>
      if (!<var>) break;
      <statementLst: algStatement(it, context, varDecls) \n>
    }
    >>
  case STMT_ASSERT then
    # preExp = ""
    # condVar = daeExp(cond, context, preExp, varDecls)
    # msgVar = daeExp(msg, context, preExp, varDecls)
    <<
    <preExp>
    MODELICA_ASSERT(<condVar>, <msgVar>);
    >>
  case when as STMT_WHEN then if context is SIMULATION
                         then algStatementWhen(when, context, varDecls)
                         else ""
  case _ then "/* not implemented alg statement*/"

// TODO: This and all help templates it calls is really ugly. It is largely due
// to the STMT_WHEN structure. It is not really suited for susan.
algStatementWhen(DAE.Statement, Context context, Text varDecls) ::=
case STMT_WHEN then
  # preIf = algStatementWhenPre(it, varDecls)
  # statements = (statementLst: '<algStatement(it, createSimulationContext(), varDecls)>' "\n")
  # else = algStatementWhenElse(elseWhen, varDecls)
  <<
  <preIf>
  if (<helpVarIndices: 'edge(localData-\>helpVars[<it>])' " || ">) {
    <statements>
  }
  <else>
  >>

algStatementWhenPre(DAE.Statement, Text varDecls) ::=
case STMT_WHEN(exp=ARRAY(array=el)) then
  # restPre = if elseWhen is SOME(ew)
              then algStatementWhenPre(ew, varDecls) else ""
  # preExp = ""
  # fooRes = foo(el, helpVarIndices, preExp, varDecls)
  <<
  <preExp>
  <fooRes>
  <restPre>
  >>
case when as STMT_WHEN then
  match helpVarIndices
  case {i} then
    # restPre = if when.elseWhen is SOME(ew)
                then algStatementWhenPre(ew, varDecls) else ""
    # preExp = ""
    # res = daeExp(when.exp, createSimulationContext(), preExp, varDecls)
    <<
    <preExp>
    localData-\>helpVars[<i>] = <res>;
    <restPre>
    >>

algStatementWhenElse(Option<DAE.Statement>, Text varDecls) ::=
case SOME(when as STMT_WHEN) then
  # statements = (when.statementLst: '<algStatement(it, createSimulationContext(), varDecls)>' "\n")
  # else = algStatementWhenElse(when.elseWhen, varDecls)
  <<
  else if (<when.helpVarIndices: 'edge(localData-\>helpVars[<it>])' " || ">) {
    <statements>
  }
  <else>
  >>

foo(list<Exp> exps, list<Integer> ints, Text preExp, Text varDecls) ::=
case {} then ""
case (firstExp :: restExps) then
  match ints
  case (firstInt :: restInts) then
    # rest = foo(restExps, restInts, preExp, varDecls)
    <<
    localData-\>helpVars[<firstInt>] = <daeExp(firstExp, createSimulationContext(), preExp, varDecls)>;
    <rest>
    >>

elseExpr(DAE.Else, Context context, Text varDecls) ::= 
  case NOELSE then ()
  case ELSEIF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp, varDecls)
    <<
    else {
    <preExp>
    if (<condExp>)) {
      <statementLst : algStatement(it, context, varDecls) \n>
    }
    <elseExpr(else_, context, varDecls)>
    }
    >>
  case ELSE then
    <<
    else {
      <statementLst : algStatement(it, context, varDecls) \n>
    }
    >>

scalarLhsCref(ComponentRef) ::=
  case CREF_IDENT then ident
  case CREF_QUAL  then '<ident>.<scalarLhsCref(componentRef)>'

//TODO: this wrong for qualified integers !
rhsCref(ComponentRef, ExpType ty) ::=
  case CREF_IDENT then '<rhsCrefType(ty)><ident>'
  case CREF_QUAL  then '<rhsCrefType(ty)><ident>.<rhsCref(componentRef,ty)>'
  case _          then "rhsCref:ERROR"

rhsCrefType(ExpType) ::=
  case ET_INT then "(modelica_integer)"
  case _      then ""
  
daeExp(Exp exp, Context context, Text preExp, Text varDecls) ::=
  case ICONST     then integer
  case RCONST     then real
  case SCONST     then daeExpSconst(string, preExp, varDecls)
  case BCONST     then if bool then "(1)" else "(0)"
  case CREF       then rhsCref(componentRef, ty)
  case BINARY     then daeExpBinary(it, context, preExp, varDecls)
  case UNARY      then daeExpUnary(it, context, preExp, varDecls)
  case LBINARY    then daeExpLbinary(it, context, preExp, varDecls)
  case LUNARY     then daeExpLunary(it, context, preExp, varDecls)
  case RELATION   then daeExpRelation(it, context, preExp, varDecls)
  case IFEXP      then daeExpIf(it, context, preExp, varDecls)
  case CALL       then daeExpCall(it, context, preExp, varDecls)
  // PARTEVALFUNCTION
  case ARRAY      then daeExpArray(it, context, preExp, varDecls)
  case MATRIX     then daeExpMatrix(it, context, preExp, varDecls)
  case RANGE      then "RANGE_NOT_IMPLEMENTED"
  case TUPLE      then "TUPLE_NOT_IMPLEMENTED"
  case CAST       then '((<expType(ty)>)<daeExp(exp, context, preExp, varDecls)>)'
  case ASUB       then daeExpAsub(it, context, preExp, varDecls)
  case SIZE       then daeExpSize(it, context, preExp, varDecls)
  case CODE       then "CODE_NOT_IMPLEMENTED"
  case REDUCTION  then "REDUCTION_NOT_IMPLEMENTED"
  case END        then "END_NOT_IMPLEMENTED"
  case VALUEBLOCK then "VALUEBLOCK_NOT_IMPLEMENTED"
  case LIST       then "LIST_NOT_IMPLEMENTED"
  case CONS       then "CONS_NOT_IMPLEMENTED"
  // META_TUPLE
  // META_OPTION
  // METARECORDCALL
  case _          then "UNKNOWN_EXP"

daeExpSconst(String string, Text preExp, Text varDecls) ::=
  # strVar = tempDecl("modelica_string", varDecls)
  # preExp += 'init_modelica_string(&<strVar>,"<Util.escapeModelicaStringToCString(string)>");<\n>'
  strVar  

daeExpBinary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case BINARY then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match operator
  case ADD(ty = ET_STRING) then
    # tmpStr = tempDecl("modelica_string", varDecls)
    # preExp += 'cat_modelica_string(&<tmpStr>,&<e1>,&<e2>);<\n>'
    tmpStr
  case ADD then '(<e1> + <e2>)'
  case SUB then '(<e1> - <e2>)'
  case MUL then '(<e1> * <e2>)'
  case DIV then '(<e1> / <e2>)'
  case POW then 'pow((modelica_real)<e1>, (modelica_real)<e2>)'
  case MUL_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'mul_alloc_<type>_scalar(&<e1>, <e2>, &<var>);'
    '<var>'
  case _   then "daeExpBinary:ERR"

daeExpLbinary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case LBINARY then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match operator
  case AND then '(<e1> && <e2>)'
  case OR  then '(<e1> || <e2>)'
  case _   then "daeExpLbinary:ERR"

daeExpLunary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case LUNARY then
  # e = daeExp(exp, context, preExp, varDecls)
  match operator
  case NOT then '(!<e>)'

daeExpUnary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case UNARY then
  # e = daeExp(exp, context, preExp, varDecls)
  match operator
  case UMINUS     then '(-<e>)'
  case UPLUS      then '(<e>)'
  case UMINUS_ARR then "UMINUS_ARR_NOT_IMPLEMENTED"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"

daeExpRelation(Exp exp, Context context, Text preExp, Text varDecls) ::=
case rel as RELATION then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match context
  case SIMULATION then (
    # res = tempDecl("modelica_boolean", varDecls)
    match rel.operator
    case LESS      then # preExp += 'RELATIONLESS(<res>, <e1>, <e2>);<\n>' res
    case LESSEQ    then # preExp += 'RELATIONLESSEQ(<res>, <e1>, <e2>);<\n>' res
    case GREATER   then # preExp += 'RELATIONGREATER(<res>, <e1>, <e2>);<\n>' res
    case GREATEREQ then # preExp += 'RELATIONGREATEREQ(<res>, <e1>, <e2>);<\n>' res
    case _         then "daeExpRelation:SIMULATION:ERR"
  )
  case OTHER then (
    match rel.operator
    case LESS(ty = ET_BOOL)        then '(!<e1> && <e2>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)         then '(<e1> \< <e2>)'
    case LESS(ty = ET_REAL)        then '(<e1> \< <e2>)'
    case GREATER(ty = ET_BOOL)     then '(<e1> && !<e2>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)      then '(<e1> > <e2>)'
    case GREATER(ty = ET_REAL)     then '(<e1> > <e2>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<e1> || <e2>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)       then '(<e1> \<= <e2>)'
    case LESSEQ(ty = ET_REAL)      then '(<e1> \<= <e2>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<e1> || !<e2>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)    then '(<e1> >= <e2>)'
    case GREATEREQ(ty = ET_REAL)   then '(<e1> >= <e2>)'
    case EQUAL(ty = ET_BOOL)       then '((!<e1> && !<e2>) || (<e1> && <e2>))'
    case EQUAL(ty = ET_STRING)     then '(!strcmp(<e1>, <e2>))'
    case EQUAL(ty = ET_INT)        then '(<e1> == <e2>)'
    case EQUAL(ty = ET_REAL)       then '(<e1> == <e2>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<e1> && <e2>) || (<e1> && !<e2>))'
    case NEQUAL(ty = ET_STRING)    then '(strcmp(<e1>, <e2>))'
    case NEQUAL(ty = ET_INT)       then '(<e1> != <e2>)'
    case NEQUAL(ty = ET_REAL)      then '(<e1> != <e2>)'
    case _                         then "daeExpRelation:OTHER:ERR"
  )
  case _ then "daeExpRelation:ERR"

daeExpIf(Exp exp, Context context, Text preExp, Text varDecls) ::=
case IFEXP then
  # condExp = daeExp(expCond, context, preExp, varDecls)
  # condVar = tempDecl("modelica_boolean", varDecls)
  # resVar = tempDecl(typeStrFromExp(expThen), varDecls)
  # preExpThen = ""
  # eThen = daeExp(expThen, context, preExpThen, varDecls)
  # preExpElse = ""
  # eElse = daeExp(expElse, context, preExpElse, varDecls)
  # preExp +=  
  <<
  <condVar> = <condExp>;
  if (<condVar>) {
    <preExpThen>
    <resVar> = <eThen>;
  } else {
    <preExpElse>
    <resVar> = <eElse>;
  }<\n>
  >>
  resVar
//  <<
//  ((<condVar>)?<eThen>:<eElse>)
//  >>

typeStrFromExp(Exp) ::=
  case ICONST    then "modelica_integer"
  case RCONST    then "modelica_real"
  case SCONST    then "modelica_string"
  case BCONST    then "modelica_bool"
  case CREF      then expType(ty)
  case BINARY    then typeStrFromOp(operator)
  case UNARY     then typeStrFromOp(operator)
  case LBINARY   then typeStrFromOp(operator)
  case LUNARY    then typeStrFromOp(operator)
  case RELATION  then typeStrFromOp(operator)
  case IFEXP     then typeStrFromExp(expThen)
  case CALL      then expType(ty)
  //PARTEVALFUNCTION
  case ARRAY     then expType(ty)
  case MATRIX    then expType(ty)
  case RANGE     then expType(ty)
  //TUPLE
  case CAST      then expType(ty)
  case ASUB      then typeStrFromExp(exp)
  case CODE      then expType(ty)
  case REDUCTION then typeStrFromExp(expr)

typeStrFromOp(Operator) ::=
  case ADD then expType(ty) 
  case SUB then expType(ty) 
  case MUL then expType(ty) 
  case DIV then expType(ty) 
  case POW then expType(ty) 
  case UMINUS then expType(ty) 
  case UPLUS then expType(ty) 
  case UMINUS_ARR then expType(ty) 
  case UPLUS_ARR then expType(ty) 
  case ADD_ARR then expType(ty) 
  case SUB_ARR then expType(ty) 
  case MUL_ARR then expType(ty) 
  case DIV_ARR then expType(ty) 
  case MUL_SCALAR_ARRAY then expType(ty)
  case MUL_ARRAY_SCALAR then expType(ty)
  case ADD_SCALAR_ARRAY then expType(ty)
  case ADD_ARRAY_SCALAR then expType(ty)
  case SUB_SCALAR_ARRAY then expType(ty)  
  case SUB_ARRAY_SCALAR then expType(ty)
  case MUL_SCALAR_PRODUCT then expType(ty) 
  case MUL_MATRIX_PRODUCT then expType(ty) 
  case DIV_ARRAY_SCALAR then expType(ty)
  case DIV_SCALAR_ARRAY then expType(ty)
  case POW_ARRAY_SCALAR then expType(ty)
  case POW_SCALAR_ARRAY then expType(ty)  
  case POW_ARR then expType(ty) 
  case POW_ARR2 then expType(ty) 
  case AND then "modelica_boolean" 
  case OR then "modelica_boolean" 
  case NOT then "modelica_boolean" 
  case LESS then expType(ty) 
  case LESSEQ then expType(ty) 
  case GREATER then expType(ty) 
  case GREATEREQ then expType(ty) 
  case EQUAL then expType(ty) 
  case NEQUAL then expType(ty) 

daeExpCall(Exp call, Context context, Text preExp, Text varDecls) ::=
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    # retType = '<expType(arg.ty)>'
    # retVar = tempDecl(retType, varDecls)
    # cast = if arg.ty is ET_INT then "(modelica_integer)" else ""
    # preExp += '<retVar> = <cast>pre(<cref(arg.componentRef)>);<\n>'
    '<retVar>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="promote"), expLst={A, n}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # var2 = daeExp(n, context, preExp, varDecls)
    # retType = '<typeStrFromExp(A)>'
    # tvar = tempDecl(retType, varDecls)
    # preExp += 'promote_alloc_<retType>(&<var1>, &<var2>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="transpose"), expLst={A}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # retType = '<typeStrFromExp(A)>'
    # tvar = tempDecl(retType, varDecls)
    # preExp += 'transpose_alloc_<retType>(&<var1>, &<tvar>);<\n>'
    tvar
  // TODO: add more special builtins (Codegen.generateBuiltinFunction)
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # preExp += '<underscorePrefix(builtin)><funName>(<argStr>);<\n>'
    '/* NORETCALL */'
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls)
    # preExp += '<retVar> = <underscorePrefix(builtin)><funName>(<argStr>);<\n>'
    if builtin then '<retVar>' else '<retVar>.<retType>_1'
  // tuple calls (multiple return values)
  case CALL(tuple_=true) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls)
    # preExp += '<retVar> = <underscorePrefix(builtin)><funName>(<argStr>);<\n>'
    '<retVar>'

daeExpArray(Exp exp, Context context, Text preExp, Text varDecls) ::=
case ARRAY then
# arrayTypeStr = '<expShortType(ty)>_array'
# arrayVar = tempDecl(arrayTypeStr, varDecls)
# scalarPrefix = if scalar then "scalar_" else ""
# scalarRef = if scalar then "&" else ""
# params = '<array of e: daeExp(e, context, preExp, varDecls) ", ">'
# preExp += 'array_alloc_<scalarPrefix><arrayTypeStr>(&<arrayVar>, <listLengthExp(array)>, <params>);<\n>'
'<arrayVar>'

daeExpMatrix(Exp exp, Context context, Text preExp, Text varDecls) ::=
case MATRIX(scalar={{}}) then
  // special case for empty matrix: create dimensional array Real[0,1]
  # arrayTypeStr = expTypeArray(ty)
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
  tmp
case MATRIX(scalar={}) then
  // special case for empty array: create dimensional array Real[0,1]
  # arrayTypeStr = expTypeArray(ty)
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
  tmp
case m as MATRIX then
  # arrayTypeStr = expType(m.ty)
  # vars2 = ""
  # promote = ""
  # catAlloc = (m.scalar of row:
                 # tmp = tempDecl(arrayTypeStr, varDecls)
                 # vars = daeExpMatrixRow(row, arrayTypeStr, context, promote, varDecls)
                 # vars2 += ', <tmp>'
                 'cat_alloc_<arrayTypeStr>(2, &<tmp>, <listLengthMatrix2(row)><vars>);'
               "\n")
  # preExp += promote
  # preExp += catAlloc
  # preExp += "\n"
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'cat_alloc_<arrayTypeStr>(2, &<tmp>, <listLengthMatrix1(m.scalar)><vars2>);<\n>'
  tmp

daeExpMatrixRow(list<tuple<Exp,Boolean>> row, String arrayTypeStr,
                Context context, Text preExp, Text varDecls) ::=
# varLstStr = ""
# preExp2 = (row of col as (e, b):
               # scalarStr = if b then "scalar_" else ""
               # scalarRefStr = if b then "" else "&"
               # expVar = daeExp(e, context, preExp, varDecls)
               # tmp = tempDecl(arrayTypeStr, varDecls)
               # varLstStr += ', &<tmp>'
               'promote_<scalarStr><arrayTypeStr>(<scalarRefStr><expVar>, 2, &<tmp>);'
             "\n")
# preExp2 += "\n"
# preExp += preExp2
varLstStr

daeExpAsub(Exp exp, Context context, Text preExp, Text varDecls) ::=
case ASUB(exp=RANGE(ty=t), sub={idx}) then
  'ASUB_EASY_CASE'
case ASUB(exp=ASUB(
            exp=ASUB(
              exp=ASUB(exp=e, sub={ICONST(integer=i)}),
              sub={ICONST(integer=j)}),
            sub={ICONST(integer=k)}),
          sub={ICONST(integer=l)}) then
  'ASUB_4D'
case ASUB(exp=ASUB(
            exp=ASUB(exp=e, sub={ICONST(integer=i)}),
            sub={ICONST(integer=j)}),
          sub={ICONST(integer=k)}) then
  'ASUB_3D'
case ASUB(exp=ASUB(exp=e, sub={ICONST(integer=i)}),
          sub={ICONST(integer=j)}) then
  'ASUB_2D'
case ASUB(exp=e, sub={ICONST(integer=i)}) then
  'ASUB_ARRAY'
case ASUB(exp=cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)), sub=subs) then // TODO: Optimize as in Codegen
  # arrName = arrayRhs(cref, context, preExp, varDecls)
  # arrayType = expTypeArray(aty)
  # dimsLenStr = listLengthOptionInt(dims)
  # dimsValuesStr = (subs of exp: daeExp(exp, context, preExp, varDecls) ", ")
  <<
  (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
  >>
case _ then
  'OTHER_ASUB'

arrayRhs(Exp cref, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  match context
  case SIMULATION then
    # tmpArr = tempDecl(expTypeArray(aty), varDecls)
    # dimsLenStr = listLengthOptionInt(dims)
    # dimsValuesStr = (dims of dim as SOME(i): i ", ")
    # preExp += '<expShortType(cref.ty)>_array_create(&<tmpArr>, &<cref(cref.componentRef)>, <dimsLenStr>, <dimsValuesStr>);<\n>'
    tmpArr
  case _ then
    cref(cref.componentRef)

daeExpSize(Exp exp, Context context, Text preExp, Text varDecls) ::=
case SIZE(exp=CREF, sz=SOME(dim)) then
  # expPart = daeExp(exp, context, preExp, varDecls)
  # dimPart = daeExp(dim, context, preExp, varDecls)
  # resVar = tempDecl("size_t", varDecls)
  # typeStr = '<expShortType(exp.ty)>_array'
  # preExp += '<resVar> = size_of_dimension_<typeStr>(<expPart>, <dimPart>);<\n>'
  resVar
case _ then "size(X) not implemented"

underscorePrefix(Boolean builtin) ::=
  case true then ""
  case false then "_"

tempDecl(String ty, Text varDecls) ::=
  # newVar = 'tmp<System.tmpTick()>'
  # varDecls += '<ty> <newVar>;<\n>'
  newVar

end SimCodeC;
// vim: filetype=susan sw=2 sts=2
