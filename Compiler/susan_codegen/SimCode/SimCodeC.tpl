// This file defines templates for transforming Modelica code to C code.
//
// Currently there is only one root template intended to be called from
// Modelica code and that is translateModel.

spackage SimCodeC

typeview "SimCodeTV.mo"

// SECTION: SIMULATION TARGET, ROOT TEMPLATE

translateModel(SimCode simCode) ::=
case SIMCODE(modelInfo=MODELINFO) then
  # simulationFileContent = simulationFile(simCode)
  # textFile(simulationFileContent, '<modelInfo.name>.cpp')
  # functionsFileContent = functionsFile(functions)
  # textFile(functionsFileContent, '<modelInfo.name>_functions.cpp')
  # makefileContent = makefile(simCode)
  # textFile(makefileContent, '<modelInfo.name>.makefile')
  () // empty result

// SECTION: FUNCTION TARGET, ROOT TEMPLATE

translateFunctions(FunctionCode functionCode) ::=
case FUNCTIONCODE then
  # functionsFileContent = functionsFile2(functions)
  # textFile(functionsFileContent, '<name>.c')
  # makefileContent = makefileFunction(functionCode)
  # textFile(makefileContent, '<name>.makefile')
  () // empty result

// SECTION: SIMULATION TARGET, SIMULATION FILE SPECIFIC TEMPLATES

simulationFile(SimCode simCode) ::=
case SIMCODE(modelInfo=MODELINFO, extObjInfo=EXTOBJINFO) then
<<
// Simulation code for <modelInfo.name> generated by the OpenModelica Compiler.

#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
  #define DLLExport   __declspec( dllexport )
#else 
  #define DLLExport /* nothing */
#endif 

#include "<modelInfo.name>_functions.cpp"

extern "C" {
<extObjInfo.includes: it "\n">
}

<globalData(modelInfo)>

<functionGetName(modelInfo)>

<functionDivisionError()>

<functionSetLocalData()>

<functionInitializeDataStruc(extObjInfo)>

<functionDeInitializeDataStruc(extObjInfo)>

<functionExtraResudials(allEquations)>

<functionDaeOutput(nonStateContEquations, removedEquations,
                   algorithmAndEquationAsserts)>

<functionDaeOutput2(nonStateDiscEquations, removedEquations)>

<functionInput(modelInfo)>

<functionOutput(modelInfo)>

<functionDaeRes()>

<functionZeroCrossing(zeroCrossings)>

<functionHandleZeroCrossing(zeroCrossingsNeedSave)>

<functionUpdateDependents(allEquations, helpVarInfo)>

<functionUpdateDepend(allEquationsPlusWhen)>

<functionOnlyZeroCrossing(zeroCrossings)>

<functionCheckForDiscreteChanges(discreteModelVars)>

<functionStoreDelayed(delayedExps)>

<functionWhen(whenClauses)>

<functionOde(stateContEquations)>

<functionInitial(initialEquations)>

<functionInitialResidual(residualEquations)>

<functionBoundParameters(parameterEquations)>

<functionCheckForDiscreteVarChanges(helpVarInfo, discreteModelVars)>
>>

globalData(ModelInfo modelInfo) ::=
case MODELINFO(varInfo=VARINFO, vars=SIMVARS) then
<<
#define NHELP <varInfo.numHelpVars>
#define NG <varInfo.numZeroCrossings>
#define NX <varInfo.numStateVars>
#define NY <varInfo.numAlgVars>
#define NP <varInfo.numParams>
#define NO <varInfo.numOutVars>
#define NI <varInfo.numInVars>
#define NR <varInfo.numResiduals>
#define NEXT <varInfo.numExternalObjects>
#define MAXORD 5
#define NYSTR <varInfo.numStringAlgVars>
#define NPSTR <varInfo.numStringParamVars>

static DATA* localData = 0;
#define time localData-\>timeValue
extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
  char *model_name="<name>";
  char *model_dir="<directory>";
}

<globalDataVarNamesArray("state_names", vars.stateVars)>
<globalDataVarNamesArray("derivative_names", vars.derivativeVars)>
<globalDataVarNamesArray("algvars_names", vars.algVars)>
<globalDataVarNamesArray("input_names", vars.inputVars)>
<globalDataVarNamesArray("output_names", vars.outputVars)>
<globalDataVarNamesArray("param_names", vars.paramVars)>
<globalDataVarNamesArray("string_alg_names", vars.stringAlgVars)>
<globalDataVarNamesArray("string_param_names", vars.stringParamVars)>

<globalDataVarCommentsArray("state_comments", vars.stateVars)>
<globalDataVarCommentsArray("derivative_comments", vars.derivativeVars)>
<globalDataVarCommentsArray("algvars_comments", vars.algVars)>
<globalDataVarCommentsArray("input_comments", vars.inputVars)>
<globalDataVarCommentsArray("output_comments", vars.outputVars)>
<globalDataVarCommentsArray("param_comments", vars.paramVars)>
<globalDataVarCommentsArray("string_alg_comments", vars.stringAlgVars)>
<globalDataVarCommentsArray("string_param_comments", vars.stringParamVars)>

<vars.stateVars: globalDataVarDefine(it, "states") "\n">
<vars.derivativeVars: globalDataVarDefine(it, "statesDerivatives") "\n">
<vars.algVars: globalDataVarDefine(it, "algebraics") "\n">
<vars.paramVars: globalDataVarDefine(it, "parameters") "\n">
<vars.extObjVars: globalDataVarDefine(it, "extObjs") "\n">
<vars.stringAlgVars: globalDataVarDefine(it, "stringVariables.algebraics") "\n">

static char init_fixed[NX+NX+NY+NP] = {
  <[(vars.stateVars of SIMVAR:
      '<globalDataBoolInt(isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.derivativeVars of SIMVAR:
      '<globalDataBoolInt(isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.algVars of SIMVAR:
      '<globalDataBoolInt(isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.paramVars of SIMVAR:
      '<globalDataBoolInt(isFixed)> /* <cref(origName)> */' ",\n")] ",\n">
};

char var_attr[NX+NY+NP] = {
  <[(vars.stateVars of SIMVAR:
      '<globalDataAttrInt(type_)>+<globalDataDiscAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n"),
    (vars.algVars of SIMVAR:
      '<globalDataAttrInt(type_)>+<globalDataDiscAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n"),
    (vars.paramVars of SIMVAR:
      '<globalDataAttrInt(type_)>+<globalDataDiscAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n")] ",\n">
};
>>

globalDataVarNamesArray(String name, list<SimVar> items) ::=
if items then
<<
char* <name>[<listLength(items)>] = {<items of SIMVAR:
  '"<crefSubscript(origName)>"' ", ">};
>>
else
<<
char* <name>[1] = {""};
>>

globalDataVarCommentsArray(String name, list<SimVar> items) ::=
if items then
<<
char* <name>[<listLength(items)>] = {<items of SIMVAR:
  '"<comment>"' ", ">};
>>
else
<<
char* <name>[1] = {""};
>>

globalDataVarDefine(SimVar, String arrayName) ::=
case SIMVAR(arrayCref=SOME(c)) then
<<
#define <cref(c)> localData-\><arrayName>[<index>]
#define <cref(name)> localData-\><arrayName>[<index>]
>>
case SIMVAR then
<<
#define <cref(name)> localData-\><arrayName>[<index>]
>>

globalDataBoolInt(Boolean) ::=
  case true  then "1"
  case false then "0"

globalDataAttrInt(DAE.ExpType) ::=
  case ET_REAL   then "1"
  case ET_STRING then "2"
  case ET_INT    then "4"
  case ET_BOOL   then "8"

globalDataDiscAttrInt(Boolean isDiscrete) ::=
  case true  then "16"
  case false then "0"

functionGetName(ModelInfo modelInfo) ::=
case MODELINFO(vars=SIMVARS) then
<<
char* getName(double* ptr)
{
  <vars.stateVars of SIMVAR:
    'if (&<cref(name)> == ptr) return state_names[<index>];' "\n">
  <vars.derivativeVars of SIMVAR:
    'if (&<cref(name)> == ptr) return derivative_names[<index>];' "\n">
  <vars.algVars of SIMVAR:
    'if (&<cref(name)> == ptr) return algvars_names[<index>];' "\n">
  <vars.paramVars of SIMVAR:
    'if (&<cref(name)> == ptr) return param_names[<index>];' "\n">
  return "";
}
>>

functionDivisionError() ::=
<<
#define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))

int encounteredDivisionByZero = 0;

double division_error(double b, const char* division_str)
{
  if(!encounteredDivisionByZero) {
    fprintf(stderr, "ERROR: Division by zero in partial equation: %s.\n",division_str);
    encounteredDivisionByZero = 1;
  }
  return b;
}
>>

functionSetLocalData() ::=
<<
void setLocalData(DATA* data)
{
  localData = data;
}
>>

functionInitializeDataStruc(ExtObjInfo extObjInfo) ::=
case EXTOBJINFO then
# varDecls = ""
# preExp = ""
# ctorCalls = (
    constructors of (var, fn, exps):
      # expsStr = (exps: daeExp(it, contextOther, preExp, varDecls) ", ")
      '<cref(var)> = <fn>(<expsStr>);'
    "\n")
<<
DATA* initializeDataStruc(DATA_FLAGS flags)
{
  <varDecls>

  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData-\>nStates = NX;
  returnData-\>nAlgebraic = NY;
  returnData-\>nParameters = NP;
  returnData-\>nInputVars = NI;
  returnData-\>nOutputVars = NO;
  returnData-\>nZeroCrossing = NG;
  returnData-\>nInitialResiduals = NR;
  returnData-\>nHelpVars = NHELP;
  returnData-\>stringVariables.nParameters = NPSTR;
  returnData-\>stringVariables.nAlgebraic = NYSTR;

  if(flags & STATES && returnData-\>nStates) {
    returnData-\>states = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStates = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStates2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
    assert(returnData-\>states&&returnData-\>oldStates&&returnData-\>oldStates2);
    memset(returnData-\>states,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStates,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStates2,0,sizeof(double)*returnData-\>nStates);
  } else {
    returnData-\>states = 0;
    returnData-\>oldStates = 0;
    returnData-\>oldStates2 = 0;
  }

  if(flags & STATESDERIVATIVES && returnData-\>nStates) {
    returnData-\>statesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
    assert(returnData-\>statesDerivatives&&returnData-\>oldStatesDerivatives&&returnData-\>oldStatesDerivatives2);
    memset(returnData-\>statesDerivatives,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStatesDerivatives,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStatesDerivatives2,0,sizeof(double)*returnData-\>nStates);
  } else {
    returnData-\>statesDerivatives = 0;
    returnData-\>oldStatesDerivatives = 0;
    returnData-\>oldStatesDerivatives2 = 0;
  }

  if(flags & HELPVARS && returnData-\>nHelpVars) {
    returnData-\>helpVars = (double*) malloc(sizeof(double)*returnData-\>nHelpVars);
    assert(returnData-\>helpVars);
    memset(returnData-\>helpVars,0,sizeof(double)*returnData-\>nHelpVars);
  } else {
    returnData-\>helpVars = 0;
  }

  if(flags & ALGEBRAICS && returnData-\>nAlgebraic) {
    returnData-\>algebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    returnData-\>oldAlgebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    returnData-\>oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    assert(returnData-\>algebraics&&returnData-\>oldAlgebraics&&returnData-\>oldAlgebraics2);
    memset(returnData-\>algebraics,0,sizeof(double)*returnData-\>nAlgebraic);
    memset(returnData-\>oldAlgebraics,0,sizeof(double)*returnData-\>nAlgebraic);
    memset(returnData-\>oldAlgebraics2,0,sizeof(double)*returnData-\>nAlgebraic);
  } else {
    returnData-\>algebraics = 0;
    returnData-\>oldAlgebraics = 0;
    returnData-\>oldAlgebraics2 = 0;
    returnData-\>stringVariables.algebraics = 0;
  }

  if (flags & ALGEBRAICS && returnData-\>stringVariables.nAlgebraic) {
    returnData-\>stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
    assert(returnData-\>stringVariables.algebraics);
    memset(returnData-\>stringVariables.algebraics,0,sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
  } else {
    returnData-\>stringVariables.algebraics=0;
  }

  if(flags & PARAMETERS && returnData-\>nParameters) {
    returnData-\>parameters = (double*) malloc(sizeof(double)*returnData-\>nParameters);
    assert(returnData-\>parameters);
    memset(returnData-\>parameters,0,sizeof(double)*returnData-\>nParameters);
  } else {
    returnData-\>parameters = 0;
  }

  if (flags & PARAMETERS && returnData-\>stringVariables.nParameters) {
  	  returnData-\>stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nParameters);
      assert(returnData-\>stringVariables.parameters);
      memset(returnData-\>stringVariables.parameters,0,sizeof(char*)*returnData-\>stringVariables.nParameters);
  } else {
      returnData-\>stringVariables.parameters=0;
  }

  if(flags & OUTPUTVARS && returnData-\>nOutputVars) {
    returnData-\>outputVars = (double*) malloc(sizeof(double)*returnData-\>nOutputVars);
    assert(returnData-\>outputVars);
    memset(returnData-\>outputVars,0,sizeof(double)*returnData-\>nOutputVars);
  } else {
    returnData-\>outputVars = 0;
  }

  if(flags & INPUTVARS && returnData-\>nInputVars) {
    returnData-\>inputVars = (double*) malloc(sizeof(double)*returnData-\>nInputVars);
    assert(returnData-\>inputVars);
    memset(returnData-\>inputVars,0,sizeof(double)*returnData-\>nInputVars);
  } else {
    returnData-\>inputVars = 0;
  }

  if(flags & INITIALRESIDUALS && returnData-\>nInitialResiduals) {
    returnData-\>initialResiduals = (double*) malloc(sizeof(double)*returnData-\>nInitialResiduals);
    assert(returnData-\>initialResiduals);
    memset(returnData-\>initialResiduals,0,sizeof(double)*returnData-\>nInitialResiduals);
  } else {
    returnData-\>initialResiduals = 0;
  }

  if(flags & INITFIXED) {
    returnData-\>initFixed = init_fixed;
  } else {
    returnData-\>initFixed = 0;
  }

  /*   names   */
  if(flags & MODELNAME) {
    returnData-\>modelName = model_name;
  } else {
    returnData-\>modelName = 0;
  }
  
  if(flags & STATESNAMES) {
    returnData-\>statesNames = state_names;
  } else {
    returnData-\>statesNames = 0;
  }

  if(flags & STATESDERIVATIVESNAMES) {
    returnData-\>stateDerivativesNames = derivative_names;
  } else {
    returnData-\>stateDerivativesNames = 0;
  }

  if(flags & ALGEBRAICSNAMES) {
    returnData-\>algebraicsNames = algvars_names;
  } else {
    returnData-\>algebraicsNames = 0;
  }

  if(flags & PARAMETERSNAMES) {
    returnData-\>parametersNames = param_names;
  } else {
    returnData-\>parametersNames = 0;
  }

  if(flags & INPUTNAMES) {
    returnData-\>inputNames = input_names;
  } else {
    returnData-\>inputNames = 0;
  }

  if(flags & OUTPUTNAMES) {
    returnData-\>outputNames = output_names;
  } else {
    returnData-\>outputNames = 0;
  }

  /*   comments  */
  if(flags & STATESCOMMENTS) {
    returnData-\>statesComments = state_comments;
  } else {
    returnData-\>statesComments = 0;
  }

  if(flags & STATESDERIVATIVESCOMMENTS) {
    returnData-\>stateDerivativesComments = derivative_comments;
  } else {
    returnData-\>stateDerivativesComments = 0;
  }

  if(flags & ALGEBRAICSCOMMENTS) {
    returnData-\>algebraicsComments = algvars_comments;
  } else {
    returnData-\>algebraicsComments = 0;
  }

  if(flags & PARAMETERSCOMMENTS) {
    returnData-\>parametersComments = param_comments;
  } else {
    returnData-\>parametersComments = 0;
  }

  if(flags & INPUTCOMMENTS) {
    returnData-\>inputComments = input_comments;
  } else {
    returnData-\>inputComments = 0;
  }

  if(flags & OUTPUTCOMMENTS) {
    returnData-\>outputComments = output_comments;
  } else {
    returnData-\>outputComments = 0;
  }

  if (flags & EXTERNALVARS) {
    returnData-\>extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData-\>extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData-\>extObjs,0,sizeof(void*)*NEXT);
    setLocalData(returnData); /* must be set since used by constructors*/
    <preExp>
    <ctorCalls>
    <aliases of (var1, var2): '<cref(var1)> = <cref(var2)>;' "\n">
  }
  return returnData;
}
>>

functionDeInitializeDataStruc(ExtObjInfo extObjInfo) ::=
case EXTOBJINFO then
<<
void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
{
  if(!data)
    return;

  if(flags & STATES && data-\>states) {
    free(data-\>states);
    data-\>states = 0;
  }

  if(flags & STATESDERIVATIVES && data-\>statesDerivatives) {
    free(data-\>statesDerivatives);
    data-\>statesDerivatives = 0;
  }

  if(flags & ALGEBRAICS && data-\>algebraics) {
    free(data-\>algebraics);
    data-\>algebraics = 0;
  }

  if(flags & PARAMETERS && data-\>parameters) {
    free(data-\>parameters);
    data-\>parameters = 0;
  }

  if(flags & OUTPUTVARS && data-\>inputVars) {
    free(data-\>inputVars);
    data-\>inputVars = 0;
  }

  if(flags & INPUTVARS && data-\>outputVars) {
    free(data-\>outputVars);
    data-\>outputVars = 0;
  }
  
  if(flags & INITIALRESIDUALS && data-\>initialResiduals){
    free(data-\>initialResiduals);
    data-\>initialResiduals = 0;
  }
  if (flags & EXTERNALVARS && data-\>extObjs) {
    <destructors of (fn, var): '<fn>(<cref(var)>);' "\n">
    free(data-\>extObjs);
    data-\>extObjs = 0;
  }
}
>>

functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations,
                  list<DAE.Statement> algorithmAndEquationAsserts) ::=
# varDecls = ""
# nonStateContPart = (nonStateContEquations:
  '<equation_(it, contextSimulationNonDescrete, varDecls)>' "\n")
# algAndEqAssertsPart = (algorithmAndEquationAsserts:
  '<algStatement(it, contextSimulationNonDescrete, varDecls)>' "\n")
# removedPart = (removedEquations:
  '<equation_(it, contextSimulationNonDescrete, varDecls)>' "\n")
<<
/* for continuous time variables */
int functionDAE_output()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();
  <nonStateContPart>
  <algAndEqAssertsPart>
  <removedPart>
  restore_memory_state(mem_state);

  return 0;
}
>>

functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
# varDecls = ""
# nonSateDiscPart = (nonStateDiscEquations:
  '<equation_(it, contextSimulationDescrete, varDecls)>' "\n")
# removedPart = (removedEquations:
  '<equation_(it, contextSimulationDescrete, varDecls)>' "\n")
<<
/* for discrete time variables */
int functionDAE_output2()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();
  <nonSateDiscPart>
  <removedPart>
  restore_memory_state(mem_state);

  return 0;
}
>>

functionInput(ModelInfo modelInfo) ::=
case MODELINFO(vars=SIMVARS) then
<<
int input_function()
{
  <vars.inputVars of SIMVAR:
    '<cref(name)> = localData-\>inputVars[<i0>];' "\n">
  return 0;
}
>>

functionOutput(ModelInfo modelInfo) ::=
case MODELINFO(vars=SIMVARS) then
<<
int output_function()
{
  <vars.outputVars of SIMVAR:
    'localData-\>outputVars[<i0>] = <cref(name)>;' "\n">
  return 0;
}
>>

functionDaeRes() ::=
<<
int functionDAE_res(double *t, double *x, double *xd, double *delta,
                    long int *ires, double *rpar, long int* ipar)
{
  int i;
  double temp_xd[NX];
  double* statesBackup;
  double* statesDerivativesBackup;
  double timeBackup;

  statesBackup = localData-\>states;
  statesDerivativesBackup = localData-\>statesDerivatives;
  timeBackup = localData-\>timeValue;
  localData-\>states = x;

  for (i=0; i\<localData-\>nStates; i++) {
    temp_xd[i] = localData-\>statesDerivatives[i];
  }

  localData-\>statesDerivatives = temp_xd;
  localData-\>timeValue = *t;

  functionODE();

  /* get the difference between the temp_xd(=localData-\>statesDerivatives)
     and xd(=statesDerivativesBackup) */
  for (i=0; i \< localData-\>nStates; i++) {
    delta[i] = localData-\>statesDerivatives[i] - statesDerivativesBackup[i];
  }

  localData-\>states = statesBackup;
  localData-\>statesDerivatives = statesDerivativesBackup;
  localData-\>timeValue = timeBackup;

  if (modelErrorCode) {
    if (ires) {
      *ires = -1;
    }
    modelErrorCode =0;
  }

  return 0;
}
>>

functionZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
# varDecls = ""
# zeroCrossingCode = zeroCrossingsTpl(zeroCrossings, varDecls)
<<
int function_zeroCrossing(long *neqm, double *t, double *x, long *ng,
                          double *gout, double *rpar, long* ipar)
{
  double timeBackup;
  state mem_state;

  mem_state = get_memory_state();

  timeBackup = localData->timeValue;
  localData->timeValue = *t;
  <varDecls>

  functionODE();
  functionDAE_output();

  <zeroCrossingCode>

  restore_memory_state(mem_state);
  localData->timeValue = timeBackup;

  return 0;
}
>>

// This function should only save in cases. The rest is done in
// function_updateDependents.
functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave) ::=
<<
int handleZeroCrossing(long index)
{
  state mem_state;

  mem_state = get_memory_state();

  switch(index) {
    <zeroCrossingsNeedSave of vars:
      <<
      case <i0>:
        <vars of SIMVAR: 'save(<cref(name)>);' "\n">
        break;
      >>
    "\n">
    default:
      break;
  }

  restore_memory_state(mem_state);

  return 0;
}
>>

functionUpdateDependents(list<SimEqSystem> allEquations,
                         list<HelpVarInfo> helpVarInfo) ::=
# varDecls = ""
# eqs = (allEquations:
  '<equation_(it, contextSimulationDescrete, varDecls)>' "\n")
# hvars = (helpVarInfo of (hindex, exp, _):
    # preExp = ""
    # expPart = daeExp(exp, contextSimulationDescrete, preExp, varDecls)
    '<preExp>localData->helpVars[<hindex>] = <expPart>;'
  "\n")
<<
int function_updateDependents()
{
  state mem_state;
  <varDecls>

  inUpdate=initial()?0:1;

  mem_state = get_memory_state();

  <eqs>
  <hvars>

  restore_memory_state(mem_state);

  inUpdate=0;

  return 0;
}
>>

// This is just a copy of function_updateDependents template. Not sure what it
// should do.
//
// All when equations should go in here too according to Willi. And something
// about if-eqs being sorted and not just added to end.
functionUpdateDepend(list<SimEqSystem> allEquationsPlusWhen) ::=
# varDecls = ""
# eqs = (allEquationsPlusWhen: '<equation_(it, contextSimulationDescrete, varDecls)>' "\n")
<<
int function_updateDepend()
{
  state mem_state;
  <varDecls>

  inUpdate=initial()?0:1;

  mem_state = get_memory_state();
  <eqs>
  restore_memory_state(mem_state);

  inUpdate=0;

  return 0;
}
>>

functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
# varDecls = ""
# zeroCrossingCode = zeroCrossingsTpl(zeroCrossings, varDecls)
<<
int function_onlyZeroCrossings(double *gout,double *t)
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <zeroCrossingCode>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionCheckForDiscreteChanges(list<ComponentRef> discreteModelVars) ::=
<<
int checkForDiscreteChanges()
{
  int needToIterate = 0;

  <discreteModelVars of var:
    'if (change(<cref(var)>)) { needToIterate=1; }' "\n">
  
  return needToIterate;
}
>>

functionStoreDelayed(list<tuple<DAE.Exp, DAE.Exp>> delayedExps) ::=
# varDecls = ""
# storePart = (delayedExps of (id, e):
    # preExp = ""
    # idRes = daeExp(id, contextSimulationNonDescrete, preExp, varDecls)
    # eRes = daeExp(e, contextSimulationNonDescrete, preExp, varDecls)
    <<
    <preExp>
    storeDelayedExpression(<idRes>, <eRes>);
    >>
  )
<<
int function_storeDelayed()
{
  state mem_state;
  <varDecls>
  mem_state = get_memory_state();
  <storePart>
  restore_memory_state(mem_state);
  return 0;
}
>>

functionWhen(list<SimWhenClause> whenClauses) ::=
# varDecls = ""
# cases = (whenClauses of SIM_WHEN_CLAUSE:
  <<
  case <i0>:
    <functionWhenCaseEquation(whenEq, varDecls)>
    <reinits of reinit:
      # preExp = ""
      # body = functionWhenReinitStatement(reinit, preExp, varDecls)
      '<preExp><\n><body>'
    "\n">
    break;<\n>
  >>)
<<
int function_when(int i)
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  switch(i) {
    <cases>
    default:
      break;
  }

  restore_memory_state(mem_state);

  return 0;
}
>>

functionWhenCaseEquation(Option<WhenEquation>, Text varDecls) ::=
case SOME(weq as WHEN_EQ) then
# preExp = ""
# expPart = daeExp(weq.right, contextSimulationDescrete, preExp, varDecls)
<<
save(<cref(weq.left)>);

<preExp>
<cref(weq.left)> = <expPart>;
>>

functionWhenReinitStatement(ReinitStatement, Text preExp, Text varDecls) ::=
case REINIT then
# val = daeExp(value, contextSimulationDescrete, preExp, varDecls)
<<
<cref(stateVar)> = <val>;
>>

functionOde(list<SimEqSystem> stateContEquations) ::=
# varDecls = ""
# stateContPart = (stateContEquations of eq:
  '<equation_(eq, contextOther, varDecls)>' "\n")
<<
int functionODE()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <stateContPart>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionInitial(list<SimEqSystem> initialEquations) ::=
# varDecls = ""
# eqPart = (initialEquations of SES_SIMPLE_ASSIGN:
  '<equation_(it, contextOther, varDecls)>' "\n")
<<
int initial_function()
{
  <varDecls>

  <eqPart>

  <initialEquations of SES_SIMPLE_ASSIGN:
    'if (sim_verbose) { printf("Setting variable start value: %s(start=%f)\n", "<cref(componentRef)>", <cref(componentRef)>); }' "\n">

  return 0;
}
>>

functionInitialResidual(list<SimEqSystem> residualEquations) ::=
# varDecls = ""
# body = (
  residualEquations of SES_RESIDUAL:
    if exp is DAE.SCONST then
      'localData-\>initialResiduals[i++] = 0;'
    else
      # preExp = ""
      # expPart = daeExp(exp, contextOther, preExp, varDecls)
      '<preExp>localData-\>initialResiduals[i++] = <expPart>;'
  "\n"
)
<<
int initial_residual()
{
  int i = 0;
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionExtraResudials(list<SimEqSystem> allEquations) ::=
(allEquations of eq as SES_NONLINEAR:
   # varDecls = ""
   # prebody = (eq.eqs of eq2 as SES_SIMPLE_ASSIGN:
     '<equation_(it, contextOther, varDecls)>' "\n")   
   # body = (eq.eqs of eq2 as SES_RESIDUAL:
       # preExp = ""
       # expPart = daeExp(eq2.exp, contextSimulationDescrete, preExp, varDecls)
       '<preExp>res[<i0>] = <expPart>;'
     "\n")
   <<
   void residualFunc<index>(int *n, double* xloc, double* res, int* iflag)
   {
     state mem_state;
     <varDecls>
     mem_state = get_memory_state();
     <prebody>
     <body>
     restore_memory_state(mem_state);
   }
   >>
 "\n\n")

functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
# varDecls = ""
# body = (parameterEquations of SES_SIMPLE_ASSIGN:
  '<equation_(it, contextOther, varDecls)>' "\n")
<<
int bound_parameters()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

// Is the -1 check really correct? It seems to work.
functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfo,
                                   list<ComponentRef> discreteModelVars) ::=
<<
int checkForDiscreteVarChanges()
{
  int needToIterate = 0;

  <helpVarInfo of (hindex, exp, windex):
    if windex is not -1 then
      'if (edge(localData-\>helpVars[<hindex>])) AddEvent(<windex> + localData-\>nZeroCrossing);'
  "\n">

  <discreteModelVars of var:
    'if (change(<cref(var)>)) { needToIterate=1; }' "\n">
  
  for (long i = 0; i \< localData-\>nHelpVars; i++) {
    if (change(localData-\>helpVars[i])) {
      needToIterate=1;
    }
  }

  return needToIterate;
}
>>

zeroCrossingsTpl(list<ZeroCrossing> zeroCrossings, Text varDecls) ::=
<<
<zeroCrossings of ZERO_CROSSING:
  '<zeroCrossingTpl(i0, relation_, varDecls)>' "\n">
>>

zeroCrossingTpl(Integer index, Exp relation, Text varDecls) ::=
match relation
case RELATION then
  # preExp = ""
  # e1 = daeExp(exp1, contextOther, preExp, varDecls)
  # op = zeroCrossingOpFunc(operator)
  # e2 = daeExp(exp2, contextOther, preExp, varDecls)
  <<
  <preExp>
  ZEROCROSSING(<index>, <op>(<e1>, <e2>));
  >>
case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
  # preExp = ""
  # e1 = daeExp(start, contextOther, preExp, varDecls)
  # e2 = daeExp(interval, contextOther, preExp, varDecls)
  <<
  <preExp>
  ZEROCROSSING(<index>, Sample(*t, <e1>, <e2>));
  >>
case _ then
  <<
  ZERO CROSSING ERROR
  >>

zeroCrossingOpFunc(Operator) ::=
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"

// Residual equations are not handled here.
equation_(SimEqSystem eq, Context context, Text varDecls) ::=
case SES_SIMPLE_ASSIGN then
# preExp = ""
# expPart = daeExp(exp, context, preExp, varDecls)
<<
<preExp>
<cref(componentRef)> = <expPart>;
>>
case SES_ARRAY_CALL_ASSIGN then // cref_array = call(...)
# preExp = ""
# expPart = daeExp(exp, context, preExp, varDecls)
<<
<preExp>
copy_real_array_data_mem(&<expPart>, &<cref(componentRef)>);
>>
case SES_ALGORITHM then
# stmts = (statements : algStatement(it, context, varDecls) \n) 
<<
<stmts>
>>
case SES_LINEAR then
# uid = System.tmpTick()
# size = listLength(vars)
# aname = 'A<uid>'
# bname = 'b<uid>'
# mixedPostfix = if partOfMixed then "_mixed" else ""
<<
declare_matrix(<aname>, <size>, <size>);
declare_vector(<bname>, <size>);
<simJac of (row, col, eq as SES_RESIDUAL):
   # preExp = ""
   # expPart = daeExp(eq.exp, context, preExp, varDecls)
   '<preExp>set_matrix_elt(<aname>, <row>, <col>, <size>, <expPart>);'
"\n">
<beqs:
   # preExp = ""
   # expPart = daeExp(it, context, preExp, varDecls)
   '<preExp>set_vector_elt(<bname>, <i0>, <expPart>);'
"\n">
solve_linear_equation_system<mixedPostfix>(<aname>, <bname>, <size>, <uid>);
<vars of SIMVAR: '<cref(it.name)> = get_vector_elt(<bname>, <i0>);' "\n">
>>
case SES_MIXED then
# contEqs = equation_(cont, context, varDecls)
# numDiscVarsStr = listLength(discVars) 
# valuesLenStr = listLength(values)
# preDisc = ""
# discLoc2 = (discEqs of SES_SIMPLE_ASSIGN:
  # expPart = daeExp(exp, context, preDisc, varDecls)
  <<
  <cref(componentRef)> = <expPart>;
  discrete_loc2[<i0>] = <cref(componentRef)>;
  >>
  "\n")
<<
mixed_equation_system(<numDiscVarsStr>);
double values[<valuesLenStr>] = {<values: '<it>' ", ">};
int value_dims[<numDiscVarsStr>] = {<value_dims: '<it>' ", ">};
<discVars of SIMVAR: 'discrete_loc[<i0>] = <cref(it.name)>;' "\n">
{
  <contEqs>
}
<preDisc>
<discLoc2>
{
  double *loc_ptrs[<numDiscVarsStr>] = {<discVars of SIMVAR: '&<cref(name)>' ", ">};
  check_discrete_values(<numDiscVarsStr>, <valuesLenStr>);
}
mixed_equation_system_end(<numDiscVarsStr>);
>>
case SES_NONLINEAR then
# size = listLength(crefs)
<<
start_nonlinear_system(<size>);
<crefs: 'nls_x[<i0>] = extraPolate(<cref(it)>);<\n>nls_xold[<i0>] = old(&<cref(it)>);' "\n">
solve_nonlinear_system(residualFunc<index>, <index>);
<crefs: '<cref(it)> = nls_x[<i0>];' "\n">
end_nonlinear_system();
>>
case SES_WHEN then
# preExp = ""
# helpInits = ""
# helpIf = (conditions of (e, hidx):
  # helpInit = daeExp(e, context, preExp, varDecls)
  # helpInits += 'localData-\>helpVars[<hidx>] = <helpInit>;'
  'edge(localData-\>helpVars[<hidx>])'
  " || "
)
# preExp2 = ""
# exp = daeExp(right, context, preExp2, varDecls)
<<
<preExp>
<helpInits>
if (<helpIf>) {
  <preExp2>
  <cref(left)> = <exp>;
} else {
  <cref(left)> = pre(<cref(left)>);
}
>>
case _ then
<<
notimplemented = notimplemented;
>>

// SECTION: FUNCTION TARGET, FUNCTIONS FILE SPECIFIC TEMPLATES

functionsFile2(list<Function> functions) ::=
<<
#include "modelica.h"
#include \<stdio.h\>
#include \<stdlib.h\>
#include \<errno.h\>

#if defined(_MSC_VER)
  #define DLLExport   __declspec( dllexport )
#else
  #define DLLExport /* nothing */
#endif

#if !defined(MODELICA_ASSERT)
  #define MODELICA_ASSERT(cond,msg) { if (!(cond)) fprintf(stderr,"Modelica Assert: %s!\n", msg); }
#endif
#if !defined(MODELICA_TERMINATE)
  #define MODELICA_TERMINATE(msg) { fprintf(stderr,"Modelica Terminate: %s!\n", msg); fflush(stderr); }
#endif


#ifdef __cplusplus
extern "C" {
#endif

/* Header */
<externalFunctionIncludes(functions)>
<functionHeaders(functions)>
/* End Header */

/* Body */
<functionBodies(functions)>
/* End Body */

#ifdef __cplusplus
}
#endif
>>

// SECTION: SIMULATION TARGET, FUNCTIONS FILE SPECIFIC TEMPLATES

functionsFile(list<Function> functions) ::=
<<
#ifdef __cplusplus
extern "C" {
#endif

/* Header */
<externalFunctionIncludes(functions)>
<functionHeaders(functions)>
/* End Header */

/* Body */
<functionBodies(functions)>
/* End Body */

#ifdef __cplusplus
}
#endif
>>

// SECTION: FUNCTION TARGET, MAKEFILE FILE SPECIFIC TEMPLATES

makefileFunction(FunctionCode) ::=
case FUNCTIONCODE(makefileParams=MAKEFILE_PARAMS) then
# libsStr = (makefileParams.libs: it " ")
<<
# Makefile generated by OpenModelica

CC=<makefileParams.ccompiler>
CXX=<makefileParams.cxxcompiler>
LINK=<makefileParams.linker>
EXEEXT=<makefileParams.exeext>
DLLEXT=<makefileParams.dllext>
CFLAGS= -I"<makefileParams.omhome>/include" <makefileParams.cflags>
LDFLAGS= -L"<makefileParams.omhome>/lib" <makefileParams.ldflags>

.PHONY: <name>
<name>: <name>.c
<\t> $(LINK) $(CFLAGS) -o <name>$(DLLEXT) <name>.c $(LDFLAGS) <libsStr> -lm
>>

// SECTION: SIMULATION TARGET, MAKEFILE FILE SPECIFIC TEMPLATES

makefile(SimCode) ::=
case SIMCODE(modelInfo=MODELINFO, makefileParams=MAKEFILE_PARAMS) then
# dirExtra = if modelInfo.directory then "-L\"<modelInfo.directory>\"" else ""
# libsStr = (makefileParams.libs: it " ")
<<
# Makefile generated by OpenModelica

CC=<makefileParams.ccompiler>
CXX=<makefileParams.cxxcompiler>
LINK=<makefileParams.linker>
EXEEXT=<makefileParams.exeext>
DLLEXT=<makefileParams.dllext>
CFLAGS= -I"<makefileParams.omhome>/include" <makefileParams.cflags>
LDFLAGS= -L"<makefileParams.omhome>/lib" <makefileParams.ldflags>

.PHONY: <modelInfo.name>
<modelInfo.name>: <modelInfo.name>.cpp
<\t> $(CXX) $(CFLAGS) -I. -o <modelInfo.name>$(EXEEXT) <modelInfo.name>.cpp <dirExtra> -lsim $(LDFLAGS) -lf2c ${SENDDATALIBS} <libsStr>
>>

// SECTION: GENERAL TEMPLATES, COMPONENT REFERENCES

cref(ComponentRef) ::=
  case CREF_IDENT then '<ident>'
  case CREF_QUAL then '<ident>.<cref(componentRef)>'
  case _ then "CREF_NOT_IDENT_OR_QUAL"

crefSubscript(ComponentRef) ::=
  case CREF_IDENT then '<ident><subscriptsTpl(subscriptLst)>'
  case _ then "CREF_NOT_IDENT"

subscriptsTpl(list<Subscript> subscripts) ::=
if subscripts then '[<subscripts of s: subscriptTpl(s) ",">]'
else ""

subscriptTpl(Subscript subscript) ::=
case INDEX then (
  match exp
  case ICONST then integer
  case _ then "SUBSCRIPT_NOT_CONSTANT"
)
case _ then "SUBSCRIPT_NOT_CONSTANT"
 
// SECTION: GENERAL TEMPLATES, PATHS

dotPath(Path) ::=
  case QUALIFIED      then '<name>.<dotPath(path)>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)

underscorePath(Path) ::=
  case QUALIFIED      then '<System.stringReplace(name, "_", "__")>_<underscorePath(path)>'
  case IDENT          then System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then underscorePath(path)

// SECTION: GENERAL TEMPLATES, FUNCTION GENERATION

externalFunctionIncludes(list<Function> functions) ::=
<<
#ifdef __cplusplus
extern "C" {
#endif
<functions of EXTERNAL_FUNCTION: (includes: it "\n") "\n">
#ifdef __cplusplus
}
#endif
>>

functionHeaders(list<Function> functions) ::=
<<
<functions:
  case FUNCTION then
    <<
    <recordDecls: recordDeclaration(it) \n>
    <functionHeader(underscorePath(name), functionArguments, outVars)>
    >> 
  case EXTERNAL_FUNCTION then
    <<
    <functionHeader(underscorePath(name), funArgs, outVars)>

    <extFunDef(it)>
    >> 
\n> 
>>

recordDeclaration(RecordDeclaration) ::=
case RECORD_DECL_FULL then
  <<
  struct <name> {
    <variables of var as VARIABLE : '<varType(var)> <cref(var.name)>;' \n>
  };
  <recordDefinition(dotPath(defPath),
                    underscorePath(defPath),
                    (variables of VARIABLE: '"<cref(name)>"' ",") )>
  >> 

recordDefinition(String origName, String encName, String fieldNames) ::=
<<
const char* <encName>__desc__fields[] = {<fieldNames>};
struct record_description <encName>__desc = {
  "<encName>", /* package_record__X */
  "<origName>", /* package.record_X */
  <encName>__desc__fields
};
>>

functionHeader(String fname, Variables fargs, Variables outVars) ::=
<<
<outVars of VARIABLE: '#define <fname>_rettype_<i1> targ<i1>' \n>
typedef struct <fname>_rettype_s 
{
  <outVars of VARIABLE:
    '<varType(it)> targ<i1>; /* <cref(name)><if ty is ET_ARRAY then '[<arrayDimensions: if it is SOME(d) then d else ":" ", ">]'> */'
  \n>
} <fname>_rettype;

DLLExport 
int in_<fname>(type_description * inArgs, type_description * outVar);

DLLExport 
<fname>_rettype _<fname>(<fargs of VARIABLE: '<varType(it)> <cref(name)>' ", ">);
>>

extFunDef(Function) ::=
case EXTERNAL_FUNCTION then
<<
extern <extReturnType(extReturn)> <extName>(<extArgs: extFunDefArg(it) ", ">);
>>

extReturnType(SimExtArg) ::=
  case SIMEXTARG then extType(type_)
  case SIMNOEXTARG then "void"

extType(Type) ::=
  case ET_INT then "int"
  case ET_REAL then "double"
  case ET_STRING then "const char*"
  case ET_BOOL then "int"
  case ET_ARRAY then extType(ty)
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ) then "void *"
  case _ then "OTHER_EXT_TYPE"

// Assume that language is C for now.
extFunDefArg(SimExtArg) ::=
case SIMEXTARG(cref=c, isInput=ii, isArray=ia, type_=t) then
  # name = cref(c)
  # typeStr = if ii then
      if ia then
        if t is ET_STRING then
          '<extType(t)> const *'
        else
          'const <extType(t)> *'
      else
        '<extType(t)>'
    else
      '<extType(t)>*'
  <<
  <typeStr> <name>
  >>
case SIMEXTARGEXP then
  # typeStr = extType(type_)
  <<
  <typeStr>
  >>
case SIMEXTARGSIZE(cref=c) then
  # name = cref(c)
  # eStr = daeExpToString(exp)
  <<
  size_t <name>_<eStr>
  >>

// This only works for constans (or else the name of a temporary variable is
// returned).
daeExpToString(Exp exp) ::=
  # preExp = ""
  # varDecls = ""
  daeExp(exp, contextOther, preExp, varDecls)

functionBodies(list<Function> functions) ::=
<<
<functions: functionBody(it) \n>
>>

functionBody(Function fn) ::=
case FUNCTION then
  # System.tmpTickReset(1)
  # fname = underscorePath(name)
  # retType = '<fname>_rettype'
  # varDecls = ""
  # varInits = ""
  # retVar = tempDecl(retType, varDecls)
  # stateVar = tempDecl("state", varDecls)
  # _ = (variableDeclarations: varInit(it, "", i1, varDecls, varInits))
  # bodyPart = (body of stmt : funStatement(stmt, varDecls) \n)
  # outVarsStr = (outVars: varOutput(it, retVar, i1, varDecls, varInits))
  <<
  <retType> _<fname>(<functionArguments of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>' ", ">)
  {
    <varDecls>
    <stateVar> = get_memory_state();

    <varInits>

    <bodyPart>
    
    _return:
    <outVarsStr>
    restore_memory_state(<stateVar>);
    return <retVar>;
  }

  int in_<fname>(type_description * inArgs, type_description * outVar)
  {
    <functionArguments of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>;' "\n">
    <retType> out;
    <functionArguments of VARIABLE: 'if (read_<expTypeArrayIf(ty)>(&inArgs, &<cref(name)>)) return 1;' "\n">
    out = _<fname>(<functionArguments of VARIABLE: cref(name) ", ">);
    <outVars of VARIABLE: 'write_<varType(it)>(outVar, &out.targ<i1>);' "\n">
    return 0;
  }
  >>
case EXTERNAL_FUNCTION then
  # System.tmpTickReset(1)
  # fname = underscorePath(name)
  # retType = '<fname>_rettype'
  # preExp = ""
  # varDecls = ""
  # outputAlloc = ""
  # callPart = extFunCall(fn, preExp, varDecls)
  # _ = (outVars: varInit(it, "out", i1, varDecls, outputAlloc))
  <<
  <retType> _<fname>(<funArgs of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>' ", ">)
  {
    <varDecls>
    <retType> out;
    <outputAlloc>
    <preExp>
    <callPart>
    return out;
  }
  >>

varInit(Variable, String outStruct, Integer i, Text varDecls, Text varInits) ::=
case var as VARIABLE then
  # varDecls += '<varType(var)> <cref(var.name)>;<\n>'
  # varName = if outStruct then '<outStruct>.targ<i>' else '<cref(var.name)>'
  # instDimsInit = (instDims of exp: daeExp(exp, contextOther, varInits, varDecls) ", ")
  if instDims then
    # varInits += 'alloc_<expTypeShort(var.ty)>_array(&<varName>, <listLength(instDims)>, <instDimsInit>);<\n>'
    ()
  else
    ()

varOutput(Variable source, String dest, Integer i, Text varDecls, Text varInits) ::=
case var as VARIABLE then
  # instDimsInit = (instDims of exp: daeExp(exp, contextOther, varInits, varDecls) ", ")
  if instDims then
    # varInits += 'alloc_<expTypeShort(var.ty)>_array(&<dest>.targ<i>, <listLength(instDims)>, <instDimsInit>);<\n>'
    <<
    copy_<expTypeShort(var.ty)>_array_data(&<cref(var.name)>, &<dest>.targ<i>);
    >>
  else
    <<
    <dest>.targ<i> = <cref(var.name)>;
    >>

extFunCall(Function fun, Text preExp, Text varDecls) ::=
case EXTERNAL_FUNCTION then
  # fname = underscorePath(name)
  # args = (extArgs: extArg(it, preExp, varDecls) ", ")
  # returnAssign = if extReturn is SIMEXTARG(cref=c) then '<cref(c)>_ext = ' else ""
  <<
  <extArgs: extFunCallVardecl(it, varDecls) "\n">
  <if extReturn is SIMEXTARG then extFunCallVardecl(extReturn, varDecls)>
  <returnAssign><extName>(<args>);
  <extArgs: extFunCallVarcopy(it) "\n">
  <if extReturn is SIMEXTARG then extFunCallVarcopy(extReturn)>
  >>

extFunCallVardecl(SimExtArg arg, Text varDecls) ::=
case SIMEXTARG(isInput=true, isArray=false, type_=ty, cref=c) then
  if ty is ET_STRING then
    ""
  else
    # varDecls += '<extType(ty)> <cref(c)>_ext;<\n>'
    <<
    <cref(c)>_ext = (<extType(ty)>)<cref(c)>;
    >>
case SIMEXTARG(outputIndex=oi, isArray=false, type_=ty, cref=c) then
  if oi is 0 then
    ""
  else
    # varDecls += '<extType(ty)> <cref(c)>_ext;<\n>'
    ""

extFunCallVarcopy(SimExtArg arg) ::=
case SIMEXTARG(outputIndex=oi, isArray=false, type_=ty, cref=c) then
  if oi is 0 then
    ""
  else
    <<
    out.targ<oi> = (<expTypeModelica(ty)>)<cref(c)>_ext;
    >>

extArg(SimExtArg, Text preExp, Text varDecls) ::=
case SIMEXTARG(cref=c, outputIndex=oi, isArray=true, type_=t) then
  # name = if oi then 'out.targ<oi>' else cref(c)
  # shortTypeStr = expTypeShort(t)
  <<
  data_of_<shortTypeStr>_array(&(<name>))
  >>
case SIMEXTARG(cref=c, isInput=ii, outputIndex=oi, type_=t) then
  # prefix = if oi then "&" else ""
  # suffix = if oi then "_ext"
             else if t is ET_STRING then ""
             else "_ext"
  <<
  <prefix><cref(c)><suffix>
  >>
case SIMEXTARGEXP then '<daeExp(exp, contextOther, preExp, varDecls)>'
case SIMEXTARGSIZE(cref=c) then
  # typeStr = expTypeShort(type_)
  # name = if outputIndex then 'out.targ<outputIndex>' else cref(c)
  # dim = daeExp(exp, contextOther, preExp, varDecls)
  <<
  size_of_dimension_<typeStr>_array(<name>, <dim>)
  >>

funBody(list<Statement> body) ::=
# varDecls = ""
# bodyPart = (body of stmt: funStatement(stmt, varDecls) \n)
<<
<varDecls>
<bodyPart>
>>

funStatement(Statement, Text varDecls) ::=
case ALGORITHM then (statementLst: algStatement(it, contextOther, varDecls) \n) 
case _ then "/* not implemented fun statement */"

algStatement(DAE.Statement, Context context, Text varDecls) ::=
case STMT_ASSIGN(exp1=CREF(componentRef=WILD), exp=e) then
  # preExp = "" 
  # expPart = daeExp(e, context, preExp, varDecls)
  <<
  <preExp>
  >>
case STMT_ASSIGN(exp1=CREF) then
  # preExp = ""
  # expPart = daeExp(exp, context, preExp, varDecls)
  <<
  <preExp>
  <scalarLhsCref(exp1, context, preExp, varDecls)> = <expPart>;
  >>
case STMT_ASSIGN then
  # preExp = ""
  # expPart1 = daeExp(exp1, context, preExp, varDecls)
  # expPart2 = daeExp(exp, context, preExp, varDecls)
  <<
  <preExp>
  <expPart1> = <expPart2>;
  >>
case STMT_ASSIGN_ARR(exp=e, componentRef=cref, type_=t) then
  # preExp = ""
  # expPart = daeExp(e, context, preExp, varDecls)
  if indexSpecFromCref(cref, context, preExp, varDecls) then
    <<
    <preExp>
    indexed_assign_<expTypeArray(t)>(&<expPart>, &<cref(cref)>, &<it>);
    >>
  else
    <<
    <preExp>
    copy_<expTypeArray(t)>_data(&<expPart>, &<cref(cref)>);
    >>
case STMT_TUPLE_ASSIGN(exp=CALL) then
  # preExp = ""
  # retStruct = daeExp(exp, context, preExp, varDecls)
  <<
  <preExp>
  <expExpLst of CREF: '<scalarLhsCref(it, context, preExp, varDecls)> = <retStruct>.targ<i1>;' "\n">
  >>
case STMT_IF then
  # preExp = ""
  # condExp = daeExp(exp, context, preExp, varDecls)
  <<
  <preExp>
  if (<condExp>) {
    <statementLst : algStatement(it, context, varDecls) \n>
  }
  <elseExpr(else_, context, varDecls)>
  >>
case STMT_FOR(exp=rng as RANGE) then
  # stateVar = tempDecl("state", varDecls)
  # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
  # identType = expType(type_, boolean)
  # r1 = tempDecl(identType, varDecls)
  # r2 = tempDecl(identType, varDecls)
  # r3 = tempDecl(identType, varDecls)
  # preExp = ""
  # er1 = daeExp(rng.exp, context, preExp, varDecls)
  # er2 = if rng.expOption is SOME(eo) 
          then daeExp(eo, context, preExp, varDecls)
          else "(1)"
  # er3 = daeExp(rng.range, context, preExp, varDecls) 
  <<
  <preExp>
  <r1> = <er1>; <r2> = <er2>; <r3> = <er3>;
  {
  <identType> <ident>;

    for (<ident> = <r1>; in_range_<expTypeShort(type_)>(<ident>, <r1>, <r3>); <ident> += <r2>) {
      <stateVar> = get_memory_state();
      <statementLst : algStatement(it, context, varDecls) \n /* ??CONTEXT(codeContext,expContext,IN_FOR_LOOP(loopContext)*/ >
      restore_memory_state(<stateVar>);
    }
  } /*end for*/
  >>
case STMT_FOR then
  # stateVar = tempDecl("state", varDecls)
  # arrayType = expTypeArray(type_)
  # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
  # tvar = tempDecl("int", varDecls)
  # identType = expType(type_, boolean)
  # ivar = tempDecl(identType, varDecls)
  # preExp = ""
  # evar = daeExp(exp, context, preExp, varDecls)
  # statements = (statementLst: algStatement(it, context, varDecls) \n)
  # id = '<ident>'
  # stmtStuff = if boolean
                then 'simple_index_alloc_<identType>1(&<evar>, <tvar>, &<ivar>);'
                else '<id> = *(<arrayType>_element_addr1(&<evar>, 1, <tvar>));'
  <<
  <preExp>
  {
  <identType> <ident>;

    for (<tvar> = 1; <tvar> \<= size_of_dimension_<arrayType>(<evar>, 1); ++<tvar>) {
      <stateVar> = get_memory_state();
      <stmtStuff>
      <statements>
      restore_memory_state(<stateVar>);
    }
  } /* end for*/
  >>
case STMT_WHILE then
  # preExp = ""
  # var = daeExp(exp, context, preExp, varDecls)
  <<
  while (1) {
    <preExp>
    if (!<var>) break;
    <statementLst: algStatement(it, context, varDecls) \n>
  }
  >>
case STMT_ASSERT then
  # preExp = ""
  # condVar = daeExp(cond, context, preExp, varDecls)
  # msgVar = daeExp(msg, context, preExp, varDecls)
  <<
  <preExp>
  MODELICA_ASSERT(<condVar>, <msgVar>);
  >>
case when as STMT_WHEN then if context is SIMULATION(genDiscrete=true)
                       then algStatementWhen(when, context, varDecls)
                       else ""
case _ then "/* not implemented alg statement*/"

algStatementWhen(DAE.Statement, Context context, Text varDecls) ::=
case STMT_WHEN then
  # preIf = algStatementWhenPre(it, varDecls)
  # statements = (statementLst: '<algStatement(it, context, varDecls)>' "\n")
  # else = algStatementWhenElse(elseWhen, varDecls)
  <<
  <preIf>
  if (<helpVarIndices: 'edge(localData-\>helpVars[<it>])' " || ">) {
    <statements>
  }
  <else>
  >>

algStatementWhenPre(DAE.Statement, Text varDecls) ::=
case STMT_WHEN(exp=ARRAY(array=el)) then
  # restPre = if elseWhen is SOME(ew)
              then algStatementWhenPre(ew, varDecls) else ""
  # preExp = ""
  # assignments = algStatementWhenPreAssigns(el, helpVarIndices, preExp, varDecls)
  <<
  <preExp>
  <assignments>
  <restPre>
  >>
case when as STMT_WHEN then
  match helpVarIndices
  case {i} then
    # restPre = if when.elseWhen is SOME(ew)
                then algStatementWhenPre(ew, varDecls) else ""
    # preExp = ""
    # res = daeExp(when.exp, contextSimulationDescrete, preExp, varDecls)
    <<
    <preExp>
    localData-\>helpVars[<i>] = <res>;
    <restPre>
    >>

algStatementWhenElse(Option<DAE.Statement>, Text varDecls) ::=
case SOME(when as STMT_WHEN) then
  # statements = (when.statementLst: '<algStatement(it, contextSimulationDescrete, varDecls)>' "\n")
  # else = algStatementWhenElse(when.elseWhen, varDecls)
  <<
  else if (<when.helpVarIndices: 'edge(localData-\>helpVars[<it>])' " || ">) {
    <statements>
  }
  <else>
  >>

algStatementWhenPreAssigns(list<Exp> exps, list<Integer> ints, Text preExp, Text varDecls) ::=
case {} then ""
case (firstExp :: restExps) then
  match ints
  case (firstInt :: restInts) then
    # rest = algStatementWhenPreAssigns(restExps, restInts, preExp, varDecls)
    <<
    localData-\>helpVars[<firstInt>] = <daeExp(firstExp, contextSimulationDescrete, preExp, varDecls)>;
    <rest>
    >>

elseExpr(DAE.Else, Context context, Text varDecls) ::= 
case NOELSE then ()
case ELSEIF then
  # preExp = ""
  # condExp = daeExp(exp, context, preExp, varDecls)
  <<
  else {
  <preExp>
  if (<condExp>) {
    <statementLst: algStatement(it, context, varDecls) \n>
  }
  <elseExpr(else_, context, varDecls)>
  }
  >>
case ELSE then
  <<
  else {
    <statementLst: algStatement(it, context, varDecls) \n>
  }
  >>

scalarLhsCref(Exp cref, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if crefNoSub(cref.componentRef) then
    '<cref(cref.componentRef)>'
  else
    daeExpCrefRhs(cref, context, preExp, varDecls)
case cref as CREF(componentRef=CREF_QUAL(subscriptLst=subs)) then
  '<cref(cref.componentRef)>'
case _ then
  "ONLY IDENT SUPPORTED"

rhsCref(ComponentRef, ExpType ty) ::=
  case CREF_IDENT then '<rhsCrefType(ty)><ident>'
  case CREF_QUAL  then '<rhsCrefType(ty)><ident>.<rhsCref(componentRef,ty)>'
  case _          then "rhsCref:ERROR"

rhsCrefType(ExpType) ::=
  case ET_INT then "(modelica_integer)"
  case _      then ""
  
// SECTION: GENERAL TEMPLATES, EXPRESSIONS

daeExp(Exp exp, Context context, Text preExp, Text varDecls) ::=
  case ICONST     then integer
  case RCONST     then real
  case SCONST     then daeExpSconst(string, preExp, varDecls)
  case BCONST     then if bool then "(1)" else "(0)"
  case CREF       then daeExpCrefRhs(it, context, preExp, varDecls)
  case BINARY     then daeExpBinary(it, context, preExp, varDecls)
  case UNARY      then daeExpUnary(it, context, preExp, varDecls)
  case LBINARY    then daeExpLbinary(it, context, preExp, varDecls)
  case LUNARY     then daeExpLunary(it, context, preExp, varDecls)
  case RELATION   then daeExpRelation(it, context, preExp, varDecls)
  case IFEXP      then daeExpIf(it, context, preExp, varDecls)
  case CALL       then daeExpCall(it, context, preExp, varDecls)
  case ARRAY      then daeExpArray(it, context, preExp, varDecls)
  case MATRIX     then daeExpMatrix(it, context, preExp, varDecls)
  case CAST       then daeExpCast(it, context, preExp, varDecls)
  case ASUB       then daeExpAsub(it, context, preExp, varDecls)
  case SIZE       then daeExpSize(it, context, preExp, varDecls)
  case REDUCTION  then daeExpReduction(it, context, preExp, varDecls)
  case VALUEBLOCK then daeExpValueblock(it, context, preExp, varDecls)
  case _          then "UNKNOWN_EXP"

daeExpSconst(String string, Text preExp, Text varDecls) ::=
  # strVar = tempDecl("modelica_string", varDecls)
  # preExp += 'init_modelica_string(&<strVar>,"<Util.escapeModelicaStringToCString(string)>");<\n>'
  strVar  

daeExpCrefRhs(Exp exp, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if daeExpCrefRhsArrayBox(exp, context, preExp, varDecls) then
    it
  else if crefNoSub(cref.componentRef) then
    # cast = if cref.ty is ET_INT then "(modelica_integer)" else ""
    '<cast><cref(cref.componentRef)>'
  else if crefSubIsScalar(cref.componentRef) then
    // The array subscript results in a scalar
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # dimsLenStr = listLength(subs)
    # dimsValuesStr = (subs of INDEX: daeExp(exp, context, preExp, varDecls) ", ")
    <<
    (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
    >>
  else
    // The array subscript denotes a slice
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # tmp = tempDecl(arrayType, varDecls)
    # spec1 = daeExpCrefRhsIndexSpec(subs, context, preExp, varDecls)
    # preExp += 'index_alloc_<arrayType>(&<arrName>, &<spec1>, &<tmp>);<\n>'
    tmp
case cref as CREF(componentRef=CREF_QUAL(subscriptLst=subs)) then
  '<cref(cref.componentRef)>'
case _ then
  "UNKNOWN RHS CREF: ONLY IDENT SUPPORTED"

daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context, Text preExp, Text varDecls) ::=
# nridx_str = listLength(subs)
# idx_str = (subs of sub:
               case INDEX then
                 # expPart = daeExp(exp, context, preExp, varDecls)
                 <<
                 (1), make_index_array(1, <expPart>), 'S'
                 >>
               case WHOLEDIM then
                 <<
                 (1), (0), 'W'
                 >>
               case SLICE then
                 # expPart = daeExp(exp, context, preExp, varDecls)
                 # tmp = tempDecl("modelica_integer", varDecls)
                 # preExp += '<tmp> = size_of_dimension_integer_array(<expPart>, 1);<\n>'
                 <<
                 <tmp>, integer_array_make_index_array(&<expPart>), 'A'
                 >>
             ", ")
# tmp = tempDecl("index_spec_t", varDecls)
# preExp += 'create_index_spec(&<tmp>, <nridx_str>, <idx_str>);<\n>'
tmp

daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = tempDecl(expTypeArray(aty), varDecls)
    # dimsLenStr = listLength(dims)
    # dimsValuesStr = (dims of dim as SOME(i): i ", ")
    # preExp += '<expTypeShort(aty)>_array_create(&<tmpArr>, &<cref(cref.componentRef)>, <dimsLenStr>, <dimsValuesStr>);<\n>'
    tmpArr

daeExpBinary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case BINARY then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match operator
  case ADD(ty = ET_STRING) then
    # tmpStr = tempDecl("modelica_string", varDecls)
    # preExp += 'cat_modelica_string(&<tmpStr>,&<e1>,&<e2>);<\n>'
    tmpStr
  case ADD then '(<e1> + <e2>)'
  case SUB then '(<e1> - <e2>)'
  case MUL then '(<e1> * <e2>)'
  case DIV then '(<e1> / <e2>)'
  case POW then 'pow((modelica_real)<e1>, (modelica_real)<e2>)'
  case ADD_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'add_alloc_<type>(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case SUB_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'sub_alloc_<type>(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case MUL_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'mul_alloc_<type>_scalar(&<e1>, <e2>, &<var>);<\n>'
    '<var>'
  case DIV_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'div_alloc_<type>_scalar(&<e1>, <e2>, &<var>);<\n>'
    '<var>'
  case _   then "daeExpBinary:ERR"

daeExpUnary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case UNARY then
  # e = daeExp(exp, context, preExp, varDecls)
  match operator
  case UMINUS     then '(-<e>)'
  case UPLUS      then '(<e>)'
  case UMINUS_ARR then "UMINUS_ARR_NOT_IMPLEMENTED"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"

daeExpLbinary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case LBINARY then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match operator
  case AND then '(<e1> && <e2>)'
  case OR  then '(<e1> || <e2>)'
  case _   then "daeExpLbinary:ERR"

daeExpLunary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case LUNARY then
  # e = daeExp(exp, context, preExp, varDecls)
  match operator
  case NOT then '(!<e>)'

daeExpRelation(Exp exp, Context context, Text preExp, Text varDecls) ::=
case rel as RELATION then
  if daeExpRelationSim(exp, context, preExp, varDecls) then
    it
  else
    # e1 = daeExp(rel.exp1, context, preExp, varDecls)
    # e2 = daeExp(rel.exp2, context, preExp, varDecls)
    match rel.operator
    case LESS(ty = ET_BOOL)        then '(!<e1> && <e2>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)         then '(<e1> \< <e2>)'
    case LESS(ty = ET_REAL)        then '(<e1> \< <e2>)'
    case GREATER(ty = ET_BOOL)     then '(<e1> && !<e2>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)      then '(<e1> > <e2>)'
    case GREATER(ty = ET_REAL)     then '(<e1> > <e2>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<e1> || <e2>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)       then '(<e1> \<= <e2>)'
    case LESSEQ(ty = ET_REAL)      then '(<e1> \<= <e2>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<e1> || !<e2>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)    then '(<e1> >= <e2>)'
    case GREATEREQ(ty = ET_REAL)   then '(<e1> >= <e2>)'
    case EQUAL(ty = ET_BOOL)       then '((!<e1> && !<e2>) || (<e1> && <e2>))'
    case EQUAL(ty = ET_STRING)     then '(!strcmp(<e1>, <e2>))'
    case EQUAL(ty = ET_INT)        then '(<e1> == <e2>)'
    case EQUAL(ty = ET_REAL)       then '(<e1> == <e2>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<e1> && <e2>) || (<e1> && !<e2>))'
    case NEQUAL(ty = ET_STRING)    then '(strcmp(<e1>, <e2>))'
    case NEQUAL(ty = ET_INT)       then '(<e1> != <e2>)'
    case NEQUAL(ty = ET_REAL)      then '(<e1> != <e2>)'
    case _                         then "daeExpRelation:ERR"

daeExpRelationSim(Exp exp, Context context, Text preExp, Text varDecls) ::=
case rel as RELATION then
  match context
  case SIMULATION then
    # e1 = daeExp(rel.exp1, context, preExp, varDecls)
    # e2 = daeExp(rel.exp2, context, preExp, varDecls)
    # res = tempDecl("modelica_boolean", varDecls)
    match rel.operator
    case LESS      then # preExp += 'RELATIONLESS(<res>, <e1>, <e2>);<\n>' res
    case LESSEQ    then # preExp += 'RELATIONLESSEQ(<res>, <e1>, <e2>);<\n>' res
    case GREATER   then # preExp += 'RELATIONGREATER(<res>, <e1>, <e2>);<\n>' res
    case GREATEREQ then # preExp += 'RELATIONGREATEREQ(<res>, <e1>, <e2>);<\n>' res

daeExpIf(Exp exp, Context context, Text preExp, Text varDecls) ::=
case IFEXP then
  # condExp = daeExp(expCond, context, preExp, varDecls)
  # condVar = tempDecl("modelica_boolean", varDecls)
  # resVarType = expTypeFromExpArrayIf(expThen)
  # resVar = tempDecl(resVarType, varDecls)
  # preExpThen = ""
  # eThen = daeExp(expThen, context, preExpThen, varDecls)
  # preExpElse = ""
  # eElse = daeExp(expElse, context, preExpElse, varDecls)
  # preExp +=  
  <<
  <condVar> = <condExp>;
  if (<condVar>) {
    <preExpThen>
    <resVar> = <eThen>;
  } else {
    <preExpElse>
    <resVar> = <eElse>;
  }<\n>
  >>
  resVar
//  <<
//  ((<condVar>)?<eThen>:<eElse>)
//  >>

daeExpCall(Exp call, Context context, Text preExp, Text varDecls) ::=
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    # retType = '<expTypeArrayIf(arg.ty)>'
    # retVar = tempDecl(retType, varDecls)
    # cast = if arg.ty is ET_INT then "(modelica_integer)" else ""
    # preExp += '<retVar> = <cast>pre(<cref(arg.componentRef)>);<\n>'
    '<retVar>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="max"), expLst={array}) then
    # expVar = daeExp(array, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(array)>'
    # tvar = tempDecl(expTypeFromExpModelica(array), varDecls)
    # preExp += '<tvar> = max_<arr_tp_str>(&<expVar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="promote"), expLst={A, n}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # var2 = daeExp(n, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls)
    # preExp += 'promote_alloc_<arr_tp_str>(&<var1>, <var2>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="transpose"), expLst={A}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls)
    # preExp += 'transpose_alloc_<arr_tp_str>(&<var1>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="identity"), expLst={A}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls)
    # preExp += 'identity_alloc_<arr_tp_str>(<var1>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="abs"), expLst={s1}) then
    # tvar = tempDecl(expTypeFromExpModelica(s1), varDecls)
    # s1Exp = daeExp(s1, context, preExp, varDecls)
    # preExp += '<tvar> = fabs(<s1Exp>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="String"), expLst={s, minlen, leftjust, signdig}) then
    # tvar = tempDecl("modelica_string", varDecls)
    # sExp = daeExp(s, context, preExp, varDecls)
    # minlenExp = daeExp(minlen, context, preExp, varDecls)
    # leftjustExp = daeExp(leftjust, context, preExp, varDecls)
    # signdigExp = daeExp(signdig, context, preExp, varDecls)
    # typeStr = expTypeFromExpModelica(s)
    # preExp += '<typeStr>_to_modelica_string(&<tvar>, <sExp>, <minlenExp>, <leftjustExp>, <signdigExp>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="delay"), expLst={ICONST(integer=index), e, d, delayMax}) then
    # tvar = tempDecl("modelica_real", varDecls)
    # var1 = daeExp(e, context, preExp, varDecls)
    # var2 = daeExp(d, context, preExp, varDecls)
    # preExp += '<tvar> = delayImpl(<index>, <var1>, time, <var2>);<\n>'
    tvar
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # preExp += '<daeExpCallBuiltinPrefix(builtin)><funName>(<argStr>);<\n>'
    '/* NORETCALL */'
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls)
    # preExp += '<retVar> = <daeExpCallBuiltinPrefix(builtin)><funName>(<argStr>);<\n>'
    if builtin then '<retVar>' else '<retVar>.<retType>_1'
  // tuple calls (multiple return values)
  case CALL(tuple_=true) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls)
    # preExp += '<retVar> = <daeExpCallBuiltinPrefix(builtin)><funName>(<argStr>);<\n>'
    '<retVar>'

daeExpCallBuiltinPrefix(Boolean builtin) ::=
  case true then ""
  case false then "_"

daeExpArray(Exp exp, Context context, Text preExp, Text varDecls) ::=
case ARRAY then
# arrayTypeStr = '<expTypeArray(ty)>'
# arrayVar = tempDecl(arrayTypeStr, varDecls)
# scalarPrefix = if scalar then "scalar_" else ""
# scalarRef = if scalar then "&" else ""
# params = '<array of e: '(<expTypeFromExpModelica(e)>)<daeExp(e, context, preExp, varDecls)>' ", ">'
# preExp += 'array_alloc_<scalarPrefix><arrayTypeStr>(&<arrayVar>, <listLength(array)>, <params>);<\n>'
'<arrayVar>'

daeExpMatrix(Exp exp, Context context, Text preExp, Text varDecls) ::=
case MATRIX(scalar={{}}) then
  // special case for empty matrix: create dimensional array Real[0,1]
  # arrayTypeStr = expTypeArray(ty)
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
  tmp
case MATRIX(scalar={}) then
  // special case for empty array: create dimensional array Real[0,1]
  # arrayTypeStr = expTypeArray(ty)
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
  tmp
case m as MATRIX then
  # arrayTypeStr = expTypeArray(m.ty)
  # vars2 = ""
  # promote = ""
  # catAlloc = (m.scalar of row:
                 # tmp = tempDecl(arrayTypeStr, varDecls)
                 # vars = daeExpMatrixRow(row, arrayTypeStr, context, promote, varDecls)
                 # vars2 += ', &<tmp>'
                 'cat_alloc_<arrayTypeStr>(2, &<tmp>, <listLength(row)><vars>);'
               "\n")
  # preExp += promote
  # preExp += catAlloc
  # preExp += "\n"
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'cat_alloc_<arrayTypeStr>(1, &<tmp>, <listLength(m.scalar)><vars2>);<\n>'
  tmp

daeExpMatrixRow(list<tuple<Exp,Boolean>> row, String arrayTypeStr,
                Context context, Text preExp, Text varDecls) ::=
# varLstStr = ""
# preExp2 = (row of col as (e, b):
               # scalarStr = if b then "scalar_" else ""
               # scalarRefStr = if b then "" else "&"
               # expVar = daeExp(e, context, preExp, varDecls)
               # tmp = tempDecl(arrayTypeStr, varDecls)
               # varLstStr += ', &<tmp>'
               'promote_<scalarStr><arrayTypeStr>(<scalarRefStr><expVar>, 2, &<tmp>);'
             "\n")
# preExp2 += "\n"
# preExp += preExp2
varLstStr

daeExpCast(Exp exp, Context context, Text preExp, Text varDecls) ::=
case CAST then
  # expVar = daeExp(exp, context, preExp, varDecls)
  match ty
  case ET_INT   then '((modelica_int)<expVar>)' // TODO: really int? not integer?
  case ET_REAL  then '((modelica_real)<expVar>)'
  case ET_ARRAY then
    # arrayTypeStr = expTypeArray(ty)
    # tvar = tempDecl(arrayTypeStr, varDecls)
    # to = expTypeShort(ty)
    # from = expTypeFromExpShort(exp)
    # preExp += 'cast_<from>_array_to_<to>(&<expVar>, &<tvar>);<\n>'
    tvar

daeExpAsub(Exp exp, Context context, Text preExp, Text varDecls) ::=
case ASUB(exp=RANGE(ty=t), sub={idx}) then
  'ASUB_EASY_CASE'
case ASUB(exp=ASUB(
            exp=ASUB(
              exp=ASUB(exp=e, sub={ICONST(integer=i)}),
              sub={ICONST(integer=j)}),
            sub={ICONST(integer=k)}),
          sub={ICONST(integer=l)}) then
  'ASUB_4D'
case ASUB(exp=ASUB(
            exp=ASUB(exp=e, sub={ICONST(integer=i)}),
            sub={ICONST(integer=j)}),
          sub={ICONST(integer=k)}) then
  'ASUB_3D'
case ASUB(exp=ASUB(exp=e, sub={ICONST(integer=i)}),
          sub={ICONST(integer=j)}) then
  'ASUB_2D'
case ASUB(exp=e, sub={ICONST(integer=i)}) then
  'ASUB_ARRAY'
case ASUB(exp=cref as CREF, sub=subs) then
  # arrName = daeExpCrefRhs(buildCrefExpFromAsub(cref, subs), context, preExp, varDecls)
  if context is SIMULATION then
    arrayScalarRhs(cref.ty, subs, arrName, context, preExp, varDecls)
  else
    '<arrName>'
case _ then
  'OTHER_ASUB'

daeExpSize(Exp exp, Context context, Text preExp, Text varDecls) ::=
case SIZE(exp=CREF, sz=SOME(dim)) then
  # expPart = daeExp(exp, context, preExp, varDecls)
  # dimPart = daeExp(dim, context, preExp, varDecls)
  # resVar = tempDecl("size_t", varDecls)
  # typeStr = '<expTypeArray(exp.ty)>'
  # preExp += '<resVar> = size_of_dimension_<typeStr>(<expPart>, <dimPart>);<\n>'
  resVar
case _ then "size(X) not implemented"

daeExpReduction(Exp exp, Context context, Text preExp, Text varDecls) ::=
case REDUCTION(path=IDENT(name=op), range=RANGE) then
  # stateVar = tempDecl("state", varDecls)
  # identType = expTypeModelica(range.ty)
  # accFun = daeExpReductionFnName(op, identType)
  # startValue = daeExpReductionStartValue(op, identType)
  # res = tempDecl(identType, varDecls)
  # tmpExpPre = ""
  # tmpExpVar = daeExp(expr, context, tmpExpPre, varDecls)
  # cast = if accFun is "max" then "(modelica_real)"
           else if accFun is "min" then "(modelica_real)"
           else ""
  # r1 = tempDecl(identType, varDecls)
  # r2 = tempDecl(identType, varDecls)
  # r3 = tempDecl(identType, varDecls)
  # er1 = daeExp(range.exp, context, preExp, varDecls)
  # er2 = if range.expOption is SOME(eo) 
          then daeExp(eo, context, preExp, varDecls)
          else "(1)"
  # er3 = daeExp(range.range, context, preExp, varDecls) 
  # preExp +=
    <<
    <res> = <startValue>;
    <r1> = <er1>; <r2> = <er2>; <r3> = <er3>;
    {
      <identType> <ident>;

      for (<ident> = <r1>; in_range_<expTypeFromExpShort(expr)>(<ident>, <r1>, <r3>); <ident> += <r2>) {
        <stateVar> = get_memory_state();
        <tmpExpPre>
        <res> = <accFun>(<cast>(<res>), <cast>(<tmpExpVar>));
        restore_memory_state(<stateVar>);
      }
    }
    >>
  res

daeExpReductionFnName(String reduction_op, String type) ::=
  case "sum" then (
    match type
    case "modelica_integer" then "intAdd"
    case "modelica_real" then "realAdd"
    case _ then "INVALID_TYPE"
  )
  case "product" then (
    match type
    case "modelica_integer" then "intMul"
    case "modelica_real" then "realMul"
    case _ then "INVALID_TYPE"
  )
  case _ then reduction_op

daeExpReductionStartValue(String reduction_op, String type) ::=
  case "min" then (
    match type
    case "modelica_integer" then "1073741823"
    case "modelica_real" then "1.e60"
    case _ then "INVALID_TYPE"
  )
  case "max" then (
    match type
    case "modelica_integer" then "-1073741823"
    case "modelica_real" then "-1.e60"
    case _ then "INVALID_TYPE"
  )
  case "sum" then "0"
  case "product" then "1"
  case _ then "UNKNOWN_REDUCTION"

daeExpValueblock(Exp exp, Context context, Text preExp, Text varDecls) ::=
case VALUEBLOCK then
  # preExpInner = ""
  # preExpRes = ""
  # varDeclsInner = ""
  # _ = (valueblockVars(it): varInit(it, "", 0, varDeclsInner, preExpInner) "\n")
  # resType = expTypeModelica(ty)
  # res = tempDecl(expTypeModelica(ty), preExp)
  # stmts = (body: '<algStatement(it, context, varDeclsInner)>' "\n")
  # expPart = daeExp(result, context, preExpRes, varDeclsInner)
  # preExp +=
  <<
  {
    <varDeclsInner>
    <preExpInner>
    <stmts>
    <preExpRes>
    <res> = <expPart>;
  }
  >>
  res

// TODO: Optimize as in Codegen
// TODO: Use this function in other places where almost the same thing is hard
//       coded
arrayScalarRhs(ExpType ty, list<Exp> subs, String arrName, Context context,
               Text preExp, Text varDecls) ::=
  # arrayType = expTypeArray(ty)
  # dimsLenStr = listLength(subs)
  # dimsValuesStr = (subs of exp: daeExp(exp, context, preExp, varDecls) ", ")
  <<
  (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
  >>

// SECTION: GENERAL TEMPLATES, TEMPORARY VARIABLES

tempDecl(String ty, Text varDecls) ::=
  # newVar = 'tmp<System.tmpTick()>'
  # varDecls += '<ty> <newVar>;<\n>'
  newVar

// SECTION: GENERAL TEMPLATES, TYPES

varType(Variable) ::=
  case var as VARIABLE then
    if instDims then
      expTypeArray(var.ty)
    else
      expTypeArrayIf(var.ty)

expTypeShort(DAE.ExpType) ::=
  case ET_INT     then "integer"
  case ET_REAL    then "real"
  case ET_STRING  then "string"
  case ET_BOOL    then "boolean"
  case ET_OTHER   then "complex"
  case ET_ARRAY   then expTypeShort(ty)   
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ) then "complex"
  case ET_COMPLEX then 'struct <underscorePath(name)>'  
  case _          then "expTypeShort:ERROR"

expType(DAE.ExpType ty, Boolean array) ::=
  match array
  case true  then expTypeArray(ty)
  case false then expTypeModelica(ty)

expTypeModelica(DAE.ExpType ty) ::=
  expTypeFlag(ty, 2)

expTypeArray(DAE.ExpType ty) ::=
  expTypeFlag(ty, 3)

expTypeArrayIf(DAE.ExpType ty) ::=
  expTypeFlag(ty, 4)

expTypeFromExpShort(Exp exp) ::=
  expTypeFromExpFlag(exp, 1)

expTypeFromExpModelica(Exp exp) ::=
  expTypeFromExpFlag(exp, 2)

expTypeFromExpArray(Exp exp) ::=
  expTypeFromExpFlag(exp, 3)

expTypeFromExpArrayIf(Exp exp) ::=
  expTypeFromExpFlag(exp, 4)

expTypeFlag(DAE.ExpType ty, Integer flag) ::=
  match flag
  // we want the short type
  case 1 then expTypeShort(ty)
  // we want the "modelica type"
  case 2 then
    if ty is ET_COMPLEX(complexClassType=EXTERNAL_OBJ) then 'modelica_<expTypeShort(ty)>'
    else if ty is ET_COMPLEX then 'struct <underscorePath(name)>'
    else 'modelica_<expTypeShort(ty)>'
  // we want the "array type"
  case 3 then '<expTypeShort(ty)>_array'
  // we want the "array type" only if type is array, otherwise "modelica type"
  case 4 then
    match ty
    case ET_ARRAY then '<expTypeShort(ty)>_array'
    case _        then expTypeFlag(ty, 2)

expTypeFromExpFlag(Exp, Integer flag) ::=
  case ICONST        then if flag is 1 then "integer" else "modelica_integer"
  case RCONST        then if flag is 1 then "real" else "modelica_real"
  case SCONST        then if flag is 1 then "string" else "modelica_string"
  case BCONST        then if flag is 1 then "boolean" else "modelica_boolean"
  case e as BINARY
  case e as UNARY
  case e as LBINARY
  case e as LUNARY
  case e as RELATION then expTypeFromOpFlag(e.operator, flag)
  case IFEXP         then expTypeFromExpFlag(expThen, flag)
  case CALL          then expTypeFlag(ty, flag)
  case c as ARRAY
  case c as MATRIX
  case c as RANGE
  case c as CAST
  case c as CREF
  case c as CODE     then expTypeFlag(c.ty, flag)
  case ASUB          then expTypeFromExpFlag(exp, flag)
  case REDUCTION     then expTypeFromExpFlag(expr, flag)
  case _             then "expTypeFromExpFlag:ERROR"

expTypeFromOpFlag(Operator, Integer flag) ::=
  case o as ADD
  case o as SUB
  case o as MUL
  case o as DIV
  case o as POW
  case o as UMINUS
  case o as UPLUS
  case o as UMINUS_ARR
  case o as UPLUS_ARR
  case o as ADD_ARR
  case o as SUB_ARR
  case o as MUL_ARR
  case o as DIV_ARR
  case o as MUL_SCALAR_ARRAY
  case o as MUL_ARRAY_SCALAR
  case o as ADD_SCALAR_ARRAY
  case o as ADD_ARRAY_SCALAR
  case o as SUB_SCALAR_ARRAY
  case o as SUB_ARRAY_SCALAR
  case o as MUL_SCALAR_PRODUCT
  case o as MUL_MATRIX_PRODUCT
  case o as DIV_ARRAY_SCALAR
  case o as DIV_SCALAR_ARRAY
  case o as POW_ARRAY_SCALAR
  case o as POW_SCALAR_ARRAY
  case o as POW_ARR
  case o as POW_ARR2
  case o as LESS
  case o as LESSEQ
  case o as GREATER
  case o as GREATEREQ
  case o as EQUAL
  case o as NEQUAL then
    expTypeFlag(o.ty, flag)
  case o as AND
  case o as OR
  case o as NOT then
    if flag is 1 then "boolean" else "modelica_boolean"
  case _ then "expTypeFromOpFlag:ERROR"

// This currently works only for CREF_IDENT
indexSpecFromCref(ComponentRef cref, Context context, Text preExp, Text
varDecls) ::=
  case CREF_IDENT(subscriptLst=subs as (_ :: _)) then
    daeExpCrefRhsIndexSpec(subs, context, preExp, varDecls)

end SimCodeC;

// vim: filetype=susan sw=2 sts=2
