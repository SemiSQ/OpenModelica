// This file defines templates for transforming Modelica/MetaModelica code to C
// code. They are used in the code generator phase of the compiler to write
// target code.
//
// There are two root templates intended to be called from the code generator:
// translateModel and translateFunctions. These templates do not return any
// result but instead write the result to files. All other templates return
// text and are used by the root templates (most of them indirectly).
//
// To future maintainers of this file:
//
// - A line like this
//     # var = "" /*BUFD*/
//   declares a text buffer that you can later append text to. It can also be
//   passed to other templates that in turn can append text to it. In the new
//   version of Susan it should be written like this instead:
//     let &var = buffer ""
//
// - A line like this
//     ..., Text var /*BUFP*/, ...
//   declares that a template takes a text buffer as input parameter. In the
//   new version of Susan it should be written like this instead:
//     ..., Text &var, ...
//
// - A line like this:
//     ..., var /*BUFC*/, ...
//   passes a text buffer to a template. In the new version of Susan it should
//   be written like this instead:
//     ..., &var, ...
//
// - Style guidelines:
//
//   - Try (hard) to limit each row to 80 characters
//
//   - Code for a template should be indented with 2 spaces
//
//     - Exception to this rule is if you have only a single case, then that
//       single case can be written using no indentation
//
//       This single case can be seen as a clarification of the input to the
//       template
//
//   - Code after a case should be indented with 2 spaces if not written on the
//     same line

spackage SimCodeC

typeview "SimCodeTV.mo"

// Generates C code and Makefile for compiling and running a simulation of a
// Modelica model.
translateModel(SimCode simCode) ::=
match simCode
case SIMCODE(modelInfo=MODELINFO) then
  # filePrefix = modelInfo.name
  # textFile(simulationFile(simCode), '<filePrefix>.cpp')
  # textFile(simulationFunctionsFile(functions), '<filePrefix>_functions.cpp')
  # textFile(simulationMakefile(simCode), '<filePrefix>.makefile')
  () // Return empty result since result written to files directly

// Generates C code and Makefile for compiling and calling Modelica and
// MetaModelica functions.
translateFunctions(FunctionCode functionCode) ::=
match functionCode
case FUNCTIONCODE then
  # filePrefix = name
  # textFile(functionsFile(functions, extraRecordDecls), '<filePrefix>.c')
  # textFile(functionsMakefile(functionCode), '<filePrefix>.makefile')
  () // Return empty result since result written to files directly

simulationFile(SimCode simCode) ::=
match simCode
case SIMCODE then
  <<
  <simulationFileHeader(simCode)>
  
  <globalData(modelInfo)>
  
  <functionGetName(modelInfo)>
  
  <functionDivisionError()>
  
  <functionSetLocalData()>
  
  <functionInitializeDataStruc(extObjInfo)>
  
  <functionDeInitializeDataStruc(extObjInfo)>
  
  <functionExtraResudials(allEquations)>
  
  <functionDaeOutput(nonStateContEquations, removedEquations,
                     algorithmAndEquationAsserts)>
  
  <functionDaeOutput2(nonStateDiscEquations, removedEquations)>
  
  <functionInput(modelInfo)>
  
  <functionOutput(modelInfo)>
  
  <functionDaeRes()>
  
  <functionZeroCrossing(zeroCrossings)>
  
  <functionHandleZeroCrossing(zeroCrossingsNeedSave)>
  
  <functionUpdateDependents(allEquations, helpVarInfo)>
  
  <functionUpdateDepend(allEquationsPlusWhen)>
  
  <functionOnlyZeroCrossing(zeroCrossings)>
  
  <functionCheckForDiscreteChanges(discreteModelVars)>
  
  <functionStoreDelayed(delayedExps)>
  
  <functionWhen(whenClauses)>
  
  <functionOde(stateContEquations)>
  
  <functionInitial(initialEquations)>
  
  <functionInitialResidual(residualEquations)>
  
  <functionBoundParameters(parameterEquations)>
  
  <functionCheckForDiscreteVarChanges(helpVarInfo, discreteModelVars)>
  >>

simulationFileHeader(SimCode simCode) ::=
match simCode
case SIMCODE(modelInfo=MODELINFO, extObjInfo=EXTOBJINFO) then
  <<
  // Simulation code for <modelInfo.name> generated by the OpenModelica Compiler.
  
  #include "modelica.h"
  #include "assert.h"
  #include "string.h"
  #include "simulation_runtime.h"
  
  #if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
    #define DLLExport   __declspec( dllexport )
  #else 
    #define DLLExport /* nothing */
  #endif 
  
  #include "<modelInfo.name>_functions.cpp"
  
  extern "C" {
  <extObjInfo.includes of include: include "\n">
  }
  >>

globalData(ModelInfo modelInfo) ::=
match modelInfo
case MODELINFO(varInfo=VARINFO, vars=SIMVARS) then
  <<
  #define NHELP <varInfo.numHelpVars>
  #define NG <varInfo.numZeroCrossings>
  #define NX <varInfo.numStateVars>
  #define NY <varInfo.numAlgVars>
  #define NP <varInfo.numParams>
  #define NO <varInfo.numOutVars>
  #define NI <varInfo.numInVars>
  #define NR <varInfo.numResiduals>
  #define NEXT <varInfo.numExternalObjects>
  #define MAXORD 5
  #define NYSTR <varInfo.numStringAlgVars>
  #define NPSTR <varInfo.numStringParamVars>
  
  static DATA* localData = 0;
  #define time localData-\>timeValue
  extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
    char *model_name="<name>";
    char *model_dir="<directory>";
  }
  
  <globalDataVarNamesArray("state_names", vars.stateVars)>
  <globalDataVarNamesArray("derivative_names", vars.derivativeVars)>
  <globalDataVarNamesArray("algvars_names", vars.algVars)>
  <globalDataVarNamesArray("input_names", vars.inputVars)>
  <globalDataVarNamesArray("output_names", vars.outputVars)>
  <globalDataVarNamesArray("param_names", vars.paramVars)>
  <globalDataVarNamesArray("string_alg_names", vars.stringAlgVars)>
  <globalDataVarNamesArray("string_param_names", vars.stringParamVars)>
  
  <globalDataVarCommentsArray("state_comments", vars.stateVars)>
  <globalDataVarCommentsArray("derivative_comments", vars.derivativeVars)>
  <globalDataVarCommentsArray("algvars_comments", vars.algVars)>
  <globalDataVarCommentsArray("input_comments", vars.inputVars)>
  <globalDataVarCommentsArray("output_comments", vars.outputVars)>
  <globalDataVarCommentsArray("param_comments", vars.paramVars)>
  <globalDataVarCommentsArray("string_alg_comments", vars.stringAlgVars)>
  <globalDataVarCommentsArray("string_param_comments", vars.stringParamVars)>
  
  <vars.stateVars of var:
    globalDataVarDefine(var, "states")
  "\n">
  <vars.derivativeVars of var:
    globalDataVarDefine(var, "statesDerivatives")
  "\n">
  <vars.algVars of var:
    globalDataVarDefine(var, "algebraics")
  "\n">
  <vars.paramVars of var:
    globalDataVarDefine(var, "parameters")
  "\n">
  <vars.extObjVars of var:
    globalDataVarDefine(var, "extObjs")
  "\n">
  <vars.stringAlgVars of var:
    globalDataVarDefine(var, "stringVariables.algebraics")
  "\n">
  
  static char init_fixed[NX+NX+NY+NP] = {
    <[(vars.stateVars of SIMVAR:
        '<globalDataFixedInt(isFixed)> /* <cref(origName)> */'
      ",\n"),
      (vars.derivativeVars of SIMVAR:
        '<globalDataFixedInt(isFixed)> /* <cref(origName)> */'
      ",\n"),
      (vars.algVars of SIMVAR:
        '<globalDataFixedInt(isFixed)> /* <cref(origName)> */'
      ",\n"),
      (vars.paramVars of SIMVAR:
        '<globalDataFixedInt(isFixed)> /* <cref(origName)> */'
      ",\n")]
    ",\n">
  };
  
  char var_attr[NX+NY+NP] = {
    <[(vars.stateVars of SIMVAR:
        '<globalDataAttrInt(type_)>+<globalDataDiscAttrInt(isDiscrete)> /* <cref(origName)> */'
      ",\n"),
      (vars.algVars of SIMVAR:
        '<globalDataAttrInt(type_)>+<globalDataDiscAttrInt(isDiscrete)> /* <cref(origName)> */'
      ",\n"),
      (vars.paramVars of SIMVAR:
        '<globalDataAttrInt(type_)>+<globalDataDiscAttrInt(isDiscrete)> /* <cref(origName)> */'
       ",\n")]
    ",\n">
  };
  >>

globalDataVarNamesArray(String name, list<SimVar> items) ::=
  match items
  case {} then
    <<
    char* <name>[1] = {""};
    >>
  case items then
    # itemsStr = (items of SIMVAR: '"<crefWithSubscript(origName)>"' ", ")
    <<
    char* <name>[<listLength(items)>] = {<itemsStr>};
    >>

globalDataVarCommentsArray(String name, list<SimVar> items) ::=
  match items
  case {} then
    <<
    char* <name>[1] = {""};
    >>
  case items then
    # itemsStr = (items of SIMVAR: '"<comment>"' ", ")
    <<
    char* <name>[<listLength(items)>] = {<itemsStr>};
    >>

globalDataVarDefine(SimVar simVar, String arrayName) ::=
  match simVar
  case SIMVAR(arrayCref=SOME(c)) then
    <<
    #define <cref(c)> localData-\><arrayName>[<index>]
    #define <cref(name)> localData-\><arrayName>[<index>]
    >>
  case SIMVAR then
    <<
    #define <cref(name)> localData-\><arrayName>[<index>]
    >>

globalDataFixedInt(Boolean isFixed) ::=
  match isFixed
  case true  then "1"
  case false then "0"

globalDataAttrInt(DAE.ExpType type) ::=
  match type
  case ET_REAL   then "1"
  case ET_STRING then "2"
  case ET_INT    then "4"
  case ET_BOOL   then "8"

globalDataDiscAttrInt(Boolean isDiscrete) ::=
  match isDiscrete
  case true  then "16"
  case false then "0"

functionGetName(ModelInfo modelInfo) ::=
match modelInfo
case MODELINFO(vars=SIMVARS) then
  <<
  char* getName(double* ptr)
  {
    <vars.stateVars of SIMVAR:
      'if (&<cref(name)> == ptr) return state_names[<index>];'
    "\n">
    <vars.derivativeVars of SIMVAR:
      'if (&<cref(name)> == ptr) return derivative_names[<index>];'
    "\n">
    <vars.algVars of SIMVAR:
      'if (&<cref(name)> == ptr) return algvars_names[<index>];'
    "\n">
    <vars.paramVars of SIMVAR:
      'if (&<cref(name)> == ptr) return param_names[<index>];'
    "\n">
    return "";
  }
  >>

functionDivisionError() ::=
  <<
  /* Commented out by Frenkel TUD because there is a new implementation of
     division by zero problem. */
  /*
  #define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))
  
  int encounteredDivisionByZero = 0;
  
  double division_error(double b, const char* division_str)
  {
    if(!encounteredDivisionByZero) {
      fprintf(stderr, "ERROR: Division by zero in partial equation: %s.\n",division_str);
      encounteredDivisionByZero = 1;
    }
    return b;
  }
  */
  >>

functionSetLocalData() ::=
  <<
  void setLocalData(DATA* data)
  {
    localData = data;
  }
  >>

functionInitializeDataStruc(ExtObjInfo extObjInfo) ::=
match extObjInfo
case EXTOBJINFO then
  # varDecls = "" /*BUFD*/
  # preExp = "" /*BUFD*/
  # ctorCalls = (constructors of (var, fnName, args):
      # argsStr = (args of arg:
          daeExp(arg, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
        ", ")
      '<cref(var)> = <fnName>(<argsStr>);'
    "\n")
  <<
  DATA* initializeDataStruc(DATA_FLAGS flags)
  {
    <varDecls>
  
    DATA* returnData = (DATA*)malloc(sizeof(DATA));
  
    if(!returnData) //error check
      return 0;
  
    memset(returnData,0,sizeof(DATA));
    returnData-\>nStates = NX;
    returnData-\>nAlgebraic = NY;
    returnData-\>nParameters = NP;
    returnData-\>nInputVars = NI;
    returnData-\>nOutputVars = NO;
    returnData-\>nZeroCrossing = NG;
    returnData-\>nInitialResiduals = NR;
    returnData-\>nHelpVars = NHELP;
    returnData-\>stringVariables.nParameters = NPSTR;
    returnData-\>stringVariables.nAlgebraic = NYSTR;
  
    if(flags & STATES && returnData-\>nStates) {
      returnData-\>states = (double*) malloc(sizeof(double)*returnData-\>nStates);
      returnData-\>oldStates = (double*) malloc(sizeof(double)*returnData-\>nStates);
      returnData-\>oldStates2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
      assert(returnData-\>states&&returnData-\>oldStates&&returnData-\>oldStates2);
      memset(returnData-\>states,0,sizeof(double)*returnData-\>nStates);
      memset(returnData-\>oldStates,0,sizeof(double)*returnData-\>nStates);
      memset(returnData-\>oldStates2,0,sizeof(double)*returnData-\>nStates);
    } else {
      returnData-\>states = 0;
      returnData-\>oldStates = 0;
      returnData-\>oldStates2 = 0;
    }
  
    if(flags & STATESDERIVATIVES && returnData-\>nStates) {
      returnData-\>statesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
      returnData-\>oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
      returnData-\>oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
      assert(returnData-\>statesDerivatives&&returnData-\>oldStatesDerivatives&&returnData-\>oldStatesDerivatives2);
      memset(returnData-\>statesDerivatives,0,sizeof(double)*returnData-\>nStates);
      memset(returnData-\>oldStatesDerivatives,0,sizeof(double)*returnData-\>nStates);
      memset(returnData-\>oldStatesDerivatives2,0,sizeof(double)*returnData-\>nStates);
    } else {
      returnData-\>statesDerivatives = 0;
      returnData-\>oldStatesDerivatives = 0;
      returnData-\>oldStatesDerivatives2 = 0;
    }
  
    if(flags & HELPVARS && returnData-\>nHelpVars) {
      returnData-\>helpVars = (double*) malloc(sizeof(double)*returnData-\>nHelpVars);
      assert(returnData-\>helpVars);
      memset(returnData-\>helpVars,0,sizeof(double)*returnData-\>nHelpVars);
    } else {
      returnData-\>helpVars = 0;
    }
  
    if(flags & ALGEBRAICS && returnData-\>nAlgebraic) {
      returnData-\>algebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
      returnData-\>oldAlgebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
      returnData-\>oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
      assert(returnData-\>algebraics&&returnData-\>oldAlgebraics&&returnData-\>oldAlgebraics2);
      memset(returnData-\>algebraics,0,sizeof(double)*returnData-\>nAlgebraic);
      memset(returnData-\>oldAlgebraics,0,sizeof(double)*returnData-\>nAlgebraic);
      memset(returnData-\>oldAlgebraics2,0,sizeof(double)*returnData-\>nAlgebraic);
    } else {
      returnData-\>algebraics = 0;
      returnData-\>oldAlgebraics = 0;
      returnData-\>oldAlgebraics2 = 0;
      returnData-\>stringVariables.algebraics = 0;
    }
  
    if (flags & ALGEBRAICS && returnData-\>stringVariables.nAlgebraic) {
      returnData-\>stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
      assert(returnData-\>stringVariables.algebraics);
      memset(returnData-\>stringVariables.algebraics,0,sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
    } else {
      returnData-\>stringVariables.algebraics=0;
    }
  
    if(flags & PARAMETERS && returnData-\>nParameters) {
      returnData-\>parameters = (double*) malloc(sizeof(double)*returnData-\>nParameters);
      assert(returnData-\>parameters);
      memset(returnData-\>parameters,0,sizeof(double)*returnData-\>nParameters);
    } else {
      returnData-\>parameters = 0;
    }
  
    if (flags & PARAMETERS && returnData-\>stringVariables.nParameters) {
    	  returnData-\>stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nParameters);
        assert(returnData-\>stringVariables.parameters);
        memset(returnData-\>stringVariables.parameters,0,sizeof(char*)*returnData-\>stringVariables.nParameters);
    } else {
        returnData-\>stringVariables.parameters=0;
    }
  
    if(flags & OUTPUTVARS && returnData-\>nOutputVars) {
      returnData-\>outputVars = (double*) malloc(sizeof(double)*returnData-\>nOutputVars);
      assert(returnData-\>outputVars);
      memset(returnData-\>outputVars,0,sizeof(double)*returnData-\>nOutputVars);
    } else {
      returnData-\>outputVars = 0;
    }
  
    if(flags & INPUTVARS && returnData-\>nInputVars) {
      returnData-\>inputVars = (double*) malloc(sizeof(double)*returnData-\>nInputVars);
      assert(returnData-\>inputVars);
      memset(returnData-\>inputVars,0,sizeof(double)*returnData-\>nInputVars);
    } else {
      returnData-\>inputVars = 0;
    }
  
    if(flags & INITIALRESIDUALS && returnData-\>nInitialResiduals) {
      returnData-\>initialResiduals = (double*) malloc(sizeof(double)*returnData-\>nInitialResiduals);
      assert(returnData-\>initialResiduals);
      memset(returnData-\>initialResiduals,0,sizeof(double)*returnData-\>nInitialResiduals);
    } else {
      returnData-\>initialResiduals = 0;
    }
  
    if(flags & INITFIXED) {
      returnData-\>initFixed = init_fixed;
    } else {
      returnData-\>initFixed = 0;
    }
  
    /*   names   */
    if(flags & MODELNAME) {
      returnData-\>modelName = model_name;
    } else {
      returnData-\>modelName = 0;
    }
    
    if(flags & STATESNAMES) {
      returnData-\>statesNames = state_names;
    } else {
      returnData-\>statesNames = 0;
    }
  
    if(flags & STATESDERIVATIVESNAMES) {
      returnData-\>stateDerivativesNames = derivative_names;
    } else {
      returnData-\>stateDerivativesNames = 0;
    }
  
    if(flags & ALGEBRAICSNAMES) {
      returnData-\>algebraicsNames = algvars_names;
    } else {
      returnData-\>algebraicsNames = 0;
    }
  
    if(flags & PARAMETERSNAMES) {
      returnData-\>parametersNames = param_names;
    } else {
      returnData-\>parametersNames = 0;
    }
  
    if(flags & INPUTNAMES) {
      returnData-\>inputNames = input_names;
    } else {
      returnData-\>inputNames = 0;
    }
  
    if(flags & OUTPUTNAMES) {
      returnData-\>outputNames = output_names;
    } else {
      returnData-\>outputNames = 0;
    }
  
    /*   comments  */
    if(flags & STATESCOMMENTS) {
      returnData-\>statesComments = state_comments;
    } else {
      returnData-\>statesComments = 0;
    }
  
    if(flags & STATESDERIVATIVESCOMMENTS) {
      returnData-\>stateDerivativesComments = derivative_comments;
    } else {
      returnData-\>stateDerivativesComments = 0;
    }
  
    if(flags & ALGEBRAICSCOMMENTS) {
      returnData-\>algebraicsComments = algvars_comments;
    } else {
      returnData-\>algebraicsComments = 0;
    }
  
    if(flags & PARAMETERSCOMMENTS) {
      returnData-\>parametersComments = param_comments;
    } else {
      returnData-\>parametersComments = 0;
    }
  
    if(flags & INPUTCOMMENTS) {
      returnData-\>inputComments = input_comments;
    } else {
      returnData-\>inputComments = 0;
    }
  
    if(flags & OUTPUTCOMMENTS) {
      returnData-\>outputComments = output_comments;
    } else {
      returnData-\>outputComments = 0;
    }
  
    if (flags & EXTERNALVARS) {
      returnData-\>extObjs = (void**)malloc(sizeof(void*)*NEXT);
      if (!returnData-\>extObjs) {
        printf("error allocating external objects\n");
        exit(-2);
      }
      memset(returnData-\>extObjs,0,sizeof(void*)*NEXT);
      setLocalData(returnData); /* must be set since used by constructors*/
      <preExp>
      <ctorCalls>
      <aliases of (var1, var2): '<cref(var1)> = <cref(var2)>;' "\n">
    }
    return returnData;
  }
  >>

functionDeInitializeDataStruc(ExtObjInfo extObjInfo) ::=
match extObjInfo
case EXTOBJINFO then
  <<
  void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
  {
    if(!data)
      return;
  
    if(flags & STATES && data-\>states) {
      free(data-\>states);
      data-\>states = 0;
    }
  
    if(flags & STATESDERIVATIVES && data-\>statesDerivatives) {
      free(data-\>statesDerivatives);
      data-\>statesDerivatives = 0;
    }
  
    if(flags & ALGEBRAICS && data-\>algebraics) {
      free(data-\>algebraics);
      data-\>algebraics = 0;
    }
  
    if(flags & PARAMETERS && data-\>parameters) {
      free(data-\>parameters);
      data-\>parameters = 0;
    }
  
    if(flags & OUTPUTVARS && data-\>inputVars) {
      free(data-\>inputVars);
      data-\>inputVars = 0;
    }
  
    if(flags & INPUTVARS && data-\>outputVars) {
      free(data-\>outputVars);
      data-\>outputVars = 0;
    }
    
    if(flags & INITIALRESIDUALS && data-\>initialResiduals){
      free(data-\>initialResiduals);
      data-\>initialResiduals = 0;
    }
    if (flags & EXTERNALVARS && data-\>extObjs) {
      <destructors of (fnName, var): '<fnName>(<cref(var)>);' "\n">
      free(data-\>extObjs);
      data-\>extObjs = 0;
    }
  }
  >>

functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations,
                  list<DAE.Statement> algorithmAndEquationAsserts) ::=
  # varDecls = "" /*BUFD*/
  # nonStateContPart = (nonStateContEquations of eq:
      equation_(eq, contextSimulationNonDescrete, varDecls /*BUFC*/)
    "\n")
  # algAndEqAssertsPart = (algorithmAndEquationAsserts of stmt:
      algStatement(stmt, contextSimulationNonDescrete, varDecls /*BUFC*/)
    "\n")
  # removedPart = (removedEquations of eq:
      equation_(eq, contextSimulationNonDescrete, varDecls /*BUFC*/)
    "\n")
  <<
  /* for continuous time variables */
  int functionDAE_output()
  {
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
    <nonStateContPart>
    <algAndEqAssertsPart>
    <removedPart>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
  # varDecls = "" /*BUFD*/
  # nonSateDiscPart = (nonStateDiscEquations of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  # removedPart = (removedEquations of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  <<
  /* for discrete time variables */
  int functionDAE_output2()
  {
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
    <nonSateDiscPart>
    <removedPart>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionInput(ModelInfo modelInfo) ::=
match modelInfo
case MODELINFO(vars=SIMVARS) then
  <<
  int input_function()
  {
    <vars.inputVars of SIMVAR:
      '<cref(name)> = localData-\>inputVars[<i0>];'
    "\n">
    return 0;
  }
  >>

functionOutput(ModelInfo modelInfo) ::=
match modelInfo
case MODELINFO(vars=SIMVARS) then
  <<
  int output_function()
  {
    <vars.outputVars of SIMVAR:
      'localData-\>outputVars[<i0>] = <cref(name)>;'
    "\n">
    return 0;
  }
  >>

functionDaeRes() ::=
  <<
  int functionDAE_res(double *t, double *x, double *xd, double *delta,
                      long int *ires, double *rpar, long int* ipar)
  {
    int i;
    double temp_xd[NX];
    double* statesBackup;
    double* statesDerivativesBackup;
    double timeBackup;
  
    statesBackup = localData-\>states;
    statesDerivativesBackup = localData-\>statesDerivatives;
    timeBackup = localData-\>timeValue;
    localData-\>states = x;
  
    for (i=0; i\<localData-\>nStates; i++) {
      temp_xd[i] = localData-\>statesDerivatives[i];
    }
  
    localData-\>statesDerivatives = temp_xd;
    localData-\>timeValue = *t;
  
    functionODE();
  
    /* get the difference between the temp_xd(=localData-\>statesDerivatives)
       and xd(=statesDerivativesBackup) */
    for (i=0; i \< localData-\>nStates; i++) {
      delta[i] = localData-\>statesDerivatives[i] - statesDerivativesBackup[i];
    }
  
    localData-\>states = statesBackup;
    localData-\>statesDerivatives = statesDerivativesBackup;
    localData-\>timeValue = timeBackup;
  
    if (modelErrorCode) {
      if (ires) {
        *ires = -1;
      }
      modelErrorCode =0;
    }
  
    return 0;
  }
  >>

functionZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
  # varDecls = "" /*BUFD*/
  # zeroCrossingsCode = zeroCrossingsTpl(zeroCrossings, varDecls /*BUFC*/)
  <<
  int function_zeroCrossing(long *neqm, double *t, double *x, long *ng,
                            double *gout, double *rpar, long* ipar)
  {
    double timeBackup;
    state mem_state;
  
    mem_state = get_memory_state();
  
    timeBackup = localData->timeValue;
    localData->timeValue = *t;
    <varDecls>
  
    functionODE();
    functionDAE_output();
  
    <zeroCrossingsCode>
  
    restore_memory_state(mem_state);
    localData->timeValue = timeBackup;
  
    return 0;
  }
  >>

functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave) ::=
  <<
  /* This function should only save in cases. The rest is done in
     function_updateDependents. */
  int handleZeroCrossing(long index)
  {
    state mem_state;
  
    mem_state = get_memory_state();
  
    switch(index) {
      <zeroCrossingsNeedSave of vars:
        <<
        case <i0>:
          <vars of SIMVAR: 'save(<cref(name)>);' "\n">
          break;
        >>
      "\n">
      default:
        break;
    }
  
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionUpdateDependents(list<SimEqSystem> allEquations,
                         list<HelpVarInfo> helpVarInfo) ::=
  # varDecls = "" /*BUFD*/
  # eqs = (allEquations of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  # hvars = (helpVarInfo of (hindex, exp, _):
      # preExp = "" /*BUFD*/
      # expPart = daeExp(exp, contextSimulationDescrete, preExp /*BUFC*/,
                         varDecls /*BUFC*/)
      '<preExp>localData->helpVars[<hindex>] = <expPart>;'
    "\n")
  <<
  int function_updateDependents()
  {
    state mem_state;
    <varDecls>
  
    inUpdate=initial()?0:1;
  
    mem_state = get_memory_state();
    <eqs>
    <hvars>
    restore_memory_state(mem_state);
  
    inUpdate=0;
  
    return 0;
  }
  >>

functionUpdateDepend(list<SimEqSystem> allEquationsPlusWhen) ::=
  # varDecls = "" /*BUFD*/
  # eqs = (allEquationsPlusWhen of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  <<
  int function_updateDepend()
  {
    state mem_state;
    <varDecls>
  
    inUpdate=initial()?0:1;
  
    mem_state = get_memory_state();
    <eqs>
    restore_memory_state(mem_state);
  
    inUpdate=0;
  
    return 0;
  }
  >>

functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
  # varDecls = "" /*BUFD*/
  # zeroCrossingsCode = zeroCrossingsTpl(zeroCrossings, varDecls /*BUFC*/)
  <<
  int function_onlyZeroCrossings(double *gout,double *t)
  {
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
    <zeroCrossingsCode>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionCheckForDiscreteChanges(list<ComponentRef> discreteModelVars) ::=
  <<
  int checkForDiscreteChanges()
  {
    int needToIterate = 0;
  
    <discreteModelVars of var:
      'if (change(<cref(var)>)) { needToIterate=1; }'
    "\n">
    
    return needToIterate;
  }
  >>

functionStoreDelayed(list<tuple<DAE.Exp, DAE.Exp>> delayedExps) ::=
  # varDecls = "" /*BUFD*/
  # storePart = (delayedExps of (id, e):
      # preExp = "" /*BUFD*/
      # idRes = daeExp(id, contextSimulationNonDescrete,
                       preExp /*BUFC*/, varDecls /*BUFC*/)
      # eRes = daeExp(e, contextSimulationNonDescrete,
                      preExp /*BUFC*/, varDecls /*BUFC*/)
      <<
      <preExp>
      storeDelayedExpression(<idRes>, <eRes>);
      >>
    )
  <<
  int function_storeDelayed()
  {
    state mem_state;
    <varDecls>

    mem_state = get_memory_state();
    <storePart>
    restore_memory_state(mem_state);

    return 0;
  }
  >>

functionWhen(list<SimWhenClause> whenClauses) ::=
  # varDecls = "" /*BUFD*/
  # cases = (whenClauses of SIM_WHEN_CLAUSE:
      <<
      case <i0>:
        <functionWhenCaseEquation(whenEq, varDecls /*BUFC*/)>
        <reinits of reinit:
          # preExp = "" /*BUFD*/
          # body = functionWhenReinitStatement(reinit, preExp /*BUFC*/,
                                               varDecls /*BUFC*/)
          '<preExp><\n><body>'
        "\n">
        break;<\n>
      >>
    )
  <<
  int function_when(int i)
  {
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
  
    switch(i) {
      <cases>
      default:
        break;
    }
  
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionWhenCaseEquation(Option<WhenEquation> when, Text varDecls /*BUFP*/) ::=
match when
case SOME(weq as WHEN_EQ) then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(weq.right, contextSimulationDescrete,
                     preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  save(<cref(weq.left)>);
  
  <preExp>
  <cref(weq.left)> = <expPart>;
  >>

functionWhenReinitStatement(ReinitStatement reinit, Text preExp /*BUFP*/,
                            Text varDecls /*BUFP*/) ::=
match reinit
case REINIT then
  # val = daeExp(value, contextSimulationDescrete,
                 preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <cref(stateVar)> = <val>;
  >>

functionOde(list<SimEqSystem> stateContEquations) ::=
  # varDecls = "" /*BUFD*/
  # stateContPart = (stateContEquations of eq:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")
  <<
  int functionODE()
  {
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
    <stateContPart>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionInitial(list<SimEqSystem> initialEquations) ::=
  # varDecls = "" /*BUFD*/
  # eqPart = (initialEquations of eq as SES_SIMPLE_ASSIGN:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")
  <<
  int initial_function()
  {
    <varDecls>
  
    <eqPart>
  
    <initialEquations of SES_SIMPLE_ASSIGN:
      'if (sim_verbose) { printf("Setting variable start value: %s(start=%f)\n", "<cref(componentRef)>", <cref(componentRef)>); }'
    "\n">
  
    return 0;
  }
  >>

functionInitialResidual(list<SimEqSystem> residualEquations) ::=
  # varDecls = "" /*BUFD*/
  # body = (residualEquations of SES_RESIDUAL:
      if exp is DAE.SCONST then
        'localData-\>initialResiduals[i++] = 0;'
      else
        # preExp = "" /*BUFD*/
        # expPart = daeExp(exp, contextOther, preExp /*BUFC*/,
                           varDecls /*BUFC*/)
        '<preExp>localData-\>initialResiduals[i++] = <expPart>;'
    "\n")
  <<
  int initial_residual()
  {
    int i = 0;
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
    <body>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

functionExtraResudials(list<SimEqSystem> allEquations) ::=
  (allEquations of eq as SES_NONLINEAR:
     # varDecls = "" /*BUFD*/
     # prebody = (eq.eqs of eq2 as SES_SIMPLE_ASSIGN:
         equation_(eq2, contextOther, varDecls /*BUFC*/)
       "\n")   
     # body = (eq.eqs of eq2 as SES_RESIDUAL:
         # preExp = "" /*BUFD*/
         # expPart = daeExp(eq2.exp, contextSimulationDescrete,
                            preExp /*BUFC*/, varDecls /*BUFC*/)
         '<preExp>res[<i0>] = <expPart>;'
       "\n")
     <<
     void residualFunc<index>(int *n, double* xloc, double* res, int* iflag)
     {
       state mem_state;
       <varDecls>
       mem_state = get_memory_state();
       <prebody>
       <body>
       restore_memory_state(mem_state);
     }
     >>
   "\n\n")

functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
  # varDecls = "" /*BUFD*/
  # body = (parameterEquations of eq as SES_SIMPLE_ASSIGN:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")
  # divbody = (parameterEquations of eq as SES_ALGORITHM:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")    
  <<
  int bound_parameters()
  {
    state mem_state;
    <varDecls>
  
    mem_state = get_memory_state();
    <body>
    <divbody>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>

// Is the -1 check really correct? It seems to work.
functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfo,
                                   list<ComponentRef> discreteModelVars) ::=
  <<
  int checkForDiscreteVarChanges()
  {
    int needToIterate = 0;
  
    <helpVarInfo of (hindex, exp, windex):
      if windex is not -1 then
        'if (edge(localData-\>helpVars[<hindex>])) AddEvent(<windex> + localData-\>nZeroCrossing);'
    "\n">
  
    <discreteModelVars of var:
      'if (change(<cref(var)>)) { needToIterate=1; }'
    "\n">
    
    for (long i = 0; i \< localData-\>nHelpVars; i++) {
      if (change(localData-\>helpVars[i])) {
        needToIterate=1;
      }
    }
  
    return needToIterate;
  }
  >>

zeroCrossingsTpl(list<ZeroCrossing> zeroCrossings, Text varDecls /*BUFP*/) ::=
  (zeroCrossings of ZERO_CROSSING:
    zeroCrossingTpl(i0, relation_, varDecls /*BUFC*/)
  "\n")

zeroCrossingTpl(Integer index, Exp relation, Text varDecls /*BUFP*/) ::=
  match relation
  case RELATION then
    # preExp = "" /*BUFD*/
    # e1 = daeExp(exp1, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    # op = zeroCrossingOpFunc(operator)
    # e2 = daeExp(exp2, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <preExp>
    ZEROCROSSING(<index>, <op>(<e1>, <e2>));
    >>
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = "" /*BUFD*/
    # e1 = daeExp(start, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    # e2 = daeExp(interval, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <preExp>
    ZEROCROSSING(<index>, Sample(*t, <e1>, <e2>));
    >>
  case _ then
    <<
    ZERO CROSSING ERROR
    >>

zeroCrossingOpFunc(Operator op) ::=
  match op
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"

// This template should not be used for a SES_RESIDUAL. Residual equations
// are handled differently.
equation_(SimEqSystem eq, Context context, Text varDecls /*BUFP*/) ::=
  match eq
  case e as SES_SIMPLE_ASSIGN
    then equationSimpleAssign(e, context, varDecls /*BUFC*/)
  case e as SES_ARRAY_CALL_ASSIGN
    then equationArrayCallAssign(e, context, varDecls /*BUFC*/)
  case e as SES_ALGORITHM
    then equationAlgorithm(e, context, varDecls /*BUFC*/)
  case e as SES_LINEAR
    then equationLinear(e, context, varDecls /*BUFC*/)
  case e as SES_MIXED
    then equationMixed(e, context, varDecls /*BUFC*/)
  case e as SES_NONLINEAR
    then equationNonlinear(e, context, varDecls /*BUFC*/)
  case e as SES_WHEN
    then equationWhen(e, context, varDecls /*BUFC*/)
  case _
    then "NOT IMPLEMENTED EQUATION"

equationSimpleAssign(SimEqSystem eq, Context context,
                     Text varDecls /*BUFP*/) ::=
match eq
case SES_SIMPLE_ASSIGN then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  <cref(componentRef)> = <expPart>;
  >>

equationArrayCallAssign(SimEqSystem eq, Context context,
                        Text varDecls /*BUFP*/) ::=
match eq
case SES_ARRAY_CALL_ASSIGN then // cref_array = call(...)
  # preExp = "" /*BUFD*/
  # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  copy_real_array_data_mem(&<expPart>, &<cref(componentRef)>);
  >>

equationAlgorithm(SimEqSystem eq, Context context, Text varDecls /*BUFP*/) ::=
match eq
case SES_ALGORITHM then
  (statements of stmt:
    algStatement(stmt, context, varDecls /*BUFC*/)
  "\n") 

equationLinear(SimEqSystem eq, Context context, Text varDecls /*BUFP*/) ::=
match eq
case SES_LINEAR then
  # uid = System.tmpTick()
  # size = listLength(vars)
  # aname = 'A<uid>'
  # bname = 'b<uid>'
  # mixedPostfix = if partOfMixed then "_mixed" else ""
  <<
  declare_matrix(<aname>, <size>, <size>);
  declare_vector(<bname>, <size>);
  <simJac of (row, col, eq as SES_RESIDUAL):
     # preExp = "" /*BUFD*/
     # expPart = daeExp(eq.exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
     '<preExp>set_matrix_elt(<aname>, <row>, <col>, <size>, <expPart>);'
  "\n">
  <beqs of exp:
     # preExp = "" /*BUFD*/
     # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
     '<preExp>set_vector_elt(<bname>, <i0>, <expPart>);'
  "\n">
  solve_linear_equation_system<mixedPostfix>(<aname>, <bname>, <size>, <uid>);
  <vars of SIMVAR: '<cref(name)> = get_vector_elt(<bname>, <i0>);' "\n">
  >>

equationMixed(SimEqSystem eq, Context context, Text varDecls /*BUFP*/) ::=
match eq
case SES_MIXED then
  # contEqs = equation_(cont, context, varDecls /*BUFC*/)
  # numDiscVarsStr = listLength(discVars) 
  # valuesLenStr = listLength(values)
  # preDisc = "" /*BUFD*/
  # discLoc2 = (discEqs of SES_SIMPLE_ASSIGN:
      # expPart = daeExp(exp, context, preDisc /*BUFC*/, varDecls /*BUFC*/)
      <<
      <cref(componentRef)> = <expPart>;
      discrete_loc2[<i0>] = <cref(componentRef)>;
      >>
    "\n")
  <<
  mixed_equation_system(<numDiscVarsStr>);
  double values[<valuesLenStr>] = {<values of val: '<val>' ", ">};
  int value_dims[<numDiscVarsStr>] = {<value_dims of dim: '<dim>' ", ">};
  <discVars of var as SIMVAR: 'discrete_loc[<i0>] = <cref(var.name)>;' "\n">
  {
    <contEqs>
  }
  <preDisc>
  <discLoc2>
  {
    double *loc_ptrs[<numDiscVarsStr>] = {<discVars of SIMVAR: '&<cref(name)>' ", ">};
    check_discrete_values(<numDiscVarsStr>, <valuesLenStr>);
  }
  mixed_equation_system_end(<numDiscVarsStr>);
  >>

equationNonlinear(SimEqSystem eq, Context context, Text varDecls /*BUFP*/) ::=
match eq
case SES_NONLINEAR then
  # size = listLength(crefs)
  <<
  start_nonlinear_system(<size>);
  <crefs of name:
    <<
    nls_x[<i0>] = extraPolate(<cref(name)>);
    nls_xold[<i0>] = old(&<cref(name)>);
    >>
  "\n">
  solve_nonlinear_system(residualFunc<index>, <index>);
  <crefs of name: '<cref(name)> = nls_x[<i0>];' "\n">
  end_nonlinear_system();
  >>

equationWhen(SimEqSystem eq, Context context, Text varDecls /*BUFP*/) ::=
match eq
case SES_WHEN then
  # preExp = "" /*BUFD*/
  # helpInits = "" /*BUFD*/
  # helpIf = (conditions of (e, hidx):
      # helpInit = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
      # helpInits += 'localData-\>helpVars[<hidx>] = <helpInit>;'
      'edge(localData-\>helpVars[<hidx>])'
    " || ")
  # preExp2 = "" /*BUFD*/
  # exp = daeExp(right, context, preExp2 /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  <helpInits>
  if (<helpIf>) {
    <preExp2>
    <cref(left)> = <exp>;
  } else {
    <cref(left)> = pre(<cref(left)>);
  }
  >>

simulationFunctionsFile(list<Function> functions) ::=
  <<
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  /* Header */
  <externalFunctionIncludes(functions)>
  <functionHeaders(functions)>
  /* End Header */
  
  /* Body */
  <functionBodies(functions)>
  /* End Body */
  
  #ifdef __cplusplus
  }
  #endif
  >>

simulationMakefile(SimCode simCode) ::=
match simCode
case SIMCODE(modelInfo=MODELINFO, makefileParams=MAKEFILE_PARAMS) then
  # dirExtra = if modelInfo.directory then "-L\"<modelInfo.directory>\"" else ""
  # libsStr = (makefileParams.libs of lib: lib " ")
  # libsPos1 = if dirExtra then "" else libsStr
  # libsPos2 = if dirExtra then libsStr else ""
  <<
  # Makefile generated by OpenModelica
  
  CC=<makefileParams.ccompiler>
  CXX=<makefileParams.cxxcompiler>
  LINK=<makefileParams.linker>
  EXEEXT=<makefileParams.exeext>
  DLLEXT=<makefileParams.dllext>
  CFLAGS= -I"<makefileParams.omhome>/include" <makefileParams.cflags>
  LDFLAGS= -L"<makefileParams.omhome>/lib" <makefileParams.ldflags>
  
  .PHONY: <modelInfo.name>
  <modelInfo.name>: <modelInfo.name>.cpp
  <\t> $(CXX) $(CFLAGS) -I. -o <modelInfo.name>$(EXEEXT) <modelInfo.name>.cpp <dirExtra> <libsPos1> -lsim $(LDFLAGS) -lf2c ${SENDDATALIBS} <libsPos2>
  >>

functionsFile(list<Function> functions,
              list<RecordDeclaration> extraRecordDecls) ::=
  <<
  #include "modelica.h"
  #include \<stdio.h\>
  #include \<stdlib.h\>
  #include \<errno.h\>
  
  #if defined(_MSC_VER)
    #define DLLExport   __declspec( dllexport )
  #else
    #define DLLExport /* nothing */
  #endif
  
  #if !defined(MODELICA_ASSERT)
    #define MODELICA_ASSERT(cond,msg) { if (!(cond)) fprintf(stderr,"Modelica Assert: %s!\n", msg); }
  #endif
  #if !defined(MODELICA_TERMINATE)
    #define MODELICA_TERMINATE(msg) { fprintf(stderr,"Modelica Terminate: %s!\n", msg); fflush(stderr); }
  #endif
  
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  /* Header */
  <externalFunctionIncludes(functions)>
  <functionHeaders(functions)>
  <extraRecordDecls of rd: recordDeclaration(rd) \n>
  /* End Header */
  
  /* Body */
  <functionBodies(functions)>
  /* End Body */
  
  #ifdef __cplusplus
  }
  #endif
  >>

functionsMakefile(FunctionCode fnCode) ::=
match fnCode
case FUNCTIONCODE(makefileParams=MAKEFILE_PARAMS) then
  # libsStr = (makefileParams.libs of lib: lib " ")
  <<
  # Makefile generated by OpenModelica
  
  CC=<makefileParams.ccompiler>
  CXX=<makefileParams.cxxcompiler>
  LINK=<makefileParams.linker>
  EXEEXT=<makefileParams.exeext>
  DLLEXT=<makefileParams.dllext>
  CFLAGS= -I"<makefileParams.omhome>/include" <makefileParams.cflags>
  LDFLAGS= -L"<makefileParams.omhome>/lib" <makefileParams.ldflags>
  
  .PHONY: <name>
  <name>: <name>.c
  <\t> $(LINK) $(CFLAGS) -o <name>$(DLLEXT) <name>.c <libsStr> $(LDFLAGS) -lm
  >>

cref(ComponentRef cref) ::=
  match cref
  case CREF_IDENT then '<ident>'
  case CREF_QUAL  then '<ident>.<cref(componentRef)>'
  case _          then "CREF_NOT_IDENT_OR_QUAL"

// Only works for CREF_IDENT.
crefWithSubscript(ComponentRef cref) ::=
  match cref
  case CREF_IDENT then '<ident><subscriptsTpl(subscriptLst)>'
  case _          then "CREF_NOT_IDENT"

subscriptsTpl(list<Subscript> subscripts) ::=
  match subscripts
  case {}         then ""
  case subscripts then '[<subscripts of s: subscriptTpl(s) ",">]'

// Only works for contstant integer indicies.
subscriptTpl(Subscript subscript) ::=
  match subscript
  case INDEX then (
    match exp
    case ICONST then integer
    case _      then "SUBSCRIPT_NOT_CONSTANT"
  )
  case _     then "SUBSCRIPT_NOT_CONSTANT"
 
dotPath(Path path) ::=
  match path
  case QUALIFIED      then '<name>.<dotPath(path)>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)

underscorePath(Path path) ::=
  match path
  case QUALIFIED then
    '<System.stringReplace(name, "_", "__")>_<underscorePath(path)>'
  case IDENT then
    System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then
    underscorePath(path)

externalFunctionIncludes(list<Function> functions) ::=
  <<
  #ifdef __cplusplus
  extern "C" {
  #endif
  <functions of EXTERNAL_FUNCTION:
    (includes of include: include "\n")
  "\n">
  #ifdef __cplusplus
  }
  #endif
  >>

functionHeaders(list<Function> functions) ::=
  (functions of fn:
    match fn
    case FUNCTION then
      <<
      <recordDecls of rd: recordDeclaration(rd) \n>
      <functionHeader(underscorePath(name), functionArguments, outVars)>
      >> 
    case EXTERNAL_FUNCTION then
      <<
      <recordDecls of rd: recordDeclaration(rd) \n>
      <functionHeader(underscorePath(name), funArgs, outVars)>
  
      <extFunDef(fn)>
      >> 
    case RECORD_CONSTRUCTOR then
      # fname = underscorePath(name)
      # funArgsStr = (funArgs of var as VARIABLE:
          '<varType(var)> <cref(name)>'
        ", ")
      <<
      <recordDecls of rd: recordDeclaration(rd) \n>
      #define <fname>_rettype_1 targ1
      typedef struct <fname>_rettype_s {
        struct <fname> targ1;
      } <fname>_rettype;
      
      DLLExport 
      <fname>_rettype _<fname>(<funArgsStr>);
      >> 
  "\n")

recordDeclaration(RecordDeclaration recDecl) ::=
  match recDecl
  case RECORD_DECL_FULL then
    <<
    struct <name> {
      <variables of var as VARIABLE: '<varType(var)> <cref(var.name)>;' "\n">
    };
    <recordDefinition(dotPath(defPath),
                      underscorePath(defPath),
                      (variables of VARIABLE: '"<cref(name)>"' ","))>
    >> 
  case RECORD_DECL_DEF then
    <<
    <recordDefinition(dotPath(path),
                      underscorePath(path),
                      (fieldNames of name: '"<name>"' ","))>
    >>

recordDefinition(String origName, String encName, String fieldNames) ::=
  <<
  const char* <encName>__desc__fields[] = {<fieldNames>};
  struct record_description <encName>__desc = {
    "<encName>", /* package_record__X */
    "<origName>", /* package.record_X */
    <encName>__desc__fields
  };
  >>

functionHeader(String fname, list<Variable> fargs, list<Variable> outVars) ::=
  # fargsStr = (fargs of var as VARIABLE: '<varType(var)> <cref(name)>' ", ")
  <<
  <outVars of VARIABLE: '#define <fname>_rettype_<i1> targ<i1>' \n>
  typedef struct <fname>_rettype_s 
  {
    <outVars of var as VARIABLE:
      # dimStr = if ty is ET_ARRAY then
          '[<arrayDimensions of dim: if dim is SOME(d) then d else ":" ", ">]'
      '<varType(var)> targ<i1>; /* <cref(name)><dimStr> */'
    "\n">
  } <fname>_rettype;
  
  DLLExport 
  int in_<fname>(type_description * inArgs, type_description * outVar);
  
  DLLExport 
  <fname>_rettype _<fname>(<fargsStr>);
  >>

extFunDef(Function fn) ::=
match fn
case EXTERNAL_FUNCTION then
  # fargsStr = (extArgs of arg: extFunDefArg(arg) ", ")
  <<
  extern <extReturnType(extReturn)> <extName>(<fargsStr>);
  >>

extReturnType(SimExtArg extArg) ::=
  match extArg
  case SIMEXTARG   then extType(type_)
  case SIMNOEXTARG then "void"

extType(ExpType type) ::=
  match type
  case ET_INT         then "int"
  case ET_REAL        then "double"
  case ET_STRING      then "const char*"
  case ET_BOOL        then "int"
  case ET_ARRAY       then extType(ty)
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ)
                      then "void *"
  case ET_COMPLEX(complexClassType=RECORD(path=rname))
                      then 'struct <underscorePath(rname)>'
  case ET_METAOPTION
  case ET_LIST
  case ET_METATUPLE
  case ET_UNIONTYPE
  case ET_POLYMORPHIC
  case ET_META_ARRAY
  case ET_BOXED       then "void*"
  case _              then "OTHER_EXT_TYPE"

// Assume that language is C for now.
extFunDefArg(SimExtArg extArg) ::=
  match extArg
  case SIMEXTARG(cref=c, isInput=ii, isArray=ia, type_=t) then
    # name = cref(c)
    # typeStr = if ii then
        if ia then
          if extType(t) is "const char*" then // For string arrays
            'const char* const *'
          else
            'const <extType(t)> *'
        else
          '<extType(t)>'
      else
        '<extType(t)>*'
    <<
    <typeStr> <name>
    >>
  case SIMEXTARGEXP then
    # typeStr = extType(type_)
    <<
    <typeStr>
    >>
  case SIMEXTARGSIZE(cref=c) then
    # name = cref(c)
    # eStr = daeExpToString(exp)
    <<
    size_t <name>_<eStr>
    >>

// This only works for constans (or else the name of a temporary variable is
// returned).
daeExpToString(Exp exp) ::=
  # preExp = "" /*BUFD*/
  # varDecls = "" /*BUFD*/
  daeExp(exp, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)

functionBodies(list<Function> functions) ::=
  (functions of fn: functionBody(fn) "\n")

functionBody(Function fn) ::=
  match fn
  case fn as FUNCTION           then functionBodyRegularFunction(fn)
  case fn as EXTERNAL_FUNCTION  then functionBodyExternalFunction(fn)
  case fn as RECORD_CONSTRUCTOR then functionBodyRecordConstructor(fn)

functionBodyRegularFunction(Function fn) ::=
match fn
case FUNCTION then
  # System.tmpTickReset(1)
  # fname = underscorePath(name)
  # retType = '<fname>_rettype'
  # varDecls = "" /*BUFD*/
  # varInits = "" /*BUFD*/
  # retVar = tempDecl(retType, varDecls /*BUFC*/)
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # _ = (variableDeclarations of var:
      varInit(var, "", i1, varDecls /*BUFC*/, varInits /*BUFC*/)
    )
  # bodyPart = (body of stmt : funStatement(stmt, varDecls /*BUFC*/) \n)
  # outVarInits = "" /*BUFD*/
  # outVarsStr = (outVars of var:
      varOutput(var, retVar, i1, varDecls /*BUFC*/, outVarInits /*BUFC*/)
    )
  <<
  <retType> _<fname>(<functionArguments of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>' ", ">)
  {
    <varDecls>
    <outVarInits>
    <stateVar> = get_memory_state();

    <varInits>

    <bodyPart>
    
    _return:
    <outVarsStr>
    restore_memory_state(<stateVar>);
    return <retVar>;
  }

  int in_<fname>(type_description * inArgs, type_description * outVar)
  {
    <functionArguments of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>;' "\n">
    <retType> out;
    <functionArguments of arg as VARIABLE: readInVar(arg) "\n">
    out = _<fname>(<functionArguments of VARIABLE: cref(name) ", ">);
    <if outVars then (outVars of var as VARIABLE: writeOutVar(var, i1) "\n") else "write_noretcall(outVar);">
    return 0;
  }
  >>

functionBodyExternalFunction(Function fn) ::=
match fn
case EXTERNAL_FUNCTION then
  # System.tmpTickReset(1)
  # fname = underscorePath(name)
  # retType = '<fname>_rettype'
  # preExp = "" /*BUFD*/
  # varDecls = "" /*BUFD*/
  # outputAlloc = "" /*BUFD*/
  # callPart = extFunCall(fn, preExp /*BUFC*/, varDecls /*BUFC*/)
  # _ = (outVars of var:
      varInit(var, "out", i1, varDecls /*BUFC*/, outputAlloc /*BUFC*/)
    )
  <<
  int in_<fname>(type_description * inArgs, type_description * outVar)
  {
    <funArgs of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>;' "\n">
    <retType> out;
    <funArgs of arg as VARIABLE: readInVar(arg) "\n">
    out = _<fname>(<funArgs of VARIABLE: cref(name) ", ">);
    <outVars of var as VARIABLE: writeOutVar(var, i1) "\n">
    return 0;
  }

  <retType> _<fname>(<funArgs of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>' ", ">)
  {
    <varDecls>
    <retType> out;
    <outputAlloc>
    <preExp>
    <callPart>
    return out;
  }
  >>

functionBodyRecordConstructor(Function fn) ::=
match fn
case RECORD_CONSTRUCTOR then
  # System.tmpTickReset(1)
  # varDecls = "" /*BUFD*/
  # fname = underscorePath(name)
  # retType = '<fname>_rettype'
  # retVar = tempDecl(retType, varDecls /*BUFC*/)
  # structType = 'struct <fname>'
  # structVar = tempDecl(structType, varDecls /*BUFC*/)
  <<
  <retType> _<fname>(<funArgs of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>' ", ">)
  {
    <varDecls>
    <funArgs of VARIABLE: '<structVar>.<cref(name)> = <cref(name)>;' "\n">
    <retVar>.targ1 = <structVar>;
    return <retVar>;
  }
  >>

readInVar(Variable var) ::=
  match var
  case VARIABLE(name=cr, ty=ET_COMPLEX(complexClassType=RECORD)) then
    <<
    if (read_modelica_record(&inArgs, <readInVarRecordMembers(ty, cref(cr))>)) return 1;
    >>
  case VARIABLE then
    <<
    if (read_<expTypeArrayIf(ty)>(&inArgs, &<cref(name)>)) return 1;
    >>

readInVarRecordMembers(ExpType type, String prefix) ::=
match type
case ET_COMPLEX(varLst=vl) then
  (vl of subvar as COMPLEX_VAR:
    if tp is ET_COMPLEX then
      # newPrefix = '<prefix>.<subvar.name>'
      readInVarRecordMembers(tp, newPrefix)
    else
      '&(<prefix>.<subvar.name>)'
  ", ")

writeOutVar(Variable var, Integer index) ::=
  match var
  case VARIABLE(ty=ET_COMPLEX(complexClassType=RECORD)) then
    <<
    write_modelica_record(outVar, <writeOutVarRecordMembers(ty, index, "")>);
    >>
  case VARIABLE then
    <<
    write_<varType(var)>(outVar, &out.targ<index>);
    >>

writeOutVarRecordMembers(ExpType type, Integer index, String prefix) ::=
match type
case ET_COMPLEX(varLst=vl, name=n) then
  # basename = underscorePath(n)
  # args = (vl of subvar as COMPLEX_VAR:
      if tp is ET_COMPLEX then
        # newPrefix = '<prefix>.<subvar.name>'
        '<expTypeRW(tp)>, <writeOutVarRecordMembers(tp, index, newPrefix)>'
      else
        '<expTypeRW(tp)>, &(out.targ<index><prefix>.<subvar.name>)'
    ", ")
  <<
  &<basename>__desc<if args then ', <args>'>, TYPE_DESC_NONE
  >>

// Does not return anything: just appends declarations to buffers.
varInit(Variable var, String outStruct, Integer i, Text varDecls /*BUFP*/,
        Text varInits /*BUFP*/) ::=
match var
case var as VARIABLE then
  # varDecls += if outStruct then "" else '<varType(var)> <cref(var.name)>;<\n>'
  # varName = if outStruct then '<outStruct>.targ<i>' else '<cref(var.name)>'
  # instDimsInit = (instDims of exp:
      daeExp(exp, contextOther, varInits /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  if instDims then
    # varInits += 'alloc_<expTypeShort(var.ty)>_array(&<varName>, <listLength(instDims)>, <instDimsInit>);<\n>'
    ()
  else
    ()

varOutput(Variable var, String dest, Integer i, Text varDecls /*BUFP*/,
          Text varInits /*BUFP*/) ::=
match var
case var as VARIABLE then
  # instDimsInit = (instDims of exp:
      daeExp(exp, contextOther, varInits /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  if instDims then
    # varInits += 'alloc_<expTypeShort(var.ty)>_array(&<dest>.targ<i>, <listLength(instDims)>, <instDimsInit>);<\n>'
    <<
    copy_<expTypeShort(var.ty)>_array_data(&<cref(var.name)>, &<dest>.targ<i>);
    >>
  else
    <<
    <dest>.targ<i> = <cref(var.name)>;
    >>

extFunCall(Function fun, Text preExp /*BUFP*/, Text varDecls /*BUFP*/) ::=
match fun
case EXTERNAL_FUNCTION then
  # fname = underscorePath(name)
  # args = (extArgs of arg:
      extArg(arg, preExp /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  # returnAssign = if extReturn is SIMEXTARG(cref=c) then
      '<cref(c)>_ext = '
    else
      ""
  <<
  <extArgs of arg: extFunCallVardecl(arg, varDecls /*BUFC*/) "\n">
  <if extReturn is SIMEXTARG then extFunCallVardecl(extReturn, varDecls /*BUFC*/)>
  <returnAssign><extName>(<args>);
  <extArgs of arg: extFunCallVarcopy(arg) "\n">
  <if extReturn is SIMEXTARG then extFunCallVarcopy(extReturn)>
  >>

extFunCallVardecl(SimExtArg arg, Text varDecls /*BUFP*/) ::=
  match arg
  case SIMEXTARG(isInput=true, isArray=false, type_=ty, cref=c) then
    if ty is ET_STRING then
      ""
    else
      # varDecls += '<extType(ty)> <cref(c)>_ext;<\n>'
      <<
      <cref(c)>_ext = (<extType(ty)>)<cref(c)>;
      >>
  case SIMEXTARG(outputIndex=oi, isArray=false, type_=ty, cref=c) then
    if oi is 0 then
      ""
    else
      # varDecls += '<extType(ty)> <cref(c)>_ext;<\n>'
      ""

extFunCallVarcopy(SimExtArg arg) ::=
match arg
case SIMEXTARG(outputIndex=oi, isArray=false, type_=ty, cref=c) then
  if oi is 0 then
    ""
  else
    <<
    out.targ<oi> = (<expTypeModelica(ty)>)<cref(c)>_ext;
    >>

extArg(SimExtArg extArg, Text preExp /*BUFP*/, Text varDecls /*BUFP*/) ::=
  match extArg
  case SIMEXTARG(cref=c, outputIndex=oi, isArray=true, type_=t) then
    # name = if oi then 'out.targ<oi>' else cref(c)
    # shortTypeStr = expTypeShort(t)
    'data_of_<shortTypeStr>_array(&(<name>))'
  case SIMEXTARG(cref=c, isInput=ii, outputIndex=oi, type_=t) then
    # prefix = if oi then "&" else ""
    # suffix = if oi then "_ext"
               else if t is ET_STRING then ""
               else "_ext"
    '<prefix><cref(c)><suffix>'
  case SIMEXTARGEXP then
    daeExp(exp, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
  case SIMEXTARGSIZE(cref=c) then
    # typeStr = expTypeShort(type_)
    # name = if outputIndex then 'out.targ<outputIndex>' else cref(c)
    # dim = daeExp(exp, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    'size_of_dimension_<typeStr>_array(<name>, <dim>)'

funBody(list<Statement> body) ::=
  # varDecls = "" /*BUFD*/
  # bodyPart = (body of stmt: funStatement(stmt, varDecls /*BUFC*/) "\n")
  <<
  <varDecls>
  <bodyPart>
  >>

funStatement(Statement stmt, Text varDecls /*BUFP*/) ::=
  match stmt
  case ALGORITHM then
    (statementLst of stmt:
      algStatement(stmt, contextOther, varDecls /*BUFC*/)
    "\n") 
  case _ then
    "NOT IMPLEMENTED FUN STATEMENT"

algStatement(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
  match stmt
  case s as STMT_ASSIGN       then algStmtAssign(s, context, varDecls /*BUFC*/)
  case s as STMT_ASSIGN_ARR   then algStmtAssignArr(s, context, varDecls /*BUFC*/)
  case s as STMT_TUPLE_ASSIGN then algStmtTupleAssign(s, context, varDecls /*BUFC*/)
  case s as STMT_IF           then algStmtIf(s, context, varDecls /*BUFC*/)
  case s as STMT_FOR          then algStmtFor(s, context, varDecls /*BUFC*/)
  case s as STMT_WHILE        then algStmtWhile(s, context, varDecls /*BUFC*/)
  case s as STMT_ASSERT       then algStmtAssert(s, context, varDecls /*BUFC*/)
  case s as STMT_WHEN         then algStmtWhen(s, context, varDecls /*BUFC*/)
  case s as STMT_MATCHCASES   then algStmtMatchcases(s, context, varDecls /*BUFC*/)
  case s as STMT_BREAK        then 'break;<\n>'
  case s as STMT_TRY          then algStmtTry(s, context, varDecls /*BUFC*/)
  case s as STMT_CATCH        then algStmtCatch(s, context, varDecls /*BUFC*/)
  case s as STMT_THROW        then 'throw 1;<\n>'
  case s as STMT_RETURN       then 'goto _return;<\n>'
  case s as STMT_NORETCALL    then algStmtNoretcall(s, context, varDecls /*BUFC*/)
  case _                      then "NOT IMPLEMENTED ALG STATEMENT"

algStmtAssign(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
  match stmt
  case STMT_ASSIGN(exp1=CREF(componentRef=WILD), exp=e) then
    # preExp = ""  /*BUFD*/
    # expPart = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <preExp>
    >>
  case STMT_ASSIGN(exp1=CREF) then
    # preExp = "" /*BUFD*/
    # varPart = scalarLhsCref(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <preExp>
    <varPart> = <expPart>;
    >>
  case STMT_ASSIGN then
    # preExp = "" /*BUFD*/
    # expPart1 = daeExp(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # expPart2 = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <preExp>
    <expPart1> = <expPart2>;
    >>

algStmtAssignArr(DAE.Statement stmt, Context context,
                 Text varDecls /*BUFP*/) ::=
match stmt
case STMT_ASSIGN_ARR(exp=e, componentRef=cref, type_=t) then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # ispec = indexSpecFromCref(cref, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  if ispec then
    <<
    <preExp>
    indexed_assign_<expTypeArray(t)>(&<expPart>, &<cref(cref)>, &<ispec>);
    >>
  else
    <<
    <preExp>
    copy_<expTypeArray(t)>_data(&<expPart>, &<cref(cref)>);
    >>

algStmtTupleAssign(DAE.Statement stmt, Context context,
                   Text varDecls /*BUFP*/) ::=
match stmt
case STMT_TUPLE_ASSIGN(exp=CALL) then
  # preExp = "" /*BUFD*/
  # retStruct = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  <expExpLst of cr as CREF:
    # lhsStr = scalarLhsCref(cr, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    '<lhsStr> = <retStruct>.targ<i1>;'
  "\n">
  >>

algStmtIf(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_IF then
  # preExp = "" /*BUFD*/
  # condExp = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  if (<condExp>) {
    <statementLst of stmt: algStatement(stmt, context, varDecls /*BUFC*/) "\n">
  }
  <elseExpr(else_, context, varDecls /*BUFC*/)>
  >>

algStmtFor(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
  match stmt
  case s as STMT_FOR(exp=rng as RANGE) then
    algStmtForRange(s, context, varDecls /*BUFC*/)
  case s as STMT_FOR then
    algStmtForGeneric(s, context, varDecls /*BUFC*/)

algStmtForRange(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_FOR(exp=rng as RANGE) then
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
  # identType = expType(type_, boolean)
  # r1 = tempDecl(identType, varDecls /*BUFC*/)
  # r2 = tempDecl(identType, varDecls /*BUFC*/)
  # r3 = tempDecl(identType, varDecls /*BUFC*/)
  # preExp = "" /*BUFD*/
  # er1 = daeExp(rng.exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # er2 = if rng.expOption is SOME(eo) then
      daeExp(eo, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    else
      "(1)"
  # er3 = daeExp(rng.range, context, preExp /*BUFC*/, varDecls /*BUFC*/) 
  <<
  <preExp>
  <r1> = <er1>; <r2> = <er2>; <r3> = <er3>;
  {
  <identType> <ident>;

    for (<ident> = <r1>; in_range_<expTypeShort(type_)>(<ident>, <r1>, <r3>); <ident> += <r2>) {
      <stateVar> = get_memory_state();
      <statementLst of stmt: algStatement(stmt, context, varDecls /*BUFC*/) "\n">
      restore_memory_state(<stateVar>);
    }
  } /*end for*/
  >>

algStmtForGeneric(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_FOR then
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # arrayType = expTypeArray(type_)
  # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
  # tvar = tempDecl("int", varDecls /*BUFC*/)
  # identType = expType(type_, boolean)
  # ivar = tempDecl(identType, varDecls /*BUFC*/)
  # preExp = "" /*BUFD*/
  # evar = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # statements = (statementLst of stmt:
      algStatement(stmt, context, varDecls /*BUFC*/)
    "\n")
  # id = '<ident>'
  # stmtStuff = if boolean then
      'simple_index_alloc_<identType>1(&<evar>, <tvar>, &<ivar>);'
    else
      '<id> = *(<arrayType>_element_addr1(&<evar>, 1, <tvar>));'
  <<
  <preExp>
  {
  <identType> <ident>;

    for (<tvar> = 1; <tvar> \<= size_of_dimension_<arrayType>(<evar>, 1); ++<tvar>) {
      <stateVar> = get_memory_state();
      <stmtStuff>
      <statements>
      restore_memory_state(<stateVar>);
    }
  } /* end for*/
  >>

algStmtWhile(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_WHILE then
  # preExp = "" /*BUFD*/
  # var = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  while (1) {
    <preExp>
    if (!<var>) break;
    <statementLst of stmt: algStatement(stmt, context, varDecls /*BUFC*/) "\n">
  }
  >>

algStmtAssert(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_ASSERT then
  # preExp = "" /*BUFD*/
  # condVar = daeExp(cond, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # msgVar = daeExp(msg, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  MODELICA_ASSERT(<condVar>, <msgVar>);
  >>

algStmtMatchcases(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_MATCHCASES then
  # loopVar = tempDecl("modelica_integer", varDecls /*BUFC*/)
  # doneVar = tempDecl("modelica_integer", varDecls /*BUFC*/)
  # numCases = listLength(caseStmt)
  <<
  <doneVar> = 0;
  for (<loopVar>=0; 0==<doneVar> && <loopVar>\<<numCases>; <loopVar>++) {
    try {
      switch (<loopVar>) {
        <caseStmt of e:
          # preExp = "" /*BUFD*/
          // the exp always seems to be a valueblock whose result should not be
          // used
          # _ = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
          <<
          case <i0>: {
            <preExp>
            <doneVar> = 1;
            break;
          };
          >>
        "\n">
      } /* end matchcontinue switch */
    } catch (int i) {
    }
  } /* end matchcontinue for */
  if (0 == <doneVar>) throw 1; /* Didn't end in a valid state */
  >>

algStmtTry(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_TRY then
  # body = (tryBody of stmt:
      algStatement(stmt, context, varDecls /*BUFC*/)
    "\n")
  <<
  try {
    <body>
  }
  >>

algStmtCatch(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_CATCH then
  # body = (catchBody of stmt:
      algStatement(stmt, context, varDecls /*BUFC*/)
    "\n")
  <<
  catch (int i) {
    <body>
  }
  >>

algStmtNoretcall(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/) ::=
match stmt
case STMT_NORETCALL then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <preExp>
  <expPart>;
  >>

algStmtWhen(DAE.Statement when, Context context, Text varDecls /*BUFP*/) ::=
match context
case SIMULATION(genDiscrete=true) then
  match when
  case STMT_WHEN then
    # preIf = algStatementWhenPre(when, varDecls /*BUFC*/)
    # statements = (statementLst of stmt:
        algStatement(stmt, context, varDecls /*BUFC*/)
      "\n")
    # else = algStatementWhenElse(elseWhen, varDecls /*BUFC*/)
    <<
    <preIf>
    if (<helpVarIndices of idx: 'edge(localData-\>helpVars[<idx>])' " || ">) {
      <statements>
    }
    <else>
    >>

algStatementWhenPre(DAE.Statement stmt, Text varDecls /*BUFP*/) ::=
  match stmt
  case STMT_WHEN(exp=ARRAY(array=el)) then
    # restPre = if elseWhen is SOME(ew) then
        algStatementWhenPre(ew, varDecls /*BUFC*/)
      else
        ""
    # preExp = "" /*BUFD*/
    # assignments = algStatementWhenPreAssigns(el, helpVarIndices,
                                               preExp /*BUFC*/,
                                               varDecls /*BUFC*/)
    <<
    <preExp>
    <assignments>
    <restPre>
    >>
  case when as STMT_WHEN then
    match helpVarIndices
    case {i} then
      # restPre = if when.elseWhen is SOME(ew) then
          algStatementWhenPre(ew, varDecls /*BUFC*/)
        else
          ""
      # preExp = "" /*BUFD*/
      # res = daeExp(when.exp, contextSimulationDescrete,
                     preExp /*BUFC*/, varDecls /*BUFC*/)
      <<
      <preExp>
      localData-\>helpVars[<i>] = <res>;
      <restPre>
      >>

algStatementWhenElse(Option<DAE.Statement> stmt, Text varDecls /*BUFP*/) ::=
match stmt
case SOME(when as STMT_WHEN) then
  # statements = (when.statementLst of stmt:
      algStatement(stmt, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  # else = algStatementWhenElse(when.elseWhen, varDecls /*BUFC*/)
  # elseCondStr = (when.helpVarIndices of idx:
      'edge(localData-\>helpVars[<idx>])'
    " || ")
  <<
  else if (<elseCondStr>) {
    <statements>
  }
  <else>
  >>

// The lists exps and ints should be of the same length. Iterating over two
// lists like this is not so well supported in Susan, so it looks a bit ugly.
algStatementWhenPreAssigns(list<Exp> exps, list<Integer> ints,
                           Text preExp /*BUFP*/, Text varDecls /*BUFP*/) ::=
  match exps
  case {} then ""
  case (firstExp :: restExps) then
    match ints
    case (firstInt :: restInts) then
      # rest = algStatementWhenPreAssigns(restExps, restInts,
                                          preExp /*BUFC*/, varDecls /*BUFC*/)
      # firstExpPart = daeExp(firstExp, contextSimulationDescrete,
                              preExp /*BUFC*/, varDecls /*BUFC*/)
      <<
      localData-\>helpVars[<firstInt>] = <firstExpPart>;
      <rest>
      >>

// Currently works only for CREF_IDENT.
indexSpecFromCref(ComponentRef cref, Context context, Text preExp /*BUFP*/,
                  Text varDecls /*BUFP*/) ::=
match cref
case CREF_IDENT(subscriptLst=subs as (_ :: _)) then
  daeExpCrefRhsIndexSpec(subs, context, preExp /*BUFC*/, varDecls /*BUFC*/)

elseExpr(DAE.Else else_, Context context, Text varDecls /*BUFP*/) ::= 
  match else_
  case NOELSE then
    ()
  case ELSEIF then
    # preExp = "" /*BUFD*/
    # condExp = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    else {
      <preExp>
      if (<condExp>) {
        <statementLst of stmt:
          algStatement(stmt, context, varDecls /*BUFC*/)
        "\n">
      }
      <elseExpr(else_, context, varDecls /*BUFC*/)>
    }
    >>
  case ELSE then
    <<
    else {
      <statementLst of stmt:
        algStatement(stmt, context, varDecls /*BUFC*/)
      "\n">
    }
    >>

scalarLhsCref(Exp cref, Context context, Text preExp /*BUFP*/,
              Text varDecls /*BUFP*/) ::=
  match cref
  case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
    if crefNoSub(cref.componentRef) then
      '<cref(cref.componentRef)>'
    else
      daeExpCrefRhs(cref, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case cref as CREF(componentRef=CREF_QUAL(subscriptLst=subs)) then
    '<cref(cref.componentRef)>'
  case _ then
    "ONLY IDENT SUPPORTED"

rhsCref(ComponentRef cref, ExpType ty) ::=
  match cref
  case CREF_IDENT then '<rhsCrefType(ty)><ident>'
  case CREF_QUAL  then '<rhsCrefType(ty)><ident>.<rhsCref(componentRef,ty)>'
  case _          then "rhsCref:ERROR"

rhsCrefType(ExpType type) ::=
  match type
  case ET_INT then "(modelica_integer)"
  case _      then ""
  
daeExp(Exp exp, Context context, Text preExp /*BUFP*/,
       Text varDecls /*BUFP*/) ::=
  match exp
  case e as ICONST         then integer
  case e as RCONST         then real
  case e as SCONST         then daeExpSconst(string, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as BCONST         then if bool then "(1)" else "(0)"
  case e as CREF           then daeExpCrefRhs(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as BINARY         then daeExpBinary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as UNARY          then daeExpUnary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as LBINARY        then daeExpLbinary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as LUNARY         then daeExpLunary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as RELATION       then daeExpRelation(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as IFEXP          then daeExpIf(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as CALL           then daeExpCall(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as ARRAY          then daeExpArray(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as MATRIX         then daeExpMatrix(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as CAST           then daeExpCast(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as ASUB           then daeExpAsub(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as SIZE           then daeExpSize(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as REDUCTION      then daeExpReduction(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as VALUEBLOCK     then daeExpValueblock(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as LIST           then daeExpList(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as CONS           then daeExpCons(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as META_TUPLE     then daeExpMetaTuple(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as META_OPTION    then daeExpMetaOption(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as METARECORDCALL then daeExpMetarecordcall(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case _                   then "UNKNOWN_EXP"

daeExpSconst(String string, Text preExp /*BUFP*/, Text varDecls /*BUFP*/) ::=
  # strVar = tempDecl("modelica_string", varDecls /*BUFC*/)
  # escapedStr = Util.escapeModelicaStringToCString(string)
  # preExp += 'init_modelica_string(&<strVar>,"<escapedStr>");<\n>'
  strVar  

daeExpCrefRhs(Exp exp, Context context, Text preExp /*BUFP*/,
              Text varDecls /*BUFP*/) ::=
  match exp
  case CREF(componentRef=cr, ty=ET_ENUMERATION) then
    getEnumIndexfromCref(cr)
  case cref as CREF(componentRef=cr, ty=ty) then
    # box = daeExpCrefRhsArrayBox(cref, context, preExp /*BUFC*/,
                                  varDecls /*BUFC*/)
    if box then
      box
    else if crefNoSub(cr) then
      # cast = if ty is ET_INT then "(modelica_integer)" else ""
      '<cast><cref(cr)>'
    else if crefSubIsScalar(cr) then
      // The array subscript results in a scalar
      # arrName = cref(cr)
      # arrayType = expTypeArray(ty)
      # dimsLenStr = listLength(crefSubs(cr))
      # dimsValuesStr = (crefSubs(cr) of INDEX:
          daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
        ", ")
      <<
      (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
      >>
    else
      // The array subscript denotes a slice
      # arrName = cref(cr)
      # arrayType = expTypeArray(ty)
      # tmp = tempDecl(arrayType, varDecls /*BUFC*/)
      # spec1 = daeExpCrefRhsIndexSpec(crefSubs(cr), context, preExp /*BUFC*/, varDecls /*BUFC*/)
      # preExp += 'index_alloc_<arrayType>(&<arrName>, &<spec1>, &<tmp>);<\n>'
      tmp

daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context,
                       Text preExp /*BUFP*/, Text varDecls /*BUFP*/) ::=
  # nridx_str = listLength(subs)
  # idx_str = (subs of sub:
      match sub
      case INDEX then
        # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
        <<
        (1), make_index_array(1, <expPart>), 'S'
        >>
      case WHOLEDIM then
        <<
        (1), (0), 'W'
        >>
      case SLICE then
        # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
        # tmp = tempDecl("modelica_integer", varDecls /*BUFC*/)
        # preExp += '<tmp> = size_of_dimension_integer_array(<expPart>, 1);<\n>'
        <<
        <tmp>, integer_array_make_index_array(&<expPart>), 'A'
        >>
    ", ")
  # tmp = tempDecl("index_spec_t", varDecls /*BUFC*/)
  # preExp += 'create_index_spec(&<tmp>, <nridx_str>, <idx_str>);<\n>'
  tmp

daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp /*BUFP*/,
                      Text varDecls /*BUFP*/) ::=
match exp
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = tempDecl(expTypeArray(aty), varDecls /*BUFC*/)
    # dimsLenStr = listLength(dims)
    # dimsValuesStr = (dims of dim as SOME(i): i ", ")
    # preExp += '<expTypeShort(aty)>_array_create(&<tmpArr>, &<cref(cref.componentRef)>, <dimsLenStr>, <dimsValuesStr>);<\n>'
    tmpArr

daeExpBinary(Exp exp, Context context, Text preExp /*BUFP*/,
             Text varDecls /*BUFP*/) ::=
match exp
case BINARY then
  # e1 = daeExp(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # e2 = daeExp(exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case ADD(ty = ET_STRING) then
    # tmpStr = tempDecl("modelica_string", varDecls /*BUFC*/)
    # preExp += 'cat_modelica_string(&<tmpStr>,&<e1>,&<e2>);<\n>'
    tmpStr
  case ADD then '(<e1> + <e2>)'
  case SUB then '(<e1> - <e2>)'
  case MUL then '(<e1> * <e2>)'
  case DIV then '(<e1> / <e2>)'
  case POW then 'pow((modelica_real)<e1>, (modelica_real)<e2>)'
  case ADD_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'add_alloc_<type>(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case SUB_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'sub_alloc_<type>(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case MUL_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'mul_alloc_<type>_scalar(&<e1>, <e2>, &<var>);<\n>'
    '<var>'
  case DIV_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'div_alloc_<type>_scalar(&<e1>, <e2>, &<var>);<\n>'
    '<var>'
  case MUL_MATRIX_PRODUCT then
    # typeShort = if ty is ET_ARRAY(ty=ET_INT) then "integer" else "real"
    # type = '<typeShort>_array'
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'mul_alloc_<typeShort>_matrix_product_smart(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case _ then "daeExpBinary:ERR"

daeExpUnary(Exp exp, Context context, Text preExp /*BUFP*/,
            Text varDecls /*BUFP*/) ::=
match exp
case UNARY then
  # e = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case UMINUS     then '(-<e>)'
  case UPLUS      then '(<e>)'
  case UMINUS_ARR(ty=ET_ARRAY(ty=ET_REAL, arrayDimensions={NONE})) then
    # preExp += 'usub_real_array(&<e>);<\n>'
    '<e>'
  case UMINUS_ARR then "unary minus for non-real arrays not implemented"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"

daeExpLbinary(Exp exp, Context context, Text preExp /*BUFP*/,
              Text varDecls /*BUFP*/) ::=
match exp
case LBINARY then
  # e1 = daeExp(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # e2 = daeExp(exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case AND then '(<e1> && <e2>)'
  case OR  then '(<e1> || <e2>)'
  case _   then "daeExpLbinary:ERR"

daeExpLunary(Exp exp, Context context, Text preExp /*BUFP*/,
             Text varDecls /*BUFP*/) ::=
match exp
case LUNARY then
  # e = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case NOT then '(!<e>)'

daeExpRelation(Exp exp, Context context, Text preExp /*BUFP*/,
               Text varDecls /*BUFP*/) ::=
match exp
case rel as RELATION then
  # simRel = daeExpRelationSim(rel, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  if simRel then
    simRel
  else
    # e1 = daeExp(rel.exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # e2 = daeExp(rel.exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    match rel.operator
    case LESS(ty = ET_BOOL)        then '(!<e1> && <e2>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)         then '(<e1> \< <e2>)'
    case LESS(ty = ET_REAL)        then '(<e1> \< <e2>)'
    case GREATER(ty = ET_BOOL)     then '(<e1> && !<e2>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)      then '(<e1> > <e2>)'
    case GREATER(ty = ET_REAL)     then '(<e1> > <e2>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<e1> || <e2>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)       then '(<e1> \<= <e2>)'
    case LESSEQ(ty = ET_REAL)      then '(<e1> \<= <e2>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<e1> || !<e2>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)    then '(<e1> >= <e2>)'
    case GREATEREQ(ty = ET_REAL)   then '(<e1> >= <e2>)'
    case EQUAL(ty = ET_BOOL)       then '((!<e1> && !<e2>) || (<e1> && <e2>))'
    case EQUAL(ty = ET_STRING)     then '(!strcmp(<e1>, <e2>))'
    case EQUAL(ty = ET_INT)        then '(<e1> == <e2>)'
    case EQUAL(ty = ET_REAL)       then '(<e1> == <e2>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<e1> && <e2>) || (<e1> && !<e2>))'
    case NEQUAL(ty = ET_STRING)    then '(strcmp(<e1>, <e2>))'
    case NEQUAL(ty = ET_INT)       then '(<e1> != <e2>)'
    case NEQUAL(ty = ET_REAL)      then '(<e1> != <e2>)'
    case _                         then "daeExpRelation:ERR"

daeExpRelationSim(Exp exp, Context context, Text preExp /*BUFP*/,
                  Text varDecls /*BUFP*/) ::=
match exp
case rel as RELATION then
  match context
  case SIMULATION then
    # e1 = daeExp(rel.exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # e2 = daeExp(rel.exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # res = tempDecl("modelica_boolean", varDecls /*BUFC*/)
    match rel.operator
    case LESS then
      # preExp += 'RELATIONLESS(<res>, <e1>, <e2>);<\n>'
      res
    case LESSEQ then
      # preExp += 'RELATIONLESSEQ(<res>, <e1>, <e2>);<\n>'
      res
    case GREATER then
      # preExp += 'RELATIONGREATER(<res>, <e1>, <e2>);<\n>'
      res
    case GREATEREQ then
      # preExp += 'RELATIONGREATEREQ(<res>, <e1>, <e2>);<\n>'
      res

daeExpIf(Exp exp, Context context, Text preExp /*BUFP*/,
         Text varDecls /*BUFP*/) ::=
match exp
case IFEXP then
  # condExp = daeExp(expCond, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # condVar = tempDecl("modelica_boolean", varDecls /*BUFC*/)
  # resVarType = expTypeFromExpArrayIf(expThen)
  # resVar = tempDecl(resVarType, varDecls /*BUFC*/)
  # preExpThen = "" /*BUFD*/
  # eThen = daeExp(expThen, context, preExpThen /*BUFC*/, varDecls /*BUFC*/)
  # preExpElse = "" /*BUFD*/
  # eElse = daeExp(expElse, context, preExpElse /*BUFC*/, varDecls /*BUFC*/)
  # preExp +=  
  <<
  <condVar> = <condExp>;
  if (<condVar>) {
    <preExpThen>
    <resVar> = <eThen>;
  } else {
    <preExpElse>
    <resVar> = <eElse>;
  }<\n>
  >>
  resVar
//  An alternative solution?
//  <<
//  ((<condVar>)?<eThen>:<eElse>)
//  >>

daeExpCall(Exp call, Context context, Text preExp /*BUFP*/,
           Text varDecls /*BUFP*/) ::=
  match call
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="DIVISION"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    # var1 = daeExp(e1, context, preExp, varDecls)
    # var2 = daeExp(e2, context, preExp, varDecls)
    # var3 = Util.escapeModelicaStringToCString(string)
    'DIVISION(<var1>,<var2>,"<var3>")'
  case CALL(tuple_=false, builtin=true, ty=ty, 
            path=IDENT(name="DIVISION_ARRAY_SCALAR"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # var1 = daeExp(e1, context, preExp, varDecls)
    # var2 = daeExp(e2, context, preExp, varDecls)
    # var3 = Util.escapeModelicaStringToCString(string)
    # preExp += 'division_alloc_<type>_scalar(&<var1>, <var2>, &<var>,"<var3>");<\n>'
    '<var>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    # retType = '<expTypeArrayIf(arg.ty)>'
    # retVar = tempDecl(retType, varDecls /*BUFC*/)
    # cast = if arg.ty is ET_INT then "(modelica_integer)" else ""
    # preExp += '<retVar> = <cast>pre(<cref(arg.componentRef)>);<\n>'
    '<retVar>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="max"), expLst={array}) then
    # expVar = daeExp(array, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<expTypeFromExpArray(array)>'
    # tvar = tempDecl(expTypeFromExpModelica(array), varDecls /*BUFC*/)
    # preExp += '<tvar> = max_<arr_tp_str>(&<expVar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="promote"), expLst={A, n}) then
    # var1 = daeExp(A, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # var2 = daeExp(n, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls /*BUFC*/)
    # preExp += 'promote_alloc_<arr_tp_str>(&<var1>, <var2>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="transpose"), expLst={A}) then
    # var1 = daeExp(A, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls /*BUFC*/)
    # preExp += 'transpose_alloc_<arr_tp_str>(&<var1>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="identity"), expLst={A}) then
    # var1 = daeExp(A, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls /*BUFC*/)
    # preExp += 'identity_alloc_<arr_tp_str>(<var1>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="abs"), expLst={s1}) then
    # tvar = tempDecl(expTypeFromExpModelica(s1), varDecls /*BUFC*/)
    # s1Exp = daeExp(s1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # preExp += '<tvar> = fabs(<s1Exp>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="String"),
            expLst={s, minlen, leftjust, signdig}) then
    # tvar = tempDecl("modelica_string", varDecls /*BUFC*/)
    # sExp = daeExp(s, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # minlenExp = daeExp(minlen, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # leftjustExp = daeExp(leftjust, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # signdigExp = daeExp(signdig, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # typeStr = expTypeFromExpModelica(s)
    # preExp += '<typeStr>_to_modelica_string(&<tvar>, <sExp>, <minlenExp>, <leftjustExp>, <signdigExp>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="delay"),
            expLst={ICONST(integer=index), e, d, delayMax}) then
    # tvar = tempDecl("modelica_real", varDecls /*BUFC*/)
    # var1 = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # var2 = daeExp(d, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # preExp += '<tvar> = delayImpl(<index>, <var1>, time, <var2>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="mmc_get_field"),
            expLst={s1, ICONST(integer=i)}) then
    # tvar = tempDecl("modelica_metatype", varDecls /*BUFC*/)
    # expPart = daeExp(s1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # preExp += '<tvar> = MMC_FETCH(MMC_OFFSET(MMC_UNTAGPTR(<expPart>), <i>));<\n>'
    tvar
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)>' ", ")
    # funName = '<underscorePath(path)>'
    # preExp += '<daeExpCallBuiltinPrefix(builtin)><funName>(<argStr>);<\n>'
    '/* NORETCALL */'
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls /*BUFC*/)
    # preExp += '<retVar> = <daeExpCallBuiltinPrefix(builtin)><funName>(<argStr>);<\n>'
    if builtin then '<retVar>' else '<retVar>.<retType>_1'
  // tuple calls (multiple return values)
  case CALL(tuple_=true) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls /*BUFC*/)
    # preExp += '<retVar> = <daeExpCallBuiltinPrefix(builtin)><funName>(<argStr>);<\n>'
    retVar

daeExpCallBuiltinPrefix(Boolean builtin) ::=
  match builtin
  case true  then ""
  case false then "_"

daeExpArray(Exp exp, Context context, Text preExp /*BUFP*/,
            Text varDecls /*BUFP*/) ::=
match exp
case ARRAY then
  # arrayTypeStr = '<expTypeArray(ty)>'
  # arrayVar = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
  # scalarPrefix = if scalar then "scalar_" else ""
  # scalarRef = if scalar then "&" else ""
  # params = (array of e:
      # prefix = if scalar then '(<expTypeFromExpModelica(e)>)' else '&'
      '<prefix><daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)>'
    ", ")
  # preExp += 'array_alloc_<scalarPrefix><arrayTypeStr>(&<arrayVar>, <listLength(array)>, <params>);<\n>'
  arrayVar

daeExpMatrix(Exp exp, Context context, Text preExp /*BUFP*/,
             Text varDecls /*BUFP*/) ::=
  match exp
  case MATRIX(scalar={{}}) then
    // special case for empty matrix: create dimensional array Real[0,1]
    # arrayTypeStr = expTypeArray(ty)
    # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
    tmp
  case MATRIX(scalar={}) then
    // special case for empty array: create dimensional array Real[0,1]
    # arrayTypeStr = expTypeArray(ty)
    # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
    tmp
  case m as MATRIX then
    # arrayTypeStr = expTypeArray(m.ty)
    # vars2 = "" /*BUFD*/
    # promote = "" /*BUFD*/
    # catAlloc = (m.scalar of row:
        # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
        # vars = daeExpMatrixRow(row, arrayTypeStr, context,
                                 promote /*BUFC*/, varDecls /*BUFC*/)
        # vars2 += ', &<tmp>'
        'cat_alloc_<arrayTypeStr>(2, &<tmp>, <listLength(row)><vars>);'
      "\n")
    # preExp += promote
    # preExp += catAlloc
    # preExp += "\n"
    # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # preExp += 'cat_alloc_<arrayTypeStr>(1, &<tmp>, <listLength(m.scalar)><vars2>);<\n>'
    tmp

daeExpMatrixRow(list<tuple<Exp,Boolean>> row, String arrayTypeStr,
                Context context, Text preExp /*BUFP*/,
                Text varDecls /*BUFP*/) ::=
  # varLstStr = "" /*BUFD*/
  # preExp2 = (row of col as (e, b):
      # scalarStr = if b then "scalar_" else ""
      # scalarRefStr = if b then "" else "&"
      # expVar = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
      # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
      # varLstStr += ', &<tmp>'
      'promote_<scalarStr><arrayTypeStr>(<scalarRefStr><expVar>, 2, &<tmp>);'
    "\n")
  # preExp2 += "\n"
  # preExp += preExp2
  varLstStr

daeExpCast(Exp exp, Context context, Text preExp /*BUFP*/,
           Text varDecls /*BUFP*/) ::=
match exp
case CAST then
  # expVar = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match ty
  case ET_INT   then '((modelica_int)<expVar>)' // Really int? Not integer?
  case ET_REAL  then '((modelica_real)<expVar>)'
  case ET_ARRAY then
    # arrayTypeStr = expTypeArray(ty)
    # tvar = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # to = expTypeShort(ty)
    # from = expTypeFromExpShort(exp)
    # preExp += 'cast_<from>_array_to_<to>(&<expVar>, &<tvar>);<\n>'
    tvar

daeExpAsub(Exp exp, Context context, Text preExp /*BUFP*/,
           Text varDecls /*BUFP*/) ::=
  match exp
  case ASUB(exp=RANGE(ty=t), sub={idx}) then
    'ASUB_EASY_CASE'
  case ASUB(exp=ASUB(
              exp=ASUB(
                exp=ASUB(exp=e, sub={ICONST(integer=i)}),
                sub={ICONST(integer=j)}),
              sub={ICONST(integer=k)}),
            sub={ICONST(integer=l)}) then
    'ASUB_4D'
  case ASUB(exp=ASUB(
              exp=ASUB(exp=e, sub={ICONST(integer=i)}),
              sub={ICONST(integer=j)}),
            sub={ICONST(integer=k)}) then
    'ASUB_3D'
  case ASUB(exp=ASUB(exp=e, sub={ICONST(integer=i)}),
            sub={ICONST(integer=j)}) then
    'ASUB_2D'
  case ASUB(exp=e, sub={ICONST(integer=i)}) then
    'ASUB_ARRAY'
  case ASUB(exp=cref as CREF, sub=subs) then
    # arrName = daeExpCrefRhs(buildCrefExpFromAsub(cref, subs), context,
                              preExp /*BUFC*/, varDecls /*BUFC*/)
    if context is SIMULATION then
      arrayScalarRhs(cref.ty, subs, arrName, context,
                     preExp /*BUFC*/, varDecls /*BUFC*/)
    else
      arrName
  case _ then
    'OTHER_ASUB'

daeExpSize(Exp exp, Context context, Text preExp /*BUFP*/,
           Text varDecls /*BUFP*/) ::=
  match exp
  case SIZE(exp=CREF, sz=SOME(dim)) then
    # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # dimPart = daeExp(dim, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # resVar = tempDecl("size_t", varDecls /*BUFC*/)
    # typeStr = '<expTypeArray(exp.ty)>'
    # preExp += '<resVar> = size_of_dimension_<typeStr>(<expPart>, <dimPart>);<\n>'
    resVar
  case _ then "size(X) not implemented"

daeExpReduction(Exp exp, Context context, Text preExp /*BUFP*/,
                Text varDecls /*BUFP*/) ::=
match exp
case REDUCTION(path=IDENT(name=op), range=RANGE) then
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # identType = expTypeModelica(range.ty)
  # accFun = daeExpReductionFnName(op, identType)
  # startValue = daeExpReductionStartValue(op, identType)
  # res = tempDecl(identType, varDecls /*BUFC*/)
  # tmpExpPre = "" /*BUFD*/
  # tmpExpVar = daeExp(expr, context, tmpExpPre /*BUFC*/, varDecls /*BUFC*/)
  # cast = if accFun is "max" then
      "(modelica_real)"
    else if accFun is "min" then
      "(modelica_real)"
    else
      ""
  # r1 = tempDecl(identType, varDecls /*BUFC*/)
  # r2 = tempDecl(identType, varDecls /*BUFC*/)
  # r3 = tempDecl(identType, varDecls /*BUFC*/)
  # er1 = daeExp(range.exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # er2 = if range.expOption is SOME(eo) then
      daeExp(eo, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    else
      "(1)"
  # er3 = daeExp(range.range, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # preExp +=
    <<
    <res> = <startValue>;
    <r1> = <er1>; <r2> = <er2>; <r3> = <er3>;
    {
      <identType> <ident>;

      for (<ident> = <r1>; in_range_<expTypeFromExpShort(expr)>(<ident>, <r1>, <r3>); <ident> += <r2>) {
        <stateVar> = get_memory_state();
        <tmpExpPre>
        <res> = <accFun>(<cast>(<res>), <cast>(<tmpExpVar>));
        restore_memory_state(<stateVar>);
      }
    }
    >>
  res

daeExpReductionFnName(String reduction_op, String type) ::=
  match reduction_op
  case "sum" then (
    match type
    case "modelica_integer" then "intAdd"
    case "modelica_real" then "realAdd"
    case _ then "INVALID_TYPE"
  )
  case "product" then (
    match type
    case "modelica_integer" then "intMul"
    case "modelica_real" then "realMul"
    case _ then "INVALID_TYPE"
  )
  case _ then reduction_op

daeExpReductionStartValue(String reduction_op, String type) ::=
  match reduction_op
  case "min" then (
    match type
    case "modelica_integer" then "1073741823"
    case "modelica_real" then "1.e60"
    case _ then "INVALID_TYPE"
  )
  case "max" then (
    match type
    case "modelica_integer" then "-1073741823"
    case "modelica_real" then "-1.e60"
    case _ then "INVALID_TYPE"
  )
  case "sum" then "0"
  case "product" then "1"
  case _ then "UNKNOWN_REDUCTION"

daeExpValueblock(Exp exp, Context context, Text preExp /*BUFP*/,
                 Text varDecls /*BUFP*/) ::=
match exp
case exp as VALUEBLOCK then
  # preExpInner = "" /*BUFD*/
  # preExpRes = "" /*BUFD*/
  # varDeclsInner = "" /*BUFD*/
  # _ = (valueblockVars(exp) of var:
      varInit(var, "", 0, varDeclsInner /*BUFC*/, preExpInner /*BUFC*/)
    )
  # resType = expTypeModelica(ty)
  # res = tempDecl(expTypeModelica(ty), preExp /*BUFC*/)
  # stmts = (body of stmt:
      algStatement(stmt, context, varDeclsInner /*BUFC*/)
    "\n")
  # expPart = daeExp(result, context, preExpRes /*BUFC*/,
                     varDeclsInner /*BUFC*/)
  # preExp +=
      <<
      {
        <varDeclsInner>
        <preExpInner>
        <stmts>
        <preExpRes>
        <res> = <expPart>;
      }
      >>
  res

// TODO: Optimize as in Codegen
// TODO: Use this function in other places where almost the same thing is hard
//       coded
arrayScalarRhs(ExpType ty, list<Exp> subs, String arrName, Context context,
               Text preExp /*BUFP*/, Text varDecls /*BUFP*/) ::=
  # arrayType = expTypeArray(ty)
  # dimsLenStr = listLength(subs)
  # dimsValuesStr = (subs of exp:
      daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  <<
  (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
  >>

daeExpList(Exp exp, Context context, Text preExp /*BUFP*/,
           Text varDecls /*BUFP*/) ::=
match exp
case LIST then
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # expPart = daeExpListToCons(valList, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # preExp += '<tmp> = <expPart>;<\n>'
  tmp

daeExpListToCons(list<Exp> listItems, Context context, Text preExp /*BUFP*/,
                 Text varDecls /*BUFP*/) ::=
  match listItems
  case {} then "mmc_mk_nil()"
  case e :: rest then
    # expPart = daeExpMetaHelperConstant(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # restList = daeExpListToCons(rest, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    mmc_mk_cons(<expPart>, <restList>)
    >>

daeExpCons(Exp exp, Context context, Text preExp /*BUFP*/,
           Text varDecls /*BUFP*/) ::=
match exp
case CONS then
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # carExp = daeExpMetaHelperConstant(car, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # cdrExp = daeExp(cdr, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # preExp += '<tmp> = mmc_mk_cons(<carExp>, <cdrExp>);<\n>'
  tmp

daeExpMetaTuple(Exp exp, Context context, Text preExp /*BUFP*/,
                Text varDecls /*BUFP*/) ::=
match exp
case META_TUPLE then
  # start = daeExpMetaHelperBoxStart(listLength(listExp))
  # args = (listExp of e:
      daeExpMetaHelperConstant(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # preExp += '<tmp> = mmc_mk_box<start>0, <args>);<\n>'
  tmp

daeExpMetaOption(Exp exp, Context context, Text preExp /*BUFP*/,
                 Text varDecls /*BUFP*/) ::=
  match exp
  case META_OPTION(exp=NONE) then
    "mmc_mk_none()"
  case META_OPTION(exp=SOME(e)) then
    # expPart = daeExpMetaHelperConstant(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    'mmc_mk_some(<expPart>)'

daeExpMetarecordcall(Exp exp, Context context, Text preExp /*BUFP*/,
                     Text varDecls /*BUFP*/) ::=
match exp
case METARECORDCALL then
  # newIndex = incrementInt(index, 3)
  # argsStr = if args then
      ', <args of exp:
        daeExpMetaHelperConstant(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
      ", ">'
    else
      ""
  # box = 'mmc_mk_box<daeExpMetaHelperBoxStart(incrementInt(listLength(args), 1))><newIndex>, &<underscorePath(path)>__desc<argsStr>)'
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # preExp += '<tmp> = <box>;<\n>'
  tmp

daeExpMetaHelperConstant(Exp e, Context context, Text preExp /*BUFP*/,
                         Text varDecls /*BUFP*/) ::=
  # expPart = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  daeExpMetaHelperConstantNameType(expPart, Exp.typeof(e), context,
                                   preExp /*BUFC*/, varDecls /*BUFC*/)

daeExpMetaHelperConstantNameType(Text varname, ExpType type, Context context,
                                 Text preExp /*BUFP*/,
                                 Text varDecls /*BUFP*/) ::=
  match type
  case ET_INT     then 'mmc_mk_icon(<varname>)'
  case ET_BOOL    then 'mmc_mk_icon(<varname>)'
  case ET_REAL    then 'mmc_mk_rcon(<varname>)'
  case ET_STRING  then 'mmc_mk_scon(<varname>)'
  case ET_COMPLEX(name=cname) then
    # start = daeExpMetaHelperBoxStart(incrementInt(listLength(varLst), 1))
    # args = if varLst then
        ', <varLst of v as COMPLEX_VAR(name=cvname):
          # nameText = '<varname>.<cvname>'
          daeExpMetaHelperConstantNameType(nameText, tp, context,
                                           preExp /*BUFC*/, varDecls /*BUFC*/)
        ", ">'
      else
        ""
    'mmc_mk_box<start>2, &<underscorePath(cname)>__desc<args>)'
  case _          then varname

daeExpMetaHelperBoxStart(Integer numVariables) ::=
  match numVariables
  case 0
  case 1
  case 2
  case 3
  case 4
  case 5
  case 6
  case 7
  case 8
  case 9 then '<numVariables>('
  case _ then '(<numVariables>, '

tempDecl(String ty, Text varDecls /*BUFP*/) ::=
  # newVar = 'tmp<System.tmpTick()>'
  # varDecls += '<ty> <newVar>;<\n>'
  newVar

varType(Variable var) ::=
match var
case var as VARIABLE then
  if instDims then
    expTypeArray(var.ty)
  else
    expTypeArrayIf(var.ty)

expTypeRW(DAE.ExpType type) ::=
  match type
  case ET_INT         then "TYPE_DESC_INT"
  case ET_REAL        then "TYPE_DESC_REAL"
  case ET_STRING      then "TYPE_DESC_STRING"
  case ET_BOOL        then "TYPE_DESC_BOOL"
  case ET_ARRAY       then '<expTypeRW(ty)>_ARRAY'
  case ET_COMPLEX(complexClassType=RECORD)
                      then "TYPE_DESC_RECORD"
  case ET_METAOPTION
  case ET_LIST
  case ET_METATUPLE
  case ET_UNIONTYPE
  case ET_POLYMORPHIC
  case ET_META_ARRAY
  case ET_BOXED       then "TYPE_DESC_MMC"

expTypeShort(DAE.ExpType type) ::=
  match type
  case ET_INT         then "integer"
  case ET_REAL        then "real"
  case ET_STRING      then "string"
  case ET_BOOL        then "boolean"
  case ET_OTHER       then "complex"
  case ET_ARRAY       then expTypeShort(ty)   
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ)
                      then "complex"
  case ET_COMPLEX     then 'struct <underscorePath(name)>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC
  case ET_META_ARRAY
  case ET_BOXED       then "metatype"
  case _              then "expTypeShort:ERROR"

expType(DAE.ExpType ty, Boolean array) ::=
  match array
  case true  then expTypeArray(ty)
  case false then expTypeModelica(ty)

expTypeModelica(DAE.ExpType ty) ::=
  expTypeFlag(ty, 2)

expTypeArray(DAE.ExpType ty) ::=
  expTypeFlag(ty, 3)

expTypeArrayIf(DAE.ExpType ty) ::=
  expTypeFlag(ty, 4)

expTypeFromExpShort(Exp exp) ::=
  expTypeFromExpFlag(exp, 1)

expTypeFromExpModelica(Exp exp) ::=
  expTypeFromExpFlag(exp, 2)

expTypeFromExpArray(Exp exp) ::=
  expTypeFromExpFlag(exp, 3)

expTypeFromExpArrayIf(Exp exp) ::=
  expTypeFromExpFlag(exp, 4)

expTypeFlag(DAE.ExpType ty, Integer flag) ::=
  match flag
  case 1 then
    // we want the short type
    expTypeShort(ty)
  case 2 then
    // we want the "modelica type"
    if ty is ET_COMPLEX(complexClassType=EXTERNAL_OBJ) then
      'modelica_<expTypeShort(ty)>'
    else if ty is ET_COMPLEX then
      'struct <underscorePath(name)>'
    else
      'modelica_<expTypeShort(ty)>'
  case 3 then
    // we want the "array type"
    '<expTypeShort(ty)>_array'
  case 4 then
    // we want the "array type" only if type is array, otherwise "modelica type"
    match ty
    case ET_ARRAY then '<expTypeShort(ty)>_array'
    case _        then expTypeFlag(ty, 2)

expTypeFromExpFlag(Exp exp, Integer flag) ::=
  match exp
  case ICONST        then if flag is 1 then "integer" else "modelica_integer"
  case RCONST        then if flag is 1 then "real" else "modelica_real"
  case SCONST        then if flag is 1 then "string" else "modelica_string"
  case BCONST        then if flag is 1 then "boolean" else "modelica_boolean"
  case e as BINARY
  case e as UNARY
  case e as LBINARY
  case e as LUNARY
  case e as RELATION then expTypeFromOpFlag(e.operator, flag)
  case IFEXP         then expTypeFromExpFlag(expThen, flag)
  case CALL          then expTypeFlag(ty, flag)
  case c as ARRAY
  case c as MATRIX
  case c as RANGE
  case c as CAST
  case c as CREF
  case c as CODE     then expTypeFlag(c.ty, flag)
  case ASUB          then expTypeFromExpFlag(exp, flag)
  case REDUCTION     then expTypeFromExpFlag(expr, flag)
  case _             then "expTypeFromExpFlag:ERROR"

expTypeFromOpFlag(Operator op, Integer flag) ::=
  match op
  case o as ADD
  case o as SUB
  case o as MUL
  case o as DIV
  case o as POW
  case o as UMINUS
  case o as UPLUS
  case o as UMINUS_ARR
  case o as UPLUS_ARR
  case o as ADD_ARR
  case o as SUB_ARR
  case o as MUL_ARR
  case o as DIV_ARR
  case o as MUL_SCALAR_ARRAY
  case o as MUL_ARRAY_SCALAR
  case o as ADD_SCALAR_ARRAY
  case o as ADD_ARRAY_SCALAR
  case o as SUB_SCALAR_ARRAY
  case o as SUB_ARRAY_SCALAR
  case o as MUL_SCALAR_PRODUCT
  case o as MUL_MATRIX_PRODUCT
  case o as DIV_ARRAY_SCALAR
  case o as DIV_SCALAR_ARRAY
  case o as POW_ARRAY_SCALAR
  case o as POW_SCALAR_ARRAY
  case o as POW_ARR
  case o as POW_ARR2
  case o as LESS
  case o as LESSEQ
  case o as GREATER
  case o as GREATEREQ
  case o as EQUAL
  case o as NEQUAL then
    expTypeFlag(o.ty, flag)
  case o as AND
  case o as OR
  case o as NOT then
    if flag is 1 then "boolean" else "modelica_boolean"
  case _ then "expTypeFromOpFlag:ERROR"

end SimCodeC;

// vim: filetype=susan sw=2 sts=2
