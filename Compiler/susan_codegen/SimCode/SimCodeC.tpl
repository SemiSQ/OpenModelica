// This file defines templates for transforming Modelica/MetaModelica code to C
// code. They are used in the code generator phase of the compiler to write
// target code.
//
// There are two root templates intended to be called from the code generator:
// translateModel and translateFunctions. These templates do not return any
// result but instead write the result to files. All other templates return
// text and are used by the root templates (most of them indirectly).
//
// To future maintainers of this file:
//
// - A line like this
//     # var = "" /*BUFD*/
//   declares a text buffer that you can later append text to. It can also be
//   passed to other templates that in turn can append text to it. In the new
//   version of Susan it should be written like this instead:
//     let &var = buffer ""
//
// - A line like this
//     ..., Text var /*BUFP*/, ...
//   declares that a template takes a text buffer as input parameter. In the
//   new version of Susan it should be written like this instead:
//     ..., Text &var, ...
//
// - A line like this:
//     ..., var /*BUFC*/, ...
//   passes a text buffer to a template. In the new version of Susan it should
//   be written like this instead:
//     ..., &var, ...
//
// - Style guidelines:
//
//   - Try (hard) to limit each row to 80 characters
//
//   - Code for a template should be indented with 2 spaces
//
//     - Exception to this rule is if you have only a single case, then that
//       single case can be written using no indentation
//
//       This single case can be seen as a clarification of the input to the
//       template
//
//   - Code after a case should be indented with 2 spaces if not written on the
//     same line

spackage SimCodeC

typeview "SimCodeTV.mo"

template translateModel(SimCode simCode) 
 "Generates C code and Makefile for compiling and running a simulation of a
  Modelica model."
::=
match simCode
case SIMCODE(modelInfo=MODELINFO) then
  # filePrefix = modelInfo.name
  # textFile(simulationFile(simCode), '<%filePrefix%>.cpp')
  # textFile(simulationFunctionsFile(functions), '<%filePrefix%>_functions.cpp')
  # textFile(simulationMakefile(simCode), '<%filePrefix%>.makefile')
  () // Return empty result since result written to files directly
end translateModel;


template translateFunctions(FunctionCode functionCode)
 "Generates C code and Makefile for compiling and calling Modelica and
  MetaModelica functions." 
::=
match functionCode
case FUNCTIONCODE then
  # filePrefix = name
  # textFile(functionsFile(functions, extraRecordDecls), '<%filePrefix%>.c')
  # textFile(functionsMakefile(functionCode), '<%filePrefix%>.makefile')
  () // Return empty result since result written to files directly
end translateFunctions;


template simulationFile(SimCode simCode)
 "Generates code for main C file for simulation target."
::=
match simCode
case SIMCODE then
  <<
  <%simulationFileHeader(simCode)%>
  
  <%globalData(modelInfo)%>
  
  <%functionGetName(modelInfo)%>
  
  <%functionDivisionError()%>
  
  <%functionSetLocalData()%>
  
  <%functionInitializeDataStruc(extObjInfo)%>
  
  <%functionDeInitializeDataStruc(extObjInfo)%>
  
  <%functionExtraResudials(allEquations)%>
  
  <%functionDaeOutput(nonStateContEquations, removedEquations,
                     algorithmAndEquationAsserts)%>
  
  <%functionDaeOutput2(nonStateDiscEquations, removedEquations)%>
  
  <%functionInput(modelInfo)%>
  
  <%functionOutput(modelInfo)%>
  
  <%functionDaeRes()%>
  
  <%functionZeroCrossing(zeroCrossings)%>
  
  <%functionHandleZeroCrossing(zeroCrossingsNeedSave)%>
  
  <%functionUpdateDependents(allEquations, helpVarInfo)%>
  
  <%functionUpdateDepend(allEquationsPlusWhen)%>
  
  <%functionOnlyZeroCrossing(zeroCrossings)%>
  
  <%functionCheckForDiscreteChanges(discreteModelVars)%>
  
  <%functionStoreDelayed(delayedExps)%>
  
  <%functionWhen(whenClauses)%>
  
  <%functionOde(stateContEquations)%>
  
  <%functionInitial(initialEquations)%>
  
  <%functionInitialResidual(residualEquations)%>
  
  <%functionBoundParameters(parameterEquations)%>
  
  <%functionCheckForDiscreteVarChanges(helpVarInfo, discreteModelVars)%>
  >>
end simulationFile;


template simulationFileHeader(SimCode simCode)
 "Generates header part of simulation file."
::=
match simCode
case SIMCODE(modelInfo=MODELINFO, extObjInfo=EXTOBJINFO) then
  <<
  // Simulation code for <%modelInfo.name%> generated by the OpenModelica Compiler.
  
  #include "modelica.h"
  #include "assert.h"
  #include "string.h"
  #include "simulation_runtime.h"
  
  #if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
    #define DLLExport   __declspec( dllexport )
  #else 
    #define DLLExport /* nothing */
  #endif 
  
  #include "<%modelInfo.name%>_functions.cpp"
  
  extern "C" {
  <%extObjInfo.includes of include: include "\n"%>
  }
  >>
end simulationFileHeader;


template globalData(ModelInfo modelInfo)
 "Generates global data in simulation file."
::=
match modelInfo
case MODELINFO(varInfo=VARINFO, vars=SIMVARS) then
  <<
  #define NHELP <%varInfo.numHelpVars%>
  #define NG <%varInfo.numZeroCrossings%>
  #define NX <%varInfo.numStateVars%>
  #define NY <%varInfo.numAlgVars%>
  #define NP <%varInfo.numParams%>
  #define NO <%varInfo.numOutVars%>
  #define NI <%varInfo.numInVars%>
  #define NR <%varInfo.numResiduals%>
  #define NEXT <%varInfo.numExternalObjects%>
  #define MAXORD 5
  #define NYSTR <%varInfo.numStringAlgVars%>
  #define NPSTR <%varInfo.numStringParamVars%>
  
  static DATA* localData = 0;
  #define time localData->timeValue
  extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
    char *model_name="<%name%>";
    char *model_dir="<%directory%>";
  }
  
  <%globalDataVarNamesArray("state_names", vars.stateVars)%>
  <%globalDataVarNamesArray("derivative_names", vars.derivativeVars)%>
  <%globalDataVarNamesArray("algvars_names", vars.algVars)%>
  <%globalDataVarNamesArray("input_names", vars.inputVars)%>
  <%globalDataVarNamesArray("output_names", vars.outputVars)%>
  <%globalDataVarNamesArray("param_names", vars.paramVars)%>
  <%globalDataVarNamesArray("string_alg_names", vars.stringAlgVars)%>
  <%globalDataVarNamesArray("string_param_names", vars.stringParamVars)%>
  
  <%globalDataVarCommentsArray("state_comments", vars.stateVars)%>
  <%globalDataVarCommentsArray("derivative_comments", vars.derivativeVars)%>
  <%globalDataVarCommentsArray("algvars_comments", vars.algVars)%>
  <%globalDataVarCommentsArray("input_comments", vars.inputVars)%>
  <%globalDataVarCommentsArray("output_comments", vars.outputVars)%>
  <%globalDataVarCommentsArray("param_comments", vars.paramVars)%>
  <%globalDataVarCommentsArray("string_alg_comments", vars.stringAlgVars)%>
  <%globalDataVarCommentsArray("string_param_comments", vars.stringParamVars)%>
  
  <%vars.stateVars of var:
    globalDataVarDefine(var, "states")
  "\n"%>
  <%vars.derivativeVars of var:
    globalDataVarDefine(var, "statesDerivatives")
  "\n"%>
  <%vars.algVars of var:
    globalDataVarDefine(var, "algebraics")
  "\n"%>
  <%vars.paramVars of var:
    globalDataVarDefine(var, "parameters")
  "\n"%>
  <%vars.extObjVars of var:
    globalDataVarDefine(var, "extObjs")
  "\n"%>
  <%vars.stringAlgVars of var:
    globalDataVarDefine(var, "stringVariables.algebraics")
  "\n"%>
  
  static char init_fixed[NX+NX+NY+NP] = {
    <%[(vars.stateVars of SIMVAR:
        '<%globalDataFixedInt(isFixed)%> /* <%cref(origName)%> */'
      ",\n"),
      (vars.derivativeVars of SIMVAR:
        '<%globalDataFixedInt(isFixed)%> /* <%cref(origName)%> */'
      ",\n"),
      (vars.algVars of SIMVAR:
        '<%globalDataFixedInt(isFixed)%> /* <%cref(origName)%> */'
      ",\n"),
      (vars.paramVars of SIMVAR:
        '<%globalDataFixedInt(isFixed)%> /* <%cref(origName)%> */'
      ",\n")]
    ",\n"%>
  };
  
  char var_attr[NX+NY+NP] = {
    <%[(vars.stateVars of SIMVAR:
        '<%globalDataAttrInt(type_)%>+<%globalDataDiscAttrInt(isDiscrete)%> /* <%cref(origName)%> */'
      ",\n"),
      (vars.algVars of SIMVAR:
        '<%globalDataAttrInt(type_)%>+<%globalDataDiscAttrInt(isDiscrete)%> /* <%cref(origName)%> */'
      ",\n"),
      (vars.paramVars of SIMVAR:
        '<%globalDataAttrInt(type_)%>+<%globalDataDiscAttrInt(isDiscrete)%> /* <%cref(origName)%> */'
       ",\n")]
    ",\n"%>
  };
  >>
end globalData;


template globalDataVarNamesArray(String name, list<SimVar> items)
 "Generates array with variable names in global data section."
::=
  match items
  case {} then
    <<
    char* <%name%>[1] = {""};
    >>
  case items then
    # itemsStr = (items of SIMVAR: '"<%crefWithSubscript(origName)%>"' ", ")
    <<
    char* <%name%>[<%listLength(items)%>] = {<%itemsStr%>};
    >>
end globalDataVarNamesArray;


template globalDataVarCommentsArray(String name, list<SimVar> items)
 "Generates array with variable comments in global data section."
::=
  match items
  case {} then
    <<
    char* <%name%>[1] = {""};
    >>
  case items then
    # itemsStr = (items of SIMVAR: '"<%comment%>"' ", ")
    <<
    char* <%name%>[<%listLength(items)%>] = {<%itemsStr%>};
    >>
end globalDataVarCommentsArray;


template globalDataVarDefine(SimVar simVar, String arrayName)
 "Generates a define statement for a varable in the global data section."
::=
  match simVar
  case SIMVAR(arrayCref=SOME(c)) then
    <<
    #define <%cref(c)%> localData-><%arrayName%>[<%index%>]
    #define <%cref(name)%> localData-><%arrayName%>[<%index%>]
    >>
  case SIMVAR then
    <<
    #define <%cref(name)%> localData-><%arrayName%>[<%index%>]
    >>
end globalDataVarDefine;


template globalDataFixedInt(Boolean isFixed)
 "Generates integer for use in arrays in global data section."
::=
  match isFixed
  case true  then "1"
  case false then "0"
end globalDataFixedInt;


template globalDataAttrInt(DAE.ExpType type)
 "Generates integer for use in arrays in global data section."
::=
  match type
  case ET_REAL   then "1"
  case ET_STRING then "2"
  case ET_INT    then "4"
  case ET_BOOL   then "8"
end globalDataAttrInt;


template globalDataDiscAttrInt(Boolean isDiscrete)
 "Generates integer for use in arrays in global data section."
::=
  match isDiscrete
  case true  then "16"
  case false then "0"
end globalDataDiscAttrInt;


template functionGetName(ModelInfo modelInfo)
 "Generates function in simulation file."
::=
match modelInfo
case MODELINFO(vars=SIMVARS) then
  <<
  char* getName(double* ptr)
  {
    <%vars.stateVars of SIMVAR:
      'if (&<%cref(name)%> == ptr) return state_names[<%index%>];'
    "\n"%>
    <%vars.derivativeVars of SIMVAR:
      'if (&<%cref(name)%> == ptr) return derivative_names[<%index%>];'
    "\n"%>
    <%vars.algVars of SIMVAR:
      'if (&<%cref(name)%> == ptr) return algvars_names[<%index%>];'
    "\n"%>
    <%vars.paramVars of SIMVAR:
      'if (&<%cref(name)%> == ptr) return param_names[<%index%>];'
    "\n"%>
    return "";
  }
  >>
end functionGetName;


template functionDivisionError()
 "Generates function in simulation file."
::=
  <<
  /* Commented out by Frenkel TUD because there is a new implementation of
     division by zero problem. */
  /*
  #define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))
  
  int encounteredDivisionByZero = 0;
  
  double division_error(double b, const char* division_str)
  {
    if(!encounteredDivisionByZero) {
      fprintf(stderr, "ERROR: Division by zero in partial equation: %s.\n",division_str);
      encounteredDivisionByZero = 1;
    }
    return b;
  }
  */
  >>
end functionDivisionError;


template functionSetLocalData()
 "Generates function in simulation file."
::=
  <<
  void setLocalData(DATA* data)
  {
    localData = data;
  }
  >>
end functionSetLocalData;


template functionInitializeDataStruc(ExtObjInfo extObjInfo)
 "Generates function in simulation file."
::=
match extObjInfo
case EXTOBJINFO then
  # varDecls = "" /*BUFD*/
  # preExp = "" /*BUFD*/
  # ctorCalls = (constructors of (var, fnName, args):
      # argsStr = (args of arg:
          daeExp(arg, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
        ", ")
      '<%cref(var)%> = <%fnName%>(<%argsStr%>);'
    "\n")
  <<
  DATA* initializeDataStruc(DATA_FLAGS flags)
  {
    <%varDecls%>
  
    DATA* returnData = (DATA*)malloc(sizeof(DATA));
  
    if(!returnData) //error check
      return 0;
  
    memset(returnData,0,sizeof(DATA));
    returnData->nStates = NX;
    returnData->nAlgebraic = NY;
    returnData->nParameters = NP;
    returnData->nInputVars = NI;
    returnData->nOutputVars = NO;
    returnData->nZeroCrossing = NG;
    returnData->nInitialResiduals = NR;
    returnData->nHelpVars = NHELP;
    returnData->stringVariables.nParameters = NPSTR;
    returnData->stringVariables.nAlgebraic = NYSTR;
  
    if(flags & STATES && returnData->nStates) {
      returnData->states = (double*) malloc(sizeof(double)*returnData->nStates);
      returnData->oldStates = (double*) malloc(sizeof(double)*returnData->nStates);
      returnData->oldStates2 = (double*) malloc(sizeof(double)*returnData->nStates);
      assert(returnData->states&&returnData->oldStates&&returnData->oldStates2);
      memset(returnData->states,0,sizeof(double)*returnData->nStates);
      memset(returnData->oldStates,0,sizeof(double)*returnData->nStates);
      memset(returnData->oldStates2,0,sizeof(double)*returnData->nStates);
    } else {
      returnData->states = 0;
      returnData->oldStates = 0;
      returnData->oldStates2 = 0;
    }
  
    if(flags & STATESDERIVATIVES && returnData->nStates) {
      returnData->statesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
      returnData->oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData->nStates);
      returnData->oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData->nStates);
      assert(returnData->statesDerivatives&&returnData->oldStatesDerivatives&&returnData->oldStatesDerivatives2);
      memset(returnData->statesDerivatives,0,sizeof(double)*returnData->nStates);
      memset(returnData->oldStatesDerivatives,0,sizeof(double)*returnData->nStates);
      memset(returnData->oldStatesDerivatives2,0,sizeof(double)*returnData->nStates);
    } else {
      returnData->statesDerivatives = 0;
      returnData->oldStatesDerivatives = 0;
      returnData->oldStatesDerivatives2 = 0;
    }
  
    if(flags & HELPVARS && returnData->nHelpVars) {
      returnData->helpVars = (double*) malloc(sizeof(double)*returnData->nHelpVars);
      assert(returnData->helpVars);
      memset(returnData->helpVars,0,sizeof(double)*returnData->nHelpVars);
    } else {
      returnData->helpVars = 0;
    }
  
    if(flags & ALGEBRAICS && returnData->nAlgebraic) {
      returnData->algebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
      returnData->oldAlgebraics = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
      returnData->oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData->nAlgebraic);
      assert(returnData->algebraics&&returnData->oldAlgebraics&&returnData->oldAlgebraics2);
      memset(returnData->algebraics,0,sizeof(double)*returnData->nAlgebraic);
      memset(returnData->oldAlgebraics,0,sizeof(double)*returnData->nAlgebraic);
      memset(returnData->oldAlgebraics2,0,sizeof(double)*returnData->nAlgebraic);
    } else {
      returnData->algebraics = 0;
      returnData->oldAlgebraics = 0;
      returnData->oldAlgebraics2 = 0;
      returnData->stringVariables.algebraics = 0;
    }
  
    if (flags & ALGEBRAICS && returnData->stringVariables.nAlgebraic) {
      returnData->stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData->stringVariables.nAlgebraic);
      assert(returnData->stringVariables.algebraics);
      memset(returnData->stringVariables.algebraics,0,sizeof(char*)*returnData->stringVariables.nAlgebraic);
    } else {
      returnData->stringVariables.algebraics=0;
    }
  
    if(flags & PARAMETERS && returnData->nParameters) {
      returnData->parameters = (double*) malloc(sizeof(double)*returnData->nParameters);
      assert(returnData->parameters);
      memset(returnData->parameters,0,sizeof(double)*returnData->nParameters);
    } else {
      returnData->parameters = 0;
    }
  
    if (flags & PARAMETERS && returnData->stringVariables.nParameters) {
    	  returnData->stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData->stringVariables.nParameters);
        assert(returnData->stringVariables.parameters);
        memset(returnData->stringVariables.parameters,0,sizeof(char*)*returnData->stringVariables.nParameters);
    } else {
        returnData->stringVariables.parameters=0;
    }
  
    if(flags & OUTPUTVARS && returnData->nOutputVars) {
      returnData->outputVars = (double*) malloc(sizeof(double)*returnData->nOutputVars);
      assert(returnData->outputVars);
      memset(returnData->outputVars,0,sizeof(double)*returnData->nOutputVars);
    } else {
      returnData->outputVars = 0;
    }
  
    if(flags & INPUTVARS && returnData->nInputVars) {
      returnData->inputVars = (double*) malloc(sizeof(double)*returnData->nInputVars);
      assert(returnData->inputVars);
      memset(returnData->inputVars,0,sizeof(double)*returnData->nInputVars);
    } else {
      returnData->inputVars = 0;
    }
  
    if(flags & INITIALRESIDUALS && returnData->nInitialResiduals) {
      returnData->initialResiduals = (double*) malloc(sizeof(double)*returnData->nInitialResiduals);
      assert(returnData->initialResiduals);
      memset(returnData->initialResiduals,0,sizeof(double)*returnData->nInitialResiduals);
    } else {
      returnData->initialResiduals = 0;
    }
  
    if(flags & INITFIXED) {
      returnData->initFixed = init_fixed;
    } else {
      returnData->initFixed = 0;
    }
  
    /*   names   */
    if(flags & MODELNAME) {
      returnData->modelName = model_name;
    } else {
      returnData->modelName = 0;
    }
    
    if(flags & STATESNAMES) {
      returnData->statesNames = state_names;
    } else {
      returnData->statesNames = 0;
    }
  
    if(flags & STATESDERIVATIVESNAMES) {
      returnData->stateDerivativesNames = derivative_names;
    } else {
      returnData->stateDerivativesNames = 0;
    }
  
    if(flags & ALGEBRAICSNAMES) {
      returnData->algebraicsNames = algvars_names;
    } else {
      returnData->algebraicsNames = 0;
    }
  
    if(flags & PARAMETERSNAMES) {
      returnData->parametersNames = param_names;
    } else {
      returnData->parametersNames = 0;
    }
  
    if(flags & INPUTNAMES) {
      returnData->inputNames = input_names;
    } else {
      returnData->inputNames = 0;
    }
  
    if(flags & OUTPUTNAMES) {
      returnData->outputNames = output_names;
    } else {
      returnData->outputNames = 0;
    }
  
    /*   comments  */
    if(flags & STATESCOMMENTS) {
      returnData->statesComments = state_comments;
    } else {
      returnData->statesComments = 0;
    }
  
    if(flags & STATESDERIVATIVESCOMMENTS) {
      returnData->stateDerivativesComments = derivative_comments;
    } else {
      returnData->stateDerivativesComments = 0;
    }
  
    if(flags & ALGEBRAICSCOMMENTS) {
      returnData->algebraicsComments = algvars_comments;
    } else {
      returnData->algebraicsComments = 0;
    }
  
    if(flags & PARAMETERSCOMMENTS) {
      returnData->parametersComments = param_comments;
    } else {
      returnData->parametersComments = 0;
    }
  
    if(flags & INPUTCOMMENTS) {
      returnData->inputComments = input_comments;
    } else {
      returnData->inputComments = 0;
    }
  
    if(flags & OUTPUTCOMMENTS) {
      returnData->outputComments = output_comments;
    } else {
      returnData->outputComments = 0;
    }
  
    if (flags & EXTERNALVARS) {
      returnData->extObjs = (void**)malloc(sizeof(void*)*NEXT);
      if (!returnData->extObjs) {
        printf("error allocating external objects\n");
        exit(-2);
      }
      memset(returnData->extObjs,0,sizeof(void*)*NEXT);
      setLocalData(returnData); /* must be set since used by constructors*/
      <%preExp%>
      <%ctorCalls%>
      <%aliases of (var1, var2): '<%cref(var1)%> = <%cref(var2)%>;' "\n"%>
    }
    return returnData;
  }
  >>
end functionInitializeDataStruc;


template functionDeInitializeDataStruc(ExtObjInfo extObjInfo)
 "Generates function in simulation file."
::=
match extObjInfo
case EXTOBJINFO then
  <<
  void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
  {
    if(!data)
      return;
  
    if(flags & STATES && data->states) {
      free(data->states);
      data->states = 0;
    }
  
    if(flags & STATESDERIVATIVES && data->statesDerivatives) {
      free(data->statesDerivatives);
      data->statesDerivatives = 0;
    }
  
    if(flags & ALGEBRAICS && data->algebraics) {
      free(data->algebraics);
      data->algebraics = 0;
    }
  
    if(flags & PARAMETERS && data->parameters) {
      free(data->parameters);
      data->parameters = 0;
    }
  
    if(flags & OUTPUTVARS && data->inputVars) {
      free(data->inputVars);
      data->inputVars = 0;
    }
  
    if(flags & INPUTVARS && data->outputVars) {
      free(data->outputVars);
      data->outputVars = 0;
    }
    
    if(flags & INITIALRESIDUALS && data->initialResiduals){
      free(data->initialResiduals);
      data->initialResiduals = 0;
    }
    if (flags & EXTERNALVARS && data->extObjs) {
      <%destructors of (fnName, var): '<%fnName%>(<%cref(var)%>);' "\n"%>
      free(data->extObjs);
      data->extObjs = 0;
    }
  }
  >>
end functionDeInitializeDataStruc;


template functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations,
                  list<DAE.Statement> algorithmAndEquationAsserts)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # nonStateContPart = (nonStateContEquations of eq:
      equation_(eq, contextSimulationNonDescrete, varDecls /*BUFC*/)
    "\n")
  # algAndEqAssertsPart = (algorithmAndEquationAsserts of stmt:
      algStatement(stmt, contextSimulationNonDescrete, varDecls /*BUFC*/)
    "\n")
  # removedPart = (removedEquations of eq:
      equation_(eq, contextSimulationNonDescrete, varDecls /*BUFC*/)
    "\n")
  <<
  /* for continuous time variables */
  int functionDAE_output()
  {
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
    <%nonStateContPart%>
    <%algAndEqAssertsPart%>
    <%removedPart%>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionDaeOutput;


template functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # nonSateDiscPart = (nonStateDiscEquations of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  # removedPart = (removedEquations of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  <<
  /* for discrete time variables */
  int functionDAE_output2()
  {
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
    <%nonSateDiscPart%>
    <%removedPart%>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionDaeOutput2;


template functionInput(ModelInfo modelInfo)
 "Generates function in simulation file."
::=
match modelInfo
case MODELINFO(vars=SIMVARS) then
  <<
  int input_function()
  {
    <%vars.inputVars of SIMVAR:
      '<%cref(name)%> = localData->inputVars[<%i0%>];'
    "\n"%>
    return 0;
  }
  >>
end functionInput;


template functionOutput(ModelInfo modelInfo)
 "Generates function in simulation file."
::=
match modelInfo
case MODELINFO(vars=SIMVARS) then
  <<
  int output_function()
  {
    <%vars.outputVars of SIMVAR:
      'localData->outputVars[<%i0%>] = <%cref(name)%>;'
    "\n"%>
    return 0;
  }
  >>
end functionOutput;


template functionDaeRes()
  "Generates function in simulation file."
::=
  <<
  int functionDAE_res(double *t, double *x, double *xd, double *delta,
                      long int *ires, double *rpar, long int* ipar)
  {
    int i;
    double temp_xd[NX];
    double* statesBackup;
    double* statesDerivativesBackup;
    double timeBackup;
  
    statesBackup = localData->states;
    statesDerivativesBackup = localData->statesDerivatives;
    timeBackup = localData->timeValue;
    localData->states = x;
  
    for (i=0; i<localData->nStates; i++) {
      temp_xd[i] = localData->statesDerivatives[i];
    }
  
    localData->statesDerivatives = temp_xd;
    localData->timeValue = *t;
  
    functionODE();
  
    /* get the difference between the temp_xd(=localData->statesDerivatives)
       and xd(=statesDerivativesBackup) */
    for (i=0; i < localData->nStates; i++) {
      delta[i] = localData->statesDerivatives[i] - statesDerivativesBackup[i];
    }
  
    localData->states = statesBackup;
    localData->statesDerivatives = statesDerivativesBackup;
    localData->timeValue = timeBackup;
  
    if (modelErrorCode) {
      if (ires) {
        *ires = -1;
      }
      modelErrorCode =0;
    }
  
    return 0;
  }
  >>
end functionDaeRes;


template functionZeroCrossing(list<ZeroCrossing> zeroCrossings)
  "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # zeroCrossingsCode = zeroCrossingsTpl(zeroCrossings, varDecls /*BUFC*/)
  <<
  int function_zeroCrossing(long *neqm, double *t, double *x, long *ng,
                            double *gout, double *rpar, long* ipar)
  {
    double timeBackup;
    state mem_state;
  
    mem_state = get_memory_state();
  
    timeBackup = localData->timeValue;
    localData->timeValue = *t;
    <%varDecls%>
  
    functionODE();
    functionDAE_output();
  
    <%zeroCrossingsCode%>
  
    restore_memory_state(mem_state);
    localData->timeValue = timeBackup;
  
    return 0;
  }
  >>
end functionZeroCrossing;


template functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave)
  "Generates function in simulation file."
::=
  <<
  /* This function should only save in cases. The rest is done in
     function_updateDependents. */
  int handleZeroCrossing(long index)
  {
    state mem_state;
  
    mem_state = get_memory_state();
  
    switch(index) {
      <%zeroCrossingsNeedSave of vars:
        <<
        case <%i0%>:
          <%vars of SIMVAR: 'save(<%cref(name)%>);' "\n"%>
          break;
        >>
      "\n"%>
      default:
        break;
    }
  
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionHandleZeroCrossing;


template functionUpdateDependents(list<SimEqSystem> allEquations,
                                  list<HelpVarInfo> helpVarInfo)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # eqs = (allEquations of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  # hvars = (helpVarInfo of (hindex, exp, _):
      # preExp = "" /*BUFD*/
      # expPart = daeExp(exp, contextSimulationDescrete, preExp /*BUFC*/,
                         varDecls /*BUFC*/)
      '<%preExp%>localData->helpVars[<%hindex%>] = <%expPart%>;'
    "\n")
  <<
  int function_updateDependents()
  {
    state mem_state;
    <%varDecls%>
  
    inUpdate=initial()?0:1;
  
    mem_state = get_memory_state();
    <%eqs%>
    <%hvars%>
    restore_memory_state(mem_state);
  
    inUpdate=0;
  
    return 0;
  }
  >>
end functionUpdateDependents;


template functionUpdateDepend(list<SimEqSystem> allEquationsPlusWhen)
  "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # eqs = (allEquationsPlusWhen of eq:
      equation_(eq, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  <<
  int function_updateDepend()
  {
    state mem_state;
    <%varDecls%>
  
    inUpdate=initial()?0:1;
  
    mem_state = get_memory_state();
    <%eqs%>
    restore_memory_state(mem_state);
  
    inUpdate=0;
  
    return 0;
  }
  >>
end functionUpdateDepend;


template functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossings)
  "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # zeroCrossingsCode = zeroCrossingsTpl(zeroCrossings, varDecls /*BUFC*/)
  <<
  int function_onlyZeroCrossings(double *gout,double *t)
  {
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
    <%zeroCrossingsCode%>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionOnlyZeroCrossing;


template functionCheckForDiscreteChanges(list<ComponentRef> discreteModelVars)
  "Generates function in simulation file."
::=
  <<
  int checkForDiscreteChanges()
  {
    int needToIterate = 0;
  
    <%discreteModelVars of var:
      'if (change(<%cref(var)%>)) { needToIterate=1; }'
    "\n"%>
    
    return needToIterate;
  }
  >>
end functionCheckForDiscreteChanges;


template functionStoreDelayed(list<tuple<DAE.Exp, DAE.Exp>> delayedExps)
  "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # storePart = (delayedExps of (id, e):
      # preExp = "" /*BUFD*/
      # idRes = daeExp(id, contextSimulationNonDescrete,
                       preExp /*BUFC*/, varDecls /*BUFC*/)
      # eRes = daeExp(e, contextSimulationNonDescrete,
                      preExp /*BUFC*/, varDecls /*BUFC*/)
      <<
      <%preExp%>
      storeDelayedExpression(<%idRes%>, <%eRes%>);
      >>
    )
  <<
  int function_storeDelayed()
  {
    state mem_state;
    <%varDecls%>

    mem_state = get_memory_state();
    <%storePart%>
    restore_memory_state(mem_state);

    return 0;
  }
  >>
end functionStoreDelayed;


template functionWhen(list<SimWhenClause> whenClauses)
  "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # cases = (whenClauses of SIM_WHEN_CLAUSE:
      <<
      case <%i0%>:
        <%functionWhenCaseEquation(whenEq, varDecls /*BUFC*/)%>
        <%reinits of reinit:
          # preExp = "" /*BUFD*/
          # body = functionWhenReinitStatement(reinit, preExp /*BUFC*/,
                                               varDecls /*BUFC*/)
          '<%preExp%><%\n%><%body%>'
        "\n"%>
        break;<%\n%>
      >>
    )
  <<
  int function_when(int i)
  {
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
  
    switch(i) {
      <%cases%>
      default:
        break;
    }
  
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionWhen;


template functionWhenCaseEquation(Option<WhenEquation> when, Text varDecls /*BUFP*/)
  "Generates content of case-clause for a when equation in function_when."
::=
match when
case SOME(weq as WHEN_EQ) then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(weq.right, contextSimulationDescrete,
                     preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  save(<%cref(weq.left)%>);
  
  <%preExp%>
  <%cref(weq.left)%> = <%expPart%>;
  >>
end functionWhenCaseEquation;


template functionWhenReinitStatement(ReinitStatement reinit, Text preExp /*BUFP*/,
                            Text varDecls /*BUFP*/)
 "Generates re-init statement for when equation."
::=
match reinit
case REINIT then
  # val = daeExp(value, contextSimulationDescrete,
                 preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%cref(stateVar)%> = <%val%>;
  >>
end functionWhenReinitStatement;


template functionOde(list<SimEqSystem> stateContEquations)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # stateContPart = (stateContEquations of eq:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")
  <<
  int functionODE()
  {
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
    <%stateContPart%>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionOde;


template functionInitial(list<SimEqSystem> initialEquations)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # eqPart = (initialEquations of eq as SES_SIMPLE_ASSIGN:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")
  <<
  int initial_function()
  {
    <%varDecls%>
  
    <%eqPart%>
  
    <%initialEquations of SES_SIMPLE_ASSIGN:
      'if (sim_verbose) { printf("Setting variable start value: %s(start=%f)\n", "<%cref(componentRef)%>", <%cref(componentRef)%>); }'
    "\n"%>
  
    return 0;
  }
  >>
end functionInitial;


template functionInitialResidual(list<SimEqSystem> residualEquations)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # body = (residualEquations of SES_RESIDUAL:
      if exp is DAE.SCONST then
        'localData->initialResiduals[i++] = 0;'
      else
        # preExp = "" /*BUFD*/
        # expPart = daeExp(exp, contextOther, preExp /*BUFC*/,
                           varDecls /*BUFC*/)
        '<%preExp%>localData->initialResiduals[i++] = <%expPart%>;'
    "\n")
  <<
  int initial_residual()
  {
    int i = 0;
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
    <%body%>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionInitialResidual;


template functionExtraResudials(list<SimEqSystem> allEquations)
 "Generates functions in simulation file."
::=
  (allEquations of eq as SES_NONLINEAR:
     # varDecls = "" /*BUFD*/
     # prebody = (eq.eqs of eq2 as SES_SIMPLE_ASSIGN:
         equation_(eq2, contextOther, varDecls /*BUFC*/)
       "\n")   
     # body = (eq.eqs of eq2 as SES_RESIDUAL:
         # preExp = "" /*BUFD*/
         # expPart = daeExp(eq2.exp, contextSimulationDescrete,
                            preExp /*BUFC*/, varDecls /*BUFC*/)
         '<%preExp%>res[<%i0%>] = <%expPart%>;'
       "\n")
     <<
     void residualFunc<%index%>(int *n, double* xloc, double* res, int* iflag)
     {
       state mem_state;
       <%varDecls%>
       mem_state = get_memory_state();
       <%prebody%>
       <%body%>
       restore_memory_state(mem_state);
     }
     >>
   "\n\n")
end functionExtraResudials;


template functionBoundParameters(list<SimEqSystem> parameterEquations)
 "Generates function in simulation file."
::=
  # varDecls = "" /*BUFD*/
  # body = (parameterEquations of eq as SES_SIMPLE_ASSIGN:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")
  # divbody = (parameterEquations of eq as SES_ALGORITHM:
      equation_(eq, contextOther, varDecls /*BUFC*/)
    "\n")    
  <<
  int bound_parameters()
  {
    state mem_state;
    <%varDecls%>
  
    mem_state = get_memory_state();
    <%body%>
    <%divbody%>
    restore_memory_state(mem_state);
  
    return 0;
  }
  >>
end functionBoundParameters;

//TODO: Is the -1 windex check really correct? It seems to work.
template functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfo,
                                            list<ComponentRef> discreteModelVars)
 "Generates function in simulation file."
::=
  <<
  int checkForDiscreteVarChanges()
  {
    int needToIterate = 0;
  
    <%helpVarInfo of (hindex, exp, windex):
      if windex is not -1 then
        'if (edge(localData->helpVars[<%hindex%>])) AddEvent(<%windex%> + localData->nZeroCrossing);'
    "\n"%>
  
    <%discreteModelVars of var:
      'if (change(<%cref(var)%>)) { needToIterate=1; }'
    "\n"%>
    
    for (long i = 0; i < localData->nHelpVars; i++) {
      if (change(localData->helpVars[i])) {
        needToIterate=1;
      }
    }
  
    return needToIterate;
  }
  >>
end functionCheckForDiscreteVarChanges;


template zeroCrossingsTpl(list<ZeroCrossing> zeroCrossings, Text varDecls /*BUFP*/)
 "Generates code for zero crossings."
::=
  (zeroCrossings of ZERO_CROSSING:
    zeroCrossingTpl(i0, relation_, varDecls /*BUFC*/)
  "\n")
end zeroCrossingsTpl;


template zeroCrossingTpl(Integer index, Exp relation, Text varDecls /*BUFP*/)
 "Generates code for a zero crossing."
::=
  match relation
  case RELATION then
    # preExp = "" /*BUFD*/
    # e1 = daeExp(exp1, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    # op = zeroCrossingOpFunc(operator)
    # e2 = daeExp(exp2, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <%preExp%>
    ZEROCROSSING(<%index%>, <%op%>(<%e1%>, <%e2%>));
    >>
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = "" /*BUFD*/
    # e1 = daeExp(start, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    # e2 = daeExp(interval, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <%preExp%>
    ZEROCROSSING(<%index%>, Sample(*t, <%e1%>, <%e2%>));
    >>
  case _ then
    <<
    ZERO CROSSING ERROR
    >>
end zeroCrossingTpl;


template zeroCrossingOpFunc(Operator op)
 "Generates zero crossing function name for operator."
::=
  match op
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"
end zeroCrossingOpFunc;


template equation_(SimEqSystem eq, Context context, Text varDecls /*BUFP*/)
 "Generates an equation.
  This template should not be used for a SES_RESIDUAL.
  Residual equations are handled differently."
::=
  match eq
  case e as SES_SIMPLE_ASSIGN
    then equationSimpleAssign(e, context, varDecls /*BUFC*/)
  case e as SES_ARRAY_CALL_ASSIGN
    then equationArrayCallAssign(e, context, varDecls /*BUFC*/)
  case e as SES_ALGORITHM
    then equationAlgorithm(e, context, varDecls /*BUFC*/)
  case e as SES_LINEAR
    then equationLinear(e, context, varDecls /*BUFC*/)
  case e as SES_MIXED
    then equationMixed(e, context, varDecls /*BUFC*/)
  case e as SES_NONLINEAR
    then equationNonlinear(e, context, varDecls /*BUFC*/)
  case e as SES_WHEN
    then equationWhen(e, context, varDecls /*BUFC*/)
  case _
    then "NOT IMPLEMENTED EQUATION"
end equation_;


template equationSimpleAssign(SimEqSystem eq, Context context,
                              Text varDecls /*BUFP*/)
 "Generates an equation that is just a simple assignment."
::=
match eq
case SES_SIMPLE_ASSIGN then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  <%cref(componentRef)%> = <%expPart%>;
  >>
end equationSimpleAssign;


template equationArrayCallAssign(SimEqSystem eq, Context context,
                                 Text varDecls /*BUFP*/)
 "Generates equation on form 'cref_array = call(...)'."
::=
match eq
case SES_ARRAY_CALL_ASSIGN then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  copy_real_array_data_mem(&<%expPart%>, &<%cref(componentRef)%>);
  >>
end equationArrayCallAssign;


template equationAlgorithm(SimEqSystem eq, Context context, Text varDecls /*BUFP*/)
 "Generates an equation that is an algorithm."
::=
match eq
case SES_ALGORITHM then
  (statements of stmt:
    algStatement(stmt, context, varDecls /*BUFC*/)
  "\n") 
end equationAlgorithm;


template equationLinear(SimEqSystem eq, Context context, Text varDecls /*BUFP*/)
 "Generates a linear equation system."
::=
match eq
case SES_LINEAR then
  # uid = System.tmpTick()
  # size = listLength(vars)
  # aname = 'A<%uid%>'
  # bname = 'b<%uid%>'
  # mixedPostfix = if partOfMixed then "_mixed" else ""
  <<
  declare_matrix(<%aname%>, <%size%>, <%size%>);
  declare_vector(<%bname%>, <%size%>);
  <%simJac of (row, col, eq as SES_RESIDUAL):
     # preExp = "" /*BUFD*/
     # expPart = daeExp(eq.exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
     '<%preExp%>set_matrix_elt(<%aname%>, <%row%>, <%col%>, <%size%>, <%expPart%>);'
  "\n"%>
  <%beqs of exp:
     # preExp = "" /*BUFD*/
     # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
     '<%preExp%>set_vector_elt(<%bname%>, <%i0%>, <%expPart%>);'
  "\n"%>
  solve_linear_equation_system<%mixedPostfix%>(<%aname%>, <%bname%>, <%size%>, <%uid%>);
  <%vars of SIMVAR: '<%cref(name)%> = get_vector_elt(<%bname%>, <%i0%>);' "\n"%>
  >>
end equationLinear;


template equationMixed(SimEqSystem eq, Context context, Text varDecls /*BUFP*/)
 "Generates a mixed equation system."
::=
match eq
case SES_MIXED then
  # contEqs = equation_(cont, context, varDecls /*BUFC*/)
  # numDiscVarsStr = listLength(discVars) 
  # valuesLenStr = listLength(values)
  # preDisc = "" /*BUFD*/
  # discLoc2 = (discEqs of SES_SIMPLE_ASSIGN:
      # expPart = daeExp(exp, context, preDisc /*BUFC*/, varDecls /*BUFC*/)
      <<
      <%cref(componentRef)%> = <%expPart%>;
      discrete_loc2[<%i0%>] = <%cref(componentRef)%>;
      >>
    "\n")
  <<
  mixed_equation_system(<%numDiscVarsStr%>);
  double values[<%valuesLenStr%>] = {<%values of val: '<%val%>' ", "%>};
  int value_dims[<%numDiscVarsStr%>] = {<%value_dims of dim: '<%dim%>' ", "%>};
  <%discVars of var as SIMVAR: 'discrete_loc[<%i0%>] = <%cref(var.name)%>;' "\n"%>
  {
    <%contEqs%>
  }
  <%preDisc%>
  <%discLoc2%>
  {
    double *loc_ptrs[<%numDiscVarsStr%>] = {<%discVars of SIMVAR: '&<%cref(name)%>' ", "%>};
    check_discrete_values(<%numDiscVarsStr%>, <%valuesLenStr%>);
  }
  mixed_equation_system_end(<%numDiscVarsStr%>);
  >>
end equationMixed;


template equationNonlinear(SimEqSystem eq, Context context, Text varDecls /*BUFP*/)
 "Generates a non linear equation system."
::=
match eq
case SES_NONLINEAR then
  # size = listLength(crefs)
  <<
  start_nonlinear_system(<%size%>);
  <%crefs of name:
    <<
    nls_x[<%i0%>] = extraPolate(<%cref(name)%>);
    nls_xold[<%i0%>] = old(&<%cref(name)%>);
    >>
  "\n"%>
  solve_nonlinear_system(residualFunc<%index%>, <%index%>);
  <%crefs of name: '<%cref(name)%> = nls_x[<%i0%>];' "\n"%>
  end_nonlinear_system();
  >>
end equationNonlinear;


template equationWhen(SimEqSystem eq, Context context, Text varDecls /*BUFP*/)
 "Generates a when equation."
::=
match eq
case SES_WHEN then
  # preExp = "" /*BUFD*/
  # helpInits = "" /*BUFD*/
  # helpIf = (conditions of (e, hidx):
      # helpInit = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
      # helpInits += 'localData->helpVars[<%hidx%>] = <%helpInit%>;'
      'edge(localData->helpVars[<%hidx%>])'
    " || ")
  # preExp2 = "" /*BUFD*/
  # exp = daeExp(right, context, preExp2 /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  <%helpInits%>
  if (<%helpIf%>) {
    <%preExp2%>
    <%cref(left)%> = <%exp%>;
  } else {
    <%cref(left)%> = pre(<%cref(left)%>);
  }
  >>
end equationWhen;


template simulationFunctionsFile(list<Function> functions)
 "Generates the content of the C file for functions in the simulation case."
::=
  <<
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  /* Header */
  <%externalFunctionIncludes(functions)%>
  <%functionHeaders(functions)%>
  /* End Header */
  
  /* Body */
  <%functionBodies(functions)%>
  /* End Body */
  
  #ifdef __cplusplus
  }
  #endif
  >>
end simulationFunctionsFile;


template simulationMakefile(SimCode simCode)
 "Generates the contents of the makefile for the simulation case."
::=
match simCode
case SIMCODE(modelInfo=MODELINFO, makefileParams=MAKEFILE_PARAMS) then
  # dirExtra = if modelInfo.directory then '-L"<%modelInfo.directory%>"' //else ""
  # libsStr = (makefileParams.libs of lib: lib " ")
  # libsPos1 = if dirExtra then "" else libsStr
  # libsPos2 = if dirExtra then libsStr else ""
  <<
  # Makefile generated by OpenModelica
  
  CC=<%makefileParams.ccompiler%>
  CXX=<%makefileParams.cxxcompiler%>
  LINK=<%makefileParams.linker%>
  EXEEXT=<%makefileParams.exeext%>
  DLLEXT=<%makefileParams.dllext%>
  CFLAGS= -I"<%makefileParams.omhome%>/include/omc" <%makefileParams.cflags%>
  LDFLAGS= -L"<%makefileParams.omhome%>/lib/omc" <%makefileParams.ldflags%>
  
  .PHONY: <%modelInfo.name%>
  <%modelInfo.name%>: <%modelInfo.name%>.cpp
  <%\t%> $(CXX) $(CFLAGS) -I. -o <%modelInfo.name%>$(EXEEXT) <%modelInfo.name%>.cpp <%dirExtra%> <%libsPos1%> -lsim $(LDFLAGS) -lf2c ${SENDDATALIBS} <%libsPos2%>
  >>
end simulationMakefile;


template functionsFile(list<Function> functions,
                       list<RecordDeclaration> extraRecordDecls)
 "Generates the contents of the main C file for the function case."
::=
  <<
  #include "modelica.h"
  #include <stdio.h>
  #include <stdlib.h>
  #include <errno.h>
  
  #if defined(_MSC_VER)
    #define DLLExport   __declspec( dllexport )
  #else
    #define DLLExport /* nothing */
  #endif
  
  #if !defined(MODELICA_ASSERT)
    #define MODELICA_ASSERT(cond,msg) { if (!(cond)) fprintf(stderr,"Modelica Assert: %s!\n", msg); }
  #endif
  #if !defined(MODELICA_TERMINATE)
    #define MODELICA_TERMINATE(msg) { fprintf(stderr,"Modelica Terminate: %s!\n", msg); fflush(stderr); }
  #endif
  
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  /* Header */
  <%externalFunctionIncludes(functions)%>
  <%functionHeaders(functions)%>
  <%extraRecordDecls of rd: recordDeclaration(rd) \n%>
  /* End Header */
  
  /* Body */
  <%functionBodies(functions)%>
  /* End Body */
  
  #ifdef __cplusplus
  }
  #endif
  >>
end functionsFile;


template functionsMakefile(FunctionCode fnCode)
 "Generates the contents of the makefile for the function case."
::=
match fnCode
case FUNCTIONCODE(makefileParams=MAKEFILE_PARAMS) then
  # libsStr = (makefileParams.libs of lib: lib " ")
  <<
  # Makefile generated by OpenModelica
  
  CC=<%makefileParams.ccompiler%>
  CXX=<%makefileParams.cxxcompiler%>
  LINK=<%makefileParams.linker%>
  EXEEXT=<%makefileParams.exeext%>
  DLLEXT=<%makefileParams.dllext%>
  CFLAGS= -I"<%makefileParams.omhome%>/include" <%makefileParams.cflags%>
  LDFLAGS= -L"<%makefileParams.omhome%>/lib" <%makefileParams.ldflags%>
  
  .PHONY: <%name%>
  <%name%>: <%name%>.c
  <%\t%> $(LINK) $(CFLAGS) -o <%name%>$(DLLEXT) <%name%>.c <%libsStr%> $(LDFLAGS) -lm
  >>
end functionsMakefile;


template cref(ComponentRef cref)
 "Generates C equivalent name for component reference.
  Most of the cases are CREF_IDENT where the name has already been converted
  in a C-specific way. This should perhaps change in the future so that all
  transformations are done in templates."
::=
  match cref
  case CREF_IDENT then '<%ident%>'
  case CREF_QUAL  then '<%ident%>.<%cref(componentRef)%>'
  case _          then "CREF_NOT_IDENT_OR_QUAL"
end cref;


template crefWithSubscript(ComponentRef cref)
 "Generates the name of a variable for variable name array.
  Only works for CREF_IDENT."
::=
  match cref
  case CREF_IDENT then '<%ident%><%subscriptsTpl(subscriptLst)%>'
  case _          then "CREF_NOT_IDENT"
end crefWithSubscript;


template subscriptsTpl(list<Subscript> subscripts)
 "Generares subscript part of the name."
::=
  match subscripts
  case {}         then ""
  case subscripts then '[<%subscripts of s: subscriptTpl(s) ","%>]'
end subscriptsTpl;


template subscriptTpl(Subscript subscript)
 "Generates a single subscript.
  Only works for contstant integer indicies."
::=
  match subscript
  case INDEX then (
    match exp
    case ICONST then integer
    case _      then "SUBSCRIPT_NOT_CONSTANT"
  )
  case _     then "SUBSCRIPT_NOT_CONSTANT"
end subscriptTpl;
 

template dotPath(Path path)
 "Generates paths with components separated by dots."
::=
  match path
  case QUALIFIED      then '<%name%>.<%dotPath(path)%>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)
end dotPath;


template underscorePath(Path path)
 "Generate paths with components separated by underscores."
::=
  match path
  case QUALIFIED then
    '<%System.stringReplace(name, "_", "__")%>_<%underscorePath(path)%>'
  case IDENT then
    System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then
    underscorePath(path)
end underscorePath;


template externalFunctionIncludes(list<Function> functions)
 "Generates external includes part in function files."
::=
  <<
  #ifdef __cplusplus
  extern "C" {
  #endif
  <%functions of EXTERNAL_FUNCTION:
    (includes of include: include "\n")
  "\n"%>
  #ifdef __cplusplus
  }
  #endif
  >>
end externalFunctionIncludes;


template functionHeaders(list<Function> functions)
 "Generates function header part in function files."
::=
  (functions of fn:
    match fn
    case FUNCTION then
      <<
      <%recordDecls of rd: recordDeclaration(rd) \n%>
      <%functionHeader(underscorePath(name), functionArguments, outVars)%>
      >> 
    case EXTERNAL_FUNCTION then
      <<
      <%recordDecls of rd: recordDeclaration(rd) \n%>
      <%functionHeader(underscorePath(name), funArgs, outVars)%>
  
      <%extFunDef(fn)%>
      >> 
    case RECORD_CONSTRUCTOR then
      # fname = underscorePath(name)
      # funArgsStr = (funArgs of var as VARIABLE:
          '<%varType(var)%> <%cref(name)%>'
        ", ")
      <<
      <%recordDecls of rd: recordDeclaration(rd) \n%>
      #define <%fname%>_rettype_1 targ1
      typedef struct <%fname%>_rettype_s {
        struct <%fname%> targ1;
      } <%fname%>_rettype;
      
      DLLExport 
      <%fname%>_rettype _<%fname%>(<%funArgsStr%>);
      >> 
  "\n")
end functionHeaders;


template recordDeclaration(RecordDeclaration recDecl)
 "Generates structs for a record declaration."
::=
  match recDecl
  case RECORD_DECL_FULL then
    <<
    struct <%name%> {
      <%variables of var as VARIABLE: '<%varType(var)%> <%cref(var.name)%>;' "\n"%>
    };
    <%recordDefinition(dotPath(defPath),
                      underscorePath(defPath),
                      (variables of VARIABLE: '"<%cref(name)%>"' ","))%>
    >> 
  case RECORD_DECL_DEF then
    <<
    <%recordDefinition(dotPath(path),
                      underscorePath(path),
                      (fieldNames of name: '"<%name%>"' ","))%>
    >>
end recordDeclaration;


template recordDefinition(String origName, String encName, String fieldNames)
 "Generates the definition struct for a record declaration."
::=
  <<
  const char* <%encName%>__desc__fields[] = {<%fieldNames%>};
  struct record_description <%encName%>__desc = {
    "<%encName%>", /* package_record__X */
    "<%origName%>", /* package.record_X */
    <%encName%>__desc__fields
  };
  >>
end recordDefinition;


template functionHeader(String fname, list<Variable> fargs, list<Variable> outVars)
 "Generates function header for a Modelica/MetaModelica function."
::=
  # fargsStr = (fargs of var as VARIABLE: '<%varType(var)%> <%cref(name)%>' ", ")
  <<
  <%outVars of VARIABLE: '#define <%fname%>_rettype_<%i1%> targ<%i1%>' \n%>
  typedef struct <%fname%>_rettype_s 
  {
    <%outVars of var as VARIABLE:
      # dimStr = if ty is ET_ARRAY then
          '[<%arrayDimensions of dim: if dim is SOME(d) then d else ":" ", "%>]'
      '<%varType(var)%> targ<%i1%>; /* <%cref(name)%><%dimStr%> */'
    "\n"%>
  } <%fname%>_rettype;
  
  DLLExport 
  int in_<%fname%>(type_description * inArgs, type_description * outVar);
  
  DLLExport 
  <%fname%>_rettype _<%fname%>(<%fargsStr%>);
  >>
end functionHeader;


template extFunDef(Function fn)
 "Generates function header for an external function."
::=
match fn
case EXTERNAL_FUNCTION then
  # fargsStr = (extArgs of arg: extFunDefArg(arg) ", ")
  <<
  extern <%extReturnType(extReturn)%> <%extName%>(<%fargsStr%>);
  >>
end extFunDef;


template extReturnType(SimExtArg extArg)
 "Generates return type for external function."
::=
  match extArg
  case SIMEXTARG   then extType(type_)
  case SIMNOEXTARG then "void"
end extReturnType;


template extType(ExpType type)
 "Generates type for external function argument or return value."
::=
  match type
  case ET_INT         then "int"
  case ET_REAL        then "double"
  case ET_STRING      then "const char*"
  case ET_BOOL        then "int"
  case ET_ARRAY       then extType(ty)
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ)
                      then "void *"
  case ET_COMPLEX(complexClassType=RECORD(path=rname))
                      then 'struct <%underscorePath(rname)%>'
  case ET_METAOPTION
  case ET_LIST
  case ET_METATUPLE
  case ET_UNIONTYPE
  case ET_POLYMORPHIC
  case ET_META_ARRAY
  case ET_BOXED       then "void*"
  case _              then "OTHER_EXT_TYPE"
end extType;


template extFunDefArg(SimExtArg extArg)
 "Generates the definition of an external function argument.
  Assume that language is C for now."
::=
  match extArg
  case SIMEXTARG(cref=c, isInput=ii, isArray=ia, type_=t) then
    # name = cref(c)
    # typeStr = if ii then
        if ia then
          if extType(t) is "const char*" then // For string arrays
            'const char* const *'
          else
            'const <%extType(t)%> *'
        else
          '<%extType(t)%>'
      else
        '<%extType(t)%>*'
    <<
    <%typeStr%> <%name%>
    >>
  case SIMEXTARGEXP then
    # typeStr = extType(type_)
    <<
    <%typeStr%>
    >>
  case SIMEXTARGSIZE(cref=c) then
    # name = cref(c)
    # eStr = daeExpToString(exp)
    <<
    size_t <%name%>_<%eStr%>
    >>
end extFunDefArg;


template daeExpToString(Exp exp)
 "Helper to extFunDefArg.
  This only works for constants (or else the name of a temporary variable is
  returned)."
::=
  # preExp = "" /*BUFD*/
  # varDecls = "" /*BUFD*/
  daeExp(exp, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
end daeExpToString;


template functionBodies(list<Function> functions)
 "Generates the body for a set of functions."
::=
  (functions of fn: functionBody(fn) "\n")
end functionBodies;


template functionBody(Function fn)
 "Generates the body for a function."
::=
  match fn
  case fn as FUNCTION           then functionBodyRegularFunction(fn)
  case fn as EXTERNAL_FUNCTION  then functionBodyExternalFunction(fn)
  case fn as RECORD_CONSTRUCTOR then functionBodyRecordConstructor(fn)
end functionBody;


template functionBodyRegularFunction(Function fn)
 "Generates the body for a Modelica/MetaModelica function."
::=
match fn
case FUNCTION then
  # System.tmpTickReset(1)
  # fname = underscorePath(name)
  # retType = '<%fname%>_rettype'
  # varDecls = "" /*BUFD*/
  # varInits = "" /*BUFD*/
  # retVar = tempDecl(retType, varDecls /*BUFC*/)
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # _ = (variableDeclarations of var:
      varInit(var, "", i1, varDecls /*BUFC*/, varInits /*BUFC*/)
    )
  # bodyPart = (body of stmt : funStatement(stmt, varDecls /*BUFC*/) \n)
  # outVarInits = "" /*BUFD*/
  # outVarsStr = (outVars of var:
      varOutput(var, retVar, i1, varDecls /*BUFC*/, outVarInits /*BUFC*/)
    )
  <<
  <%retType%> _<%fname%>(<%functionArguments of VARIABLE: '<%expTypeArrayIf(ty)%> <%cref(name)%>' ", "%>)
  {
    <%varDecls%>
    <%outVarInits%>
    <%stateVar%> = get_memory_state();

    <%varInits%>

    <%bodyPart%>
    
    _return:
    <%outVarsStr%>
    restore_memory_state(<%stateVar%>);
    return <%retVar%>;
  }

  int in_<%fname%>(type_description * inArgs, type_description * outVar)
  {
    <%functionArguments of VARIABLE: '<%expTypeArrayIf(ty)%> <%cref(name)%>;' "\n"%>
    <%retType%> out;
    <%functionArguments of arg as VARIABLE: readInVar(arg) "\n"%>
    out = _<%fname%>(<%functionArguments of VARIABLE: cref(name) ", "%>);
    <%if outVars then (outVars of var as VARIABLE: writeOutVar(var, i1) "\n") else "write_noretcall(outVar);"%>
    return 0;
  }
  >>
end functionBodyRegularFunction;


template functionBodyExternalFunction(Function fn)
 "Generates the body for an external fuction (just a wrapper)."
::=
match fn
case EXTERNAL_FUNCTION then
  # System.tmpTickReset(1)
  # fname = underscorePath(name)
  # retType = '<%fname%>_rettype'
  # preExp = "" /*BUFD*/
  # varDecls = "" /*BUFD*/
  # outputAlloc = "" /*BUFD*/
  # callPart = extFunCall(fn, preExp /*BUFC*/, varDecls /*BUFC*/)
  # _ = (outVars of var:
      varInit(var, "out", i1, varDecls /*BUFC*/, outputAlloc /*BUFC*/)
    )
  <<
  int in_<%fname%>(type_description * inArgs, type_description * outVar)
  {
    <%funArgs of VARIABLE: '<%expTypeArrayIf(ty)%> <%cref(name)%>;' "\n"%>
    <%retType%> out;
    <%funArgs of arg as VARIABLE: readInVar(arg) "\n"%>
    out = _<%fname%>(<%funArgs of VARIABLE: cref(name) ", "%>);
    <%outVars of var as VARIABLE: writeOutVar(var, i1) "\n"%>
    return 0;
  }

  <%retType%> _<%fname%>(<%funArgs of VARIABLE: '<%expTypeArrayIf(ty)%> <%cref(name)%>' ", "%>)
  {
    <%varDecls%>
    <%retType%> out;
    <%outputAlloc%>
    <%preExp%>
    <%callPart%>
    return out;
  }
  >>
end functionBodyExternalFunction;


template functionBodyRecordConstructor(Function fn)
 "Generates the body for a record constructor."
::=
match fn
case RECORD_CONSTRUCTOR then
  # System.tmpTickReset(1)
  # varDecls = "" /*BUFD*/
  # fname = underscorePath(name)
  # retType = '<%fname%>_rettype'
  # retVar = tempDecl(retType, varDecls /*BUFC*/)
  # structType = 'struct <%fname%>'
  # structVar = tempDecl(structType, varDecls /*BUFC*/)
  <<
  <%retType%> _<%fname%>(<%funArgs of VARIABLE: '<%expTypeArrayIf(ty)%> <%cref(name)%>' ", "%>)
  {
    <%varDecls%>
    <%funArgs of VARIABLE: '<%structVar%>.<%cref(name)%> = <%cref(name)%>;' "\n"%>
    <%retVar%>.targ1 = <%structVar%>;
    return <%retVar%>;
  }
  >>
end functionBodyRecordConstructor;


template readInVar(Variable var)
 "Generates code for reading a variable from inArgs."
::=
  match var
  case VARIABLE(name=cr, ty=ET_COMPLEX(complexClassType=RECORD)) then
    <<
    if (read_modelica_record(&inArgs, <%readInVarRecordMembers(ty, cref(cr))%>)) return 1;
    >>
  case VARIABLE then
    <<
    if (read_<%expTypeArrayIf(ty)%>(&inArgs, &<%cref(name)%>)) return 1;
    >>
end readInVar;


template readInVarRecordMembers(ExpType type, String prefix)
 "Helper to readInVar."
::=
match type
case ET_COMPLEX(varLst=vl) then
  (vl of subvar as COMPLEX_VAR:
    if tp is ET_COMPLEX then
      # newPrefix = '<%prefix%>.<%subvar.name%>'
      readInVarRecordMembers(tp, newPrefix)
    else
      '&(<%prefix%>.<%subvar.name%>)'
  ", ")
end readInVarRecordMembers;


template writeOutVar(Variable var, Integer index)
 "Generates code for writing a variable to outVar."
::=
  match var
  case VARIABLE(ty=ET_COMPLEX(complexClassType=RECORD)) then
    <<
    write_modelica_record(outVar, <%writeOutVarRecordMembers(ty, index, "")%>);
    >>
  case VARIABLE then
    <<
    write_<%varType(var)%>(outVar, &out.targ<%index%>);
    >>
end writeOutVar;


template writeOutVarRecordMembers(ExpType type, Integer index, String prefix)
 "Helper to writeOutVar."
::=
match type
case ET_COMPLEX(varLst=vl, name=n) then
  # basename = underscorePath(n)
  # args = (vl of subvar as COMPLEX_VAR:
      if tp is ET_COMPLEX then
        # newPrefix = '<%prefix%>.<%subvar.name%>'
        '<%expTypeRW(tp)%>, <%writeOutVarRecordMembers(tp, index, newPrefix)%>'
      else
        '<%expTypeRW(tp)%>, &(out.targ<%index%><%prefix%>.<%subvar.name%>)'
    ", ")
  <<
  &<%basename%>__desc<%if args then ', <%args%>'%>, TYPE_DESC_NONE
  >>
end writeOutVarRecordMembers;


template varInit(Variable var, String outStruct, Integer i, Text varDecls /*BUFP*/,
        Text varInits /*BUFP*/)
 "Generates code to initialize variables.
  Does not return anything: just appends declarations to buffers."
::=
match var
case var as VARIABLE then
  # varDecls += if outStruct then "" else '<%varType(var)%> <%cref(var.name)%>;<%\n%>'
  # varName = if outStruct then '<%outStruct%>.targ<%i%>' else '<%cref(var.name)%>'
  # instDimsInit = (instDims of exp:
      daeExp(exp, contextOther, varInits /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  if instDims then
    # varInits += 'alloc_<%expTypeShort(var.ty)%>_array(&<%varName%>, <%listLength(instDims)%>, <%instDimsInit%>);<%\n%>'
    ()
  else
    ()
end varInit;


template varOutput(Variable var, String dest, Integer i, Text varDecls /*BUFP*/,
          Text varInits /*BUFP*/)
 "Generates code to copy result value from a function to dest."
::=
match var
case var as VARIABLE then
  # instDimsInit = (instDims of exp:
      daeExp(exp, contextOther, varInits /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  if instDims then
    # varInits += 'alloc_<%expTypeShort(var.ty)%>_array(&<%dest%>.targ<%i%>, <%listLength(instDims)%>, <%instDimsInit%>);<%\n%>'
    <<
    copy_<%expTypeShort(var.ty)%>_array_data(&<%cref(var.name)%>, &<%dest%>.targ<%i%>);
    >>
  else
    <<
    <%dest%>.targ<%i%> = <%cref(var.name)%>;
    >>
end varOutput;


template extFunCall(Function fun, Text preExp /*BUFP*/, Text varDecls /*BUFP*/)
 "Generates the call to an external function."
::=
match fun
case EXTERNAL_FUNCTION then
  # fname = underscorePath(name)
  # args = (extArgs of arg:
      extArg(arg, preExp /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  # returnAssign = if extReturn is SIMEXTARG(cref=c) then
      '<%cref(c)%>_ext = '
    else
      ""
  <<
  <%extArgs of arg: extFunCallVardecl(arg, varDecls /*BUFC*/) "\n"%>
  <%if extReturn is SIMEXTARG then extFunCallVardecl(extReturn, varDecls /*BUFC*/)%>
  <%returnAssign%><%extName%>(<%args%>);
  <%extArgs of arg: extFunCallVarcopy(arg) "\n"%>
  <%if extReturn is SIMEXTARG then extFunCallVarcopy(extReturn)%>
  >>
end extFunCall;


template extFunCallVardecl(SimExtArg arg, Text varDecls /*BUFP*/)
 "Helper to extFunCall."
::=
  match arg
  case SIMEXTARG(isInput=true, isArray=false, type_=ty, cref=c) then
    if ty is ET_STRING then
      ""
    else
      # varDecls += '<%extType(ty)%> <%cref(c)%>_ext;<%\n%>'
      <<
      <%cref(c)%>_ext = (<%extType(ty)%>)<%cref(c)%>;
      >>
  case SIMEXTARG(outputIndex=oi, isArray=false, type_=ty, cref=c) then
    if oi is 0 then
      ""
    else
      # varDecls += '<%extType(ty)%> <%cref(c)%>_ext;<%\n%>'
      ""
end extFunCallVardecl;


template extFunCallVarcopy(SimExtArg arg)
 "Helper to extFunCall."
::=
match arg
case SIMEXTARG(outputIndex=oi, isArray=false, type_=ty, cref=c) then
  if oi is 0 then
    ""
  else
    <<
    out.targ<%oi%> = (<%expTypeModelica(ty)%>)<%cref(c)%>_ext;
    >>
end extFunCallVarcopy;


template extArg(SimExtArg extArg, Text preExp /*BUFP*/, Text varDecls /*BUFP*/)
 "Helper to extFunCall."
::=
  match extArg
  case SIMEXTARG(cref=c, outputIndex=oi, isArray=true, type_=t) then
    # name = if oi then 'out.targ<%oi%>' else cref(c)
    # shortTypeStr = expTypeShort(t)
    'data_of_<%shortTypeStr%>_array(&(<%name%>))'
  case SIMEXTARG(cref=c, isInput=ii, outputIndex=oi, type_=t) then
    # prefix = if oi then "&" else ""
    # suffix = if oi then "_ext"
               else if t is ET_STRING then ""
               else "_ext"
    '<%prefix%><%cref(c)%><%suffix%>'
  case SIMEXTARGEXP then
    daeExp(exp, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
  case SIMEXTARGSIZE(cref=c) then
    # typeStr = expTypeShort(type_)
    # name = if outputIndex then 'out.targ<%outputIndex%>' else cref(c)
    # dim = daeExp(exp, contextOther, preExp /*BUFC*/, varDecls /*BUFC*/)
    'size_of_dimension_<%typeStr%>_array(<%name%>, <%dim%>)'
end extArg;


template funStatement(Statement stmt, Text varDecls /*BUFP*/)
 "Generates function statements."
::=
  match stmt
  case ALGORITHM then
    (statementLst of stmt:
      algStatement(stmt, contextOther, varDecls /*BUFC*/)
    "\n") 
  case _ then
    "NOT IMPLEMENTED FUN STATEMENT"
end funStatement;


template algStatement(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates an algorithm statement."
::=
  match stmt
  case s as STMT_ASSIGN       then algStmtAssign(s, context, varDecls /*BUFC*/)
  case s as STMT_ASSIGN_ARR   then algStmtAssignArr(s, context, varDecls /*BUFC*/)
  case s as STMT_TUPLE_ASSIGN then algStmtTupleAssign(s, context, varDecls /*BUFC*/)
  case s as STMT_IF           then algStmtIf(s, context, varDecls /*BUFC*/)
  case s as STMT_FOR          then algStmtFor(s, context, varDecls /*BUFC*/)
  case s as STMT_WHILE        then algStmtWhile(s, context, varDecls /*BUFC*/)
  case s as STMT_ASSERT       then algStmtAssert(s, context, varDecls /*BUFC*/)
  case s as STMT_WHEN         then algStmtWhen(s, context, varDecls /*BUFC*/)
  case s as STMT_MATCHCASES   then algStmtMatchcases(s, context, varDecls /*BUFC*/)
  case s as STMT_BREAK        then 'break;<%\n%>'
  case s as STMT_TRY          then algStmtTry(s, context, varDecls /*BUFC*/)
  case s as STMT_CATCH        then algStmtCatch(s, context, varDecls /*BUFC*/)
  case s as STMT_THROW        then 'throw 1;<%\n%>'
  case s as STMT_RETURN       then 'goto _return;<%\n%>'
  case s as STMT_NORETCALL    then algStmtNoretcall(s, context, varDecls /*BUFC*/)
  case _                      then "NOT IMPLEMENTED ALG STATEMENT"
end algStatement;


template algStmtAssign(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates an assigment algorithm statement."
::=
  match stmt
  case STMT_ASSIGN(exp1=CREF(componentRef=WILD), exp=e) then
    # preExp = ""  /*BUFD*/
    # expPart = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <%preExp%>
    >>
  case STMT_ASSIGN(exp1=CREF) then
    # preExp = "" /*BUFD*/
    # varPart = scalarLhsCref(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <%preExp%>
    <%varPart%> = <%expPart%>;
    >>
  case STMT_ASSIGN then
    # preExp = "" /*BUFD*/
    # expPart1 = daeExp(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # expPart2 = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    <%preExp%>
    <%expPart1%> = <%expPart2%>;
    >>
end algStmtAssign;


template algStmtAssignArr(DAE.Statement stmt, Context context,
                 Text varDecls /*BUFP*/)
 "Generates an array assigment algorithm statement."
::=
match stmt
case STMT_ASSIGN_ARR(exp=e, componentRef=cref, type_=t) then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # ispec = indexSpecFromCref(cref, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  if ispec then
    <<
    <%preExp%>
    indexed_assign_<%expTypeArray(t)%>(&<%expPart%>, &<%cref(cref)%>, &<%ispec%>);
    >>
  else
    <<
    <%preExp%>
    copy_<%expTypeArray(t)%>_data(&<%expPart%>, &<%cref(cref)%>);
    >>
end algStmtAssignArr;


template algStmtTupleAssign(DAE.Statement stmt, Context context,
                   Text varDecls /*BUFP*/)
 "Generates a tuple assigment algorithm statement."
::=
match stmt
case STMT_TUPLE_ASSIGN(exp=CALL) then
  # preExp = "" /*BUFD*/
  # retStruct = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  <%expExpLst of cr as CREF:
    # lhsStr = scalarLhsCref(cr, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    '<%lhsStr%> = <%retStruct%>.targ<%i1%>;'
  "\n"%>
  >>
end algStmtTupleAssign;


template algStmtIf(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates an if algorithm statement."
::=
match stmt
case STMT_IF then
  # preExp = "" /*BUFD*/
  # condExp = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  if (<%condExp%>) {
    <%statementLst of stmt: algStatement(stmt, context, varDecls /*BUFC*/) "\n"%>
  }
  <%elseExpr(else_, context, varDecls /*BUFC*/)%>
  >>
end algStmtIf;


template algStmtFor(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a for algorithm statement."
::=
  match stmt
  case s as STMT_FOR(exp=rng as RANGE) then
    algStmtForRange(s, context, varDecls /*BUFC*/)
  case s as STMT_FOR then
    algStmtForGeneric(s, context, varDecls /*BUFC*/)
end algStmtFor;


template algStmtForRange(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a for algorithm statement where range is RANGE."
::=
match stmt
case STMT_FOR(exp=rng as RANGE) then
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
  # identType = expType(type_, boolean)
  # r1 = tempDecl(identType, varDecls /*BUFC*/)
  # r2 = tempDecl(identType, varDecls /*BUFC*/)
  # r3 = tempDecl(identType, varDecls /*BUFC*/)
  # preExp = "" /*BUFD*/
  # er1 = daeExp(rng.exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # er2 = if rng.expOption is SOME(eo) then
      daeExp(eo, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    else
      "(1)"
  # er3 = daeExp(rng.range, context, preExp /*BUFC*/, varDecls /*BUFC*/) 
  <<
  <%preExp%>
  <%r1%> = <%er1%>; <%r2%> = <%er2%>; <%r3%> = <%er3%>;
  {
  <%identType%> <%ident%>;

    for (<%ident%> = <%r1%>; in_range_<%expTypeShort(type_)%>(<%ident%>, <%r1%>, <%r3%>); <%ident%> += <%r2%>) {
      <%stateVar%> = get_memory_state();
      <%statementLst of stmt: algStatement(stmt, context, varDecls /*BUFC*/) "\n"%>
      restore_memory_state(<%stateVar%>);
    }
  } /*end for*/
  >>
end algStmtForRange;


template algStmtForGeneric(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a for algorithm statement where range is not RANGE."
::=
match stmt
case STMT_FOR then
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # arrayType = expTypeArray(type_)
  # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
  # tvar = tempDecl("int", varDecls /*BUFC*/)
  # identType = expType(type_, boolean)
  # ivar = tempDecl(identType, varDecls /*BUFC*/)
  # preExp = "" /*BUFD*/
  # evar = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # statements = (statementLst of stmt:
      algStatement(stmt, context, varDecls /*BUFC*/)
    "\n")
  # id = '<%ident%>'
  # stmtStuff = if boolean then
      'simple_index_alloc_<%identType%>1(&<%evar%>, <%tvar%>, &<%ivar%>);'
    else
      '<%id%> = *(<%arrayType%>_element_addr1(&<%evar%>, 1, <%tvar%>));'
  <<
  <%preExp%>
  {
  <%identType%> <%ident%>;

    for (<%tvar%> = 1; <%tvar%> <= size_of_dimension_<%arrayType%>(<%evar%>, 1); ++<%tvar%>) {
      <%stateVar%> = get_memory_state();
      <%stmtStuff%>
      <%statements%>
      restore_memory_state(<%stateVar%>);
    }
  } /* end for*/
  >>
end algStmtForGeneric;


template algStmtWhile(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a while algorithm statement."
::=
match stmt
case STMT_WHILE then
  # preExp = "" /*BUFD*/
  # var = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  while (1) {
    <%preExp%>
    if (!<%var%>) break;
    <%statementLst of stmt: algStatement(stmt, context, varDecls /*BUFC*/) "\n"%>
  }
  >>
end algStmtWhile;


template algStmtAssert(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates an assert algorithm statement."
::=
match stmt
case STMT_ASSERT then
  # preExp = "" /*BUFD*/
  # condVar = daeExp(cond, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # msgVar = daeExp(msg, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  MODELICA_ASSERT(<%condVar%>, <%msgVar%>);
  >>
end algStmtAssert;


template algStmtMatchcases(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a matchcases algorithm statement."
::=
match stmt
case STMT_MATCHCASES then
  # loopVar = tempDecl("modelica_integer", varDecls /*BUFC*/)
  # doneVar = tempDecl("modelica_integer", varDecls /*BUFC*/)
  # numCases = listLength(caseStmt)
  <<
  <%doneVar%> = 0;
  for (<%loopVar%>=0; 0==<%doneVar%> && <%loopVar%><<%numCases%>; <%loopVar%>++) {
    try {
      switch (<%loopVar%>) {
        <%caseStmt of e:
          # preExp = "" /*BUFD*/
          // the exp always seems to be a valueblock whose result should not be
          // used
          # _ = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
          <<
          case <%i0%>: {
            <%preExp%>
            <%doneVar%> = 1;
            break;
          };
          >>
        "\n"%>
      } /* end matchcontinue switch */
    } catch (int i) {
    }
  } /* end matchcontinue for */
  if (0 == <%doneVar%>) throw 1; /* Didn't end in a valid state */
  >>
end algStmtMatchcases;


template algStmtTry(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a try algorithm statement."
::=
match stmt
case STMT_TRY then
  # body = (tryBody of stmt:
      algStatement(stmt, context, varDecls /*BUFC*/)
    "\n")
  <<
  try {
    <%body%>
  }
  >>
end algStmtTry;


template algStmtCatch(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a catch algorithm statement."
::=
match stmt
case STMT_CATCH then
  # body = (catchBody of stmt:
      algStatement(stmt, context, varDecls /*BUFC*/)
    "\n")
  <<
  catch (int i) {
    <%body%>
  }
  >>
end algStmtCatch;


template algStmtNoretcall(DAE.Statement stmt, Context context, Text varDecls /*BUFP*/)
 "Generates a no return call algorithm statement."
::=
match stmt
case STMT_NORETCALL then
  # preExp = "" /*BUFD*/
  # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  <<
  <%preExp%>
  <%expPart%>;
  >>
end algStmtNoretcall;


template algStmtWhen(DAE.Statement when, Context context, Text varDecls /*BUFP*/)
 "Generates a when algorithm statement."
::=
match context
case SIMULATION(genDiscrete=true) then
  match when
  case STMT_WHEN then
    # preIf = algStatementWhenPre(when, varDecls /*BUFC*/)
    # statements = (statementLst of stmt:
        algStatement(stmt, context, varDecls /*BUFC*/)
      "\n")
    # else = algStatementWhenElse(elseWhen, varDecls /*BUFC*/)
    <<
    <%preIf%>
    if (<%helpVarIndices of idx: 'edge(localData->helpVars[<%idx%>])' " || "%>) {
      <%statements%>
    }
    <%else%>
    >>
end algStmtWhen;


template algStatementWhenPre(DAE.Statement stmt, Text varDecls /*BUFP*/)
 "Helper to algStmtWhen."
::=
  match stmt
  case STMT_WHEN(exp=ARRAY(array=el)) then
    # restPre = if elseWhen is SOME(ew) then
        algStatementWhenPre(ew, varDecls /*BUFC*/)
      else
        ""
    # preExp = "" /*BUFD*/
    # assignments = algStatementWhenPreAssigns(el, helpVarIndices,
                                               preExp /*BUFC*/,
                                               varDecls /*BUFC*/)
    <<
    <%preExp%>
    <%assignments%>
    <%restPre%>
    >>
  case when as STMT_WHEN then
    match helpVarIndices
    case {i} then
      # restPre = if when.elseWhen is SOME(ew) then
          algStatementWhenPre(ew, varDecls /*BUFC*/)
        else
          ""
      # preExp = "" /*BUFD*/
      # res = daeExp(when.exp, contextSimulationDescrete,
                     preExp /*BUFC*/, varDecls /*BUFC*/)
      <<
      <%preExp%>
      localData->helpVars[<%i%>] = <%res%>;
      <%restPre%>
      >>
end algStatementWhenPre;


template algStatementWhenElse(Option<DAE.Statement> stmt, Text varDecls /*BUFP*/)
 "Helper to algStmtWhen."
::=
match stmt
case SOME(when as STMT_WHEN) then
  # statements = (when.statementLst of stmt:
      algStatement(stmt, contextSimulationDescrete, varDecls /*BUFC*/)
    "\n")
  # else = algStatementWhenElse(when.elseWhen, varDecls /*BUFC*/)
  # elseCondStr = (when.helpVarIndices of idx:
      'edge(localData->helpVars[<%idx%>])'
    " || ")
  <<
  else if (<%elseCondStr%>) {
    <%statements%>
  }
  <%else%>
  >>
end algStatementWhenElse;


template algStatementWhenPreAssigns(list<Exp> exps, list<Integer> ints,
                           Text preExp /*BUFP*/, Text varDecls /*BUFP*/)
 "Helper to algStatementWhenPre.
  The lists exps and ints should be of the same length. Iterating over two
  lists like this is not so well supported in Susan, so it looks a bit ugly."
::=
  match exps
  case {} then ""
  case (firstExp :: restExps) then
    match ints
    case (firstInt :: restInts) then
      # rest = algStatementWhenPreAssigns(restExps, restInts,
                                          preExp /*BUFC*/, varDecls /*BUFC*/)
      # firstExpPart = daeExp(firstExp, contextSimulationDescrete,
                              preExp /*BUFC*/, varDecls /*BUFC*/)
      <<
      localData->helpVars[<%firstInt%>] = <%firstExpPart%>;
      <%rest%>
      >>
end algStatementWhenPreAssigns;


template indexSpecFromCref(ComponentRef cref, Context context, Text preExp /*BUFP*/,
                  Text varDecls /*BUFP*/)
 "Helper to algStmtAssignArr.
  Currently works only for CREF_IDENT."
::=
match cref
case CREF_IDENT(subscriptLst=subs as (_ :: _)) then
  daeExpCrefRhsIndexSpec(subs, context, preExp /*BUFC*/, varDecls /*BUFC*/)
end indexSpecFromCref;


template elseExpr(DAE.Else else_, Context context, Text varDecls /*BUFP*/)
 "Helper to algStmtIf."
 ::= 
  match else_
  case NOELSE then
    ()
  case ELSEIF then
    # preExp = "" /*BUFD*/
    # condExp = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    else {
      <%preExp%>
      if (<%condExp%>) {
        <%statementLst of stmt:
          algStatement(stmt, context, varDecls /*BUFC*/)
        "\n"%>
      }
      <%elseExpr(else_, context, varDecls /*BUFC*/)%>
    }
    >>
  case ELSE then
    <<
    else {
      <%statementLst of stmt:
        algStatement(stmt, context, varDecls /*BUFC*/)
      "\n"%>
    }
    >>
end elseExpr;

template scalarLhsCref(Exp cref, Context context, Text preExp /*BUFP*/,
              Text varDecls /*BUFP*/)
 "Generates the left hand side (for use on left hand side) of a component
  reference."
::=
  match cref
  case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
    if crefNoSub(cref.componentRef) then
      '<%cref(cref.componentRef)%>'
    else
      daeExpCrefRhs(cref, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case cref as CREF(componentRef=CREF_QUAL(subscriptLst=subs)) then
    '<%cref(cref.componentRef)%>'
  case _ then
    "ONLY IDENT SUPPORTED"
end scalarLhsCref;


template rhsCref(ComponentRef cref, ExpType ty)
 "Like cref but with cast if type is integer."
::=
  match cref
  case CREF_IDENT then '<%rhsCrefType(ty)%><%ident%>'
  case CREF_QUAL  then '<%rhsCrefType(ty)%><%ident%>.<%rhsCref(componentRef,ty)%>'
  case _          then "rhsCref:ERROR"
end rhsCref;


template rhsCrefType(ExpType type)
 "Helper to rhsCref."
::=
  match type
  case ET_INT then "(modelica_integer)"
  case _      then ""
end rhsCrefType;
  

template daeExp(Exp exp, Context context, Text preExp /*BUFP*/,
       Text varDecls /*BUFP*/)
 "Generates code for an expression."
::=
  match exp
  case e as ICONST         then integer
  case e as RCONST         then real
  case e as SCONST         then daeExpSconst(string, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as BCONST         then if bool then "(1)" else "(0)"
  case e as CREF           then daeExpCrefRhs(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as BINARY         then daeExpBinary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as UNARY          then daeExpUnary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as LBINARY        then daeExpLbinary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as LUNARY         then daeExpLunary(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as RELATION       then daeExpRelation(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as IFEXP          then daeExpIf(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as CALL           then daeExpCall(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as ARRAY          then daeExpArray(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as MATRIX         then daeExpMatrix(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as CAST           then daeExpCast(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as ASUB           then daeExpAsub(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as SIZE           then daeExpSize(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as REDUCTION      then daeExpReduction(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as VALUEBLOCK     then daeExpValueblock(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as LIST           then daeExpList(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as CONS           then daeExpCons(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as META_TUPLE     then daeExpMetaTuple(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as META_OPTION    then daeExpMetaOption(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case e as METARECORDCALL then daeExpMetarecordcall(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  case _                   then "UNKNOWN_EXP"
end daeExp;


template daeExpSconst(String string, Text preExp /*BUFP*/, Text varDecls /*BUFP*/)
 "Generates code for a string constant."
::=
  # strVar = tempDecl("modelica_string", varDecls /*BUFC*/)
  # escapedStr = Util.escapeModelicaStringToCString(string)
  # preExp += 'init_modelica_string(&<%strVar%>,"<%escapedStr%>");<%\n%>'
  strVar  
end daeExpSconst;


template daeExpCrefRhs(Exp exp, Context context, Text preExp /*BUFP*/,
                       Text varDecls /*BUFP*/)
 "Generates code for a component reference."
::=
  match exp
  case CREF(componentRef=cr, ty=ET_ENUMERATION) then
    getEnumIndexfromCref(cr)
  case cref as CREF(componentRef=cr, ty=ty) then
    # box = daeExpCrefRhsArrayBox(cref, context, preExp /*BUFC*/,
                                  varDecls /*BUFC*/)
    if box then
      box
    else if crefNoSub(cr) then
      # cast = if ty is ET_INT then "(modelica_integer)" else ""
      '<%cast%><%cref(cr)%>'
    else if crefSubIsScalar(cr) then
      // The array subscript results in a scalar
      # arrName = cref(cr)
      # arrayType = expTypeArray(ty)
      # dimsLenStr = listLength(crefSubs(cr))
      # dimsValuesStr = (crefSubs(cr) of INDEX:
          daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
        ", ")
      <<
      (*<%arrayType%>_element_addr(&<%arrName%>, <%dimsLenStr%>, <%dimsValuesStr%>))
      >>
    else
      // The array subscript denotes a slice
      # arrName = cref(cr)
      # arrayType = expTypeArray(ty)
      # tmp = tempDecl(arrayType, varDecls /*BUFC*/)
      # spec1 = daeExpCrefRhsIndexSpec(crefSubs(cr), context, preExp /*BUFC*/, varDecls /*BUFC*/)
      # preExp += 'index_alloc_<%arrayType%>(&<%arrName%>, &<%spec1%>, &<%tmp%>);<%\n%>'
      tmp
end daeExpCrefRhs;


template daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context,
                                Text preExp /*BUFP*/, Text varDecls /*BUFP*/)
 "Helper to daeExpCrefRhs."
::=
  # nridx_str = listLength(subs)
  # idx_str = (subs of sub:
      match sub
      case INDEX then
        # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
        <<
        (1), make_index_array(1, <%expPart%>), 'S'
        >>
      case WHOLEDIM then
        <<
        (1), (0), 'W'
        >>
      case SLICE then
        # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
        # tmp = tempDecl("modelica_integer", varDecls /*BUFC*/)
        # preExp += '<%tmp%> = size_of_dimension_integer_array(<%expPart%>, 1);<%\n%>'
        <<
        <%tmp%>, integer_array_make_index_array(&<%expPart%>), 'A'
        >>
    ", ")
  # tmp = tempDecl("index_spec_t", varDecls /*BUFC*/)
  # preExp += 'create_index_spec(&<%tmp%>, <%nridx_str%>, <%idx_str%>);<%\n%>'
  tmp
end daeExpCrefRhsIndexSpec;


template daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp /*BUFP*/,
                               Text varDecls /*BUFP*/)
 "Helper to daeExpCrefRhs."
::=
match exp
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = tempDecl(expTypeArray(aty), varDecls /*BUFC*/)
    # dimsLenStr = listLength(dims)
    # dimsValuesStr = (dims of dim as SOME(i): i ", ")
    # preExp += '<%expTypeShort(aty)%>_array_create(&<%tmpArr%>, &<%cref(cref.componentRef)%>, <%dimsLenStr%>, <%dimsValuesStr%>);<%\n%>'
    tmpArr
end daeExpCrefRhsArrayBox;


template daeExpBinary(Exp exp, Context context, Text preExp /*BUFP*/,
                      Text varDecls /*BUFP*/)
 "Generates code for a binary expression."
::=
match exp
case BINARY then
  # e1 = daeExp(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # e2 = daeExp(exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case ADD(ty = ET_STRING) then
    # tmpStr = tempDecl("modelica_string", varDecls /*BUFC*/)
    # preExp += 'cat_modelica_string(&<%tmpStr%>,&<%e1%>,&<%e2%>);<%\n%>'
    tmpStr
  case ADD then '(<%e1%> + <%e2%>)'
  case SUB then '(<%e1%> - <%e2%>)'
  case MUL then '(<%e1%> * <%e2%>)'
  case DIV then '(<%e1%> / <%e2%>)'
  case POW then 'pow((modelica_real)<%e1%>, (modelica_real)<%e2%>)'
  case ADD_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'add_alloc_<%type%>(&<%e1%>, &<%e2%>, &<%var%>);<%\n%>'
    '<%var%>'
  case SUB_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'sub_alloc_<%type%>(&<%e1%>, &<%e2%>, &<%var%>);<%\n%>'
    '<%var%>'
  case MUL_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'mul_alloc_<%type%>_scalar(&<%e1%>, <%e2%>, &<%var%>);<%\n%>'
    '<%var%>'
  case DIV_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'div_alloc_<%type%>_scalar(&<%e1%>, <%e2%>, &<%var%>);<%\n%>'
    '<%var%>'
  case MUL_MATRIX_PRODUCT then
    # typeShort = if ty is ET_ARRAY(ty=ET_INT) then "integer" else "real"
    # type = '<%typeShort%>_array'
    # var = tempDecl(type, varDecls /*BUFC*/)
    # preExp += 'mul_alloc_<%typeShort%>_matrix_product_smart(&<%e1%>, &<%e2%>, &<%var%>);<%\n%>'
    '<%var%>'
  case _ then "daeExpBinary:ERR"
end daeExpBinary;


template daeExpUnary(Exp exp, Context context, Text preExp /*BUFP*/,
                     Text varDecls /*BUFP*/)
 "Generates code for a unary expression."
::=
match exp
case UNARY then
  # e = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case UMINUS     then '(-<%e%>)'
  case UPLUS      then '(<%e%>)'
  case UMINUS_ARR(ty=ET_ARRAY(ty=ET_REAL, arrayDimensions={NONE})) then
    # preExp += 'usub_real_array(&<%e%>);<%\n%>'
    '<%e%>'
  case UMINUS_ARR then "unary minus for non-real arrays not implemented"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"
end daeExpUnary;


template daeExpLbinary(Exp exp, Context context, Text preExp /*BUFP*/,
                       Text varDecls /*BUFP*/)
 "Generates code for a logical binary expression."
::=
match exp
case LBINARY then
  # e1 = daeExp(exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # e2 = daeExp(exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case AND then '(<%e1%> && <%e2%>)'
  case OR  then '(<%e1%> || <%e2%>)'
  case _   then "daeExpLbinary:ERR"
end daeExpLbinary;


template daeExpLunary(Exp exp, Context context, Text preExp /*BUFP*/,
                      Text varDecls /*BUFP*/)
 "Generates code for a logical unary expression."
::=
match exp
case LUNARY then
  # e = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match operator
  case NOT then '(!<%e%>)'
end daeExpLunary;


template daeExpRelation(Exp exp, Context context, Text preExp /*BUFP*/,
                        Text varDecls /*BUFP*/)
 "Generates code for a relation expression."
::=
match exp
case rel as RELATION then
  # simRel = daeExpRelationSim(rel, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  if simRel then
    simRel
  else
    # e1 = daeExp(rel.exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # e2 = daeExp(rel.exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    match rel.operator
    case LESS(ty = ET_BOOL)        then '(!<%e1%> && <%e2%>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)         then '(<%e1%> < <%e2%>)'
    case LESS(ty = ET_REAL)        then '(<%e1%> < <%e2%>)'
    case GREATER(ty = ET_BOOL)     then '(<%e1%> && !<%e2%>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)      then '(<%e1%> > <%e2%>)'
    case GREATER(ty = ET_REAL)     then '(<%e1%> > <%e2%>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<%e1%> || <%e2%>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)       then '(<%e1%> <= <%e2%>)'
    case LESSEQ(ty = ET_REAL)      then '(<%e1%> <= <%e2%>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<%e1%> || !<%e2%>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)    then '(<%e1%> >= <%e2%>)'
    case GREATEREQ(ty = ET_REAL)   then '(<%e1%> >= <%e2%>)'
    case EQUAL(ty = ET_BOOL)       then '((!<%e1%> && !<%e2%>) || (<%e1%> && <%e2%>))'
    case EQUAL(ty = ET_STRING)     then '(!strcmp(<%e1%>, <%e2%>))'
    case EQUAL(ty = ET_INT)        then '(<%e1%> == <%e2%>)'
    case EQUAL(ty = ET_REAL)       then '(<%e1%> == <%e2%>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<%e1%> && <%e2%>) || (<%e1%> && !<%e2%>))'
    case NEQUAL(ty = ET_STRING)    then '(strcmp(<%e1%>, <%e2%>))'
    case NEQUAL(ty = ET_INT)       then '(<%e1%> != <%e2%>)'
    case NEQUAL(ty = ET_REAL)      then '(<%e1%> != <%e2%>)'
    case _                         then "daeExpRelation:ERR"
end daeExpRelation;


template daeExpRelationSim(Exp exp, Context context, Text preExp /*BUFP*/,
                           Text varDecls /*BUFP*/)
 "Helper to daeExpRelation."
::=
match exp
case rel as RELATION then
  match context
  case SIMULATION then
    # e1 = daeExp(rel.exp1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # e2 = daeExp(rel.exp2, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # res = tempDecl("modelica_boolean", varDecls /*BUFC*/)
    match rel.operator
    case LESS then
      # preExp += 'RELATIONLESS(<%res%>, <%e1%>, <%e2%>);<%\n%>'
      res
    case LESSEQ then
      # preExp += 'RELATIONLESSEQ(<%res%>, <%e1%>, <%e2%>);<%\n%>'
      res
    case GREATER then
      # preExp += 'RELATIONGREATER(<%res%>, <%e1%>, <%e2%>);<%\n%>'
      res
    case GREATEREQ then
      # preExp += 'RELATIONGREATEREQ(<%res%>, <%e1%>, <%e2%>);<%\n%>'
      res
end daeExpRelationSim;


template daeExpIf(Exp exp, Context context, Text preExp /*BUFP*/,
                  Text varDecls /*BUFP*/)
 "Generates code for an if expression."
::=
match exp
case IFEXP then
  # condExp = daeExp(expCond, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # condVar = tempDecl("modelica_boolean", varDecls /*BUFC*/)
  # resVarType = expTypeFromExpArrayIf(expThen)
  # resVar = tempDecl(resVarType, varDecls /*BUFC*/)
  # preExpThen = "" /*BUFD*/
  # eThen = daeExp(expThen, context, preExpThen /*BUFC*/, varDecls /*BUFC*/)
  # preExpElse = "" /*BUFD*/
  # eElse = daeExp(expElse, context, preExpElse /*BUFC*/, varDecls /*BUFC*/)
  # preExp +=  
  <<
  <%condVar%> = <%condExp%>;
  if (<%condVar%>) {
    <%preExpThen%>
    <%resVar%> = <%eThen%>;
  } else {
    <%preExpElse%>
    <%resVar%> = <%eElse%>;
  }<%\n%>
  >>
  resVar
//  An alternative solution?
//  <<
//  ((<%condVar%>)?<%eThen%>:<%eElse%>)
//  >>
end daeExpIf;


template daeExpCall(Exp call, Context context, Text preExp /*BUFP*/,
                    Text varDecls /*BUFP*/)
 "Generates code for a function call."
::=
  match call
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="DIVISION"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    # var1 = daeExp(e1, context, preExp, varDecls)
    # var2 = daeExp(e2, context, preExp, varDecls)
    # var3 = Util.escapeModelicaStringToCString(string)
    'DIVISION(<%var1%>,<%var2%>,"<%var3%>")'
  case CALL(tuple_=false, builtin=true, ty=ty, 
            path=IDENT(name="DIVISION_ARRAY_SCALAR"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # var1 = daeExp(e1, context, preExp, varDecls)
    # var2 = daeExp(e2, context, preExp, varDecls)
    # var3 = Util.escapeModelicaStringToCString(string)
    # preExp += 'division_alloc_<%type%>_scalar(&<%var1%>, <%var2%>, &<%var%>,"<%var3%>");<%\n%>'
    '<%var%>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    # retType = '<%expTypeArrayIf(arg.ty)%>'
    # retVar = tempDecl(retType, varDecls /*BUFC*/)
    # cast = if arg.ty is ET_INT then "(modelica_integer)" else ""
    # preExp += '<%retVar%> = <%cast%>pre(<%cref(arg.componentRef)%>);<%\n%>'
    '<%retVar%>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="max"), expLst={array}) then
    # expVar = daeExp(array, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<%expTypeFromExpArray(array)%>'
    # tvar = tempDecl(expTypeFromExpModelica(array), varDecls /*BUFC*/)
    # preExp += '<%tvar%> = max_<%arr_tp_str%>(&<%expVar%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="promote"), expLst={A, n}) then
    # var1 = daeExp(A, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # var2 = daeExp(n, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<%expTypeFromExpArray(A)%>'
    # tvar = tempDecl(arr_tp_str, varDecls /*BUFC*/)
    # preExp += 'promote_alloc_<%arr_tp_str%>(&<%var1%>, <%var2%>, &<%tvar%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="transpose"), expLst={A}) then
    # var1 = daeExp(A, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<%expTypeFromExpArray(A)%>'
    # tvar = tempDecl(arr_tp_str, varDecls /*BUFC*/)
    # preExp += 'transpose_alloc_<%arr_tp_str%>(&<%var1%>, &<%tvar%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="identity"), expLst={A}) then
    # var1 = daeExp(A, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # arr_tp_str = '<%expTypeFromExpArray(A)%>'
    # tvar = tempDecl(arr_tp_str, varDecls /*BUFC*/)
    # preExp += 'identity_alloc_<%arr_tp_str%>(<%var1%>, &<%tvar%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="abs"), expLst={s1}) then
    # tvar = tempDecl(expTypeFromExpModelica(s1), varDecls /*BUFC*/)
    # s1Exp = daeExp(s1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # preExp += '<%tvar%> = fabs(<%s1Exp%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="String"),
            expLst={s, minlen, leftjust, signdig}) then
    # tvar = tempDecl("modelica_string", varDecls /*BUFC*/)
    # sExp = daeExp(s, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # minlenExp = daeExp(minlen, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # leftjustExp = daeExp(leftjust, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # signdigExp = daeExp(signdig, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # typeStr = expTypeFromExpModelica(s)
    # preExp += '<%typeStr%>_to_modelica_string(&<%tvar%>, <%sExp%>, <%minlenExp%>, <%leftjustExp%>, <%signdigExp%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="delay"),
            expLst={ICONST(integer=index), e, d, delayMax}) then
    # tvar = tempDecl("modelica_real", varDecls /*BUFC*/)
    # var1 = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # var2 = daeExp(d, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # preExp += '<%tvar%> = delayImpl(<%index%>, <%var1%>, time, <%var2%>);<%\n%>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="mmc_get_field"),
            expLst={s1, ICONST(integer=i)}) then
    # tvar = tempDecl("modelica_metatype", varDecls /*BUFC*/)
    # expPart = daeExp(s1, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # preExp += '<%tvar%> = MMC_FETCH(MMC_OFFSET(MMC_UNTAGPTR(<%expPart%>), <%i%>));<%\n%>'
    tvar
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst of exp: '<%daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)%>' ", ")
    # funName = '<%underscorePath(path)%>'
    # preExp += '<%daeExpCallBuiltinPrefix(builtin)%><%funName%>(<%argStr%>);<%\n%>'
    '/* NORETCALL */'
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst of exp: '<%daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)%>' ", ")
    # funName = '<%underscorePath(path)%>'
    # retType = '<%funName%>_rettype'
    # retVar = tempDecl(retType, varDecls /*BUFC*/)
    # preExp += '<%retVar%> = <%daeExpCallBuiltinPrefix(builtin)%><%funName%>(<%argStr%>);<%\n%>'
    if builtin then '<%retVar%>' else '<%retVar%>.<%retType%>_1'
  // tuple calls (multiple return values)
  case CALL(tuple_=true) then
    # argStr = (expLst of exp: '<%daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)%>' ", ")
    # funName = '<%underscorePath(path)%>'
    # retType = '<%funName%>_rettype'
    # retVar = tempDecl(retType, varDecls /*BUFC*/)
    # preExp += '<%retVar%> = <%daeExpCallBuiltinPrefix(builtin)%><%funName%>(<%argStr%>);<%\n%>'
    retVar
end daeExpCall;


template daeExpCallBuiltinPrefix(Boolean builtin)
 "Helper to daeExpCall."
::=
  match builtin
  case true  then ""
  case false then "_"
end daeExpCallBuiltinPrefix;


template daeExpArray(Exp exp, Context context, Text preExp /*BUFP*/,
                     Text varDecls /*BUFP*/)
 "Generates code for an array expression."
::=
match exp
case ARRAY then
  # arrayTypeStr = '<%expTypeArray(ty)%>'
  # arrayVar = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
  # scalarPrefix = if scalar then "scalar_" else ""
  # scalarRef = if scalar then "&" else ""
  # params = (array of e:
      # prefix = if scalar then '(<%expTypeFromExpModelica(e)%>)' else '&'
      '<%prefix%><%daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)%>'
    ", ")
  # preExp += 'array_alloc_<%scalarPrefix%><%arrayTypeStr%>(&<%arrayVar%>, <%listLength(array)%>, <%params%>);<%\n%>'
  arrayVar
end daeExpArray;


template daeExpMatrix(Exp exp, Context context, Text preExp /*BUFP*/,
                      Text varDecls /*BUFP*/)
 "Generates code for a matrix expression."
::=
  match exp
  case MATRIX(scalar={{}}) then
    // special case for empty matrix: create dimensional array Real[0,1]
    # arrayTypeStr = expTypeArray(ty)
    # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # preExp += 'alloc_<%arrayTypeStr%>(&<%tmp%>, 2, 0, 1);<%\n%>'
    tmp
  case MATRIX(scalar={}) then
    // special case for empty array: create dimensional array Real[0,1]
    # arrayTypeStr = expTypeArray(ty)
    # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # preExp += 'alloc_<%arrayTypeStr%>(&<%tmp%>, 2, 0, 1);<%\n%>'
    tmp
  case m as MATRIX then
    # arrayTypeStr = expTypeArray(m.ty)
    # vars2 = "" /*BUFD*/
    # promote = "" /*BUFD*/
    # catAlloc = (m.scalar of row:
        # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
        # vars = daeExpMatrixRow(row, arrayTypeStr, context,
                                 promote /*BUFC*/, varDecls /*BUFC*/)
        # vars2 += ', &<%tmp%>'
        'cat_alloc_<%arrayTypeStr%>(2, &<%tmp%>, <%listLength(row)%><%vars%>);'
      "\n")
    # preExp += promote
    # preExp += catAlloc
    # preExp += "\n"
    # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # preExp += 'cat_alloc_<%arrayTypeStr%>(1, &<%tmp%>, <%listLength(m.scalar)%><%vars2%>);<%\n%>'
    tmp
end daeExpMatrix;


template daeExpMatrixRow(list<tuple<Exp,Boolean>> row, String arrayTypeStr,
                         Context context, Text preExp /*BUFP*/,
                         Text varDecls /*BUFP*/)
 "Helper to daeExpMatrix."
::=
  # varLstStr = "" /*BUFD*/
  # preExp2 = (row of col as (e, b):
      # scalarStr = if b then "scalar_" else ""
      # scalarRefStr = if b then "" else "&"
      # expVar = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
      # tmp = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
      # varLstStr += ', &<%tmp%>'
      'promote_<%scalarStr%><%arrayTypeStr%>(<%scalarRefStr%><%expVar%>, 2, &<%tmp%>);'
    "\n")
  # preExp2 += "\n"
  # preExp += preExp2
  varLstStr
end daeExpMatrixRow;


template daeExpCast(Exp exp, Context context, Text preExp /*BUFP*/,
                    Text varDecls /*BUFP*/)
 "Generates code for a cast expression."
::=
match exp
case CAST then
  # expVar = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  match ty
  case ET_INT   then '((modelica_int)<%expVar%>)' // Really int? Not integer?
  case ET_REAL  then '((modelica_real)<%expVar%>)'
  case ET_ARRAY then
    # arrayTypeStr = expTypeArray(ty)
    # tvar = tempDecl(arrayTypeStr, varDecls /*BUFC*/)
    # to = expTypeShort(ty)
    # from = expTypeFromExpShort(exp)
    # preExp += 'cast_<%from%>_array_to_<%to%>(&<%expVar%>, &<%tvar%>);<%\n%>'
    tvar
end daeExpCast;


template daeExpAsub(Exp exp, Context context, Text preExp /*BUFP*/,
                    Text varDecls /*BUFP*/)
 "Generates code for an asub expression."
::=
  match exp
  case ASUB(exp=RANGE(ty=t), sub={idx}) then
    'ASUB_EASY_CASE'
  case ASUB(exp=ASUB(
              exp=ASUB(
                exp=ASUB(exp=e, sub={ICONST(integer=i)}),
                sub={ICONST(integer=j)}),
              sub={ICONST(integer=k)}),
            sub={ICONST(integer=l)}) then
    'ASUB_4D'
  case ASUB(exp=ASUB(
              exp=ASUB(exp=e, sub={ICONST(integer=i)}),
              sub={ICONST(integer=j)}),
            sub={ICONST(integer=k)}) then
    'ASUB_3D'
  case ASUB(exp=ASUB(exp=e, sub={ICONST(integer=i)}),
            sub={ICONST(integer=j)}) then
    'ASUB_2D'
  case ASUB(exp=e, sub={ICONST(integer=i)}) then
    'ASUB_ARRAY'
  case ASUB(exp=cref as CREF, sub=subs) then
    # arrName = daeExpCrefRhs(buildCrefExpFromAsub(cref, subs), context,
                              preExp /*BUFC*/, varDecls /*BUFC*/)
    if context is SIMULATION then
      arrayScalarRhs(cref.ty, subs, arrName, context,
                     preExp /*BUFC*/, varDecls /*BUFC*/)
    else
      arrName
  case _ then
    'OTHER_ASUB'
end daeExpAsub;


template daeExpSize(Exp exp, Context context, Text preExp /*BUFP*/,
                    Text varDecls /*BUFP*/)
 "Generates code for a size expression."
::=
  match exp
  case SIZE(exp=CREF, sz=SOME(dim)) then
    # expPart = daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # dimPart = daeExp(dim, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # resVar = tempDecl("size_t", varDecls /*BUFC*/)
    # typeStr = '<%expTypeArray(exp.ty)%>'
    # preExp += '<%resVar%> = size_of_dimension_<%typeStr%>(<%expPart%>, <%dimPart%>);<%\n%>'
    resVar
  case _ then "size(X) not implemented"
end daeExpSize;


template daeExpReduction(Exp exp, Context context, Text preExp /*BUFP*/,
                         Text varDecls /*BUFP*/)
 "Generates code for a reduction expression."
::=
match exp
case REDUCTION(path=IDENT(name=op), range=RANGE) then
  # stateVar = tempDecl("state", varDecls /*BUFC*/)
  # identType = expTypeModelica(range.ty)
  # accFun = daeExpReductionFnName(op, identType)
  # startValue = daeExpReductionStartValue(op, identType)
  # res = tempDecl(identType, varDecls /*BUFC*/)
  # tmpExpPre = "" /*BUFD*/
  # tmpExpVar = daeExp(expr, context, tmpExpPre /*BUFC*/, varDecls /*BUFC*/)
  # cast = if accFun is "max" then
      "(modelica_real)"
    else if accFun is "min" then
      "(modelica_real)"
    else
      ""
  # r1 = tempDecl(identType, varDecls /*BUFC*/)
  # r2 = tempDecl(identType, varDecls /*BUFC*/)
  # r3 = tempDecl(identType, varDecls /*BUFC*/)
  # er1 = daeExp(range.exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # er2 = if range.expOption is SOME(eo) then
      daeExp(eo, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    else
      "(1)"
  # er3 = daeExp(range.range, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # preExp +=
    <<
    <%res%> = <%startValue%>;
    <%r1%> = <%er1%>; <%r2%> = <%er2%>; <%r3%> = <%er3%>;
    {
      <%identType%> <%ident%>;

      for (<%ident%> = <%r1%>; in_range_<%expTypeFromExpShort(expr)%>(<%ident%>, <%r1%>, <%r3%>); <%ident%> += <%r2%>) {
        <%stateVar%> = get_memory_state();
        <%tmpExpPre%>
        <%res%> = <%accFun%>(<%cast%>(<%res%>), <%cast%>(<%tmpExpVar%>));
        restore_memory_state(<%stateVar%>);
      }
    }
    >>
  res
end daeExpReduction;


template daeExpReductionFnName(String reduction_op, String type)
 "Helper to daeExpReduction."
::=
  match reduction_op
  case "sum" then (
    match type
    case "modelica_integer" then "intAdd"
    case "modelica_real" then "realAdd"
    case _ then "INVALID_TYPE"
  )
  case "product" then (
    match type
    case "modelica_integer" then "intMul"
    case "modelica_real" then "realMul"
    case _ then "INVALID_TYPE"
  )
  case _ then reduction_op
end daeExpReductionFnName;


template daeExpReductionStartValue(String reduction_op, String type)
 "Helper to daeExpReduction."
::=
  match reduction_op
  case "min" then (
    match type
    case "modelica_integer" then "1073741823"
    case "modelica_real" then "1.e60"
    case _ then "INVALID_TYPE"
  )
  case "max" then (
    match type
    case "modelica_integer" then "-1073741823"
    case "modelica_real" then "-1.e60"
    case _ then "INVALID_TYPE"
  )
  case "sum" then "0"
  case "product" then "1"
  case _ then "UNKNOWN_REDUCTION"
end daeExpReductionStartValue;


template daeExpValueblock(Exp exp, Context context, Text preExp /*BUFP*/,
                          Text varDecls /*BUFP*/)
 "Generates code for a valueblock expression."
::=
match exp
case exp as VALUEBLOCK then
  # preExpInner = "" /*BUFD*/
  # preExpRes = "" /*BUFD*/
  # varDeclsInner = "" /*BUFD*/
  # _ = (valueblockVars(exp) of var:
      varInit(var, "", 0, varDeclsInner /*BUFC*/, preExpInner /*BUFC*/)
    )
  # resType = expTypeModelica(ty)
  # res = tempDecl(expTypeModelica(ty), preExp /*BUFC*/)
  # stmts = (body of stmt:
      algStatement(stmt, context, varDeclsInner /*BUFC*/)
    "\n")
  # expPart = daeExp(result, context, preExpRes /*BUFC*/,
                     varDeclsInner /*BUFC*/)
  # preExp +=
      <<
      {
        <%varDeclsInner%>
        <%preExpInner%>
        <%stmts%>
        <%preExpRes%>
        <%res%> = <%expPart%>;
      }
      >>
  res
end daeExpValueblock;

// TODO: Optimize as in Codegen
// TODO: Use this function in other places where almost the same thing is hard
//       coded
template arrayScalarRhs(ExpType ty, list<Exp> subs, String arrName, Context context,
               Text preExp /*BUFP*/, Text varDecls /*BUFP*/)
 "Helper to daeExpAsub."
::=
  # arrayType = expTypeArray(ty)
  # dimsLenStr = listLength(subs)
  # dimsValuesStr = (subs of exp:
      daeExp(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  <<
  (*<%arrayType%>_element_addr(&<%arrName%>, <%dimsLenStr%>, <%dimsValuesStr%>))
  >>
end arrayScalarRhs;


template daeExpList(Exp exp, Context context, Text preExp /*BUFP*/,
                    Text varDecls /*BUFP*/)
 "Generates code for a meta modelica list expression."
::=
match exp
case LIST then
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # expPart = daeExpListToCons(valList, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # preExp += '<%tmp%> = <%expPart%>;<%\n%>'
  tmp
end daeExpList;


template daeExpListToCons(list<Exp> listItems, Context context, Text preExp /*BUFP*/,
                          Text varDecls /*BUFP*/)
 "Helper to daeExpList."
::=
  match listItems
  case {} then "mmc_mk_nil()"
  case e :: rest then
    # expPart = daeExpMetaHelperConstant(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    # restList = daeExpListToCons(rest, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    <<
    mmc_mk_cons(<%expPart%>, <%restList%>)
    >>
end daeExpListToCons;


template daeExpCons(Exp exp, Context context, Text preExp /*BUFP*/,
                    Text varDecls /*BUFP*/)
 "Generates code for a meta modelica cons expression."
::=
match exp
case CONS then
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # carExp = daeExpMetaHelperConstant(car, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # cdrExp = daeExp(cdr, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  # preExp += '<%tmp%> = mmc_mk_cons(<%carExp%>, <%cdrExp%>);<%\n%>'
  tmp
end daeExpCons;


template daeExpMetaTuple(Exp exp, Context context, Text preExp /*BUFP*/,
                         Text varDecls /*BUFP*/)
 "Generates code for a meta modelica tuple expression."
::=
match exp
case META_TUPLE then
  # start = daeExpMetaHelperBoxStart(listLength(listExp))
  # args = (listExp of e:
      daeExpMetaHelperConstant(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    ", ")
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # preExp += '<%tmp%> = mmc_mk_box<%start%>0, <%args%>);<%\n%>'
  tmp
end daeExpMetaTuple;


template daeExpMetaOption(Exp exp, Context context, Text preExp /*BUFP*/,
                          Text varDecls /*BUFP*/)
 "Generates code for a meta modelica option expression."
::=
  match exp
  case META_OPTION(exp=NONE) then
    "mmc_mk_none()"
  case META_OPTION(exp=SOME(e)) then
    # expPart = daeExpMetaHelperConstant(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
    'mmc_mk_some(<%expPart%>)'
end daeExpMetaOption;


template daeExpMetarecordcall(Exp exp, Context context, Text preExp /*BUFP*/,
                              Text varDecls /*BUFP*/)
 "Generates code for a meta modelica record call expression."
::=
match exp
case METARECORDCALL then
  # newIndex = incrementInt(index, 3)
  # argsStr = if args then
      ', <%args of exp:
        daeExpMetaHelperConstant(exp, context, preExp /*BUFC*/, varDecls /*BUFC*/)
      ", "%>'
    else
      ""
  # box = 'mmc_mk_box<%daeExpMetaHelperBoxStart(incrementInt(listLength(args), 1))%><%newIndex%>, &<%underscorePath(path)%>__desc<%argsStr%>)'
  # tmp = tempDecl("modelica_metatype", varDecls /*BUFC*/)
  # preExp += '<%tmp%> = <%box%>;<%\n%>'
  tmp
end daeExpMetarecordcall;


template daeExpMetaHelperConstant(Exp e, Context context, Text preExp /*BUFP*/,
                                  Text varDecls /*BUFP*/)
 "Generates a constant meta modelica value."
::=
  # expPart = daeExp(e, context, preExp /*BUFC*/, varDecls /*BUFC*/)
  daeExpMetaHelperConstantNameType(expPart, Exp.typeof(e), context,
                                   preExp /*BUFC*/, varDecls /*BUFC*/)
end daeExpMetaHelperConstant;


template daeExpMetaHelperConstantNameType(Text varname, ExpType type, Context context,
                                          Text preExp /*BUFP*/,
                                          Text varDecls /*BUFP*/)
 "Helper to daeExpMetaHelperConstant."
::=
  match type
  case ET_INT     then 'mmc_mk_icon(<%varname%>)'
  case ET_BOOL    then 'mmc_mk_icon(<%varname%>)'
  case ET_REAL    then 'mmc_mk_rcon(<%varname%>)'
  case ET_STRING  then 'mmc_mk_scon(<%varname%>)'
  case ET_COMPLEX(name=cname) then
    # start = daeExpMetaHelperBoxStart(incrementInt(listLength(varLst), 1))
    # args = if varLst then
        ', <%varLst of v as COMPLEX_VAR(name=cvname):
          # nameText = '<%varname%>.<%cvname%>'
          daeExpMetaHelperConstantNameType(nameText, tp, context,
                                           preExp /*BUFC*/, varDecls /*BUFC*/)
        ", "%>'
      else
        ""
    'mmc_mk_box<%start%>2, &<%underscorePath(cname)%>__desc<%args%>)'
  case _          then varname
end daeExpMetaHelperConstantNameType;


template daeExpMetaHelperBoxStart(Integer numVariables)
 "Helper to determine how mmc_mk_box should be called."
::=
  match numVariables
  case 0
  case 1
  case 2
  case 3
  case 4
  case 5
  case 6
  case 7
  case 8
  case 9 then '<%numVariables%>('
  case _ then '(<%numVariables%>, '
end daeExpMetaHelperBoxStart;


template tempDecl(String ty, Text varDecls /*BUFP*/)
 "Declares a temporary variable in varDecls and returns the name."
::=
  # newVar = 'tmp<%System.tmpTick()%>'
  # varDecls += '<%ty%> <%newVar%>;<%\n%>'
  newVar
end tempDecl;


template varType(Variable var)
 "Generates type for a variable."
::=
match var
case var as VARIABLE then
  if instDims then
    expTypeArray(var.ty)
  else
    expTypeArrayIf(var.ty)
end varType;


template expTypeRW(DAE.ExpType type)
 "Helper to writeOutVarRecordMembers."
::=
  match type
  case ET_INT         then "TYPE_DESC_INT"
  case ET_REAL        then "TYPE_DESC_REAL"
  case ET_STRING      then "TYPE_DESC_STRING"
  case ET_BOOL        then "TYPE_DESC_BOOL"
  case ET_ARRAY       then '<%expTypeRW(ty)%>_ARRAY'
  case ET_COMPLEX(complexClassType=RECORD)
                      then "TYPE_DESC_RECORD"
  case ET_METAOPTION
  case ET_LIST
  case ET_METATUPLE
  case ET_UNIONTYPE
  case ET_POLYMORPHIC
  case ET_META_ARRAY
  case ET_BOXED       then "TYPE_DESC_MMC"
end expTypeRW;


template expTypeShort(DAE.ExpType type)
 "Generate type helper."
::=
  match type
  case ET_INT         then "integer"
  case ET_REAL        then "real"
  case ET_STRING      then "string"
  case ET_BOOL        then "boolean"
  case ET_OTHER       then "complex"
  case ET_ARRAY       then expTypeShort(ty)   
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ)
                      then "complex"
  case ET_COMPLEX     then 'struct <%underscorePath(name)%>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC
  case ET_META_ARRAY
  case ET_BOXED       then "metatype"
  case _              then "expTypeShort:ERROR"
end expTypeShort;


template expType(DAE.ExpType ty, Boolean array)
 "Generate type helper."
::=
  match array
  case true  then expTypeArray(ty)
  case false then expTypeModelica(ty)
end expType;


template expTypeModelica(DAE.ExpType ty)
 "Generate type helper."
::=
  expTypeFlag(ty, 2)
end expTypeModelica;


template expTypeArray(DAE.ExpType ty)
 "Generate type helper."
::=
  expTypeFlag(ty, 3)
end expTypeArray;


template expTypeArrayIf(DAE.ExpType ty)
 "Generate type helper."
::=
  expTypeFlag(ty, 4)
end expTypeArrayIf;


template expTypeFromExpShort(Exp exp)
 "Generate type helper."
::=
  expTypeFromExpFlag(exp, 1)
end expTypeFromExpShort;


template expTypeFromExpModelica(Exp exp)
 "Generate type helper."
::=
  expTypeFromExpFlag(exp, 2)
end expTypeFromExpModelica;


template expTypeFromExpArray(Exp exp)
 "Generate type helper."
::=
  expTypeFromExpFlag(exp, 3)
end expTypeFromExpArray;


template expTypeFromExpArrayIf(Exp exp)
 "Generate type helper."
::=
  expTypeFromExpFlag(exp, 4)
end expTypeFromExpArrayIf;


template expTypeFlag(DAE.ExpType ty, Integer flag)
 "Generate type helper."
::=
  match flag
  case 1 then
    // we want the short type
    expTypeShort(ty)
  case 2 then
    // we want the "modelica type"
    if ty is ET_COMPLEX(complexClassType=EXTERNAL_OBJ) then
      'modelica_<%expTypeShort(ty)%>'
    else if ty is ET_COMPLEX then
      'struct <%underscorePath(name)%>'
    else
      'modelica_<%expTypeShort(ty)%>'
  case 3 then
    // we want the "array type"
    '<%expTypeShort(ty)%>_array'
  case 4 then
    // we want the "array type" only if type is array, otherwise "modelica type"
    match ty
    case ET_ARRAY then '<%expTypeShort(ty)%>_array'
    case _        then expTypeFlag(ty, 2)
end expTypeFlag;


template expTypeFromExpFlag(Exp exp, Integer flag)
 "Generate type helper."
::=
  match exp
  case ICONST        then if flag is 1 then "integer" else "modelica_integer"
  case RCONST        then if flag is 1 then "real" else "modelica_real"
  case SCONST        then if flag is 1 then "string" else "modelica_string"
  case BCONST        then if flag is 1 then "boolean" else "modelica_boolean"
  case e as BINARY
  case e as UNARY
  case e as LBINARY
  case e as LUNARY
  case e as RELATION then expTypeFromOpFlag(e.operator, flag)
  case IFEXP         then expTypeFromExpFlag(expThen, flag)
  case CALL          then expTypeFlag(ty, flag)
  case c as ARRAY
  case c as MATRIX
  case c as RANGE
  case c as CAST
  case c as CREF
  case c as CODE     then expTypeFlag(c.ty, flag)
  case ASUB          then expTypeFromExpFlag(exp, flag)
  case REDUCTION     then expTypeFromExpFlag(expr, flag)
  case _             then "expTypeFromExpFlag:ERROR"
end expTypeFromExpFlag;


template expTypeFromOpFlag(Operator op, Integer flag)
 "Generate type helper."
::=
  match op
  case o as ADD
  case o as SUB
  case o as MUL
  case o as DIV
  case o as POW
  case o as UMINUS
  case o as UPLUS
  case o as UMINUS_ARR
  case o as UPLUS_ARR
  case o as ADD_ARR
  case o as SUB_ARR
  case o as MUL_ARR
  case o as DIV_ARR
  case o as MUL_SCALAR_ARRAY
  case o as MUL_ARRAY_SCALAR
  case o as ADD_SCALAR_ARRAY
  case o as ADD_ARRAY_SCALAR
  case o as SUB_SCALAR_ARRAY
  case o as SUB_ARRAY_SCALAR
  case o as MUL_SCALAR_PRODUCT
  case o as MUL_MATRIX_PRODUCT
  case o as DIV_ARRAY_SCALAR
  case o as DIV_SCALAR_ARRAY
  case o as POW_ARRAY_SCALAR
  case o as POW_SCALAR_ARRAY
  case o as POW_ARR
  case o as POW_ARR2
  case o as LESS
  case o as LESSEQ
  case o as GREATER
  case o as GREATEREQ
  case o as EQUAL
  case o as NEQUAL then
    expTypeFlag(o.ty, flag)
  case o as AND
  case o as OR
  case o as NOT then
    if flag is 1 then "boolean" else "modelica_boolean"
  case _ then "expTypeFromOpFlag:ERROR"
end expTypeFromOpFlag;

end SimCodeC;

// vim: filetype=susan sw=2 sts=2
