// This file defines templates for transforming Modelica code to C# code.

spackage SimCodeCSharp

typeview "SimCodeTV.mo"

// SECTION: SIMULATION TARGET, ROOT TEMPLATE

translateModel(SimCode simCode) ::=
  case SIMCODE(modelInfo = MODELINFO) then
    # csFileContent = csFile(simCode)
    # textFile(csFileContent, '<%modelInfo.name%>.cs')
    () // empty result of the top-level template .., only side effects


// SECTION: SIMULATION TARGET, C# FILE SPECIFIC TEMPLATES

csFile(SimCode simCode) ::=
case sc as SIMCODE(modelInfo = MODELINFO) then
<<
// Simulation code for <%modelInfo.name%> generated by the OpenModelica Compiler.

using System;
using Bodylight.Solvers;
namespace Bodylight.Models
{
  public partial class <%modelInfo.name%> : DAESystem
  {
         
    <%modelDataMembers(modelInfo)%>

    <%functionDaeOutput(nonStateContEquations, removedEquations)%>

    <%functionDaeOutput2(nonStateDiscEquations, removedEquations)%>

    <%functionInput(modelInfo)%>

    <%functionOutput(modelInfo)%>

    <%functionZeroCrossing(zeroCrossings)%>

    <%functionHandleZeroCrossing(zeroCrossingsNeedSave)%>

    <%functionUpdateDependents(allEquations, helpVarInfo)%>
    
    <%functionUpdateDepend(allEquations, helpVarInfo)%>

    <%functionOnlyZeroCrossing(zeroCrossings)%>

    <%functionStoreDelayed()%>
    
    <%functionWhen(whenClauses)%>

    <%functionOde(stateContEquations)%>

    <%functionInitial(initialEquations)%>

    <%functionInitialResidual(residualEquations)%>
    
    <%functionExtraResudials(allEquations)%>
    
    <%functionBoundParameters(parameterEquations)%>

    <%functionCheckForDiscreteVarChanges(sc.helpVarInfo, sc.discreteModelVars)%>
    
  }
}
>>

modelDataMembers(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
const int 
  NHELP = <%varInfo.numHelpVars%>, NG = <%varInfo.numZeroCrossings%>,
  NX = <%varInfo.numStateVars%>, NY = <%varInfo.numAlgVars%>, NP = <%varInfo.numParams%>,
  NO = <%varInfo.numOutVars%>, NI = <%varInfo.numInVars%>, NR = <%varInfo.numResiduals%>,
  NEXT = <%varInfo.numExternalObjects%>, NYSTR = <%varInfo.numStringAlgVars%>, NPSTR = <%varInfo.numStringParamVars%>;

public override string ModelName  { get { return "<%name%>"; }}
public override int HelpVarsCount      { get { return NHELP; } }
public override int ZeroCrossingsCount { get { return NG; } }
public override int StatesCount        { get { return NX; } }
public override int AlgebraicsCount    { get { return NY; } }
public override int ParametersCount    { get { return NP; } }
        
public override int OutputsCount   { get { return NO; } }
public override int InputsCount    { get { return NI; } }
public override int ResidualsCount { get { return NR; } }
//public int ExternalObjectsCount { get { return NEXT; } }        
public override int MaximumOrder { get { return 5; } }
public override int StringVarsCount { get { return NYSTR; } }
public override int StringParametersCount { get { return NPSTR; } }

<%vars.stateVars of SIMVAR: <<
public double <%cref(name)%> { get { return states[<%index%>]; } set { states[<%index%>] = value; }}
>> \n%>
<%vars.derivativeVars of SIMVAR: <<
public double <%cref(name)%> { get { return statesDerivatives[<%index%>]; } set { statesDerivatives[<%index%>] = value; }}
>> \n%>
  
<%vars.algVars of SIMVAR: <<
public double <%cref(name)%> { get { return algebraics[<%index%>]; } set { algebraics[<%index%>] = value; }}
public double Pre_<%cref(name)%> { get { return savedAlgebraics[<%index%>]; } set { savedAlgebraics[<%index%>] = value; }}
>> \n%>
<%vars.paramVars of SIMVAR: <<
public double <%cref(name)%> { get { return parameters[<%index%>]; } set { parameters[<%index%>] = value; }}
>> \n%>

private static readonly SimVarInfo[] VariableInfosStatic = new[] {
	<%[  
		(vars.stateVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.State, <%index%>, false)
		>> ",\n"),
		(vars.derivativeVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.StateDer, <%index%>, false)
		>> ",\n"),
		(vars.algVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.Algebraic, <%index%>, false)
		>> ",\n"),
		(vars.paramVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.Parameter, <%index%>, true)
		>> ",\n")
	] ",\n\n"%>
};
public override SimVarInfo[] VariableInfos { get { return VariableInfosStatic; } }

private static readonly bool[] InitialFixedStatic = new bool[NX + NX + NY + NP] {
    <%[ if vars.stateVars      then "//states\n" + initFixed(vars.stateVars),
       if vars.derivativeVars then "//derivatives\n" + initFixed(vars.derivativeVars),
       if vars.algVars        then "//algebraics\n" + initFixed(vars.algVars), 
       if vars.paramVars      then "//parameters\n" + initFixed(vars.paramVars)
     ] ",\n"%>
};
public override bool[] InitialFixed { get { return InitialFixedStatic; } }

public <%name%>() {
    CreateData();
}

<%/*
    //a kind of SimulationVarInfo list will be created here
    //and statically promoted to interface/override implementation
	<%utilStaticStringArray("StateNames", vars.stateVars)%>
	<%utilStaticStringArray("DerivativeNames", vars.derivativeVars)%>
	<%utilStaticStringArray("AlgvarsNames", vars.algVars)%>
	<%utilStaticStringArray("InputNames", vars.inputVars)%>
	<%utilStaticStringArray("OutputNames", vars.outputVars)%>
	<%utilStaticStringArray("ParamNames", vars.paramVars)%>
	<%utilStaticStringArray("StringAlgNames", vars.stringAlgVars)%>
	<%utilStaticStringArray("StringParamNames", vars.stringParamVars)%>
	
	<%utilStaticStringArrayComment("StateComments", vars.stateVars)%>
	<%utilStaticStringArrayComment("DerivativeComments", vars.derivativeVars)%>
	<%utilStaticStringArrayComment("algvars_comments", vars.algVars)%>
	<%utilStaticStringArrayComment("input_comments", vars.inputVars)%>
	<%utilStaticStringArrayComment("output_comments", vars.outputVars)%>
	<%utilStaticStringArrayComment("param_comments", vars.paramVars)%>
	<%utilStaticStringArrayComment("string_alg_comments", vars.stringAlgVars)%>
	<%utilStaticStringArrayComment("string_param_comments", vars.stringParamVars)%>
*/%>

>>


initFixed(list<SimVar> simVarLst) ::=
  (simVarLst of SIMVAR: '<%isFixed%> /* <%crefSubscript(origName)%> */' ",\n")

functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations) ::=
# System.tmpTickReset(1)
<<
/* for continuous time variables */
public override void FunDAEOutput()
{
  <%nonStateContEquations : equation_(it,contextSimulationNonDescrete) \n%>
  <%removedEquations      : equation_(it,contextSimulationNonDescrete) \n%>
}
>>

functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
# System.tmpTickReset(1)
<<
/* for discrete time variables */
public override void FunDAEOutput2()
{
  <%nonStateDiscEquations : equation_(it,contextSimulationDescrete) \n%>
  <%removedEquations      : equation_(it,contextSimulationDescrete) \n%>
}
>>

functionInput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
public override void InputFun()
{
  <%vars.inputVars of SIMVAR : 
  <<
  <%cref(name)%> = inputVars[<%i0%>];
  >> \n%>
}
>>

functionOutput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
public override void OutputFun()
{
  /* not yet
  <%vars.outputVars of SIMVAR :
  <<
  outputVars[<%i0%>] = <%cref(name)%>;
  >> \n%>
  */
}
>>


functionZeroCrossing(list<ZeroCrossing> zeroCrossingLst) ::=
# System.tmpTickReset(1)
<<
public override void FunZeroCrossing(double time, double[] x, double[] xd, double[] gout)
{
  var timeBackup = this.time;
  this.time = time;

  FunODE();
  FunDAEOutput();
  
  <%zeroCrossingLst of ZERO_CROSSING : zeroCrossing(relation_, i0) \n%>  

  this.time = timeBackup;
}
>>

// This function should only save in cases. The rest is done in
// function_updateDependents.
functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave) ::=
<<
public override void FunHandleZeroCrossing(int index)
{  
  switch(index) {
    <%zeroCrossingsNeedSave of vars:
    <<
    case <%i0%>:
      <%vars of SIMVAR: 'Pre_<%cref(name)%> = <%cref(name)%>; //save()' \n%>
      break;
    >> \n%>
    default:
       break;
  }
}
>>

functionUpdateDependents(list<SimEqSystem> allEquations, list<HelpVarInfo> helpVarInfoLst) ::=
# System.tmpTickReset(1)
<<
public override void FunUpdateDependents()
{
  //inUpdate=initial()?0:1;
  isInUpdate = ! isInit;

  <%allEquations : equation_(it, contextSimulationDescrete) \n%>
  <%helpVarInfoLst of (in1, exp, _) :
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationDescrete, preExp)
      <<
      <%preExp%>
      helpVars[<%in1%>] = <%expPart%> ? 1.0 : 0.0;<%/*???TODO: ? 1.0 : 0.0;*/%>
      >>
  \n%>

  isInUpdate = false;
}
>>

// All when equations should go in here too according to Willi
// And something about if-eqs being sorted ans not just added to end
functionUpdateDepend(list<SimEqSystem> allEquations, list<HelpVarInfo> helpVarInfoLst) ::=
# System.tmpTickReset(1)
<<
public override void FunUpdateDepend()
{
  isInUpdate = ! isInit;
  
  <%allEquations : equation_(it, contextSimulationDescrete) \n%>
  <%helpVarInfoLst of (in1, exp, _) :
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationDescrete, preExp)
      <<
      <%preExp%>
      helpVars[<%in1%>] = <%expPart%> ? 1.0 : 0.0;<%/*???TODO: ? 1.0 : 0.0;*/%>
      >>
  \n%>

  isInUpdate = false;
}
>>

functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossingLst) ::=
# System.tmpTickReset(1)
<<
public override void FunOnlyZeroCrossings(double time, double[] gout) //TODO:??time in original is *t only ... how is it called?
{
  <%zeroCrossingLst of ZERO_CROSSING : zeroCrossing(relation_, i0) \n%>  
}
>>

zeroCrossing(Exp, Integer index) ::=
  case RELATION then
    # preExp = ""
    # e1 = daeExp(exp1, contextOther, preExp)
    # e2 = daeExp(exp2, contextOther, preExp)
    <<
    {<%preExp%>var _zen = zeroCrossingEnabled[<%index%>]; //ZEROCROSSING(<%index%>, <%zeroCrossingOpFunc(operator)%>(<%e1%>, <%e2%>));
    gout[<%index%>] = (_zen != 0) ? _zen * (<%match operator
                                           case LESS
                                           case LESSEQ    then '<%e1%>-<%e2%>'
                                           case GREATER
                                           case GREATEREQ then '<%e2%>-<%e1%>'
                                          %>) : 1.0; }
    >>    
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = ""
    # eStart = daeExp(start, contextOther, preExp)
    # eInterval = daeExp(interval, contextOther, preExp)
    <<
    {<%preExp%>var _zen = zeroCrossingEnabled[<%index%>]; //ZEROCROSSING(<%index%>, Sample(*t, <%eStart%>, <%eInterval%>));
    gout[<%index%>] = (_zen != 0) ? _zen * Sample(time, <%eStart%>, <%eInterval%>) : 1.0; }
    >> 
  case _ then
    <<
    ZERO_CROSSING_ERROR
    >>

zeroCrossingOpFunc(Operator) ::=
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"

// New runtime function. What should it do?
functionStoreDelayed() ::=
# System.tmpTickReset(1)
<<
public override void FunStoreDelayed()
{  
}
>>



functionWhen(list<SimWhenClause> whenClauses) ::=
# System.tmpTickReset(1)
<<
public override void FunWhen(int i)
{
  switch(i) {
    <%whenClauses of SIM_WHEN_CLAUSE :
    <<
    case <%i0%>:
      <%functionWhen_caseEquation(whenEq)%>
      <%reinits of REINIT :
        # preExp = ""
        # valueExp = daeExp(value, contextSimulationDescrete, preExp)
      <<
      <%preExp%>
      <%cref(stateVar)%> = <%valueExp%>;
      >> \n%>
      break;
    >> \n%>
    default:
      break;
  }
}
>>

functionWhen_caseEquation(Option<WhenEquation>) ::=
case SOME(weq as WHEN_EQ) then
# preExp = ""
# expPart = daeExp(weq.right, contextSimulationDescrete, preExp)
<<
Pre_<%cref(weq.left)%> = <%cref(weq.left)%>; //save()
<%preExp%>
<%cref(weq.left)%> = <%expPart%>;
>>



functionOde(list<SimEqSystem> stateContEquations) ::=
# System.tmpTickReset(1)
<<
public override void FunODE()
{
  <%stateContEquations : equation_(it, contextOther) \n%>
}
>>

//TODO:??there is st more in the trunk
functionInitial(list<SimEqSystem> initialEquations) ::=
# System.tmpTickReset(1)
<<
public override void InitialFun()
{
  <%initialEquations of SES_SIMPLE_ASSIGN: equation_(it, contextOther) \n%>

  //if (sim_verbose) {
    <%initialEquations of SES_SIMPLE_ASSIGN:
    <<
    //Debug.WriteLine("Setting variable start value: {0}(start={1})", "<%cref(componentRef)%>", <%cref(componentRef)%>);
    >> \n%>
  //}
}
>>

functionInitialResidual(list<SimEqSystem> residualEquations) ::=
# System.tmpTickReset(1)
<<
public override void InitialResidual()
{
  int _i = 0;

  <%residualEquations of SES_RESIDUAL :
    if exp is DAE.SCONST then
      'initialResiduals[_i++] = 0;'
    else
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationNonDescrete, preExp) // ??contextOther
      <<
      <%preExp%>
      initialResiduals[_i++] = <%expPart%>;
      >>
  \n%>
}
>>

functionExtraResudials(list<SimEqSystem> allEquations) ::=
# System.tmpTickReset(1)
(allEquations of SES_NONLINEAR:
<<
void ResidualFun<%index%>(int n, double[] xloc, double[] res, int iflag)
{
   <%eqs of SES_RESIDUAL :
     # preExp = ""
     # expPart = daeExp(exp, contextSimulationDescrete, preExp)
   <<
   <%preExp%>
   res[<%i0%>] = <%expPart%>;
   >> \n%>
}
>> \n)



functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
# System.tmpTickReset(1)
<<
public override void BoundParameters()
{
  <%parameterEquations of SES_SIMPLE_ASSIGN : equation_(it, contextOther) \n%>
}
>>

// TODO: Is the -1 thing really correct? It seems to work.
functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfoLst,
                                   list<ComponentRef> discreteModelVars) ::=
<<
public override bool CheckForDiscreteVarChanges()
{
  //var needToIterate = false;

  //edge(helpVars[i])
  <%helpVarInfoLst of (id1, exp, id2):
  if id2 is not -1 then
  <<
  if (helpVars[<%id1%>]!=0.0 && savedHelpVars[<%id1%>]==0.0) EventQueue.Add(<%id2%> + NG);
  >> \n%>

  //TODO: changeDiscreteVar(i) and to get the i from ComponentRef
  //if change()
  <%discreteModelVars :
  <<
  if (Pre_<%cref(it)%> != <%cref(it)%>) return true; /*needToIterate = true; */
  >> \n%>
  
  var _hvs = helpVars;
  var _shvs = savedHelpVars;
  for (int i = 0; i < _hvs.Length; i++) {
    //change(helpVars[i]) ?? TODO: not sure if it can be only 1.0 or 0.0
    if (_hvs[i] != _shvs[i])
      return true; //needToIterate=true;
  }

  return false; //needToIterate;
}
>>


// Residual equations are not handled here
equation_(SimEqSystem eq, Context context) ::=
case SES_SIMPLE_ASSIGN then
  # preExp = ""
  # expPart = daeExp(exp, context, preExp)
  <<
  <%preExp%>
  <%cref(componentRef)%> = <%expPart%>;
  >>
case SES_LINEAR then
  # uid = System.tmpTick()
  # size = listLength(vars)
  # aname = 'A<%uid%>'
  # bname = 'b<%uid%>'
  <<
  var <%aname%> = new double[<%size%>*<%size%>]; //declare_matrix(<%aname%>, <%size%>, <%size%>);
  var <%bname%> = new double[<%size%>]; //declare_vector(<%bname%>, <%size%>);
  <%simJac of (row, col, eq as SES_RESIDUAL):
     # preExp = ""
     # expPart = daeExp(eq.exp, context, preExp)
     '<%preExp%><%aname%>[<%row%>+<%col%>*<%size%>] = <%expPart%>; //set_matrix_elt(<%aname%>, <%row%>, <%col%>, <%size%>, <%expPart%>);'
  "\n"%>
  <%beqs:
     # preExp = ""
     # expPart = daeExp(it, context, preExp)
     '<%preExp%><%bname%>[<%i0%>] = <%expPart%>; //set_vector_elt(<%bname%>, <%i0%>, <%expPart%>);'
  "\n"%>
  SolveLinearSystem<%if partOfMixed then "Mixed"%>(<%aname%>, <%bname%>, <%size%>, <%uid%>);
  <%vars of SIMVAR: '<%cref(name)%> = <%bname%>[<%i0%>]; //get_vector_elt(<%bname%>, <%i0%>);' "\n"%>
  >>
case SES_MIXED then
  # contEqs = equation_(cont, context)
  # numDiscVarsStr = listLength(discVars) 
  # valuesLenStr = listLength(values)
  # preDisc = "" /*BUFD*/
  # discLoc2 = 
  	match discEqs
    case { discEq as SES_SIMPLE_ASSIGN } then
      <<
      <%cref(discEq.componentRef)%> = <%daeExp(discEq.exp, context, preDisc /*BUFC*/)%>;
      double discrete_loc2_0 = <%cref(discEq.componentRef)%>;
      >>
  	case discEqs then
      <<
      var discrete_loc2 = new double[<%numDiscVarsStr%>];
      <%discEqs of SES_SIMPLE_ASSIGN:
        <<
        <%cref(componentRef)%> = <%daeExp(exp, context, preDisc /*BUFC*/)%>;
        discrete_loc2[<%i0%>] = <%cref(componentRef)%>;
        >>
        "\n"%>
      >>
  <<
  // *** mixed_equation_system(<%numDiscVarsStr%>) ***
  { int found_solution = 0;
    int cur_value_indx = 0;
    do {
	  <% match discVars
	    case { var as SIMVAR } then
	      <<
	      double discrete_loc_0 = <%cref(var.name)%>;
          >>
	    case discVars then
	      <<
	      var discrete_loc = new double[<%numDiscVarsStr%>] {
	        <%discVars of SIMVAR: cref(name) ",\n"%>
	      };
	      >>
	  %>
	  {
	    <%contEqs%>
	  }
	  <%preDisc%>
	  <%discLoc2%>
	  {
	    // check_discrete_values(<%numDiscVarsStr%>, <%valuesLenStr%>);
	    if (found_solution == -1) { /*system of equations failed*/
            found_solution = 0;
        } else {
            found_solution = 1;
            <% match discVars
	    	  case { SIMVAR } then
	    	    <<
	    	    if ( Math.Abs(discrete_loc_0 - discrete_loc2_0) > 1e-12) {
                    found_solution = 0;
                }
                >>
              case discVars then
                <<
                for (int i=0; i < <%numDiscVarsStr%>; i++) {
	                if ( Math.Abs(discrete_loc[i] - discrete_loc2[i]) > 1e-12) {
	                    found_solution = 0;
	                }
	            }
	            >>
	        %>
        }
        if (found_solution == 0) { //!found_solution
            cur_value_indx++;
            if (cur_value_indx > <%valuesLenStr%>/<%numDiscVarsStr%>) {
                found_solution = -1; //?? failed ??
            }             
        }
	  }
    } while (found_solution == 0);
  } // *** mixed_equation_system_end(<%numDiscVarsStr%>) ***
  >>

case _ then
  <<
  equation_NOT_YET_IMPLEMENTED
  >>

// SECTION: SIMULATION TARGET, FUNCTIONS FILE SPECIFIC TEMPLATES
// not yet implemented

// SECTION: GENERAL TEMPLATES, COMPONENT REFERENCES

cref(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident)
  case _ then "CREF_NOT_IDENT"

crefSubscript(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident) + subscripts(subscriptLst)
  case _ then "CREF_NOT_IDENT"

subscripts(list<Subscript> subscriptsLst) ::=
  if subscriptsLst then '[<%subscriptsLst : subscript() ","%>]'

subscript(Subscript) ::=
  case INDEX(exp = ICONST) then exp.integer
  case _ then "SUBSCRIPT_NOT_CONSTANT"


// SECTION: GENERAL TEMPLATES, PATHS

dotPath(Path) ::=
  case QUALIFIED      then '<%name%>.<%dotPath(path)%>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)

underscorePath(Path) ::=
  case QUALIFIED      then '<%System.stringReplace(name, "_", "__")%>_<%underscorePath(path)%>'
  case IDENT          then System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then underscorePath(path)


// SECTION: GENERAL TEMPLATES, FUNCTION GENERATION
// not yet implemented




// Codegen.generateStatement
algStatement(DAE.Statement, Context context) ::=
  case STMT_ASSIGN(exp1 = CREF(componentRef = WILD), exp = e) then
    # preExp = "" 
    # expPart = daeExp(e, context, preExp)
    <<
    <%preExp%>
    <%expPart%>
    >>    
  case STMT_ASSIGN(exp1 = CREF) then
    # preExp = ""
    # expPart = daeExp(exp, context, preExp)
    <<
    <%preExp%>
    <%scalarLhsCref(exp1, context, preExp)%> = <%expPart%>;
    >>
  case STMT_ASSIGN then
    # preExp = ""
    # expPart1 = daeExp(exp1, context, preExp)
    # expPart2 = daeExp(exp, context, preExp)
    <<
    <%preExp%>
    <%expPart1%> = <%expPart2%>;
    >>
  case STMT_IF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp)
    <<
    <%preExp%>
    if (<%condExp%>) {
      <%statementLst : algStatement(it, context) \n%>
    }
    <%elseExpr(else_, context)%>
    >>
  case _ then "NOT_IMPLEMENTED_ALG_STATEMENT"
 /*
  case STMT_FOR(exp = rng as RANGE) then
    <<
    {
      <%expTypeA(type_, boolean)%> 
        _r1 = <%daeExp(rng.exp,isSimulationCode)%>,
        _r2 = <%if rng.expOption is SOME(eo) then daeExp(eo,isSimulationCode) else "(1)"%>,
        _r3 = <%daeExp(rng.range,isSimulationCode)%>,
        <%ident%>;

      for (<%ident%> = _r1; in_range_<%expShortType(type_)%>(<%ident%>, _r1, _r3); <%ident%> += _r2) {
        <%statementLst : algStatement() \n /* ??CONTEXT(codeContext,expContext,IN_FOR_LOOP(loopContext)*/ %>        
      }
    } /*end for*/
    >>
  */

elseExpr(DAE.Else, Context context) ::= 
  case NOELSE then ()
  case ELSEIF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp)
    <<
    else {
    <%preExp%>
    if (<%condExp%>)) {
      <%statementLst : algStatement(it, context) \n%>
    }
    <%elseExpr(else_, context)%>
    }
    >>
  case ELSE then
    <<
    else {
      <%statementLst : algStatement(it, context) \n%>
    }
    >>
    
//try this
/*
foo(list<Exp> exps, list<Integer> ints, Text varDecls) ::=
  if exps is (firstExp :: restExps) then
  if ints is (firstInt :: restInts) then
    # preExp = ""
    # expPart = daeExp(firstExp, contextSimulationDescrete, preExp, varDecls) 
    <<
    <%preExp%>
    localData->helpVars[<%firstInt%>] = <%expPart%>;
    <%foo(restExps, restInts, preExp, varDecls)%>
    >>
*/
foo(list<Exp> exps, list<Integer> ints) ::=
  if exps is (firstExp :: restExps) then
  if ints is (firstInt :: restInts) then
    # preExp = ""
    # expPart = daeExp(firstExp, contextSimulationDescrete, preExp)
    <<
    <%preExp%>
    localData->helpVars[<%firstInt%>] = <%expPart%>;
    <%foo(restExps, restInts)%>
    >>


scalarLhsCref(Exp cref, Context context, Text preExp) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if crefNoSub(cref.componentRef) then
    cref(cref.componentRef)
  else
    daeExpCrefRhs(cref, context, preExp)
case _ then
  "ONLY IDENT SUPPORTED"

/*
scalarLhsCref(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident)
  case CREF_QUAL  then '<%ident%>.<%scalarLhsCref(componentRef)%>'
*/

//TODO: this wrong for qualified integers !
rhsCref(ComponentRef, ExpType ty) ::=
  case CREF_IDENT then '<%rhsCrefType(ty)%><%replaceDollarWorkaround(ident)%>'
  case CREF_QUAL  then '<%rhsCrefType(ty)%><%ident%>.<%rhsCref(componentRef,ty)%>'
  case _          then "rhsCref:ERROR"

rhsCrefType(ExpType) ::=
  case ET_INT then "(int)"
  case _      then ""


replaceDollarWorkaround(String ident) ::=
  stringReplace(
    stringReplace(ident,"$DER","Der_"), 
    "$", "")

// SECTION: GENERAL TEMPLATES, EXPRESSIONS
  
daeExp(Exp exp, Context context, Text preExp) ::=
  case ICONST     then integer
  case RCONST     then real
  case SCONST     then '"<%Util.escapeModelicaStringToCString(string)%>"'
  case BCONST     then if bool then "(1)" else "(0)"
  case CREF       then daeExpCrefRhs(it, context, preExp)
  case LBINARY
  case BINARY     then daeExpBinary(operator, exp1, exp2, context, preExp)
  case LUNARY
  case UNARY      then daeExpUnary(operator, exp, context, preExp)
  case RELATION   then daeExpRelation(operator, exp1, exp2, context, preExp)
  case IFEXP      then daeExpIf(expCond, expThen, expElse, context, preExp)
  case CALL       then daeExpCall(exp, context, preExp)
  // PARTEVALFUNCTION
  case ARRAY      then daeExpArray(ty, scalar, array, context, preExp)
  case MATRIX     then "MATRIX_NOT_IMPLEMENTED"
  case RANGE      then "RANGE_NOT_IMPLEMENTED"
  case TUPLE      then "TUPLE_NOT_IMPLEMENTED"
  case CAST       then "CAST_NOT_IMPLEMENTED"
  case ASUB       then "ASUB_NOT_IMPLEMENTED"
  case SIZE       then "SIZE_NOT_IMPLEMENTED"
  case CODE       then "CODE_NOT_IMPLEMENTED"
  case REDUCTION  then "REDUCTION_NOT_IMPLEMENTED"
  case END        then "END_NOT_IMPLEMENTED"
  case VALUEBLOCK then "VALUEBLOCK_NOT_IMPLEMENTED"
  case LIST       then "LIST_NOT_IMPLEMENTED"
  case CONS       then "CONS_NOT_IMPLEMENTED"
  // META_TUPLE
  // META_OPTION
  // METARECORDCALL
  case _          then "UNKNOWN_EXP"
  
daeExpCrefRhs(Exp exp, Context context, Text preExp) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if daeExpCrefRhsArrayBox(exp, context, preExp) then
    it
  else if crefNoSub(cref.componentRef) then
    <<
    <%if cref.ty is ET_INT then "(int)"
    %><%cref(cref.componentRef)%>
    >>
  else if crefSubIsScalar(cref.componentRef) then
    // The array subscript results in a scalar
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # dimsLenStr = listLength(subs)
    # dimsValuesStr = (subs of INDEX: daeExp(exp, context, preExp) ", ")
    <<
    !!!TODO:(*<%arrayType%>_element_addr(&<%arrName%>, <%dimsLenStr%>, <%dimsValuesStr%>))
    >>
  else
    // The array subscript denotes a slice
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # spec1 = daeExpCrefRhsIndexSpec(subs, context, preExp)
    # tmp = ""
    # preExp += '!!!TODO: <%tempDecl(arrayType, tmp)%> = index_alloc_<%arrayType%>(&<%arrName%>, &<%spec1%>, &<%tmp%>);<%\n%>'
    tmp
case _ then
  "UNKNOWN RHS CREF: ONLY IDENT SUPPORTED"

daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context, Text preExp) ::=
# nridx_str = listLength(subs)
# idx_str = (subs :
               case INDEX then
                 # expPart = daeExp(exp, context, preExp)
                 <<
                 (1), make_index_array(1, <%expPart%>), 'S'
                 >>
               case WHOLEDIM then
                 <<
                 (1), (0), 'W'
                 >>
               case SLICE then
                 # expPart = daeExp(exp, context, preExp)
                 # tmp = ""
                 # preExp += '!!!TODO:<%tempDecl("int", tmp)%> = size_of_dimension_integer_array(<%expPart%>, 1);<%\n%>'
                 <<
                 <%tmp%>, integer_array_make_index_array(&<%expPart%>), 'A'
                 >>
             ", ")
# tmp = "" 
# preExp += '!!!TODO:<%tempDecl("index_spec_t", tmp)%> = create_index_spec(&<%tmp%>, <%nridx_str%>, <%idx_str%>);<%\n%>'
tmp

daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp) ::=
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = ""
    # dimsLenStr = listLength(dims)
    # dimsValuesStr = (dims of SOME(i): i ", ")
    # preExp += '!!!TODO:<%tempDecl(expTypeArray(aty), tmpArr)%> = <%expShortType(aty)%>_array_create(&<%tmpArr%>, &<%cref(cref.componentRef)%>, <%dimsLenStr%>, <%dimsValuesStr%>);<%\n%>'
    tmpArr

    

daeExpBinary(Operator, Exp exp1, Exp exp2, Context context, Text preExp) ::=
  # e1 = daeExp(exp1, context, preExp)
  # e2 = daeExp(exp2, context, preExp)
  case ADD then '(<%e1%> + <%e2%>)'
  case SUB then '(<%e1%> - <%e2%>)'
  case MUL then '(<%e1%> * <%e2%>)'
  case DIV then '(<%e1%> / <%e2%>)'
  case POW then 'Math.Pow(<%e1%>, <%e2%>)'
  case AND then '(<%e1%> && <%e2%>)'
  case OR  then '(<%e1%> || <%e2%>)'
  case _   then "daeExpBinary:ERR"

daeExpUnary(Operator, Exp exp, Context context, Text preExp) ::=
  # e = daeExp(exp, context, preExp)
  case UMINUS     then '(-<%e%>)'
  case UPLUS      then '(<%e%>)'
  case NOT        then '(!<%e%>)'
  case UMINUS_ARR then "UMINUS_ARR_NOT_IMPLEMENTED"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"


daeExpRelation(Operator op, Exp exp1, Exp exp2, Context context, Text preExp) ::=
  # e1 = daeExp(exp1, context, preExp)
  # e2 = daeExp(exp2, context, preExp)
  if  daeExpSimRelation(context, op, e1, e2, preExp) then 
    it
  else //non-SIMULATION context or precise equality 
    match op
    case LESS(ty = ET_BOOL)        then '(!<%e1%> && <%e2%>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)
    case LESS(ty = ET_REAL)        then '(<%e1%> < <%e2%>)'
    case GREATER(ty = ET_BOOL)     then '(<%e1%> && !<%e2%>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)
    case GREATER(ty = ET_REAL)     then '(<%e1%> > <%e2%>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<%e1%> || <%e2%>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)
    case LESSEQ(ty = ET_REAL)      then '(<%e1%> <= <%e2%>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<%e1%> || !<%e2%>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)
    case GREATEREQ(ty = ET_REAL)   then '(<%e1%> >= <%e2%>)'
    case EQUAL(ty = ET_BOOL)       then '((!<%e1%> && !<%e2%>) || (<%e1%> && <%e2%>))'
    case EQUAL(ty = ET_STRING)
    case EQUAL(ty = ET_INT)
    case EQUAL(ty = ET_REAL)       then '(<%e1%> == <%e2%>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<%e1%> && <%e2%>) || (<%e1%> && !<%e2%>))'
    case NEQUAL(ty = ET_STRING)
    case NEQUAL(ty = ET_INT)
    case NEQUAL(ty = ET_REAL)      then '(<%e1%> != <%e2%>)'
    case _                         then "daeExpRelation:ERR"

daeExpSimRelation(Context, Operator op, Text e1, Text e2, Text preExp) ::=
	case SIMULATION then
	   match op
	   case LESS      then SimRelationSimple(e1, e2, " <", preExp)
	   case LESSEQ    then SimRelationEqual(e1, e2, " <", preExp)
	   case GREATER   then SimRelationSimple(e1, e2, " >", preExp)
	   case GREATEREQ then SimRelationEqual(e1, e2, " >", preExp)

SimRelationSimple(Text e1, Text e2, String op, Text preExp) ::=
  # res = ""    
  # preExp += 
    <<
    // RELATION( <%e1%><%op%> <%e2%> ) macro expansion
    <%tempDecl("bool", res)%> = <%e1%><%op%> <%e2%>; if (!<%res%> && isInUpdate && (<%e1%><%op%>= <%e2%>)) { SwapOldVars(); double res1 = <%e1%> - <%e2%>;  SwapOldVars12(); <%res%> = res1<%op%>= (<%e1%> - <%e2%>); SwapOldVars2(); }<%\n%>
    >>
  res 

SimRelationEqual(Text e1, Text e2, String op, Text preExp) ::=
  # res = ""    
  # preExp += 
    <<
    // RELATION( <%e1%><%op%>= <%e2%> ) macro expansion
    <%tempDecl("bool", res)%>;  if (isInUpdate) { <%res%> = <%e1%><%op%> <%e2%>;  if(!<%res%> && (<%e1%><%op%>= <%e2%>)) {  SwapOldVars(); double res1 = <%e1%> - <%e2%>;  SwapOldVars12(); <%res%> = res1<%op%>= (<%e1%> - <%e2%>); SwapOldVars2(); }  } else <%res%> = <%e1%><%op%>= <%e2%>;<%\n%>
    >>
  res

daeExpIf(Exp cond, Exp then_, Exp else_, Context context, Text preExp) ::=
  # condExp = daeExp(cond, context, preExp)
  # resVar = ""
  # preExpThen = ""
  # eThen = daeExp(then_, context, preExpThen)
  # preExpElse = ""
  # eElse = daeExp(else_, context, preExpElse)
  # preExp +=  
  <<
  <%tempDecl(expTypeFromExpArrayIf(then_), resVar)%>;
  if (<%condExp%><%/*if expTypeFromExp(cond) is "bool" then " != 0.0"*/%>) { //cond type is <%expTypeFromExp(cond)%>
    <%preExpThen%>
    <%resVar%> = <%eThen%>;
  } else {
    <%preExpElse%>
    <%resVar%> = <%eElse%>;
  }<%\n%>
  >>
  resVar

/*<<
(<%daeExp(cond, context, preExp)
  %> ? <%daeExp(then_, context, preExp)%> : <%daeExp(else_, context, preExp)%>)
>>*/

daeExpCall(Exp, Context context, Text preExp) ::=
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="DIVISION"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    # var1 = daeExp(e1, context, preExp)
    # msg = Util.escapeModelicaStringToCString(string)
    (match e2 
     case RCONST then 
     	//if rr is 0.0 then 'DivBy0(<%var1%>,0.0,"<%msg%>")'
     	//else 
     	'<%var1%>/<%daeExp(e2, context, preExp)%>'
     case _ then
     	# var2 = daeExp(e2, context, preExp)
    	'(<%var2%>!=0.0 ? <%var1%>/<%var2%> : DivBy0(<%var1%>,<%var2%>,"<%msg%>"))' 
     ) 
    
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    //# retType = expType(arg.ty)
    <<
    <%if arg.ty is ET_INT then "(int)"
    %>Pre_<%cref(arg.componentRef)%>
    >>
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="min"), expLst={e1,e2}) then
    'Math.Min(<%daeExp(e1, context, preExp)%>,<%daeExp(e2, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="max"), expLst={e1,e2}) then
    'Math.Max(<%daeExp(e1, context, preExp)%>,<%daeExp(e2, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="log"), expLst={s1}) then
    'Math.Log(<%daeExp(s1, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="exp"), expLst={s1}) then
    'Math.Exp(<%daeExp(s1, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="sin"), expLst={s1}) then
    'Math.Sin(<%daeExp(s1, context, preExp)%>)'
  
    
  // TODO: add more special builtins (Codegen.generateBuiltinFunction)
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst : daeExp(it, context, preExp) ", ")
    # preExp += '<%underscorePrefix(builtin)%><%underscorePath(path)%>(<%argStr%>);<%\n%>'
    <<
    /* NORETCALL */
    >>
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst : daeExp(it, context, preExp) ", ")
    # funName = underscorePath(path)
    <<
    <%underscorePrefix(builtin)
    %><%funName%>(<%argStr%>)<%if not builtin then '/* !!!TODO:.<%funName%>_rettype_1 */'%>
    >>
  case _ then "daeExpCall:NOT_YET_IMPLEMENTED"
    

daeExpArray(ExpType ty, Boolean scalar, list<Exp> array, Context context, Text preExp) ::=
  # arrayTypeStr = expTypeArray(ty)
  # arrayVar = "" //tempDecl(arrayTypeStr, varDecls /*BUFC*/)
  # scalarPrefix = if scalar then "" else "NON_SCALAR_ARRAY_notYetImplemeted"
  # scalarRef = if scalar then "&" else ""
  # params = '<%array of e: '(<%expTypeFromExp(e)%>)<%daeExp(e, context, preExp)%>' ", "%>'
  # preExp += '<%scalarPrefix%><%tempDecl(arrayTypeStr,arrayVar)%> = new <%arrayTypeStr%>{ <% ["0.0",params] ", "%> };<%\n%>'
  arrayVar


underscorePrefix(Boolean builtin) ::=
  case true then ""
  case false then "_"

// SECTION: GENERAL TEMPLATES, TEMPORARY VARIABLES

//newVar parameter is assumed to be empty or it can hold an identifier prefix
tempDecl(String ty, Text newVar) ::=
  # newVar += '_tmp<%System.tmpTick()%>'
  <<
  <%ty%> <%newVar%>
  >>
  


// SECTION: GENERAL TEMPLATES, TYPES

// TODO: Check with Codegen
expShortType(DAE.ExpType) ::=
  case ET_INT    then "int"
  case ET_REAL   then "double"
  case ET_STRING then "string"
  case ET_BOOL   then "bool"
  case ET_OTHER  then "#complex#"
  case ET_ARRAY then expShortType(ty)   
  case ET_COMPLEX then '/*struct*/<%underscorePath(name)%>'  

expTypeArray(DAE.ExpType ty) ::=
<<
<%expShortType(ty)%>[]
>>

expTypeFromExpArrayIf(Exp exp) ::=
  expTypeFromExp(exp)

expTypeFromExp(Exp) ::=
  case ICONST    then "int"
  case RCONST    then "double"
  case SCONST    then "string"
  case BCONST    then "bool"
  case BINARY
  case UNARY
  case LBINARY
  case LUNARY
  case RELATION   then expTypeFromOp(operator)
  case IFEXP      then expTypeFromExp(expThen)
  case CALL       then expShortType(ty)
  case ARRAY
  case MATRIX
  case RANGE
  case CAST
  case CREF
  case CODE       then expShortType(ty)
  case ASUB       then expTypeFromExp(exp)
  case REDUCTION  then expTypeFromExp(expr)
  case _          then "expTypeFromExp:ERROR"


expTypeFromOp(Operator) ::=
  case ADD
  case SUB
  case MUL
  case DIV
  case POW
  case UMINUS
  case UPLUS
  case UMINUS_ARR
  case UPLUS_ARR
  case ADD_ARR
  case SUB_ARR
  case MUL_ARR
  case DIV_ARR
  case MUL_SCALAR_ARRAY
  case MUL_ARRAY_SCALAR
  case ADD_SCALAR_ARRAY
  case ADD_ARRAY_SCALAR
  case SUB_SCALAR_ARRAY
  case SUB_ARRAY_SCALAR
  case MUL_SCALAR_PRODUCT
  case MUL_MATRIX_PRODUCT
  case DIV_ARRAY_SCALAR
  case DIV_SCALAR_ARRAY
  case POW_ARRAY_SCALAR
  case POW_SCALAR_ARRAY
  case POW_ARR
  case POW_ARR2
  case LESS
  case LESSEQ
  case GREATER
  case GREATEREQ
  case EQUAL
  case NEQUAL       then  expShortType(ty)
  case AND
  case OR
  case NOT then "bool"
  case _ then "expTypeFromOp:ERROR"

/*
// TODO: Check with Codegen
expType(DAE.ExpType) ::=
  case ET_INT    then "int"
  case ET_REAL   then "double"
  case ET_BOOL   then "bool"
  case ET_STRING then "string"
  case ET_COMPLEX(complexClassType = EXTERNAL_OBJ)  then "#complex external obj#" 
  case ET_OTHER  then "#OTHER type#"
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "#metamodelica_type#"
  case ET_ARRAY then 
    match ty
    case ET_INT    then "int[]"
    case ET_REAL   then "double[]"
    case ET_STRING then "string[]"
    case ET_BOOL   then "bool[]"

// TODO: Check with Codegen (expTypeStr)
expTypeA(DAE.ExpType, Boolean isArray) ::=
  case ET_COMPLEX     then expShortType() // i.e. 'struct <%name%>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "#metamodelica_type#"
*/


end SimCodeCSharp;
// vim: filetype=susan sw=2 sts=2
