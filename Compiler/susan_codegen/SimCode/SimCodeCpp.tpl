package SimCodeCpp

import interface SimCodeTV;

// SECTION: SIMULATION TARGET, ROOT TEMPLATE

template translateModel(SimCode simCode) ::=
  match simCode
  case SIMCODE(modelInfo = MODELINFO(__)) then
  let()= textFile(simulationHeaderFile(simCode), '<%lastIdentOfPath(modelInfo.name)%>.h')
  let()= textFile(simulationCppFile(simCode), '<%lastIdentOfPath(modelInfo.name)%>.cpp')
  //let()= textFile(simulationInitFile(simCode), '<%fileNamePrefix%>_init.txt')
  let()= textFile(simulationFunctionsHeaderFile(simCode,modelInfo.functions), 'Functions.h')
  let()= textFile(simulationFunctionsFile(simCode, modelInfo.functions), 'Functions.cpp')
  //let()= textFile(recordsFile(fileNamePrefix, recordDecls), '<%fileNamePrefix%>_records.c')
  let()= textFile(simulationMakefile(simCode), '<%fileNamePrefix%>.makefile')
     "" // empty result of the top-level template .., only side effects
end translateModel;

template translateFunctions(FunctionCode functionCode)
 "Generates C code and Makefile for compiling and calling Modelica and
  MetaModelica functions." 
::=
  match functionCode
  case FUNCTIONCODE(__) then
  
  "" // Return empty result since result written to files directly
end translateFunctions;

template simulationHeaderFile(SimCode simCode)
 "Generates code for header file for simulation target."
::=
match simCode
case SIMCODE(__) then
  <<
   <%generateHeaderInlcudeString(simCode)%>
   <%generateClassDeclarationCode(simCode)%>
   
   
   >>
end simulationHeaderFile;

template simulationFunctionsFile(SimCode simCode, list<Function> functions)
 "Generates the content of the Cpp file for functions in the simulation case."
::=
match simCode
case SIMCODE(modelInfo=MODELINFO(__)) then
  <<
  #include "Modelica.h"
  #include "Functions.h"
  
   Functions::Functions() 
   { 
   } 

   Functions::~Functions() 
   { 
   } 
    <%functionBodies(functions,simCode)%>
  >>
  
end simulationFunctionsFile;

template simulationFunctionsHeaderFile(SimCode simCode, list<Function> functions)
::=
match simCode
case SIMCODE(modelInfo=MODELINFO(__)) then
  <<
  #pragma once
  #include "Math/Implementation/ArrayOperations.h"
  #include "Math/Implementation/Functions.h"
  /*****************************************************************************
  *    
  * Simulation code for FunctionCall functions generated by the OpenModelica Compiler.
  *
  *****************************************************************************/
  <%functionHeaderBodies(functions,simCode)%>

  >>
  
end simulationFunctionsHeaderFile;

template simulationMakefile(SimCode simCode)
 "Generates the contents of the makefile for the simulation case."
::=
match simCode
case SIMCODE(modelInfo=MODELINFO(__), makefileParams=MAKEFILE_PARAMS(__), simulationSettingsOpt = sopt) then
let extraCflags = match sopt case SOME(s as SIMULATION_SETTINGS(__)) then
    '<%if s.measureTime then "-D_OMC_MEASURE_TIME "%> <%match s.method
       case "inline-euler" then "-D_OMC_INLINE_EULER"
       case "inline-rungekutta" then "-D_OMC_INLINE_RK"%>'
<<
# Makefile generated by OpenModelica
include ModelicaConfic.inc
# Simulations use -O3 by default
SIM_OR_DYNLOAD_OPT_LEVEL=-O3
CC=<%makefileParams.ccompiler%>
CXX=<%makefileParams.cxxcompiler%>
LINK=<%makefileParams.linker%>
EXEEXT=<%makefileParams.exeext%>
DLLEXT=<%makefileParams.dllext%>
CFLAGS_BASED_ON_INIT_FILE=<%extraCflags%>
CFLAGS=$(CFLAGS_BASED_ON_INIT_FILE) -I"<%makefileParams.omhome%>/include/omc/cpp" -I"$(BOOST_INCLUDE)" <%makefileParams.includes ; separator=" "%> <%makefileParams.cflags%> <%match sopt case SOME(s as SIMULATION_SETTINGS(__)) then s.cflags %>
LDFLAGS=-L"<%makefileParams.omhome%>/bin" -L$(BOOST_LIBS)

MAINFILE=<%lastIdentOfPath(modelInfo.name)%><% if acceptMetaModelicaGrammar() then ".conv"%>.cpp
FUNCTIONFILE=Functions.cpp

.PHONY: <%lastIdentOfPath(modelInfo.name)%>
<%lastIdentOfPath(modelInfo.name)%>: $(MAINFILE) 
<%\t%>$(CXX) -shared -I. -o $(MODELICA_SYSTEM_LIB) $(MAINFILE) $(FUNCTIONFILE)  -L"..//Test//Base/"    $(CFLAGS)  $(LDFLAGS) -lSystem -lMath -Wl,-Bstatic  -Wl,-Bdynamic
	 
>>
end simulationMakefile;

template simulationCppFile(SimCode simCode)
 "Generates code for main cpp file for simulation target."
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
  <<
   #include "Modelica.h"
   #include "<%lastIdentOfPath(modelInfo.name)%>.h"


   using boost::extensions::factory;
   BOOST_EXTENSION_TYPE_MAP_FUNCTION {
	types.get<std::map<std::string, factory<IDAESystem,IGlobalSettings&> > >()
	["ModelicaSystem"].set<<%lastIdentOfPath(modelInfo.name)%>>();
    }
    
    <%lastIdentOfPath(modelInfo.name)%>::<%lastIdentOfPath(modelInfo.name)%>(IGlobalSettings& globalSettings) 
   :SystemDefaultImplementation()
     <%simulationInitFile(simCode)%>
    { 
       // Number of equations
       <%dimension1(simCode)%>
      //DAE's are not supported yet, Index reduction is enabled
	  _dimAE = 0; // algebraic equations
	  // Initialize the state vector
	  SystemDefaultImplementation::init();
	  //Instantiate auxiliary object for event handling functionality
	  _event_handling.resetHelpVar =  boost::bind(&<%lastIdentOfPath(modelInfo.name)%>::resetHelpVar, this, _1);
	  _historyImpl = new HistoryImplType(globalSettings);
	  <%arrayReindex(modelInfo)%>
	  <%arrayInit(simCode)%>
    }
    
    <%lastIdentOfPath(modelInfo.name)%>::~<%lastIdentOfPath(modelInfo.name)%>() 
    { 
    delete _historyImpl;
    }
   <%init(simCode)%>
   void <%lastIdentOfPath(modelInfo.name)%>::resetTimeEvents()
   {
    <%resetTimeEvents(sampleConditions,whenClauses,simCode)%>
   }
   <%Update(simCode)%>  
   <%writeoutput(simCode)%>
   <%DefaultImplementationCode(simCode)%>
   <%checkForDiscreteEvents(discreteModelVars,simCode)%>
   <%giveZeroFunc1(zeroCrossings,simCode)%>
   <%isODE(simCode)%>
   <%DimZeroFunc(simCode)%>
   <%handleSystemEvents(zeroCrossings,whenClauses,simCode)%>
   <%saveall(modelInfo,simCode)%>
   <%resethelpvar(whenClauses,simCode)%>

   >>
end simulationCppFile;

template functionBodies(list<Function> functions,SimCode simCode)
 "Generates the body for a set of functions."
::=
  (functions |> fn => functionBody(fn, false,simCode) ;separator="\n")
end functionBodies;

template functionBody(Function fn, Boolean inFunc,SimCode simCode)
 "Generates the body for a function."
::=
  match fn
  case fn as FUNCTION(__)           then functionBodyRegularFunction(fn, inFunc,simCode)
  case fn as EXTERNAL_FUNCTION(__)  then ""
  case fn as RECORD_CONSTRUCTOR(__) then ""
end functionBody;

template functionHeaderBodies(list<Function> functions,SimCode simCode)
 "Generates the body for a set of functions."
::=
  (functions |> fn => functionHeaderBody(fn,simCode) ;separator="\n")
end functionHeaderBodies;

template functionHeaderBody(Function fn,SimCode simCode)
 "Generates the body for a function."
::=
  match fn
  case fn as FUNCTION(__)           then functionHeaderRegularFunction(fn,simCode)
  case fn as EXTERNAL_FUNCTION(__)  then ""
  case fn as RECORD_CONSTRUCTOR(__) then ""
end functionHeaderBody;

template functionHeaderRegularFunction(Function fn,SimCode simCode)
::=
match fn
case FUNCTION(__) then 
  let fname = underscorePath(name)
  << 
    typedef int   <%fname%>RetType;
    typedef int&  <%fname%>RefRetType;

    class Functions
     { 
      public: 
	    Functions(); 
       ~Functions(); 
        <%fname%>RefRetType <%fname%>(<%functionArguments |> var => funArgDefinition(var,simCode) ;separator=", "%>);

      private:
        <%fname%>RetType _<%fname%>;
    };
  >>
end functionHeaderRegularFunction;

template functionBodyRegularFunction(Function fn, Boolean inFunc,SimCode simCode)
 "Generates the body for a Modelica/MetaModelica function."
::=
match fn
case FUNCTION(__) then
  let()= System.tmpTickReset(1)
  let fname = underscorePath(name)
  let retType = if outVars then '<%fname%>RefRetType' else "void"
  let &varDecls = buffer "" /*BUFD*/
  let &varInits = buffer "" /*BUFD*/
  //let retVar = if outVars then tempDecl(retType, &varDecls /*BUFD*/)
  //let stateVar = if not acceptMetaModelicaGrammar() then tempDecl("state", &varDecls /*BUFD*/)
  let _ = (variableDeclarations |> var hasindex i1 fromindex 1 =>
      varInit(var, "", i1, &varDecls /*BUFD*/, &varInits /*BUFC*/,simCode) ; empty /* increase the counter! */
    )
  //let addRootsInputs = (functionArguments |> var => addRoots(var) ;separator="\n")
  //let addRootsOutputs = (outVars |> var => addRoots(var) ;separator="\n")
  //let funArgs = (functionArguments |> var => functionArg(var, &varInits) ;separator="\n")
  let bodyPart = (body |> stmt  => funStatement(stmt, &varDecls /*BUFD*/,simCode) ;separator="\n")
  let &outVarInits = buffer ""
  let &outVarCopy = buffer ""
  let &outVarAssign = buffer ""
  let _ = (outVars |> var hasindex i1 fromindex 1 =>
     varOutput(fn, var, i1, &varDecls, &outVarInits, &outVarCopy, &outVarAssign, simCode)
      ;separator="\n"; empty /* increase the counter! */
     )
  //let boxedFn = if acceptMetaModelicaGrammar() then functionBodyBoxed(fn)
  <<
  <%retType%> Functions::<%fname%>(<%functionArguments |> var => funArgDefinition(var,simCode) ;separator=", "%>)
  {  
    <%varDecls%>
    <%outVarInits%>
    <%varInits%>
    <%bodyPart%>
    <%outVarAssign%>
    return <%if outVars then '_<%fname%>' %>;
  }
  
  <% if inFunc then
  <<
  int in_<%fname%>(type_description * inArgs, type_description * outVar)
  {
    <%functionArguments |> var => '<%funArgDefinition(var,simCode)%>;' ;separator="\n"%>
    <%if outVars then '<%retType%> out;'%>
  
    //MMC_TRY_TOP()


    
    return 0; 
  }
  >>
  %>
  
 
  >>
end functionBodyRegularFunction;

template varOutput(Function fn, Variable var, Integer ix, Text &varDecls,
          Text &varInits, Text &varCopy, Text &varAssign, SimCode simCode)
 "Generates code to copy result value from a function to dest."
::=
match fn
case FUNCTION(__) then
 let fname = underscorePath(name)
match var
/* The storage size of arrays is known at call time, so they can be allocated
 * before set_memory_state. Strings are not known, so we copy them, etc...
 */
case var as VARIABLE(ty = ET_STRING(__)) then 
    if not acceptMetaModelicaGrammar() then
      // We need to strdup() all strings, then allocate them on the memory pool again, then free the temporary string
      let strVar = tempDecl("modelica_string_t", &varDecls)
      let &varCopy += '<%strVar%> = strdup(<%contextCref(var.name,contextFunction,simCode)%>);<%\n%>'
      let &varAssign +=
        <<
        _<%fname%> = init_modelica_string(<%strVar%>);
        free(<%strVar%>);<%\n%>
        >>
      ""
    else
      let &varAssign += '_<%fname%>= <%contextCref(var.name,contextFunction,simCode)%>;<%\n%>'
      ""
case var as VARIABLE(__) then
  let marker = '<%contextCref(var.name,contextFunction,simCode)%>'
  let &varInits += '/* varOutput varInits(<%marker%>) */ <%\n%>'
  let &varAssign += '/* varOutput varAssign(<%marker%>) */ <%\n%>'
  let instDimsInit = (instDims |> exp =>
      daeExp(exp, contextFunction, &varInits /*BUFC*/, &varDecls /*BUFD*/,simCode)
    ;separator=", ")
  if instDims then
    //let &varInits += 'alloc_<%expTypeShort(var.ty)%>_array(&<%dest%>.targ<%ix%>, <%listLength(instDims)%>, <%instDimsInit%>);<%\n%>'
    //let &varAssign += 'copy_<%expTypeShort(var.ty)%>_array_data(&<%contextCref(var.name,contextFunction,simCode)%>, &<%dest%>.targ<%ix%>);<%\n%>'
    ""
  else
   // let &varInits += initRecordMembers(var)
    let &varAssign += '_<%fname%> = <%contextCref(var.name,contextFunction,simCode)%>;<%\n%>'
    ""
case var as FUNCTION_PTR(__) then
    let &varAssign += '_<%fname%> = (modelica_fnptr) _<%var.name%>;<%\n%>'
    ""
end varOutput;

template varInit(Variable var, String outStruct, Integer i, Text &varDecls /*BUFP*/, Text &varInits /*BUFP*/, SimCode simCode)
 "Generates code to initialize variables.
  Does not return anything: just appends declarations to buffers."
::=
match var
case var as VARIABLE(__) then
  let varName = '<%contextCref(var.name,contextFunction,simCode)%>'
  let typ = '<%varType(var)%>'
  let initVar = match typ case "modelica_metatype" then ' = NULL' else ''
  let addRoot = match typ case "modelica_metatype" then ' mmc_GC_add_root(&<%varName%>, mmc_GC_local_state, "<%varName%>");' else ''  
  let &varDecls += if not outStruct then '<%typ%> <%varName%><%initVar%>;<%addRoot%><%\n%>' //else ""
  let varName = if outStruct then '<%outStruct%>.targ<%i%>' else '<%contextCref(var.name,contextFunction,simCode)%>'
  let instDimsInit = (instDims |> exp =>
      daeExp(exp, contextFunction, &varInits /*BUFC*/, &varDecls /*BUFD*/,simCode)
    ;separator=", ") 
  if instDims then
    (match var.value
    case SOME(exp) then
      let &varInits += 'alloc_<%expTypeShort(var.ty)%>_array(&<%varName%>, <%listLength(instDims)%>, <%instDimsInit%>);<%\n%>'
      let defaultValue = varDefaultValue(var, outStruct, i, varName, &varDecls, &varInits,simCode)
      let &varInits += defaultValue
      let var_name = if outStruct then 
        '<%extVarName(var.name,simCode)%>' else 
        '<%contextCref(var.name, contextFunction,simCode)%>' 
      let defaultValue1 = '<%var_name%> = <%daeExp(exp, contextFunction, &varInits  /*BUFC*/, &varDecls /*BUFD*/,simCode)%>;<%\n%>'
      let &varInits += defaultValue1
      " "
    else
      let &varInits += 'alloc_<%expTypeShort(var.ty)%>_array(&<%varName%>, <%listLength(instDims)%>, <%instDimsInit%>);<%\n%>'
      let defaultValue = varDefaultValue(var, outStruct, i, varName, &varDecls, &varInits,simCode)
     let &varInits += defaultValue
      "")
  else
    (match var.value
    case SOME(exp) then
      let defaultValue = '<%contextCref(var.name,contextFunction,simCode)%> = <%daeExp(exp, contextFunction, &varInits  /*BUFC*/, &varDecls /*BUFD*/,simCode)%>;<%\n%>'
      let &varInits += defaultValue

      " "
    else
      "")
case var as FUNCTION_PTR(__) then
  let &ignore = buffer ""
  let &varDecls += functionArg(var,&ignore)
  ""

end varInit;

template functionArg(Variable var, Text &varInit)
"Shared code for function arguments that are part of the function variables and valueblocks.
Valueblocks need to declare a reference to the function while input variables
need to initialize."
::=
match var
case var as FUNCTION_PTR(__) then
  let typelist = (args |> arg => mmcVarType(arg) ;separator=", ")
  let rettype = '<%name%>RetType'
  match tys
    case {} then
      let &varInit += '_<%name%> = (void(*)(<%typelist%>)) <%name%><%\n%>;'
      'void(*_<%name%>)(<%typelist%>);<%\n%>'
    else

      let &varInit += '_<%name%> = (<%rettype%>(*)(<%typelist%>)) <%name%>;<%\n%>'
      <<
      <% tys |> arg hasindex i1 fromindex 1 => '#define <%rettype%>_<%i1%> targ<%i1%>' ; separator="\n" %>
      typedef struct <%rettype%>_s
      {
        <% tys |> ty hasindex i1 fromindex 1 => 'modelica_<%mmcExpTypeShort(ty)%> targ<%i1%>;' ; separator="\n" %> 
      } <%rettype%>;
      <%rettype%>(*_<%name%>)(<%typelist%>);<%\n%>
      >>
  end match
end functionArg;

template mmcVarType(Variable var)
::=
  match var
  case VARIABLE(__) then 'modelica_<%mmcExpTypeShort(ty)%>'
  case FUNCTION_PTR(__) then 'modelica_fnptr'
end mmcVarType;

template mmcExpTypeShort(DAE.ExpType type)
::=
  match type
  case ET_INT(__)                     then "integer"
  case ET_REAL(__)                    then "real"
  case ET_STRING(__)                  then "string"
  case ET_BOOL(__)                    then "integer"
  case ET_ENUMERATION(__)             then "integer"
  case ET_ARRAY(__)                   then "array"
  case ET_METATYPE(__) case ET_BOXED(__)                then "metatype"
  case ET_FUNCTION_REFERENCE_VAR(__)  then "fnptr"
  else "mmcExpTypeShort:ERROR"
end mmcExpTypeShort;

template extVarName(ComponentRef cr, SimCode simCode)
::= '<%contextCref(cr,contextFunction,simCode)%>_ext'
end extVarName;

template varDefaultValue(Variable var, String outStruct, Integer i, String lhsVarName,  Text &varDecls /*BUFP*/, Text &varInits /*BUFP*/,SimCode simCode)
::=
match var
case var as VARIABLE(__) then
  match value
  case SOME(CREF(componentRef = cr)) then
    'copy_<%expTypeShort(var.ty)%>_array_data(&<%contextCref(cr,contextFunction,simCode)%>, &<%outStruct%>.targ<%i%>);<%\n%>'
  case SOME(arr as ARRAY(__)) then
    let arrayExp = '<%daeExp(arr, contextFunction, &varInits /*BUFC*/, &varDecls /*BUFD*/,simCode)%>'
    <<
    copy_<%expTypeShort(var.ty)%>_array_data(&<%arrayExp%>, &<%lhsVarName%>);<%\n%>
    >>
end varDefaultValue;


template funArgDefinition(Variable var,SimCode simCode)
::=
  match var
  case VARIABLE(__) then '<%varType(var)%> <%contextCref(name,contextFunction,simCode)%>'
  case FUNCTION_PTR(__) then 'modelica_fnptr <%name%>'
end funArgDefinition;

template varType(Variable var)
 "Generates type for a variable."
::=
match var
case var as VARIABLE(__) then
  if instDims then
    expTypeArray(var.ty)
  else
    expTypeArrayIf(var.ty)
end varType;

template funStatement(Statement stmt, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates function statements."
::=
  match stmt
  case ALGORITHM(__) then
    (statementLst |> stmt =>
      algStatement(stmt, contextFunction, &varDecls /*BUFD*/,simCode)
    ;separator="\n") 
  else
    "NOT IMPLEMENTED FUN STATEMENT"
end funStatement;

template init(SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
  <<
   void <%lastIdentOfPath(modelInfo.name)%>::init(double ts,double te)
   {  
   <%initvar(modelInfo,simCode)%>
   <%functionInitial(initialEquations,simCode)%>
    <%functionOnlyZeroCrossing(zeroCrossings,simCode)%>
    <%timeEventCondition(sampleConditions,simCode)%>
    <%eventHandlingInit(simCode)%>
    _event_handling.init(this,<%helpvarlength(simCode)%>);
    saveAll(); 
    vector<unsigned int> var_ouputs_idx;
   _historyImpl->setOutputs(var_ouputs_idx);
   _historyImpl->clear();
   }
   >>
end init;

template Update(SimCode simCode)
::=
match simCode
case SIMCODE(__) then
  <<
   <%update(odeEquations,algebraicEquations,whenClauses,parameterEquations,simCode)%>
  >>
end Update;
  
  
template writeoutput(SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
  <<  
   void <%lastIdentOfPath(modelInfo.name)%>::writeOutput(const OUTPUT command)
   {
  	//Write head line
	if (command & HEAD_LINE)
	{
	vector<string> head;
	head+= <%writeoutput1(modelInfo)%>
	_historyImpl->write(head);
	}
	//Write the current values
	else
	{
	HistoryImplType::value_type_v v(<%numAlgvars(modelInfo)%>+<%numStatevars(modelInfo)%>);
	HistoryImplType::value_type_dv v2(<%numDerivativevars(modelInfo)%>);
	 <%writeoutput2(modelInfo)%>
	 _historyImpl->write(v,v2,time);
	}
   }
  >>
end writeoutput;

template generateHeaderInlcudeString(SimCode simCode)
 "Generates header part of simulation file."
::=
match simCode
case SIMCODE(modelInfo=MODELINFO(__), extObjInfo=EXTOBJINFO(__)) then
  <<
  #pragma once
  #define BOOST_EXTENSION_SYSTEM_DECL BOOST_EXTENSION_IMPORT_DECL
  #define BOOST_EXTENSION_EVENTHANDLING_DECL BOOST_EXTENSION_IMPORT_DECL
  #include "System/Implementation/SystemDefaultImplementation.h"
  #include "Math/Implementation/ArrayOperations.h"
  #include "System/Implementation/EventHandling.h"
  #include "Settingsfactory/Interfaces/IGlobalSettings.h"
  #include "DataExchange/Interfaces/IHistory.h"
  #include "HistoryImpl.h"
  #include "policies/TextFileWriter.h"
  #include "Functions.h"

  /*****************************************************************************
  * 
  * Simulation code for <%lastIdentOfPath(modelInfo.name)%> generated by the OpenModelica Compiler.
  * System class <%lastIdentOfPath(modelInfo.name)%> implements the Interface IDAESystem
  *
  *****************************************************************************/
  
  typedef HistoryImpl<TextFileWriter,<%numAlgvars(modelInfo)%>+<%numStatevars(modelInfo)%>,<%numDerivativevars(modelInfo)%>> HistoryImplType;
  >>
end generateHeaderInlcudeString;

template generateClassDeclarationCode(SimCode simCode)
 "Generates class declarations."
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
  <<
  class <%lastIdentOfPath(modelInfo.name)%>: public IDAESystem ,public IContinous ,public IEvent ,public ISystemProperties, public SystemDefaultImplementation
  { 
  public: 
      <%lastIdentOfPath(modelInfo.name)%>(IGlobalSettings& globalSettings); 
      ~<%lastIdentOfPath(modelInfo.name)%>();
      
       <%generateMethodDeclarationCode(simCode)%>
  
  private:    
    //Methods:
	//Saves all variables before an event is handled, is needed for the pre, edge and change operator
     void saveAll();

	 void resetHelpVar(const int index);
	 
	 //Variables:
	 EventHandling _event_handling;
	 
     <%MemberVariable(modelInfo)%>
     <%conditionvariable(zeroCrossings,sampleConditions,simCode)%>
     Functions _functions;
     HistoryImplType* _historyImpl;
   };
  >>
end generateClassDeclarationCode;

template DefaultImplementationCode(SimCode simCode)

::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
<< 
  // Release instance
void <%lastIdentOfPath(modelInfo.name)%>::destroy()
{
	delete this;
}

// Set current integration time 
void <%lastIdentOfPath(modelInfo.name)%>::setTime(const double& t)
{
	SystemDefaultImplementation::setTime(t);
}

// Returns the vector with all time events 
event_times_type <%lastIdentOfPath(modelInfo.name)%>::getTimeEvents()
{
	return _event_handling.getTimeEvents();
}

// Provide number (dimension) of variables according to the index
int <%lastIdentOfPath(modelInfo.name)%>::getDimVars(const INDEX index) const
{
	return(SystemDefaultImplementation::getDimVars(index));
}

// Provide number (dimension) of right hand sides (equations and/or residuals) according to the index
int <%lastIdentOfPath(modelInfo.name)%>::getDimRHS(const INDEX index ) const
{
	 return(SystemDefaultImplementation::getDimRHS(index));
}

// Provide variables with given index to the system
void <%lastIdentOfPath(modelInfo.name)%>::giveVars(double* z, const INDEX index)
{	
	SystemDefaultImplementation::giveVars(z,index);
}

// Set variables with given index to the system
void <%lastIdentOfPath(modelInfo.name)%>::setVars(const double* z, const INDEX index)
{
	SystemDefaultImplementation::setVars(z,index);
}
 
// Provide the right hand side (according to the index)
void <%lastIdentOfPath(modelInfo.name)%>::giveRHS(double* f, const INDEX index)
{
	SystemDefaultImplementation::giveRHS(f,index);
}
void <%lastIdentOfPath(modelInfo.name)%>::giveJacobianSparsityPattern(SparcityPattern pattern)
{
  throw std::runtime_error("giveJacobianSparsityPattern is not yet implemented");	
}

void <%lastIdentOfPath(modelInfo.name)%>::giveJacobian(SparseMatrix matrix)
{
  throw std::runtime_error("giveJacobian is not yet implemented");	
}

void <%lastIdentOfPath(modelInfo.name)%>::giveMassSparsityPattern(SparcityPattern pattern)
{
  throw std::runtime_error("giveMassSparsityPattern is not yet implemented");	
}

void <%lastIdentOfPath(modelInfo.name)%>::giveMassMatrix(SparseMatrix matrix)
{
  throw std::runtime_error("giveMassMatrix is not yet implemented");	
}

void <%lastIdentOfPath(modelInfo.name)%>::giveConstraintSparsityPattern(SparcityPattern pattern)
{
  throw std::runtime_error("giveConstraintSparsityPattern is not yet implemented");	
}

void <%lastIdentOfPath(modelInfo.name)%>::giveConstraint(SparseMatrix matrix)
{
  throw std::runtime_error("giveConstraint is not yet implemented");	
}

bool <%lastIdentOfPath(modelInfo.name)%>::isAutonomous()
{
  throw std::runtime_error("isAutonomous is not yet implemented");	
}

bool <%lastIdentOfPath(modelInfo.name)%>::isTimeInvariant()
{
  throw std::runtime_error("isTimeInvariant is not yet implemented");	
}

bool <%lastIdentOfPath(modelInfo.name)%>::isAlgebraic()
{
  return false; // Indexreduction is enabled
}

bool <%lastIdentOfPath(modelInfo.name)%>::isExplicit()
{
  return true; // At the moment only explicit form is supported
}

bool <%lastIdentOfPath(modelInfo.name)%>::hasConstantMass()
{
  throw std::runtime_error("hasConstantMass is not yet implemented");	
}

bool <%lastIdentOfPath(modelInfo.name)%>::hasStateDependentMass()
{
  throw std::runtime_error("hasStateDependentMass is not yet implemented");	
}

bool <%lastIdentOfPath(modelInfo.name)%>::provideSymbolicJacobian()
{
  throw std::runtime_error("provideSymbolicJacobian is not yet implemented");	
}

void <%lastIdentOfPath(modelInfo.name)%>::handleEvent(unsigned long index)
{
 <%handleEvent(sampleConditions,simCode)%>
}
>>
end DefaultImplementationCode;

template generateMethodDeclarationCode(SimCode simCode)

::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
<< 
     //Releases the Modelica System 
	virtual void destroy();
    //provide number (dimension) of variables according to the index
	virtual int getDimVars(const INDEX index = ALL_VARS) const;
	//Provide number (dimension) of right hand sides (equations and/or residuals) according to the index 
	virtual int getDimRHS(const INDEX index = ALL_VARS)const;
    //(Re-) initialize the system of equations
	virtual void init(double ts,double te);
	//Resets all time events
	virtual void resetTimeEvents();
	//Set current integration time 
    virtual void setTime(const double& t);
	//Provide variables with given index to the system 
    virtual void giveVars(double* z, const INDEX index = ALL_VARS);
	//Set variables with given index to the system
	virtual void setVars(const double* z, const INDEX index = ALL_VARS);
	//Update transfer behavior of the system of equations according to command given by solver
	virtual void update(const UPDATE command =IContinous::UNDEF_UPDATE);
	//Provide the right hand side (according to the index)
	virtual void giveRHS(double* f, const INDEX index = ALL_VARS);
	//Output routine (to be called by the solver after every successful integration step)
	virtual void writeOutput(const OUTPUT command = UNDEF_OUTPUT);
	//Provide pattern for Jacobian
	virtual void giveJacobianSparsityPattern(SparcityPattern pattern);
	//Provide Jacobian
	virtual void giveJacobian(SparseMatrix matrix);
	//Provide pattern for mass matrix
	virtual void giveMassSparsityPattern(SparcityPattern pattern); 
	//Provide mass matrix 
	virtual void giveMassMatrix(SparseMatrix matrix);
	//Provide pattern for global constraint jacobian 
	virtual void giveConstraintSparsityPattern(SparcityPattern pattern);
	//Provide global constraint jacobian 
	virtual void giveConstraint(SparseMatrix matrix);
	//Provide number (dimension) of zero functions 
	virtual int getDimZeroFunc();
	//Provides current values of root/zero functions 
	 virtual void giveZeroFunc(double* f,const double& eps);
	//Called to handle all  events occured at same time  
	virtual void handleSystemEvents(const bool* events,update_events_type update_event);
	//Called to handle an event  
	virtual void handleEvent(unsigned long index);
	//Checks if a discrete variable has changed and triggers an event 
	virtual bool checkForDiscreteEvents();
	//Returns the vector with all time events 
	virtual event_times_type getTimeEvents();
	// No input
	virtual bool isAutonomous();
	// Time is not present
	virtual bool isTimeInvariant();
	// M is regular 
	virtual bool isODE();
	// M is singular 
	virtual bool isAlgebraic();
	//M = identity 
	virtual bool isExplicit(); 
	// M does not depend on t, z 
	virtual bool hasConstantMass(); 
	// M depends on z 
	virtual bool hasStateDependentMass(); 
	// System is able to provide the Jacobian symbolically 
	virtual bool provideSymbolicJacobian(); 
>>
end generateMethodDeclarationCode;

template MemberVariable(ModelInfo modelInfo)
 "Define membervariable in simulation file."
::=
match modelInfo
case MODELINFO(vars=SIMVARS(__)) then
  <<
  <%vars.algVars |> var =>
    MemberVariableDefine(var, "algebraics")
  ;separator="\n"%>
  <%vars.paramVars |> var =>
    MemberVariableDefine(var, "parameters")
  ;separator="\n"%>
   <%vars.aliasVars |> var =>
    MemberVariableDefine(var, "aliasVars")
  ;separator="\n"%>
  <%vars.intAlgVars |> var =>
    MemberVariableDefine(var, "intVariables.algebraics")
  ;separator="\n"%>
  <%vars.intParamVars |> var =>
    MemberVariableDefine(var, "intVariables.parameters")
  ;separator="\n"%>
   <%vars.intAliasVars |> var =>
    MemberVariableDefine(var, "intVariables.AliasVars")
  ;separator="\n"%>
  <%vars.boolAlgVars |> var =>
    MemberVariableDefine(var, "boolVariables.algebraics")
  ;separator="\n"%>
  <%vars.boolParamVars |> var =>
    MemberVariableDefine(var, "boolVariables.parameters")
  ;separator="\n"%>
   <%vars.boolAliasVars |> var =>
    MemberVariableDefine(var, "boolVariables.AliasVars")
  ;separator="\n"%>   
  <%vars.stringAlgVars |> var =>
    MemberVariableDefine(var, "stringVariables.algebraics")
  ;separator="\n"%>
  <%vars.stringParamVars |> var =>
    MemberVariableDefine(var, "stringVariables.parameters")
  ;separator="\n"%>
  <%vars.stringAliasVars |> var =>
    MemberVariableDefine(var, "stringVariables.AliasVars")
  ;separator="\n"%>
   <%vars.constVars |> var =>
    MemberVariableDefine(var, "constvariables")
  ;separator="\n"%>
   <%vars.intConstVars |> var =>
    MemberVariableDefine(var, "intConstvariables")
  ;separator="\n"%>
   <%vars.boolConstVars |> var =>
    MemberVariableDefine(var, "boolConstvariables")
  ;separator="\n"%>
   <%vars.stringConstVars |> var =>
    MemberVariableDefine(var, "stringConstvariables")
  ;separator="\n"%>
  >>
end MemberVariable;


template MemberVariableDefine(SimVar simVar, String arrayName)
::=
match simVar
  	case SIMVAR(numArrayElement={}) then
      <<
       <%variableType(type_)%> <%cref(name)%>;
       >>
    case v as SIMVAR(name=CREF_IDENT(subscriptLst = sub),arrayCref=SOME(_),numArrayElement=num) then
      <<
       multi_array<<%variableType(type_)%>,<%listLength(sub)%>> <%arraycref(name)%>;
       >>
     case v as SIMVAR(name=CREF_QUAL(componentRef=CREF_IDENT(subscriptLst = sub)),arrayCref=SOME(_),numArrayElement=num) then
      <<
       multi_array<<%variableType(type_)%>,<%listLength(sub)%>> <%arraycref(name)%>;
       >>
end MemberVariableDefine;

template arrayConstruct(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(vars = vars as SIMVARS(__)) 
  then
  <<
  <%arrayConstruct1(vars.algVars)%>
  <%arrayConstruct1(vars.intAlgVars)%>
  <%arrayConstruct1(vars.boolAlgVars)%>
  <%arrayConstruct1(vars.stringAlgVars)%>
  <%arrayConstruct1(vars.paramVars)%>
  <%arrayConstruct1(vars.intParamVars)%>
  <%arrayConstruct1(vars.boolParamVars)%>
  <%arrayConstruct1(vars.stringParamVars)%>
  <%arrayConstruct1(vars.aliasVars)%>
  <%arrayConstruct1(vars.intAliasVars)%>
  <%arrayConstruct1(vars.boolAliasVars)%>
  <%arrayConstruct1(vars.stringAliasVars)%>
  <%arrayConstruct1(vars.constVars)%>
  <%arrayConstruct1(vars.intConstVars)%>
  <%arrayConstruct1(vars.boolConstVars)%>
  <%arrayConstruct1(vars.stringConstVars)%>
  >>
end arrayConstruct;

template arrayConstruct1(list<SimVar> varsLst) ::=
  varsLst |> v as SIMVAR(arrayCref=SOME(_)) =>
  <<
    ,<%arraycref(name)%>(boost::extents[<%v.numArrayElement;separator="]["%>])
  >> 
  ;separator="\n"
end arrayConstruct1;

template variableType(DAE.ExpType type)
 "Generates integer for use in arrays in global data section."
::=
  match type
  case ET_REAL(__)        then "double"
  case ET_STRING(__)      then "string"
  case ET_INT(__)         then "int"
  case ET_BOOL(__)        then "bool"
end variableType;

template lastIdentOfPath(Path modelName) ::=
  match modelName
  case QUALIFIED(__) then lastIdentOfPath(path)
  case IDENT(__)     then name
  case FULLYQUALIFIED(__) then lastIdentOfPath(path)
end lastIdentOfPath;

template cref(ComponentRef cr)
 "Generates C equivalent name for component reference."
::=
  match cr
  case CREF_IDENT(ident = "xloc") then crefStr(cr)
  case CREF_IDENT(ident = "time") then "time"
  case WILD(__) then ''
  else "$"+crefToCStr(cr)
end cref;

template cref2(ComponentRef cr)
 "Generates C equivalent name for component reference."
::=
  match cr
  case CREF_IDENT(ident = "xloc") then crefStr(cr)
  case CREF_IDENT(ident = "time") then "time"
  case WILD(__) then ''
  else crefToCStr(cr)
end cref2;

template crefToCStr(ComponentRef cr)
 "Helper function to cref."
::=
  match cr
  case CREF_IDENT(__) then '<%ident%><%subscriptsToCStr(subscriptLst)%>'
  case CREF_QUAL(__) then '<%ident%><%subscriptsToCStr(subscriptLst)%>$P<%crefToCStr(componentRef)%>'
  case WILD(__) then ''
  else "CREF_NOT_IDENT_OR_QUAL"
end crefToCStr;

template crefToCStr2(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(__) then '<%ident%>'
  case CREF_QUAL(__) then '<%ident%>'
  case WILD(__) then ''
  else "CREF_NOT_IDENT_OR_QUAL"
end crefToCStr2;

template subscriptsToCStr(list<Subscript> subscripts)
::=
  if subscripts then
    '[<%subscripts |> s => subscriptToCStr(s) ;separator="]["%>]'
end subscriptsToCStr;

template subscriptToCStr(Subscript subscript)
::=
  match subscript
  case INDEX(exp=ICONST(integer=i)) then i
  case SLICE(exp=ICONST(integer=i)) then i
  case WHOLEDIM(__) then "WHOLEDIM"
  else "UNKNOWN_SUBSCRIPT"
end subscriptToCStr;

template arraycref(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(ident = "xloc") then crefStr(cr)
  case CREF_IDENT(ident = "time") then "time"
  case WILD(__) then ''
  else "$"+crefToCStr1(cr)
end arraycref;

template crefToCStr1(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(__) then '<%ident%>'
  case CREF_QUAL(__) then '<%ident%><%subscriptsToCStr(subscriptLst)%>$P<%crefToCStr2(componentRef)%>'
  case WILD(__) then ''
  else "CREF_NOT_IDENT_OR_QUAL"
end crefToCStr1;

template crefStr(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(__) then '<%ident%><%subscriptsStr(subscriptLst)%>'
  // Are these even needed? Function context should only have CREF_IDENT :)
  case CREF_QUAL(ident = "$DER") then 'der(<%crefStr(componentRef)%>)'
  case CREF_QUAL(__) then '<%ident%><%subscriptsStr(subscriptLst)%>.<%crefStr(componentRef)%>'
  else "CREF_NOT_IDENT_OR_QUAL"
end crefStr;

template subscriptsStr(list<Subscript> subscripts)
 "Generares subscript part of the name."
::=
  if subscripts then
    '[<%subscripts |> s => subscriptStr(s) ;separator=","%>]'
end subscriptsStr;

template subscriptStr(Subscript subscript)
 "Generates a single subscript.
  Only works for constant integer indicies."
::=
  match subscript
  case INDEX(exp=ICONST(integer=i)) then i
  case SLICE(exp=ICONST(integer=i)) then i
  case WHOLEDIM(__) then "WHOLEDIM"
  else "UNKNOWN_SUBSCRIPT"
end subscriptStr;

template simulationInitFile(SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(varInfo = vi as VARINFO(__), vars = vars as SIMVARS(__))) 
  then
  <<
  <%arrayConstruct(modelInfo)%>
  <%initVals(vars.paramVars)%>
  <%initVals(vars.intParamVars)%>
  <%initVals(vars.boolParamVars)%>
  <%initVals(vars.stringParamVars)%>
  >>
end simulationInitFile;

template initVals(list<SimVar> varsLst) ::=
  varsLst |> SIMVAR(numArrayElement={}) =>
  <<
    ,<%cref(name)%>(<%match initialValue 
    case SOME(v) then initVal(v)
      else ""
    %>) 
    >>  
  ;separator="\n"
end initVals;

template arrayInit(SimCode simCode)
 "Generates the contents of the makefile for the simulation case."
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(varInfo = vi as VARINFO(__), vars = vars as SIMVARS(__))) 
  then
  <<
  <%initVals1(vars.paramVars)%>
  <%initVals1(vars.intParamVars)%>
  <%initVals1(vars.boolParamVars)%>
  <%initVals1(vars.stringParamVars)%>
  >>
end arrayInit;

template initVals1(list<SimVar> varsLst) ::=
  varsLst |> SIMVAR(name=CREF_IDENT(subscriptLst=_)) =>
  <<
    <%cref(name)%>=<%match initialValue 
    case SOME(v) then initVal(v)
      else ""
    %>;
    >> 
  ;separator="\n"
end initVals1;

template arrayReindex(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(vars = vars as SIMVARS(__)) 
  then
  <<
  <%arrayReindex1(vars.algVars)%>
  <%arrayReindex1(vars.intAlgVars)%>
  <%arrayReindex1(vars.boolAlgVars)%>
  <%arrayReindex1(vars.stringAlgVars)%>
  <%arrayReindex1(vars.paramVars)%>
  <%arrayReindex1(vars.intParamVars)%>
  <%arrayReindex1(vars.boolParamVars)%>
  <%arrayReindex1(vars.stringParamVars)%>
  <%arrayReindex1(vars.aliasVars)%>
  <%arrayReindex1(vars.intAliasVars)%>
  <%arrayReindex1(vars.boolAliasVars)%>
  <%arrayReindex1(vars.stringAliasVars)%>
  <%arrayReindex1(vars.constVars)%>
  <%arrayReindex1(vars.intConstVars)%>
  <%arrayReindex1(vars.boolConstVars)%>
  <%arrayReindex1(vars.stringConstVars)%>
  >>
end arrayReindex;

template arrayReindex1(list<SimVar> varsLst) ::=
  varsLst |> SIMVAR(arrayCref=SOME(_)) =>
  <<
    <%arraycref(name)%>.reindex(1);
  >> 
  ;separator="\n"
end arrayReindex1;


template initVal(Exp initialValue) 
::=
  match initialValue 
  case ICONST(__) then integer
  case RCONST(__) then real
  case SCONST(__) then '"<%Util.escapeModelicaStringToCString(string)%>"'
  case BCONST(__) then if bool then "true" else "false"
  case ENUM_LITERAL(__) then '<%index%>/*ENUM:<%dotPath(name)%>*/'
  else "*ERROR* initial value of unknown type"
end initVal;

template dotPath(Path path)
 "Generates paths with components separated by dots."
::=
  match path
  case QUALIFIED(__)      then '<%name%>.<%dotPath(path)%>'

  case IDENT(__)          then name
  case FULLYQUALIFIED(__) then dotPath(path)
end dotPath;

template writeoutput1(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(vars=SIMVARS(__)) then
  <<  
      <%{(vars.algVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.intAlgVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.boolAlgVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.aliasVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.intAliasVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.boolAliasVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.stateVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=","),
      (vars.derivativeVars |> SIMVAR(__) =>
        ' "<%crefStr(name)%>" '
      ;separator=",")}
    ;separator=","%>;
  >>    
end writeoutput1;

template numStatevars(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(varInfo=VARINFO(__)) then
<<
  <%varInfo.numStateVars%>
>>
end numStatevars;

template numAlgvars(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(varInfo=VARINFO(__)) then
<<
  <%varInfo.numAlgVars%>+<%varInfo.numIntAlgVars%>+<%varInfo.numBoolAlgVars%>
>>
end numAlgvars;

template numAlgvar(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(varInfo=VARINFO(__)) then
<<
  <%varInfo.numAlgVars%>
>>
end numAlgvar;

template numIntAlgvar(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(varInfo=VARINFO(__)) then
<<
  <%varInfo.numIntAlgVars%>
>>
end numIntAlgvar;


template numDerivativevars(ModelInfo modelInfo)
::=
match modelInfo
case MODELINFO(varInfo=VARINFO(__)) then
<<
  <%varInfo.dimODE1stOrder%>+<%varInfo.dimODE2ndOrder%>
>>
end numDerivativevars;


template writeoutput2(ModelInfo modelInfo)

::=
match modelInfo
case MODELINFO(vars=SIMVARS(__)) then
 <<  
     <%vars.algVars |> SIMVAR(__) =>'v(<%index%>)=<%cref(name)%>;'%>
     <%vars.intAlgVars |> SIMVAR(__) =>'v(<%numAlgvar(modelInfo)%>+<%index%>)=<%cref(name)%>;'%>
     <%vars.boolAlgVars |> SIMVAR(__) =>'v(<%numAlgvar(modelInfo)%>+<%numIntAlgvar(modelInfo)%>+<%index%>)=<%cref(name)%>;'%>
     <%(vars.stateVars  |> SIMVAR(__) =>' v(<%numAlgvars(modelInfo)%>+<%index%>)=_z[<%index%>]; ')%>
     <%(vars.derivativeVars  |> SIMVAR(__) =>' v2(<%index%>)=_zDot[<%index%>]; ')%>
   
 
 >>
end writeoutput2;


template saveall(ModelInfo modelInfo, SimCode simCode)
 
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(vars = vars as SIMVARS(__))) 
  then
  <<  
    void <%lastIdentOfPath(modelInfo.name)%>::saveAll()
    { 
      <%{(vars.algVars |> SIMVAR(__) =>
        '_event_handling.save(<%cref(name)%>,"<%cref(name)%>");'
      ;separator="\n"),
      (vars.intAlgVars |> SIMVAR(__) =>
       '_event_handling.save(<%cref(name)%>,"<%cref(name)%>");'
      ;separator="\n"),
      (vars.boolAlgVars |> SIMVAR(__) =>
        '_event_handling.save(<%cref(name)%>,"<%cref(name)%>");'
      ;separator="\n"),
      (vars.stateVars |> SIMVAR(__) =>
        '_event_handling.save(_z[<%index%>],"<%cref(name)%>");'
      ;separator="\n")}
     ;separator="\n"%>
     _event_handling.saveH();
    }
  >>    
end saveall;

template initvar(ModelInfo modelInfo,SimCode simCode)
::=
match modelInfo
case MODELINFO(vars=SIMVARS(__)) then
 <<  
  <%initValst(vars.stateVars, simCode)%> 
  <%initValst(vars.derivativeVars, simCode)%>
  <%initValst(vars.algVars, simCode)%>
  <%initValst(vars.intAlgVars, simCode)%>
  <%initValst(vars.boolAlgVars, simCode)%>
  <%initValst(vars.aliasVars, simCode)%>
  <%initValst(vars.intAliasVars, simCode)%>
  <%initValst(vars.boolAliasVars, simCode)%>
  <%initValst(vars.constVars, simCode)%>
  <%initValst(vars.intConstVars, simCode)%>
  <%initValst(vars.boolConstVars, simCode)%>
  <%initValst(vars.stringConstVars, simCode)%>
 >>
end initvar;

template initValst(list<SimVar> varsLst, SimCode simCode) ::=
  varsLst |> sv as SIMVAR(__) =>
	match initialValue 
  	case SOME(v) then 
      let &preExp = buffer "" //dummy ... the value is always a constant
      let &varDecls = buffer ""
      match daeExp(v, contextOther, &preExp, &varDecls,simCode)
      case vStr as "0"
      case vStr as "0.0"
      case vStr as "(0)" then
       '<%cref1(sv.name,simCode)%>=<%vStr%>;//<%cref(sv.name)%>'  
      case vStr then
       '<%cref1(sv.name,simCode)%>=<%vStr%>;//<%cref(sv.name)%>' 
  	  end match
  	else '<%cref1(sv.name,simCode)%>=0;'
  ;separator="\n"
end initValst;

//template initValst1(list<SimVar> varsLst, SimCode simCode) ::=
  //varsLst |> sv as SIMVAR(__) =>
	// match aliasvar 
  	//case ALIAS(__) then 
  	 //'<%cref1(sv.name,simCode)%>=$<%crefStr(varName)%>;'
  	 //else
      //'<%initValst(varsLst,simCode)%>'
//end initValst1;

template eventHandlingInit(SimCode simCode)

::=
match simCode
case SIMCODE(__) then
  << 
      for(int i=0;i<=<%helpvarlength(simCode)%>;++i) { handleEvent(i); }
  >>
end eventHandlingInit;
  

template dimension1(SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(varInfo = vi as VARINFO(__)))
then
 <<
    <%modelInfo.varInfo |> VARINFO(__) =>'<%match dimODE1stOrder 
    case SOME(v) then 
               <<
                 _dimODE1stOrder = <%vi.dimODE1stOrder%>;
               >>
      else ""%> ';separator=";\n"%>
    <%modelInfo.varInfo |> VARINFO(__) =>'<%match dimODE2ndOrder 
    case SOME(v) then 
                <<
                 _dimODE2ndOrder = <%vi.dimODE2ndOrder%>;
               >> 
      else ""%> ';separator=";\n"%>
  
 >>
end dimension1;

template isODE(SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(varInfo = vi as VARINFO(__)))
then
<< 
   bool <%lastIdentOfPath(modelInfo.name)%>::isODE()
 {
  return <%vi.numStateVars%>>0 ;
 }
>>
end isODE;


template contextArrayCref(ComponentRef cr, Context context)
 "Generates code for an array component reference depending on the context."
::=
  match context
  case FUNCTION_CONTEXT(__) then "_" + arrayCrefStr(cr)
  else arrayCrefCStr(cr)
end contextArrayCref;

template arrayCrefStr(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(__) then '<%ident%>'
  case CREF_QUAL(__) then '<%ident%>.<%arrayCrefStr(componentRef)%>'
  else "CREF_NOT_IDENT_OR_QUAL"
end arrayCrefStr;

template expTypeFlag(DAE.ExpType ty, Integer flag)

::=
  match flag
  case 1 then
    // we want the short type
    expTypeShort(ty)
  case 2 then
    // we want the "modelica type"
    match ty case ET_COMPLEX(complexClassType=EXTERNAL_OBJ(__)) then
      '<%expTypeShort(ty)%>'
    else match ty case ET_COMPLEX(__) then
      'struct <%underscorePath(name)%>'
    else
      '<%expTypeShort(ty)%>'
  case 3 then
    // we want the "array type"
    '<%expTypeShort(ty)%>'  
  case 4 then
    // we want the "array type" only if type is array, otherwise "modelica type"
    match ty
    case ET_ARRAY(__) then '<%expTypeShort(ty)%>'
    else expTypeFlag(ty, 2)
    end match
  case 5 then 
     match ty 
    case ET_ARRAY(ty=aty,arrayDimensions=dims) then '<%listLength(dims)%>'
end expTypeFlag;

template expTypeArray(DAE.ExpType ty)

::=
  expTypeFlag(ty, 3)
end expTypeArray;

template expTypeArrayforDim(DAE.ExpType ty)

::=
  expTypeFlag(ty, 5)
end expTypeArrayforDim;

template expTypeShort(DAE.ExpType type)

::=
  match type
  case ET_INT(__)         then "int"  
  case ET_REAL(__)        then "double"
  case ET_STRING(__)      then if acceptMetaModelicaGrammar() then "metatype" else "string"
  case ET_BOOL(__)        then "bool"
  case ET_ENUMERATION(__) then "int"  
  case ET_OTHER(__)       then "complex"
  case ET_ARRAY(__)       then expTypeShort(ty)   
  case ET_COMPLEX(complexClassType=EXTERNAL_OBJ(__))
                      then "complex"
  case ET_COMPLEX(__)     then 'struct <%underscorePath(name)%>'  
  case ET_METATYPE(__) case ET_BOXED(__)    then "metatype"
  case ET_FUNCTION_REFERENCE_VAR(__) then "fnptr"
  else "expTypeShort:ERROR"
end expTypeShort;

template dimension(Dimension d)
::=
  match d
  case DAE.DIM_INTEGER(__) then integer
  case DAE.DIM_ENUM(__) then size
  case DAE.DIM_UNKNOWN(__) then ":"
  else "INVALID_DIMENSION"
end dimension;

template arrayCrefCStr(ComponentRef cr)
::= '$<%arrayCrefCStr2(cr)%>'
end arrayCrefCStr;

template arrayCrefCStr2(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(__) then '<%unquoteIdentifier(ident)%>'
  case CREF_QUAL(__) then '<%unquoteIdentifier(ident)%>$P<%arrayCrefCStr2(componentRef)%>'
  else "CREF_NOT_IDENT_OR_QUAL"
end arrayCrefCStr2;

template underscorePath(Path path)
 "Generate paths with components separated by underscores.
  Replaces also the . in identifiers with _. 
  The dot might happen for world.gravityAccleration"
::=
  match path
  case QUALIFIED(__) then
    '<%replaceDotAndUnderscore(name)%>_<%underscorePath(path)%>'
  case IDENT(__) then
    replaceDotAndUnderscore(name)
  case FULLYQUALIFIED(__) then
    underscorePath(path)
end underscorePath;

template replaceDotAndUnderscore(String str)
 "Replace _ with __ and dot in identifiers with _"
::=
  match str
  case name then
    let str_dots = System.stringReplace(name,".", "_")  
    let str_underscores = System.stringReplace(str_dots, "_", "__")
    '<%str_underscores%>'
end replaceDotAndUnderscore;

template tempDecl(String ty, Text &varDecls /*BUFP*/)
 "Declares a temporary variable in varDecls and returns the name."
::=
  let newVar = 'tmp<%System.tmpTick()%>'
  let &varDecls += '<%ty%> <%newVar%>;<%\n%>'
  newVar
end tempDecl;


template contextCref(ComponentRef cr, Context context,SimCode simCode)
  "Generates code for a component reference depending on which context we're in."
::=
  match context
  case FUNCTION_CONTEXT(__) then crefStr(cr)
  else cref1(cr,simCode)
end contextCref;

template crefFunctionName(ComponentRef cr)
::=
  match cr
  case CREF_IDENT(__) then 
    System.stringReplace(unquoteIdentifier(ident), "_", "__")
  case CREF_QUAL(__) then 
    '<%System.stringReplace(unquoteIdentifier(ident), "_", "__")%>_<%crefFunctionName(componentRef)%>'
end crefFunctionName;

template functionInitial(list<SimEqSystem> initialEquations,SimCode simCode)

::=
  let &preExp = buffer "" /*BUFD*/
 
  let eqPart = (initialEquations |> eq as SES_SIMPLE_ASSIGN(__) =>
      equation_(eq, contextOther, &preExp,simCode)
    ;separator="\n")
  <<
    <%preExp%>
    <%eqPart%>
  >>
end functionInitial;


template equation_(SimEqSystem eq, Context context, Text &varDecls, SimCode simCode)
 "Generates an equation.
  This template should not be used for a SES_RESIDUAL.
  Residual equations are handled differently."
::=
  match eq
  case e as SES_SIMPLE_ASSIGN(__)
    then equationSimpleAssign(e, context,&varDecls,simCode)
  case e as SES_ALGORITHM(__)
    then equationAlgorithm(e, context, &varDecls /*BUFD*/,simCode)
  case e as SES_WHEN(__)
    then equationWhen(e, context, &varDecls /*BUFD*/,simCode)
  case e as SES_ARRAY_CALL_ASSIGN(__)
    then equationArrayCallAssign(e, context, &varDecls /*BUFD*/,simCode)
  case e as SES_NONLINEAR(__)
    then equationNonlinear(e, context, &varDecls /*BUFD*/,simCode)
  else
    "NOT IMPLEMENTED EQUATION"
end equation_;

template equationNonlinear(SimEqSystem eq, Context context, Text &varDecls /*BUFP*/, SimCode simCode)
 "Generates a non linear equation system."
::=
match eq
case SES_NONLINEAR(__) then
  let size = listLength(crefs)
  <<
  start_nonlinear_system(<%size%>);
  <%crefs |> name hasindex i0 =>
    <<
    nls_x[<%i0%>] = extraPolate(<%cref(name)%>);
    nls_xold[<%i0%>] = old(&<%cref(name)%>);
    >>
  ;separator="\n"%>
  solve_nonlinear_system(residualFunc<%index%>,<%index%>);
  <%crefs |> name hasindex i0 => '<%cref(name)%> = nls_x[<%i0%>];' ;separator="\n"%>
  end_nonlinear_system();
  >>
end equationNonlinear;

template equationArrayCallAssign(SimEqSystem eq, Context context,
                                 Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates equation on form 'cref_array = call(...)'."
::=
match eq

case eqn as SES_ARRAY_CALL_ASSIGN(__) 
  then
    <<
      .......
    >>
end equationArrayCallAssign;
 
template equationWhen(SimEqSystem eq, Context context, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates a when equation."
::=
match eq
 case SES_WHEN(__) then
  let &preExp = buffer ""
  let &helpInits = buffer "" /*BUFD*/
  let helpIf = (conditions |>(e, hidx) =>
    let helpInit = daeExp(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
      let &preExp +=""
      '_event_handling.edge(_event_handling[<%hidx%>],"h<%hidx%>")'
   ;separator="||")
  let &preExp2 = buffer ""
  let rightExp = daeExp(right, context, &preExp2,&varDecls,simCode)
  <<
  <%preExp%>
  <%helpInits%>
  if (<%helpIf%>) {
    <%preExp2%>
    <%cref1(left, simCode)%> = <%rightExp%>;
  } 
  >>
 else  
  "UNKNOWN_equation"
end equationWhen;

template helpvarvector(list<SimWhenClause> whenClauses,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  let reinit = (whenClauses |> when hasindex i0 =>
      helpvarvector1(when, contextOther,&varDecls,i0,simCode)
    ;separator="")
  <<
    <%reinit%>
  >>
end helpvarvector;

template helpvarvector1(SimWhenClause whenClauses,Context context, Text &varDecls,Integer int,SimCode simCode)
::=
match whenClauses
case SIM_WHEN_CLAUSE(__) then
  let &preExp = buffer "" /*BUFD*/
  let &helpInits = buffer "" /*BUFD*/
  let helpIf = (conditions |> (e, hidx) =>
      let helpInit = daeExp(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
      let &preExp +='h[<%hidx%>]=<%helpInit%>;<%\n%>'
      ""
   ;separator="")      
<<
 <%preExp%>
  <%helpIf%>
>>
end helpvarvector1;

template resethelpvar(list<SimWhenClause> whenClauses,SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
  <<
   void <%lastIdentOfPath(modelInfo.name)%>::resetHelpVar(const int index)
   {
    <%resethelpvar2(whenClauses,simCode)%>
   }
  >>
end resethelpvar;

template resethelpvar2(list<SimWhenClause> whenClauses,SimCode simCode)

::=
  let &varDecls = buffer "" /*BUFD*/
  let reinit = (whenClauses |> when hasindex i0 =>
      resethelpvar1(when, contextOther,&varDecls,i0,simCode)
    ;separator="\n")
  <<
    <%reinit%>
  >>
end resethelpvar2;

template resethelpvar1(SimWhenClause whenClauses,Context context, Text &varDecls,Integer int,SimCode simCode)
::=
  match whenClauses
  case SIM_WHEN_CLAUSE(__) then
  let &preExp = buffer "" /*BUFD*/
  let &helpInits = buffer "" /*BUFD*/
  let helpIf = (conditions |> (e, hidx) =>
      let helpInit = daeExp(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
   let &preExp += ""
    ' if(index==<%hidx%>)
     _event_handling.setHelpVar(<%hidx%>,<%helpInit%>);
    '
   )
   
 <<
  <%preExp%>
  <%helpIf%>
 >>

end resethelpvar1;

template preCref(ComponentRef cr, SimCode simCode) ::=
'pre<%representationCref(cr, simCode)%>'
end preCref;

template equationSimpleAssign(SimEqSystem eq, Context context,Text &varDecls,
                              SimCode simCode)
 "Generates an equation that is just a simple assignment."
::=
match eq
case SES_SIMPLE_ASSIGN(__) then
  let &preExp = buffer "" /*BUFD*/
  let expPart = daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  <<
  <%preExp%>
  <%cref1(cref, simCode)%>=<%expPart%>;
  >>

end equationSimpleAssign;





template daeExp(Exp exp, Context context, Text &preExp /*BUFP*/, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for an expression."
::=
  match exp
  case e as ICONST(__)          then '<%integer%>' /* Yes, we need to cast int to long on 64-bit arch... */
  case e as RCONST(__)          then real
  case e as BCONST(__)          then if bool then "(1)" else "(0)" 
  case e as CREF(__)            then daeExpCrefRhs(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as CAST(__)            then daeExpCast(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as SCONST(__)          then daeExpSconst(string, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as UNARY(__)           then daeExpUnary(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as LBINARY(__)         then daeExpLbinary(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as LUNARY(__)          then daeExpLunary(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as BINARY(__)          then daeExpBinary(operator, exp1, exp2, context, &preExp, &varDecls,simCode)
  case e as IFEXP(__)           then daeExpIf(expCond, expThen, expElse, context, &preExp /*BUFC*/, &varDecls /*BUFD*/, simCode)
  case e as RELATION(__)        then daeExpRelation(operator, index,exp1, exp2, context, &preExp, &varDecls,simCode)
  case e as CALL(__)            then daeExpCall(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as ASUB(__)            then daeExpAsub(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case e as ARRAY(__)           then daeExpArray(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  else ""
end daeExp;

template daeExpArray(Exp exp, Context context, Text &preExp /*BUFP*/,
                     Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for an array expression."
::=
match exp
case ARRAY(__) then
  let arrayTypeStr = expTypeArray(ty)

  let arrayDim = expTypeArrayforDim(ty)
  let arrayVar = tempDecl(arrayTypeStr, &varDecls /*BUFD*/)
  let scalarPrefix = if scalar then "scalar_" else ""
  let scalarRef = if scalar then "&" else ""
  let params = (array |> e =>
      '<%daeExp(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)%>'
    ;separator=", ")
   let &preExp += '
   short array_short[]={<%params%>};'
  arrayVar
end daeExpArray;


template daeExpAsub(Exp exp, Context context, Text &preExp /*BUFP*/,
                    Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for an asub expression."
::=
 match exp
   case ASUB(exp=ecr as CREF(__), sub=subs) then
    let arrName = daeExpCrefRhs(buildCrefExpFromAsub(ecr, subs), context,
                              &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    match context case FUNCTION_CONTEXT(__)  then
      arrName
    else
      arrayScalarRhs(exp, subs, arrName, context, &preExp, &varDecls,simCode)

end daeExpAsub;

template arrayScalarRhs(Exp exp, list<Exp> subs, String arrName, Context context,
               Text &preExp /*BUFP*/, Text &varDecls /*BUFP*/,SimCode simCode)
 "Helper to daeExpAsub."
::=
   match exp
   case ASUB(exp=ecr as CREF(__)) then
  let arrayType = expTypeArray(exp.ty)
  let dimsLenStr = listLength(subs)
  let dimsValuesStr = (subs |> exp =>
      daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)

    ;separator="][")
  match arrayType
    case "metatype_array" then
      'arrayGet(<%arrName%>,<%dimsValuesStr%>) /*arrayScalarRhs*/'
    else
      <<
      <%arrayCrefCStr(ecr.componentRef)%>[<%dimsValuesStr%>]
      >>
end arrayScalarRhs;

template daeExpCast(Exp exp, Context context, Text &preExp /*BUFP*/,
                    Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a cast expression."
::=
match exp
case CAST(__) then
  let expVar = daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  match ty
  case ET_INT(__)   then '((int)<%expVar%>)'  
  case ET_REAL(__)  then '((double)<%expVar%>)'
  case ET_ENUMERATION(__)   then '((modelica_integer)<%expVar%>)'
  case ET_BOOL(__)   then '((bool)<%expVar%>)'  
  case ET_ARRAY(__) then
    let arrayTypeStr = expTypeArray(ty)
    let tvar = tempDecl(arrayTypeStr, &varDecls /*BUFD*/)
    let to = expTypeShort(ty)
    let from = expTypeFromExpShort(exp)
    let &preExp += 'cast_<%from%>_array_to_<%to%>(&<%expVar%>, &<%tvar%>);<%\n%>'
    '<%tvar%>'
  else 
    '(<%expVar%>) /* could not cast, using the variable as it is */'
end daeExpCast;

template daeExpCall(Exp call, Context context, Text &preExp /*BUFP*/,
                    Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a function call."
::=
  match call
  // special builtins
  
  case CALL(path=IDENT(name="edge"),
            expLst={e1}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    '_event_handling.edge(<%var1%>,"<%var1%>")'
    
  case CALL(path=IDENT(name="pre"),
            expLst={arg as CREF(__)}) then
    let var1 = daeExp(arg, context, &preExp, &varDecls,simCode)
    '_event_handling.pre(<%var1%>,"<%cref(arg.componentRef)%>")'
    
  case CALL(path=IDENT(name="sample"), expLst={start, interval,index}) then
    let &preExp = buffer "" /*BUFD*/
    let eStart = daeExp(start, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
    let eInterval = daeExp(interval, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
    let eIndex = daeExp(index, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
     '_condition<%eIndex%>'
    
  case CALL(path=IDENT(name="DIVISION"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    '(<%var1%>/<%var2%>)'
  
  case CALL(path=IDENT(name="DIVISION_ARRAY_SCALAR"),
            expLst={e1, e2, DAE.SCONST(string=string)},attr=attr as CALL_ATTR(__)) then
    let type = match attr.ty case ET_ARRAY(ty=ET_INT(__)) then "integer_array" 
                        case ET_ARRAY(ty=ET_ENUMERATION(__)) then "integer_array"
                        else "real_array"
    let var = tempDecl(type, &varDecls)
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    let var3 = Util.escapeModelicaStringToCString(string)
    let &preExp += 'division_alloc_<%type%>_scalar(&<%var1%>, <%var2%>, &<%var%>,"<%var3%>");<%\n%>'
    '<%var%>'
    
  case CALL(path=IDENT(name="der"), expLst={arg as CREF(__)}) then
    '$P$DER<%cref(arg.componentRef)%>'
  case CALL(path=IDENT(name="pre"), expLst={arg as CREF(__)}) then
    let retType = '<%expTypeArrayIf(arg.ty)%>'
    let retVar = tempDecl(retType, &varDecls /*BUFD*/)
    let cast = match arg.ty case ET_INT(__) then "(int)" 
                            case ET_ENUMERATION(__) then "(int)" //else ""
    let &preExp += '<%retVar%> = <%cast%>pre(<%cref(arg.componentRef)%>);<%\n%>'
    '<%retVar%>'
  
  case CALL(path=IDENT(name="print"), expLst={e1}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    if acceptMetaModelicaGrammar() then 'print(<%var1%>)' else 'puts(<%var1%>)'
  
  case CALL(path=IDENT(name="max"), attr=CALL_ATTR(ty = ET_REAL()), expLst={e1,e2}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'fmax(<%var1%>,<%var2%>)'
  
  case CALL(path=IDENT(name="max"), expLst={e1,e2}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'int_max((int)<%var1%>,(int)<%var2%>)'
  
  case CALL(attr=CALL_ATTR(ty = ET_REAL()),
            path=IDENT(name="min"), expLst={e1,e2}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'fmin(<%var1%>,<%var2%>)'
  
  case CALL(path=IDENT(name="min"), expLst={e1,e2}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'int_min((int)<%var1%>,(int)<%var2%>)'
  
  case CALL(path=IDENT(name="abs"), expLst={e1}, attr=CALL_ATTR(ty = ET_INT())) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    'labs(<%var1%>)'
  
  case CALL(path=IDENT(name="abs"), expLst={e1}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    'fabs(<%var1%>)'
  
  case CALL(path=IDENT(name="sqrt"),
            expLst={e1},attr=attr as CALL_ATTR(__)) then
    //relation = DAE.LBINARY(e1,DAE.GREATEREQ(ET_REAL()),DAE.RCONST(0))
    //string = DAE.SCONST('Model error: Argument of sqrt should  >= 0')
    //let retPre = assertCommon(relation,s, context, &varDecls)
    let retPre = assertCommon(createAssertforSqrt(e1),createDAEString("Model error: Argument of sqrt should be >= 0"), context, &varDecls, dummyInfo,simCode)
    let argStr = (expLst |> exp => '<%daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)%>' ;separator=", ")
    let funName = '<%underscorePath(path)%>'
    let retType = '<%funName%>RetType'
    let &preExp += '<%retPre%>'
    let retVar = tempDecl(retType, &varDecls /*BUFD*/)
    let &preExp += '<%retVar%> = <%daeExpCallBuiltinPrefix(attr.builtin)%><%funName%>(<%argStr%>);<%\n%>'
    if attr.builtin then '<%retVar%>' else '<%retVar%>.<%retType%>_1'
  
  case CALL(path=IDENT(name="div"), expLst={e1,e2}, attr=CALL_ATTR(ty = ET_INT())) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'ldiv(<%var1%>,<%var2%>).quot'
  
  case CALL(path=IDENT(name="div"), expLst={e1,e2}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'trunc(<%var1%>/<%var2%>)'
  
  case CALL(path=IDENT(name="mod"), expLst={e1,e2}, attr=attr as CALL_ATTR(__)) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    'modelica_mod_<%expTypeShort(attr.ty)%>(<%var1%>,<%var2%>)'
  
  case CALL(path=IDENT(name="max"), expLst={array}) then
    let expVar = daeExp(array, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arr_tp_str = '<%expTypeFromExpArray(array)%>'
    let tvar = tempDecl(expTypeFromExpModelica(array), &varDecls /*BUFD*/)
    let &preExp += '<%tvar%> = max_<%arr_tp_str%>(&<%expVar%>);<%\n%>'
    '<%tvar%>'
    
  case CALL(path=IDENT(name="min"), expLst={array}) then
    let expVar = daeExp(array, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arr_tp_str = '<%expTypeFromExpArray(array)%>'
    let tvar = tempDecl(expTypeFromExpModelica(array), &varDecls /*BUFD*/)
    let &preExp += '<%tvar%> = min_<%arr_tp_str%>(&<%expVar%>);<%\n%>'
    '<%tvar%>'
  
  case CALL(path=IDENT(name="fill"), expLst=val::dims, attr=attr as CALL_ATTR(__)) then
    let valExp = daeExp(val, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let dimsExp = (dims |> dim =>
      daeExp(dim, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode) ;separator=", ")
    let ty_str = '<%expTypeArray(attr.ty)%>'
    let tvar = tempDecl(ty_str, &varDecls /*BUFD*/)
    let &preExp += 'fill_alloc_<%ty_str%>(&<%tvar%>, <%valExp%>, <%listLength(dims)%>, <%dimsExp%>);<%\n%>'
    '<%tvar%>'
    
  case CALL(path=IDENT(name="cat"), expLst=dim::arrays, attr=attr as CALL_ATTR(__)) then
    let dim_exp = daeExp(dim, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arrays_exp = (arrays |> array =>
      daeExp(array, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode) ;separator=", &")
    let ty_str = '<%expTypeArray(attr.ty)%>'
    let tvar = tempDecl(ty_str, &varDecls /*BUFD*/)
    let &preExp += 'cat_alloc_<%ty_str%>(<%dim_exp%>, &<%tvar%>, <%listLength(arrays)%>, &<%arrays_exp%>);<%\n%>'
    '<%tvar%>'
    
  case CALL(path=IDENT(name="promote"), expLst={A, n}) then
    let var1 = daeExp(A, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let var2 = daeExp(n, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arr_tp_str = '<%expTypeFromExpArray(A)%>'
    let tvar = tempDecl(arr_tp_str, &varDecls /*BUFD*/)
    let &preExp += 'promote_alloc_<%arr_tp_str%>(&<%var1%>, <%var2%>, &<%tvar%>);<%\n%>'
    '<%tvar%>'
  
  case CALL(path=IDENT(name="transpose"), expLst={A}) then
    let var1 = daeExp(A, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arr_tp_str = '<%expTypeFromExpArray(A)%>'
    let tvar = tempDecl(arr_tp_str, &varDecls /*BUFD*/)
    let &preExp += 'transpose_alloc_<%arr_tp_str%>(&<%var1%>, &<%tvar%>);<%\n%>'
    '<%tvar%>'
   
   case CALL(path=IDENT(name="cross"), expLst={v1, v2}) then
    let var1 = daeExp(v1, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let var2 = daeExp(v2, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arr_tp_str = '<%expTypeFromExpArray(v1)%>'
    let tvar = tempDecl(arr_tp_str, &varDecls /*BUFD*/)
    let &preExp += 'cross_alloc_<%arr_tp_str%>(&<%var1%>, &<%var2%>, &<%tvar%>);<%\n%>'
    '<%tvar%>'
  
  case CALL(path=IDENT(name="identity"), expLst={A}) then
    let var1 = daeExp(A, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let arr_tp_str = '<%expTypeFromExpArray(A)%>'
    let tvar = tempDecl(arr_tp_str, &varDecls /*BUFD*/)
    let &preExp += 'identity_alloc_<%arr_tp_str%>(<%var1%>, &<%tvar%>);<%\n%>'
    '<%tvar%>'
   
   case CALL(path=IDENT(name="rem"),
             expLst={e1, e2}) then
    let var1 = daeExp(e1, context, &preExp, &varDecls,simCode)
    let var2 = daeExp(e2, context, &preExp, &varDecls,simCode)
    let typeStr = expTypeFromExpShort(e1)
    'modelica_rem_<%typeStr%>(<%var1%>,<%var2%>)'
    
   case CALL(path=IDENT(name="String"),
             expLst={s, format}) then
    let tvar = tempDecl("modelica_string", &varDecls /*BUFD*/)
    let sExp = daeExp(s, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let formatExp = daeExp(format, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let typeStr = expTypeFromExpModelica(s)
    let &preExp += '<%tvar%> = <%typeStr%>_to_modelica_string_format(<%sExp%>, <%formatExp%>);<%\n%>'
    '<%tvar%>'
    
   case CALL(path=IDENT(name="String"),
             expLst={s, minlen, leftjust}) then
    let tvar = tempDecl("modelica_string", &varDecls /*BUFD*/)
    let sExp = daeExp(s, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let minlenExp = daeExp(minlen, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let leftjustExp = daeExp(leftjust, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let typeStr = expTypeFromExpModelica(s)
    let &preExp += '<%tvar%> = <%typeStr%>_to_modelica_string(<%sExp%>, <%minlenExp%>, <%leftjustExp%>);<%\n%>'
    '<%tvar%>'
  
  case CALL(path=IDENT(name="String"),
            expLst={s, minlen, leftjust, signdig}) then
    let tvar = tempDecl("modelica_string", &varDecls /*BUFD*/)
    let sExp = daeExp(s, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let minlenExp = daeExp(minlen, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let leftjustExp = daeExp(leftjust, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let signdigExp = daeExp(signdig, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let &preExp += '<%tvar%> = double_to_modelica_string(<%sExp%>, <%minlenExp%>, <%leftjustExp%>, <%signdigExp%>);<%\n%>'
    '<%tvar%>'
    
  case CALL(path=IDENT(name="delay"),
            expLst={ICONST(integer=index), e, d, delayMax}) then
    let tvar = tempDecl("double", &varDecls /*BUFD*/)
    let var1 = daeExp(e, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let var2 = daeExp(d, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let var3 = daeExp(delayMax, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let &preExp += '<%tvar%> = delayImpl(<%index%>, <%var1%>, time, <%var2%>, <%var3%>);<%\n%>'
    '<%tvar%>'
  
  case CALL(path=IDENT(name="integer"),
            expLst={toBeCasted}) then
    let castedVar = daeExp(toBeCasted, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    '((int)<%castedVar%>)'
    
   case CALL(path=IDENT(name="Integer"),
             expLst={toBeCasted}) then
    let castedVar = daeExp(toBeCasted, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    '((int)<%castedVar%>)'
  
  case CALL(path=IDENT(name="clock"), expLst={}) then
    'mmc_clock()'

  case CALL(path=IDENT(name="noEvent"),
            expLst={e1}) then
    daeExp(e1, context, &preExp, &varDecls,simCode)
  
  case CALL(path=IDENT(name="anyString"),
            expLst={e1}) then
    'mmc_anyString(<%daeExp(e1, context, &preExp, &varDecls,simCode)%>)'
    
  case CALL(path=IDENT(name="mmc_get_field"),
            expLst={s1, ICONST(integer=i)}) then
    let tvar = tempDecl("modelica_metatype", &varDecls /*BUFD*/)
    let expPart = daeExp(s1, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let &preExp += '<%tvar%> = MMC_FETCH(MMC_OFFSET(MMC_UNTAGPTR(<%expPart%>), <%i%>));<%\n%>'
    '<%tvar%>'
  
  case exp as CALL(attr=attr as CALL_ATTR(__)) then
    let argStr = (expLst |> exp => '<%daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)%>' ;separator=", ")
    let funName = '<%underscorePath(path)%>'
    let retType = '<%funName%>RetType'
    let retVar = match exp
      case CALL(attr=CALL_ATTR(ty=ET_NORETCALL(__))) then ""
      else tempDecl(retType, &varDecls)
    let &preExp += if not attr.builtin then match context case SIMULATION(__) then
      <<
      #ifdef _OMC_MEASURE_TIME
      SIM_PROF_TICK_FN(<%funName%>_index);
      #endif<%\n%>
      >>
    let &preExp += '<%if retVar then '<%retVar%> = '%>_functions.<%funName%>(<%argStr%>);<%\n%>'
    let &preExp += if not attr.builtin then match context case SIMULATION(__) then
      <<
      #ifdef _OMC_MEASURE_TIME
      SIM_PROF_ACC_FN(<%funName%>_index);
      #endif<%\n%>
      >>
    match exp
      // no return calls
      case CALL(attr=CALL_ATTR(ty=ET_NORETCALL(__))) then '/* NORETCALL */'
      // non tuple calls (single return value)
      case CALL(attr=CALL_ATTR(tuple_=false)) then
        '<%retVar%>' 
      // tuple calls (multiple return values)
      case CALL(attr=CALL_ATTR(tuple_=true)) then
        '<%retVar%>'
  
    
end daeExpCall;

template expTypeFromExpShort(Exp exp)

::=
  expTypeFromExpFlag(exp, 1)
end expTypeFromExpShort;

template expTypeFromExpModelica(Exp exp)

::=
  expTypeFromExpFlag(exp, 2)
end expTypeFromExpModelica;

template expTypeFromExpArray(Exp exp)

::=
  expTypeFromExpFlag(exp, 3)
end expTypeFromExpArray;

template assertCommon(Exp condition, Exp message, Context context, Text &varDecls, Info info,SimCode simCode)
::=
  let &preExpCond = buffer ""
  let &preExpMsg = buffer ""
  let condVar = daeExp(condition, context, &preExpCond, &varDecls,simCode)
  let msgVar = daeExp(message, context, &preExpMsg, &varDecls,simCode)
  <<
  <%preExpCond%>
  if (!<%condVar%>) {
    <%preExpMsg%>
    omc_fileInfo info = {<%infoArgs(info)%>};
    MODELICA_ASSERT(info, <%if acceptMetaModelicaGrammar() then 'MMC_STRINGDATA(<%msgVar%>)' else msgVar%>);
  }
  >>
end assertCommon;

template infoArgs(Info info)
::=
  match info
  case INFO(__) then '"<%fileName%>",<%lineNumberStart%>,<%columnNumberStart%>,<%lineNumberEnd%>,<%columnNumberEnd%>,<%isReadOnly%>'
end infoArgs;


template underscorePrefix(Boolean builtin) ::=
  match builtin
  case true then ""
  case false then "_"
end underscorePrefix;

template daeExpCallBuiltinPrefix(Boolean builtin)
 "Helper to daeExpCall."
::=
  match builtin
  case true  then ""
  case false then "_"
end daeExpCallBuiltinPrefix;


template daeExpLunary(Exp exp, Context context, Text &preExp /*BUFP*/,
                      Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a logical unary expression."
::=
match exp
case LUNARY(__) then
  let e = daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  match operator
  case NOT(__) then '(!<%e%>)'
end daeExpLunary;

template daeExpLbinary(Exp exp, Context context, Text &preExp /*BUFP*/,
                       Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a logical binary expression."
::=
match exp
case LBINARY(__) then
  let e1 = daeExp(exp1, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  let e2 = daeExp(exp2, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  match operator
  case AND(__) then '(<%e1%> && <%e2%>)'
  case OR(__)  then '(<%e1%> || <%e2%>)'
  else "daeExpLbinary:ERR"
end daeExpLbinary;

template daeExpBinary(Operator it, Exp exp1, Exp exp2, Context context, Text &preExp,Text &varDecls /*BUFP*/, SimCode simCode) ::=
  let e1 = daeExp(exp1, context, &preExp, &varDecls, simCode)
  let e2 = daeExp(exp2, context, &preExp, &varDecls, simCode)
  match it
  case ADD(__) then '(<%e1%> + <%e2%>)'
  case SUB(__) then '(<%e1%> - <%e2%>)'
  case MUL(__) then '(<%e1%> * <%e2%>)'
  case DIV(__) then '(<%e1%> / <%e2%>)'
  case POW(__) then 'pow(<%e1%>, <%e2%>)'
  case AND(__) then '(<%e1%> && <%e2%>)'
  case OR(__)  then '(<%e1%> || <%e2%>)'
  case _   then "daeExpBinary:ERR"
end daeExpBinary;

template daeExpSconst(String string, Context context, Text &preExp /*BUFP*/, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a string constant."
::=
  '"<%Util.escapeModelicaStringToCString(string)%>"'
end daeExpSconst;

template daeExpUnary(Exp exp, Context context, Text &preExp /*BUFP*/,
                     Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a unary expression."
::=
match exp
case UNARY(__) then
  let e = daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  match operator
  case UMINUS(__)     then '(-<%e%>)'
  case UPLUS(__)      then '(<%e%>)'
  case UMINUS_ARR(ty=ET_ARRAY(ty=ET_REAL(__))) then
    let &preExp += 'usub_real_array(&<%e%>);<%\n%>'
    '<%e%>'
  case UMINUS_ARR(__) then 'unary minus for non-real arrays not implemented'
  case UPLUS_ARR(__)  then "UPLUS_ARR_NOT_IMPLEMENTED"
  else "daeExpUnary:ERR"
end daeExpUnary;


template daeExpCrefRhs(Exp exp, Context context, Text &preExp /*BUFP*/,
                       Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a component reference on the right hand side of an
 expression."
::=
  match exp
  // A record cref without subscripts (i.e. a record instance) is handled
  // by daeExpRecordCrefRhs only in a simulation context, not in a function.
  case CREF(componentRef = cr, ty = t as ET_COMPLEX(complexClassType = RECORD(path = _))) then
    match context case FUNCTION_CONTEXT(__) then
      daeExpCrefRhs2(exp, context, &preExp, &varDecls,simCode)
    else
      daeExpRecordCrefRhs(t, cr, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
  case CREF(componentRef = cr, ty = ET_FUNCTION_REFERENCE_FUNC(__)) then
    '((modelica_fnptr)boxptr_<%crefFunctionName(cr)%>)'
  case CREF(componentRef = cr, ty = ET_FUNCTION_REFERENCE_VAR(__)) then
    '((modelica_fnptr) _<%crefStr(cr)%>)'
  else daeExpCrefRhs2(exp, context, &preExp, &varDecls,simCode)
end daeExpCrefRhs;

template daeExpRecordCrefRhs(DAE.ExpType ty, ComponentRef cr, Context context, Text &preExp /*BUFP*/,
                       Text &varDecls /*BUFP*/,SimCode simCode)
::=
match ty
case ET_COMPLEX(name = record_path, varLst = var_lst) then
  let vars = var_lst |> v => daeExp(makeCrefRecordExp(cr,v), context, &preExp, &varDecls,simCode) 
             ;separator=", "
  let record_type_name = underscorePath(record_path)
  let ret_type = '<%record_type_name%>RetType'
  let ret_var = tempDecl(ret_type, &varDecls)
  let &preExp += '<%ret_var%> = _functions.<%record_type_name%>(<%vars%>);<%\n%>'
  '<%ret_var%>'
end daeExpRecordCrefRhs;

template daeExpCrefRhs2(Exp ecr, Context context, Text &preExp /*BUFP*/,
                       Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a component reference."
::=
  match ecr
  case ecr as CREF(componentRef=cr, ty=ty) then
      let box = daeExpCrefRhsArrayBox(ecr, context, &preExp, &varDecls,simCode)
    if box then
      box
    else if crefIsScalar(cr, context) then
      let cast = match ty case ET_INT(__) then ""
                          case ET_ENUMERATION(__) then "" //else ""
      '<%cast%><%contextCref(cr,context,simCode)%>'
    else 
     if crefSubIsScalar(cr) then
      // The array subscript results in a scalar
      let arrName = contextCref(crefStripLastSubs(cr), context,simCode)
      let arrayType = expTypeArray(ty)
      let dimsLenStr = listLength(crefSubs(cr))
      let dimsValuesStr = (crefSubs(cr) |> INDEX(__) =>
          daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
        ;separator=", ")
      match arrayType
        case "metatype_array" then
          'arrayGet(<%arrName%>,<%dimsValuesStr%>) /* DAE.CREF */'
        else
          <<
          (*<%arrayType%>_element_addr(&<%arrName%>, <%dimsLenStr%>, <%dimsValuesStr%>))
          >>
    else
      // The array subscript denotes a slice
      let arrName = contextArrayCref(cr, context)
      let arrayType = expTypeArray(ty)
      let tmp = tempDecl(arrayType, &varDecls /*BUFD*/)
      let spec1 = daeExpCrefRhsIndexSpec(crefSubs(cr), context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
      let &preExp += 'index_alloc_<%arrayType%>(&<%arrName%>, &<%spec1%>, &<%tmp%>);<%\n%>'
      tmp
end daeExpCrefRhs2;

template daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context,
                                Text &preExp /*BUFP*/, Text &varDecls /*BUFP*/,SimCode simCode)
 "Helper to daeExpCrefRhs."
::=
  let nridx_str = listLength(subs)
  let idx_str = (subs |> sub =>
      match sub
      case INDEX(__) then
        let expPart = daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
        <<
        (0), make_index_array(1, (int) <%expPart%>), 'S'

        >>
      case WHOLEDIM(__) then
        <<
        (1), (int*)0, 'W'
        >>
      case SLICE(__) then
        let expPart = daeExp(exp, context, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
        let tmp = tempDecl("int", &varDecls /*BUFD*/)
        let &preExp += '<%tmp%> = size_of_dimension_integer_array(<%expPart%>, 1);<%\n%>'
        <<
        (int) <%tmp%>, integer_array_make_index_array(&<%expPart%>), 'A'
        >>
    ;separator=", ")
  let tmp = tempDecl("index_spec_t", &varDecls /*BUFD*/)
  let &preExp += 'create_index_spec(&<%tmp%>, <%nridx_str%>, <%idx_str%>);<%\n%>'
  tmp
end daeExpCrefRhsIndexSpec;

template daeExpCrefRhsArrayBox(Exp ecr, Context context, Text &preExp /*BUFP*/,
                               Text &varDecls /*BUFP*/,SimCode simCode)
 "Helper to daeExpCrefRhs."
::=
match ecr
case ecr as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  match context
  case FUNCTION_CONTEXT(__) then ''
  else
    // For context simulation and other array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    let tmpArr = tempDecl(expTypeArray(aty), &varDecls /*BUFD*/)
    let dimsLenStr = listLength(dims)
    let type = expTypeShort(aty)
     //let &preExp += '<%type%>_array_create(&<%tmpArr%>, ((modelica_<%type%>*)&(<%arrayCrefCStr(ecr.componentRef)%>)), <%dimsLenStr%>);<%\n%>'
    tmpArr
    
end daeExpCrefRhsArrayBox;

template cref1(ComponentRef cr, SimCode simCode) ::=
  match cr
  case CREF_IDENT(ident = "xloc") then ""
  case CREF_IDENT(ident = "time") then "time"
  else '<%representationCref(cr, simCode) %>'
end cref1;

template representationCref(ComponentRef inCref, SimCode simCode) ::=
  cref2simvar(inCref, simCode) |> SIMVAR(__) =>
	 match varKind 
  case STATE(__)        then
    << <%representationCref1(inCref,simCode)%> >>
  case STATE_DER(__)   then 
    << <%representationCref2(inCref,simCode)%> >>
  else << <%cref(inCref)%> >>
end representationCref;


template representationCref1(ComponentRef inCref, SimCode simCode) ::=
  cref2simvar(inCref, simCode) |> SIMVAR(__) =>
    match index
   case -1 then 
   << <%cref2(inCref)%> >>
   case _  then
   << _z[<%index%>] >>
end representationCref1;

template representationCref2(ComponentRef inCref, SimCode simCode) ::=
  cref2simvar(inCref, simCode) |> SIMVAR(__) =>'_zDot[<%index%>]'
end representationCref2;

template helpvarlength(SimCode simCode) 
::=
match simCode
case SIMCODE(__) then
  let size = listLength(helpVarInfo)
  <<
   <%size%>
  >>
end helpvarlength;

template zerocrosslength(SimCode simCode) 
::=
match simCode
case SIMCODE(__) then
  let size = listLength(zeroCrossings)
  <<
    return <%size%>
  >>
end zerocrosslength;


template DimZeroFunc(SimCode simCode)
::=
match simCode
case SIMCODE(modelInfo = MODELINFO(__)) then
  <<
   int <%lastIdentOfPath(modelInfo.name)%>::getDimZeroFunc()
    {
      <%zerocrosslength(simCode)%>;
    }
  >>
end DimZeroFunc;



template daeExpRelation(Operator op, Integer index,Exp exp1, Exp exp2, Context context, Text &preExp,Text &varDecls,SimCode simCode) ::=
  let e1 = daeExp(exp1, context, &preExp, &varDecls,simCode)
  let e2 = daeExp(exp2, context, &preExp, &varDecls,simCode)
  match index 
  case -1 then 
     match op
    case LESS(ty = ET_BOOL(__))        then '(!<%e1%> && <%e2%>)'
    case LESS(ty = ET_STRING(__))      then "# string comparison not supported\n"
    case LESS(ty = ET_INT(__))
    case LESS(ty = ET_REAL(__))        then '(<%e1%> < <%e2%>)'
    case GREATER(ty = ET_BOOL(__))     then '(<%e1%> && !<%e2%>)'
    case GREATER(ty = ET_STRING(__))   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT(__))
    case GREATER(ty = ET_REAL(__))     then '(<%e1%> > <%e2%>)'
    case LESSEQ(ty = ET_BOOL(__))      then '(!<%e1%> || <%e2%>)'
    case LESSEQ(ty = ET_STRING(__))    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT(__))
    case LESSEQ(ty = ET_REAL(__))       then '(<%e1%> <= <%e2%>)'
    case GREATEREQ(ty = ET_BOOL(__))   then '(<%e1%> || !<%e2%>)'
    case GREATEREQ(ty = ET_STRING(__)) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT(__))
    case GREATEREQ(ty = ET_REAL(__))   then '(<%e1%> >= <%e2%>)'
    case EQUAL(ty = ET_BOOL(__))       then '((!<%e1%> && !<%e2%>) || (<%e1%> && <%e2%>))'
    case EQUAL(ty = ET_STRING(__))
    case EQUAL(ty = ET_INT(__))
    case EQUAL(ty = ET_REAL(__))       then '(<%e1%> == <%e2%>)'
    case NEQUAL(ty = ET_BOOL(__))      then '((!<%e1%> && <%e2%>) || (<%e1%> && !<%e2%>))'
    case NEQUAL(ty = ET_STRING(__))
    case NEQUAL(ty = ET_INT(__))
    case NEQUAL(ty = ET_REAL(__))      then '(<%e1%> != <%e2%>)'
    case _                         then "daeExpRelation:ERR"
      end match
  case _ then 
     match op
    case LESS(ty = ET_BOOL(__))        then '_condition<%index%>'
    case LESS(ty = ET_STRING(__))      then "# string comparison not supported\n"
    case LESS(ty = ET_INT(__))
    case LESS(ty = ET_REAL(__))        then '_condition<%index%>'
    case GREATER(ty = ET_BOOL(__))     then '_condition<%index%>'
    case GREATER(ty = ET_STRING(__))   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT(__))
    case GREATER(ty = ET_REAL(__))     then '_condition<%index%>'
    case LESSEQ(ty = ET_BOOL(__))      then '_condition<%index%>'
    case LESSEQ(ty = ET_STRING(__))    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT(__))
    case LESSEQ(ty = ET_REAL(__))       then '_condition<%index%>'
    case GREATEREQ(ty = ET_BOOL(__))   then '_condition<%index%>'
    case GREATEREQ(ty = ET_STRING(__)) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT(__))
    case GREATEREQ(ty = ET_REAL(__))   then '_condition<%index%>'
    case EQUAL(ty = ET_BOOL(__))       then '_condition<%index%>'
    case EQUAL(ty = ET_STRING(__))
    case EQUAL(ty = ET_INT(__))
    case EQUAL(ty = ET_REAL(__))       then '_condition<%index%>'
    case NEQUAL(ty = ET_BOOL(__))      then '_condition<%index%>'
    case NEQUAL(ty = ET_STRING(__))
    case NEQUAL(ty = ET_INT(__))
    case NEQUAL(ty = ET_REAL(__))      then '_condition<%index%>'
    case _                         then "daeExpRelation:ERR"
      end match
end daeExpRelation;


template daeExpIf(Exp cond, Exp then_, Exp else_, Context context, Text &preExp, Text &varDecls,SimCode simCode) ::=
  let condExp = daeExp(cond, context, &preExp, &varDecls,simCode)
  let &preExpThen = buffer ""
  let eThen = daeExp(then_, context, &preExpThen, &varDecls,simCode)
  let &preExpElse = buffer ""
  let eElse = daeExp(else_, context, &preExpElse /*BUFC*/, &varDecls /*BUFD*/,simCode)
      let condVar = tempDecl("bool", &varDecls /*BUFD*/)
      let resVarType = expTypeFromExpArrayIf(then_)
      let resVar = tempDecl(resVarType, &varDecls /*BUFD*/)
      let &preExp +=  
      <<
      <%condVar%> = <%condExp%>;
      if (<%condVar%>) {
        <%preExpThen%>
        <%resVar%> = <%eThen%>;
      } else {
        <%preExpElse%>
        <%resVar%> = <%eElse%>;
      }<%\n%>
      >>
      resVar
end daeExpIf;

template expTypeFromExpArrayIf(Exp exp) ::=
  expTypeFromExp(exp)
end expTypeFromExpArrayIf;

template expTypeFromExp(Exp it) ::=
  match it
  case ICONST(__)    then "int"
  case RCONST(__)    then "double"
  case SCONST(__)    then "string"
  case BCONST(__)    then "bool"
  case BINARY(__)
  case UNARY(__)
  case LBINARY(__)
  case LUNARY(__)     then expTypeFromOp(operator)
  case RELATION(__)   then "bool" //TODO: a HACK, it was expTypeFromOp(operator)
  case IFEXP(__)      then expTypeFromExp(expThen)
  case CALL(attr=CALL_ATTR(__))       then expTypeShort(attr.ty)
  case ARRAY(__)
  case MATRIX(__)
  case RANGE(__)
  case CAST(__)
  case CREF(__)
  case CODE(__)       then expTypeShort(ty)
  case ASUB(__)       then expTypeFromExp(exp)
  case REDUCTION(__)  then expTypeFromExp(expr)
  case _          then "expTypeFromExp:ERROR"
end expTypeFromExp;


template expTypeFromOp(Operator it) ::=
  match it
  case ADD(__)
  case SUB(__)
  case MUL(__)
  case DIV(__)
  case POW(__)
  case UMINUS(__)
  case UPLUS(__)
  case UMINUS_ARR(__)
  case UPLUS_ARR(__)
  case ADD_ARR(__)
  case SUB_ARR(__)
  case MUL_ARR(__)
  case DIV_ARR(__)
  case MUL_SCALAR_ARRAY(__)
  case MUL_ARRAY_SCALAR(__)
  case ADD_SCALAR_ARRAY(__)
  case ADD_ARRAY_SCALAR(__)
  case SUB_SCALAR_ARRAY(__)
  case SUB_ARRAY_SCALAR(__)
  case MUL_SCALAR_PRODUCT(__)
  case MUL_MATRIX_PRODUCT(__)
  case DIV_ARRAY_SCALAR(__)
  case DIV_SCALAR_ARRAY(__)
  case POW_ARRAY_SCALAR(__)
  case POW_SCALAR_ARRAY(__)
  case POW_ARR(__)
  case POW_ARR2(__)
  case LESS(__)
  case LESSEQ(__)
  case GREATER(__)
  case GREATEREQ(__)
  case EQUAL(__)
  case NEQUAL(__)       then  expTypeShort(ty)
  case AND(__)
  case OR(__)
  case NOT(__) then "bool"
  case _ then "expTypeFromOp:ERROR"
end expTypeFromOp;

template equationAlgorithm(SimEqSystem eq, Context context,Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates an equation that is an algorithm."
::=
match eq
case SES_ALGORITHM(__) then
  (statements |> stmt =>
    algStatement(stmt, context, &varDecls /*BUFD*/,simCode)
  ;separator="\n") 
end equationAlgorithm;

template algStatement(DAE.Statement it, Context context, Text &varDecls,SimCode simCode) ::=
  match it
  case STMT_ASSIGN(exp1 = CREF(componentRef = WILD(__)), exp = e) then
    let &preExp = buffer "" 
    let expPart = daeExp(e, context, &preExp, &varDecls, simCode)
    <<
    <%preExp%>
    <%expPart%>
    >>
  case STMT_ASSIGN(exp1 = CREF(__)) then
    let &preExp = buffer ""
    let expPart = daeExp(exp, context, &preExp,&varDecls, simCode)
    <<
    <%preExp%>
    <%scalarLhsCref(exp1, context, &preExp, &varDecls, simCode)%> = <%expPart%>;
    >>  
  case STMT_ASSIGN(__) then
    let &preExp = buffer ""
    let expPart1 = daeExp(exp1, context, &preExp, &varDecls,simCode)
    let expPart2 = daeExp(exp, context, &preExp, &varDecls,simCode)
    <<
    <%preExp%>
    <%expPart1%> = <%expPart2%>;
    >>  
  case STMT_ASSIGN_ARR(componentRef = CREF_IDENT(subscriptLst=subs as (_ :: _))) then
     let &preExp = buffer ""
     let expPart = daeExp(exp, context, &preExp,&varDecls, simCode)
     let spec = daeExpCrefRhsIndexSpec(subs, context, &preExp, &varDecls, simCode)
     <<
     <%preExp%>
     <%componentRef.ident%>.AssignSpec(<%spec%>, <%expPart%>.A);
     >>
  case STMT_ASSIGN_ARR(__) then
     let &preExp = buffer ""
     let expPart = daeExp(exp, context, &preExp, &varDecls,simCode)
     <<
     <%preExp%>
     ArrayCopy(<%expPart%>.A, <%contextCref(componentRef, context,simCode)%>.A);
     >>  
  case STMT_IF(__) then
    let &preExp = buffer ""
    let condExp = daeExp(exp, context, &preExp,&varDecls, simCode)
    <<
    <%preExp%>
    if (<%condExp%>) {
      <%statementLst |> it => algStatement(it, context,&varDecls,simCode) ;separator="\n"%>
    }
    <%elseExpr(else_, context,&preExp, &varDecls, simCode)%>
    >>

  case STMT_FOR(range=rng as RANGE(__)) then
    let identType = expType(type_, iterIsArray) //TODO: ?? what is this for ... no array typed iterator is possible ???
    let identTypeShort = expTypeShort(type_)
    let stmtStr = (statementLst |> stmt => algStatement(stmt, context, &varDecls,simCode)
                   ;separator="\n")
    algStmtForRange_impl(rng, iter, identType, identTypeShort, stmtStr, context, &varDecls,simCode)
  
  case STMT_WHILE(__)  then
    let &preExp = buffer ""
    let var = daeExp(exp, context, &preExp,&varDecls, simCode)
    <<
    while (1) {
    <%preExp%>
    if (!<%var%>) break;
      <%statementLst |> stmt => algStatement(stmt, context,&varDecls,simCode) ;separator="\n"%>
    }
    >>
     
  case STMT_TUPLE_ASSIGN(__)   then "STMT_TUPLE_ASSIGN_NI"
  case STMT_ASSERT(__)         then "STMT_ASSERT_NI"
  case STMT_TERMINATE(__)      then "STMT_TERMINATE_NI"
  case STMT_WHEN(__)           then algStmtWhen(it, context,&varDecls, simCode)
  case STMT_FOR(__)            
     then 
   algStmtForGeneric(it, context,&varDecls, simCode)
  case STMT_BREAK(__)          then 'break; //break stmt<%\n%>'
  case STMT_FAILURE(__)        then "STMT_FAILURE_NI"
  case STMT_TRY(__)            then "STMT_TRY_NI"
  case STMT_CATCH(__)          then "STMT_CATCH_NI"
  case STMT_THROW(__)          then "STMT_THROW_NI"
  case STMT_RETURN(__)         then "STMT_RETURN_NI"
  case STMT_NORETCALL(__)      then "STMT_NORETCALL_NI"
  case STMT_REINIT(__)         then "STMT_REINIT_NI"
  case _ then "NOT_IMPLEMENTED_ALG_STATEMENT"
      
end algStatement;

template algStmtForGeneric(DAE.Statement stmt, Context context, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates a for algorithm statement where range is not RANGE."
::=
match stmt
case STMT_FOR(__) then
  let iterType = expType(type_, iterIsArray)
  let arrayType = expTypeArray(type_)


  let stmtStr = (statementLst |> stmt => 
    algStatement(stmt, context, &varDecls,simCode) ;separator="\n")
  algStmtForGeneric_impl(range, iter, iterType, arrayType, iterIsArray, stmtStr, 
    context, &varDecls,simCode)
end algStmtForGeneric;

template algStmtForGeneric_impl(Exp exp, Ident iterator, String type, 
  String arrayType, Boolean iterIsArray, Text &body, Context context, Text &varDecls,SimCode simCode)
 "The implementation of algStmtForGeneric, which is also used by daeExpReduction."
::=
  let iterName = contextIteratorName(iterator, context)
  //let stateVar = if not acceptMetaModelicaGrammar() then tempDecl("state", &varDecls)
  let tvar = tempDecl("int", &varDecls)
  let ivar = tempDecl(type, &varDecls)
  let &preExp = buffer ""
  let evar = daeExp(exp, context, &preExp, &varDecls,simCode)
  let stmtStuff = if iterIsArray then
      'simple_index_alloc_<%type%>1(&<%evar%>, <%tvar%>, &<%ivar%>);'
    else
      '<%iterName%> = *(<%arrayType%>_element_addr1(&<%evar%>, 1, <%tvar%>));'
  <<
  <%preExp%>
  
    <%type%> <%iterName%>;
  
   BOOST_FOREACH( short & <%iterName%>, array_short ){ 
      <%body%> 
    }
  
  >>
end algStmtForGeneric_impl;

template contextIteratorName(Ident name, Context context)
  "Generates code for an iterator variable."
::=
  match context
  case FUNCTION_CONTEXT(__) then "_" + name
  else name
end contextIteratorName;


template algStmtWhen(DAE.Statement when, Context context, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates a when algorithm statement."
::=
match context
case SIMULATION(genDiscrete=true) then
  match when
  case STMT_WHEN(__) then
    <<
    
    if (<%helpVarIndices |> idx => edgeHelpVar(idx) ;separator=" || "%>) {
      <% statementLst |> stmt =>  algStatement(stmt, context, &varDecls,simCode)
         ;separator="\n" %>
    }
    <%algStatementWhenElse(elseWhen, &varDecls,simCode)%>
    >>
  end match
end algStmtWhen;

template algStatementWhenElse(Option<DAE.Statement> stmt, Text &varDecls /*BUFP*/,SimCode simCode)
 "Helper to algStmtWhen."
::=
match stmt
case SOME(when as STMT_WHEN(__)) then
  let elseCondStr = (when.helpVarIndices |> idx => edgeHelpVar(idx)
                      ;separator=" || ")
  <<
  else if (<%elseCondStr%>) {
    <% when.statementLst |> stmt =>  algStatement(stmt, contextSimulationDiscrete,&varDecls,simCode)
       ;separator="\n"%>
  }
  <%algStatementWhenElse(when.elseWhen, &varDecls,simCode)%>
  >>
end algStatementWhenElse;

template edgeHelpVar(String idx) ::=
   '_event_handling.edge(_event_handling[<%idx%>],"h<%idx%>")'
end edgeHelpVar;

template algStmtForRange_impl(Exp range, Ident iterator, String type, String shortType, Text body, Context context, Text &varDecls,SimCode simCode)
 "The implementation of algStmtForRange, which is also used by daeExpReduction."
::=
match range
case RANGE(__) then
  let iterName = iterator
  let &stopVar = buffer ""
  let &preExp = buffer ""
  let startValue = daeExp(exp, context, &preExp, &varDecls,simCode)
  let stopValue = daeExp(range, context, &preExp, &varDecls,simCode)
  let res = tempDecl(type, &varDecls /*BUFC*/)
  match expOption 
  case SOME(eo) then
    let &stepVar = buffer "" 
    let stepValue = daeExp(eo, context, &preExp,&varDecls,simCode)
    <<
    <%preExp%>
    for(<%type%> <%iterName%> = <%startValue%>;(<%stepValue%> > 0? <%iterName%><=<%stopValue%> : <%stopValue%><=<%iterName%>); <%iterName%> += <%stepValue%>) { 
      <%body%>
    }
    >>
  else //optimization for 1 step
    <<
    <%preExp%>
    for(<%type%> <%iterName%> = <%startValue%>; <%iterName%><=<%stopValue%>; <%iterName%> += 1) { 
      <%body%>
    }
    >>
end algStmtForRange_impl;

template scalarLhsCref(Exp ecr, Context context, Text &preExp,Text &varDecls, SimCode simCode) ::=
match ecr
case ecr as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if crefNoSub(ecr.componentRef) then
    contextCref(ecr.componentRef, context,simCode)
  else
    daeExpCrefRhs(ecr, context, &preExp, &varDecls, simCode)
case ecr as CREF(componentRef=CREF_QUAL(__)) then
    contextCref(ecr.componentRef, context,simCode)
else
    "ONLY_IDENT_OR_QUAL_CREF_SUPPORTED_SLHS"
end scalarLhsCref;

template elseExpr(DAE.Else it, Context context, Text &preExp, Text &varDecls,SimCode simCode) ::= 
  match it
  case NOELSE(__) then ""
  case ELSEIF(__) then
    let &preExp = buffer ""
    let condExp = daeExp(exp, context, &preExp, &varDecls,simCode)
    <<
    else {
    <%preExp%>
    if (<%condExp%>) {
      <%statementLst |> it => algStatement(it, context, &varDecls,simCode) 
      ;separator="\n"%>
    }
    <%elseExpr(else_, context, &preExp, &varDecls,simCode)%>
    }
    >>
  case ELSE(__) then
    <<
    else {
      <%statementLst |> it => algStatement(it, context, &varDecls,simCode) 
      ;separator="\n"%>
    }
    >>
end elseExpr;


template expType(DAE.ExpType ty, Boolean isArray)
 "Generate type helper."
::=
  if isArray 
  then 'expType_<%expTypeArray1(ty,0)%>_NOT_YET'
  else expTypeShort(ty)
end expType;


template expTypeArrayIf(DAE.ExpType ty)
 "Generate type helper."
::=
  expTypeFlag(ty, 4)
end expTypeArrayIf;

template expTypeArray1(DAE.ExpType ty, Integer dims) ::=
<<
 SimArray<%dims%><<%expTypeShort(ty)%>>
>>
end expTypeArray1;


template functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossings,SimCode simCode)
  "Generates function in simulation file."
::=
  let &varDecls = buffer "" /*BUFD*/
  let zeroCrossingsCode = zeroCrossingsTpl2(zeroCrossings, &varDecls /*BUFD*/, simCode)
  <<
    <%varDecls%>
    <%zeroCrossingsCode%> 
  >>
end functionOnlyZeroCrossing;

template zeroCrossingsTpl2(list<ZeroCrossing> zeroCrossings, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for zero crossings."
::=

  (zeroCrossings |> ZERO_CROSSING(__) hasindex i0 =>
    zeroCrossingTpl2(i0, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end zeroCrossingsTpl2;


template zeroCrossingTpl2(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates code for a zero crossing."
::=
  match relation
  case RELATION(index=zerocrossingIndex) then
    let &preExp = buffer "" /*BUFD*/
    let e1 = daeExp(exp1, contextOther, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let op = zeroCrossingOpFunc(operator)
    let e2 = daeExp(exp2, contextOther, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let res = tempDecl("bool", &varDecls /*BUFC*/)
    <<
    <%preExp%>
    <%res%>=(<%e1%><%op%><%e2%>);
    _condition<%zerocrossingIndex%>=<%res%>;
    >>
end zeroCrossingTpl2;


template timeEventCondition(list<SampleCondition> sampleConditions,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  let timeEventConditionCode = timeEventcondition(sampleConditions, &varDecls /*BUFD*/, simCode)
  <<
    <%varDecls%>
    <%timeEventConditionCode%>
  >>
end timeEventCondition;


template timeEventcondition(list<SampleCondition> sampleConditions,Text &varDecls /*BUFP*/,SimCode simCode)
::=
  (sampleConditions |> (relation_,index)  =>
    timeEventcondition1(index, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end timeEventcondition;

template timeEventcondition1(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
::=
  match relation
  case CALL(path=IDENT(name="sample"), expLst={start, interval,index}) then
    let &preExp = buffer "" /*BUFD*/
    let eStart = daeExp(start, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
    let eInterval = daeExp(interval, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
    let eIndex = daeExp(index, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
    let res = tempDecl("bool", &varDecls /*BUFC*/)
     <<
     <%preExp%>
     <%res%>= false;
     _condition<%eIndex%> = <%res%>;
      event_times_type sample<%eIndex%> = _event_handling.makePeriodeEvents(<%eStart%>,te,<%eInterval%>,<%eIndex%>);
     _event_handling.addTimeEvents(sample<%eIndex%>);
    >>
end timeEventcondition1;

template resetTimeEvents(list<SampleCondition> sampleConditions,list<SimWhenClause> whenClauses,SimCode simCode)
::=
match simCode
case SIMCODE(sampleConditions=sam) then
  << 
     <%resetTimeEvent(sampleConditions,simCode)%>
     double h[<%helpvarlength(simCode)%>];
     <%helpvarvector(whenClauses,simCode)%>
      _event_handling.setHelpVars(h);
  >> 
end resetTimeEvents;

template resetTimeEvent(list<SampleCondition> sampleConditions,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  (sampleConditions |> (relation_,index)  =>
    resetTimeEvent1(index, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end resetTimeEvent;

template resetTimeEvent1(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
::=
  match relation
  case CALL(path=IDENT(name="sample"), expLst={start, interval,index}) then
    let &preExp = buffer "" /*BUFD*/
    let eIndex = daeExp(index, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
     <<
     _condition<%eIndex%> = false;
    >>
end resetTimeEvent1;

template handleEvent(list<SampleCondition> sampleConditions,SimCode simCode)
::=
match simCode
case SIMCODE(__) then
  << 
     switch(index)	
    {
     <%handleEvent1(sampleConditions,simCode)%>
    }
  >>
 
end handleEvent;

template handleEvent1(list<SampleCondition> sampleConditions,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  (sampleConditions |> (relation_,index)  =>
    handleEvent2(index, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end handleEvent1;

template handleEvent2(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
::=
  match relation
  case CALL(path=IDENT(name="sample"), expLst={start, interval,index}) then
    let &preExp = buffer "" /*BUFD*/
    let eIndex = daeExp(index, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
     <<
     case <%eIndex%>:
	  {
       _condition<%eIndex%> = true;
       break;
      }
    >>
end handleEvent2;

template handleSystemEvents(list<ZeroCrossing> zeroCrossings,list<SimWhenClause> whenClauses,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  let zeroCrossingsCode = handleSystemEvents1(zeroCrossings, &varDecls /*BUFD*/, simCode)
  match simCode
  case SIMCODE(modelInfo = MODELINFO(__)) then 
  <<
   void <%lastIdentOfPath(modelInfo.name)%>::handleSystemEvents(const bool* events,update_events_type update_event)
   { 
    <%varDecls%>
    bool restart=true;
    int iter=0;
    while(restart && !(iter++ > 10))
    {
    	//save all variables for pre and edge operators
	saveAll();
    <%zeroCrossingsCode%>
    double h[<%helpvarlength(simCode)%>];
    <%helpvarvector(whenClauses,simCode)%>
     _event_handling.setHelpVars(h);
    //iterate and handle all events inside the eventqueue
    restart=_event_handling.IterateEventQueue(events,update_event);
    }
     resetTimeEvents();
    if(iter>10){
     throw std::runtime_error("Number of event iteration steps exceeded. ");}
   }
  >>
end handleSystemEvents;

template handleSystemEvents1(list<ZeroCrossing> zeroCrossings, Text &varDecls /*BUFP*/,SimCode simCode)
::=

  (zeroCrossings |> ZERO_CROSSING(__) hasindex i0 =>
    handleSystemEvents2(i0, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end handleSystemEvents1;

template handleSystemEvents2(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
::=
  match relation
  case RELATION(index=zerocrossingIndex) then
    let &preExp = buffer "" /*BUFD*/
    let e1 = daeExp(exp1, contextOther, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let op = zeroCrossingOpFunc(operator)
    let e2 = daeExp(exp2, contextOther, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    let res = tempDecl("bool", &varDecls /*BUFC*/)
    <<
    <%preExp%>
    if(events[<%zerocrossingIndex%>])
    {
      <%res%>=(<%e1%><%op%><%e2%>);
      _condition<%zerocrossingIndex%>=<%res%>;
      _event_handling.addEvent(<%zerocrossingIndex%>);
      handleEvent(<%zerocrossingIndex%>);
    }
   >>
 end handleSystemEvents2;

template zeroCrossingOpFunc(Operator op)
 "Generates zero crossing function name for operator."
::=
  match op
  case LESS(__)      then "<"
  case GREATER(__)   then ">"
  case LESSEQ(__)    then "<="
  case GREATEREQ(__) then ">="
end zeroCrossingOpFunc;

template giveZeroFunc1(list<ZeroCrossing> zeroCrossings,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  let zeroCrossingsCode = giveZeroFunc2(zeroCrossings, &varDecls /*BUFD*/, simCode)
  match simCode
  case SIMCODE(modelInfo = MODELINFO(__)) then
<<
 void <%lastIdentOfPath(modelInfo.name)%>::giveZeroFunc(double* f,const double& eps)
  {
   <%varDecls%>
   <%zeroCrossingsCode%>
  }   
>>
end giveZeroFunc1;

template giveZeroFunc2(list<ZeroCrossing> zeroCrossings, Text &varDecls /*BUFP*/,SimCode simCode)
::=

  (zeroCrossings |> ZERO_CROSSING(__) hasindex i0 =>
    giveZeroFunc3(i0, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end giveZeroFunc2;

template giveZeroFunc3(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
::=
  match relation
  case RELATION(__) then
    let &preExp = buffer "" /*BUFD*/
    let e1 = daeExp(exp1, contextOther, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    //let op = zeroCrossingOpFunc(operator)
    let e2 = daeExp(exp2, contextOther, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    <<
    f[<%index1%>]=(<%e2%>-<%e1%>);
    >> 
end giveZeroFunc3;

template conditionvarZero(list<ZeroCrossing> zeroCrossings,SimCode simCode)
::=
  (zeroCrossings |> ZERO_CROSSING(__) hasindex i0 =>
    conditionvarZero1(i0, relation_, simCode)
  ;separator="\n")
end conditionvarZero;

template conditionvarZero1(Integer index1, Exp relation,SimCode simCode)
::=
  match relation
  case RELATION(index=zerocrossingIndex) then
    <<
     bool _condition<%zerocrossingIndex%>;
    >>
end conditionvarZero1;

template conditionvarSample(list<SampleCondition> sampleConditions,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  (sampleConditions |> (relation_,index)  =>
    conditionvarSample1(index, relation_, &varDecls /*BUFD*/,simCode)
  ;separator="\n")
end conditionvarSample;

template conditionvarSample1(Integer index1, Exp relation, Text &varDecls /*BUFP*/,SimCode simCode)
::=
  match relation
  case CALL(path=IDENT(name="sample"), expLst={start, interval,index}) then
    let &preExp = buffer "" /*BUFD*/
    let eIndex = daeExp(index, contextOther, &preExp, &varDecls /*BUFD*/,simCode)
     <<
     bool _condition<%eIndex%>;
    >>
end conditionvarSample1;

template conditionvariable(list<ZeroCrossing> zeroCrossings,list<SampleCondition> sampleConditions,SimCode simCode) 
::=
  let conditionvariable = conditionvarZero(zeroCrossings,simCode)
  let conditionvarsample = conditionvarSample(sampleConditions,simCode)
  <<
   <%conditionvariable%>
   <%conditionvarsample%>
  >>
end conditionvariable;

template expTypeFromExpFlag(Exp exp, Integer flag)
::=
  match exp
  case ICONST(__)        then match flag case 8 then "int" case 1 then "int" else "int"
  case RCONST(__)        then match flag case 1 then "double" else "double"
  case SCONST(__)        then if acceptMetaModelicaGrammar() then
                                (match flag case 1 then "metatype" else "modelica_metatype")
                              else
                                (match flag case 1 then "string" else "modelica_string")
  case BCONST(__)        then match flag case 1 then "bool" else "modelica_boolean"
  case ENUM_LITERAL(__)  then match flag case 8 then "int" case 1 then "int" else "int"
  case e as BINARY(__)
  case e as UNARY(__)
  case e as LBINARY(__)
  case e as LUNARY(__)
  case e as RELATION(__) then expTypeFromOpFlag(e.operator, flag)
  case IFEXP(__)         then expTypeFromExpFlag(expThen, flag)
  case CALL(attr=CALL_ATTR(__))          then expTypeFlag(attr.ty, flag)
  case c as ARRAY(__)
  case c as MATRIX(__)
  case c as RANGE(__)
  case c as CAST(__)
  case c as CREF(__)
  case c as CODE(__)     then expTypeFlag(c.ty, flag)
  case ASUB(__)          then expTypeFromExpFlag(exp, flag)
  case REDUCTION(__)     then expTypeFlag(typeof(exp), flag)
  case BOX(__)
  case CONS(__)
  case LIST(__)

  case META_TUPLE(__)
  case META_OPTION(__)
  case MATCHEXPRESSION(__)
  case METARECORDCALL(__)
  case BOX(__)           then match flag case 1 then "metatype" else "modelica_metatype"
  case c as UNBOX(__)    then expTypeFlag(c.ty, flag)
  case c as SHARED_LITERAL(__) then expTypeFlag(c.ty, flag)
  else ""
end expTypeFromExpFlag;

template expTypeFromOpFlag(Operator op, Integer flag)
 "Generate type helper."
::=
  match op
  case o as ADD(__)
  case o as SUB(__)
  case o as MUL(__)
  case o as DIV(__)
  case o as POW(__)

  case o as UMINUS(__)
  case o as UPLUS(__)
  case o as UMINUS_ARR(__)
  case o as UPLUS_ARR(__)
  case o as ADD_ARR(__)
  case o as SUB_ARR(__)
  case o as MUL_ARR(__)
  case o as DIV_ARR(__)
  case o as MUL_SCALAR_ARRAY(__)
  case o as MUL_ARRAY_SCALAR(__)
  case o as ADD_SCALAR_ARRAY(__)
  case o as ADD_ARRAY_SCALAR(__)
  case o as SUB_SCALAR_ARRAY(__)
  case o as SUB_ARRAY_SCALAR(__)
  case o as MUL_SCALAR_PRODUCT(__)
  case o as MUL_MATRIX_PRODUCT(__)
  case o as DIV_ARRAY_SCALAR(__)
  case o as DIV_SCALAR_ARRAY(__)
  case o as POW_ARRAY_SCALAR(__)
  case o as POW_SCALAR_ARRAY(__)
  case o as POW_ARR(__)
  case o as POW_ARR2(__)
  case o as LESS(__)
  case o as LESSEQ(__)
  case o as GREATER(__)
  case o as GREATEREQ(__)
  case o as EQUAL(__)
  case o as NEQUAL(__) then
    expTypeFlag(o.ty, flag)
  case o as AND(__)
  case o as OR(__)
  case o as NOT(__) then
    match flag case 1 then "bool" else "modelica_boolean"
  else "expTypeFromOpFlag:ERROR"
end expTypeFromOpFlag;

template checkForDiscreteEvents(list<ComponentRef> discreteModelVars,SimCode simCode)
::=

  let changediscreteVars = (discreteModelVars |> var => match var case CREF_QUAL(__) case CREF_IDENT(__) then
       'if (_event_handling.change(<%cref(var)%>,"<%cref(var)%>")) {  restart=true; }'
       ;separator="\n")
  match simCode
  case SIMCODE(modelInfo = MODELINFO(__)) then
  <<
  bool <%lastIdentOfPath(modelInfo.name)%>::checkForDiscreteEvents()
  {
    bool restart = false;
    <%changediscreteVars%>
    return restart;
  }
  >>
end checkForDiscreteEvents;

template update(list<SimEqSystem> continousEquations,list<SimEqSystem> discreteEquations,list<SimWhenClause> whenClauses,list<SimEqSystem> parameterEquations,SimCode simCode)
::=
  let &varDecls = buffer "" /*BUFD*/
  let continous = (continousEquations |> eq =>
      equation_(eq, contextOther, &varDecls /*BUFC*/,simCode)
    ;separator="\n")
  let paraEquations = (parameterEquations |> eq =>
      equation_(eq, contextOther, &varDecls /*BUFD*/,simCode)
    ;separator="\n") 
  let discrete = (discreteEquations |> eq =>
      equation_(eq, contextSimulationDiscrete, &varDecls /*BUFC*/,simCode)
    ;separator="\n")
  let reinit = (whenClauses |> when hasindex i0 =>
         genreinits(when, &varDecls,i0,simCode)
    ;separator="\n") 
  match simCode
  case SIMCODE(modelInfo = MODELINFO(__)) then    
  <<
  void <%lastIdentOfPath(modelInfo.name)%>::update(const UPDATE command)
  {
    <%varDecls%>
   if(command & CONTINOUS)
  {
    <%paraEquations%>
    <%continous%>
  }
   if (command & DISCRETE)
  {
    <%discrete%>
    <%reinit%>
  }
  }
  >>
end update;

template genreinits(SimWhenClause whenClauses, Text &varDecls, Integer int,SimCode simCode)
::=

match whenClauses
case SIM_WHEN_CLAUSE(__) then
  let &preExp = buffer "" /*BUFD*/
  let &helpInits = buffer "" /*BUFD*/
  let helpIf = (conditions |> (e, hidx) =>
      let helpInit = daeExp(e, contextSimulationDiscrete, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
      let &helpInits +=""
      '_event_handling.edge(_event_handling[<%hidx%>],"h<%hidx%>")'
   ;separator="||")
  let ifthen = functionWhenReinitStatementThen(reinits, &varDecls /*BUFP*/,simCode)                     

if reinits then  
<<

  //For whenclause index: <%int%>
  <%preExp%>
  <%helpInits%>
  if (<%helpIf%>) { 
    <%ifthen%>
  }
>>
end genreinits;

template functionWhenReinitStatementThen(list<WhenOperator> reinits, Text &varDecls /*BUFP*/,SimCode simCode)
 "Generates re-init statement for when equation."
::=
  let body = (reinits |> reinit =>
    match reinit
    case REINIT(__) then 
      let &preExp = buffer "" /*BUFD*/
      let val = daeExp(value, contextSimulationDiscrete,
                   &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
     <<
      <%preExp%>
                <%cref1(stateVar,simCode)%> = <%val%>;
              
                >>
    case TERMINATE(__) then 
      let &preExp = buffer "" /*BUFD*/
    let msgVar = daeExp(message, contextSimulationDiscrete, &preExp /*BUFC*/, &varDecls /*BUFD*/,simCode)
    <<  
                <%preExp%> 
                MODELICA_TERMINATE(<%msgVar%>);
                >>
  case ASSERT(source=SOURCE(info=info)) then 
    assertCommon(condition, message, contextSimulationDiscrete, &varDecls, info,simCode)
  ;separator="\n")
  <<
   <%body%>  
  >>
end functionWhenReinitStatementThen;

end SimCodeCpp;