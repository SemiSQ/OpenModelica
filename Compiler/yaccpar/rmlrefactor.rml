module RMLRefactor:
  with "absyn.rml"	
  
  datatype RMLRefactor = RENAME_RELATION of Absyn.Ident * Absyn.Ident
		       | RENAME_VARIABLE of Absyn.Ident * Absyn.Ident
	               | RENAME_CONTRUCTOR of Absyn.Ident * Absyn.Ident 

  relation dummy: () => ()	
  relation refactor: Absyn.Program => ()
end

(*
relation print_id =
  rule  print name
	----------------
	print_id(Absyn.RMLSHORTID(name)) => ()

  rule  print prefix & print "." & print name
	----------------------
	print_id(Absyn.RMLLONGID(prefix,name)) => ()
 
(*  rule 	print id 
       	-------------
	print_id(Absyn.RMLIdent(id)) => () *)	  

end

relation print_operator =
  rule  print "+"
	-------------------
	print_operator(Absyn.ADD) => ()

  rule  print "-"
	-------------------
	print_operator(Absyn.SUB) => ()

  rule  print "*"
	-------------------
	print_operator(Absyn.MUL) => ()

  rule  print "/"
	-------------------
	print_operator(Absyn.DIV) => ()

  rule  print "-"
	------------------
	print_operator(Absyn.UMINUS) => ()
end

relation print_literal =
  (* FIXME: handle escape sequences *)
  rule  print "\"" & print s & print "\""
	--------------------------
	print_literal(Absyn.RMLLIT_STRING(s)) => ()

  rule  int_string(i) => s & print s
	--------------------------
	print_literal(Absyn.RMLLIT_INTEGER(i)) => ()

  rule  real_string(r) => s & print s
	-------------------------
	print_literal(Absyn.RMLLIT_REAL(r)) => ()

  (* RMLLIT_CHAR ? *)
end


relation refactor_expression_list =
  rule  refactor_expression(last)
	-----------------------------
	refactor_expression_list(last :: []) => () 

  rule  refactor_expression(first) &
	print ", " &
	refactor_expression_list(rest)
	------------------------------
	refactor_expression_list(first :: rest) => ()

  rule  print ""
	------------------------------
	refactor_expression_list([]) => ()
end 


relation refactor_expression =
  rule  print id &
        print "(" &
        refactor_expression_list(args) &
        print ")"
	----------------------------
	refactor_expression(Absyn.RMLCALL(id,args)) => ()

  rule  refactor_expression(left) &
	print " :: " &
	refactor_expression(right)
	----------------------------
	refactor_expression(Absyn.RMLCONS(left,right)) => ()

  rule  refactor_expression(left) &
        print_operator(op) &
        refactor_expression(right)
	-------------------------------
	refactor_expression(Absyn.BINARY(left,op,right)) => ()

  rule  print_operator(op) &
        refactor_expression(exp)
	-------------------------------
	refactor_expression(Absyn.UNARY(op,exp)) => ()

  rule  print "()"
	------------------------------
	refactor_expression(Absyn.RMLNIL) => ()

  (* Debug *)
(*  rule  refactor_expression(first) &
        print ", " &
        refactor_expression(rest)
	------------------------
	refactor_expression(Absyn.ARRAY(first::rest)) => () *)
end

relation refactor_pattern_list =
  rule  refactor_pattern(last)
	------------------------
	refactor_pattern_list(last :: []) => ()

  rule  refactor_pattern(first) &
	print ", " &
	refactor_pattern_list(rest)
	----------------------------
	refactor_pattern_list(first :: rest) => ()

  rule  print ""
	------------------------------
	refactor_pattern_list([]) => ()
end


relation refactor_pattern =
  rule  print id & print " as " & refactor_pattern(pat)
	-----------------------------
	refactor_pattern(Absyn.RMLPAT_AS(id,pat)) => ()

  rule  refactor_pattern(first) & print " :: " & refactor_pattern(rest)
	------------------------------
	refactor_pattern(Absyn.RMLPAT_CONS(first,rest)) => ()

  rule  print "(" &
	refactor_pattern_list(list) &
	print ")"
	------------------------------
	refactor_pattern(Absyn.RMLPAT_STRUCT(list)) => ()

  rule  print "()"
	-----------------------------
	refactor_pattern(Absyn.RMLPAT_NIL) => ()

  rule  print id &
	print "(" &
	refactor_pattern_list(patlist) &
	print ")"
	-----------------------------
	refactor_pattern(Absyn.RMLPAT_CALL(id,patlist)) => ()

  rule  print_id(id)
	-----------------------------
	refactor_pattern(Absyn.RMLPAT_IDENT(id)) => ()

  rule  print "_"
	------------------------------
	refactor_pattern(Absyn.RMLPAT_WILDCARD) => ()

  rule  print_literal(lit)
	------------------------------
	refactor_pattern(Absyn.RMLPAT_LITERAL(lit)) => ()

end


relation refactor_goal =
  rule  print "not " &
	refactor_goal(goal)
	------------------
	refactor_goal(Absyn.RMLGOAL_NOT(goal)) => ()

  rule  refactor_goal(leftgoal) &
	print "&\n        " &
	refactor_goal(rightgoal)
	------------------
	refactor_goal(Absyn.RMLGOAL_AND(leftgoal,rightgoal)) => ()

  rule  refactor_pattern(pat)
	------------------
	refactor_goal(Absyn.RMLGOAL_PAT(pat)) => ()

  rule  print "let " &
        print id &
	print " = " &
	refactor_expression(exp)
	------------------------
	refactor_goal(Absyn.RMLGOAL_LET(id,exp)) => ()

  rule  refactor_expression(leftexp) &
	print " = " &
	refactor_expression(rightexp)
	------------------------
	refactor_goal(Absyn.RMLGOAL_EQUAL(leftexp,rightexp)) => ()

  rule  print id &
        print "(" &
	refactor_expression_list(args) &
	print ")" &
	print " => " &
	refactor_pattern(pat)
	------------------------
	refactor_goal(Absyn.RMLGOAL_RELATION(id,args,pat)) => ()
end


relation refactor_result =
  rule	print " => fail"
	---------------------
	refactor_result(Absyn.RMLResultFail) => ()

  rule  print ""
	---------------------
	refactor_result(Absyn.RMLNoResult) => ()

  rule  print " => " &
	refactor_expression_list(list)
	----------------------
	refactor_result(Absyn.RMLResultExp(list)) => ()
end


relation refactor_rule =
  rule  print "  rule  " &
        refactor_goal(goal) &
        print "\n\t-------------------------------\n\t" &
	print id &
	print "(" &
	refactor_pattern_list(patlist) &
	print ")" &
	refactor_result(result) &
        print "\n"
	-------------------------------------------
	refactor_rule(Absyn.RMLRULE(id,patlist,goal,result),RENAME_RELATION(old,new)) => ()
end


relation refactor_rule_list =
  rule  
	----------------------------
	refactor_rule_list([]) => []

  rule  refactor_rule(last,refactor) => reflast
	----------------------------
	refactor_rule_list(last :: [],refactor) => reflast::[]

  rule  refactor_rule(first,refactor) => reffirst &
	refactor_rule_list(rest,refactor) => refrest
	----------------------------
	refactor_rule_list(first :: rest,refactor) => reffirst::refrest
end

(* UN
relation refactor_type_tuple =
  rule  refactor_type(first)
	-------------------------------
	refactor_type_tuple(first :: []) => ()

  rule  refactor_type(first) &
	print " * " &
	refactor_type_tuple(rest)
	-------------------------------
	refactor_type_tuple(first :: rest) => ()
end *)

(*UN
relation refactor_type =
  rule  print "int"
	------------------------
	refactor_type(Absyn.RMLTYPE_INT) => ()

  rule  print "real"
	------------------------
	refactor_type(Absyn.RMLTYPE_REAL) => ()

  rule  print "string"
	------------------------
	refactor_type(Absyn.RMLTYPE_STRING) => ()

  rule  print "int"
	------------------------
	refactor_type(Absyn.RMLTYPE_INT) => ()

  rule  refactor_type(rtype) &
	print "list"
	------------------------
	refactor_type(Absyn.RMLTYPE_LIST(rtype)) => ()

  rule  refactor_type(intype) &
	print " => " &
	refactor_type(outtype)
	------------------------
	refactor_type(Absyn.RMLTYPE_SIGNATURE(Absyn.CALLSIGN(intype,outtype))) => ()

  rule  refactor_type_tuple(typelist)
	------------------------
	refactor_type(Absyn.RMLTYPE_TUPLE(typelist)) => ()

  rule  print_id(id)
	------------------------
	refactor_type(Absyn.RMLTYPE_TYVAR(id)) => ()

  rule  print_id(id)
	-------------------------
	refactor_type(Absyn.RMLTYPE_USERDEFINED(id)) => ()
end *)

(*UN
relation refactor_comment =
  rule  print "(* " &
        print s &
	print "*)\n"
	--------------------------------------
	refactor_comment(s) => ()
end


relation refactor_dtmember =
  rule  print id &
	print " of " &
	refactor_type_tuple(typelist)
	--------------------------
	refactor_dtmember(Absyn.DTCONS(id,typelist))
end


relation refactor_dtmember_list =
  rule  refactor_dtmember(last)
	-----------------------------
	refactor_dtmember_list(last :: []) => ()

  rule  refactor_dtmember(first) &
	print "\n\t\t| " &
	refactor_dtmember_list(rest)
	-----------------------------
	refactor_dtmember_list(first :: rest) => ()
end


relation refactor_decl_signature =
  rule 	refactor_type(intype) & 
	print " => " &
	refactor_type(outtype) 
	----------------------------
	refactor_decl_signature(Absyn.CALLSIGN(intype,outtype)) => () 

end
*)
relation refactor_rmldecl =
  rule (*	refactor_decl_signature(sign) & *) 
        refactor_id(id,old,new) => refid
	----------------------
	refactor_rmldecl(Absyn.RELATION_INTERFACE(id,sign),RENAME_RELATION(old,new)) => (* () *)
	Absyn.RELATION_INTERFACE(refid,sign)	

  rule	(*refactor_decl_signature(sign)  *)
	refactor_id(id,old,new) => refid &
	refactor_rule_list(rules,RENAME_RELATION(old,new)) 
	--------------------------------
	refactor_rmldecl(Absyn.RELATION_DEFINITION(id,sign,rules),RENAME_RELATION(old,new)) => 
	Absyn.RELATION_DEFINITION(refid,sign,rules)

  rule  refactor_id(id) => refid
	--------------------------
	refactor_rmldecl(Absyn.DATATYPE(id,dtmlist),RENAME_DATATYPE(old,new)) => 
	Absyn.DATATYPE(refid,dtmlist)

  rule 	(*UN refactor_type(rtype) & *)
	----------------------------
	refactor_rmldecl(Absyn.TYPE(id,rtype),refactor) => () (* must be something *)

  rule  (*UN print_literal(Absyn.RMLLIT_STRING(s)) & *)
	-------------------------------
	refactor_rmldecl(Absyn.WITH(s),refactor) =>
	Absyn.WITH(s)

  rule	(*UN refactor_type(rtype) & *)
	-------------------------------
	refactor_rmldecl(Absyn.VALINTERFACE(id,rtype),refactor) =>
	Absyn.VALINTERFACE(id,rtype)

  rule 
(*UN	refactor_expression(exp) & UN*)
	--------------------------------
	refactor_rmldecl(Absyn.VALDEF(id,exp),refactor) => Absyn.VALDEF(id,exp)


  rule  (*refactor_comment(s) UN*)
	--------------------------------
	refactor_rmldecl(Absyn.RMLDECLCOMMENT(s),refactor) => () 
end

(* can list be handled like this *)
relation refactor_rmldecl_list =
  rule 	refactor_rmldecl(last,refactor) => reflast 
	---------------------------
	refactor_rmldecl_list(last::[],refactor) => reflast::[]
	
  rule 	refactor_rmldecl(first,refactor) => reffirst&
	refactor_rmldecl_list(rest,refactor) 		
	-----------------------
	refactor_rmldecl_list(first::rest,refactor) => reffirst::rest

end


relation refactor_interfaces =
  rule  recator_rmldecl_list(x,refactor) => refdecl_list
	---------------------------
	refactor_interfaces(x,refactor) => refdecl_list
end


relation refactor_definitions =
  rule  refactor_rmldecl_list(x,refactor) => refdecl_list
	---------------------------
	refactor_definitions(x,refactor) => refecl_list
end
*)

relation refactor =
 (*
  rule  refactor_interfaces(iflist,refactor) => refiflist & 
        refactor_definitions(deflist,refactor) => refdeflist  
	---------------------------
	refactor(Absyn.RML_FILE(id,refiflist,refdeflist),refactor) => ()

  rule  print "(* Non-RML *)\n"
	---------------------
	refactor(_,refactor) => ()
  *)
  rule 	print "(* Non-supported refactor *)"
        ----------------------------
	refactor(_) => ()
  	
end

relation dummy =
  rule 	print "dummy oh dummy\n"
	----------------------
	dummy() => ()
end	