// FILE/CLASS ADDED 2005-20-27 /AF

/*! 
 * \file highlighter.cpp
 * \author www.trolltech.com
 *
 * \brief This file was taken from trolltech:s website:
 * http://doc.trolltech.com/4.0/richtext-syntaxhighlighter-highlighter-cpp.html
 */

/****************************************************************************
**
** Copyright (C) 2005-2005 Trolltech AS. All rights reserved.
**
** This file is part of the documentation of the Qt Toolkit.
**
** This file may be used under the terms of the GNU General Public
** License version 2.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of
** this file.  Please review the following information to ensure GNU
** General Public Licensing requirements will be met:
** http://www.trolltech.com/products/qt/opensource.html
**
** If you are unsure which license is appropriate for your use, please
** review the following information:
** http://www.trolltech.com/products/qt/licensing.html or contact the
** sales department at sales@trolltech.com.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

#include <iostream>
#include <QtGui>

#include "highlighter.h"


using namespace std;

Highlighter::Highlighter(QObject *parent)
: QObject(parent)
{
	// added 2005-11-14 AF
	insideString_ = false;
	insideComment_ = false;
}

void Highlighter::addToDocument(QTextDocument *doc)
{
	connect(doc, SIGNAL(contentsChange(int, int, int)),
		this, SLOT(highlight(int, int, int)));
}

void Highlighter::addMapping(const QString &pattern,
							 const QTextCharFormat &format)
{
	mappings[pattern] = format;
}

// Added 2005-11-13 AF, need it to have strings/comments span over sevral blocks
void Highlighter::addCommentLineMapping( const QString &pattern, 
	const QTextCharFormat &format )
{
	commentLine_.setPattern( pattern );
	commentLineFormat_ = format;
}

// Added 2005-11-13 AF, need it to have strings/comments span over sevral blocks
void Highlighter::addStringMapping( const QString &patternStart, 
	const QString &patternEnd, 
	const QTextCharFormat &format )
{
	stringStart_.setPattern( patternStart );
	stringEnd_.setPattern( patternEnd );
	stringFormat_ = format;
}

// Added 2005-11-13 AF, need it to have strings/comments span over sevral blocks
void Highlighter::addCommentMapping( const QString &patternStart, 
	const QString &patternEnd, 
	const QTextCharFormat &format )
{
	commentStart_.setPattern( patternStart );
	commentEnd_.setPattern( patternEnd );
	commentFormat_ = format;
}

void Highlighter::highlight( int from, int removed, int added )
{
	QTextDocument *doc = qobject_cast<QTextDocument *>(sender());

	/*
	QTextBlock block = doc->findBlock(position);
	if (!block.isValid())
		return;

	QTextBlock endBlock;
	if (added > removed)
		endBlock = doc->findBlock(position + added);
	else
		endBlock = block;

	while (block.isValid() && !(endBlock < block)) {
		highlightBlock(block);
		block = block.next();
	}
	*/

	// to syntax highlight strings and comments correctly, I need
	// to go through the whole document
	QTextBlock block = doc->begin();

	insideString_ = false;
	insideComment_ = false;

	if( block.isValid() )
	{
		if( block.text().isEmpty() )
			cout << "Highlight() - Empty" << endl;
		else
			cout << "HIGHLIGHT: Start" << endl;
	}


	while( block.isValid() )
	{
		highlightBlock(block);
		block = block.next();
	}
}

// changed 2005-11-14 AF
void Highlighter::highlightBlock(QTextBlock block)
{
    QTextLayout *layout = block.layout();
    const QString text = block.text();
    QList<QTextLayout::FormatRange> overrides;

	bool wholeBlock = false;
	int startPos = 0;

	if( insideString_ )
	{
		int end = text.indexOf( stringEnd_, startPos );

		if( end >= 0 )
		{ // found end in this block
			startPos = end + stringEnd_.matchedLength();
			insideString_ = false;

			QTextLayout::FormatRange range;
			range.start = 0;
			range.length = startPos;
			range.format = stringFormat_;
			overrides << range;
		}
		else
		{ // found no end, syntax highlight whole block
			wholeBlock = true;

			QTextLayout::FormatRange range;
			range.start = 0;
			range.length = block.length();
			range.format = stringFormat_;
			overrides << range;
		}
	}
	else if( insideComment_ )
	{
		int end = text.indexOf( commentEnd_, startPos );
		
		if( end >= 0 )
		{ // found end in this block
			startPos = end + commentEnd_.matchedLength();
			insideComment_ = false;

			QTextLayout::FormatRange range;
			range.start = 0;
			range.length = startPos;
			range.format = commentFormat_;
			overrides << range;
		}
		else
		{ // found no end, syntax highlight whole block
			wholeBlock = true;

			QTextLayout::FormatRange range;
			range.start = 0;
			range.length = block.length();
			range.format = commentFormat_;
			overrides << range;
		}
	}
	
	
	if( !wholeBlock )
	{
		foreach( QString pattern, mappings.keys() ) 
		{
			QRegExp expression( pattern );
			int i = text.indexOf( expression, startPos );

			while( i >= 0 ) 
			{
				QTextLayout::FormatRange range;
				range.start = i;
				range.length = expression.matchedLength();
				range.format = mappings[pattern];
				overrides << range;

				i = text.indexOf(expression, i + expression.matchedLength());
			}
		}
	

		while( true )
		{
			int firstString = -1;
			int firstComment = -1;
			int firstCommentLine = -1;


			if( !stringStart_.isEmpty() )
				firstString = text.indexOf( stringStart_, startPos );
			if( !commentStart_.isEmpty() )
				firstComment = text.indexOf( commentStart_, startPos );
			if( !commentLine_.isEmpty() )
				firstCommentLine = text.indexOf( commentLine_, startPos );


			if( firstString >= 0 && 
				( (firstString < firstComment) || (firstComment < 0) ) && 
				( (firstString < firstCommentLine) || (firstCommentLine < 0) ))
			{
				int end = text.indexOf( stringEnd_, 
					firstString + stringStart_.matchedLength() );
				if( end >= 0 )
				{
					startPos = end + stringEnd_.matchedLength();

					QTextLayout::FormatRange range;
					range.start = firstString;
					range.length = startPos - firstString;
					range.format = stringFormat_;
					overrides << range;
				}
				else
				{ // found no end, syntax highlight to the end of the block
					QTextLayout::FormatRange range;
					range.start = firstString;
					range.length = block.length() - firstString;
					range.format = stringFormat_;
					overrides << range;
					insideString_ = true;
					break;
				}
			}
			else if( firstComment >= 0 && 
				( (firstComment < firstString) || (firstString < 0) ) &&
				( (firstComment < firstCommentLine) || (firstCommentLine < 0) ))
			{
				int end = text.indexOf( commentEnd_, 
					firstComment + commentStart_.matchedLength() );
				if( end >= 0 )
				{
					startPos = end + commentEnd_.matchedLength();

					QTextLayout::FormatRange range;
					range.start = firstComment;
					range.length = startPos - firstComment;
					range.format = commentFormat_;
					overrides << range;
				}
				else
				{ // found no end, syntax highlight to the end of the block
					QTextLayout::FormatRange range;
					range.start = firstComment;
					range.length = block.length() - firstComment;
					range.format = commentFormat_;
					overrides << range;
					insideComment_ = true;
					break;
				}
			}
			else if( firstCommentLine >= 0 && 
				( (firstCommentLine < firstString) || (firstString < 0) ) &&
				( (firstCommentLine < firstComment) || (firstComment < 0) ))
			{
				QTextLayout::FormatRange range;
				range.start = firstCommentLine;
				range.length = (block.length() - firstCommentLine);
				range.format = commentLineFormat_;
				overrides << range;
				break;
			}
			else
				break;
		}
	}

    layout->setAdditionalFormats( overrides );
    //const_cast<QTextDocument *>(block.document())->markContentsDirty(
    //    block.position(), block.length());
}

