#ifndef MODEQ_COMMUNICATOR_HPP_
#define MODEQ_COMMUNICATOR_HPP_

// MME includes
//#include "main.hpp"
//#include "exceptions.hpp"

// QT includes
#include <QtCore/QObject>

/*
// MME forward declarations
class AnnotationCompiler;
class PlacementAnnotation;
class DiagramLayerAnnotation;
class GraphicalLayerAnnotation;
class IconLayerAnnotation;
class Line;
class Modification;
*/

// QT forward declarations
class QString;
class QStringList;

// Modeq communication interface
#include "modeq_communication.h"

/**
 *
 */

/*
  struct ComponentDeclaration
  {
  ComponentDeclaration(QString type, QString name, QString comment) : type_(type), name_(name), comment_(comment) {};
  
  QString type_;
  QString name_;
  QString comment_;
  };
*/  
//------------------------------------------------------------------------------------

/**
 * \brief
 * The ModeqCommunicator handles all low level communication with Modeq.
 *
 * This class is a singleton class, use the static getInstance() member function to obtain a
 * reference to its instance.
 */
class ModeqCommunicator : public QObject
{
  Q_OBJECT

public:
  ~ModeqCommunicator();
   static ModeqCommunicator& getInstance();
   
   bool establishConnection();
   void closeConnection();
   bool isConnected() const;
  
   QString callModeq(const QString& fnCall); 

/*
  void loadFile(const QString& file);
  bool loadClass(const QString& ref);
  void saveClass(const QString& file, const QString& ref);

  void createPackage(const QString& ref, const QStringList& baseClassRefs,
  const QString& comment, bool encapsulated, bool partial);
  void createConnector(const QString& ref, const QStringList& baseClassRefs,
  const QString& comment, bool encapsulated, bool partial);
  void createModel(const QString& ref, const QStringList& baseClassRefs,
  const QString& comment, bool encapsulated, bool partial);
  void createBlock(const QString& ref, const QStringList& baseClassRefs,
  const QString& comment, bool encapsulated, bool partial);
  void createRecord(const QString& ref, const QStringList& baseClassRefs,
  const QString& comment, bool encapsulated, bool partial);
  void createFunction(const QString& ref, const QStringList& baseClassRefs,
  const QString& comment, bool encapsulated, bool partial);
  
  bool deleteClass(const QString& ref);

  bool existsClass(const QString& ref);
  bool isBlock(const QString& ref);
  bool isClass(const QString& ref);
  bool isConnector(const QString& ref);
  bool isFunction(const QString& ref);
  bool isModel(const QString& ref);
  bool isPackage(const QString& ref);
  bool isRecord(const QString& ref);
  bool isType(const QString& ref);
  bool isPrimitive(const QString& ref);

  QString getClassNames(const QString& ref);

  IconLayerAnnotation* getIconLayerAnnotation(const QString& ref);
  DiagramLayerAnnotation* getDiagramLayerAnnotation(const QString& ref);
  void setClassLayerAnnotation(const QString& ref, const QString& annotation);

  int getInheritanceCount(const QString& ref);
  QString getNthInheritedClass(const QString& ref, int index);

  int getComponentCount(const QString& ref);
  std::vector<ComponentDeclaration> getComponents(const QString& ref);
  Modification* getNthComponentModification(const QString& ref, int index, const QString& name);
  std::vector<PlacementAnnotation*> getComponentAnnotations(const QString& ref);
  
  void addComponent(const QString& name, const QString& type, const QString& ref,
  const QString& annotation);
  void updateComponent(const QString& name, const QString& type, const QString& ref,
  const QString& comment, const QString& annotation = "");
  void deleteComponent(const QString& name, const QString& ref);
  bool isProtected(const QString& name, const QString& ref);
  
  int getConnectionCount(const QString& ref);
  QString getNthConnection(const QString& ref, int index);
  Line* getNthConnectionAnnotation(const QString& ref, int index);
  
  void addConnection(const QString& sourceConnectorRef, const QString& destinationConnectorRef,
  const QString& ref, const QString& annotation = "");
  void updateConnection(const QString& sourceConnectorRef,
  const QString& destinationConnectorRef, const QString& ref, const QString& annotation);
  void deleteConnection(const QString& sourceConnectorRef,
  const QString& destinationConnectorRef, const QString& ref);
  
  QString list(const QString& ref);
  void quit();
  
  void updateClassDefinition(const QString& ref, const QString& definition);


signals:
  void modeqInput(const QString&);
  void modeqOutput(const QString&);
*/
private:
   // Enforce the singleon's uniqueness.
   ModeqCommunicator();
   ModeqCommunicator(const ModeqCommunicator&);
   ModeqCommunicator& operator=(const ModeqCommunicator&);
   
//   QString callModeq(const QString& fnCall);

private:
   ModeqCommunication_var modeq_;
   //AnnotationCompiler* compiler_;
};

#endif

