/*
------------------------------------------------------------------------------------
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet,
Department of Computer and Information Science, PELAB
See also: www.ida.liu.se/projects/OpenModelica

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

* Neither the name of Linköpings universitet nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

For more information about the Qt-library visit TrollTech:s webpage regarding
licence: http://www.trolltech.com/products/qt/licensing.html

------------------------------------------------------------------------------------
*/

/*!
 * \file serializingvisitor.h
 * \author Ingemar Axelsson (and Anders Fernström)
 */


//STD Headers
#include <iostream>

// QT Headers
#include <QtCore/QBuffer>
#include <QtCore/QDataStream>

//IAEX Headers
#include "serializingvisitor.h"
#include "cellgroup.h"
#include "textcell.h"
#include "inputcell.h"
#include "cellcursor.h"
#include "imagecell.h"
#include "celldocument.h"


namespace IAEX
{
	/*!
	 * \class SerializingVisitor
	 * \date 2005-11-23 (update)
	 *
	 * \brief Saves a celltree to an xml file, by converting cell
	 * structure to XML.
	 *
	 * Traverses the cellstructure and * creates a serialized
	 * stream of the internal representation of * the document.
	 *
	 * 2005-11-01 AF, Had to update some small things due to changes
	 * in cell structure (porting from Q3TextEdit to QTextEdit).
	 * 2005-11-20 AF, Added support for saving images
	 * 2005-11-23 AF, Added support for saving state of output part,
	 * evaluated or not evaluated
	 */

	/*!
	 * \author Ingemar Axelsson
	 *
	 * \brief The class constructor
	 */
	SerializingVisitor::SerializingVisitor(QDomElement &element, QDomDocument &doc, Document* document)
		: currentElement_(element), doc_(doc), document_(document)
	{
	}

	/*!
	 * \author Ingemar Axelsson
	 *
	 * \brief The class deconstructor
	 */
	SerializingVisitor::~SerializingVisitor()
	{

	}

	// CELL
	void SerializingVisitor::visitCellNodeBefore(Cell *)
	{
		cout << "visitCellNode is not implemented" << endl;
	}

	void SerializingVisitor::visitCellNodeAfter(Cell *)
	{
	}

	// GROUPCELL
	void SerializingVisitor::visitCellGroupNodeBefore(CellGroup *node)
	{
		parents_.push(currentElement_);
		QDomElement ce = doc_.createElement("CellGroupData");
		currentElement_.appendChild(ce);

		ce.setAttribute("closed", node->isClosed());

		currentElement_ = ce;
	}

	/*!
	 * \bug Does not set the parent correctly.
 	 */
	void SerializingVisitor::visitCellGroupNodeAfter(CellGroup *)
	{
		currentElement_ = parents_.top();
		parents_.pop();
	}

	// TEXTCELL
	void SerializingVisitor::visitTextCellNodeBefore(TextCell *node)
	{
		// Make sure that the text is viewed correct /AF
		node->viewExpression(false);

		QDomElement textcell = doc_.createElement("Cell");

		// Changed 2005-11-01 AF, from 'node->text()' to
		// 'node->textHtml()', due to changes in the textcell.
		QString text = node->textHtml();
		QDomText t = doc_.createTextNode( text );

		// Changed 2005-11-01 AF, from 'node->style()' to
		// 'node->style().name()', due to changes in style.
		textcell.setAttribute("style", node->style().name());
		textcell.appendChild(t);

		Cell::rules_t r = node->rules();
		Cell::rules_t::const_iterator i = r.begin();
		for(;i!=r.end();++i)
		{
			textcell.setAttribute((*i)->attribute(), (*i)->value());
		}

		currentElement_.appendChild(textcell);

		// 2005-11-20
		// check if any images have been included in the text
		int pos(0);

		while( true )
		{
			int start = text.indexOf( "<img src=", pos, Qt::CaseInsensitive );
			if( 0 <= start )
			{ // found an image
				start += 10; // pos of first letter in imagename
				int end = text.indexOf( "\"", start );

				// get the image
				QString imagename = text.mid( start, end - start );

				CellDocument *doc = dynamic_cast<CellDocument*>(document_);
				QImage *image = doc->getImage( imagename );

				if( !image->isNull() )
				{
					// create element and save the image to file
					QDomElement imagenode = doc_.createElement("Image");
					imagenode.setAttribute( "name", imagename );

					QBuffer buffer;
					buffer.open( QBuffer::WriteOnly );
					QDataStream out( &buffer );
					out << *image;
					buffer.close();

					QDomText imagedata = doc_.createTextNode( buffer.buffer().toBase64() );
					imagenode.appendChild( imagedata );

					currentElement_.appendChild( imagenode );
				}

				pos = end + 1;
			}
			else
				break;
		}
	}

	void SerializingVisitor::visitTextCellNodeAfter(TextCell *)
	{
	}

	//INPUTCELL
	void SerializingVisitor::visitInputCellNodeBefore(InputCell *node)
	{
		QDomElement inputcell = doc_.createElement("Cell");

		QDomText text = doc_.createTextNode(node->text());
		inputcell.setAttribute("style", "Input");

		// 2005-11-23
		// save output state (evaluated or not) and output text
		QString outputtext;
		if( node->isEvaluated() )
		{
			inputcell.setAttribute( "eval", "true" );

			if( node->isPlot() )
			{
				outputtext = node->textOutputHtml();
				inputcell.setAttribute( "output", outputtext );
			}
			else
				inputcell.setAttribute( "output", node->textOutput() );
		}
		else
			inputcell.setAttribute( "eval", "false" );


		inputcell.appendChild(text);
		currentElement_.appendChild(inputcell);

		// check if any images have been included in the text
		int pos(0);

		while( true )
		{
			int start = outputtext.indexOf( "<img src=", pos, Qt::CaseInsensitive );
			if( 0 <= start )
			{ // found an image
				start += 10; // pos of first letter in imagename
				int end = outputtext.indexOf( "\"", start );

				// get the image
				QString imagename = outputtext.mid( start, end - start );

				CellDocument *doc = dynamic_cast<CellDocument*>(document_);
				QImage *image = doc->getImage( imagename );

				if( !image->isNull() )
				{
					// create element and save the image to file
					QDomElement imagenode = doc_.createElement("Image");
					imagenode.setAttribute( "name", imagename );

					QBuffer buffer;
					buffer.open( QBuffer::WriteOnly );
					QDataStream out( &buffer );
					out << *image;
					buffer.close();

					QDomText imagedata = doc_.createTextNode( buffer.buffer().toBase64() );
					imagenode.appendChild( imagedata );

					currentElement_.appendChild( imagenode );
				}

				pos = end + 1;
			}
			else
				break;
		}
	}

	void SerializingVisitor::visitInputCellNodeAfter(InputCell *)
	{
	}

	//IMAGECELL
	void SerializingVisitor::visitImageCellNodeBefore(ImageCell *node)
	{
		QDomElement imgCell = doc_.createElement("Cell");
		imgCell.setAttribute("style", "Image");
		imgCell.setAttribute("filename", node->filename());

		currentElement_.appendChild(imgCell);
	}

	void SerializingVisitor::visitImageCellNodeAfter(ImageCell *)
	{
	}

	//CELLCURSOR
	void SerializingVisitor::visitCellCursorNodeBefore(CellCursor *)
	{
	}

	void SerializingVisitor::visitCellCursorNodeAfter(CellCursor *)
	{
	}
}
