package %ParseCode% // %time%
import Types;

%prologue%

uniontype AstStack
  record ASTSTACK
%astStack%  end ASTSTACK;
  record EMPTY end EMPTY;
end AstStack;

function initAstStack
  input AstStack astStack;
  output AstStack astStack2;
 algorithm 
   astStack2 := ASTSTACK(%initStack%);
end initAstStack;

function getAST "returns the AST built by the parsing"
  input AstStack astStk "MultiTypedStack used by the parser";
  output AstTree ast "returns the AST in the final type of the tree";
  list<%astTree%> retStk;
  algorithm
    ASTSTACK(stack%astTree%=retStk) := astStk;
    ast::_ := retStk;
end getAST;  



function actionRed
  input Integer act;
  input AstStack astStk;
  input array<Integer> mm_r2;
  output AstStack astStk2;
  output Boolean error=false;
  output String errorMsg="";
  Types.Info info;
  // env variables       
  // AstStack 
%astStackVar%

  
algorithm
   
  // printContentStack(astStk);
  // print(" rule:" + intString(act));
   %GETASTSTACK%  
  (_) := matchcontinue(act,astStk)
    local
      //local variables
%caseAction%    
    case (_,_) 
      equation
        //lAST = intString(act);
        printAny("\n" + Types.printInfoError(info) + " : Ilegal action case " + intString(act));
      then ();
  end matchcontinue;
    %PUTASTSTACK% 
 /* astStk2 := ASTSTACK(idStk,inStk,boStk,roStk,exStk,ilStk,stStk); */
  
end actionRed;  

function reduceStringStack
  input list<String> skString;
  input Integer nTokens;
  output list<String> skStringRes;
  String strReduce;
  Integer i;
 algorithm 
  for i in 1:nTokens loop 
    strReduce::skString := skString; 
  end for;
  skStringRes := skString;
end reduceStringStack;

function getInfo
  input list<Token> skToken;
  input Integer nTokens;
  output Types.Info info;
  output list<Token> skTokenRes;
  Token token;
  Types.Info tmpInfo;
  Integer lns,cns,lne,cne,i;
  String fn;
algorithm  
  for i in 1:nTokens loop
     token::skToken := skToken;
     Types.TOKEN(loc=info) := token;
     if (i==nTokens) then
        Types.INFO(fileName=fn,lineNumberStart=lns,columnNumberStart=cns) := info;
     end if;
     if (i==1) then
        Types.INFO(lineNumberEnd=lne,columnNumberEnd=cne) := info;
     end if;
  end for;
  info := Types.INFO(fn,false,lns,cns,lne,cne,Types.getTimeStamp()); 
  token := Types.TOKEN("grupped",0,{},info);
  skTokenRes := token::skToken; 
end getInfo;

function push
  input AstStack astStk;
  input String inVal;
  input Types.Token token;
  output AstStack astStk2;
  // AstStack 
%astStackVar%
algorithm
 %GETASTSTACK%
  skString := inVal::skString;
  skToken := token::skToken;
  %PUTASTSTACK%
end push;

%epilogue%

end %ParseCode%;