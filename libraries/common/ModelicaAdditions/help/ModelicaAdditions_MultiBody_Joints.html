<HTML>
<HEAD><META name="HTML-Generator" content="Dymola"><TITLE>ModelicaAdditions</TITLE></HEAD>
<BODY><P>
<H2><A NAME="ModelicaAdditions.MultiBody.Joints"></A><A HREF="ModelicaAdditions_MultiBody.html#ModelicaAdditions.MultiBody"
>ModelicaAdditions.MultiBody</A>.Joints</H2>
<B>Joints in the spanning tree</B>
<P>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.RevoluteI.png" ALT="ModelicaAdditions.MultiBody.Joints.Revolute" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.PrismaticI.png" ALT="ModelicaAdditions.MultiBody.Joints.Prismatic" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Screw"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.ScrewI.png" ALT="ModelicaAdditions.MultiBody.Joints.Screw" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Cylindrical"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.CylindricalI.png" ALT="ModelicaAdditions.MultiBody.Joints.Cylindrical" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Universal"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.UniversalI.png" ALT="ModelicaAdditions.MultiBody.Joints.Universal" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Planar"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.PlanarI.png" ALT="ModelicaAdditions.MultiBody.Joints.Planar" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Spherical"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.SphericalI.png" ALT="ModelicaAdditions.MultiBody.Joints.Spherical" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.FreeMotion"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.FreeMotionI.png" ALT="ModelicaAdditions.MultiBody.Joints.FreeMotion" WIDTH=80  HEIGHT=80 ></A>
<P><P>
<H3>Information</H3>
<PRE></pre>
<p>
This package contains elements to model ideal joints.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF="mailto:Martin.Otter@dlr.de">Martin.Otter@dlr.de</A><br>
</dl>
<br>

<p><b>Release Notes:</b></p>
<ul>
<li><i>April 5, 2000</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>:<br>
       Realized.</li>
</ul>
<br>

<p><b>Copyright &copy; 2000-2002, DLR.</b></p>

<p><i>
The Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file "Modelica/package.mo".
</i></p>
<pre>
</PRE><P>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.RevoluteI.png" ALT="ModelicaAdditions.MultiBody.Joints.Revolute" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Revolute"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Revolute</H2>
<B>Revolute joint (1 degree-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.RevoluteD.png" ALT="ModelicaAdditions.MultiBody.Joints.Revolute">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a.
The joint axis has an additional flange where it can be
driven with elements of the Modelica.Mechanics.Rotational library.
The relative angle q [rad] and the relative angular velocity
qd [rad/s] are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  n : Axis of rotation resolved in frame_a (= same as in frame_b).
      n  must not necessarily be a unit vector. E.g.,
         n = {0, 0, 1} or n = {1, 0, 1}
  q0: Rotation angle offset in [deg].
      If q=q0, frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{0,0,1}</TD><TD>Axis of rotation resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>q0</TD><TD>0</TD><TD>Rotation angle offset (see info) [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Revolute <font color="darkgreen">
  &quot;Revolute joint (1 degree-of-freedom, used in spanning tree)&quot;</font> 
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>Interfaces.TreeJoint</A>;
  <font color="blue">parameter </font>Real n[3]={0,0,1} <font color="darkgreen">
    &quot;Axis of rotation resolved in frame_a (= same as in frame_b)&quot;</font>;
  <font color="blue">parameter </font>Real q0=0 <font color="darkgreen">&quot;Rotation angle offset (see info) [deg]&quot;</font>;
  <font color="blue">parameter </font>Boolean startValueFixed=false <font color="darkgreen">
    &quot;true, if start values of q, qd are fixed&quot;</font>;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> q(<font color="blue">final </font>fixed=startValueFixed);
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> qd(<font color="blue">final </font>fixed=startValueFixed);
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> qdd;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> qq;
  Real nn[3];
  Real sinq;
  Real cosq;
  <font color="darkgreen"></font>
  <A HREF="../../Modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a"
>Modelica.Mechanics.Rotational.Interfaces.Flange_a</A> axis;
  <A HREF="../../Modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b"
>Modelica.Mechanics.Rotational.Interfaces.Flange_b</A> bearing;
<font color="blue">equation </font>
  axis.phi = q;
  bearing.phi = 0;
  <font color="darkgreen"></font>
  <font color="darkgreen">// define states</font>
  qd = <font color="red">der</font>(q);
  qdd = <font color="red">der</font>(qd);
  <font color="darkgreen"></font>
  <font color="darkgreen">/*rotation matrix*/</font>
  nn = n/<font color="red">sqrt</font>(n*n);
  qq = q - q0*pi/180;
  sinq = <font color="red">sin</font>(qq);
  cosq = <font color="red">cos</font>(qq);
  S_rel = [nn]*<font color="red">transpose</font>([nn]) + (<font color="red">identity</font>(3) - [nn]*<font color="red">transpose</font>([nn]))*cosq - <font color="red">
    skew</font>(nn)*sinq;
  <font color="darkgreen"></font>
  <font color="darkgreen">/*other kinematic quantities*/</font>
  r_rela = <font color="red">zeros</font>(3);
  v_rela = <font color="red">zeros</font>(3);
  a_rela = <font color="red">zeros</font>(3);
  w_rela = nn*qd;
  z_rela = nn*qdd;
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Transform the kinematic quantities from frame_a to frame_b and the
     force and torque acting at frame_b to frame_a
     (= general equations of a &quot;TreeJoint&quot; specialized to this class).
  */</font>
  Sb = Sa*<font color="red">transpose</font>(S_rel);
  r0b = r0a;
  <font color="darkgreen"></font>
  vb = S_rel*va;
  wb = S_rel*(wa + w_rela);
  <font color="darkgreen"></font>
  ab = S_rel*aa;
  zb = S_rel*(za + z_rela + <font color="red">cross</font>(wa, w_rela));
  <font color="darkgreen"></font>
  fa = <font color="red">transpose</font>(S_rel)*fb;
  ta = <font color="red">transpose</font>(S_rel)*tb;
  <font color="darkgreen"></font>
  <font color="darkgreen">// d'Alemberts principle</font>
  axis.tau = nn*tb;
<font color="blue">end </font>Revolute;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.PrismaticI.png" ALT="ModelicaAdditions.MultiBody.Joints.Prismatic" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Prismatic"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Prismatic</H2>
<B>Prismatic joint (1 degree-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.PrismaticD.png" ALT="ModelicaAdditions.MultiBody.Joints.Prismatic">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where frame_b is translated around axis n which is fixed in frame_a.
The joint axis has an additional flange where it can be
driven with elements of the Modelica.Mechanics.Translational library.
The relative distance q [m] and the relative velocity qd [m] are
used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  n : Axis of translation resolved in frame_a (= same as in frame_b).
      n must not necessarily be a unit vector. E.g.,
         n = {0, 0, 1} or n = {1, 0, 1}
  q0: Relative distance offset in [m].
      (in the direction of n).
      If q=q0, frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{1,0,0}</TD><TD>Axis of translation resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>q0</TD><TD>0</TD><TD>Relative distance offset(see info) [m]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Prismatic <font color="darkgreen">
  &quot;Prismatic joint (1 degree-of-freedom, used in spanning tree)&quot;</font> 
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>Interfaces.TreeJoint</A>;
  <font color="blue">parameter </font>Real n[3]={1,0,0} <font color="darkgreen">
    &quot;Axis of translation resolved in frame_a (= same as in frame_b)&quot;</font>;
  <font color="blue">parameter </font><A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Position"
>SI.Position</A> q0=0 <font color="darkgreen">&quot;Relative distance offset(see info)&quot;</font>;
  <font color="blue">parameter </font>Boolean startValueFixed=false <font color="darkgreen">
    &quot;true, if start values of q, qd are fixed&quot;</font>;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Position"
>SI.Position</A> q(<font color="blue">final </font>fixed=startValueFixed);
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Velocity"
>SI.Velocity</A> qd(<font color="blue">final </font>fixed=startValueFixed);
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Acceleration"
>SI.Acceleration</A> qdd;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Position"
>SI.Position</A> qq;
  Real nn[3];
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Velocity"
>SI.Velocity</A> vaux[3];
  <font color="darkgreen"></font>
  <A HREF="../../Modelica/help/Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_a"
>Modelica.Mechanics.Translational.Interfaces.Flange_a</A> axis;
  <A HREF="../../Modelica/help/Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b"
>Modelica.Mechanics.Translational.Interfaces.Flange_b</A> bearing;
<font color="blue">equation </font>
  axis.s = q;
  bearing.s = 0;
  <font color="darkgreen"></font>
  <font color="darkgreen">// define states</font>
  qd = <font color="red">der</font>(q);
  qdd = <font color="red">der</font>(qd);
  <font color="darkgreen"></font>
  <font color="darkgreen">/*normalize axis vector*/</font>
  nn = n/<font color="red">sqrt</font>(n*n);
  <font color="darkgreen"></font>
  <font color="darkgreen">/*kinematic quantities*/</font>
  S_rel = <font color="red">identity</font>(3);
  qq = q - q0;
  r_rela = nn*qq;
  v_rela = nn*qd;
  a_rela = nn*qdd;
  w_rela = <font color="red">zeros</font>(3);
  z_rela = <font color="red">zeros</font>(3);
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Transform the kinematic quantities from frame_a to frame_b and the
     force and torque acting at frame_b to frame_a
     (= general equations of a &quot;TreeJoint&quot; specialized to this class).
  */</font>
  Sb = Sa;
  r0b = r0a + Sa*r_rela;
  <font color="darkgreen"></font>
  vaux = <font color="red">cross</font>(wa, r_rela);
  vb = va + v_rela + vaux;
  wb = wa;
  <font color="darkgreen"></font>
  ab = aa + a_rela + <font color="red">cross</font>(za, r_rela) + <font color="red">cross</font>(wa, vaux + 2*v_rela);
  zb = za;
  <font color="darkgreen"></font>
  fa = fb;
  ta = tb + <font color="red">cross</font>(r_rela, fa);
  <font color="darkgreen"></font>
  <font color="darkgreen">// d'Alemberts principle</font>
  axis.f = nn*fb;
<font color="blue">end </font>Prismatic;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.ScrewI.png" ALT="ModelicaAdditions.MultiBody.Joints.Screw" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Screw"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Screw</H2>
<B>Screw joint (1 degree-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.ScrewD.png" ALT="ModelicaAdditions.MultiBody.Joints.Screw">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a
and at the same time is translated around the same axis. The rotational
and translational movement are coupled by a fixed factor.
The joint axis has an additional flange where it can be
driven with elements of the Modelica.Mechanics.Rotational library.
The relative angle q [rad] and the relative angular velocity
qd [rad/s] are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  n    : Axis of rotation resolved in frame_a (= same as in frame_b).
         n  must not necessarily be a unit vector. E.g.,
            n = {0, 0, 1} or n = {1, 0, 1}
  q0   : Rotation angle offset in [deg].
         If q=q0, frame_a and frame_b are identical.
  R    : Radius of the screw in [m].
  slope: Slope of the screw in [deg].
         (relative distance = (q-q0)*R*tan( slope*pi/180 ))
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{1,0,0}</TD><TD>Screw axis resolved in frame_a and frame_b</TD></TR>
<TR><TD>R</TD><TD>0.01</TD><TD>Screw radius [m]</TD></TR>
<TR><TD>slope</TD><TD>1</TD><TD>Screw slope in [deg] (slope&gt;0)</TD></TR>
<TR><TD>q0</TD><TD>0</TD><TD>Screw axis angle offset in [deg]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Screw <font color="darkgreen">
  &quot;Screw joint (1 degree-of-freedom, used in spanning tree)&quot;</font> 
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>Interfaces.TreeJoint</A>;
  <font color="blue">parameter </font>Real n[3]={1,0,0} <font color="darkgreen">&quot;Screw axis resolved in frame_a and frame_b&quot;</font>;
  <font color="blue">parameter </font><A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Length"
>SI.Length</A> R=0.01 <font color="darkgreen">&quot;Screw radius&quot;</font>;
  <font color="blue">parameter </font>Real slope=1 <font color="darkgreen">&quot;Screw slope in [deg] (slope&gt;0)&quot;</font>;
  <font color="blue">parameter </font>Real q0=0 <font color="darkgreen">&quot;Screw axis angle offset in [deg]&quot;</font>;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> q(start=0, fixed=true);
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> qd(start=0, fixed=true);
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> qdd;
  Real nn[3];
  Real nt[3];
  Real sinq;
  Real cosq;
  Real ri;
  Real vaux[3];
  Real qq;
  <font color="darkgreen"></font>
  <A HREF="../../Modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a"
>Modelica.Mechanics.Rotational.Interfaces.Flange_a</A> axis;
  <A HREF="../../Modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b"
>Modelica.Mechanics.Rotational.Interfaces.Flange_b</A> bearing;
<font color="blue">equation </font>
  axis.phi = q;
  bearing.phi = 0;
  <font color="darkgreen"></font>
  <font color="darkgreen">// define states</font>
  qd = <font color="red">der</font>(q);
  qdd = <font color="red">der</font>(qd);
  <font color="darkgreen"></font>
  <font color="darkgreen">/*rotation matrix*/</font>
  nn = n/<font color="red">sqrt</font>(n*n);
  qq = q - q0*pi/180;
  sinq = <font color="red">sin</font>(qq);
  cosq = <font color="red">cos</font>(qq);
  S_rel = [nn]*<font color="red">transpose</font>([nn]) + (<font color="red">identity</font>(3) - [nn]*<font color="red">transpose</font>([nn]))*cosq - <font color="red">
    skew</font>(nn)*sinq;
  <font color="darkgreen"></font>
  <font color="darkgreen">/*other kinematic quantities*/</font>
  ri = R*<font color="red">tan</font>(slope*pi/180);
  nt = nn*ri;
  r_rela = nt*qq;
  v_rela = nt*qd;
  a_rela = nt*qdd;
  <font color="darkgreen"></font>
  w_rela = nn*qd;
  z_rela = nn*qdd;
  <font color="darkgreen"></font>
  <font color="darkgreen">/*Transform the kinematic quantities from frame_a to frame_b and the
 force and torque acting at frame_b to frame_a
 (= general equations of a &quot;TreeJoint&quot; specialized to this class).
*/</font>
  Sb = Sa*<font color="red">transpose</font>(S_rel);
  r0b = r0a + Sa*r_rela;
  <font color="darkgreen"></font>
  vaux = <font color="red">cross</font>(wa, r_rela);
  vb = S_rel*(va + v_rela + vaux);
  wb = S_rel*(wa + w_rela);
  <font color="darkgreen"></font>
  ab = S_rel*(aa + a_rela + <font color="red">cross</font>(za, r_rela) + <font color="red">cross</font>(wa, vaux + 2*v_rela));
  zb = S_rel*(za + z_rela + <font color="red">cross</font>(wa, w_rela));
  <font color="darkgreen"></font>
  fa = <font color="red">transpose</font>(S_rel)*fb;
  ta = <font color="red">transpose</font>(S_rel)*tb + <font color="red">cross</font>(r_rela, fa);
  <font color="darkgreen"></font>
  <font color="darkgreen">// d'Alemberts principle</font>
  axis.tau = nn*tb + nt*fb;
<font color="blue">end </font>Screw;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.CylindricalI.png" ALT="ModelicaAdditions.MultiBody.Joints.Cylindrical" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Cylindrical"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Cylindrical</H2>
<B>Cylindrical joint (2 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.CylindricalD.png" ALT="ModelicaAdditions.MultiBody.Joints.Cylindrical">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a
and translates independently around the same axis.
The relative angle revolute.q [rad], the relative distance
prismatic.q [m], the relative angular velocity revolute.qd [rad/s]
and the relative velocity prismatic.qd [m/s] are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
  n    : Axis of cylindrical joint resolved in frame_a (= same as in frame_b).
         n  must not necessarily be a unit vector.
  qt0  : If revolute.q=qr0 and prismatic.q=qt0,
  qr0    frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{1,0,0}</TD><TD>Cylinder axis resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>qt0</TD><TD>0</TD><TD>Distance offset (see info) [m]</TD></TR>
<TR><TD>qr0</TD><TD>0</TD><TD>Rotation angle offset (see info) in [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Cylindrical <font color="darkgreen">
  &quot;Cylindrical joint (2 degrees-of-freedom, used in spanning tree)&quot;</font> 
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>Interfaces.TwoTreeFrames</A>;
  <font color="blue">parameter </font>Real n[3]={1,0,0} <font color="darkgreen">
    &quot;Cylinder axis resolved in frame_a (= same as in frame_b)&quot;</font>;
  <font color="blue">parameter </font><A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Position"
>SI.Position</A> qt0=0 <font color="darkgreen">&quot;Distance offset (see info)&quot;</font>;
  <font color="blue">parameter </font>Real qr0=0 <font color="darkgreen">&quot;Rotation angle offset (see info) in [deg]&quot;</font>;
  <font color="blue">parameter </font>Boolean startValueFixed=false <font color="darkgreen">
    &quot;true, if start values of q, qd are fixed&quot;</font>;
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
>Prismatic</A> prismatic(
    n=n, 
    q0=qt0, 
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>Revolute</A> revolute(
    n=n, 
    q0=qr0, 
    startValueFixed=startValueFixed);
<font color="blue">equation </font>
  <font color="red">connect</font>(frame_a, prismatic.frame_a);
  <font color="red">connect</font>(prismatic.frame_b, revolute.frame_a);
  <font color="red">connect</font>(revolute.frame_b, frame_b);
<font color="blue">end </font>Cylindrical;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.UniversalI.png" ALT="ModelicaAdditions.MultiBody.Joints.Universal" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Universal"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Universal</H2>
<B>Universal joint (2 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.UniversalD.png" ALT="ModelicaAdditions.MultiBody.Joints.Universal">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where frame_a rotates around axis nx which is fixed in frame_a
and at the same time rotates around axis ny which is fixed in frame_b.
The relative angles revolute1.q, revolute2.q [rad] and the relative
angular velocities revolute1.qd, revolute2.qd [rad/s] are used as
state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  nx : Axis of rotation 1 resolved in frame_a.
       nx must not necessarily be a unit vector. E.g.,
          nx = {0, 0, 1} or nx = {1, 0, 1}
  ny : Axis of rotation 2 resolved in frame_b.
       ny must not necessarily be a unit vector. E.g.,
          ny = {0, 0, 1} or ny = {1, 0, 1}
  qx0: Rotation angle offset 1 in [deg].
  qy0: Rotation angle offset 2 in [deg].
       If revolute1.q=qx0 and revolute2.q=qy0,
       frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<pre>

</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>nx[3]</TD><TD>{1,0,0}</TD><TD>Axis of revolute joint 1 resolved in frame_a</TD></TR>
<TR><TD>ny[3]</TD><TD>{0,1,0}</TD><TD>Axis of revolute joint 2 resolved in frame_b</TD></TR>
<TR><TD>qx0</TD><TD>0</TD><TD>Rotation angle offset in direction of nx (see info) in [deg]</TD></TR>
<TR><TD>qy0</TD><TD>0</TD><TD>Rotation angle offset in direction of ny (see info) in [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Universal <font color="darkgreen">
  &quot;Universal joint (2 degrees-of-freedom, used in spanning tree)&quot;</font> 
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>Interfaces.TwoTreeFrames</A>;
  <font color="blue">parameter </font>Real nx[3]={1,0,0} <font color="darkgreen">&quot;Axis of revolute joint 1 resolved in frame_a&quot;</font>;
  <font color="blue">parameter </font>Real ny[3]={0,1,0} <font color="darkgreen">&quot;Axis of revolute joint 2 resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>Real qx0=0 <font color="darkgreen">
    &quot;Rotation angle offset in direction of nx (see info) in [deg]&quot;</font>;
  <font color="blue">parameter </font>Real qy0=0 <font color="darkgreen">
    &quot;Rotation angle offset in direction of ny (see info) in [deg]&quot;</font>;
  <font color="blue">parameter </font>Boolean startValueFixed=false <font color="darkgreen">
    &quot;true, if start values of q, qd are fixed&quot;</font>;
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>Revolute</A> revolute1(
    n=nx, 
    q0=qx0, 
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>Revolute</A> revolute2(
    n=ny, 
    q0=qy0, 
    startValueFixed=startValueFixed);
<font color="blue">equation </font>
  <font color="red">connect</font>(frame_a, revolute1.frame_a);
  <font color="red">connect</font>(revolute2.frame_b, frame_b);
  <font color="red">connect</font>(revolute1.frame_b, revolute2.frame_a);
<font color="blue">end </font>Universal;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.PlanarI.png" ALT="ModelicaAdditions.MultiBody.Joints.Planar" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Planar"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Planar</H2>
<B>Planar joint (3 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.PlanarD.png" ALT="ModelicaAdditions.MultiBody.Joints.Planar">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where frame_b can move in a plane and can rotation around an
axis perpendicular to the plane. The plane is defined by
vector n which is perpendicular to the plane and by vector nx,
which points in the direction of the x-axis of the plane.
The relative distances prismatic1.q, prismatic2.q [m] and
the relative rotation angle revolute.q [rad], as well as
the relative velocities prismatic1.qd, prismatic1.qd [m/s],
and the relative angular velocity revolute.qd [rad/s]
are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
  n    : Axis perpendicular to plane resolved in frame_a (= same as in frame_b)
         n must not necessarily be a unit vector. E.g.,
            n = {0, 0, 1} or n = {1, 0, 1}
  qx0  : If prismatic1.q0=qx0, prismatic2.q0=qy0 and
  qy0    revolute.q=qr0, frame_a and frame_b are identical.
  qr0
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{0,0,1}</TD><TD>Axis perpendicular to plane resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>nx[3]</TD><TD>{1,0,0}</TD><TD>x-translation axis resolved in frame_a</TD></TR>
<TR><TD>qx0</TD><TD>0</TD><TD>Distance offset in nx direction (see info) [m]</TD></TR>
<TR><TD>qy0</TD><TD>0</TD><TD>Distance offset in ny direction (see info) [m]</TD></TR>
<TR><TD>qr0</TD><TD>0</TD><TD>Rotation angle offset (see info) in [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Planar <font color="darkgreen">
  &quot;Planar joint (3 degrees-of-freedom, used in spanning tree)&quot;</font> 
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>Interfaces.TwoTreeFrames</A>;
  <font color="blue">parameter </font>Real n[3]={0,0,1} <font color="darkgreen">
    &quot;Axis perpendicular to plane resolved in frame_a (= same as in frame_b)&quot;</font>;
  <font color="blue">parameter </font>Real nx[3]={1,0,0} <font color="darkgreen">&quot;x-translation axis resolved in frame_a&quot;</font>;
  <font color="blue">parameter </font><A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Position"
>SI.Position</A> qx0=0 <font color="darkgreen">&quot;Distance offset in nx direction (see info)&quot;</font>;
  <font color="blue">parameter </font><A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Position"
>SI.Position</A> qy0=0 <font color="darkgreen">&quot;Distance offset in ny direction (see info)&quot;</font>;
  <font color="blue">parameter </font>Real qr0=0 <font color="darkgreen">&quot;Rotation angle offset (see info) in [deg]&quot;</font>;
  <font color="blue">parameter </font>Boolean startValueFixed=false <font color="darkgreen">
    &quot;true, if start values of q, qd are fixed&quot;</font>;
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
>Prismatic</A> prismatic1(
    n=(<font color="red">cross</font>(<font color="red">cross</font>(n, nx), n)), 
    q0=qx0, 
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
>Prismatic</A> prismatic2(
    n=(<font color="red">cross</font>(n, nx)), 
    q0=qy0, 
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>Revolute</A> revolute(
    n=n, 
    q0=qr0, 
    startValueFixed=startValueFixed);
<font color="blue">equation </font>
  <font color="red">connect</font>(frame_a, prismatic1.frame_a);
  <font color="red">connect</font>(prismatic1.frame_b, prismatic2.frame_a);
  <font color="red">connect</font>(prismatic2.frame_b, revolute.frame_a);
  <font color="red">connect</font>(revolute.frame_b, frame_b);
<font color="blue">end </font>Planar;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.SphericalI.png" ALT="ModelicaAdditions.MultiBody.Joints.Spherical" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Spherical"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Spherical</H2>
<B>Spherical joint described by three Cardan angles (3 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.SphericalD.png" ALT="ModelicaAdditions.MultiBody.Joints.Spherical">
<H3>Information</H3>
<PRE></pre>
<p>
Joint where the origins of frame_a and frame_b always coincide, and
the frames are rotating against each other. The joint is realized in
such a way, that a singularity cannot occur. This is achieved because
the Cardan angles are defined between a frame_fix fixed in frame_a and
frame_b. Whenever the Cardan angles are near a singularity, the
integration is stopped and frame_fix is changed, such that the Cardan
angles are far away from the singularity. The following state
variables are used:
</p>

<pre>
  phi[3]   : Cardan angles, also called Tait-Bryan angles, i.e.,
             rotate around 1-, 2-, 3-axis in [rad] from intermediate
             frame_fix, which is fixed in frame_a, to frame_b. Initially, frame_fix
             is identical to frame_a. If phi[2] is near its singularity (= pi/2 or -pi/2),
             the frame_fix and phi are changed, such that phi[2] is far away from
             its singularity.
  w_rela[3]: Relative angular velocity of frame_b with respect to frame_a
             resolved in frame_a in [rad/s].
</pre>
<pre>
</PRE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Spherical <font color="darkgreen">
  &quot;Spherical joint described by three Cardan angles (3 degrees-of-freedom, used in spanning tree)&quot;</font>
   
  <font color="darkgreen"></font>
  <font color="blue">import </font><A HREF="../../Modelica/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.*;
  <font color="darkgreen"></font>
  <font color="darkgreen">// S_rel needs a correct start value, because pre(S_rel) is referenced below</font>
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>Interfaces.TreeJoint</A>(S_rel(start=<font color="red">identity</font>(3)));
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi[3](fixed={true,true,true}) <font color="darkgreen">
    &quot;Cardan angles from a frame fixed in frame_a to frame_b&quot;</font>;
  <font color="darkgreen"></font>
<font color="blue">protected </font>
  <font color="blue">constant </font>Real phi2_critical_deg=80 <font color="darkgreen">
    &quot;angle in [deg] too close to singularity. Redefine S_fix and phi&quot;</font>;
  <font color="blue">constant </font>Real phi2_critical=phi2_critical_deg*Modelica.Constants.pi/180.0;
  <font color="blue">constant </font>Real c2_small=1.e-5 <font color="darkgreen">
    &quot;if cos(phi[2]) &lt; c2_small, c2_small is used as guard against zero division&quot;</font>
    ;
  Real s1;
  Real s2;
  Real s3;
  Real c1;
  Real c2;
  Real c2a;
  Real c3;
  Boolean switch_state;
  Real S_phi[3, 3] <font color="darkgreen">&quot;S_rel = S_phi(phi)*S_fix&quot;</font>;
  Real S_fix[3, 3](start=<font color="red">identity</font>(3)) <font color="darkgreen">&quot;S_rel = S_phi(phi)*S_fix&quot;</font>;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_fix[3] <font color="darkgreen">
    &quot;Relative angular velocity resolved in intermediate frame S_fix&quot;</font>;
<font color="blue">equation </font>
  <font color="darkgreen">/* Determine sines and cosines of the Cardan angles */</font>
  s1 = <font color="red">sin</font>(phi[1]);
  s2 = <font color="red">sin</font>(phi[2]);
  s3 = <font color="red">sin</font>(phi[3]);
  c1 = <font color="red">cos</font>(phi[1]);
  c2a = <font color="red">cos</font>(phi[2]);
  c3 = <font color="red">cos</font>(phi[3]);
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Below, some expressions are divided by c2. By construction, it is not possible
     that c2=0, during continuous simulation. However, at initial time and when
     large numerical errors occur, c2=0 is possible, which would result in a division
     by zero. The following statement is a guard against this unlikely situation.
  */</font>
  c2 = <font color="blue">if </font><font color="red">noEvent</font>(c2a &gt; c2_small<font color="blue"> or </font>c2a &lt; -c2_small)<font color="blue"> then </font>c2a<font color="blue"> else </font><font color="blue">if </font><font color="red">noEvent</font>(
    c2a &gt;= 0)<font color="blue"> then </font>c2_small<font color="blue"> else </font>-c2_small;
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Relative transformation matrix
       S_phi = [ c3, s3, 0;
                -s3, c3, 0;
                  0, 0, 1]*[c2, 0, -s2;
                             0, 1, 0;
                            s2, 0, c2]*[1, 0, 0;
                                        0, c1, s1;
                                        0, -s1, c1];
  */</font>
  switch_state = phi[2] &gt;= phi2_critical<font color="blue"> or </font>phi[2] &lt;= -phi2_critical;
  <font color="blue">when </font>switch_state<font color="blue"> then</font>
    S_fix = <font color="red">pre</font>(S_rel);
    <font color="red">reinit</font>(phi, <font color="red">zeros</font>(3));
  <font color="blue">end when</font>;
  S_phi = [c2*c3, c1*s3 + s1*s2*c3, s1*s3 - c1*s2*c3; -c2*s3, c1*c3 - s1*s2*s3
    , s1*c3 + c1*s2*s3; s2, -s1*c2, c1*c2];
  S_rel = S_phi*S_fix;
  <font color="darkgreen"></font>
  <font color="darkgreen">// No translational movement</font>
  r_rela = <font color="red">zeros</font>(3);
  v_rela = <font color="red">zeros</font>(3);
  a_rela = <font color="red">zeros</font>(3);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Kinematic differential equations for rotational motion</font>
  w_fix = S_fix*w_rela;
  <font color="red">der</font>(phi) = {w_fix[1] + (s1*w_fix[2] - c1*w_fix[3])*s2/c2,c1*w_fix[2] + s1*
    w_fix[3],(-s1*w_fix[2] + c1*w_fix[3])/c2};
  <font color="red">der</font>(w_rela) = z_rela;
  <font color="darkgreen"></font>
  <font color="darkgreen">// Kinematic relationships</font>
  frame_b.S = frame_a.S*<font color="red">transpose</font>(S_rel);
  frame_b.r0 = frame_a.r0;
  <font color="darkgreen"></font>
  frame_b.v = S_rel*frame_a.v;
  frame_b.w = S_rel*(frame_a.w + w_rela);
  <font color="darkgreen"></font>
  frame_b.a = S_rel*frame_a.a;
  frame_b.z = S_rel*(frame_a.z + <font color="red">cross</font>(frame_a.w, w_rela) + z_rela);
  <font color="darkgreen"></font>
  <font color="darkgreen">// cut-torques are zero</font>
  frame_a.f = -<font color="red">transpose</font>(S_rel)*frame_b.f;
  frame_a.t = <font color="red">zeros</font>(3);
  frame_b.t = <font color="red">zeros</font>(3);
<font color="blue">end </font>Spherical;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.FreeMotionI.png" ALT="ModelicaAdditions.MultiBody.Joints.FreeMotion" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.FreeMotion"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.FreeMotion</H2>
<B>Free motion joint (6 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.FreeMotionD.png" ALT="ModelicaAdditions.MultiBody.Joints.FreeMotion">
<H3>Information</H3>
<PRE></pre>
<p>
Joint which does not constrain the motion between frame_a and frame_b.
Such a joint is just used to define the desired states to be used.
The joint is realized in
such a way, that a singularity cannot occur. This is achieved because
the Cardan angles are defined between a frame_fix fixed in frame_a and
frame_b. Whenever the Cardan angles are near a singularity, the
integration is stopped and frame_fix is changed, such that the Cardan
angles are far away from the singularity. The following state
variables are used:
</p>

<pre>
  r_rela[3]: Distance vector from the origin of frame_a to the origin
             of frame_b, resolved in frame_a in [m].
  phi[3]   : Cardan angles, also called Tait-Bryan angles, i.e.,
             rotate around 1-, 2-, 3-axis in [rad] from intermediate
             frame_fix, which is fixed in frame_a, to frame_b. Initially, frame_fix
             is identical to frame_a. If phi[2] is near its singularity (= pi/2 or -pi/2),
             the frame_fix and phi are changed, such that phi[2] is far away from
             its singularity.
  v_rela[3]: = der(r_rela); relative velocity of frame_b with respect to frame_a
             resolved in frame_a in [m/s].
  w_rela[3]: Relative angular velocity of frame_b with respect to frame_a
             resolved in frame_a in [rad/s].
</pre>
<pre>
</PRE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> FreeMotion <font color="darkgreen">
  &quot;Free motion joint (6 degrees-of-freedom, used in spanning tree)&quot;</font> 
  <font color="darkgreen"></font>
  <font color="blue">import </font><A HREF="../../Modelica/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.*;
  <font color="darkgreen"></font>
  <font color="darkgreen">// S_rel needs a correct start value, because pre(S_rel) is referenced below</font>
  <font color="blue">extends </font><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>Interfaces.TreeJoint</A>(S_rel(start=<font color="red">identity</font>(3)));
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi[3] <font color="darkgreen">&quot;Cardan angles from a frame fixed in frame_a to frame_b&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">constant </font>Real phi2_critical_deg=80 <font color="darkgreen">
    &quot;angle in [deg] too close to singularity. Redefine S_fix and phi&quot;</font>;
  <font color="blue">constant </font>Real phi2_critical=phi2_critical_deg*Modelica.Constants.pi/180.0;
  <font color="blue">constant </font>Real c2_small=1.e-5 <font color="darkgreen">
    &quot;if cos(phi[2]) &lt; c2_small, c2_small is used as guard against zero division&quot;</font>
    ;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.Velocity"
>SI.Velocity</A> vaux[3];
  Real s1;
  Real s2;
  Real s3;
  Real c1;
  Real c2;
  Real c2a;
  Real c3;
  Boolean switch_state;
  Real S_phi[3, 3] <font color="darkgreen">&quot;S_rel = S_phi(phi)*S_fix&quot;</font>;
  Real S_fix[3, 3](start=<font color="red">identity</font>(3)) <font color="darkgreen">&quot;S_rel = S_phi(phi)*S_fix&quot;</font>;
  <A HREF="../../Modelica/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_fix[3] <font color="darkgreen">
    &quot;Relative angular velocity resolved in intermediate frame S_fix&quot;</font>;
  <font color="darkgreen"></font>
<font color="blue">equation </font>
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Determine sines and cosines of the Cardan angles */</font>
  s1 = <font color="red">sin</font>(phi[1]);
  s2 = <font color="red">sin</font>(phi[2]);
  s3 = <font color="red">sin</font>(phi[3]);
  c1 = <font color="red">cos</font>(phi[1]);
  c2a = <font color="red">cos</font>(phi[2]);
  c3 = <font color="red">cos</font>(phi[3]);
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Below, some expressions are divided by c2. By construction, it is not possible
     that c2=0, during continuous simulation. However, at initial time and when
     large numerical errors occur, c2=0 is possible, which would result in a division
     by zero. The following statement is a guard against this unlikely situation.
  */</font>
  c2 = <font color="blue">if </font><font color="red">noEvent</font>(c2a &gt; c2_small<font color="blue"> or </font>c2a &lt; -c2_small)<font color="blue"> then </font>c2a<font color="blue"> else </font><font color="blue">if </font><font color="red">noEvent</font>(
    c2a &gt;= 0)<font color="blue"> then </font>c2_small<font color="blue"> else </font>-c2_small;
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Relative transformation matrix
       S_phi = [ c3, s3, 0;
                -s3, c3, 0;
                  0, 0, 1]*[c2, 0, -s2;
                             0, 1, 0;
                            s2, 0, c2]*[1, 0, 0;
                                        0, c1, s1;
                                        0, -s1, c1];
  */</font>
  switch_state = phi[2] &gt;= phi2_critical<font color="blue"> or </font>phi[2] &lt;= -phi2_critical;
  <font color="blue">when </font>switch_state<font color="blue"> then</font>
    S_fix = <font color="red">pre</font>(S_rel);
    <font color="red">reinit</font>(phi, <font color="red">zeros</font>(3));
  <font color="blue">end when</font>;
  S_phi = [c2*c3, c1*s3 + s1*s2*c3, s1*s3 - c1*s2*c3; -c2*s3, c1*c3 - s1*s2*s3
    , s1*c3 + c1*s2*s3; s2, -s1*c2, c1*c2];
  S_rel = S_phi*S_fix;
  <font color="darkgreen"></font>
  <font color="darkgreen">// Kinematic differential equations for translational motion</font>
  <font color="red">der</font>(r_rela) = v_rela;
  <font color="red">der</font>(v_rela) = a_rela;
  <font color="darkgreen"></font>
  <font color="darkgreen">// Kinematic differential equations for rotational motion</font>
  w_fix = S_fix*w_rela;
  <font color="red">der</font>(phi) = {w_fix[1] + (s1*w_fix[2] - c1*w_fix[3])*s2/c2,c1*w_fix[2] + s1*
    w_fix[3],(-s1*w_fix[2] + c1*w_fix[3])/c2};
  <font color="red">der</font>(w_rela) = z_rela;
  <font color="darkgreen"></font>
  <font color="darkgreen">// Kinematic relationships</font>
  frame_b.S = frame_a.S*<font color="red">transpose</font>(S_rel);
  frame_b.r0 = frame_a.r0 + frame_a.S*r_rela;
  <font color="darkgreen"></font>
  vaux = <font color="red">cross</font>(frame_a.w, r_rela);
  frame_b.v = S_rel*(frame_a.v + v_rela + vaux);
  frame_b.w = S_rel*(frame_a.w + w_rela);
  <font color="darkgreen"></font>
  frame_b.a = S_rel*(frame_a.a + <font color="red">cross</font>(frame_a.z, r_rela) + <font color="red">cross</font>(frame_a.w, 
    vaux + 2*v_rela) + a_rela);
  frame_b.z = S_rel*(frame_a.z + <font color="red">cross</font>(frame_a.w, w_rela) + z_rela);
  <font color="darkgreen"></font>
  <font color="darkgreen">// cut-forces and cut-torques are zero</font>
  frame_a.f = <font color="red">zeros</font>(3);
  frame_a.t = <font color="red">zeros</font>(3);
  frame_b.f = <font color="red">zeros</font>(3);
  frame_b.t = <font color="red">zeros</font>(3);
<font color="blue">end </font>FreeMotion;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Tue Dec 10 16:33:55 2002
.
</address></BODY>
</HTML>
