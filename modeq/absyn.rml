(* absyn.rml *)

module Absyn:

  with "exp.rml"
  with "types.rml"

  type Ident = Exp.Ident
  type Path = Exp.Path
  type Subscript = Exp.Subscript
  type ArrayDim = Types.ArrayDim
  type ClassRestriction = Types.Restriction

  datatype ElementArg = MODIFICATION of bool * Path * Modification
		      | REDECLARATION of bool * ElementSpec

  and	   Modification = CLASSMOD of ElementArg list * Exp.Exp option

  and	   Component = COMPONENT of Ident	(* component name *)
				  * ArrayDim
				  * Modification option

  and	   ElementSpec = CLASSDEF of bool		(* replaceable *)
				   * Class
		       | EXTENDS of Path * ElementArg list
		       | COMPONENTS of Types.VarAttr
				     * Path	(* type name *)
				     * Component list

  and	   Element = ELEMENT of bool		(* final *)
			      * Ident
			      * ElementSpec

  and	   Class = CLASS of Ident             (* Name *)
			  * bool			(* Partial *)
			  * ClassRestriction      (* Restricion *)
			  * ClassDef		(* Parts *)

  and	   ClassDef = PARTS of ClassPart list
		    | DERIVED of Path
			       * ArrayDim option
			       * ElementArg list

  and	   ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list

  and	   Equation = EQ_EXPR of Exp.Exp (* more later *)
		    | EQ_EQUALS of Exp.Exp * Exp.Exp
		    | EQ_CONNECT of Exp.ComponentRef * Exp.ComponentRef

  and	   Algorithm = ALGORITHM (* Fill in later *)

  type Program = Class list

  relation element_spec_name : ElementSpec => Ident

end

(**********************************************************************)

relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,[COMPONENT(n,_,_)]) => n

  rule  print "# element_spec_name EXTENDS\n"
	-------------------------------------
	element_spec_name EXTENDS(_,_) => fail

end
