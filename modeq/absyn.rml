(**
 ** file:	 absyn.rml
 ** description: Abstract syntax
 **
 ** RCS: $Id$
 **
 ** This file defines the abstract syntax for Modelica.
 **)

module Absyn:

  type Ident = string

  (** - Programs *)
  type Program = Class list
  (** A program is simply a list of class definitions declared at top
   ** level in the source file.
   **)

  (** - Classes *)
  datatype Class = CLASS of Ident		     (* Name *)
			  * bool		     (* Partial *)
			  (* FIXME: final *)
			  * Restriction	             (* Restricion *)
			  * ClassDef		     (* Body *)
  (** A class definition consists of a name, a flag to indicate if this *)
  (** class is declared as `partial', the declared class restriction, *)
  (** and the body of the declaration. *)


  datatype ClassDef = PARTS of ClassPart list
		    | DERIVED of Path
			       * ArrayDim option
			       * ElementArg list
  (** The `ClassDef' type contains the definition part of a class *)
  (** declaration.  The definition is either explicit, with a list of *)
  (** parts (`public', `protected', `equation' and `algorithm'), or it *)
  (** is a definition derived from another class.  In the latter case *)
  (** this types contains the name of the derived class and an optional *)
  (** array dimension and a list of modifications. *)

  datatype ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list
  (** A class definition contains several parts.  There are public and *)
  (** protected component declarations, type definitions and `extends' *)
  (** clauses, collectively called elements.  There are also equation *)
  (** sections and algorithm sections. *)

  (** - Elements *)
  datatype Element = ELEMENT of bool		     (* final *)
			      * Ident
			      * ElementSpec

  datatype ElementSpec = CLASSDEF of bool	     (* replaceable *)
				   * Class
		       | EXTENDS of Path * ElementArg list
		       | COMPONENTS of VarAttr
				     * Path	     (* type name *)
				     * Component list
  (** An element is something that occurs in a public or protected *)
  (** section in a class definition.  There is one constructor in the *)
  (** `ElementSpec' type for each possible element type.  There are *)
  (** class definitions (`CLASSDEF'), `extends' clauses (`EXTENDS') *)
  (** and component declarations (`COMPONENTS'). *)

  datatype Component = COMPONENT of Ident	     (* component name *)
				  * ArrayDim
				  * Modification option
  (** Several component declarations can be grouped together in one *)
  (** `ElementSpec' by writing them on the same line in the source. *)
  (** This type contains the information specific to one component. *)

  datatype Equation = EQ_EXPR of Exp	     (* more later? *)
		    | EQ_IF of Exp
			     * Equation list	     (* true branch *)  
			     * (Exp * Equation list) list (* elseif branches *)
			     * Equation list	     (* else branch *)
		    | EQ_EQUALS of Exp * Exp
		    | EQ_CONNECT of ComponentRef * ComponentRef
		    | EQ_FOR of Ident * Exp * Equation list
  (** The `Equation' type describes one equation in an equation *)
  (** section. *)

  datatype Algorithm = ALG_ASSIGN of ComponentRef * Exp
		     | ALG_IF of Exp
			       * Algorithm list	     (* true branch *)  
			       * (Exp * Algorithm list) list (* elseif *)
			       * Algorithm list	     (* else branch *)
		     | ALG_FOR of Ident * Exp * Algorithm list
		     | ALG_WHILE of Exp * Algorithm list
		     | ALG_WHEN of Exp * Algorithm list
  (** The `Algorithm' type describes one algorithm statement in an *)
  (** algorithm section.  It does not describe a whole algorithm.  The *)
  (** reason this type is named like this is that the name of the *)
  (** grammar rule for algorithm statements is `algorithm'. *)

  (** - Modifications *)
  datatype Modification = CLASSMOD of ElementArg list * Exp option

  datatype ElementArg = MODIFICATION of bool * ComponentRef * Modification
		      | REDECLARATION of bool * ElementSpec
  (** Modifications are described by the `Modification' type. *)

  (** - Variable attributes *)
  datatype VarAttr = ATTR of ArrayDim
			   * bool	(* flow *)
			   * VarType	(* parameter *)
			   * Direction
  datatype VarType = VAR | DISCRETE | PARAM | CONST
  datatype Direction = INPUT | OUTPUT | BIDIR

  (** - Array dimensions *)
  type ArrayDim = Subscript list
  (** Variables in Modelica can be scalar or arrays with one or more *)
  (** dimensions. This datatype is used to indicate the dimensionality *)
  (** of a variable or a type definition. *)

  (** - Expressions *)

  datatype Exp = INTEGER of int
	       | REAL of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       | BINARY of Exp * Operator * Exp
	       | UNARY of Operator * Exp
	       | LBINARY of Exp * Operator * Exp
	       | LUNARY of Operator * Exp
	       | RELATION of Exp * Operator * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of ComponentRef * Exp list
	       (* | ARRAY of Exp list *)
	       | MATRIX of Exp list list
	       | RANGE of Exp * Exp option * Exp
  (** The `Exp' datatype is the container of a Modelica expression. *)

  datatype Operator = ADD   | SUB    | MUL     | DIV       | POW
		    | UPLUS | UMINUS
		    | AND   | OR
		    | NOT
		    | LESS  | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  (** - Subscripts *)
  datatype Subscript = NOSUB
		     | SUBSCRIPT of Exp
  (** The `Subscript' datatype is used both in array declarations and *)
  (** variable references. *)

  (** - Component references and paths *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Path = QUALIFIED of Ident * Path
	      	| IDENT of Ident
  (** A component reference is the fully or partially qualified name of *)
  (** a component (variable).  It is represented as a list of *)
  (** identifier--subscript pairs.  The type `Path', on the other hand, *)
  (** is used to store references to class names, or components inside *)
  (** class definitions. *)
	      	
  (** - Restrictions *)
  datatype Restriction = R_CLASS
		       | R_MODEL
		       | R_RECORD
		       | R_BLOCK
		       | R_CONNECTOR
		       | R_TYPE
		       | R_PACKAGE
		       | R_FUNCTION
		       | R_PREDEFINED_INT
		       | R_PREDEFINED_REAL
		       | R_PREDEFINED_STRING
		       | R_PREDEFINED_BOOL
  (** These constructors each correspond to a different kind of class *)
  (** declaration in Modelica, except the last four, which are used *)
  (** for the predefined types.  The parser assignes each class *)
  (** declaration one of the restrictions, and the actual class *)
  (** definition is checked for conformance during translation.  The *)
  (** predefined types are created in the `Builtin' module and are *)
  (** assigned special restrictions. *)


  relation path_string : Path => string
  relation cref_to_path : ComponentRef => Path
  relation element_spec_name : ElementSpec => Ident
  relation print_restr : Restriction => ()

end

(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

(** relation: cref_to_path
 **
 ** This relation converts a `ComponentRef' to a `Path', if possible.
 ** If the component reference contains subscripts, it will silently
 ** fail.
 **)

relation cref_to_path : ComponentRef => Path =

  axiom	cref_to_path CREF_IDENT(i,[]) => IDENT(i)

  rule	cref_to_path c => p
	-------------------
	cref_to_path CREF_QUAL(i,[],c) => QUALIFIED(i,p)

end

(** relation: element_spec_name
 **)

relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,[COMPONENT(n,_,_)]) => n

  rule  print "# element_spec_name EXTENDS\n"
	-------------------------------------
	element_spec_name EXTENDS(_,_) => fail

end

(** relation: print_restr
 **
 ** This is a utility relation for printing a `Restriction'.  The code
 ** is excluded for brevity.
 **)

(*!ignorecode*)

relation print_restr : Restriction => () =

  rule	print "CLASS"
	-------------
	print_restr R_CLASS
	
  rule	print "MODEL"
	-------------
	print_restr R_MODEL
	
  rule	print "RECORD"
	--------------
	print_restr R_RECORD
	
  rule	print "BLOCK"
	-------------
	print_restr R_BLOCK
	
  rule	print "CONNECTOR"
	-----------------
	print_restr R_CONNECTOR
	
  rule	print "TYPE"
	------------
	print_restr R_TYPE
	
  rule	print "PACKAGE"
	---------------
	print_restr R_PACKAGE
	
  rule	print "FUNCTION"
	----------------
	print_restr R_FUNCTION

  rule	print "PREDEFINED_INT"
	----------------
	print_restr R_PREDEFINED_INT

  rule	print "PREDEFINED_REAL"
	----------------
	print_restr R_PREDEFINED_REAL

  rule	print "PREDEFINED_STRING"
	----------------
	print_restr R_PREDEFINED_STRING

  rule	print "PREDEFINED_BOOL"
	----------------
	print_restr R_PREDEFINED_BOOL

end
