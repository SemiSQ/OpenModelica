(**
 ** file:	 absyn.rml
 ** module:      Absyn
 ** description: Abstract syntax
 **
 ** RCS: $Id$
 **
 ** This file defines the abstract syntax for Modelica.  It mainly
 ** contains datatypes for constructing the abstract syntax tree
 ** (AST), and a few relations for printing the AST.
 **)



module Absyn:
  with "debug.rml"

  type Ident = string

  (** - Programs *)
  type Program = Class list
  (** A program is simply a list of class definitions declared at top
   ** level in the source file.
   **)

  (** - Classes *)
  datatype Class = CLASS of Ident		     (* Name *)
			  * bool		     (* Partial *)
			  * Restriction	             (* Restricion *)
			  * ClassDef		     (* Body *)
  (** A class definition consists of a name, a flag to indicate if this *)
  (** class is declared as `partial', the declared class restriction, *)
  (** and the body of the declaration. *)


  datatype ClassDef = PARTS of ClassPart list
		    | DERIVED of Path
			       * ArrayDim option
			       * ElementArg list
  (** The `ClassDef' type contains the definition part of a class *)
  (** declaration.  The definition is either explicit, with a list of *)
  (** parts (`public', `protected', `equation' and `algorithm'), or it *)
  (** is a definition derived from another class.  In the latter case *)
  (** this type contains the name of the derived class and an optional *)
  (** array dimension and a list of modifications. *)

  datatype ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list
  (** A class definition contains several parts.  There are public and *)
  (** protected component declarations, type definitions and `extends' *)
  (** clauses, collectively called elements.  There are also equation *)
  (** sections and algorithm sections. *)

  (** - Elements *)
  datatype Element = ELEMENT of bool		     (* final *)
			      * Ident
			      * ElementSpec

  datatype ElementSpec = CLASSDEF of bool	     (* replaceable *)
				   * Class
		       | EXTENDS of Path * ElementArg list
		       | COMPONENTS of ElementAttributes (*1.1 contains Araydim also.*)
				     * Path	     (* type name *)
				     * Component list
  (** An element is something that occurs in a public or protected
   ** section in a class definition.  There is one constructor in the
   ** `ElementSpec' type for each possible element type.  There are
   ** class definitions (`CLASSDEF'), `extends' clauses (`EXTENDS')
   ** and component declarations (`COMPONENTS').
   ** 
   ** As an example, if the element `extends TwoPin;' appears
   ** in the source, it is represented in the AST as
   ** `EXTENDS(IDENT("TwoPin"),[])'.
   **)

  datatype Component = COMPONENT of Ident 	     (* component name *)
				  * ArrayDim
				  * Modification option
  (** Several component declarations can be grouped together in one *)
  (** `ElementSpec' by writing them on the same line in the source. *)
  (** This type contains the information specific to one component. *)

  datatype Equation = EQ_EXPR of Exp	     (* more later? *)
		    | EQ_IF of Exp
			     * Equation list	     (* true branch *)  
			     * (Exp * Equation list) list (* elseif branches *)
			     * Equation list	     (* else branch *)
		    | EQ_EQUALS of Exp * Exp
		    | EQ_CONNECT of ComponentRef * ComponentRef
		    | EQ_FOR of Ident * Exp * Equation list
		    | EQ_WHEN_E of Exp * Equation list (*1.1*) 

  (** The `Equation' type describes one equation in an equation *)
  (** section. *)

  datatype Algorithm = ALG_ASSIGN of ComponentRef * Exp
		     | ALG_IF of Exp
			       * Algorithm list	     (* true branch *)  
			       * (Exp * Algorithm list) list (* elseif *)
			       * Algorithm list	     (* else branch *)
		    | ALG_FOR of Ident * Exp * Algorithm list
		    | ALG_WHILE of Exp * Algorithm list
		(* Old 1.0     | ALG_WHEN of Exp * Algorithm list  *)
		     | ALG_WHEN_A of Exp * Algorithm list (*1.1*)
  (** The `Algorithm' type describes one algorithm statement in an *)
  (** algorithm section.  It does not describe a whole algorithm.  The *)
  (** reason this type is named like this is that the name of the *)
  (** grammar rule for algorithm statements is `algorithm'. *)

  (** - Modifications *)
  datatype Modification = CLASSMOD of ElementArg list * Exp option

  datatype ElementArg = MODIFICATION of bool * ComponentRef * Modification
		      | REDECLARATION of bool * ElementSpec
  (** Modifications are described by the `Modification' type.  There *)
  (** are two forms of modifications: redeclarations and component *)
  (** modifications. *)

  (** - Component attributes *)
  datatype ElementAttributes = ATTR of bool	(* flow *)
			     	     * Variability	(* parameter *)
			     	     * Direction
				     * ArrayDim  (*1.1*)
     
  datatype Variability = VAR | DISCRETE | PARAM | CONST
  datatype Direction = INPUT | OUTPUT | BIDIR
  (** Component attributes are *)
  (** properties of components which are applied by type prefixes. *)
  (** As an example, declaring a component as `input Real x;' will *)
  (** give the attributes `ATTR([],false,VAR,INPUT)'. *)

  (** - Array dimensions *)
  type ArrayDim = Subscript list
  (** Components in Modelica can be scalar or arrays with one or more *)
  (** dimensions. This datatype is used to indicate the dimensionality *)
  (** of a component or a type definition. *)

  (** - Expressions *)

  datatype Exp = INTEGER of int
	       | REAL of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       | BINARY of Exp * Operator * Exp
	       | UNARY of Operator * Exp
	       | LBINARY of Exp * Operator * Exp
	       | LUNARY of Operator * Exp
	       | RELATION of Exp * Operator * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of ComponentRef * Exp list
(*	       | ARRAY of Exp list *)

(*P.R		ARRAY consists of an vector of the dimension sizes and an vector consiting of the vector data.*)	
	       | ARRAY of Exp list

	       | MATRIX of Exp list list
	       | RANGE of Exp * Exp option * Exp
	       | TUPLE of Exp list (*PR.*)

  (** The `Exp' datatype is the container of a Modelica expression. *)

  datatype Operator = ADD   | SUB    | MUL     | DIV       | POW
		    | UPLUS | UMINUS
		    | AND   | OR
		    | NOT
		    | LESS  | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  (** - Subscripts *)
  datatype Subscript = NOSUB
		     | SUBSCRIPT of Exp
  (** The `Subscript' datatype is used both in array declarations and *)
  (** component references.  This might seem strange, but it is *)
  (** inherited from the grammar.  The `NOSUB' constructor means that *)
  (** the dimension size is undefined when used in a declaration, and *)
  (** when it is used in a component reference it means a slice of the *)
  (** whole dimension. *)

  (** - Component references and paths *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Path = QUALIFIED of Ident * Path
	      	| IDENT of Ident
  (** A component reference is the fully or partially qualified name of *)
  (** a component.  It is represented as a list of *)
  (** identifier--subscript pairs.  The type `Path', on the other hand, *)
  (** is used to store references to class names, or names inside *)
  (** class definitions. *)
	      	
  (** - Restrictions *)
  datatype Restriction = R_CLASS
		       | R_MODEL
		       | R_RECORD
		       | R_BLOCK
		       | R_CONNECTOR
		       | R_TYPE
		       | R_PACKAGE
		       | R_FUNCTION
		       | R_PREDEFINED_INT
		       | R_PREDEFINED_REAL
		       | R_PREDEFINED_STRING
		       | R_PREDEFINED_BOOL
  (** These constructors each correspond to a different kind of class *)
  (** declaration in Modelica, except the last four, which are used *)
  (** for the predefined types.  The parser assigns each class *)
  (** declaration one of the restrictions, and the actual class *)
  (** definition is checked for conformance during translation.  The *)
  (** predefined types are created in the `Builtin' module and are *)
  (** assigned special restrictions. *)


  relation path_string : Path => string
  relation cref_to_path : ComponentRef => Path
  relation element_spec_name : ElementSpec => Ident
  relation print_restr : Restriction => ()
  relation restr_string : Restriction => string
  relation print_absyn_exp : Exp => ()  (*PR. for debugging.*)
end

(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

(** relation: cref_to_path
 **
 ** This relation converts a `ComponentRef' to a `Path', if possible.
 ** If the component reference contains subscripts, it will silently
 ** fail.
 **)

relation cref_to_path : ComponentRef => Path =

  axiom	cref_to_path CREF_IDENT(i,[]) => IDENT(i)

  rule	cref_to_path c => p
	-------------------
	cref_to_path CREF_QUAL(i,[],c) => QUALIFIED(i,p)

end

(** relation: element_spec_name
 **
 ** The `ElementSpec' type contans the name of the element, and this
 ** relation extracts this name.
 **)

relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,[COMPONENT(n,_,_)]) => n

  rule  print "# element_spec_name EXTENDS\n"
	-------------------------------------
	element_spec_name EXTENDS(_,_) => fail

end

(** relation: print_restr
 **
 ** This is a utility relation for printing a `Restriction'.  The code
 ** is excluded for brevity.
 **)

(*!ignorecode*)

relation restr_string : Restriction => string =

  axiom restr_string R_CLASS			=> "CLASS"
  axiom	restr_string R_MODEL			=> "MODEL"
  axiom	restr_string R_RECORD			=> "RECORD"
  axiom restr_string R_BLOCK			=> "BLOCK"
  axiom restr_string R_CONNECTOR		=> "CONNECTOR"
  axiom restr_string R_TYPE			=> "TYPE"
  axiom restr_string R_PACKAGE			=> "PACKAGE"
  axiom restr_string R_FUNCTION			=> "FUNCTION"
  axiom restr_string R_PREDEFINED_INT		=> "PREDEFINED_INT"
  axiom restr_string R_PREDEFINED_REAL		=> "PREDEFINED_REAL"
  axiom restr_string R_PREDEFINED_STRING	=> "PREDEFINED_STRING"
  axiom restr_string R_PREDEFINED_BOOL		=> "PREDEFINED_BOOL"

end

relation print_restr : Restriction => () =

  rule	restr_string restr => str &
	print str
	----------------
	print_restr restr

end


(* PR. To debug. *)
relation print_absyn_exp : Exp => () =
  rule	Debug.print "This is an array: " &
	Debug.print "[" &

	Debug.print "]"
	---------
	print_absyn_exp (ARRAY(es))

	(*PR.*)
  rule	Debug.print "(" &

	Debug.print ")"
	---------
	print_absyn_exp (TUPLE(es))


  rule	Debug.print "\nNo tuple." 
	---------
	print_absyn_exp (_)

	
end
