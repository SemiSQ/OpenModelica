(** file: absyn.rml
 **
 ** This file defines the abstract syntax for Modelica. It uses data
 ** types from the `Exp' and `Types' modules.  Each type is described
 ** below.
 **)

module Absyn:

  with "exp.rml"
  with "types.rml"

(** These types are imported from other modules and given unqualified *)
(** names to help the readibility, and for backwards compatibility *)
(** with older versions.  This should be changed. *)

  type Ident = Exp.Ident
  type Path = Exp.Path
  type Subscript = Exp.Subscript
  type ClassRestriction = Types.Restriction

(**  Types
 **
 ** A program is simply a list of class definitions declared at top
 ** level in the source file.
 **)

  type Program = Class list

(** A class definition consists of a name, a flag to indicate if this *)
(** class is declared as `partial', the declared class restriction, *)
(** and the body of the declaration. *)

  datatype Class = CLASS of Ident		     (* Name *)
			  * bool		     (* Partial *)
			  (* FIXME: final *)
			  * ClassRestriction	     (* Restricion *)
			  * ClassDef		     (* Body *)

(** The `ClassDef' type contains the definition part of a class *)
(** declaration.  The definition is either explicit, with a list of *)
(** parts (`public', `protected', `equation' and `algorithm'), or it *)
(** is a definition derived from another class.  In the latter case *)
(** this types contains the name of the derived class and an optional *)
(** array dimension and a list of modifications. *)

  datatype ClassDef = PARTS of ClassPart list
		    | DERIVED of Path
			       * Types.ArrayDim option
			       * ElementArg list

  datatype ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list

  datatype Element = ELEMENT of bool		     (* final *)
			      * Ident
			      * ElementSpec

  datatype ElementSpec = CLASSDEF of bool	     (* replaceable *)
				   * Class
		       | EXTENDS of Path * ElementArg list
		       | COMPONENTS of Types.VarAttr
				     * Path	     (* type name *)
				     * Component list

  datatype Component = COMPONENT of Ident	     (* component name *)
				  * Types.ArrayDim
				  * Modification option

  datatype Equation = EQ_EXPR of Exp.Exp	     (* more later? *)
		    | EQ_EQUALS of Exp.Exp * Exp.Exp
		    | EQ_CONNECT of Exp.ComponentRef * Exp.ComponentRef

  datatype Algorithm = ALGORITHM		     (* FIXME *)

  datatype Modification = CLASSMOD of ElementArg list * Exp.Exp option

  datatype ElementArg = MODIFICATION of bool * Path * Modification
		      | REDECLARATION of bool * ElementSpec

  relation element_spec_name : ElementSpec => Ident

end

(** relation: element_spec_name
 **)

relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,[COMPONENT(n,_,_)]) => n

  rule  print "# element_spec_name EXTENDS\n"
	-------------------------------------
	element_spec_name EXTENDS(_,_) => fail

end
