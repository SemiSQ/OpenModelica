(**
 ** file:	 algorithm.rml
 ** description: Algorithm datatypes
 **
 ** RCS: $Id$
 **
 **)

module Algorithm:

  with "exp.rml"
  with "types.rml"
  with "staticexp.rml"

  type Ident = string

  datatype Algorithm = ALGORITHM of Statement list

  datatype Statement = ASSIGN of Exp.ComponentRef * Exp.Exp
		     | IF of Exp.Exp * Statement list * Else
		     | FOR of Ident * Exp.Exp * Statement list
		     | WHILE of Exp.Exp * Statement list
		     | WHEN of Exp.Exp * Statement list

  datatype Else = NOELSE
		| ELSEIF of Exp.Exp * Statement list * Else
		| ELSE of Statement list

  relation make_assignment : (Exp.Exp, Static.Properties,
			      Exp.Exp, Static.Properties) => Statement

  relation make_if : (Exp.Exp,
		      Static.Properties,
		      Statement list,
		      (Exp.Exp * Static.Properties * Statement list) list,
		      Statement list) => Statement

  relation make_for : (Ident, Exp.Exp, Static.Properties,
		       Statement list) => Statement

  relation make_while : (Exp.Exp, Static.Properties,
			 Statement list) => Statement
	
  relation make_when : (Exp.Exp, Static.Properties,
			Statement list) => Statement
	
end

(** relation: make_assignment *)

relation make_assignment : (Exp.Exp, Static.Properties,
			    Exp.Exp, Static.Properties) => Statement =

  rule	Static.match_prop(rhs, lhprop, rhprop) => rhs'
	--------------------------------------
	make_assignment(Exp.CREF(c), lhprop as Static.PROP(_,false),
			rhs, rhprop) => ASSIGN(c,rhs')

  rule	print "# Trying to assign to constant component\n" &
	print "    " & Exp.print_exp lhs &
 	print " := " & Exp.print_exp rhs & print "\n"
	-------------------------------------------
	make_assignment (lhs,Static.PROP(lt,true),
			 rhs,Static.PROP(rt,_)) => fail

  rule	Types.equivtypes (lt,rt) => false &
	print "# Type mismatch in assignment\n" &
	print "    " & Exp.print_exp lhs &
 	print " := " & Exp.print_exp rhs & print "\n" &
	print "    " & Types.print_type lt &
 	print " := " & Types.print_type rt & print "\n"
	-------------------------------------------
	make_assignment (lhs,Static.PROP(lt,_),rhs,Static.PROP(rt,_)) => fail

  rule	print "- Algorithm.make_assignment failed\n" &
	print "    " & Exp.print_exp lhs &
 	print " := " & Exp.print_exp rhs & print "\n"
	---------------------------------------------
	make_assignment (lhs,_,rhs,_) => fail

end

(** relation: make_if *)

relation make_if : (Exp.Exp,
		    Static.Properties,
		    Statement list,
		    (Exp.Exp * Static.Properties * Statement list) list,
		    Statement list) => Statement =

  rule	make_else(eib,fb) => else
	-------------------------
	make_if(e,Static.PROP(Types.T_BOOL,_),tb,eib,fb) => IF(e,tb,else)

  rule	print "# Type error in if conditional (" &
	Exp.print_exp e & print ")\n" &
	print "    Expected Boolean, got " &
	Types.print_type t & print "\n"
	-------------------------------
	make_if(e,Static.PROP(t,_),_,_,_) => fail

end

(** relation: make_else *)

relation make_else : ((Exp.Exp * Static.Properties * Statement list) list,
		      Statement list) => Else =

	(** This removes empty else branches *)
  axiom	make_else ([],[]) => NOELSE

  axiom	make_else ([],fb) => ELSE(fb)

  rule	make_else (xs,fb) => else
	-------------------------
	make_else ((e,Static.PROP(Types.T_BOOL,_),b)::xs,fb)
	  => ELSEIF(e,b,else)
	
  rule	print "# Type error in elseif conditional (" &
	Exp.print_exp e & print ")\n" &
	print "    Expected Boolean, got " &
	Types.print_type t & print "\n"
	-------------------------------
	make_else((e,Static.PROP(t,_),_)::_,_) => fail

end

(** relation: make_if *)

relation make_for : (Ident, Exp.Exp, Static.Properties,
		     Statement list) => Statement =

  axiom	make_for(i,e,Static.PROP(Types.T_ARRAY(_,_),_),stmts) => FOR(i,e,stmts)

  rule	print "# Type error in for conditional.\n" &
	print "    Expected array, got " &
	Types.print_type t & print "\n"
	-------------------------------
	make_for(_,_,Static.PROP(t,_),_) => fail

end

(** relation: make_while *)

relation make_while : (Exp.Exp, Static.Properties,
		       Statement list) => Statement =

  axiom	make_while(e,Static.PROP(Types.T_BOOL,_),stmts) => WHILE(e,stmts)

  rule	print "# Type error in while conditional.\n" &
	print "    Expected Boolean, got " &
	Types.print_type t & print "\n"
	-------------------------------
	make_while(_,Static.PROP(t,_),_) => fail

end

(** relation: make_when *)

relation make_when : (Exp.Exp, Static.Properties,
		      Statement list) => Statement =

  axiom	make_when(e,Static.PROP(Types.T_BOOL,_),stmts) => WHEN(e,stmts)

  rule	print "# Type error in when conditional.\n" &
	print "    Expected Boolean, got " &
	Types.print_type t & print "\n"
	-------------------------------
	make_when(_,Static.PROP(t,_),_) => fail

end
