<<
/* parser.dlg -- DLG Description of scanner
 *
 * Generated from: modgram.g
 *
 * Terence Parr, Will Cohen, and Hank Dietz: 1989-1994
 * Purdue University Electrical Engineering
 * With AHPCRC, University of Minnesota
 * ANTLR Version 1.33
 */

#include "tokens.h"
#include "AToken.h"
#include "ASTBase.h"


#include "parser.h"
// #include "comments.h"
#include "modAST.h"

#ifndef __GNUG__
#include "bool.h"
#endif

#ifdef _WIN32
extern "C" {
	int getopt(int nargc, char **nargv, char *ostr);
	extern int optind;
	extern char *optarg;
	char *__progname;
}
#endif


extern Comment *newComment;

  
>>


%%START

@
	<<
		return (ANTLRTokenType)1;
	>>

/\*
	<<
		skip(); mode(C_STYLE_COMMENT); 
		newComment=new Comment(line(),EOL);   
		return (ANTLRTokenType)2;
	>>

import
	<<
		return IMPORT;
	>>

class
	<<
		return CLASS_;
	>>

boundary
	<<
		return BOUNDARY;
	>>

model
	<<
		return MODEL;
	>>

function
	<<
		return FUNCTION;
	>>

package
	<<
		return PACKAGE;
	>>

record
	<<
		return RECORD;
	>>

block
	<<
		return BLOCK;
	>>

connector
	<<
		return CONNECTOR;
	>>

type
	<<
		return TYPE;
	>>

end
	<<
		return END;
	>>

annotation
	<<
		return ANNOTATION;
	>>

external
	<<
		return EXTERNAL;
	>>

extends
	<<
		return EXTENDS;
	>>

parameter
	<<
		return PARAMETER;
	>>

constant
	<<
		return CONSTANT;
	>>

virtual
	<<
		return VIRTUAL;
	>>

partial
	<<
		return PARTIAL;
	>>

redeclare
	<<
		return REDECLARE;
	>>

input
	<<
		return INPUT;
	>>

output
	<<
		return OUTPUT;
	>>

flow
	<<
		return FLOW;
	>>

equation
	<<
		return EQUATION;
	>>

algorithm
	<<
		return ALGORITHM;
	>>

results
	<<
		return RESULTS;
	>>

final
	<<
		return FINAL;
	>>

public
	<<
		return PUBLIC;
	>>

protected
	<<
		return PROTECTED;
	>>

\(
	<<
		return LPAR;
	>>

\)
	<<
		return RPAR;
	>>

\[
	<<
		return LBRACK;
	>>

\]
	<<
		return RBRACK;
	>>

if
	<<
		return IF;
	>>

then
	<<
		return THEN;
	>>

else
	<<
		return ELSE;
	>>

elseif
	<<
		return ELSEIF;
	>>

or
	<<
		return OR;
	>>

and
	<<
		return AND;
	>>

not
	<<
		return NOT;
	>>

time
	<<
		return TIME;
	>>

false
	<<
		return FALS;
	>>

true
	<<
		return TRU;
	>>

in
	<<
		return IN;
	>>

for
	<<
		return FOR;
	>>

while
	<<
		return WHILE;
	>>

loop
	<<
		return LOOP;
	>>

der
	<<
		return DER;
	>>

<
	<<
		return (ANTLRTokenType)51;
	>>

<=
	<<
		return (ANTLRTokenType)52;
	>>

>
	<<
		return (ANTLRTokenType)53;
	>>

>=
	<<
		return (ANTLRTokenType)54;
	>>

==
	<<
		return (ANTLRTokenType)55;
	>>

<>
	<<
		return (ANTLRTokenType)56;
	>>

\+
	<<
		return (ANTLRTokenType)58;
	>>

\-
	<<
		return (ANTLRTokenType)59;
	>>

\*
	<<
		return (ANTLRTokenType)61;
	>>

/
	<<
		return (ANTLRTokenType)62;
	>>

=
	<<
		return (ANTLRTokenType)64;
	>>

:=
	<<
		return (ANTLRTokenType)65;
	>>

//(~[\n])*
	<<
		skip(); 
		newComment=new Comment(line(),EOL);
		newComment->addText(lextext()+2);
		return (ANTLRTokenType)67;
	>>

([a-z]|[A-Z])([a-z]|[A-Z]|[0-9]|_)*
	<<
		return IDENT;
	>>

\"(~[\"])*\"
	<<
		return STRING;
	>>

[0-9]+{\.[0-9]*}{[eE]{[\+\-]}[0-9]+}
	<<
		return UNSIGNED_NUMBER;
	>>

[\ \t]+
	<<
		skip();   
		return (ANTLRTokenType)71;
	>>

\n
	<<
		skip(); newline();   
		return (ANTLRTokenType)72;
	>>

;
	<<
		return (ANTLRTokenType)77;
	>>

,
	<<
		return (ANTLRTokenType)78;
	>>

:
	<<
		return (ANTLRTokenType)79;
	>>

^
	<<
		return (ANTLRTokenType)80;
	>>

.
	<<
		return (ANTLRTokenType)81;
	>>


%%C_STYLE_COMMENT

@
	<<
		return (ANTLRTokenType)1;
	>>

[\n\r]
	<<
		skip(); newline(); newComment->addText("\n");   
		return (ANTLRTokenType)73;
	>>

\*/
	<<
		skip(); mode(START);   
		return (ANTLRTokenType)74;
	>>

\*
	<<
		skip(); newComment->addText("*");   
		return (ANTLRTokenType)75;
	>>

~[\*\n\r]+
	<<
		skip(); newComment->addText(lextext());   
		return (ANTLRTokenType)76;
	>>

%%
