module Builtin:

  with "absyn.rml"
  with "explode.rml"
  with "env.rml"

  relation initial_env : () => Env.Env

  val rl_type   : Explode.Class
  val int_type  : Explode.Class
  val str_type  : Explode.Class
  val bool_type : Explode.Class

end

with "exp.rml"
with "mod.rml"
with "classinf.rml"

val rl_type = Explode.CLASS("RealType",false,ClassInf.R_PREDEFINED,
			    Explode.PARTS([],[],[]))
val int_type = Explode.CLASS("IntegerType",false,ClassInf.R_PREDEFINED,
			     Explode.PARTS([],[],[]))
val str_type = Explode.CLASS("StringType",false,ClassInf.R_PREDEFINED,
			     Explode.PARTS([],[],[]))
val bool_type = Explode.CLASS("BooleanType",false,ClassInf.R_PREDEFINED,
			      Explode.PARTS([],[],[]))

(*
val real_type = Absyn.CLASS("Real",false,ClassInf.R_PREDEFINED,
			    Absyn.PARTS(
			    [Absyn.PUBLIC(
			    [Absyn.ELEMENT(true,"value",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("RealType"),
					       [Absyn.COMPONENT("value",
								NONE,
								NONE)])),
			     Absyn.ELEMENT(true,"quantity",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("quantity",
								NONE,
								NONE)])),
			     Absyn.ELEMENT(true,"unit",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("unit",
								NONE,
								NONE)])),
			     Absyn.ELEMENT(true,"displayUnit",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("displayUnit",
								NONE,
								NONE)]))])]))

val integer_type = Absyn.CLASS("Integer",false,ClassInf.R_PREDEFINED,
			    Absyn.PARTS(
			    [Absyn.PUBLIC(
			    [Absyn.ELEMENT(true,"value",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("IntegerType"),
					       [Absyn.COMPONENT("value",
								NONE,
								NONE)])),
			     Absyn.ELEMENT(true,"quantity",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("quantity",
								NONE,
								NONE)])),
			     Absyn.ELEMENT(true,"unit",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("unit",
								NONE,
								NONE)])),
			     Absyn.ELEMENT(true,"displayUnit",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("displayUnit",
								NONE,
								NONE)]))])]))

val string_type = Absyn.CLASS("String",false,ClassInf.R_PREDEFINED,
			    Absyn.PARTS(
			    [Absyn.PUBLIC(
			    [Absyn.ELEMENT(true,"value",
			      Absyn.COMPONENTS(false, true, false,
					       false, false,
					       Exp.IDENT("StringType"),
					       [Absyn.COMPONENT("value",
								NONE,
								NONE)]))])]))
*)
relation initial_env =

  rule	Env.new_frame(Env.empty_env) => env &
	Env.extend_frame_c(env, rl_type, Mod.NOMOD) => env' &
	Env.extend_frame_c(env', int_type, Mod.NOMOD) => env'' &
	Env.extend_frame_c(env'', str_type, Mod.NOMOD) => env''' &
	Env.extend_frame_c(env'', bool_type, Mod.NOMOD) => env''''
(*	Env.extend_frame_c(env, real_type) => env'''' &
	Env.extend_frame_c(env, integer_type) => env''''' &
	Env.extend_frame_c(env, string_type) => env'''''' *)
	----------------------------------------------
	initial_env () => env''''

end
