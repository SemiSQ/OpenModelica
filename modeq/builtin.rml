(**
 ** file:	 builtin.rml
 ** module:      Builtin
 ** description: Builting types and variables
 **
 ** RCS: $Id$
 **
 ** This module defines the builtin types, variables and functions in
 ** Modelica.  The only exported relation is `initial_env'.
 ** 
 ** Currently, the only attribute defined in the built-in types is
 ** `unit'.  The others can easily be added.
 **)

module Builtin:

  with "absyn.rml"
  with "explode.rml"
  with "env.rml"

  val rl_type   : SCode.Class
  val int_type  : SCode.Class
  val str_type  : SCode.Class
  val bool_type : SCode.Class

  val real_type : SCode.Class

  relation initial_env : () => Env.Env

end

(**)

with "exp.rml"
with "types.rml"
with "classinf.rml"

(** - The primitive types *)

val rl_type = SCode.CLASS("RealType",false,Absyn.R_PREDEFINED_REAL,
			  SCode.PARTS([],[],[]))
val int_type = SCode.CLASS("IntegerType",false,Absyn.R_PREDEFINED_INT,
			   SCode.PARTS([],[],[]))
val str_type = SCode.CLASS("StringType",false,Absyn.R_PREDEFINED_STRING,
			   SCode.PARTS([],[],[]))
val bool_type = SCode.CLASS("BooleanType",false,Absyn.R_PREDEFINED_BOOL,
			    SCode.PARTS([],[],[]))
(** These are the primitive types that are used to build the types
 ** `Real', `Integer' etc. *)

val unit = SCode.COMPONENT("unit",true,false,
			      SCode.ATTR([],
					 false,
					 SCode.RW,
					 Absyn.VAR,
					 Absyn.BIDIR),
			      Absyn.IDENT("StringType"),
			      SCode.MOD(false,[],SOME(Absyn.STRING(""))))
(** This `unit' component is used in several places below, and it is
 ** declared once here to make the definitions below easier to read. *)

(** - The `Real' type *)

val real_type =
SCode.CLASS("Real",false,Absyn.R_PREDEFINED_REAL,
	    SCode.PARTS
	    ([unit],
	     [],
	     []))

(** - The `Integer' type *)

val integer_type =
SCode.CLASS("Integer",false,Absyn.R_PREDEFINED_INT,
	    SCode.PARTS
	    ([unit],
	     [],
	     []))

(** - The `String' type *)

val string_type =
SCode.CLASS("String",false,Absyn.R_PREDEFINED_STRING,
	    SCode.PARTS
	    ([],
	     [],
	     []))

(** - The `Boolean' type *)

val boolean_type =
SCode.CLASS("Boolean",false,Absyn.R_PREDEFINED_BOOL,
	    SCode.PARTS
	    ([],
	     [],
	     []))

(** - The `time' variable *)

val time_var =
Types.VAR("time", Types.ATTR(false, SCode.RO, Absyn.VAR, Absyn.BIDIR),
	  false, Types.T_REAL, Types.UNBOUND)

(** - Some assorted function types *)

val nil2real = Types.T_FUNCTION([],
				Types.T_REAL)

val real2real = Types.T_FUNCTION([("x",Types.T_REAL)],
				 Types.T_REAL)

val real_real2real = Types.T_FUNCTION([("x",Types.T_REAL),("y",Types.T_REAL)],
				      Types.T_REAL)

val bool2bool = Types.T_FUNCTION([("x",Types.T_BOOL)],
				 Types.T_BOOL)

val real_real2bool = Types.T_FUNCTION([("x",Types.T_REAL),("y",Types.T_REAL)],
				      Types.T_BOOL)

(** - Initial environment *)

(** relation: initial_env
 ** 
 ** The initial environment where instantiation takes place is built
 ** up using this relation.  It creates an empty environment and adds
 ** all the built-in definitions to it.
 **)
 
relation initial_env =

  rule	Env.open_scope(Env.empty_env) => env1 &
	Env.extend_frame_c(env1, rl_type) => env2 &
	Env.extend_frame_c(env2, int_type) => env3 &
	Env.extend_frame_c(env3, str_type) => env4 &
	Env.extend_frame_c(env4, bool_type) => env5 &
	Env.extend_frame_c(env5, real_type) => env6 &
	Env.extend_frame_c(env6, integer_type) => env7 &
	Env.extend_frame_c(env7, string_type) => env8 &
	Env.extend_frame_c(env8, boolean_type) => env9 &
	Env.extend_frame_c(env9, boolean_type) => env10 &

	Env.extend_frame_v(env10, time_var) => env11 &

	(* non-functions *)
	Env.extend_frame_t(env11, "inital", nil2real)                => env12 &
	Env.extend_frame_t(env12, "terminal", nil2real)              => env13 &
	Env.extend_frame_t(env13, "event", bool2bool)                => env14 &
	Env.extend_frame_t(env14, "switch", bool2bool)               => env15 &
	Env.extend_frame_t(env15, "timeEvent", real_real2bool)       => env16 &
	Env.extend_frame_t(env16, "der", real2real)                  => env17 &

	(* non-differentiable functions *)
	Env.extend_frame_t(env17, "div", real_real2real)             => env18 &
	Env.extend_frame_t(env18, "rem", real_real2real)             => env19 &
	Env.extend_frame_t(env19, "ceil", real2real)                 => env20 &
	Env.extend_frame_t(env20, "floor", real2real)                => env21 &

	(* differentiable functions *)
	Env.extend_frame_t(env21, "abs", real2real)                  => env22 &
	Env.extend_frame_t(env22, "sign", real2real)                 => env23 &

	(* Not in the report *)
	Env.extend_frame_t(env23, "sin", real2real) 		     => env24 &
	Env.extend_frame_t(env24, "cos", real2real) 		     => env25
	----------------------------------------------
	initial_env () => env25

end
