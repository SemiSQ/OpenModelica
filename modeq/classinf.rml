(*
 *  CLASS -+- TYPE --- RECORD --- CONNECTOR
 *         |
 *         +- BLOCK --- FUNCTION
 *         |
 *         +- PACKAGE
 *         |
 *         +- MODEL
 *
 *)
 

module ClassInf :

  datatype Restriction = R_CLASS
		       | R_MODEL
		       | R_RECORD
		       | R_BLOCK
		       | R_CONNECTOR
		       | R_TYPE
		       | R_PACKAGE
		       | R_FUNCTION
		       | R_PREDEFINED (* For internal use only *)

  datatype State = UNKNOWN       of string
		 | MODEL	 of string
		 | RECORD	 of string
		 | BLOCK	 of string
		 | CONNECTOR	 of string
		 | TYPE		 of string
		 | PACKAGE	 of string
		 | FUNCTION	 of string
		 | PREDEFINED	 of string
		 | HAS_EQUATIONS of string
		 | IS_NEW        of string

  datatype Event = FOUND_EQUATION     (* There are definitions *)
		 | NEWDEF	      (* This is not a derived class *)

  relation print_restr : Restriction => ()
  relation start : (Restriction, string) => State
  relation trans : (State, Event) => State
  relation valid : (State, Restriction) => ()
  relation assert_valid : (State, Restriction) => ()

end

relation print_restr : Restriction => () =

  rule	print "CLASS"
	-------------
	print_restr R_CLASS
	
  rule	print "MODEL"
	-------------
	print_restr R_MODEL
	
  rule	print "RECORD"
	--------------
	print_restr R_RECORD
	
  rule	print "BLOCK"
	-------------
	print_restr R_BLOCK
	
  rule	print "CONNECTOR"
	-----------------
	print_restr R_CONNECTOR
	
  rule	print "TYPE"
	------------
	print_restr R_TYPE
	
  rule	print "PACKAGE"
	---------------
	print_restr R_PACKAGE
	
  rule	print "FUNCTION"
	----------------
	print_restr R_FUNCTION

  rule	print "PREDEFINED"
	----------------
	print_restr R_PREDEFINED

end

relation print_state : State => () =

  rule	print "UNKNOWN " & print s
	----------------------------
	print_state UNKNOWN(s)

  rule	print "MODEL " & print s
	----------------------------
	print_state MODEL(s)

  rule	print "RECORD " & print s
	----------------------------
	print_state RECORD(s)

  rule	print "BLOCK " & print s
	----------------------------
	print_state BLOCK(s)

  rule	print "CONNECTOR " & print s
	----------------------------
	print_state CONNECTOR(s)

  rule	print "TYPE " & print s
	----------------------------
	print_state TYPE(s)

  rule	print "PACKAGE " & print s
	----------------------------
	print_state PACKAGE(s)

  rule	print "FUNCTION " & print s
	----------------------------
	print_state FUNCTION(s)

  rule	print "PREDEFINED " & print s
	----------------------------
	print_state PREDEFINED(s)

  rule	print "IS_NEW " & print s
	----------------------------
	print_state IS_NEW(s)

  rule	print "HAS_EQUATIONS " & print s
	----------------------------
	print_state HAS_EQUATIONS(s)

end

relation start : (Restriction, string) => State =

  axiom	start (R_CLASS, s) => UNKNOWN(s)
  axiom	start (R_MODEL, s) => MODEL(s)
  axiom	start (R_RECORD, s) => RECORD(s)
  axiom	start (R_BLOCK, s) => BLOCK(s)
  axiom	start (R_CONNECTOR, s) => CONNECTOR(s)
  axiom	start (R_TYPE, s) => TYPE(s)
  axiom	start (R_PACKAGE, s) => PACKAGE(s)
  axiom	start (R_FUNCTION, s) => FUNCTION(s)
  axiom	start (R_PREDEFINED, s) => PREDEFINED(s)

end

relation trans : (State, Event) => State =

	(* NEWDEF *)

  axiom	trans(UNKNOWN(s),        NEWDEF) => IS_NEW(s)
  axiom	trans(MODEL(s),          NEWDEF) => MODEL(s)
  axiom	trans(RECORD(s),         NEWDEF) => RECORD(s)
  axiom	trans(BLOCK(s),          NEWDEF) => BLOCK(s)
  axiom	trans(CONNECTOR(s),      NEWDEF) => CONNECTOR(s)

  rule	print "# In class " & print s & print "\n" &
	print "# 'type' can only be derived from predefined types\n"
	-----------------------------------------------
	trans(TYPE(s),           NEWDEF) => fail

  axiom	trans(PACKAGE(s),        NEWDEF) => PACKAGE(s)
  axiom	trans(FUNCTION(s),       NEWDEF) => FUNCTION(s)
  axiom	trans(PREDEFINED(s),     NEWDEF) => PREDEFINED(s)

	(* FOUND_EQUATION *)

  axiom	trans(UNKNOWN(s),        FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(IS_NEW(s),         FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(MODEL(s),          FOUND_EQUATION) => MODEL(s)

  rule	print "# In class " & print s & print "\n" &
	print "# Equations not allowed in records\n"
	-----------------------------------------------
	trans(RECORD(s),         FOUND_EQUATION) => fail

  axiom	trans(BLOCK(s),          FOUND_EQUATION) => BLOCK(s)

  rule	print "# In class " & print s & print "\n" &
	print "# Equations not allowed in connectors\n"
	-----------------------------------------------
	trans(CONNECTOR(s),      FOUND_EQUATION) => fail

  axiom	trans(TYPE(s),           FOUND_EQUATION) => fail (* CORRECT? *)
  axiom	trans(PACKAGE(s),        FOUND_EQUATION) => fail
  axiom	trans(FUNCTION(s),       FOUND_EQUATION) => fail
  axiom	trans(HAS_EQUATIONS(s),  FOUND_EQUATION) => HAS_EQUATIONS(s)

  rule	print "- trans fallthru: " & print_state st & print "\n"
	--------------------------------------------------------
	trans(st, ev) => fail

end

relation valid : (State, Restriction) => () =

  axiom	valid(UNKNOWN(s), _)

  axiom	valid(IS_NEW(s),        R_CLASS)
  axiom	valid(HAS_EQUATIONS(s), R_CLASS)

  axiom	valid(MODEL(s),         R_MODEL)
  axiom	valid(IS_NEW(s),        R_MODEL)
  axiom	valid(HAS_EQUATIONS(s), R_MODEL)

  axiom	valid(RECORD(s),        R_RECORD)
  axiom	valid(IS_NEW(s),        R_RECORD)

  axiom	valid(BLOCK(s),         R_BLOCK)
  axiom	valid(HAS_EQUATIONS(s), R_BLOCK)

  axiom	valid(CONNECTOR(s),     R_CONNECTOR)
  axiom	valid(IS_NEW(s),        R_CONNECTOR)

  axiom	valid(TYPE(s),          R_TYPE)
  axiom	valid(PREDEFINED(s),    R_TYPE)

  axiom	valid(IS_NEW(s),        R_PACKAGE)
  axiom	valid(PACKAGE(s),       R_PACKAGE)

  axiom	valid(IS_NEW(s),        R_FUNCTION)
  axiom	valid(FUNCTION(s),      R_FUNCTION)

end

relation assert_valid : (State, Restriction) => () =

  rule	valid(st,re)
	------------
	assert_valid(st,re)

  rule	print "# Restriction violation: " & print_state st &
	print " is not a " & print_restr re & print "\n" 
	-------------------------------------------
	assert_valid(st,re) => fail

end
