(**
 ** file: classinf.rml
 **
 ** This module deals with class inference, that is determining if a
 ** class definition adhers to one of the class restrictions, and, if
 ** specifically declared in a restrictied form, if it breaks that
 ** restriction.
 **
 ** The inference is implemented as a finite state machine.  The
 ** relation `start' initializes a new machine, and the relation
 ** `trans' signals transitions in the machine.  Finally, the state
 ** can be checked agains a restriction with the `valid' relation.
 **
 ** The restricted forms are ordered in a hierarchal fashion as
 ** described by the following diagram:
 **
 **| CLASS -+- TYPE --- RECORD --- CONNECTOR
 **|	    |
 **|	    +- BLOCK --- FUNCTION
 **|	    |
 **|	    +- PACKAGE
 **|	    |
 **|	    +- MODEL
 **
 **)

module ClassInf :

  with "absyn.rml"

  (** - Machine states *)
  datatype State = UNKNOWN       of string
		 | MODEL	 of string
		 | RECORD	 of string
		 | BLOCK	 of string
		 | CONNECTOR	 of string
		 | TYPE		 of string
		 | PACKAGE	 of string
		 | FUNCTION	 of string
		 | HAS_EQUATIONS of string
		 | IS_NEW        of string
		 | TYPE_INTEGER  of string
		 | TYPE_REAL     of string
		 | TYPE_STRING   of string
		 | TYPE_BOOL     of string

  (** - Events *)
  datatype Event = FOUND_EQUATION     (* There are definitions inside *)
				      (* the current definition *)
		 | NEWDEF	      (* This is not a derived class *)
  (** The `Event' type contains the different events during *)
  (** instantiation that signals a possible machine transition. *)

  (** - Exported relations *)

  relation start : (Absyn.Restriction, string) => State
  relation trans : (State, Event) => State

  relation valid : (State, Absyn.Restriction) => ()
  (* `assert_valid' is identical to 'valid'.  The only difference is *)
  (* that it prints an error message when it fails. *)
  relation assert_valid : (State, Absyn.Restriction) => ()

  (* Debug relation *)
  relation print_state : State => ()

end

(** - Printing *)
(**)
(** Some relations for printing error and debug information about the *)
(** state machine. *)

(** relation: print_state *)

relation print_state : State => () =

  rule	print "UNKNOWN " & print s
	----------------------------
	print_state UNKNOWN(s)

  rule	print "MODEL " & print s
	----------------------------
	print_state MODEL(s)

  rule	print "RECORD " & print s
	----------------------------
	print_state RECORD(s)

  rule	print "BLOCK " & print s
	----------------------------
	print_state BLOCK(s)

  rule	print "CONNECTOR " & print s
	----------------------------
	print_state CONNECTOR(s)

  rule	print "TYPE " & print s
	----------------------------
	print_state TYPE(s)

  rule	print "PACKAGE " & print s
	----------------------------
	print_state PACKAGE(s)

  rule	print "FUNCTION " & print s
	----------------------------
	print_state FUNCTION(s)

  rule	print "TYPE_INTEGER " & print s
	----------------------------
	print_state TYPE_INTEGER(s)

  rule	print "TYPE_REAL " & print s
	----------------------------
	print_state TYPE_REAL(s)

  rule	print "TYPE_STRING " & print s
	----------------------------
	print_state TYPE_STRING(s)

  rule	print "TYPE_BOOL " & print s
	----------------------------
	print_state TYPE_BOOL(s)

  rule	print "IS_NEW " & print s
	----------------------------
	print_state IS_NEW(s)

  rule	print "HAS_EQUATIONS " & print s
	----------------------------
	print_state HAS_EQUATIONS(s)

end

(** relation: print_event *)

relation print_event : Event => () =

  rule	print "FOUND_EQUATION"
	----------------------
	print_event FOUND_EQUATION

  rule	print "NEWDEF"
	--------------
	print_event NEWDEF

end

(** - Transitions *)

(** relation: start
 ** purpose:  State machine initialization
 **)

relation start : (Absyn.Restriction, string) => State =

  axiom	start (Absyn.R_CLASS, s) 	       => UNKNOWN(s)
  axiom	start (Absyn.R_MODEL, s) 	       => MODEL(s)
  axiom	start (Absyn.R_RECORD, s)            => RECORD(s)
  axiom	start (Absyn.R_BLOCK, s)             => BLOCK(s)
  axiom	start (Absyn.R_CONNECTOR, s)         => CONNECTOR(s)
  axiom	start (Absyn.R_TYPE, s)              => TYPE(s)
  axiom	start (Absyn.R_PACKAGE, s)           => PACKAGE(s)
  axiom	start (Absyn.R_FUNCTION, s)          => FUNCTION(s)
  axiom	start (Absyn.R_PREDEFINED_INT, s)    => TYPE_INTEGER(s)
  axiom	start (Absyn.R_PREDEFINED_REAL, s)   => TYPE_REAL(s)
  axiom	start (Absyn.R_PREDEFINED_STRING, s) => TYPE_STRING(s)
  axiom	start (Absyn.R_PREDEFINED_BOOL, s)   => TYPE_BOOL(s)

end

(** relation: trans
 **)

relation trans : (State, Event) => State =

	(* NEWDEF *)

  axiom	trans(UNKNOWN(s),        NEWDEF) => IS_NEW(s)
  axiom	trans(MODEL(s),          NEWDEF) => MODEL(s)
  axiom	trans(RECORD(s),         NEWDEF) => RECORD(s)
  axiom	trans(BLOCK(s),          NEWDEF) => BLOCK(s)
  axiom	trans(CONNECTOR(s),      NEWDEF) => CONNECTOR(s)

  rule	print "# In class " & print s & print "\n" &
	print "# 'type' can only be derived from predefined types\n"
	-----------------------------------------------
	trans(TYPE(s),           NEWDEF) => fail

  axiom	trans(PACKAGE(s),        NEWDEF) => PACKAGE(s)
  axiom	trans(FUNCTION(s),       NEWDEF) => FUNCTION(s)
  axiom	trans(IS_NEW(s),         NEWDEF) => IS_NEW(s)
  axiom	trans(TYPE_INTEGER(s),   NEWDEF) => TYPE_INTEGER(s)
  axiom	trans(TYPE_REAL(s),      NEWDEF) => TYPE_REAL(s)
  axiom	trans(TYPE_STRING(s),    NEWDEF) => TYPE_STRING(s)
  axiom	trans(TYPE_BOOL(s),      NEWDEF) => TYPE_BOOL(s)

	(* FOUND_EQUATION *)

  axiom	trans(UNKNOWN(s),        FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(IS_NEW(s),         FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(MODEL(s),          FOUND_EQUATION) => MODEL(s)

  rule	print "# In class " & print s & print "\n" &
	print "# Equations not allowed in records\n"
	-----------------------------------------------
	trans(RECORD(s),         FOUND_EQUATION) => fail

  axiom	trans(BLOCK(s),          FOUND_EQUATION) => BLOCK(s)

  rule	print "# In class " & print s & print "\n" &
	print "# Equations not allowed in connectors\n"
	-----------------------------------------------
	trans(CONNECTOR(s),      FOUND_EQUATION) => fail

  axiom	trans(TYPE(s),           FOUND_EQUATION) => fail (* CORRECT? *)
  axiom	trans(PACKAGE(s),        FOUND_EQUATION) => fail
  axiom	trans(FUNCTION(s),       FOUND_EQUATION) => fail
  axiom	trans(HAS_EQUATIONS(s),  FOUND_EQUATION) => HAS_EQUATIONS(s)

  rule	print "- trans failed: " & print_state st &
 	print ", " & print_event ev & print "\n"
	--------------------------------------------------------
	trans(st, ev) => fail

end

(** relation: valid
 **)

relation valid : (State, Absyn.Restriction) => () =

  axiom	valid(UNKNOWN(s), _)

  axiom	valid(IS_NEW(s),        Absyn.R_CLASS)
  axiom	valid(HAS_EQUATIONS(s), Absyn.R_CLASS)

  axiom	valid(MODEL(s),         Absyn.R_MODEL)
  axiom	valid(IS_NEW(s),        Absyn.R_MODEL)
  axiom	valid(HAS_EQUATIONS(s), Absyn.R_MODEL)

  axiom	valid(RECORD(s),        Absyn.R_RECORD)
  axiom	valid(IS_NEW(s),        Absyn.R_RECORD)

  axiom	valid(BLOCK(s),         Absyn.R_BLOCK)
  axiom	valid(HAS_EQUATIONS(s), Absyn.R_BLOCK)

  axiom	valid(CONNECTOR(s),     Absyn.R_CONNECTOR)
  axiom	valid(IS_NEW(s),        Absyn.R_CONNECTOR)

  axiom	valid(TYPE(s),          Absyn.R_TYPE)
  axiom	valid(TYPE_INTEGER(s),  Absyn.R_TYPE)
  axiom	valid(TYPE_REAL(s),     Absyn.R_TYPE)
  axiom	valid(TYPE_STRING(s),   Absyn.R_TYPE)
  axiom	valid(TYPE_BOOL(s),     Absyn.R_TYPE)

  axiom	valid(IS_NEW(s),        Absyn.R_PACKAGE)
  axiom	valid(PACKAGE(s),       Absyn.R_PACKAGE)

  axiom	valid(IS_NEW(s),        Absyn.R_FUNCTION)
  axiom	valid(FUNCTION(s),      Absyn.R_FUNCTION)

end

(** relation: assert_valid
 **)

relation assert_valid : (State, Absyn.Restriction) => () =

  rule	valid(st,re)
	------------
	assert_valid(st,re)

  rule	print "# Restriction violation: " & print_state st &
	print " is not a " & Absyn.print_restr re & print "\n" 
	-------------------------------------------
	assert_valid(st,re) => fail

end
