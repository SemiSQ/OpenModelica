(**
 ** file:	 codegen.rml
 ** module:      Codegen
 ** description: Generate code from DAE (Flat Modelica)
 **
 ** RCS: $Id$
 **
 **)


module Codegen :

  with "dae.rml"
  with "exp.rml"
  with "types.rml"
  with "algorithm.rml"

  type Ident = string

  type ReturnType          = string
  type FunctionName        = string
  type ArgumentDeclaration = string
  type VariableDeclaration = string
  type InitStatement       = string
  type Statement           = string
  type CleanupStatement    = string
  type ReturnTypeStruct    = string list

  datatype CFunction = CFUNCTION of 
                         ReturnType *
                         FunctionName * 
                         ReturnTypeStruct *
                         (ArgumentDeclaration list) *
                         (VariableDeclaration list) *
                         (InitStatement       list) *
                         (Statement           list) *
                         (CleanupStatement    list)

  

  relation generate_functions : DAE.DAElist => ()
	  
end

with "util.rml"
with "modutil.rml"
with "dump.rml"
with "debug.rml"
with "staticexp.rml"
with "inst.rml"
with "rtopts.rml"
with "absyn.rml"
with "classinf.rml"

val c_empty_function = CFUNCTION("","",[],[],[],[],[],[])

relation c_make_function : (ReturnType,
			    FunctionName,
			    ReturnTypeStruct,
			    ArgumentDeclaration list)
	  => CFunction =

  axiom	c_make_function (rt,fn,rts,ads) => CFUNCTION(rt,fn,rts,ads,[],[],[],[])

end

relation c_add_variables : (CFunction, VariableDeclaration list) => CFunction =

  rule	list_append(vd,nvd) => vd'
	--------------------------
	c_add_variables (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nvd)
			 => CFUNCTION(rt,fn,rts,ads,vd',is,st,cl)

end


relation c_add_inits : (CFunction, InitStatement list) => CFunction =

  rule	list_append(is,nis) => is'
	--------------------------
	c_add_inits (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nis)
			 => CFUNCTION(rt,fn,rts,ads,vd,is',st,cl)

end

relation c_add_statements : (CFunction, Statement list) => CFunction =

  rule	list_append(st,nst) => st'
	--------------------------
	c_add_statements (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nst)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st',cl)

end

relation c_add_cleanups : (CFunction, CleanupStatement list) => CFunction =

  rule	list_append(cl,ncl) => cl'
	--------------------------
	c_add_cleanups (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),ncl)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st,cl')

end

relation c_merge_fns : CFunction list => CFunction =
	
  axiom	c_merge_fns [] => c_empty_function

  rule	c_merge_fns r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	c_merge_fns cfn1::r => cfn

end

relation c_merge_fn : (CFunction, CFunction) => CFunction =

  rule	list_append(vd1,vd2) => vd &
	list_append(is1,is2) => is &
	list_append(st1,st2) => st &
	list_append(cl1,cl2) => cl 	
	-----------------------------
	c_merge_fn (CFUNCTION(rt,fn,rts,ad,vd1,is1,st1,cl1),
		    CFUNCTION(_ , _, _ , _,vd2,is2,st2,cl2)) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)
			 
end

relation c_print_functions : CFunction list => () =

  axiom	c_print_functions []

  rule	c_print_function(f) &
	c_print_functions(r)
	---------------------
	c_print_functions f::r
end

relation c_print_function : CFunction => () =

  rule	Dump.print_list(rts,print,"\n") & print "\n" &
	Dump.print_list([rt," ",fn,"("],print,"") &
	Dump.print_list(ad,print,", ") & print ")\n{\n  " &
	Dump.print_list(vd,print,"\n  ") & print "\n  " &
	Dump.print_list(is,print,"\n  ") & print "\n  " &
	Dump.print_list(st,print,"\n  ") & print "\n  " &
	Dump.print_list(cl,print,"\n  ") & print "\n" &
	print "}\n"
	-----------
	c_print_function CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)

end

relation generate_functions : DAE.DAElist => () =

  rule	Debug.fprintln ("cgtr", "generate_functions") &
	generate_functions_elist elist => cfns &
	print "#include \"modelica.h\"\n" &
	c_print_functions cfns &
	print "\n"
	------------------------------
	generate_functions DAE.DAE(elist)

  rule	print "#--- generate_functions failed\n"
	--------------------------------------
	generate_functions _ 

end



relation generate_functions_elist : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") 
	----------------------------------------------------
	generate_functions_elist [] => []

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") &
	generate_function f => cfns1 &
	generate_functions_elist rest => cfns2 &
	list_append(cfns1,cfns2) => cfns
	----------------------------
	generate_functions_elist f :: rest => cfns
	
end

relation generate_params_type : Ident => string =

  rule	string_append (n, "_params") => s
	---------------------------------
	generate_params_type n => s

end


relation generate_function : DAE.Element => CFunction list =

  rule	generate_function_name fpath => fn_name_str &
	Debug.fprintl ("cg", ["generating function ", fn_name_str, "\n"]) &


	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath           => retstr &
	Util.list_map(args, generate_function_arg)  => arg_strs &

	c_make_function(retstr, fn_name_str, struct_strs,arg_strs)=> head_cfn &

	generate_function_body_tuple(fpath, dae, restype) => body_cfn &

	c_merge_fn(head_cfn,body_cfn) => cfn &
	
	generate_read_call_write(fn_name_str,outvars,retstr,invars) => rcw_fn
	---------------------------
	generate_function DAE.FUNCTION(fpath, 
				       DAE.DAE(dae), 
				       Types.T_FUNCTION(args,restype)) 
	  => [cfn,rcw_fn]


  rule	generate_functions_elist daelist => cfns
	----------------------
	generate_function DAE.COMP(n, DAE.DAE(daelist)) => cfns

	(* for non-function elements *)

  axiom	generate_function _ => []
	
end


relation generate_result_struct : (DAE.Element list, Absyn.Path) 
	  => string list =

  rule	generate_return_type fpath => ptname &
	generate_return_decls outvars => (var_strs,var_names) &
	generate_return_defs (ptname,var_names,1) => defs &
	indent_strings var_strs => var_strs' &
	Util.string_append_list(["typedef struct ",ptname,"_s"]) => first_row &
	Util.string_append_list(["} ",ptname,";"]) => last_row &
	Util.list_flatten([defs,[first_row,"{"],var_strs',[last_row]]) => strs
	-----------------------------------------
	generate_result_struct (outvars, fpath) => strs

(*
  rule	DAE.get_vars ( daelist, DAE.is_parameter ) => params &
	list_length params => nbrparams &
	int_le (nbrparams, 0) => true &
	print "#-- no params in " &
	print n &
	print "\n"
	-----------------------------------------
	generate_params_struct (daelist, n)
*)

end

relation generate_return_defs : (string, string list, int) => string list =

  axiom generate_return_defs (_,[],_) => []
	
  rule	int_string i => i_str &
	Util.string_append_list(["#define ",tn,"_",i_str," ",f]) => f' &
	int_add(i,1) => i' &
	generate_return_defs (tn,r,i') => r'
	----
	generate_return_defs (tn,f::r,i) => f'::r'

end

relation generate_return_decls : DAE.Element list => (string list, 
						      string list) =

  axiom	generate_return_decls [] => ([],[])

  rule	generate_return_decl first => ("",_) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (rs,rd)

  rule	generate_return_decl first => (fs,fd) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (fs::rs,fd::rd)

end


relation generate_return_decl: DAE.Element => (string, string) =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.list_map(inst_dims,int_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([typ_str," ",id_str,";",
				 " /* [",dims_str,"] */"]) 
	  => decl_str
	---------------------------------------------------
	generate_return_decl (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, NONE,inst_dims))
	  => (decl_str,id_str)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.string_append_list([typ_str," ",id_str,";"]) => decl_str &
	print "# default/init values not implemented yet: " &
	Exp.print_exp e &
	print "\n"
	-----------
	generate_return_decl (DAE.VAR(id, 
				      DAE.VARIABLE, 
				      DAE.OUTPUT, 
				      typ, 
				      SOME(e),
				      _))
	=> (decl_str,id_str)


  axiom	generate_return_decl (_) => ("","")

end

relation is_array : Exp.ComponentRef => bool =
	
  axiom	is_array Exp.CREF_IDENT(_,[]) => false
  axiom	is_array Exp.CREF_IDENT(_,_::_) => true
  axiom	is_array Exp.CREF_QUAL(_,_::_,_) => true

  rule	is_array cref => b
	------------------
	is_array Exp.CREF_QUAL(_,[],cref) => b

end

relation is_first_in_array : Exp.ComponentRef => bool =

  axiom	is_first_in_array Exp.CREF_IDENT(_,[]) => true

  rule	subs_is_one subs => b
	---------------------
	is_first_in_array Exp.CREF_IDENT(_,subs) => b

  rule	is_first_in_array cref => b
	---------------------------
	is_first_in_array Exp.CREF_QUAL(_,[],cref) => b

  rule	subs_is_one subs => b1 &
	is_first_in_array cref => b2 &
	bool_and(b1,b2) => b
	------------------------------
	is_first_in_array Exp.CREF_QUAL(_,subs,cref) => b
end

relation subs_is_one : Exp.Subscript list => bool =

  axiom subs_is_one [] => true

  rule	subs_is_one r => b
	------------------
	subs_is_one Exp.INDEX(Exp.ICONST(1))::r => b

  axiom	subs_is_one _::_ => false

end


relation dae_type_str : (DAE.Type, bool) => string =

  axiom	dae_type_str (DAE.INT, false) => "modelica_integer"
  axiom	dae_type_str (DAE.REAL, false) => "modelica_real"
  axiom	dae_type_str (DAE.STRING, false) => "modelica_string"
  axiom	dae_type_str (DAE.BOOL, false) => "modelica_boolean"

  axiom	dae_type_str (DAE.INT, true) => "integer_array"
  axiom	dae_type_str (DAE.REAL, true) => "real_array"
  axiom	dae_type_str (DAE.STRING, true) => "string_array"
  axiom	dae_type_str (DAE.BOOL, true) => "boolean_array"

end

relation exp_type_str : (Exp.Type, bool) => string =

  axiom	exp_type_str (Exp.INT, false) => "modelica_integer"
  axiom	exp_type_str (Exp.REAL, false) => "modelica_real"
  axiom	exp_type_str (Exp.STRING, false) => "modelica_string"
  axiom	exp_type_str (Exp.BOOL, false) => "modelica_boolean"
  axiom	exp_type_str (Exp.OTHER, false) => "modelica_other"

  axiom	exp_type_str (Exp.INT, true) => "integer_array"
  axiom	exp_type_str (Exp.REAL, true) => "real_array"
  axiom	exp_type_str (Exp.STRING, true) => "string_array"
  axiom	exp_type_str (Exp.BOOL, true) => "boolean_array"
  axiom	exp_type_str (Exp.OTHER, true) => "other_array"

end

relation generate_type : Types.Type => string =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => ty_str 
	---------------------------
	generate_type Types.T_TUPLE(tys) => ty_str


  rule	Debug.fprintln ("cgtr", "generate_type") &
	flatten_array_type tys => (arrayty, dims) &
	generate_array_type (arrayty, dims) => ty_str
	-----------------------------------
	generate_type (tys as Types.T_ARRAY(_,_)) => ty_str


  axiom	generate_type Types.T_INTEGER => "modelica_integer"
  axiom generate_type Types.T_REAL => "modelica_real"
  axiom	generate_type Types.T_STRING => "modelica_string"
  axiom	generate_type Types.T_BOOL => "modelica_boolean"


  rule	print "#-- generate_type failed: " &
	Types.print_type ty & print "\n"
	--------------------------------
	generate_type ty => fail

end


relation generate_return_type : Absyn.Path => string =

  rule	generate_function_name fpath => fstr &
	string_append (fstr, "_rettype" ) => res
	--------------------------
	generate_return_type fpath => res
end

(*
relation generate_return_type : Types.Type => () =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => str &
	print str
	---------------------------
	generate_return_type Types.T_TUPLE(tys)


  rule	Debug.fprintln ("cgtr", "generate_type") &
	flatten_array_type tys => (arrayty, dims) &
	generate_array_return_type (arrayty, dims)
	-----------------------------------
	generate_return_type (tys as Types.T_ARRAY(_,_))


  rule	print "#-- generate_type failed\n" &
	Types.print_type ty & print "\n"
	--------------------------------
	generate_return_type ty => fail

end
*)

relation flatten_array_type : Types.Type => (Types.Type, int list) =

  rule	Debug.fprintln ("cgtr", "flatten_array_type1") &
	flatten_array_type ty => (ty', dimlist')
	--------------------------------------
  	flatten_array_type Types.T_ARRAY(Types.DIM(NONE), ty) => (ty', dimlist')

  rule	Debug.fprintln ("cgtr", "flatten_array_type2") &
	flatten_array_type ty => (ty', dimlist) &
	list_append (dimlist,[dim]) => dimlist'
	--------------------------------------
  	flatten_array_type Types.T_ARRAY(Types.DIM(SOME(dim)), ty) => (ty', dimlist')

  axiom	flatten_array_type ty => (ty, [])

end

relation generate_array_type : (Types.Type, int list) => string =

(*
  rule	Types.print_type ty &
	print "[" & Dump.print_list (dims, print_int, ",") & print "]" 
	-------------------------------------------------------------
	generate_array_type (ty, dims)
*)
  rule	array_type_string ty => str 
	--------------------------
	generate_array_type (ty, dims) => str
end

relation generate_array_return_type : (Types.Type, int list) => string =

  rule	array_type_string ty => ty_str
	-------------------------------
	generate_array_return_type (ty, dims) => ty_str

end

relation print_int : int => () =

  rule	int_string i => str &
	print str
	---------
	print_int i
end

relation print_star : int => () =

  rule	print "*"
	---------
	print_star i

end



relation generate_tuple_type : Types.Type list => string =


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_1") &
	generate_simple_type ty => str
	--------------------------------
	generate_tuple_type [ty] => str


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_2") &
	generate_simple_type ty => str &
	generate_tuple_type tys => str' &
	string_append (str, str') => str'' &
	string_append ("struct ", str'') => str'''
	----------------------------------
	generate_tuple_type (ty::tys) => str'''

end



relation generate_simple_type : Types.Type => string =

  axiom	generate_simple_type Types.T_INTEGER => "modelica_integer"
  axiom	generate_simple_type Types.T_REAL => "modelica_real"
  axiom	generate_simple_type Types.T_STRING => "modelica_string"
  axiom	generate_simple_type Types.T_BOOL => "modelica_boolean"

  rule	string_append ("const ", n) => n' &
	string_append (n', "&") => n''
	------------------------------
	generate_simple_type Types.T_COMPLEX (ClassInf.RECORD(n),_) => n''

  rule	Types.array_element_type t => t' &
	array_type_string t' => t_str
	-----------------------
	generate_simple_type (t as Types.T_ARRAY(_,_)) => t_str

  rule	print "#--generate_simple_type failed " &
	Types.print_type ty & 
	print "\n"
	--------------------------------------
	generate_simple_type ty => fail
end

relation array_type_string : Types.Type => string =

  axiom	array_type_string Types.T_INTEGER => "integer_array"
  axiom	array_type_string Types.T_REAL => "real_array"
  axiom	array_type_string Types.T_STRING => "string_array"
  axiom	array_type_string Types.T_BOOL => "boolean_array"

end

relation generate_function_name : Absyn.Path => string =

  rule	ModUtil.path_string fpath => fstr 
	----------
	generate_function_name fpath => fstr

end



relation generate_function_arg : Types.FuncArg => string =

  rule	generate_tuple_type [ty] => str &
	string_append (str, " ") => str' &
	string_append (str', name) => str''
	-----------------------------------
	generate_function_arg ((name, ty)) => str''

end




relation generate_function_body_tuple : (Absyn.Path, 
					 DAE.Element list, 
					 Types.Type) 
	  => CFunction =
	  
  rule	Debug.fprintln ("cgtr", "generate_function_body_tuple") &
	
	let tnr = 1 &

	generate_return_type fpath => ret_type_str &
	generate_temp_decl(ret_type_str,tnr) => (ret_decl, ret_var, tnr_ret') &
	Util.string_append_list(["return ",ret_var,";"]) => ret_stmt &

	DAE.get_output_vars dae => outvars &
	generate_alloc_outvars(outvars,ret_decl,ret_var,tnr_ret')
	  => (out_fn,tnr_ret) &

	generate_temp_decl("state",tnr_ret) 
	      => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var," = get_memory_state();"]) 
	  => mem_stmt1 &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => mem_stmt2 &

	c_add_variables (out_fn, [mem_decl])  => mem_fn' &
	c_add_inits     (mem_fn',[mem_stmt1]) => mem_fn &

	generate_vars        (dae, is_var_q, tnr_mem)=> (var_fn,tnr_var) &
	generate_algorithms  (dae, tnr_var)          => (alg_fn,tnr_alg) &
	generate_result_vars (dae, ret_var, tnr_alg) => (res_var_fn,tnr_res) &
	
	c_merge_fn(mem_fn, var_fn)     => cfn' &
	c_merge_fn(cfn'  , alg_fn)     => cfn'' &
	c_merge_fn(cfn'' , res_var_fn) => cfn''' &

	c_add_cleanups(cfn''',[mem_stmt2,ret_stmt]) => cfn
	--------------
	generate_function_body_tuple (fpath, dae, restype) => cfn

end

relation generate_alloc_outvars : (DAE.Element list, string, string,int) 
	  => (CFunction,int) =

	  
  rule	c_add_variables(c_empty_function,[rd]) => cfn
	---------
	generate_alloc_outvars([],rd,rv,tnr) => (cfn,tnr)

  rule	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars(r,rd,rv,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------
	generate_alloc_outvars ((var as DAE.VAR(cr,vk,vd,t,e,id))::r,
				rd,rv,tnr)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars(r,rd,rv,tnr) => (cfn2,tnr2)
	--------------
	generate_alloc_outvars (_::r,rd,rv,tnr) => (cfn2,tnr2)

end

relation generate_alloc_outvar : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,int_string) => dim_strs &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,
			"(&",prefix,".",cref_str,", ",
			ndims_str,", ",dims_str,");"])
	  => alloc_str &
	  
	  c_add_inits(c_empty_function,[alloc_str]) => cfn' &
	Util.if (is_a,cfn',c_empty_function) => cfn
	-----------
	generate_alloc_outvar(DAE.VAR(id, vk, vd, typ, e,inst_dims),
			      prefix,
			      tnr) 
	  => (cfn,tnr)

  axiom	generate_alloc_outvar (_,_,tnr) => (c_empty_function,tnr)

end

relation prefix_cr : (string, Exp.ComponentRef) => Exp.ComponentRef =

  axiom	prefix_cr (prf,cref) 
	  => Exp.CREF_QUAL(prf,[],cref)
	  
end

relation generate_algorithms: (DAE.Element list, int)
	  => (CFunction, int) =

  axiom	generate_algorithms ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm (first,tnr) => (cfn1,tnr1) &
	generate_algorithms (rest,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------
	generate_algorithms (first::rest, tnr) => (cfn,tnr2)

end



relation generate_algorithm: (DAE.Element, int)
	  => (CFunction, int) =

  rule	generate_algorithm_statements (stmts,tnr) => (cfn,tnr') 
	----------------------------------------
	generate_algorithm (DAE.ALGORITHM(Algorithm.ALGORITHM(stmts)),tnr)
	  => (cfn,tnr')

  axiom	generate_algorithm (_,tnr) => (c_empty_function,tnr)

end

relation generate_algorithm_statements : (Algorithm.Statement list, int)
	  => (CFunction, int) =

  axiom	generate_algorithm_statements ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm_statement (f,tnr) => (cfn1,tnr1) &
	generate_algorithm_statements(r,tnr1) =>(cfn2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn
	-----------
	generate_algorithm_statements (f::r, tnr) => (cfn,tnr2)
end


(*
 relation : generate_algorithm_statement

 returns:
   CFunction | Code
   string    | expression result: variable name, or 'c' expression
   int       | next temporary number 
 *)

relation generate_algorithm_statement : (Algorithm.Statement, int)
	  => (CFunction, int) =

  rule	Debug.fprintln("cgas","generate_algorithm_statement") &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_scalar_lhs_cref(typ,cref,tnr1)
	  => (cfn2,var2,tnr2) &
	Util.string_append_list([var2," = ",var1,";"]) => stmt &

	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	----------------
	generate_algorithm_statement (Algorithm.ASSIGN(typ,cref,exp),tnr)
	  => (cfn, tnr2)

  rule	comp_ref_cstr cref => (cref_str,[]) &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["copy_",type_str,"_data(&",
			var1,", &",cref_str,");"]) => stmt &
	  c_add_statements(cfn1,[stmt]) => cfn2
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn2,tnr1)

  rule	comp_ref_cstr cref => (cref_str,subs as _::_) &
	
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_index_spec(subs,tnr1) => (cfn2,var2,tnr2) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["indexed_assign_",type_str,"(&",
			var1,", &",cref_str,", ",var2,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn,tnr2)

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	
	Util.string_append_list(["if (",var1,") {"]) => if_begin &
	c_add_statements(cfn1,[if_begin]) => cfn1' &
	generate_algorithm_statements(then,tnr1) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	generate_else (else,tnr2) => (cfn3,tnr3) &
	c_merge_fns([cfn1',cfn2',cfn3]) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.IF(e,then,else),tnr) 
	  => (cfn,tnr3)

  rule	print "# for statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(_,_,_),_) => fail

  rule	c_add_statements(c_empty_function,["while (1) {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (!",var2,") break;"]) => crit_stmt &
	c_add_statements(cfn2,[crit_stmt]) => cfn2' &

	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1,cfn2',cfn3']) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.WHILE(e,stmts),tnr) 
	  => (cfn,tnr3)

  rule	print "# when statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.WHEN(_,_),_) => fail

  rule	print "# generate_algorithm_statement failed\n"
	-------------------------
	generate_algorithm_statement (_,_) => fail

end

relation generate_else : (Algorithm.Else, int) => (CFunction, int) =

  axiom	generate_else (Algorithm.NOELSE,tnr) => (c_empty_function,tnr)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (",var2,") {"]) => if_begin &
	c_add_statements(cfn2,[if_begin]) => cfn2' &
	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &
	generate_else(else,tnr3) => (cfn4,tnr4) &
	c_add_statements(cfn4,["}"]) => cfn4' &
	c_merge_fns([cfn1,cfn2',cfn3',cfn4']) => cfn
	-------
	generate_else (Algorithm.ELSEIF(e,stmts,else),tnr) => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_algorithm_statements(stmts,tnr) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	--------
	generate_else (Algorithm.ELSE(stmts),tnr) => (cfn,tnr)

  rule	print "# generate_else failed\n"
	---------------
	generate_else (_,_) => fail
end

relation generate_vars : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_vars ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var (first,tnr)  => (cfn1,tnr1) & 
	generate_vars (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_vars (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	print "# generate_vars failed\n"
	---------------------------------
	generate_vars (_,_,_) => fail
	
end


relation generate_var : (DAE.Element,int) => (CFunction,int) =
(*
 parameters are put in the params struct

  rule	generate_var_q2 (vd) &
	indent 2 &
	DAE.dump_type typ &
	Exp.print_component_ref id &
	print " = 0;  /* Warning: without value, set to zero */\n"
	-----------
	generate_var(DAE.VAR(id, DAE.PARAM, vd, typ, NONE,_))
*)

  rule	is_first_in_array id => false
	-----------------------------
	generate_var(DAE.VAR(id,_,_,_,_,_),tnr) => (c_empty_function,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,int_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dims_str,");"]) => alloc_str &
	c_add_variables(c_empty_function,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn
	----------------------------------------------------
	generate_var(DAE.VAR(id, vk, vd, typ, NONE,inst_dims),tnr) => (cfn,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,int_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])
	  => decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dims_str,");"]) => alloc_str &
	c_add_variables(c_empty_function,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn &
	print "# default value not implemented yet: " &
	Exp.print_exp e & print "\n"
	-----------
	generate_var(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) 
	  => (cfn,tnr)

  
  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.string_append_list([typ_str," ",cref_str,";"]) => decl_str &
	generate_expression(e,tnr) => (cfn,var,tnr1) &
	c_add_variables(cfn,[decl_str]) => cfn' &
	Util.string_append_list([cref_str," = ",var,";"]) => init_stmt &
	c_add_inits(cfn',[init_stmt]) => cfn'' &
	print "# default value not implemented yet: " &
	Exp.print_exp e & print "\n"
	-----------
	generate_var(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) => (cfn'',tnr1)
	
  rule	print "# generate_var failed\n  " &
	DAE.dump_debug_element e & print "\n"
	-----------------------------------
	generate_var (e,_) => fail
end


relation is_var_q : DAE.Element => () =

  rule	generate_var_q(vk) &
	generate_var_q2(vd)
	---------------------
	is_var_q DAE.VAR(id,vk,vd,_,_,_)

end
relation generate_var_q : DAE.VarKind => () =

  axiom	generate_var_q DAE.VARIABLE
(*  axiom	generate_var_q DAE.PARAM *)
  axiom	generate_var_q DAE.CONST 

end

relation generate_var_q2 : DAE.VarDirection => () =

  axiom	generate_var_q2 DAE.OUTPUT
  axiom	generate_var_q2 DAE.BIDIR

end


relation generate_result_vars : (DAE.Element list,string, int) 
	  => (CFunction, int) =

  axiom	generate_result_vars ([],_,tnr) => (c_empty_function,tnr)

  rule	generate_result_var (first,varname,tnr) => (cfn1,tnr1) &
	generate_result_vars (rest,varname,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------------------
	generate_result_vars (first :: rest,varname,tnr) => (cfn,tnr2)

end

relation generate_result_var : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => false &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list([varname,".",cref_str1," = ",cref_str2,";"])
	  =>stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array id => true &
	is_first_in_array id => true &
	dae_type_str (typ, true) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list(["copy_",typ_str,"_data(&",
			cref_str1,", &",varname,".",cref_str2,");"]) 
	  => stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array id => true &
	is_first_in_array id => false
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (c_empty_function,tnr)

  axiom	generate_result_var (_,_,tnr) => (c_empty_function,tnr)

end


(* LS: ATT! These can only be assignments for the moment, 
 since no sorting or solving exists *)

relation generate_equations : DAE.Element list => () =

  axiom	generate_equations []

  rule	indent 2 & 
	Exp.print_exp e1 &
	print " = " &
	Exp.print_exp e2 &
	print ";\n" &
	generate_equations rest
	------------------
	generate_equations DAE.EQUATION(e1,e2) :: rest

  rule	generate_equations rest
	-----------------------
	generate_equations _ :: rest

end






(*******************************)
(* LS: Copied from dae.rml     *)
(* and maybe modified slightly *)
(*******************************)



(** relation: pp_statement
 **
 ** Prettyprint an algorithm statement
 **)

relation pp_statement : Algorithm.Statement => () =

  rule	pp_stmt (alg,2)
	--------------
	pp_statement alg

end

relation pp_stmt : (Algorithm.Statement, int) => () =

  rule	indent i &
	Exp.print_component_ref c &
	print " = " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN(_,c,e), i)

  rule	indent i &
	Exp.print_component_ref c &
	print " = " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN_ARR(_,c,e), i)

  rule	indent i &
 	print "if " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i) &
	indent i & print "end if;\n"
        -------------------
	pp_stmt (Algorithm.IF(e,then,else), i)
	
  rule	indent i &
	print "for " & print id & print " in " &
 	Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end for;\n"
        -------------------
	pp_stmt (Algorithm.FOR(id,e,stmts), i)
	
  rule	indent i &
	print "while " & Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end while;\n"
        -------------------
	pp_stmt (Algorithm.WHILE(e,stmts), i)
	
  rule	indent i &
	print "when " & Exp.print_exp e & print " do\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end when;\n"
        -------------------
	pp_stmt (Algorithm.WHEN(e,stmts), i)
	
  rule	indent i & print "**ALGORITHM**;\n"
	----------------------------------
	pp_stmt (_,i)

end

relation pp_stmt_list : (Algorithm.Statement list, int) => () =

  axiom	pp_stmt_list ([],_)

  rule	pp_stmt (stmt,i) & pp_stmt_list(stmts,i)
	--------------------------------
	pp_stmt_list (stmt::stmts,i)

end

relation pp_else : (Algorithm.Else, int) => () =

  axiom	pp_else (Algorithm.NOELSE, _)

  rule	indent i &
 	print "elseif " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i)
        -----------------
	pp_else (Algorithm.ELSEIF(e,then,else), i)

  rule	indent i &
 	print "else\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i')
        ------------------------
	pp_else (Algorithm.ELSE(stmts), i)

end

relation indent : int => () =

  axiom indent 0

  rule	print " " & int_sub(i,1) => i' & indent i'
	------------------------------------------
	indent i
end

(***********************************)
(* / LS: End of copy from dae.rml  *)
(***********************************)





relation generate_exp : Exp.Exp => () =

  rule	print "{" &
	Exp.print_list (es, generate_exp, ", ") &
	print "}"
	---------------------------------------
	generate_exp Exp.ARRAY(es)

  rule	Exp.print_exp e
	---------------
	generate_exp e

end



relation get_array_dim : Types.Type => int =

  axiom	get_array_dim Types.T_ARRAY(Types.DIM(SOME(ad)), ty2) => ad

	(** LS: Fail if not array, or if there is no dim value **)

end




relation generate_expressions : (Exp.Exp list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_expressions ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (f,tnr) => (cfn1,var1,tnr1) &
	generate_expressions(r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn 
	----
	generate_expressions (f::r,tnr) => (cfn,var1::vars2,tnr2)

end




(*
 generate_expression

 returns
   CFunction | the generated code
   string    | expression result variable name, or c expression
   int       | next temporary number 
*)
 
relation generate_expression : (Exp.Exp, int) => (CFunction,string,int) =
(*	  => (string list, string list, string list, string, int) =*)
	  
  rule	int_string i => istr
	-----------------------------------------------------
	generate_expression(Exp.ICONST(i),tnr) => (c_empty_function,istr,tnr)

  rule	real_string r => rstr
	------------------
	generate_expression(Exp.RCONST(r),tnr) => (c_empty_function,rstr,tnr)
	
  rule	print "# sconst not implemented\n"
	-------------------------
	generate_expression(Exp.SCONST(_),_) => fail

  rule	Util.if(b,"(1)","(0)") => var
	-------------------------
	generate_expression(Exp.BCONST(b),tnr) => (c_empty_function,var,tnr)

  rule	generate_rhs_cref(cref, t, tnr) => (cfn,var,tnr')
	-------------------------------------------------
	generate_expression(Exp.CREF(cref,t),tnr) => (cfn,var,tnr')

  rule	generate_binary(e1,op,e2,tnr) => (cfn, var, tnr')
	-------------------------------------------------
	generate_expression(Exp.BINARY(e1,op,e2),tnr) => (cfn, var, tnr')

  rule	print "# unary not implemented\n"
	-------------------------
	generate_expression(Exp.UNARY(_,_),_) => fail

  rule	generate_lbinary(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LBINARY(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_lunary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LUNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_relation(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.RELATION(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	generate_temp_decl("modelica_boolean",tnr1) => (decl,tvar,tnr1') &
	Util.string_append_list([tvar," = ",var1,";"]) => b_stmt &
	Util.string_append_list(["if (",tvar,") {"]) => if_begin &
	c_add_statements(cfn1,[b_stmt,if_begin]) => cfn1'' &
	c_add_variables(cfn1'',[decl]) => cfn1' &	

	generate_expression(then,tnr1') => (cfn2,var2,tnr2) &
	c_add_statements(cfn2,["}","else {"]) => cfn2' &

	generate_expression(else,tnr2) => (cfn3,var3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1',cfn2',cfn3']) => cfn &

	Util.string_append_list(["((",tvar,")?",var2,":",var3,")"]) => var	
	-------------------------
	generate_expression(Exp.IFEXP(e,then,else),tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = ",fn_name,"(", args_str,");"])
	  => stmt &

	c_add_statements(cfn2,[stmt]) => cfn &

	Util.string_append_list([tvar,".",ret_type,"_1"]) => var
	-------------------------
	generate_expression(Exp.CALL(fn,args,false),tnr) => (cfn,var,tnr2)

rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = ",fn_name,"(", args_str,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn
	-------------------------
	generate_expression(Exp.CALL(fn,args,true),tnr) => (cfn,tvar,tnr2)

  rule	print "# array not implemented\n"
	-------------------------
	generate_expression(Exp.ARRAY(_),_) => fail

  rule	print "# matrix not implemented\n"
	-------------------------
	generate_expression(Exp.MATRIX(_),_) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) 	
	-------------------------
	generate_expression(Exp.RANGE(t,e1,NONE,e2),tnr) => fail

  rule	print "# tuple not implemented\n"
	-------------------------
	generate_expression(Exp.TUPLE(_),_) => fail

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_int)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.INT,e),tnr) => (cfn,var',tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_real)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.REAL,e),tnr) => (cfn,var',tnr')

  rule	print "# asub not implemented\n"
	-------------------------
	generate_expression(Exp.ASUB(_,_),_) => fail

  
  rule	Debug.fprintln("ccode","# generate_expression failed") &
	Debug.fcall("ccode",Exp.print_exp,e) &
	Debug.fprintln("ccode","")
	----------------
	generate_expression(e,_) => fail
end


(*

 generate_binary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_binary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =
	  
  rule	generate_expression(e1,tnr ) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) => (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," + ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.ADD(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," - ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.SUB(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," * ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.MUL(_),e2,tnr) => (cfn,var,tnr2)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," / ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.DIV(_),e2,tnr) => (cfn,var,tnr2)

  rule	print "# pow not implemented yet"
	-------------------------------
	generate_binary(e1,Exp.POW(_),e2,tnr) => fail

  rule	print "# Unary minus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UMINUS(_),_,_) => fail
	
  rule	print "# Unary plus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UPLUS(_),_,_) => fail
		
  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_real_array(&",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.REAL),e2, tnr) => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_real_array(&",var1,", &",
			var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.INT),e2, tnr)
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_real_array(",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_integer_array(",var1,
		       ", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_real_scalar_product(&",var1,
			", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.REAL),e2, tnr)
	  => (cfn,var,tnr2)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_integer_scalar_product(&",var1,
		       ", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_matrix_product_smart(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_matrix_product_smart(&",
				 var1,", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	print "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	print "# pow_array not implemented\n"
	-------------------------
	generate_binary(_,Exp.POW_ARR(_),_,_) => fail

  rule	print "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	print "# generate_binary failed\n"
	-------------------------
	generate_binary(_,_,_,_) => fail



end

relation generate_temp_decl : (string, int) => (string, string, int) =
	 
  rule	int_string(tnr) => tnr_str &
	int_add(tnr,1) => tnr' &
	string_append("tmp",tnr_str) => tmp_name &
	Util.string_append_list([t," ",tmp_name,";"]) => t' 
	------------------------------	
	generate_temp_decl(t, tnr) => (t', tmp_name, tnr')

end
 
relation generate_scalar_lhs_cref : (Exp.Type, Exp.ComponentRef, int)
	  => (CFunction, string, int) =

  rule	Debug.fprintln("gcge","generating cref ccode") &
	ident_cstr id => cid
	--------------------
	generate_scalar_lhs_cref(_,Exp.CREF_IDENT(id,[]),tnr)
	  => (c_empty_function,cid,tnr)

  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
  
  rule	print "# generate_scalar_lhs_cref failed\n"
	-----------------------------
	generate_scalar_lhs_cref(_,_,_) => fail

end

relation generate_rhs_cref : (Exp.ComponentRef, Exp.Type, int) 
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[]) 
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => true &
	generate_scalar_rhs_cref(cref_str,crt, subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => false &
	generate_array_rhs_cref(cref_str,crt,subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

end

relation subs_to_scalar : Exp.Subscript list => bool =

  axiom subs_to_scalar [] => true
  axiom subs_to_scalar Exp.SLICE(_)::_ => false
  axiom	subs_to_scalar Exp.WHOLEDIM::_ => false

  rule	subs_to_scalar r => b
	---------------------
	subs_to_scalar Exp.INDEX(_)::r => b

end

relation generate_scalar_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)
end

relation generate_array_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_index_spec(subs,tnr) => (cfn1,spec1,tnr1) &
	exp_type_str(crt,true) => array_type_str &
	generate_temp_decl(array_type_str,tnr1) => (decl,temp,tnr2) &
	Util.string_append_list(["index_alloc_",array_type_str,"(&",cref_str,
				 ", ",spec1,", ",temp,");"]) => stmt &
	c_add_variables(cfn1,[decl]) => cfn'&
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------------------------
	generate_array_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn,temp,tnr2)
end

relation generate_index_spec : (Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices_array(subs,tnr) => (cfn1,idxs1,tnr1) &
	generate_temp_decl("index_spec_t",tnr1) => (decl,spec,tnr2) &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	Util.string_append_list(["create_index_spec(&",
				 spec,", ",idxs_str,");"]) => stmt &
  
	c_add_variables(cfn1,[decl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	
	---------------------------------------------
	generate_index_spec (subs, tnr) => (cfn,spec,tnr2)

  rule	print "# generate_index_spec failed\n"
	-----------------------------
	generate_index_spec(_,_) => fail

end

relation generate_indices_array : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices_array ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index_array(f,tnr) => (cfn1,idx1, tnr1) &
	generate_indices_array(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices_array (f::r, tnr) => (cfn,idxs,tnr2)

  rule	print "# generate_indices_array failed\n"
	-----------------------------
	generate_indices_array(_,_) => fail

end

relation generate_indices : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index(f,tnr) => (cfn1, idx1, tnr1) &
	generate_indices(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices (f::r, tnr) => (cfn,idxs,tnr2)

  rule	print "# generate_indices failed\n"
	-----------------------------
	generate_indices(_,_) => fail

end

relation generate_index_array : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1) &
	Util.string_append_list(["make_index_array(",var1,")"]) => idx1
	------------------------------------
	generate_index_array(Exp.INDEX(e), tnr) 
	  => (cfn,idx1,tnr1)

  rule	let idx1 = "(0)"
	------------------------------------
	generate_index_array(Exp.WHOLEDIM, tnr) 
	  => (c_empty_function,idx1,tnr)

	  
  rule	print "# generate_index_array failed\n"
	-----------------------------
	generate_index_array(_,_) => fail

end

relation generate_index : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1)	
	------------------------------------
	generate_index(Exp.INDEX(e), tnr) => (cfn,var1,tnr1)

  rule	print "# generate_index failed\n"
	-----------------------------
	generate_index(_,_) => fail

end

relation indent_strings : string list => string list =

  axiom	indent_strings [] => []

  rule	string_append("  ",f) => f' &
	indent_strings r => r'
	-----------------------------
	indent_strings f::r => f'::r'
	
end

relation ident_cstr : string => string =
  axiom ident_cstr s => s
end

relation comp_ref_cstr : Exp.ComponentRef => (string, Exp.Subscript list) =

  rule	ident_cstr id => id_str
	---------------------
	comp_ref_cstr Exp.CREF_IDENT(id,subs) => (id_str,subs)

  rule	ident_cstr id => id_str &
	comp_ref_cstr cref => (cref_str,cref_subs) &
	Util.string_append_list([id,"__",cref_str]) => cref_str' &
	Util.list_flatten([subs,cref_subs]) => subs'
	------------------------------
	comp_ref_cstr Exp.CREF_QUAL(id,subs,cref) => (cref_str',subs')

end


(*

 generate_lbinary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_lbinary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.AND,e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.OR,e2,tnr) => (cfn, var, tnr2)


  rule	print "# generate_lbinary failed\n"
	-----------------------------
	generate_lbinary (_,_,_,_) => fail

end

(*

 generate_lunary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_lunary : (Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	Util.string_append_list(["(!",var1,")"]) => var
	-------
	generate_lunary (Exp.NOT,e,tnr) => (cfn1, var, tnr1)


  rule	print "# generate_lbinary failed\n"
	-----------------------------
	generate_lunary (_,_,_) => fail

end

(*

 generate_relation

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_relation : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	print "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESS(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	print "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATER(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	print "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	print "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && !",var2,") || (",
			var1," && ",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	print "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," == ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	print "# Reals can't be compared with ==\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.REAL),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && ",var2,") || (",
			var1," && !",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	print "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," != ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	print "# Reals can't be compared with <>\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.REAL),e2,tnr) => fail


  rule	print "# generate_relation failed\n"
	-----------------------------
	generate_relation (_,_,_,_) => fail

end

(* generate_read_call_write(fpath,outvars,retstr,args) => rcw_fn *)
relation generate_read_call_write : (string,
				     DAE.Element list,
				     string,
				     DAE.Element list)
	=> CFunction =


  rule	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES",
			       out_decl]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)
	generate_vars(invars,is_rcw_input,1) => (cfn3,tnr2) &
	c_add_statements(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &
	invar_names invars => in_names &
	Util.string_delimit_list(in_names,", ") => in_args &
	
	generate_read(invars) => cfn4 &
	Util.string_append_list(["out = ",fnname,"(",in_args,");"]) => fn_call &
	c_add_statements(cfn4,["PRE_READ_DONE",
			       fn_call,
			       "PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE",
			       "return 0;"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',cfn4',cfn5']) => cfn 
	------------------------------------------------------
	generate_read_call_write(fnname,outvars,retstr,invars) => cfn

end

relation invar_names : DAE.Element list => string list =

  axiom	invar_names [] => []


  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	invar_names r => r'
	----------
	invar_names DAE.VAR(id,vk,DAE.INPUT,t,_,_)::r => cref_str::r'

  rule	invar_names r => cfn
	-------
	invar_names _::r => cfn


end

relation generate_read : DAE.Element list => CFunction =

  axiom	generate_read [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["read_",type_string,"(in_file, &",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,[])::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["read_",type_string,"(in_file, &",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,_::_)::r => cfn

	
  rule	generate_read r => cfn
	-------
	generate_read _::r => cfn


end


relation generate_write : DAE.Element list => CFunction =

  axiom	generate_write [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,[])::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,_::_)::r => cfn

	
  rule	generate_write r => cfn
	-------
	generate_write _::r => cfn


end

relation is_rcw_output : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_output_var e
	--------------------
	is_rcw_output e 

end

relation is_rcw_input : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_input_var e
	--------------------
	is_rcw_input e 

end
