(**
 ** file:	 codegen.rml
 ** module:      Codegen
 ** description: Generate code from DAE (Flat Modelica)
 **
 ** RCS: $Id$
 **
 **)


module Codegen :

  with "dae.rml"
  with "exp.rml"
  with "types.rml"
  with "algorithm.rml"

  type Ident = string

  type ReturnType          = string
  type FunctionName        = string
  type ArgumentDeclaration = string
  type VariableDeclaration = string
  type InitStatement       = string
  type Statement           = string
  type CleanupStatement    = string
  type ReturnTypeStruct    = string list

  datatype CFunction = CFUNCTION of 
                         ReturnType *
                         FunctionName * 
                         ReturnTypeStruct *
                         (ArgumentDeclaration list) *
                         (VariableDeclaration list) *
                         (InitStatement       list) *
                         (Statement           list) *
                         (CleanupStatement    list)

  

  relation generate_functions : DAE.DAElist => ()

  relation string_prefix_component_refs : (string, 
					   (Exp.ComponentRef, 'b) => (), 
					   'b, 
					   Exp.Exp list) => Exp.Exp list

  relation string_prefix_component_ref : (string, 
					  (Exp.ComponentRef, 'b) => (), 
					  'b, 
					  Exp.Exp) => Exp.Exp

  relation string_prefix_elements : (string, 
				     DAE.Element list, 
				     DAE.Element list) => DAE.Element list

  relation string_prefix_params : DAE.DAElist => DAE.DAElist

	  
end


with "dump.rml"
with "debug.rml"
with "staticexp.rml"
with "inst.rml"
with "rtopts.rml"
with "absyn.rml"
with "classinf.rml"



relation list_flatten : 'a list list => 'a list =

  axiom	list_flatten [] => []

  rule	list_flatten r => r' &
	list_append(f,r') => l
	-----------------------
	list_flatten f::r => l

end

relation list_map : ('a list, 'a => 'b) => 'b list =
	
  axiom	list_map ([],_) => []

  rule	fn f => f' &
	list_map(r,fn) => r'
	-------------------
	list_map (f::r,fn) => f'::r'

end

relation if : (bool,'a,'a) => 'a =
	
  axiom	if (true,r,_) => r
  axiom	if (false,_,r) => r

end

val c_empty_function = CFUNCTION("","",[],[],[],[],[],[])

relation c_make_function : (ReturnType,
			    FunctionName,
			    ReturnTypeStruct,
			    ArgumentDeclaration list)
	  => CFunction =

  axiom	c_make_function (rt,fn,rts,ads) => CFUNCTION(rt,fn,rts,ads,[],[],[],[])

end

relation c_add_variables : (CFunction, VariableDeclaration list) => CFunction =

  rule	list_append(vd,nvd) => vd'
	--------------------------
	c_add_variables (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nvd)
			 => CFUNCTION(rt,fn,rts,ads,vd',is,st,cl)

end


relation c_add_inits : (CFunction, InitStatement list) => CFunction =

  rule	list_append(is,nis) => is'
	--------------------------
	c_add_inits (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nis)
			 => CFUNCTION(rt,fn,rts,ads,vd,is',st,cl)

end

relation c_add_statements : (CFunction, Statement list) => CFunction =

  rule	list_append(st,nst) => st'
	--------------------------
	c_add_statements (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nst)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st',cl)

end

relation c_add_cleanups : (CFunction, CleanupStatement list) => CFunction =

  rule	list_append(cl,ncl) => cl'
	--------------------------
	c_add_cleanups (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),ncl)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st,cl')

end

relation c_merge_fns : CFunction list => CFunction =
	
  axiom	c_merge_fns [] => c_empty_function

  rule	c_merge_fns r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	c_merge_fns cfn1::r => cfn

end

relation c_merge_fn : (CFunction, CFunction) => CFunction =

  rule	list_append(vd1,vd2) => vd &
	list_append(is1,is2) => is &
	list_append(st1,st2) => st &
	list_append(cl1,cl2) => cl 	
	-----------------------------
	c_merge_fn (CFUNCTION(rt,fn,rts,ad,vd1,is1,st1,cl1),
		    CFUNCTION(_ , _, _ , _,vd2,is2,st2,cl2)) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)
			 
end

relation c_print_functions : CFunction list => () =

  axiom	c_print_functions []

  rule	c_print_function(f) &
	c_print_functions(r)
	---------------------
	c_print_functions f::r
end

relation c_print_function : CFunction => () =

  rule	Dump.print_list(rts,print,"\n") & print "\n" &
	Dump.print_list([rt," ",fn,"("],print,"") &
	Dump.print_list(ad,print,", ") & print ")\n{\n  " &
	Dump.print_list(vd,print,"\n  ") & print "\n  " &
	Dump.print_list(is,print,"\n  ") & print "\n  " &
	Dump.print_list(st,print,"\n  ") & print "\n  " &
	Dump.print_list(cl,print,"\n  ") & print "\n" &
	print "}\n"
	-----------
	c_print_function CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)

end

relation generate_functions : DAE.DAElist => () =

  rule	Debug.fprintln ("cgtr", "generate_functions") &
	generate_functions_elist elist => cfns &
	print "#include \"modelica.h\"\n" &
	c_print_functions cfns &
	print "\n"
	------------------------------
	generate_functions DAE.DAE(elist)

  rule	print "#--- generate_functions failed\n"
	--------------------------------------
	generate_functions _ 

end



relation generate_functions_elist : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") 
	----------------------------------------------------
	generate_functions_elist [] => []

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") &
	generate_function f => cfns1 &
	generate_functions_elist rest => cfns2 &
	list_append(cfns1,cfns2) => cfns
	----------------------------
	generate_functions_elist f :: rest => cfns
	
end

relation generate_params_type : Ident => string =

  rule	string_append (n, "_params") => s
	---------------------------------
	generate_params_type n => s

end


relation generate_function : DAE.Element => CFunction list =

  (* rule	path_string fpath => fstr & *)
(* 	Debug.fprintl ("cg", ["generating function ", fstr, "\n"]) & *)

(* 	DAE.get_output_vars dae => [outvar] & *)
(* 	generate_simple_type   restype => retstr & *)
(* 	generate_function_name fpath   => fn_name_str &  *)
(* 	list_map(args, generate_function_arg) => arg_strs & *)
	
(* 	c_make_function (retstr, fn_name_str, arg_strs) => cfn & *)

(* 	append_strings([retstr," ",fn_name_str,"(",args_str,")"],"")  *)
(* 	  => decl_str & *)

(* 	generate_function_body (fpath, dae, outvar, restype) => body_strs & *)

(* 	list_flatten([[decl_str],body_strs]) => fn_strs *)
(* 	----------------------------------------------------------------- *)
(* 	generate_function DAE.FUNCTION(fpath,  *)
(* 				       DAE.DAE(dae),  *)
(* 				       Types.T_FUNCTION(args,restype)) *)
(* 	  => fn_strs *)

  rule	path_string fpath => fstr &
	Debug.fprintl ("cg", ["generating function ", fstr, "\n"]) &


	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath           => retstr &
	generate_function_name fpath           => fn_name_str & 
	list_map(args, generate_function_arg)  => arg_strs &

	c_make_function(retstr, fn_name_str, struct_strs,arg_strs)=> head_cfn &

	generate_function_body_tuple(fpath, dae, restype) => body_cfn &

	c_merge_fn(head_cfn,body_cfn) => cfn &
	
	generate_read_call_write(fn_name_str,outvars,retstr,invars) => rcw_fn
	---------------------------
	generate_function DAE.FUNCTION(fpath, 
				       DAE.DAE(dae), 
				       Types.T_FUNCTION(args,restype)) 
	  => [cfn,rcw_fn]


  rule	generate_functions_elist daelist => cfns
	----------------------
	generate_function DAE.COMP(n, DAE.DAE(daelist)) => cfns

	(* for non-function elements *)

  axiom	generate_function _ => []
	
end


relation generate_params_struct : (DAE.Element list, Ident) => () =

  rule	DAE.get_matching_elements ( daelist, DAE.is_parameter ) => params &
	(* list_length params => nbrparams &
	int_gt (nbrparams, 0) => true & *) (* if we do this we have to modify the function 
					    * declaration as well *)
	generate_params_type n => ptname &
	print "typedef struct " & print ptname & print "_s {\n" &
	generate_param_decls params &
	print "} " & print ptname & print ";\n"
	-----------------------------------------
	generate_params_struct (daelist, n)

(*
  rule	DAE.get_matching_elements ( daelist, DAE.is_parameter ) => params &
	list_length params => nbrparams &
	int_le (nbrparams, 0) => true &
	print "#-- no params in " &
	print n &
	print "\n"
	-----------------------------------------
	generate_params_struct (daelist, n)
*)

end


relation generate_param_decls : DAE.Element list => () =

  axiom	generate_param_decls []

  rule	Debug.fprintln ("cgtr", "generate_param_decls-1") &
	generate_param_decl first &
	generate_param_decls rest
	------------------
	generate_param_decls first :: rest

end


relation generate_param_decl: DAE.Element => () =

  rule	Debug.fprintln ("cgtr", "generate_param_decl-1") &
	indent 2 &
	DAE.dump_type typ &
	Exp.print_component_ref id &
	print ";\n"
	-----------
	generate_param_decl DAE.VAR(id, DAE.PARAM, _, typ, _,_)

  rule	print "#-- generate_param_decl didn't match" &
	DAE.dump_debug DAE.DAE([d])
	---------------------------
	generate_param_decl d

end

relation generate_params_init_fkn : (DAE.Element list, Ident) => () =

  rule	DAE.get_matching_elements ( daelist, DAE.is_parameter ) => params &
	generate_params_type n => ptname &
	print "void " & print ptname & print "_init (" & 
	print ptname & print " *params) {\n" &
	generate_param_inits ("params->", params) &
	print "}\n"
	-----------------------------------------
	generate_params_init_fkn (daelist, n)

end

relation generate_params_init_fkn_decl : (DAE.Element list, Ident) => () =

  rule	DAE.get_matching_elements ( daelist, DAE.is_parameter ) => params &
	generate_params_type n => ptname &
	print "void " & print ptname & print "_init (" & 
	print ptname & print " *params);\n"
	-----------------------------------------
	generate_params_init_fkn_decl (daelist, n)

end


relation generate_param_inits : (string, DAE.Element list) => () =

  axiom	generate_param_inits (_, [])

  rule	Debug.fprintln ("cgtr", "generate_param_inits-1") &
	generate_param_init (str, first) &
	generate_param_inits (str, rest)
	------------------
	generate_param_inits (str, first :: rest)

end

relation generate_param_init: (string, DAE.Element) => () =

  rule	Debug.fprintln ("cgtr", "generate_param_init-1") &
	indent 2 &
	print str &
	Exp.print_component_ref id &
	print " = " &
	print_exp_no_funcall e &
	print ";\n"
	-----------
	generate_param_init (str, DAE.VAR(id, DAE.PARAM, _, _, SOME(e),_))


	(** What to do if there is no value for the parameter?
	 set to zero, or don't generate initialization at all? **)

  rule	Debug.fprintln ("cgtr", "generate_param_init-2") &
	indent 2 &
	print str &
	Exp.print_component_ref id &
	print " = 0" &
	print ";\t\t/* uninitialized, set to zero by modeq */\n"
	-----------
	generate_param_init (str, DAE.VAR(id, DAE.PARAM, _, typ, NONE,_))


  rule	print "#-- generate_param_decl didn't match" &
	DAE.dump_debug DAE.DAE([d])
	---------------------------
	generate_param_init (_, d)

end


relation generate_result_struct : (DAE.Element list, Absyn.Path) 
	  => string list =

  rule	generate_return_type fpath => ptname &
	generate_return_decls outvars => var_strs &
	indent_strings var_strs => var_strs' &
	append_strings(["typedef struct ",ptname,"_s"],"") => first_row &
	append_strings(["} ",ptname,";"],"") => last_row &
	list_flatten([[first_row,"{"],var_strs',[last_row]]) => strs
	-----------------------------------------
	generate_result_struct (outvars, fpath) => strs

(*
  rule	DAE.get_vars ( daelist, DAE.is_parameter ) => params &
	list_length params => nbrparams &
	int_le (nbrparams, 0) => true &
	print "#-- no params in " &
	print n &
	print "\n"
	-----------------------------------------
	generate_params_struct (daelist, n)
*)

end



relation generate_return_decls : DAE.Element list => string list =

  axiom	generate_return_decls [] => []

  rule	generate_return_decl first => "" &
	generate_return_decls rest => rs
	------------------
	generate_return_decls first :: rest => rs

  rule	generate_return_decl first => fs &
	generate_return_decls rest => rs
	------------------
	generate_return_decls first :: rest => fs::rs

end


relation generate_return_decl: DAE.Element => string =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	list_map(inst_dims,int_string) => dim_strs &
	append_strings(dim_strs," * ") => dims_str &
	append_strings([typ_str," ",id_str,";"," /* [",dims_str,"] */"],"") 
	  => decl_str
	---------------------------------------------------
	generate_return_decl (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, NONE,inst_dims))
	  => decl_str

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	append_strings([typ_str," ",id_str,";"],"") => decl_str &
	print "# default/init values not implemented yet: " &
	Exp.print_exp e &
	print "\n"
	-----------
	generate_return_decl (DAE.VAR(id, 
				      DAE.VARIABLE, 
				      DAE.OUTPUT, 
				      typ, 
				      SOME(e),
				      _))
	=> decl_str


  axiom	generate_return_decl (_) => ""

end

relation is_array : Exp.ComponentRef => bool =
	
  axiom	is_array Exp.CREF_IDENT(_,[]) => false
  axiom	is_array Exp.CREF_IDENT(_,_::_) => true
  axiom	is_array Exp.CREF_QUAL(_,_::_,_) => true

  rule	is_array cref => b
	------------------
	is_array Exp.CREF_QUAL(_,[],cref) => b

end

relation is_first_in_array : Exp.ComponentRef => bool =

  axiom	is_first_in_array Exp.CREF_IDENT(_,[]) => true

  rule	subs_is_one subs => b
	---------------------
	is_first_in_array Exp.CREF_IDENT(_,subs) => b

  rule	is_first_in_array cref => b
	---------------------------
	is_first_in_array Exp.CREF_QUAL(_,[],cref) => b

  rule	subs_is_one subs => b1 &
	is_first_in_array cref => b2 &
	bool_and(b1,b2) => b
	------------------------------
	is_first_in_array Exp.CREF_QUAL(_,subs,cref) => b
end

relation subs_is_one : Exp.Subscript list => bool =

  axiom subs_is_one [] => true

  rule	subs_is_one r => b
	------------------
	subs_is_one Exp.INDEX(Exp.ICONST(1))::r => b

  axiom	subs_is_one _::_ => false

end


relation dae_type_str : (DAE.Type, bool) => string =

  axiom	dae_type_str (DAE.INT, false) => "modelica_integer"
  axiom	dae_type_str (DAE.REAL, false) => "modelica_real"
  axiom	dae_type_str (DAE.STRING, false) => "modelica_string"
  axiom	dae_type_str (DAE.BOOL, false) => "modelica_boolean"

  axiom	dae_type_str (DAE.INT, true) => "integer_array"
  axiom	dae_type_str (DAE.REAL, true) => "real_array"
  axiom	dae_type_str (DAE.STRING, true) => "string_array"
  axiom	dae_type_str (DAE.BOOL, true) => "boolean_array"

end

relation exp_type_str : (Exp.Type, bool) => string =

  axiom	exp_type_str (Exp.INT, false) => "modelica_integer"
  axiom	exp_type_str (Exp.REAL, false) => "modelica_real"
  axiom	exp_type_str (Exp.STRING, false) => "modelica_string"
  axiom	exp_type_str (Exp.BOOL, false) => "modelica_boolean"
  axiom	exp_type_str (Exp.OTHER, false) => "modelica_other"

  axiom	exp_type_str (Exp.INT, true) => "integer_array"
  axiom	exp_type_str (Exp.REAL, true) => "real_array"
  axiom	exp_type_str (Exp.STRING, true) => "string_array"
  axiom	exp_type_str (Exp.BOOL, true) => "boolean_array"
  axiom	exp_type_str (Exp.OTHER, true) => "other_array"

end

relation generate_type : Types.Type => string =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => ty_str 
	---------------------------
	generate_type Types.T_TUPLE(tys) => ty_str


  rule	Debug.fprintln ("cgtr", "generate_type") &
	flatten_array_type tys => (arrayty, dims) &
	generate_array_type (arrayty, dims) => ty_str
	-----------------------------------
	generate_type (tys as Types.T_ARRAY(_,_)) => ty_str


  axiom	generate_type Types.T_INTEGER => "modelica_integer"
  axiom generate_type Types.T_REAL => "modelica_real"
  axiom	generate_type Types.T_STRING => "modelica_string"
  axiom	generate_type Types.T_BOOL => "modelica_boolean"


  rule	print "#-- generate_type failed: " &
	Types.print_type ty & print "\n"
	--------------------------------
	generate_type ty => fail

end


relation generate_return_type : Absyn.Path => string =

  rule	path_string fpath => fstr &
	string_append (fstr, "_rettype" ) => res
	--------------------------
	generate_return_type fpath => res
end

(*
relation generate_return_type : Types.Type => () =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => str &
	print str
	---------------------------
	generate_return_type Types.T_TUPLE(tys)


  rule	Debug.fprintln ("cgtr", "generate_type") &
	flatten_array_type tys => (arrayty, dims) &
	generate_array_return_type (arrayty, dims)
	-----------------------------------
	generate_return_type (tys as Types.T_ARRAY(_,_))


  rule	print "#-- generate_type failed\n" &
	Types.print_type ty & print "\n"
	--------------------------------
	generate_return_type ty => fail

end
*)

relation flatten_array_type : Types.Type => (Types.Type, int list) =

  rule	Debug.fprintln ("cgtr", "flatten_array_type1") &
	flatten_array_type ty => (ty', dimlist')
	--------------------------------------
  	flatten_array_type Types.T_ARRAY(Types.DIM(NONE), ty) => (ty', dimlist')

  rule	Debug.fprintln ("cgtr", "flatten_array_type2") &
	flatten_array_type ty => (ty', dimlist) &
	list_append (dimlist,[dim]) => dimlist'
	--------------------------------------
  	flatten_array_type Types.T_ARRAY(Types.DIM(SOME(dim)), ty) => (ty', dimlist')

  axiom	flatten_array_type ty => (ty, [])

end

relation generate_array_type : (Types.Type, int list) => string =

(*
  rule	Types.print_type ty &
	print "[" & Dump.print_list (dims, print_int, ",") & print "]" 
	-------------------------------------------------------------
	generate_array_type (ty, dims)
*)
  rule	array_type_string ty => str 
	--------------------------
	generate_array_type (ty, dims) => str
end

relation generate_array_return_type : (Types.Type, int list) => string =

  rule	array_type_string ty => ty_str
	-------------------------------
	generate_array_return_type (ty, dims) => ty_str

end

relation print_int : int => () =

  rule	int_string i => str &
	print str
	---------
	print_int i
end

relation print_star : int => () =

  rule	print "*"
	---------
	print_star i

end



relation generate_tuple_type : Types.Type list => string =


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_1") &
	generate_simple_type ty => str
	--------------------------------
	generate_tuple_type [ty] => str


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_2") &
	generate_simple_type ty => str &
	generate_tuple_type tys => str' &
	string_append (str, str') => str'' &
	string_append ("struct ", str'') => str'''
	----------------------------------
	generate_tuple_type (ty::tys) => str'''

end



relation generate_simple_type : Types.Type => string =

  axiom	generate_simple_type Types.T_INTEGER => "modelica_integer"
  axiom	generate_simple_type Types.T_REAL => "modelica_real"
  axiom	generate_simple_type Types.T_STRING => "modelica_string"
  axiom	generate_simple_type Types.T_BOOL => "modelica_boolean"

  rule	string_append ("const ", n) => n' &
	string_append (n', "&") => n''
	------------------------------
	generate_simple_type Types.T_COMPLEX (ClassInf.RECORD(n),_) => n''

  rule	Types.array_element_type t => t' &
	array_type_string t' => t_str
	-----------------------
	generate_simple_type (t as Types.T_ARRAY(_,_)) => t_str

  rule	print "#--generate_simple_type failed " &
	Types.print_type ty & 
	print "\n"
	--------------------------------------
	generate_simple_type ty => fail
end

relation array_type_string : Types.Type => string =

  axiom	array_type_string Types.T_INTEGER => "integer_array"
  axiom	array_type_string Types.T_REAL => "real_array"
  axiom	array_type_string Types.T_STRING => "string_array"
  axiom	array_type_string Types.T_BOOL => "boolean_array"

end

relation generate_function_name : Absyn.Path => string =

  rule	path_string fpath => fstr 
	----------
	generate_function_name fpath => fstr

end



relation generate_function_arg : Types.FuncArg => string =

  rule	generate_tuple_type [ty] => str &
	string_append (str, " ") => str' &
	string_append (str', name) => str''
	-----------------------------------
	generate_function_arg ((name, ty)) => str''

end




relation generate_function_body_tuple : (Absyn.Path, 
					 DAE.Element list, 
					 Types.Type) 
	  => CFunction =
	  
  rule	Debug.fprintln ("cgtr", "generate_function_body_tuple") &
	
	let tnr = 1 &

	generate_return_type fpath => ret_type_str &
	generate_temp_decl(ret_type_str,tnr) => (ret_decl, ret_var, tnr_ret') &
	append_strings(["return ",ret_var,";"],"") => ret_stmt &

	DAE.get_output_vars dae => outvars &
	generate_alloc_outvars(outvars,ret_decl,ret_var,tnr_ret')
	  => (out_fn,tnr_ret) &

	generate_temp_decl("state",tnr_ret) 
	      => (mem_decl, mem_var, tnr_mem) &
	append_strings([mem_var," = get_memory_state();"],"") => mem_stmt1 &
	append_strings(["restore_memory_state(",mem_var,");"],"") =>mem_stmt2 &

	c_add_variables (out_fn, [mem_decl])  => mem_fn' &
	c_add_inits     (mem_fn',[mem_stmt1]) => mem_fn &

	generate_vars        (dae, is_var_q, tnr_mem)=> (var_fn,tnr_var) &
	generate_algorithms  (dae, tnr_var)          => (alg_fn,tnr_alg) &
	generate_result_vars (dae, ret_var, tnr_alg) => (res_var_fn,tnr_res) &
	
	c_merge_fn(mem_fn, var_fn)     => cfn' &
	c_merge_fn(cfn'  , alg_fn)     => cfn'' &
	c_merge_fn(cfn'' , res_var_fn) => cfn''' &

	c_add_cleanups(cfn''',[mem_stmt2,ret_stmt]) => cfn
	--------------
	generate_function_body_tuple (fpath, dae, restype) => cfn

end

relation generate_alloc_outvars : (DAE.Element list, string, string,int) 
	  => (CFunction,int) =

	  
  rule	c_add_variables(c_empty_function,[rd]) => cfn
	---------
	generate_alloc_outvars([],rd,rv,tnr) => (cfn,tnr)

  rule	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars(r,rd,rv,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------
	generate_alloc_outvars ((var as DAE.VAR(cr,vk,vd,t,e,id))::r,
				rd,rv,tnr)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars(r,rd,rv,tnr) => (cfn2,tnr2)
	--------------
	generate_alloc_outvars (_::r,rd,rv,tnr) => (cfn2,tnr2)

end

relation generate_alloc_outvar : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	list_map(inst_dims,int_string) => dim_strs &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	append_strings(dim_strs,", ") => dims_str &
	append_strings(["alloc_",typ_str,
			"(&",prefix,".",cref_str,", ",
			ndims_str,", ",dims_str,");"],"")
	  => alloc_str &
	  
	  c_add_inits(c_empty_function,[alloc_str]) => cfn' &
	if (is_a,cfn',c_empty_function) => cfn
	-----------
	generate_alloc_outvar(DAE.VAR(id, vk, vd, typ, e,inst_dims),
			      prefix,
			      tnr) 
	  => (cfn,tnr)

  axiom	generate_alloc_outvar (_,_,tnr) => (c_empty_function,tnr)

end

relation prefix_cr : (string, Exp.ComponentRef) => Exp.ComponentRef =

  axiom	prefix_cr (prf,cref) 
	  => Exp.CREF_QUAL(prf,[],cref)
	  
end

relation generate_algorithms: (DAE.Element list, int)
	  => (CFunction, int) =

  axiom	generate_algorithms ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm (first,tnr) => (cfn1,tnr1) &
	generate_algorithms (rest,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------
	generate_algorithms (first::rest, tnr) => (cfn,tnr2)

end



relation generate_algorithm: (DAE.Element, int)
	  => (CFunction, int) =

  rule	generate_algorithm_statements (stmts,tnr) => (cfn,tnr') 
	----------------------------------------
	generate_algorithm (DAE.ALGORITHM(Algorithm.ALGORITHM(stmts)),tnr)
	  => (cfn,tnr')

  axiom	generate_algorithm (_,tnr) => (c_empty_function,tnr)

end

relation generate_algorithm_statements : (Algorithm.Statement list, int)
	  => (CFunction, int) =

  axiom	generate_algorithm_statements ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm_statement (f,tnr) => (cfn1,tnr1) &
	generate_algorithm_statements(r,tnr1) =>(cfn2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn
	-----------
	generate_algorithm_statements (f::r, tnr) => (cfn,tnr2)
end
(*
 relation : generate_algorithm_statement

 returns:
   string list  | Constructing code, variables, defines
   string list  | Executing code
   string list  | Destructing code, undefines 
   string       | expression result: variable name, or 'c' expression
   int          | next temporary number 
 *)

relation generate_algorithm_statement : (Algorithm.Statement, int)
	  => (CFunction, int) =

  rule	Debug.fprintln("cgas","generate_algorithm_statement") &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_scalar_lhs_cref(typ,cref,tnr1)
	  => (cfn2,var2,tnr2) &
	append_strings([var2," = ",var1,";"],"") => stmt &

	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	----------------
	generate_algorithm_statement (Algorithm.ASSIGN(typ,cref,exp),tnr)
	  => (cfn, tnr2)

  rule	comp_ref_cstr cref => (cref_str,[]) &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(typ,true) => type_str &
	append_strings(["copy_",type_str,"_data(&",
			var1,", &",cref_str,");"],"") => stmt &
	  c_add_statements(cfn1,[stmt]) => cfn2
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn2,tnr1)

  rule	comp_ref_cstr cref => (cref_str,subs as _::_) &
	
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_index_spec(subs,tnr1) => (cfn2,var2,tnr2) &
	exp_type_str(typ,true) => type_str &
	append_strings(["indexed_assign_",type_str,"(&",
			var1,", &",cref_str,", ",var2,");"],"") => stmt &

	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn,tnr2)

  rule	print "# if statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.IF(_,_,_),_) => fail

  rule	print "# for statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(_,_,_),_) => fail

  rule	print "# while statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.WHILE(_,_),_) => fail

  rule	print "# when statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.WHEN(_,_),_) => fail

  rule	print "# generate_algorithm_statement failed\n"
	-------------------------
	generate_algorithm_statement (_,_) => fail

end

relation generate_vars : (DAE.Element list,DAE.Element => (),int) => (CFunction,int) =

  axiom	generate_vars ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var (first,tnr)  => (cfn1,tnr1) & 
	generate_vars (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_vars (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	print "# generate_vars failed\n"
	---------------------------------
	generate_vars (_,_,_) => fail
	
end


relation generate_var : (DAE.Element,int) => (CFunction,int) =
(*
 parameters are put in the params struct

  rule	generate_var_q2 (vd) &
	indent 2 &
	DAE.dump_type typ &
	Exp.print_component_ref id &
	print " = 0;  /* Warning: without value, set to zero */\n"
	-----------
	generate_var(DAE.VAR(id, DAE.PARAM, vd, typ, NONE,_))
*)

  rule	is_first_in_array id => false
	-----------------------------
	generate_var(DAE.VAR(id,_,_,_,_,_),tnr) => (c_empty_function,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	list_map(inst_dims,int_string) => dim_strs &
	append_strings(dim_strs,", ") => dims_str &
	append_strings([" /* [",dims_str,"] */"],"") => dim_comment &
	if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	append_strings([typ_str," ",cref_str,";",dim_comment'],"")=> decl_str &
	append_strings(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dims_str,");"],"") => alloc_str &
	c_add_variables(c_empty_function,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	if (is_a,cfn'',cfn') => cfn
	----------------------------------------------------
	generate_var(DAE.VAR(id, vk, vd, typ, NONE,inst_dims),tnr) => (cfn,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	list_map(inst_dims,int_string) => dim_strs &
	append_strings(dim_strs,", ") => dims_str &
	append_strings([" /* [",dims_str,"] */"],"") => dim_comment &
	if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	append_strings([typ_str," ",cref_str,";",dim_comment'],"")=> decl_str &
	append_strings(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dims_str,");"],"") => alloc_str &
	c_add_variables(c_empty_function,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	if (is_a,cfn'',cfn') => cfn &
	print "# default value not implemented yet: " &
	Exp.print_exp e & print "\n"
	-----------
	generate_var(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) 
	  => (cfn,tnr)

  
  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	append_strings([typ_str," ",cref_str,";"],"") => decl_str &
	generate_expression(e,tnr) => (cfn,var,tnr1) &
	c_add_variables(cfn,[decl_str]) => cfn' &
	append_strings([cref_str," = ",var,";"],"") => init_stmt &
	c_add_inits(cfn',[init_stmt]) => cfn'' &
	print "# default value not implemented yet: " &
	Exp.print_exp e & print "\n"
	-----------
	generate_var(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) => (cfn'',tnr1)
	
  rule	print "# generate_var failed\n  " &
	DAE.dump_debug_element e & print "\n"
	-----------------------------------
	generate_var (e,_) => fail
end


relation is_var_q : DAE.Element => () =

  rule	generate_var_q(vk) &
	generate_var_q2(vd)
	---------------------
	is_var_q DAE.VAR(id,vk,vd,_,_,_)

end
relation generate_var_q : DAE.VarKind => () =

  axiom	generate_var_q DAE.VARIABLE
(*  axiom	generate_var_q DAE.PARAM *)
  axiom	generate_var_q DAE.CONST 

end

relation generate_var_q2 : DAE.VarDirection => () =

  axiom	generate_var_q2 DAE.OUTPUT
  axiom	generate_var_q2 DAE.BIDIR

end


relation generate_result_vars : (DAE.Element list,string, int) 
	  => (CFunction, int) =

  axiom	generate_result_vars ([],_,tnr) => (c_empty_function,tnr)

  rule	generate_result_var (first,varname,tnr) => (cfn1,tnr1) &
	generate_result_vars (rest,varname,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------------------
	generate_result_vars (first :: rest,varname,tnr) => (cfn,tnr2)

end

relation generate_result_var : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => false &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	append_strings([varname,".",cref_str1," = ",cref_str2,";"],"") =>stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array id => true &
	is_first_in_array id => true &
	dae_type_str (typ, true) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	append_strings(["copy_",typ_str,"_data(&",
			cref_str1,", &",varname,".",cref_str2,");"],"") 
	  => stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array id => true &
	is_first_in_array id => false
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (c_empty_function,tnr)

  axiom	generate_result_var (_,_,tnr) => (c_empty_function,tnr)

end


(* LS: ATT! These can only be assignments for the moment, 
 since no sorting or solving exists *)

relation generate_equations : DAE.Element list => () =

  axiom	generate_equations []

  rule	indent 2 & 
	Exp.print_exp e1 &
	print " = " &
	Exp.print_exp e2 &
	print ";\n" &
	generate_equations rest
	------------------
	generate_equations DAE.EQUATION(e1,e2) :: rest

  rule	generate_equations rest
	-----------------------
	generate_equations _ :: rest

end






(*******************************)
(* LS: Copied from dae.rml     *)
(* and maybe modified slightly *)
(*******************************)



(** relation: pp_statement
 **
 ** Prettyprint an algorithm statement
 **)

relation pp_statement : Algorithm.Statement => () =

  rule	pp_stmt (alg,2)
	--------------
	pp_statement alg

end

relation pp_stmt : (Algorithm.Statement, int) => () =

  rule	indent i &
	Exp.print_component_ref c &
	print " = " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN(_,c,e), i)

  rule	indent i &
	Exp.print_component_ref c &
	print " = " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN_ARR(_,c,e), i)

  rule	indent i &
 	print "if " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i) &
	indent i & print "end if;\n"
        -------------------
	pp_stmt (Algorithm.IF(e,then,else), i)
	
  rule	indent i &
	print "for " & print id & print " in " &
 	Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end for;\n"
        -------------------
	pp_stmt (Algorithm.FOR(id,e,stmts), i)
	
  rule	indent i &
	print "while " & Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end while;\n"
        -------------------
	pp_stmt (Algorithm.WHILE(e,stmts), i)
	
  rule	indent i &
	print "when " & Exp.print_exp e & print " do\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end when;\n"
        -------------------
	pp_stmt (Algorithm.WHEN(e,stmts), i)
	
  rule	indent i & print "**ALGORITHM**;\n"
	----------------------------------
	pp_stmt (_,i)

end

relation pp_stmt_list : (Algorithm.Statement list, int) => () =

  axiom	pp_stmt_list ([],_)

  rule	pp_stmt (stmt,i) & pp_stmt_list(stmts,i)
	--------------------------------
	pp_stmt_list (stmt::stmts,i)

end

relation pp_else : (Algorithm.Else, int) => () =

  axiom	pp_else (Algorithm.NOELSE, _)

  rule	indent i &
 	print "elseif " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i)
        -----------------
	pp_else (Algorithm.ELSEIF(e,then,else), i)

  rule	indent i &
 	print "else\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i')
        ------------------------
	pp_else (Algorithm.ELSE(stmts), i)

end

relation indent : int => () =

  axiom indent 0

  rule	print " " & int_sub(i,1) => i' & indent i'
	------------------------------------------
	indent i
end

(***********************************)
(* / LS: End of copy from dae.rml  *)
(***********************************)



relation find_var : (DAE.Element list, Exp.ComponentRef) => DAE.Element option =

  axiom	find_var ([], _) => NONE

  rule	Exp.cref_equal (cr1, cr2) => true
	--------------------
	find_var ((e as DAE.VAR(cr1, vk, vd, ty, value,_))::rest, cr2) => SOME(e)

  rule	find_var (rest, cr) => e'
	----------------------------
	find_var (_::rest, cr) => e'

end



relation generate_exp : Exp.Exp => () =

  rule	print "{" &
	Exp.print_list (es, generate_exp, ", ") &
	print "}"
	---------------------------------------
	generate_exp Exp.ARRAY(es)

  rule	Exp.print_exp e
	---------------
	generate_exp e

end



relation get_array_dim : Types.Type => int =

  axiom	get_array_dim Types.T_ARRAY(Types.DIM(SOME(ad)), ty2) => ad

	(** LS: Fail if not array, or if there is no dim value **)

end


relation string_prefix_component_refs : (string, (Exp.ComponentRef, 'b) => (), 'b, Exp.Exp list) 
	  => Exp.Exp list =

  axiom	string_prefix_component_refs (_, _, _, []) => []
	
  rule	string_prefix_component_refs (str, r, rarg, rest) => res &
	string_prefix_component_ref (str, r, rarg, e) => e'
	----------------------------------------------
	string_prefix_component_refs (str, r, rarg, e::rest) => e'::res
end


relation string_prefix_component_ref : (string, (Exp.ComponentRef, 'b) => (), 'b, Exp.Exp) 
	  => Exp.Exp =

  rule	r(cr, rarg) &
	string_prefix_cref (str, cr) => cr'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.CREF(cr,t)) 
	  => Exp.CREF(cr',t)

  rule	not r(cr, rarg)
	----------------------------------------------
	string_prefix_component_ref (_, r, rarg, Exp.CREF(cr,t)) 
	  => Exp.CREF(cr,t)

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.BINARY(e1,op,e2)) 
	  => Exp.BINARY(e1',op,e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.UNARY(op,e1)) 
	  => Exp.UNARY(op,e1')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.LBINARY(e1,op,e2)) 
	  => Exp.LBINARY(e1',op,e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.LUNARY(op,e1)) 
	  => Exp.LUNARY(op,e1')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.RELATION(e1,op,e2)) 
	  => Exp.RELATION(e1',op,e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2' &
	string_prefix_component_ref (str, r, rarg, e3) => e3'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.IFEXP(e1,e2,e3)) 
	  => Exp.IFEXP(e1',e2',e3')

  rule	string_prefix_component_refs (str, r, rarg, el) => el'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.CALL(p, el)) 
	  => Exp.CALL(p, el')

  rule	string_prefix_component_refs (str, r, rarg, el) => el'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.ARRAY(el)) 
	  => Exp.ARRAY(el')

  rule	string_prefix_component_refs_list (str, r, rarg, ell) => ell'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.MATRIX(ell)) 
	  => Exp.MATRIX(ell')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.RANGE(e1, NONE, e2))
	  => Exp.RANGE(e1', NONE, e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2' &
	string_prefix_component_ref (str, r, rarg, e3) => e3'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.RANGE(e1, SOME(e2), e3))
	  => Exp.RANGE(e1', SOME(e2'), e3')

  rule	string_prefix_component_refs (str, r, rarg, el) => el'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.TUPLE(el)) 
	  => Exp.TUPLE(el')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.CAST(ty, e1)) 
	  => Exp.CAST(ty, e1')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.ASUB(e1, i)) 
	  => Exp.ASUB(e1', i)

  axiom	string_prefix_component_ref (str, r, rarg, e) => e

end

relation string_prefix_component_refs_list : 
	(string, (Exp.ComponentRef, 'b) => (), 'b, Exp.Exp list list) => Exp.Exp list list =

  axiom string_prefix_component_refs_list (_, _, _, []) => []

  rule	string_prefix_component_refs (str, r, rarg, el) => el' &
	string_prefix_component_refs_list (str, r, rarg, rest) => res
	----------------------------------------------------
	string_prefix_component_refs_list (str, r, rarg, el::rest) => el'::res

end

relation string_prefix_cref : (string, Exp.ComponentRef) 
	  => Exp.ComponentRef =

  rule	string_append (str, s) => s'
	-----------------------
	string_prefix_cref (str, Exp.CREF_IDENT(s, si)) => Exp.CREF_IDENT(s', si)

  rule	string_append (str, s) => s'
	-----------------------
	string_prefix_cref (str, Exp.CREF_QUAL(s, si, cr)) 
	  => Exp.CREF_QUAL(s', si, cr)

end


relation string_prefix_elements : (string, DAE.Element list, DAE.Element list) 
	  => DAE.Element list =

  axiom	string_prefix_elements (_, _, []) => []

  rule	string_prefix_element (str, dae, el) => el' &
	string_prefix_elements (str, dae, rest) => res
	-----------------------------------------
	string_prefix_elements (str, dae, el::rest) => el'::res

end

relation string_prefix_element : (string, DAE.Element list, DAE.Element) 
	  => DAE.Element =


  rule	string_prefix_component_ref (str, is_parameter_daelist, dae, exp) => exp'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.VAR(cr,vk,vd,ty,SOME(exp),inst_dims)) 
	  => DAE.VAR(cr,vk,vd,ty,SOME(exp'),inst_dims)

  rule	string_prefix_component_ref (str, is_parameter_daelist, dae, exp) => exp'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.DEFINE(cr,exp)) 
	  => DAE.DEFINE(cr,exp')

  rule	string_prefix_component_ref (str, is_parameter_daelist, dae, exp1) 
	  => exp1' &
	string_prefix_component_ref (str, is_parameter_daelist, dae, exp2) 
	  => exp2'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.EQUATION(exp1,exp2)) 
	  => DAE.EQUATION(exp1',exp2')

  rule	string_prefix_algorithm (str, dae, alg) => alg'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.ALGORITHM(alg)) 
	  => DAE.ALGORITHM(alg')


(** What happens if a variable is not found among dae, should we check dae1,
    i.e. where the COMP and FUNCTION was found? **)
  rule	string_prefix_elements (str, dae, dae) => dae'
	----------------------------------------------
	string_prefix_element (str, dae1, DAE.COMP(n, DAE.DAE(dae))) 
	  => DAE.COMP(n, DAE.DAE(dae'))

  rule	string_prefix_elements (str, dae, dae) => dae'
	----------------------------------------------
	string_prefix_element (str, dae1, DAE.FUNCTION(n, DAE.DAE(dae), ty)) 
	  => DAE.FUNCTION(n, DAE.DAE(dae'), ty)

  axiom	string_prefix_element (str, dae, e) => e

end


relation string_prefix_algorithm : (string, DAE.Element list, Algorithm.Algorithm) 
	  => Algorithm.Algorithm =

  axiom	string_prefix_algorithm (str, dae, alg) => alg

end


relation is_parameter_daelist : (Exp.ComponentRef, DAE.Element list) => () =

  rule	Exp.cref_equal (cr, crv) => true
	------------------------
	is_parameter_daelist (cr, DAE.VAR(crv,DAE.PARAM,vd,ty,e,_)::rest)

  rule	Exp.cref_equal (cr, crv) => true
	------------------------
	is_parameter_daelist (cr, DAE.VAR(crv,vk,vd,ty,e,_)::rest) => fail

  rule	is_parameter_daelist (cr, rest)
	-------------------------------
	is_parameter_daelist (cr, e::rest)

end

relation string_prefix_params : DAE.DAElist => DAE.DAElist =

  rule	string_prefix_elements ("params->", dae, dae) => dae'
	-----------------------------------------------------
	string_prefix_params DAE.DAE(dae) => DAE.DAE(dae')

end


relation get_component_ref_next : Exp.ComponentRef => Exp.ComponentRef =

  axiom	get_component_ref_next Exp.CREF_QUAL(n, sl, cr) => cr
  rule	print "#-- Cannot get subname of an unqualified component reference\n" &
	Exp.print_component_ref cr
	----------------------------------------------------------------------
	get_component_ref_next (cr as Exp.CREF_IDENT(n, sl)) => fail

end

relation get_var_value_expr : (DAE.Element list, Exp.ComponentRef) 
	  => Exp.Exp =

  rule	find_var (dae, cr) => SOME(DAE.VAR(cr2, vk, vd, ty, NONE,_)) &
	print "#-- get_var_value_expr: Warning: Variable is not initialized\n" &
	Exp.print_component_ref cr & print "\n"
	---------------------------------------------------------
	get_var_value_expr (dae, cr) => Exp.SCONST("UNDEF")


  rule	find_var (dae, cr) => SOME(DAE.VAR(cr2, vk, vd, ty, SOME(value),_))
	---------------------------------------------------------
	get_var_value_expr (dae, cr) => value

  rule	print "#-- get_var_value_expr: Error: Variable not found\n" &
	Exp.print_component_ref cr & print "\n"
	---------------------------------------
	get_var_value_expr (dae, cr) => fail

end


relation print_exp_no_funcall : Exp.Exp => () =

  rule	path_string(fcn) => fs &
	print fs
	--------
	print_exp_no_funcall Exp.CALL(fcn, args)

  rule	Exp.print_exp e
	---------------
	print_exp_no_funcall e
	
end


relation path_string: Absyn.Path => string =

  axiom	path_string(Absyn.IDENT(s)) => s
  
  rule	RTOpts.modelica_output => true &
	path_string(n) => ns &
	string_append(s,"__") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(Absyn.QUALIFIED(s,n)) => ss

  rule	RTOpts.modelica_output => false &
	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(Absyn.QUALIFIED(s,n)) => ss
	
end






(*
 generate_expression

 returns
   CFunction | the generated code
   string    | expression result variable name, or c expression
   int       | next temporary number 
*)
 
relation generate_expression : (Exp.Exp, int) => (CFunction,string,int) =
(*	  => (string list, string list, string list, string, int) =*)
	  
  rule	int_string i => istr
	-----------------------------------------------------
	generate_expression(Exp.ICONST(i),tnr) => (c_empty_function,istr,tnr)

  rule	real_string r => rstr
	------------------
	generate_expression(Exp.RCONST(r),tnr) => (c_empty_function,rstr,tnr)
	
  rule	print "# sconst not implemented\n"
	-------------------------
	generate_expression(Exp.SCONST(_),_) => fail

  rule	print "# bconst not implemented\n"
	-------------------------
	generate_expression(Exp.BCONST(_),_) => fail

(*  rule	Debug.fprintln("gcge","generating cref ccode")
	------------------------------------------------
	generate_expression(Exp.CREF(Exp.CREF_IDENT(id,[]),t),tnr)
	  => ([],[],[],id,tnr)
*)

  rule	generate_rhs_cref(cref, t, tnr) => (cfn,var,tnr')
	-------------------------------------------------
	generate_expression(Exp.CREF(cref,t),tnr) => (cfn,var,tnr')

  rule	generate_binary(e1,op,e2,tnr) => (cfn, var, tnr')
	-------------------------------------------------
	generate_expression(Exp.BINARY(e1,op,e2),tnr) => (cfn, var, tnr')

  rule	print "# unary not implemented\n"
	-------------------------
	generate_expression(Exp.UNARY(_,_),_) => fail

  rule	print "# lbinary not implemented\n"
	-------------------------
	generate_expression(Exp.LBINARY(_,_,_),_) => fail

  rule	print "# lunary not implemented\n"
	-------------------------
	generate_expression(Exp.LUNARY(_,_),_) => fail

  rule	print "# relation not implemented\n"
	-------------------------
	generate_expression(Exp.RELATION(_,_,_),_) => fail

  rule	print "# if not implemented\n"
	-------------------------
	generate_expression(Exp.IFEXP(_,_,_),_) => fail

  rule	print "# call not implemented\n"
	-------------------------
	generate_expression(Exp.CALL(_,_),_) => fail

  rule	print "# array not implemented\n"
	-------------------------
	generate_expression(Exp.ARRAY(_),_) => fail

  rule	print "# matrix not implemented\n"
	-------------------------
	generate_expression(Exp.MATRIX(_),_) => fail

  rule	print "# range not implemented\n"
	-------------------------
	generate_expression(Exp.RANGE(_,_,_),_) => fail

  rule	print "# tuple not implemented\n"
	-------------------------
	generate_expression(Exp.TUPLE(_),_) => fail

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	append_strings(["((modelica_int)",var,")"],"") => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.INT,e),tnr) => (cfn,var',tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	append_strings(["((modelica_real)",var,")"],"") => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.REAL,e),tnr) => (cfn,var',tnr')

  rule	print "# asub not implemented\n"
	-------------------------
	generate_expression(Exp.ASUB(_,_),_) => fail

  
  rule	Debug.fprintln("ccode","# generate_expression failed") &
	Debug.fcall("ccode",Exp.print_exp,e) &
	Debug.fprintln("ccode","")
	----------------
	generate_expression(e,_) => fail
end


(*

 generate_binary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_binary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =
	  
  rule	generate_expression(e1,tnr ) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) => (cfn2,var2,tnr2) &
	append_strings(["(",var1," + ",var2,")"],"") => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.ADD(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	append_strings(["(",var1," - ",var2,")"],"") => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.SUB(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	append_strings(["(",var1," * ",var2,")"],"") => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.MUL(_),e2,tnr) => (cfn,var,tnr2)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	append_strings(["(",var1," / ",var2,")"],"") => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.DIV(_),e2,tnr) => (cfn,var,tnr2)

  rule	print "# pow not implemented yet"
	-------------------------------
	generate_binary(e1,Exp.POW(_),e2,tnr) => fail

  rule	print "# Unary minus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UMINUS(_),_,_) => fail
	
  rule	print "# Unary plus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UPLUS(_),_,_) => fail
		
  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	append_strings(["add_alloc_real_array(&",var1,
			", &",var2,", &",var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.REAL),e2, tnr) => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	append_strings(["add_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	append_strings(["sub_alloc_real_array(&",var1,", &",
			var2,", &", var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	append_strings(["sub_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.INT),e2, tnr)
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	append_strings(["mul_alloc_scalar_real_array(",var1,
			", &",var2,", &",var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	append_strings(["mul_alloc_scalar_integer_array(",var1,
		       ", &",var2,", &",var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	append_strings(["mul_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	append_strings(["mul_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	append_strings(["mul_real_scalar_product(&",var1,
			", &",var2,")"],"") => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.REAL),e2, tnr)
	  => (cfn,var,tnr2)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	append_strings(["mul_integer_scalar_product(&",var1,
		       ", &",var2,")"],"") => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	append_strings(["mul_alloc_real_matrix_product(&",var1,
			", &",var2,", &", var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	append_strings(["mul_alloc_integer_matrix_product_smart(&",var1,
			", &",var2,", &", var,");"],"") => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	print "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	print "# pow_array not implemented\n"
	-------------------------
	generate_binary(_,Exp.POW_ARR(_),_,_) => fail

  rule	print "# and not implemented\n"
	-------------------------
	generate_binary(_,Exp.AND,_,_) => fail
  
  rule	print "# or not implemented\n"
	-------------------------
	generate_binary(_,Exp.OR,_,_) => fail
	
  rule	print "# not not implemented\n"
	-------------------------
	generate_binary(_,Exp.NOT,_,_) => fail

  rule	print "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	print "# less not implemented\n"
	-------------------------
	generate_binary(_,Exp.LESS(_),_,_) => fail

  rule	print "# lesseq not implemented\n"
	-------------------------
	generate_binary(_,Exp.LESSEQ(_),_,_) => fail

  rule	print "# greater not implemented\n"
	-------------------------
	generate_binary(_,Exp.GREATER(_),_,_) => fail

  rule	print "# greatereq not implemented\n"
	-------------------------
	generate_binary(_,Exp.GREATEREQ(_),_,_) => fail

  rule	print "# equal not implemented\n"
	-------------------------
	generate_binary(_,Exp.EQUAL(_),_,_) => fail

  rule	print "# nequal not implemented\n"
	-------------------------
	generate_binary(_,Exp.NEQUAL(_),_,_) => fail


  rule	print "# generate_binary failed\n"
	-------------------------
	generate_binary(_,_,_,_) => fail



end

relation generate_temp_decl : (string, int) => (string, string, int) =
	 
  rule	int_string(tnr) => tnr_str &
	int_add(tnr,1) => tnr' &
	string_append("tmp",tnr_str) => tmp_name &
	append_strings([t," ",tmp_name,";"],"") => t' 
	------------------------------	
	generate_temp_decl(t, tnr) => (t', tmp_name, tnr')

end
 
relation generate_scalar_lhs_cref : (Exp.Type, Exp.ComponentRef, int)
	  => (CFunction, string, int) =

  rule	Debug.fprintln("gcge","generating cref ccode") &
	ident_cstr id => cid
	--------------------
	generate_scalar_lhs_cref(_,Exp.CREF_IDENT(id,[]),tnr)
	  => (c_empty_function,cid,tnr)

  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	append_strings(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	append_strings(["(*",type_str,"_element_addr(&",id,
			", ",idxs_str,"))"],"") => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
  
  rule	print "# generate_scalar_lhs_cref failed\n"
	-----------------------------
	generate_scalar_lhs_cref(_,_,_) => fail

end

relation generate_rhs_cref : (Exp.ComponentRef, Exp.Type, int) 
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[]) 
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => true &
	generate_scalar_rhs_cref(cref_str,crt, subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => false &
	generate_array_rhs_cref(cref_str,crt,subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

end

relation subs_to_scalar : Exp.Subscript list => bool =

  axiom subs_to_scalar [] => true
  axiom subs_to_scalar Exp.SLICE(_)::_ => false
  axiom	subs_to_scalar Exp.WHOLEDIM::_ => false

  rule	subs_to_scalar r => b
	---------------------
	subs_to_scalar Exp.INDEX(_)::r => b

end

relation generate_scalar_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	append_strings(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	append_strings(["(*",array_type_str,"_element_addr(&",cref_str,
			", ",idxs_str,"))"],"") => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)
end

relation generate_array_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_index_spec(subs,tnr) => (cfn1,spec1,tnr1) &
	exp_type_str(crt,true) => array_type_str &
	generate_temp_decl(array_type_str,tnr1) => (decl,temp,tnr2) &
	append_strings(["index_alloc_",array_type_str,"(&",cref_str,
			", ",spec1,", ",temp,");"],"") => stmt &
	c_add_variables(cfn1,[decl]) => cfn'&
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------------------------
	generate_array_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn,temp,tnr2)
end

relation generate_index_spec : (Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices_array(subs,tnr) => (cfn1,idxs1,tnr1) &
	generate_temp_decl("index_spec_t",tnr1) => (decl,spec,tnr2) &
	append_strings(idxs1,", ") => idxs_str &
	append_strings(["create_index_spec(&",spec,", ",idxs_str,");"],"")
	  => stmt &
  
	  c_add_variables(cfn1,[decl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	
	---------------------------------------------
	generate_index_spec (subs, tnr) => (cfn,spec,tnr2)

  rule	print "# generate_index_spec failed\n"
	-----------------------------
	generate_index_spec(_,_) => fail

end

relation generate_indices_array : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices_array ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index_array(f,tnr) => (cfn1,idx1, tnr1) &
	generate_indices_array(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices_array (f::r, tnr) => (cfn,idxs,tnr2)

  rule	print "# generate_indices_array failed\n"
	-----------------------------
	generate_indices_array(_,_) => fail

end

relation generate_indices : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index(f,tnr) => (cfn1, idx1, tnr1) &
	generate_indices(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices (f::r, tnr) => (cfn,idxs,tnr2)

  rule	print "# generate_indices failed\n"
	-----------------------------
	generate_indices(_,_) => fail

end

relation generate_index_array : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1) &
	append_strings(["make_index_array(",var1,")"],"") => idx1
	------------------------------------
	generate_index_array(Exp.INDEX(e), tnr) 
	  => (cfn,idx1,tnr1)

  rule	append_strings(["(0)"],"") => idx1
	------------------------------------
	generate_index_array(Exp.WHOLEDIM, tnr) 
	  => (c_empty_function,idx1,tnr)

	  
  rule	print "# generate_index_array failed\n"
	-----------------------------
	generate_index_array(_,_) => fail

end

relation generate_index : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1)	
	------------------------------------
	generate_index(Exp.INDEX(e), tnr) => (cfn,var1,tnr1)

  rule	print "# generate_index failed\n"
	-----------------------------
	generate_index(_,_) => fail

end

relation append_strings : (string list, string) => string =
	
  axiom append_strings([],_) => ""

  axiom	append_strings([f],delim) => f

  rule	append_strings(r,delim) => str1 &
	string_append(f,delim) => str2 &
	string_append(str2,str1) => str
	---------------------------
	append_strings(f::r,delim) => str

end

relation indent_strings : string list => string list =

  axiom	indent_strings [] => []

  rule	string_append("  ",f) => f' &
	indent_strings r => r'
	-----------------------------
	indent_strings f::r => f'::r'
	
end

relation ident_cstr : string => string =
  axiom ident_cstr s => s
end

relation comp_ref_cstr : Exp.ComponentRef => (string, Exp.Subscript list) =

  rule	ident_cstr id => id_str
	---------------------
	comp_ref_cstr Exp.CREF_IDENT(id,subs) => (id_str,subs)

  rule	ident_cstr id => id_str &
	comp_ref_cstr cref => (cref_str,cref_subs) &
	append_strings([id,"__",cref_str],"") => cref_str' &
	list_flatten([subs,cref_subs]) => subs'
	------------------------------
	comp_ref_cstr Exp.CREF_QUAL(id,subs,cref) => (cref_str',subs')

end

(* generate_read_call_write(fpath,outvars,retstr,args) => rcw_fn *)
relation generate_read_call_write : (string,
				     DAE.Element list,
				     string,
				     DAE.Element list)
	=> CFunction =


  rule	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	append_strings([retstr," out;"],"") => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES",
			       out_decl]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)
	generate_vars(invars,is_rcw_input,1) => (cfn3,tnr2) &
	c_add_statements(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &
	invar_names invars => in_names &
	append_strings(in_names,", ") => in_args &
	
	generate_read(invars) => cfn4 &
	append_strings(["out = ",fnname,"(",in_args,");"],"") => fn_call &
	c_add_statements(cfn4,["PRE_READ_DONE",
			       fn_call,
			       "PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE",
			       "return 0;"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',cfn4',cfn5']) => cfn 
	------------------------------------------------------
	generate_read_call_write(fnname,outvars,retstr,invars) => cfn

end

relation invar_names : DAE.Element list => string list =

  axiom	invar_names [] => []


  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	invar_names r => r'
	----------
	invar_names DAE.VAR(id,vk,DAE.INPUT,t,_,_)::r => cref_str::r'

  rule	invar_names r => cfn
	-------
	invar_names _::r => cfn


end

relation generate_read : DAE.Element list => CFunction =

  axiom	generate_read [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	append_strings(["read_",type_string,"(in_file, &",cref_str,");"],"")
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,[])::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	dae_type_str(t, true) => type_string &
	append_strings(["read_",type_string,"(in_file, &",cref_str,");"],"")
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,_::_)::r => cfn

	
  rule	generate_read r => cfn
	-------
	generate_read _::r => cfn


end


relation generate_write : DAE.Element list => CFunction =

  axiom	generate_write [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	append_strings(["write_",type_string,"(out_file, &out.",cref_str,");"],"")
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,[])::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	dae_type_str(t, true) => type_string &
	append_strings(["write_",type_string,"(out_file, &out.",cref_str,");"],"")
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,_::_)::r => cfn

	
  rule	generate_write r => cfn
	-------
	generate_write _::r => cfn


end

relation is_rcw_output : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_output_var e
	--------------------
	is_rcw_output e 

end

relation is_rcw_input : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_input_var e
	--------------------
	is_rcw_input e 

end
