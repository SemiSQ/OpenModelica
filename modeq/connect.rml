(**
 ** file: connect.rml
 **)

module Connect :

  with "exp.rml"
  with "staticexp.rml"
  with "dae.rml"

  (* datatype Dir = IN | OUT *)
  datatype Face = INNER | OUTER

  datatype Set = EQU of Exp.ComponentRef list
	       | FLOW of (Exp.ComponentRef * Face) list

  type Sets = Set list

  relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets
  relation add_flow : (Sets,
		       Exp.ComponentRef, Face,
		       Exp.ComponentRef, Face) => Sets
  relation print_sets : Sets => ()
  relation equations : Sets => DAE.DAEcomp list

end

(**
 ** - Adding
 **)

relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets =

  rule	(* print "   add_equ: looking for sets\n" & *)
	find_equ_set(ss,r1) => s1 &
	find_equ_set(ss,r2) => s2 &
	(* print "   add_equ: found, merging\n" & *)
	merge(ss,s1,s2) => ss' (* &
	print_sets ss' *)
	----------------------
	add_equ(ss,r1,r2) => ss'
	
end

relation add_flow : (Sets, Exp.ComponentRef, Face, Exp.ComponentRef, Face)
	  => Sets =

  rule	(* print "   add_flow: looking for sets\n" & *)
	find_flow_set(ss,r1,d1) => s1 &
	find_flow_set(ss,r2,d2) => s2 &
	(* print "   add_flow: found, merging\n" & *)
	merge(ss,s1,s2) => ss' (* &
	print_sets ss' *)
	----------------------
	add_flow(ss,r1,d1,r2,d2) => ss'
	
end

(**
 ** - Dumping
 **)

with "dump.rml"

relation print_sets : Sets => () =

  axiom	print_sets []

  rule	print_set x &
	print_sets xs
	------------
	print_sets x::xs

end
(**)
relation print_set : Set => () =

  rule	print " non-flow set: { " &
	Exp.print_list(cs, Exp.print_component_ref, ", ") &
	print " }\n"
	----------------------------------------------------
	print_set EQU(cs)

  rule	print " flow set: { " &
	Exp.print_list(cs, print_flow_ref, ", ") &
	print " }\n"
	----------------------------------------------------
	print_set FLOW(cs)

end
(**)
relation print_flow_ref : (Exp.ComponentRef * Face) => () =

  rule	Exp.print_component_ref c &
	print " INNER"
	-----------
	print_flow_ref((c,INNER))

  rule	Exp.print_component_ref c &
	print " OUTER"
	-----------
	print_flow_ref((c,OUTER))

end

(**
 ** - Equation generation
 **)

relation equations : Sets => DAE.DAEcomp list =

  axiom	equations [] => []

  rule	equ_equations cs => dae1 &
	equations ss => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations EQU(cs)::ss => dae

  rule	flow_equations cs => dae1 &
	equations ss => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations FLOW(cs)::ss => dae

end

(**)

relation equ_equations : Exp.ComponentRef list => DAE.DAEcomp list =

  axiom	equ_equations [_] => []

  rule	(* FIXME: check types. Must be real. *)
	equ_equations y::cs => eq
	------------------------
	equ_equations x::y::cs => DAE.EQUATION(Exp.RELATION(Exp.CREF(x),
							    Exp.REAL_EQUAL,
							    Exp.CREF(y)))::eq
end
(**)
relation flow_equations : (Exp.ComponentRef * Face) list => DAE.DAEcomp list =

  rule	flow_sum cs => sum
	------------------
	flow_equations cs => [DAE.EQUATION(Exp.RELATION(sum,
							Exp.REAL_EQUAL,
							Exp.RCONST(0.0)))]

end
(**)
relation flow_sum : (Exp.ComponentRef * Face) list => Exp.Exp =

  rule	sign_flow(c,f) => exp
	-------------------
	flow_sum [(c,f)] => exp

  rule	sign_flow(c,f) => exp1 &
	flow_sum cs => exp2
	------------------
	flow_sum ((c,f)::cs) => Exp.BINARY(exp1, Exp.REAL_ADD, exp2)

end
(**)
relation sign_flow : (Exp.ComponentRef, Face) => Exp.Exp =

  axiom	sign_flow (c,INNER) => Exp.CREF(c)
  axiom	sign_flow (c,OUTER) => Exp.UNARY(Exp.UMINUS,Exp.CREF(c))

end

(**
 ** - Lookup
 **)

relation find_in_set_equ : (Exp.ComponentRef list, Exp.ComponentRef) => () =

  rule	StaticExp.eq_cref(c1,c2)
	------------------
	find_in_set_equ(c1::_,c2)

  rule	find_in_set_equ(cs,c2)
	----------------------
	find_in_set_equ(_::cs,c2)

end
(**)
relation find_in_set_flow : ((Exp.ComponentRef * Face) list, Exp.ComponentRef)
	  => () =

  rule	StaticExp.eq_cref(c1,c2)
	------------------
	find_in_set_flow((c1,_)::_,c2)

  rule	find_in_set_flow(cs,c2)
	----------------------
	find_in_set_flow(_::cs,c2)

end
(**)
relation find_in_set : (Set, Exp.ComponentRef) => () =

  rule	find_in_set_equ(cs,c)
	---------------------
	find_in_set(EQU(cs), c)

  rule	find_in_set_flow(cs, c)
	-----------------------
	find_in_set(FLOW(cs), c)

end
(**)
relation new_equ_set : Exp.ComponentRef => Set =

  axiom	new_equ_set c => EQU([c])

end
(**)
relation new_flow_set : (Exp.ComponentRef, Face) => Set =

  axiom	new_flow_set(c,d) => FLOW([(c,d)])

end
(**)
relation find_equ_set : (Sets, Exp.ComponentRef) => Set =

  rule	new_equ_set c => s
	------------------
	find_equ_set([],c) => s

  rule	find_in_set(s,c)
	----------------
	find_equ_set(s::_,c) => s

  rule	find_equ_set(ss,c) => s
	-------------------
	find_equ_set(_::ss,c) => s

end	
(**)
relation find_flow_set : (Sets, Exp.ComponentRef, Face) => Set =

  rule	new_flow_set(c,d) => s
	------------------
	find_flow_set([],c,d) => s

  rule	find_in_set(s,c)
	----------------
	find_flow_set(s::_,c,d) => s

  rule	find_flow_set(ss,c,d) => s
	-------------------
	find_flow_set(_::ss,c,d) => s

end	

(**
 ** - Merge
 **)

relation merge : (Sets, Set, Set) => Sets =

  rule	s1 = s2
	-------
	merge(ss,s1,s2) => ss

  rule	list_append(cs1,cs2) => cs &
	remove_set2(ss,s1,s2) => ss'
	----------------------------
	merge(ss, s1 as EQU(cs1), s2 as EQU(cs2)) => EQU(cs)::ss'

  rule	list_append(cs1,cs2) => cs &
	remove_set2(ss,s1,s2) => ss'
	----------------------------
	merge(ss, s1 as FLOW(cs1), s2 as FLOW(cs2)) => FLOW(cs)::ss'

end

(**)

relation remove_set2 : (Sets, Set, Set) => Sets =

  axiom	remove_set2([],_,_) => []

  rule	s = s1 &
	remove_set(ss,s2) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => ss'
	
  rule	s = s2 &
	remove_set(ss,s1) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => ss'
	
  rule	remove_set2(ss,s1,s2) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => s::ss'

end

relation remove_set : (Sets, Set) => Sets =

  axiom	remove_set([],_) => []

  rule	s = s1
	------
	remove_set(s::ss, s1) => ss
	
  rule	remove_set(ss,s1) => ss'
	------------------------
	remove_set(s::ss, s1) => s::ss'

end
