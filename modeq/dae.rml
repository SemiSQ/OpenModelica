(**
 ** file:	 dae.rml
 ** description: DAE management and output
 **
 ** RCS: $Id$
 **
 ** This file is not really mine.  It will be rewritten later.
 **)

(** - Module header *)

module DAE:
  
  with "absyn.rml"
  with "dump.rml"
  with "exp.rml"
  with "explode.rml"

  type Ident = string

  datatype VarKind = VARIABLE | DISCRETE | PARAM | CONST

  datatype Type = REAL | INT | BOOL | STRING

  datatype DAEcomp = VAR of Exp.ComponentRef * VarKind * Type
			  * Absyn.ArrayDim (*FIXME*)
		   | VARVAL of Ident * VarKind * Exp.Exp
		   | EQUATION of Exp.Exp
		   | ALGORITHM of SCode.Algorithm
		   | COMP of Ident * DAEform
  and	 DAEform = DAE of DAEcomp list
	  
  relation dump: DAEform => ()
	  
end

(** - Relations
 **
 ** The only relations in this module are for printing, and are not
 ** included in the report.
 **)

(*!ignorecode*)

(** relation: dump
 **
 ** This relation prints the DAE in the standard outpur format.
 **)

relation dump: DAEform => () =
	
  rule	print "fclass " & print n & print "\n" &
	dump(l) &
	print "end " & print n & print ";\n"
	-----------------------------------
	dump DAE([COMP(n,l)])

  rule	dump_vars l &
	print "equation\n" &
	dump_equations l &
	dump_algorithms l
	-----------------
	dump DAE(l)

end

relation dump_kind =

  rule	print "  constant  "
	--------------------
	dump_kind CONST
	
  rule	print "  parameter "
	--------------------
	dump_kind PARAM
	
  rule	print "  discrete  "
	--------------------
	dump_kind DISCRETE

  rule	print "            "
	--------------------
	dump_kind VARIABLE

end

relation dump_type =

  rule	print "Integer "
	----------------
	dump_type INT

  rule	print "Real    "
	----------------
	dump_type REAL

  rule	print "Boolean "
	----------------
	dump_type BOOL

  rule	print "String  "
	----------------
	dump_type STRING

end

relation dump_comp: DAEcomp => () =
	
  rule	dump_kind kind & dump_type typ &
 	Exp.print_component_ref id & Dump.print_arraydim ad & print "\n"
	--------------------------------------
	dump_comp(VAR(id, kind, typ, ad))
	
  rule	dump_kind kind & print id &
	print "=" & Exp.print_exp ex & print "\n"
	--------------------------------------
	dump_comp(VARVAL(id, kind, ex))
	
  rule	print "  " & Exp.print_exp eq & print "\n"
	--------------------------------------
	dump_comp(EQUATION(eq))
	
  rule	print "{ begin " & print id & print " }\n" &
	dump contents &
	print "{ end " & print id & print " }\n"
        --------------------------------------
        dump_comp ( COMP(id, contents))

end

relation dump_var : DAEcomp => () =
	
  rule	dump_kind kind & dump_type typ &
 	Exp.print_component_ref id & Dump.print_arraydim ad & print ";\n"
	--------------------------------------
	dump_var(VAR(id, kind, typ, ad))
	
  axiom	dump_var _

end

relation dump_equation : DAEcomp => () =
	
  rule	print "  " & Exp.print_exp eq & print ";\n"
	--------------------------------------
	dump_equation(EQUATION(eq))
	
  axiom	dump_equation _

end

relation dump_algorithm : DAEcomp => () =

  rule	print "algorithm\n" &
	Dump.print_list(alg, pp_algorithm, "")
	----------------------------------------------
	dump_algorithm ALGORITHM(SCode.ALGORITHM(alg))

  axiom	dump_algorithm _

end

relation dump_vars: DAEcomp list => () =
	
  axiom	dump_vars []
	
  rule	dump_var first &
	dump_vars rest
	-------------------
	dump_vars first :: rest

end

relation dump_equations: DAEcomp list => () =
	
  axiom	dump_equations []
	
  rule	dump_equation first &
	dump_equations rest
	-------------------
	dump_equations first :: rest

end

relation dump_algorithms: DAEcomp list => () =
	
  axiom	dump_algorithms []
	
  rule	dump_algorithm first &
	dump_algorithms rest
	-------------------
	dump_algorithms first :: rest

end

(** relation: pp_algorithm
 **
 ** Prettyprint an algorithm element
 **)

relation pp_algorithm : Absyn.Algorithm => () =

  rule	pp_alg (alg,2)
	--------------
	pp_algorithm alg

end

relation pp_alg : (Absyn.Algorithm, int) => () =

  rule	indent i &
	Dump.print_component_ref c &
	print " := " &
	Dump.print_exp e &
	print ";\n"
	----------
	pp_alg (Absyn.ALG_ASSIGN(c,e), i)

  rule	indent i &
	print "while(" & Dump.print_exp e & print ") loop\n" &
	int_add(i,2) => i' &
	pp_alg_list (algs, i') &
	indent i &
	print "end while;\n"
        -------------------
	pp_alg (Absyn.ALG_WHILE(e,algs), i)
	
  rule	indent i & print "**ALGORITHM**;\n"
	----------------------------------
	pp_alg (_,i)

end

relation pp_alg_list : (Absyn.Algorithm list, int) => () =

  axiom	pp_alg_list ([],_)

  rule	pp_alg (alg,i) & pp_alg_list(algs,i)
	--------------------------------
	pp_alg_list (alg::algs,i)

end

relation indent : int => () =

  axiom indent 0

  rule	print " " & int_sub(i,1) => i' & indent i'
	------------------------------------------
	indent i

end
