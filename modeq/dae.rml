(**
 ** file:	 dae.rml
 ** module:      DAE
 ** description: DAE management and output
 **
 ** RCS: $Id$
 ** 
 ** This module defines types for collecting DAE equations together
 ** with declarations of variables.
 **)

(** - Module header *)

module DAE:
  
  with "absyn.rml"
  with "dump.rml"
  with "exp.rml"
  with "explode.rml"
  with "algorithm.rml"
  with "types.rml"
  with "staticexp.rml"

  type Ident = string
  type InstDims = Exp.Subscript list

  datatype VarKind = VARIABLE | DISCRETE | PARAM | CONST

  datatype Type = REAL | INT | BOOL | STRING

(* LS: Added for variables in functions *)
  datatype VarDirection = INPUT | OUTPUT | BIDIR

(* LS: Removed VARVAL completely, and added Exp.Exp as an option to VAR *)
  datatype Element = VAR of Exp.ComponentRef * VarKind * VarDirection * Type * Exp.Exp option * InstDims
		   | DEFINE of Exp.ComponentRef * Exp.Exp
		   | EQUATION of Exp.Exp * Exp.Exp
		   | ALGORITHM of Algorithm.Algorithm
		   | COMP of Ident * DAElist
		   | FUNCTION of Absyn.Path * DAElist * Types.Type



(* 
 LS: Could have extended DAElist to have two lists, one with 
 functions and one with elements, but that would mean a lot of
 change in places where two daes are built and appended, in 
 inst.rml 
 FUNCTION could also consist of SCode.Class instead.
 *)


  datatype DAElist = DAE of Element list
	  
  relation dump: DAElist => ()
  relation dump_debug: DAElist => ()
  relation dump_debug_element : Element => ()
  relation dump_graphviz: DAElist => ()
  relation dump_type: Type => ()
  relation dump_algorithm: Element => ()
  relation get_matching_elements: (Element list, Element => () )  => Element list
  relation get_matching: ('a list, 'a => () )  => 'a list
  relation get_output_vars: Element list  => Element list
  relation get_input_vars: Element list  => Element list
  relation is_algorithm : Element => ()
  relation is_function : Element => ()
  relation is_var: Element => ()
  relation is_output_var: Element => ()
  relation is_input_var: Element => ()
  relation is_parameter: Element => ()
  relation is_comp: Element => ()
  relation find_element: (Element list, Element => ()) => Element option
  relation build_gr_strlist : ('a list, 'a => string, int) => (string list, 'a list)
end


(** - Relations
 **
 ** The only relations in this module are for printing, and are not
 ** included in the report.
 **)

(*!ignorecode*)

with "rtopts.rml"
with "graphviz.rml"

(** relation: dump
 **
 ** This relation prints the DAE in the standard output format.
 **)

relation dump : DAElist => () =

  rule	dump_list (daelist, dump_function) &
	dump_list (daelist, dump_comp_element)
	-------------
	dump DAE(daelist)
end



relation dump_list : ('a list, 'a => ()) => () =

  axiom	dump_list ([],_)

  rule	r(first) &
	dump_list (rest, r)
	-------------------
	dump_list (first::rest, r)

end



relation dump_comp_element : Element => () =

  rule	RTOpts.modelica_output => false &
	print "fclass " & print n & print "\n" &
	dump_elements(l) &
	print "end " & print n & print ";\n"
	-----------------------------------
	dump_comp_element COMP(n,DAE(l))

  rule	RTOpts.modelica_output => true &
	print "class " & print n & print "\n" &
	dump_elements(l) &
	print "end " & print n & print ";\n"
	-----------------------------------
	dump_comp_element COMP(n,DAE(l))

(* LS: for non-COMPS, which are only FUNCTIONS at the moment *)

  axiom	dump_comp_element _

end



relation dump_elements : Element list => () =

  rule	dump_vars l &
	print "equation\n" &
	dump_list (l, dump_equation) &
	dump_list (l, dump_algorithm)
	-----------------
	dump_elements l

end

(* replace this with dump_list when everything works after the VARVAL removal *)
 (* project *)
relation dump_vars: Element list => () =
	
  axiom	dump_vars []
	
  rule	dump_var first &
	dump_vars rest
	-------------------
	dump_vars first :: rest

end



relation dump_kind =

  rule	print " constant  "
	--------------------
	dump_kind CONST
	
  rule	print " parameter "
	--------------------
	dump_kind PARAM
	
  rule	print " discrete  "
	--------------------
	dump_kind DISCRETE

  rule	print "           "
	--------------------
	dump_kind VARIABLE

end

relation dump_kind_str: VarKind => string =

  axiom	dump_kind_str CONST => "constant"
  axiom	dump_kind_str PARAM => "parameter"
  axiom	dump_kind_str DISCRETE => "discrete"
  axiom	dump_kind_str VARIABLE => ""

end


relation dump_direction =

  rule	print " input  "
	--------------------
	dump_direction INPUT

  rule	print " output "
	--------------------
	dump_direction OUTPUT
	
  rule	print "        "
	--------------------
	dump_direction BIDIR

end


relation dump_type =

  rule	print "Integer "
	----------------
	dump_type INT

  rule	print "Real    "
	----------------
	dump_type REAL

  rule	print "Boolean "
	----------------
	dump_type BOOL

  rule	print "String  "
	----------------
	dump_type STRING

end

relation dump_var : Element => () =
	
  rule	dump_kind kind & dump_direction dir & dump_type typ &
 	Exp.print_component_ref id & print ";\n"
	--------------------------------------
	dump_var VAR(id, kind, dir, typ, NONE,_)
	
  rule	dump_kind kind & dump_direction dir & dump_type typ &
 	Exp.print_component_ref id & print " = " &
	Exp.print_exp e & print ";\n"
	--------------------------------------
	dump_var VAR(id, kind, dir, typ, SOME(e),_)
	
  axiom	dump_var (_)

end

relation dump_equation : Element => () =
	
  rule	print "  " & Exp.print_exp e1 &
	print " = " & Exp.print_exp e2 & print ";\n"
	--------------------------------------
	dump_equation(EQUATION(e1, e2))
	
  rule	print "  " & Exp.print_component_ref c &
	print " ::= " & Exp.print_exp e & print ";\n"
	--------------------------------------
	dump_equation(DEFINE(c, e))
	
  axiom	dump_equation _

end

relation dump_algorithm : Element => () =

  rule	print "algorithm\n" &
	Dump.print_list(stmts, pp_statement, "")
	----------------------------------------------
	dump_algorithm ALGORITHM(Algorithm.ALGORITHM(stmts))

  axiom	dump_algorithm _

end


(* LS *)
relation dump_function: Element => () =


  rule	print "function " &
	Absyn.path_string fpath => fstr &
	print fstr & print "\n" &
	dump_elements(dae) &
	print "end " & print fstr & print ";\n\n\n"
	------------------------------------
	dump_function FUNCTION(fpath,DAE(dae),t)
	
  axiom	dump_function _


end


(** relation: pp_statement
 **
 ** Prettyprint an algorithm statement
 **)

relation pp_statement : Algorithm.Statement => () =

  rule	pp_stmt (alg,2)
	--------------
	pp_statement alg

end

relation pp_stmt : (Algorithm.Statement, int) => () =

  rule	indent i &
	Exp.print_component_ref c &
	print " := " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN(_,c,e), i)

  rule	indent i &
	Exp.print_component_ref c &
	print " := " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN_ARR(_,c,e), i)

  rule	indent i &
 	print "if " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i) &
	indent i & print "end if;\n"
        -------------------
	pp_stmt (Algorithm.IF(e,then,else), i)
	
  rule	indent i &
	print "for " & print id & print " in " &
 	Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end for;\n"
        -------------------
	pp_stmt (Algorithm.FOR(_,_,id,e,stmts), i)
	
  rule	indent i &
	print "while " & Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end while;\n"
        -------------------
	pp_stmt (Algorithm.WHILE(e,stmts), i)
	
  rule	indent i &
	print "when " & Exp.print_exp e & print " do\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end when;\n"
        -------------------
	pp_stmt (Algorithm.WHEN(e,stmts), i)
	
  rule	indent i & print "**ALGORITHM**;\n"
	----------------------------------
	pp_stmt (_,i)

end

relation pp_stmt_list : (Algorithm.Statement list, int) => () =

  axiom	pp_stmt_list ([],_)

  rule	pp_stmt (stmt,i) & pp_stmt_list(stmts,i)
	--------------------------------
	pp_stmt_list (stmt::stmts,i)

end

relation pp_else : (Algorithm.Else, int) => () =

  axiom	pp_else (Algorithm.NOELSE, _)

  rule	indent i &
 	print "elseif " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i)
        -----------------
	pp_else (Algorithm.ELSEIF(e,then,else), i)

  rule	indent i &
 	print "else\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i')
        ------------------------
	pp_else (Algorithm.ELSE(stmts), i)

end

relation indent : int => () =

  axiom indent 0

  rule	print " " & int_sub(i,1) => i' & indent i'
	------------------------------------------
	indent i

end


(* LS *)
relation get_matching_elements: (Element list, Element => () )  => Element list =

  rule	get_matching (elist, cond ) => elist
	------------------------------------
	get_matching_elements (elist, cond) => elist
end	

(* LS *)
relation get_matching: ('a list, 'a => () )  => 'a list =

  axiom	get_matching ([],_) => []

  rule	cond(v) &
	get_matching (vl, cond) => vl'
	-------------------
	get_matching (v::vl, cond) => v::vl'

  rule	not cond(v) &
	get_matching (vl, cond) => vl'
	--------------------------
	get_matching (v::vl, cond) => vl'
end	


(* LS *)
relation is_parameter: Element => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_parameter VAR(_, PARAM, _, _, _, _)

end

(* LS *)
relation is_comp: Element => () =

  axiom	is_comp COMP(_,_) 

end



(* LS *)
relation get_output_vars: Element list  => Element list =
	
  rule	get_matching_elements(vl, is_output_var) => vl'
	---------------------------------
	get_output_vars vl => vl'
end

(* HJ *)
relation get_input_vars: Element list  => Element list =
	
  rule	get_matching_elements(vl, is_input_var) => vl'
	---------------------------------
	get_input_vars vl => vl'
end

(* LS *)
relation is_output_var: Element => () =

  axiom	is_output_var VAR(n, VARIABLE, OUTPUT, ty, _, _)

end

(* HJ *)
relation is_input_var: Element => () =

  axiom	is_input_var VAR(n, VARIABLE, INPUT, ty, _, _)

end


(* LS *)
relation is_not_var: Element => () =

  rule	not is_var e
	------------
	is_not_var e
end

(* LS *)
relation is_var: Element => () =

  axiom	is_var VAR(_,_,_,_,_,_)

end

relation is_algorithm : Element => () =

  axiom is_algorithm ALGORITHM(_)

end

relation is_function : Element => () =

  axiom is_function FUNCTION(_,_,_)

end

(*******************************

 Dump the data structures in a 
 paranthesised way

********************************)


relation dump_debug : DAElist => () =

  rule	print "DAE(" & dump_debug_elist elist & print ")"
	-------------------------------------------------
	dump_debug DAE(elist)

end

relation dump_debug_elist : Element list => () =

  axiom dump_debug_elist []

  rule	dump_debug_element first & print "\n" &
	dump_debug_elist rest
	---------------------
	dump_debug_elist first :: rest

end

relation dump_debug_element : Element => () =

  rule	print "VAR(" &
	Exp.print_component_ref cr & print ", " &
	dump_kind vk &
	print ")"
	-------------
	dump_debug_element VAR(cr,vk,vd,ty,NONE,_)

  rule	print "VAR(" &
	Exp.print_component_ref cr & print ", " &
	dump_kind vk & print ", " &
	Exp.print_exp e &
	print ")"
	-------------
	dump_debug_element VAR(cr,vk,vd,ty,SOME(e),_)

  rule	print "DEFINE(" &
	Exp.print_component_ref cr &
	print ", " &
	Exp.print_exp exp &
	print ")"
	----------------
	dump_debug_element DEFINE(cr,exp)

  rule	print "EQUATION(" &
	Exp.print_exp e1 &
	print "," &
	Exp.print_exp e2 &
	print ")"
	------------------
	dump_debug_element EQUATION(e1,e2)

  rule	print "ALGORITHM()"
	-------------------
	dump_debug_element ALGORITHM(_)

  rule	print "COMP(" & print n & print "," &
	dump_debug (l) &
	print ")"
	--------------------------------------
	dump_debug_element COMP(n,l)

  rule	print "FUNCTION(" &
	Absyn.path_string fpath => fstr &
	print fstr & print "," &
	Types.print_type t & print "," &
	dump_debug (l) &
	print ")"
	--------------------------------------
	dump_debug_element FUNCTION(fpath,l,t)

end


relation find_element : (Element list, Element => ()) => Element option =

  axiom	find_element ([],_) => NONE

  rule	f(e)
	------------
	find_element (e::rest, f) => SOME(e)

  rule	not f(e) &
	find_element (rest, f) => e'
	-----------------
	find_element (e::rest, f) => e'

end


(***************************
 Graphviz relations to visualize 
 the dae
***************************)

relation dump_graphviz : DAElist => () =

  rule	build_graphviz dae => r &
	Graphviz.dump(r)
	----------------
	dump_graphviz dae

end


relation build_graphviz : DAElist => Graphviz.Node =

  rule	get_matching_elements (els, is_var) => vars &
	get_matching_elements (els, is_not_var) => nonvars &
	build_gr_list nonvars => nonvarnodes &
	build_gr_vars vars => varnodes &
	list_append (nonvarnodes,varnodes) => nodelist
	-----------------------------
	build_graphviz DAE(els) => Graphviz.NODE("DAE",[],nodelist)

end

relation build_gr_list : Element list => Graphviz.Node list =

  axiom build_gr_list [] => []

  rule	build_gr_element el => node &
	build_gr_list rest => nodelist
	---------------------------
	build_gr_list el::rest => node::nodelist

end

relation build_gr_vars : Element list => Graphviz.Node list =

  axiom build_gr_vars [] => []

  rule	build_gr_strlist (vars, build_gr_var_str, 10) => (strlist,_)
	---------------------------
	build_gr_vars vars => [Graphviz.LNODE("VARS",strlist,[Graphviz.box],[])]

end

relation build_gr_strlist : ('a list, 'a => string, int) => (string list, 'a list) =

  axiom	build_gr_strlist ([], _, _) => ([],[])

  rule	int_le (count, 0) => true	
	-------------------------------------
	build_gr_strlist (ignored, printer, count) => (["..."], ignored)

  rule	int_gt (count, 0) => true &
	int_sub (count, 1) => count' &
	build_gr_strlist (rest, printer, count') => (strlist, ignored) &
	printer (var) => str
	-------------------------------------
	build_gr_strlist (var::rest, printer, count) => (str::strlist, ignored)

end

relation build_gr_var_str : Element => string =

  rule	Exp.print_component_ref_str cr => str
	-------------------------------------
	build_gr_var_str VAR(cr,_,_,_,NONE,_) => str

  rule	Exp.print_component_ref_str cr => str &
	print_exp_str_special exp => expstr &
	string_append (str, " = ") => str' &
	string_append (str', expstr) => str''
	-------------------------------------
	build_gr_var_str VAR(cr,_,_,_,SOME(exp),_) => str''

end

relation print_exp_str_special : (Exp.Exp) => string =

  rule	string_append ("\\\"", s) => s' &
	string_append (s', "\\\"") => s''
	---------------------------------
	print_exp_str_special Exp.SCONST(s) => s''

  rule	Exp.print_exp_str exp => str
	----------------------------
	print_exp_str_special exp => str

end



relation build_gr_element : Element => Graphviz.Node =


  rule	Exp.print_component_ref_str cr => crstr &
	dump_kind_str vk => vkstr
	--------------------------
	build_gr_element VAR(cr,vk,vd,ty,NONE,_) => Graphviz.LNODE("VAR",[crstr,vkstr],[],[])

  rule	Exp.print_component_ref_str cr => crstr &
	dump_kind_str vk => vkstr &
	print_exp_str_special exp => expstr &
	string_append ("= ", expstr) => expstr'
	-------------------------------
	build_gr_element VAR(cr,vk,vd,ty,SOME(exp),_) => Graphviz.LNODE("VAR",[crstr,vkstr,expstr'],[],[])


  rule	Exp.print_component_ref_str cr => crstr &
	print_exp_str_special exp => expstr &
	string_append ("= ", expstr) => expstr'
	---------------------------------------
	build_gr_element DEFINE(cr,exp) => Graphviz.LNODE("DEFINE",[crstr,expstr'],[],[])

  rule	print_exp_str_special e1 => e1str &
	print_exp_str_special e2 => e2str
	---------------------------------------
	build_gr_element EQUATION(e1,e2) => Graphviz.LNODE("EQUATION",[e1str,"=",e2str],[],[])

  axiom	build_gr_element ALGORITHM(_) => Graphviz.NODE("ALGORITHM",[],[])

  rule	build_graphviz dae => node
	---------------------------------------
	build_gr_element COMP(n,dae) => Graphviz.LNODE("COMP",[n],[],[node])

  rule	build_graphviz dae => node &
	Absyn.path_string fpath => fstr
	---------------------------------------
	build_gr_element FUNCTION(fpath,dae,ty) => Graphviz.LNODE("FUNCTION",[fstr],[],[node])


end
