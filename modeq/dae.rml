(**
 ** file:	 dae.rml
 ** description: DAE management and output
 **
 ** RCS: $Id$
 **
 ** This file is not really mine.  It will be rewritten later.
 **)

(** - Module header *)

module DAE:
  
  with "absyn.rml"
  with "dump.rml"
  with "exp.rml"
  with "explode.rml"
  with "algorithm.rml"

  type Ident = string

  datatype VarKind = VARIABLE | DISCRETE | PARAM | CONST

  datatype Type = REAL | INT | BOOL | STRING

  datatype Element = VAR of Exp.ComponentRef * VarKind * Type
		   | DEFINE of Exp.ComponentRef * Exp.Exp
		   | EQUATION of Exp.Exp * Exp.Exp
		   | ALGORITHM of Algorithm.Algorithm
		   | COMP of Ident * DAElist

  datatype DAElist = DAE of Element list
	  
  relation dump: DAElist => ()
	  
end

(** - Relations
 **
 ** The only relations in this module are for printing, and are not
 ** included in the report.
 **)

(*!ignorecode*)

(** relation: dump
 **
 ** This relation prints the DAE in the standard outpur format.
 **)

relation dump: DAElist => () =
	
  rule	print "fclass " & print n & print "\n" &
	dump(l) &
	print "end " & print n & print ";\n"
	-----------------------------------
	dump DAE([COMP(n,l)])

  rule	dump_vars l &
	print "equation\n" &
	dump_equations l &
	dump_algorithms l
	-----------------
	dump DAE(l)

end

relation dump_kind =

  rule	print "  constant  "
	--------------------
	dump_kind CONST
	
  rule	print "  parameter "
	--------------------
	dump_kind PARAM
	
  rule	print "  discrete  "
	--------------------
	dump_kind DISCRETE

  rule	print "            "
	--------------------
	dump_kind VARIABLE

end

relation dump_type =

  rule	print "Integer "
	----------------
	dump_type INT

  rule	print "Real    "
	----------------
	dump_type REAL

  rule	print "Boolean "
	----------------
	dump_type BOOL

  rule	print "String  "
	----------------
	dump_type STRING

end

relation dump_element: Element => () =
	
  rule	dump_kind kind & dump_type typ &
 	Exp.print_component_ref id & print "\n"
	--------------------------------------
	dump_element(VAR(id, kind, typ))
	
  rule	print "  " & Exp.print_exp e1 &
	print " = " & Exp.print_exp e2 & print ";\n"
	--------------------------------------
	dump_element(EQUATION(e1, e2))
	
  rule	print "  " & Exp.print_component_ref c &
	print " ::= " & Exp.print_exp e & print ";\n"
	--------------------------------------
	dump_element(DEFINE(c, e))
	
  rule	print "{ begin " & print id & print " }\n" &
	dump contents &
	print "{ end " & print id & print " }\n"
        --------------------------------------
        dump_element ( COMP(id, contents))

end

relation dump_var : Element => () =
	
  rule	dump_kind kind & dump_type typ &
 	Exp.print_component_ref id & print ";\n"
	--------------------------------------
	dump_var(VAR(id, kind, typ))
	
  axiom	dump_var _

end

relation dump_equation : Element => () =
	
  rule	print "  " & Exp.print_exp e1 &
	print " = " & Exp.print_exp e2 & print ";\n"
	--------------------------------------
	dump_equation(EQUATION(e1, e2))
	
  rule	print "  " & Exp.print_component_ref c &
	print " ::= " & Exp.print_exp e & print ";\n"
	--------------------------------------
	dump_equation(DEFINE(c, e))
	
  axiom	dump_equation _

end

relation dump_algorithm : Element => () =

  rule	print "algorithm\n" &
	Dump.print_list(stmts, pp_statement, "")
	----------------------------------------------
	dump_algorithm ALGORITHM(Algorithm.ALGORITHM(stmts))

  axiom	dump_algorithm _

end

relation dump_vars: Element list => () =
	
  axiom	dump_vars []
	
  rule	dump_var first &
	dump_vars rest
	-------------------
	dump_vars first :: rest

end

relation dump_equations: Element list => () =
	
  axiom	dump_equations []
	
  rule	dump_equation first &
	dump_equations rest
	-------------------
	dump_equations first :: rest

end

relation dump_algorithms: Element list => () =
	
  axiom	dump_algorithms []
	
  rule	dump_algorithm first &
	dump_algorithms rest
	-------------------
	dump_algorithms first :: rest

end

(** relation: pp_statement
 **
 ** Prettyprint an algorithm statement
 **)

relation pp_statement : Algorithm.Statement => () =

  rule	pp_stmt (alg,2)
	--------------
	pp_statement alg

end

relation pp_stmt : (Algorithm.Statement, int) => () =

  rule	indent i &
	Exp.print_component_ref c &
	print " := " &
	Exp.print_exp e &
	print ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN(c,e), i)

  rule	indent i &
 	print "if " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i) &
	indent i & print "end if;\n"
        -------------------
	pp_stmt (Algorithm.IF(e,then,else), i)
	
  rule	indent i &
	print "for " & print id & print " in " &
 	Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end for;\n"
        -------------------
	pp_stmt (Algorithm.FOR(id,e,stmts), i)
	
  rule	indent i &
	print "while " & Exp.print_exp e & print " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end while;\n"
        -------------------
	pp_stmt (Algorithm.WHILE(e,stmts), i)
	
  rule	indent i &
	print "when " & Exp.print_exp e & print " do\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	print "end when;\n"
        -------------------
	pp_stmt (Algorithm.WHEN(e,stmts), i)
	
  rule	indent i & print "**ALGORITHM**;\n"
	----------------------------------
	pp_stmt (_,i)

end

relation pp_stmt_list : (Algorithm.Statement list, int) => () =

  axiom	pp_stmt_list ([],_)

  rule	pp_stmt (stmt,i) & pp_stmt_list(stmts,i)
	--------------------------------
	pp_stmt_list (stmt::stmts,i)

end

relation pp_else : (Algorithm.Else, int) => () =

  axiom	pp_else (Algorithm.NOELSE, _)

  rule	indent i &
 	print "elseif " & Exp.print_exp e & print " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i)
        -----------------
	pp_else (Algorithm.ELSEIF(e,then,else), i)

  rule	indent i &
 	print "else\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i')
        ------------------------
	pp_else (Algorithm.ELSE(stmts), i)

end

relation indent : int => () =

  axiom indent 0

  rule	print " " & int_sub(i,1) => i' & indent i'
	------------------------------------------
	indent i

end
