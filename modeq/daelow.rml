 (*
    Copyright PELAB, Linkoping University
    This source is non-free and should not be included in OpenModelica.

*)

(**
 ** file:	 daelow.rml
 ** module:      DAELow
 ** description: DAELow a lower form of DAE including sparse matrises for
 ** BLT decomposition, etc.
 **
 ** RCS: $Id$
 ** 
 **)

(** 
 ** This module is a lowered form of a DAE including equations simple equations in
 ** two separate lists. The variables are split into known variables
 ** parameters and constants, and unknown variables, 
 ** states and algebraic variables.
 ** The module includes the BLT sorting algorithm which sorts the
 ** equations into blocks, and the index reduction algorithm using
 ** dummy derivatives for solving higher index problems.
 ** It also includes the tarjan algorithm to detect strong components
 ** in the BLT sorting.
**)
module DAELow:
  
  with "dae.rml"
  with "exp.rml"
  with "values.rml"
  with "absyn.rml"



  datatype VarKind = VARIABLE | STATE | DUMMY_DER | DUMMY_STATE | DISCRETE | PARAM | CONST

  datatype Var = VAR of Exp.ComponentRef * 
			VarKind * 
			DAE.VarDirection * 
			DAE.Type * 
			Exp.Exp option * (* Binding expression e.g. for parameters*)
			Values.Value option * (* binding value for parameters*)
			DAE.InstDims *
			DAE.StartValue *  (* value of start attribute *)
			int * (* index in impl. vector *)
		        string *(* original variable name *)
			Absyn.Path (* classname variable belongs to *)


  datatype Equation = EQUATION of Exp.Exp * Exp.Exp


(* The lowered DAE consist of variables and equations. The variables are split into 
 * two lists, one for unknown variables states and algebraic and one for known variables
 * constants and parameters.
 * The equations are also split into two lists, one with simple equations, a=b, a-b=0, etc., that 
  * are removed from  the set of equations to speed up calculations.
 *)
 datatype DAELow = DAELOW of Variables (* ordered Variables, only states and alg. vars*)		    
		  * Variables (* Known variables, i.e. constants and parameters*)
	          * Equation list (* ordered Equations *)
	          * Equation list (* Removed equations a=b*)

 datatype Variables = VARIABLES of Var vector (* A vector of the variables*)
					* BinTree (* A binary tree mapping variable names (ComponentRef)
						   * to vector indices (1...n)  *)
						(* NOTE: RML vectors are though indexed 0..n-1 
						 but will probably change in future to 1..n *)


(** Generic Binary tree implementation *)
 datatype BinTree = TREENODE of TreeValue option * (* Value *)
				BinTree option * (* left subtree *)
				BinTree option (* right subtree *)

(* Each node in the binary tree can have a value associated with it.*)

  datatype TreeValue = TREEVALUE of Key (* Key *)
				* Value (* Value *)

  type Key = Exp.ComponentRef

  type Value = int


  type IncidenceMatrix = int list list (* a list of variable indexes, one for each equation*)


  type IncidenceMatrixT = IncidenceMatrix (* a list of equation indexes, one for each variable*)

  relation dump: DAELow => ()
  relation dump_vars: Var list => ()

  relation lower: (DAE.DAElist) => DAELow

  relation incidence_matrix: (DAELow) => IncidenceMatrix
 
  relation transpose_matrix: IncidenceMatrix => IncidenceMatrixT
		  
  relation dump_incidence_matrix: IncidenceMatrix => ()

  relation dump_incidence_matrix_inv: IncidenceMatrixT => ()

  relation dump_matching: (int vector) => () 
	  
  relation matching_algorithm: (DAELow,IncidenceMatrix, IncidenceMatrixT) 
	  => (int vector,(* var solved in eqn*) 
	      int vector, (* eqn solves var *) 
	      DAELow,
	      IncidenceMatrix, 
	      IncidenceMatrixT)

  relation strong_components: (IncidenceMatrix, IncidenceMatrixT,
			       int vector, int vector) => 
	  (int list list )

  relation dump_components: (int list list) => ()

  relation translate_dae: DAELow => DAELow 
  relation calculate_values: DAELow => DAELow	  
	  
  relation calculate_sizes: DAELow => (int, (* nx *)
				       int, (* ny *)
				       int) (* np *)

  relation states: (DAE.DAElist,BinTree) => BinTree
end (* End Module *)

(* Implementation *)
with "util.rml" 
with "daeext.rml"
with "print.rml"
with "derive.rml"
with "debug.rml"
with "env.rml" 
with "builtin.rml"
with "ceval.rml" 
with "types.rml"
with "explode.rml"
with "dump.rml"
with "system.rml"

val empty_bintree = TREENODE(NONE,NONE,NONE)

relation lower: (DAE.DAElist) => DAELow =

  rule	states(lst,empty_bintree) => s &
	lower2(lst,s) => (low as DAELOW(vars,knvars,eqns,reqns))  &
(*	print "lowered dae:" & dump low &*)
	remove_simple_equations(low,s) => low' 
(*	& print "removed simple equations, dae:" &
	dump low' *)
	(*list_length(vars) => varlen &
	int_string(varlen) => vs &
	list_length(eqns) => eqnlen &
	int_string(eqnlen) => es &
	print vs & print " variables\n========" &
	dump_vars(vars) &
	print st & print "\n" &
	print es & print " equations\n" *)
	--------------------
	lower(lst) => low'
end


relation dump: DAELow => () =

  rule	print "Variables\n" &
	print "=========\n" &
	vector_list(varvec) => vars &
	dump_vars vars &
	print "\n" &
	print "Known Variables (constants)\n" &
	print "=============================\n" &
	vector_list(varvec2) => knvars &
	dump_vars knvars &
	print "\nEquations\n" &
	print "=========\n" &
	dump_eqns eqns &
	print "Simple Equations\n" &
	print "=========\n" &
	dump_eqns reqns 
	-----------------
	dump(DAELOW(VARIABLES(varvec,bt),VARIABLES(varvec2,bt2),eqns,reqns))
end
relation dump_eqns: Equation list => () =

  rule	Util.list_map(eqns,equation_str) => lst &
	Util.string_delimit_list(lst,"\n") => s &
	print s & print "\n" 
	----------------
	dump_eqns(eqns)
end

relation equation_str: Equation => string =

  rule	Exp.print_exp_str e1 => s1 &
	Exp.print_exp_str e2 => s2 &
	Util.string_append_list([s1,"=",s2]) => res
	--------------------
	equation_str(EQUATION(e1,e2)) => res
end

(** relation: remove_simple_equations
 ** This relation moves simple equations on the form a=b from equations 2nd in DAELow
 ** to simple equations 3rd in DAELow to speed up assignment alg. 
 **)
relation remove_simple_equations: (DAELow,BinTree) 
	=> (DAELow) =

  rule	(* These two relations implements a simple while loop. While 
	 remove_simple_equations2 succeds do .... *)
	remove_simple_equations2(eqns,eqns,reqns,states,vars,knvars)
	  => (eqns,reqns,vars,knvars) &
	remove_simple_equations(DAELOW(vars,knvars,eqns,reqns),states) => res
	-------------------------------------
	remove_simple_equations(DAELOW(vars,knvars,eqns,reqns),states) 
	  => res

  rule	not remove_simple_equations2(eqns,eqns,reqns,states,vars,knvars)
	  => (_,_,_,_)
	-------------------------------------
	remove_simple_equations(dae as DAELOW(vars,knvars,eqns,reqns),states) 
	  => dae
end

(** relation remove_simple_equations2
 ** helper relation to remove_simple_equations
 **)
relation remove_simple_equations2: (Equation list, (* all equations *)
				    Equation list, (* eqns to iterate*)
				    Equation list, (* removed eqns*)
				    BinTree,(* states *)
				    Variables, (* variables states+alg *)
				    Variables) (* known variables *)
	  => (Equation list, (* all equations *)  
	      Equation list, (* removed equations*) 
	      Variables, (* variables states+alg *)
	      Variables) (* known variables *) =

  axiom	remove_simple_equations2(alleqns,[],reqns,states,vars,knvars) 
	  => fail

  rule	not tree_get(states,cr2) => _ &		(* No state..*)
	get_var(cr2,vars) => (_,_) &		(* .. but variable*)
	Util.list_deletemember(alleqns,e) => alleqns' &
	replace_all_lst(alleqns',cr2,cr1) => alleqns'' &
	remove_variable_named(vars,cr2) => (vars',var) &
	add_var(var,knvars) => knvars'
	--------------------------------------------------
	remove_simple_equations2(alleqns,(e as EQUATION(Exp.CREF(cr1,_),Exp.CREF(cr2,_)))::eqns,reqns,states,vars,knvars) 
	  => (alleqns'',e::reqns,vars',knvars')

  rule	(* as above but swapped args *)
	not tree_get(states,cr2) => _ &		(* No state... *)
	get_var(cr2,vars) => (_,_) &		(* .. but variable*)
	Util.list_deletemember(alleqns,e) => alleqns' &
	replace_all_lst(alleqns',cr2,cr1) => alleqns'' &
	remove_variable_named(vars,cr2) => (vars',var) 	&
	add_var(var,knvars) => knvars'
	--------------------------------------------------
	remove_simple_equations2(alleqns,(e as EQUATION(Exp.CREF(cr2,_),Exp.CREF(cr1,_)))::eqns,reqns,states,vars,knvars) 
	  => (alleqns'',e::reqns,vars',knvars')
	

  rule	Exp.is_zero(e2) => true &
	not tree_get(states,cr2) => _ &		(* No state... *)
	get_var(cr2,vars) => (_,_) &		(* .. but variable*)
	Util.list_deletemember(alleqns,e) => alleqns' &	
(*	Util.list_map_2(alleqns',replace_all,cr2,cr1) => alleqns'' &*)
	replace_all_lst(alleqns',cr2,cr1) => alleqns'' &
	remove_variable_named(vars,cr2) => (vars',var) &
	add_var(var,knvars) => knvars'
	--------------------------------------------------
	remove_simple_equations2(alleqns,(e as EQUATION(Exp.BINARY(Exp.CREF(cr1,_),Exp.SUB(_),Exp.CREF(cr2,_)),e2))::eqns,reqns,states,vars,knvars) 
	  => (alleqns'',e::reqns,vars',knvars')

  rule	(* As above but swapped args *)
	Exp.is_zero(e2) => true &
	not tree_get(states,cr2) => _ &		(* No state... *)
	get_var(cr2,vars) => (_,_) &		(* .. but variable*)
	Util.list_deletemember(alleqns,e) => alleqns' &	
	replace_all_lst(alleqns',cr2,cr1) => alleqns'' &
	remove_variable_named(vars,cr2) => (vars',var)  &
	add_var(var,knvars) => knvars'
	--------------------------------------------------
	remove_simple_equations2(alleqns,(e as EQUATION(Exp.BINARY(Exp.CREF(cr2,_),Exp.SUB(_),Exp.CREF(cr1,_)),e2))::eqns,reqns,states,vars,knvars) 
	  => (alleqns'',e::reqns,vars',knvars')

  rule	remove_simple_equations2(alleqns,eqns,reqns,states,vars,knvars) 
	  => (alleqns',reqns,vars',knvars')
	--------------------------------------------------------------
	remove_simple_equations2(alleqns,_::eqns,reqns,states,vars,knvars)
	  => (alleqns',reqns,vars',knvars')
end 

(** relation: remove_variable_named
 ** Removes a varaible from the 'Variables' set given a ComponentRef name.
 ** The removed variable is returned, such that is can be used elsewhere.
 **)
relation remove_variable_named: (Variables,  Exp.ComponentRef) => (Variables, Var) =

  rule	not get_var(cr,vars) => (_,_) &
	print "-remove_variable_named failed. variable " & Exp.print_component_ref_str cr => str &
	print str & print " not found.\n" 
	---------------------
 	remove_variable_named(vars,cr)  => fail

  rule	get_var(cr,vars) => (var,_) &
	delete_var(vars,cr) => vars' 
	------------------------------
	remove_variable_named(vars,cr) => (vars',var)
end

relation replace_all_lst: (Equation list, (* equation list *)
		       Exp.ComponentRef, (*source variable, *)
		       Exp.ComponentRef) (*target variable: src replaced with*)
	=> Equation list =

  axiom	replace_all_lst([],_,_) => []

  rule	replace_all(e,cr1,cr2) => e' &
	replace_all_lst(lst,cr1,cr2) => lst'
	-----------------------------
	replace_all_lst(e::lst,cr1,cr2) => e'::lst'

  rule	replace_all_lst(lst,cr1,cr2) => lst'
	-----------------------------------
	replace_all_lst(e::lst,cr1,cr2) => e::lst'
end

relation replace_all: (Equation, (* equation *)
		       Exp.ComponentRef, (*source variable, *)
		       Exp.ComponentRef) (*target variable: src replaced with*)
	=> Equation =

  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2'
	------------------------------
	replace_all (EQUATION(e1,e2),s,t) => EQUATION(e1',e2')

  rule 	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2'
	------------------------------
	replace_all (EQUATION(e1,e2),s,t) => EQUATION(e1,e2')

  rule 	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _
	------------------------------
	replace_all (EQUATION(e1,e2),s,t) => EQUATION(e1',e2)

  rule 	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _
	-----------------------------
	replace_all (eqn as EQUATION(e1,e2),s,t) => fail
end

relation replace_all_exp: (Exp.Exp, 
			   Exp.ComponentRef, (* source variable *)
			   Exp.ComponentRef) (* target variable *)
	  => (Exp.Exp) =

  rule	Exp.cref_equal(cr,s) => true
	----------------------------
	replace_all_exp(Exp.CREF(cr,tp),s,t) => Exp.CREF(t,tp)

  rule  Exp.cref_equal(cr,s) => false
	-----------------------------
	replace_all_exp(Exp.CREF(cr,tp),s,t) => fail

  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2' 
	-----------------------------
	replace_all_exp(Exp.BINARY(e1,op,e2),s,t) => Exp.BINARY(e1',op,e2')

  rule	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2' 
	-----------------------------
	replace_all_exp(Exp.BINARY(e1,op,e2),s,t) => Exp.BINARY(e1,op,e2')

  rule	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _ 
	-----------------------------
	replace_all_exp(Exp.BINARY(e1,op,e2),s,t) => Exp.BINARY(e1',op,e2)


  rule	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _ 
	-----------------------------
	replace_all_exp(exp as Exp.BINARY(e1,op,e2),s,t) => fail

  rule	replace_all_exp(e,s,t) => e' 
	-----------------------------
	replace_all_exp(Exp.UNARY(op,e),s,t) => Exp.UNARY(op,e')

  rule	not replace_all_exp(e,s,t) => _ 
	-----------------------------
	replace_all_exp(exp as Exp.UNARY(op,e),s,t) => fail

  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2' 
	-----------------------------
	replace_all_exp(Exp.LBINARY(e1,op,e2),s,t) => Exp.LBINARY(e1',op,e2')

  rule	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2' 
	-----------------------------
	replace_all_exp(Exp.LBINARY(e1,op,e2),s,t) => Exp.LBINARY(e1,op,e2')

  rule	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _
	-----------------------------
	replace_all_exp(Exp.LBINARY(e1,op,e2),s,t) => Exp.LBINARY(e1',op,e2)

  rule	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _
	----------------------------
	replace_all_exp(exp as Exp.LBINARY(e1,op,e2),s,t) => fail
	
  rule	replace_all_exp(e,s,t) => e'
	-----------------------------
	replace_all_exp(Exp.LUNARY(op,e),s,t) => Exp.LUNARY(op,e')

  rule	not replace_all_exp(e,s,t) => _
	-----------------------------
	replace_all_exp(exp as Exp.LUNARY(op,e),s,t) => exp

  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2'
	-------------------------
	replace_all_exp(Exp.RELATION(e1,rel,e2),s,t) => Exp.RELATION(e1',rel,e2')

  rule	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2'
	-------------------------
	replace_all_exp(Exp.RELATION(e1,rel,e2),s,t) => Exp.RELATION(e1,rel,e2')

  rule	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _
	-------------------------
	replace_all_exp(Exp.RELATION(e1,rel,e2),s,t) => Exp.RELATION(e1',rel,e2)

  rule	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _
	-------------------------
	replace_all_exp(exp as Exp.RELATION(e1,rel,e2),s,t) => fail
	
  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2' &
	replace_all_exp(e3,s,t) => e3'
	-------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1',e2',e3')

  rule	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2' &
	replace_all_exp(e3,s,t) => e3'
	-------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1,e2',e3')

  rule	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _ &
	replace_all_exp(e3,s,t) => e3'
	-------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1',e2,e3')

  rule	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _ &
	replace_all_exp(e3,s,t) => e3'
	-------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1,e2,e3')

  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2' &
	not replace_all_exp(e3,s,t) => _
	-------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1',e2',e3)

  rule	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2' &
	not replace_all_exp(e3,s,t) => _
	--------------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1,e2',e3)

  rule	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _ &
	not replace_all_exp(e3,s,t) => _
	-------------------------
	replace_all_exp(Exp.IFEXP(e1,e2,e3),s,t) => Exp.IFEXP(e1',e2,e3)

  rule	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _ &
	not replace_all_exp(e3,s,t) => _
	-------------------------
	replace_all_exp(exp as Exp.IFEXP(e1,e2,e3),s,t) => fail

  rule	(* Fixme, replace_all_exp can now fail, special map function needed*)
	Util.list_map_2(expl,replace_all_exp,s,t) => expl' 
	-------------------------------------------------
	replace_all_exp(Exp.CALL(a,expl,b,c),s,t) => Exp.CALL(a,expl',b,c)
	
  rule	(* Fixme, replace_all_exp can now fail, special map function needed*)
	Util.list_map_2(expl,replace_all_exp,s,t) => expl' 
	--------------------------------------------
	replace_all_exp(Exp.ARRAY(tp,b,expl),s,t) => Exp.ARRAY(tp,b,expl')

  rule	Print.print_buf "replace_all_exp on MATRIX not impl.\n" &
	print "replace_all_exp on MATRIX not impl.\n"
	---------------------------------------
	replace_all_exp(e as Exp.MATRIX(_,_,_),s,t) => e
	
  rule	(* Fixme, replace_all_exp can now fail, special map function needed*)
	Util.list_map_2(expl,replace_all_exp,s,t) => expl'
	-----------------------
	replace_all_exp(Exp.TUPLE(expl),s,t) => Exp.TUPLE(expl')

  rule	replace_all_exp(e,s,t) => e'
	-----------------------
	replace_all_exp(Exp.CAST(tp,e),s,t) => Exp.CAST(tp,e')

  rule	not replace_all_exp(e,s,t) => _
	-----------------------
	replace_all_exp(exp as Exp.CAST(tp,e),s,t) => fail

  rule	replace_all_exp(e,s,t) => e'
	----------------------------
	replace_all_exp(Exp.ASUB(e,i),s,t) => Exp.ASUB(e,i)

  rule	not replace_all_exp(e,s,t) => _
	----------------------------
	replace_all_exp(exp as Exp.ASUB(e,i),s,t) => exp

  rule	replace_all_exp(e1,s,t) => e1' &
	replace_all_exp(e2,s,t) => e2' 
	------------------------------
	replace_all_exp(Exp.REDUCTION(a,e1,b,e2),s,t) 
	  => Exp.REDUCTION(a,e1',b,e2')

  rule	not replace_all_exp(e1,s,t) => _ &
	replace_all_exp(e2,s,t) => e2' 
	------------------------------
	replace_all_exp(Exp.REDUCTION(a,e1,b,e2),s,t) 
	  => Exp.REDUCTION(a,e1,b,e2')

  rule	replace_all_exp(e1,s,t) => e1' &
	not replace_all_exp(e2,s,t) => _
	------------------------------
	replace_all_exp(Exp.REDUCTION(a,e1,b,e2),s,t) 
	  => Exp.REDUCTION(a,e1',b,e2)

  rule	not replace_all_exp(e1,s,t) => _ &
	not replace_all_exp(e2,s,t) => _
	------------------------------
	replace_all_exp(exp as Exp.REDUCTION(a,e1,b,e2),s,t) 
	  => fail
end


relation dump_vars: Var list => ()=

  axiom	dump_vars [] => ()

  rule	DAE.dump_direction_str dir => dirstr & print dirstr & print " " &
	Exp.print_component_ref_str(cr) => str &
	print str & print ":" & dump_kind kind &

	print "= " & Exp.print_exp_str e => s & print s & print ",\n " &
	dump_vars(xs) 
	-------------
	dump_vars(VAR(cr,kind,dir,_,SOME(e),_,_,_,_,_,_)::xs)

  rule  DAE.dump_direction_str dir => dirstr & print dirstr & print " " &
	Exp.print_component_ref_str(cr) => str &
	print str & print ":" & dump_kind kind &
	print ",\n " &
	dump_vars(xs) 
	-------------
	dump_vars(VAR(cr,kind,dir,_,NONE,_,_,_,_,_,_)::xs)
end 
relation dump_kind: VarKind => () =

  rule	print "VARIABLE" 
	--------------
	dump_kind VARIABLE

  rule	print "STATE" 
	--------------
	dump_kind STATE

  rule	print "DUMMY_DER" 
	--------------
	dump_kind DUMMY_DER

  rule	print "DUMMY_STATE" 
	--------------
	dump_kind DUMMY_STATE

  rule	print "DISCRETE" 
	--------------
	dump_kind DISCRETE

  rule	print "PARAM" 
	--------------
	dump_kind PARAM

  rule	print "CONST" 
	--------------
	dump_kind CONST
end

relation states: (DAE.DAElist,BinTree) => BinTree =

  axiom states (DAE.DAE([]),bt) => bt

  rule	states(DAE.DAE(xs),bt) => bt &
	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------------
	states(DAE.DAE(DAE.EQUATION(e1,e2)::xs),bt)  => bt

  rule	states(dae,bt) => bt &
	states(DAE.DAE(xs),bt) => bt 
	-------------------------
	states(DAE.DAE(DAE.COMP(_,dae)::xs),bt) => bt
	
  rule  states(DAE.DAE(xs),bt) => bt
	-----------------
	states(DAE.DAE(_::xs),bt) => bt
end

relation states_exp: (Exp.Exp,BinTree) => BinTree =

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------
	states_exp(Exp.BINARY(e1,_,e2),bt) => bt

  rule	states_exp(e,bt) => bt
	-----------------------------
	states_exp(Exp.UNARY(_,e),bt) => bt

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------------
	states_exp(Exp.LBINARY(e1,_,e2),bt) => bt
	
  rule	states_exp(e,bt) => bt
	----------------------
	states_exp(Exp.LUNARY(_,e),bt) => bt

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-------------------------
	states_exp(Exp.RELATION(e1,_,e2),bt) => bt
	
  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt &
	states_exp(e3,bt) => bt 
	-------------------------
	states_exp(Exp.IFEXP(e1,e2,e3),bt) => bt

  rule	(* value irrelevant, give zero *)
	Exp.stringify_component_ref(cr) => cr' &
	tree_add(bt,cr',0) => bt
	-----------------------
	states_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),bt) => bt

  rule	Util.list_fold(expl,states_exp,bt) => bt 
	----------------------------------------
	states_exp(Exp.CALL(_,expl,_,_),bt) => bt
	
  rule	Util.list_fold(expl,states_exp,bt) => bt 
	----------------------------------------
	states_exp(Exp.ARRAY(_,_,expl),bt) => bt

  rule	Print.print_buf "states_exp on MATRIX not impl.\n" &
	print "states_exp on MATRIX not impl.\n"
	---------------------------------------
	states_exp(Exp.MATRIX(_,_,_),bt) => bt
	
  rule	Util.list_fold(expl,states_exp,bt) => bt 
	----------------------------------------
	states_exp(Exp.TUPLE(expl),bt) => bt

  rule	states_exp(e,bt) => bt
	-----------------------
	states_exp(Exp.CAST(_,e),bt) => bt

  rule	states_exp(e,bt) => bt
	-----------------------
	states_exp(Exp.ASUB(e,_),bt) => bt

  rule	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------
	states_exp(Exp.REDUCTION(_,e1,_,e2),bt) => bt

  axiom	states_exp(_,bt) => bt
end


relation lower2: (DAE.DAElist, BinTree (* states *)) => DAELow =
	
  rule	empty_vars() => v1 &
	empty_vars() => v2
	------------------
	lower2 (DAE.DAE([]),_) => DAELOW(v1,v2,[],[])
	
  rule	lower2(DAE.DAE(xs),states) => DAELOW(vars,knvars,eqns,reqns) &
	lower_var (v,states) => v' &
	add_var(v',vars) => vars' 
	--------------------------------
	lower2 (DAE.DAE((v as DAE.VAR(_,_,_,_,_,_,_,_,_))::xs),states) 
	  => DAELOW(vars',knvars,eqns,reqns)

  rule	lower2(DAE.DAE(xs),states) => DAELOW(vars,knvars,eqns,reqns) &
	(* in previous rule, lower_var failed.  *)
	lower_known_var (v) => v' &
	add_var(v',knvars) => knvars'
	--------------------------------
	lower2 (DAE.DAE((v as DAE.VAR(_,_,_,_,_,_,_,_,_))::xs),states) 
	  => DAELOW(vars,knvars',eqns,reqns)
	  
  rule	lower2(DAE.DAE(xs),states) => DAELOW(vars,knvars,eqns,reqns) &
	lower_eqn(e) => e' 
	--------------------------------
	lower2 (DAE.DAE((e as DAE.EQUATION(e1,e2))::xs),states) 
	  => DAELOW(vars,knvars,e'::eqns,reqns)

  rule	lower2(dae,states) => DAELOW(vars1,knvars1,eqns1,reqns1) &
	lower2(DAE.DAE(xs),states) => DAELOW(vars2,knvars2,eqns2,reqns2) &
	merge_vars(vars1,vars2) => vars &
	list_append(eqns1,eqns2) => eqns &
	list_append(reqns1,reqns2) => reqns &
	merge_vars(knvars1,knvars2) => knvars
	--------------------------------
	lower2(DAE.DAE(DAE.COMP(_,dae)::xs),states) 
	  => DAELOW(vars,knvars,eqns,reqns)
	
  rule	lower2(DAE.DAE(xs),states) => res
	---------------------
	lower2 (DAE.DAE(_::xs),states) => res	

  rule	print "-lower2 failed\n" 
	------------------------
	lower2 (_,_) => fail	
end

relation lower_eqn: (DAE.Element) => Equation =

  rule	Exp.simplify(e1) => e1' &
	Exp.simplify(e2) => e2' &
	Exp.stringify_crefs(e1') => e1'' &
	Exp.stringify_crefs(e2') => e2'' 
	-----------------------
	lower_eqn(DAE.EQUATION(e1,e2)) => EQUATION(e1'',e2'')
end

(** relation: lower_var
 ** Transforms a DAE variable to DAELOW variable.
 ** Includes changing the ComponentRef name to a simpler form 'a'.'b'.'c' becomes
 ** 'a.b.c' (as CREF_IDENT("a.b.c",[]) )
 **)
relation lower_var: (DAE.Element, BinTree(* states*)) => Var =

  rule	Exp.print_component_ref_str name => origname &
	let newname = Exp.CREF_IDENT(origname,[]) &
	lower_varkind(kind,newname,states) => kind' & 
	lower_binding(bind) => bind' &
	lower_binding(start) => start'
	----------------------------------------
	lower_var (DAE.VAR(name,kind,dir,tp,bind,dims,start,_,class),states)
	  => VAR(newname,kind',dir,tp,bind',NONE,dims,start',-1,origname,class)

(*  rule	print "-lower_var failed\n" 
	------------------------
	lower_var (_,_) => fail*)

end

relation lower_binding: Exp.Exp option => Exp.Exp option =
	
  axiom	 lower_binding NONE => NONE 

  rule	Exp.stringify_crefs(e) => e'
	----------------------------
	lower_binding(SOME(e)) =>  SOME(e)
end

relation lower_known_var: (DAE.Element) => Var =

  rule	lower_known_varkind(kind) => kind' &
	Exp.print_component_ref_str name => origname &
	lower_binding(bind) => bind' &
	lower_binding(start) => start'
	----------------------------------------
	lower_known_var (DAE.VAR(name,kind,dir,tp,bind,dims,start,_,class))
	  => VAR(Exp.CREF_IDENT(origname,[]),kind',dir,tp,bind',NONE,dims,start',-1,origname,class)
end

relation lower_varkind: (DAE.VarKind, Exp.ComponentRef, BinTree (* states *)) 
	=> VarKind =
	(* Fails for not states that are not algebraic variables, e.g.
	 parameters and constants *)

  rule	tree_get(states,v) => _
	-----------------------------
	lower_varkind(DAE.VARIABLE,v,states) => STATE

  axiom	lower_varkind(DAE.VARIABLE,_,_) => VARIABLE

end

relation lower_known_varkind: (DAE.VarKind) => VarKind =
(* Fails for everything but parameters and constants *)

  axiom	lower_known_varkind(DAE.PARAM) => PARAM
(*  axiom	lower_known_varkind(DAE.CONST) => CONST*)
end

relation incidence_matrix: (DAELow)
	  => IncidenceMatrix =
	  
  axiom	incidence_matrix(DAELOW(_,_,[],_)) => [] 

  rule	incidence_matrix(DAELOW(vars,knvars,eqns,reqns)) => lst &
	incidence_row(vars,e) => row
	----------------------------
	incidence_matrix(DAELOW(vars,knvars,e::eqns,reqns)) => row::lst

  rule	print "incidence_matrix failed\n" 
	----------------------
	incidence_matrix(_) => fail
end


relation incidence_row: ( Variables, Equation) 
	  => int list =
	
  rule	(*Inefficient to for each cref in equation traverse the varlist*)
	(* Should use a map or a bintree*)
	incidence_row_exp(e1,vars) => lst1 &
	incidence_row_exp(e2,vars) => lst2 &
	list_append(lst1,lst2) => res
	------------------------------------
	incidence_row(vars,EQUATION(e1,e2)) => res

  rule	print "-incidence_row failed\n"
	------------------
	incidence_row(vars,_) => fail
end 

relation incidence_row_exp: (Exp.Exp, Variables ) 
	  => int list =

  rule	(* If variable x is a state, der(x) is a variable in incidence matrix,
	 but not x itself, it is considered known.*)
	get_var(cr,vars) => (VAR(_,STATE,_,_,_ ,_,_,_,_,_,_),_)
 	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => []
	
  rule	get_var(cr,vars) => (VAR(_,VARIABLE,_,_,_, _,_,_,_,_,_),p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => [p]

  rule	get_var(cr,vars) => (VAR(_,DUMMY_DER,_,_,_ ,_,_,_,_,_,_),p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => [p]

  rule	get_var(cr,vars) => (VAR(_,DUMMY_STATE,_,_,_, _,_,_,_,_,_),p) 
	-----------------------------
	incidence_row_exp(Exp.CREF(cr,_),vars) => [p]

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-----------------------------
	incidence_row_exp(Exp.BINARY(e1,_,e2),vars) => res

  rule	incidence_row_exp(e,vars) => res
	-----------------------------
	incidence_row_exp(Exp.UNARY(_,e),vars) => res

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-----------------------------
	incidence_row_exp(Exp.LBINARY(e1,_,e2),vars) => res
	
  rule	incidence_row_exp(e,vars) => res
	-----------------------------
	incidence_row_exp(Exp.LUNARY(_,e),vars) => res

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	-------------------------
	incidence_row_exp(Exp.RELATION(e1,_,e2),vars) => res
	
  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	incidence_row_exp(e3,vars) => s3 &
	Util.list_flatten([s1,s2,s3]) => res
	-------------------------
	incidence_row_exp(Exp.IFEXP(e1,e2,e3),vars) => res

  rule  get_var(cr,vars) => (VAR(_,STATE,_,_,_, _,_,_,_,_,_),p)
	--------------------------------
	incidence_row_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),vars) 
	  => [p]

  rule  get_var(cr,vars) => (_,p)
	--------------------------------
	incidence_row_exp(Exp.CALL(Absyn.IDENT("der"),[Exp.CREF(cr,_)],_,_),vars) 
	  => []

  rule	Util.list_map_1(expl,incidence_row_exp,vars) => lst &
	Util.list_flatten(lst) => res
	-----------------------------------------------
	incidence_row_exp(Exp.CALL(_,expl,_,_),vars) => res
	
  rule	print "not impl. yet" 
	-----------------------
	incidence_row_exp(Exp.ARRAY(_,_,expl),vars) => []

  rule	Print.print_buf "incidence_row_exp on MATRIX not impl.\n" &
	print "incidence_row_exp on MATRIX not impl.\n"
	---------------------------------------
	incidence_row_exp(Exp.MATRIX(_,_,_),vars) => []
	
  rule	print "not impl. yet." 
	-----------------------
	incidence_row_exp(Exp.TUPLE(expl),vars) => []

  rule	incidence_row_exp(e,vars) => res
	-----------------------
	incidence_row_exp(Exp.CAST(_,e),vars) => res

  rule	incidence_row_exp(e,vars) => res
	-----------------------
	incidence_row_exp(Exp.ASUB(e,_),vars) => res

  rule	incidence_row_exp(e1,vars) => s1 &
	incidence_row_exp(e2,vars) => s2 &
	list_append(s1,s2) => res
	--------------------
	incidence_row_exp(Exp.REDUCTION(_,e1,_,e2),vars) => res

  axiom	incidence_row_exp(_,_) => []
end

(**relation empty_vars
 ** Returns a Variable datastructure that is empty
 **)
relation empty_vars: () => Variables =

  rule	list_vector([]) => emptyvec
	------------------------
	empty_vars() => VARIABLES(emptyvec, empty_bintree)
end

(** relation: merge_vars
 ** Takes two sets of Variables and merges them. The variables of the first argument takes 
 ** precedence over the second set, i.e. if a variable name exists in both sets, the variable
 ** definition from the first set is used.
 **)
relation merge_vars: (Variables, Variables) => Variables =

rule	vector_list(vec) => varlst &
	Util.list_fold(varlst,add_var,vars1) => vars1' 
	------------------------------
	merge_vars(vars1,vars2 as VARIABLES(vec,bt)) => vars1'

  rule	print "-merge_vars failed\n" 
	----------------------------
	merge_vars(_,_) => fail
end

(** relation: add_var
 ** Add a variable to Variables.
 ** If the variable allready exists, the relation updates the variable.
 **)
relation add_var: (Var, Variables) => Variables =

  rule	(* adding when not existing previously *)
	not get_var(cr,vars) => (_,_) &
	vector_length(varvec) => veclen &
	int_add(veclen,1) => newpos &
	vector_list(varvec) => varlst &
	list_append(varlst,[v]) => varlst' &
	list_vector(varlst') => varvec' &
	tree_add(bt,cr,newpos) => bt'
	-----------------------------
	add_var(v as VAR(cr,_,_,_,_,_,_,_,_,_,_),vars as VARIABLES(varvec,bt)) 
	  => VARIABLES(varvec',bt')

  rule	(* adding when allready present => Updating value *)
	get_var(cr,vars) => (v,indx) &
	int_sub(indx,1) => indx' &
	vector_list(varvec) => varlst &
	Util.list_replaceat(newv,indx',varlst) => varlst' &
	list_vector(varlst') => varvec'
	---------------------------
	add_var( newv as VAR(cr,_,_,_,_,_,_,_,_,_,_),vars as VARIABLES(varvec,bt))
	  => VARIABLES(varvec',bt)
end

(** relation: update_vars_bt
 ** Creates a new binary tree according to the variables in the variable vector
 **)
relation update_vars_bt: (Variables) => Variables =

  rule	vector_length(varvec) => veclen & 
	update_vars_bt2(veclen,varvec,empty_bintree) => bt'
	---------------------------------
	update_vars_bt(VARIABLES(varvec,bt)) 
	  => VARIABLES(varvec,bt')

  rule	print "-update_vars_bt failed\n" 
	--------------------
	update_vars_bt(_) => fail
end

(** relation: update_vars_bt2
 ** helper relation to update_vars_bt
 **)
relation update_vars_bt2: (int,Var vector, BinTree) => BinTree =

  rule	vector_nth(varvec,0) =>  VAR(cr,_,_,_,_, _,_,_,_,_,_) &
	tree_add(bt,cr,1) => bt'
	------------------------
	update_vars_bt2(1,varvec,bt) => bt'
	
  rule	int_sub(indx,1) => indx' &
	vector_nth(varvec,indx') => VAR(cr,_,_,_,_, _,_,_,_,_,_) &
	tree_add(bt,cr,indx) => bt' &
	update_vars_bt2(indx',varvec,bt') => bt''
	---------------------------
	update_vars_bt2(indx,varvec,bt) => bt''
end

(** relation: get_var
 ** Return a variable and its index in the vector.
 ** The index is enumerated from 1..n 
 **)
relation get_var: (Exp.ComponentRef, Variables) => (Var,int) =
	
  rule	tree_get(bt,cr) => index &
	int_sub(index,1) => index' &
	vector_nth(varvec,index') => v 
	-----------------------------
	get_var(cr,VARIABLES(varvec,bt)) => (v,index)
end

(** relation: delete_var
 ** Deletes a variable from 'Variables'. This is an expensive operation since we need to create a new 
 ** binary tree with new indexes as well as a new compacted vector of variables.
 **)
relation delete_var: (Variables,Exp.ComponentRef) => Variables =

  rule	tree_get(bt,cr) => index &
	int_sub(index,1) => index' &
	vector_list(varvec) => varlst &
	list_delete(varlst,index') => newvars &
	list_vector(newvars) => varvec' &
	update_vars_bt(VARIABLES(varvec',empty_bintree)) => vars'
	--------------------------------------------------
	delete_var(VARIABLES(varvec,bt),cr) =>  vars'
end

relation transpose_matrix: IncidenceMatrix => IncidenceMatrixT =

  rule	list_length(m) => neq &
	transpose_matrix2(m,neq,0,[]) => mt
	----------------
	transpose_matrix(m) => mt

  rule	print "#transpose_matrix failed\n" 
	---------------------
	transpose_matrix(_) => fail
end
relation transpose_matrix2: (IncidenceMatrix,int,int,IncidenceMatrixT) 
	  => IncidenceMatrixT =
  axiom	transpose_matrix2(_,0,_,_) => []

  rule	int_sub(neq,1) => neq' &
	int_add(eqno,1) => eqno' &
	transpose_matrix2(m,neq',eqno',mt) => mt'&
	transpose_row(m,eqno',1) => row
	-------------------------
	transpose_matrix2(m,neq,eqno,mt) => row::mt'
end

(* relation: transpose_row
 ** Input: IncidenceMatrix (eqn => var)
 ** Input: row number (variable)
 ** Input: iterator (start with one)
**)
relation transpose_row: (IncidenceMatrix,int(*row*),int(*iter*)) => int list =

  axiom	transpose_row([],_,_) => []
	
  rule	list_member(varno,m) => true &
	int_add(eqn,1) => eqn' &
	transpose_row(ms,varno,eqn') => res
	---------------------------
	transpose_row(m::ms,varno,eqn) => eqn::res

  rule	list_member(varno,m) => false &
	int_add(eqn,1) => eqn' &
	transpose_row(ms,varno,eqn') => res
	---------------------------
	transpose_row(m::ms,varno,eqn) => res

  rule	print "-transpose_row failed\n" 
	-------------------------------
	transpose_row(_,_,_) => fail
end

relation dump_incidence_matrix: IncidenceMatrix => () =

  rule	print "Incidence Matrix\n (row == equation)" &
	print "====================================\n" &
	dump_incidence_matrix2(m) 
	-------------------------
	dump_incidence_matrix(m) => ()
end 

relation dump_incidence_matrix_inv: IncidenceMatrix => () =

  rule	print "Transpose Incidence Matrix (row == var)\n" &
	print "=====================================\n" &
	dump_incidence_matrix2(m) 
	-------------------------
	dump_incidence_matrix_inv(m) => ()
end 
	
relation dump_incidence_matrix2: IncidenceMatrix => () =

  axiom	dump_incidence_matrix2([]) => ()

  rule	dump_incidence_row(row) &
	dump_incidence_matrix2(rows)
	---------------------------
	dump_incidence_matrix2(row::rows)
end

relation dump_incidence_row: int list => () =

  rule	print "\n"
	----------
	dump_incidence_row [] 

  rule	int_string(x) => s &
	print s & print " " &
	dump_incidence_row(xs) 
	----------------------
	dump_incidence_row (x::xs)
end

relation dump_matching: (int vector) => () =
	
  rule	print "Matching\n" &
	print "========\n" &
	dump_matching2(v,0) 
	-------------------
	dump_matching(v) 
end

relation dump_matching2: (int vector, int) => () =

  rule	vector_length(v) => len &
	int_add(i,1) => i' &
	int_eq(len,i') => true &
	int_string i' => s & 
	print "var " & print s & 
	print " is solved in eqn " &
	vector_nth(v,i) => eqn &
	int_string eqn => s2 & print s2 & print "\n" 
	---------------------
	dump_matching2(v,i) 

  rule	vector_length(v) => len &
	int_add(i,1) => i' &
	int_eq(len,i') => false &
	int_string i' => s & 
	print "var " & print s & 
	print " is solved in eqn " &
	vector_nth(v,i) => eqn &
	int_string eqn => s2 & print s2 & print "\n" &
	dump_matching2(v,i') 
	---------------------
	dump_matching2(v,i) 
end

relation matching_algorithm: (DAELow,IncidenceMatrix, IncidenceMatrixT) 
	  => ( int vector , int vector,
	      DAELow,IncidenceMatrix, IncidenceMatrixT) =

  rule	list_length(m) => nvars &
	list_length(mt) => neqns &
	Util.list_fill(0,nvars) => assign1 &
	Util.list_fill(0,nvars) => assign2 &
	matching_algorithm2(dae,m,mt,nvars,neqns,1,assign1,assign2) 
	  => (lst1, lst2,dae,m,mt) &
	list_vector(lst1) => vec1 &
	list_vector(lst2) => vec2 
	----------------------
	matching_algorithm(dae,m,mt) => (vec1,vec2,dae,m,mt)
end

relation matching_algorithm2: (DAELow,IncidenceMatrix, IncidenceMatrixT
			       ,int (* number of vars*)
			       ,int (* number of eqns*)
			       ,int (* current var*)
			       , int list, int list) 
	  =>  (int list, 
	       int list,
	       DAELow,
	       IncidenceMatrix, 
	       IncidenceMatrixT) =
	  
  rule	int_eq(nv,i) => true &
	DAEEXT.init_marks(nv,nf) &(* eMark(i)=vMark(i)=false *)
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2')  (* exit loop *)
	---------------------------------------------
	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2) 
	  => (ass1',ass2',dae,m,mt)

  rule	int_add(i,1) => i' &
	DAEEXT.init_marks(nv,nf) &(* eMark(i)=vMark(i)=false *)
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2') & 
	matching_algorithm2(dae,m,mt,nv,nf,i',ass1',ass2') 
	  => (ass1'',ass2'',dae,m,mt)
	----------------------------------------------------------------
	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2) 
	  => (ass1'',ass2'',dae,m,mt) 

  rule	(* path_found failed, Try index reduction using dummy derivatives.
	 When a constraint exist between states and index reduction is needed
	 the dummy derivative will select one of the states as a dummy state
	 (and the derivative of that state as a dummy derivative).
	 For instance, u1=u2 is a constraint between states. Choose u1 as dummy state
	 and der(u1) as dummy derivative, named der_u1. The differentiated function 
	 then becomes: der_u1 = der(u2).
	 In the dummy derivative method this equation is added and the original equation
	 u1=u2 is kept. This is not the case for the original pantilides algorithm, where
	 the original equation is removed from the system.
	 *)
	reduce_index_dummy_der(dae,m,mt,nv,nf,i) 
	  => (dae as DAELOW(VARIABLES(vars,_),VARIABLES(knvars,_),eqns,_),m,mt) &
	  (* and try again, restarting. This could be optimized later. It should not
	   be necessary to restart the matching, according to Bernard Bachmann. Instead one 
	   could continue the matching as usual. This was tested (2004-11-22) and it does not 
	   work to continue without restarting.
	   For instance the Influenca model "../testsuite/mofiles/Influenca.mo" does not work if
	   not restarting.*)
	vector_length(vars) => nv' &
 	list_length(eqns) => nf' &
	Util.list_fill(0,nv') => ass1 &
	Util.list_fill(0,nf') => ass2 &
	matching_algorithm2(dae,m,mt,nv',nf',1,ass1,ass2)
	  => (ass1',ass2',dae,m,mt)
	------------------------
	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2) 
	  => (ass1',ass2',dae,m,mt)

  rule	print "Error, model singular. i=" &
	int_string(i) => is & print is & print "\n" 
	& DAEEXT.dump_marked_equations(nf) 
	& DAEEXT.dump_marked_variables(nv)
	------------------------------
 	matching_algorithm2(dae,m,mt,nv,nf,i,ass1,ass2) => fail
end

relation reduce_index_dummy_der: (DAELow, 
				  IncidenceMatrix, 
				  IncidenceMatrixT,
				  int, (* number of vars*)
				  int, (* number of eqns*)
				  int) (* i *)
			    
			    => (DAELow,
				IncidenceMatrix, 
				IncidenceMatrixT) =
	
  rule	marked_eqns(nf) => eqns &

	Util.list_map(eqns,int_string) => es &
	Util.string_delimit_list(es,", ") => es' &
	(*print "marked equations " & print es' & print "\n" &*)
	(* Collect the states in the equations that are singular, i.e. composing
	 a constraint between states.*)
	states_in_eqns(eqns,dae,m,mt) => (states,stateindx) &
	differentiate_eqns(dae,m,mt,nv,nf,eqns) 
	  => (dae,m,mt,nv,nf,deqns) &	
	select_dummy_state(states,stateindx,dae,m,mt) => (state,stateno) & 
(*	Exp.print_component_ref_str state => statestr &
	print "Choosen dummy state: " & print statestr & print "\n" &*)
	new_dummy_var(state,dae) => (dummy_der,dae) &
	eqns_for_var(mt,stateno) => reqns &
	Util.list_union_p(deqns,reqns,int_eq) => changedeqns &
	(* We need to change variables in the differentiated equations and in the 
	  equations having the dummy derivative *)
	replace_dummy_der(state,dummy_der,dae,m,mt,changedeqns) => (dae,m,mt) &
	make_algebraic(dae,state) => dae & 
	update_incidence_matrix(dae,m,mt,changedeqns) => (m,mt) 
	---------------------------------------------
	reduce_index_dummy_der(dae,m,mt,nv,nf,i) 
	  => (dae,m,mt)

  rule	marked_eqns(nf) => eqns &

	Util.list_map(eqns,int_string) => es &
	Util.string_delimit_list(es,", ") => es' &
	states_in_eqns(eqns,dae,m,mt) => ([],_) &
	print_equations(eqns,dae) 
	---------------------------------------------
	reduce_index_dummy_der(dae,m,mt,nv,nf,i) 
	  => fail

  rule	print "-reduce_index_dummy_der failed\n"
	--------------------
	reduce_index_dummy_der(_,_,_,_,_,_) => fail
end

(** relation: update_incidence_matrix
 ** Takes a daelow and the incidence matrix and its transposed represenation and a list of 
 ** equation indexes that needs to be updated.
 ** First the IncidenceMatrix is updated, i.e. the mapping from equations to variables.
 ** Then, by collecting all variables in the list of equations to update, a list of changed variables
 ** are retrieved. This is used to update the IncidenceMatrixT (transpose) mapping from variables to 
 ** equations.
 ** The relation returns an updated incidence matrix.
 **)
relation update_incidence_matrix:(DAELow,
				  IncidenceMatrix, 
				  IncidenceMatrixT,
				  int list) (* list of equations to update*)
	  => (IncidenceMatrix, 
	      IncidenceMatrixT) =
 
 rule	update_incidence_matrix2(dae,m,eqns) => (m',changedvars) &
	Util.list_flatten(changedvars) => changedvars' &
	update_transposed_matrix(changedvars',m',mt) => mt' 
	------------------------------
	update_incidence_matrix(dae,m,mt,eqns) => (m',mt')
end

relation update_incidence_matrix2: (DAELow,
				    IncidenceMatrix,
				    int list) (* list of equations to update *)
	  => (IncidenceMatrix, 
	      int list list ) (* changed vars *) =

  axiom	update_incidence_matrix2(dae,m,[]) => (m,[[]])

  rule	int_sub(e,1) => e' &
	list_nth(daeeqns,e') => eqn &
	incidence_row(vars,eqn) => row &
	Util.list_replaceat_with_fill(row,e',m,[]) => m' &
	vars_in_eqn(m',e) => changedvars1 &
	update_incidence_matrix2(dae,m',eqns) => (m'',changedvars2) 
	---------------------------------------------------
	update_incidence_matrix2(dae as DAELOW(vars,knvars,daeeqns,daeseqns),m,e::eqns) => (m'',changedvars1::changedvars2)

  rule	print "-update_incididence_matrix failed\n" 
	-------------------------------------------
	update_incidence_matrix2(_,_,_) => fail

end

(* relation: update_transposed_matrix
 ** Takes a list of variables and the transposed IncidenceMatrix, and updates the
 ** variable rows.
**)
relation update_transposed_matrix: (int list(*var list*), IncidenceMatrix,IncidenceMatrixT) 
	  => IncidenceMatrixT =

  axiom	update_transposed_matrix([],m,mt) => mt

  rule	transpose_row(m,v,1) => row' &
	int_sub(v,1) => v' &
	Util.list_replaceat_with_fill(row',v',mt,[]) => mt' &
	update_transposed_matrix(vars,m,mt') => mt''
	-------------------------
	update_transposed_matrix(v::vars,m,mt) => mt''

  rule	print "-update_transposed_matrix failed\n" 
	------------------
	update_transposed_matrix(_,_,_) => fail
end

(** relation: make_algebraic
 Make the variable a dummy derivative, i.e. change varkind from STATE to DUMMY_STATE 
 **)
relation make_algebraic: (DAELow, 
			  Exp.ComponentRef) (* state *)
	  => (DAELow) =
	  
  rule	get_var(cr,vars) => (VAR(cr,kind,d,t,b,value,dim,start,idx,name,class) ,indx) &
	add_var(VAR(cr,DUMMY_STATE,d,t,b,value,dim,start,idx,name,class),vars) => vars'
	-------------------------------------------------------------------------
	make_algebraic(DAELOW(vars,kv,e,se),cr) => DAELOW(vars',kv,e,se)
end	  

(* replaces der(state) with the variable dummy der *)
relation replace_dummy_der: (Exp.ComponentRef, (* state *)
			     Exp.ComponentRef, (* dummy der name *)
			     DAELow, 
			     IncidenceMatrix, 
			     IncidenceMatrixT,
			     int list) 
	  => ( DAELow, 
	      IncidenceMatrix, 
	      IncidenceMatrixT) =
	
  axiom	replace_dummy_der(state,dummy,dae,m,mt,[]) => (dae,m,mt)
	
  rule	int_sub(e,1) => e' &
	list_nth(eqns,e') => eqn &
	replace_dummy_der2(state,dummyder,eqn) => eqn' &
	replace_dummy_der_others(eqn',v) => (eqn',v') &
	(*incidence_row(v'',eqn') => row' &
	 Util.list_replaceat(row',e',m) => m' &
	 transpose_matrix(m') => mt' &*)
	Util.list_replaceat(eqn',e',eqns) => eqns' &
	replace_dummy_der(state,dummyder,DAELOW(v',kv,eqns',seqns),m,mt,rest) 
	  => (dae,m,mt) 
	  -------------------------------
	replace_dummy_der(state,dummyder,DAELOW(v,kv,eqns,seqns),m,mt,e::rest)
	  => (dae,m,mt)
	  
  rule	print "-replace_dummy_der failed\n" 
	-------------------
	replace_dummy_der(_,_,_,_,_,_) => fail
end

(* replaces der(state) with dummy_der variable in equation *)
relation replace_dummy_der2:(Exp.ComponentRef,
			     Exp.ComponentRef,
			     Equation) => Equation =
	
  rule	let dercall = Exp.CALL(Absyn.IDENT("der"),
			       [Exp.CREF(st,Exp.REAL)],
			       false,
			       false) &
	Exp.replace_exp(e1,dercall, Exp.CREF(dummyder,Exp.REAL)) => (e1',_) &
	Exp.replace_exp(e2,dercall, Exp.CREF(dummyder,Exp.REAL)) => (e2',_)
	---------------------------------------------------------------
	replace_dummy_der2(st,dummyder,EQUATION(e1,e2)) => EQUATION(e1',e2')
	
  rule	print "-replace_dummy_der2 failed\n" 
	---------------
	replace_dummy_der2(_,_,_) => fail
end
(** relation: replace_dummy_der_others
 ** This relation replaces
 ** 1. der(der_s)  with der2_s (Where der_s is a dummy state)
 ** 2. der(der(v)) with der2_v (where v is a state)
 ** 3. der(v)  for alg. var v with der_v 
 ** in the 'Equation' given as arguments. To do this it needs the 'Variables' 
 ** also passed as argument to the relation to e.g. determine if a variable
 ** is a dummy variable, etc.
 **)
relation replace_dummy_der_others:(Equation, Variables) => (Equation, Variables) =
	
	
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars') &
	replace_dummy_der_others_exp(e2,vars') => (e2', vars'')
	---------------------------------------------------------------
	replace_dummy_der_others(EQUATION(e1,e2),vars)
	  => (EQUATION(e1',e2'),vars'')

  rule	not replace_dummy_der_others_exp(e1,vars) => (_,_) &
	replace_dummy_der_others_exp(e2,vars) => (e2', vars')
	----------------------
	replace_dummy_der_others(EQUATION(e1,e2),vars)
	  => (EQUATION(e1,e2'),vars')

  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars') &
	not replace_dummy_der_others_exp(e2,vars) => (_, _)
	----------------------
	replace_dummy_der_others(EQUATION(e1,e2),vars)
	  => (EQUATION(e1',e2),vars')

  rule	not replace_dummy_der_others_exp(e1,vars) => (_,_) &
	not replace_dummy_der_others_exp(e2,vars) => (_, _)
	----------------------
	replace_dummy_der_others(EQUATION(e1,e2),vars)
	  => (EQUATION(e1,e2),vars)

  rule	print "-replace_dummy_der_others failed\n" 
	---------------------
	replace_dummy_der_others(_,_) => fail 
end

(** relation replace_dummy_der_others_exp
 ** Helper relation for replace_dummy_der_others
 **)
relation replace_dummy_der_others_exp: (Exp.Exp, Variables) => (Exp.Exp,Variables) =
	
  axiom	replace_dummy_der_others_exp(e as Exp.ICONST(_),vars) => (e,vars)
  axiom	replace_dummy_der_others_exp(e as Exp.RCONST(_),vars) => (e,vars)
  axiom	replace_dummy_der_others_exp(e as Exp.SCONST(_),vars) => (e,vars)
  axiom	replace_dummy_der_others_exp(e as Exp.BCONST(_),vars) => (e,vars)	
  axiom	replace_dummy_der_others_exp(e as Exp.CREF(_,_),vars) => (e,vars)
	
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.BINARY(e1,op,e2),vars)
	  => (Exp.BINARY(e1',op,e2'),vars2)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.LBINARY(e1,op,e2),vars)
	  => (Exp.LBINARY(e1',op,e2'),vars2)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.UNARY(op,e1),vars)
	  => (Exp.UNARY(op,e1'),vars1)

  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1)
	---------------------------------------
	replace_dummy_der_others_exp(Exp.LUNARY(op,e1),vars)
	  => (Exp.LUNARY(op,e1'),vars1)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2) 
	--------------------------------------------
	replace_dummy_der_others_exp(Exp.RELATION(e1,op,e2),vars)
	  => (Exp.RELATION(e1',op,e2'), vars2)
	  
  rule	replace_dummy_der_others_exp(e1,vars) => (e1',vars1) &
	replace_dummy_der_others_exp(e2,vars1) => (e2',vars2) &
	replace_dummy_der_others_exp(e3,vars2) => (e3',vars3) 
	--------------------------------------------
	replace_dummy_der_others_exp(Exp.IFEXP(e1,e2,e3),vars)
	  => (Exp.IFEXP(e1',e2',e3'),vars3)
	  
  rule	(* der(der(s)) s is state => der_der_s *)
	get_var(cr,vars) => (VAR(_,STATE,a,b,c ,d,e,f,g,h,i),_) &
	create_dummy_var(cr) => dummyder & 
	create_dummy_var(dummyder) => dummyder' &
	add_var(VAR(dummyder',DUMMY_DER,a,b,NONE,NONE,e,NONE,0,"dummyder",i),vars) => vars'
	--------------------------------------------------------------------------------
	replace_dummy_der_others_exp(Exp.CALL(Absyn.IDENT("der"),
					      [Exp.CALL(Absyn.IDENT("der"),
							[Exp.CREF(cr,_)],
							_,
							 _)],
					       _,
					       _),vars)
	 => (Exp.CREF(dummyder',Exp.REAL),vars')

   rule  (* der(der_s)) der_s is dummy var => der_der_s *)
	get_var(cr,vars) => (VAR(_,DUMMY_DER,a,b,c,d,e,f,g,h,i),_) &
	create_dummy_var(cr) => dummyder & 
	add_var(VAR(dummyder,DUMMY_DER,a,b,NONE,NONE,e,NONE,0,"dummyder",i),vars) => vars'
	-------------------------------------------------------
	replace_dummy_der_others_exp(Exp.CALL(Absyn.IDENT("der"),
					      [Exp.CREF(cr,_)],
					      _,
					      _),vars)
	  => (Exp.CREF(dummyder,Exp.REAL),vars')
	  
	  
  rule  (* der(v) v is alg var => der_v *)
	get_var(cr,vars) => (VAR(_,VARIABLE,a,b,c,d,e,f,g,h,i),_) &
	create_dummy_var(cr) => dummyder & 
	add_var(VAR(dummyder,DUMMY_DER,a,b,NONE,NONE,e,NONE,0,"dummyder",i),vars) => vars'
	-------------------------------------------------------
	replace_dummy_der_others_exp(Exp.CALL(Absyn.IDENT("der"),
					      [Exp.CREF(cr,_)],
					      _,
					      _),vars)
	  => (Exp.CREF(dummyder,Exp.REAL),vars')
	  
end

relation var_equal: (Var,Var) => bool =
	
  rule	Exp.cref_equal(cr1,cr2) => res 
	------------------------------
	var_equal(VAR(cr1,_,_,_,_ ,_,_,_,_,_,_),VAR(cr2,_,_,_,_ ,_,_,_,_,_,_)) => res
end

(* creates a new variable named "der_"+<varname> and adds it to the dae *) 
relation new_dummy_var:(Exp.ComponentRef,DAELow) => (Exp.ComponentRef,DAELow) =
	
  rule	get_var(var,vars) => (VAR(_,kind,dir,tp,bind,value,dim,start,idx,name,class),_) &
	create_dummy_var(var) => dummyvar &
	add_var(VAR(dummyvar,DUMMY_DER,dir,tp,NONE,NONE,dim,NONE,0,"dummyvar",class),vars) 
	  => vars'
	-----------------------------------
	new_dummy_var(var,DAELOW(vars,kv,eqns,seqns)) 
	  => (dummyvar, DAELOW(vars',kv,eqns,seqns))
end

relation create_dummy_var: (Exp.ComponentRef) => Exp.ComponentRef =
	
  rule	string_append("der_",id) => id'
	-------------------------------
	create_dummy_var(Exp.CREF_IDENT(id,subs)) 
	  => Exp.CREF_IDENT(id',subs)
	  
  rule	create_dummy_var(cr) => cr'
	------------------------
	create_dummy_var(Exp.CREF_QUAL(id,subs,cr)) 
	  => Exp.CREF_QUAL(id,subs,cr')
end

(* Heuristic to select among the states which one will be transformed into
 an algebraic variable, a so called dummy state (dummy derivative) *)
relation select_dummy_state: (Exp.ComponentRef list, (* variable names *)
			      int list, (* variable numbers *)
			      DAELow, 
			      IncidenceMatrix,
			      IncidenceMatrixT) 
	  => (Exp.ComponentRef, int) =
	  
	  (* for now, select the first one... *)
  axiom	select_dummy_state(s::_,sn::_,_,_,_) => (s,sn)
	
  rule	print "Error, no state to select\n" 
	------------------------------------
	select_dummy_state([],_,_,_,_) => fail
end

relation states_in_eqns: (int list (* eqns *),
			  DAELow, 
			  IncidenceMatrix,
			  IncidenceMatrixT) 
	  => (Exp.ComponentRef list, (* name for each state *)
	      int list)  (* number for each state *)
	=
	
  axiom	states_in_eqns([],_,_,_) => ([],[])
	
  rule	states_in_eqns(rest,DAELOW(vars,kv,eqns,seqns),m,mt) => (res1,res2) &
	int_sub(e,1) => e' &
	list_nth(eqns,e') => eqn &
	states_in_eqn(eqn,vars) => vars2 &
	vector_list(varvec) => vars &
	states_in_vars(vars,vars2) => (res11,res22) &
	list_append(res11,res1) => res1' &
	list_append(res22,res2) => res2'
	--------------------------------
	states_in_eqns(e::rest,DAELOW(vars as VARIABLES(varvec,bt),kv,eqns,seqns),m,mt) => (res1',res2')
	
  rule	print "-states_in_eqns failed\n"
	-------------------------
	states_in_eqns(_,_,_,_) => fail
	
end

relation states_in_vars: (Var list, int list) => 
	(Exp.ComponentRef list, (* names of the states *)
	 int list ) (* number for each state *)  =
	
  axiom	states_in_vars (vars,[]) => ([],[])
	
  rule	int_sub(v,1) => v' &
	list_nth(vars,v') => VAR(cr,_,_,_,_, _,_,_,_,_,_) &
	states_in_vars(vars,rest) => (res1,res2)  
	---------------------------------
	states_in_vars(vars,v::rest) => (cr::res1,v::res2)
	
  rule	states_in_vars(vars,rest) => (res1,res2)
	----------------------------------------
	states_in_vars(vars,v::rest) => (res1,res2)
end

relation reassign_vars:(int list, (* variables *)
			int list, (* assignments *)
			int list) (* assignmentsT *)
	  => (int list, int list) (*assignments, assignmentsT*) =
	  
  axiom	reassign_vars([],ass1,ass2) => (ass1,ass2)
	
  rule	get_assigned(v,ass1,ass2) => vass &
	DAEEXT.get_f(vass) => fassj &
	assign(v,fassj,ass1,ass2) => (ass1,ass2) &
	reassign_vars(vs,ass1,ass2) => (ass1,ass2) 
	---------------------
	reassign_vars(v::vs,ass1,ass2) => (ass1,ass2)
end

relation differentiate_eqns: (DAELow, 
			      IncidenceMatrix, 
			      IncidenceMatrixT,
			      int, (* number of vars*)
			      int, (* number of eqns*)
			      int list) (* equations *)
	  => (DAELow, 
	      IncidenceMatrix, 
	      IncidenceMatrixT,
	      int, (* number of vars*)
	      int, (* number of eqns*) 
	      int list) (* differentiated equations *) =
  axiom	differentiate_eqns(dae,m,mt,nv,nf,[]) => (dae,m,mt,nv,nf,[])
	
  rule	int_sub(e,1) => e' &
	list_nth(eqns,e') => eqn &
	time_varying_vars(dae) => timevars &
	Derive.differentiate_equation_time(eqn,timevars) => eqn' &
	(* update equation row in IncidenceMatrix *)	
	Debug.fprint("bltdump", "High index problem, differentiated equation: " )&
	print "differentiated equation " &
	equation_str eqn => str & 
	print str & print "\n" &
	Debug.fprint("bltdump", str) &
	Debug.fprint("bltdump", " to ") & 
	equation_str eqn' => str &
	print " to " & print str &  print "\n" &
	Debug.fprint("bltdump",str) & 
	Debug.fprint("bltdump", "\n") &
	list_append(eqns,[eqn']) => eqns' &
	list_length(eqns') => leneqns & (* length gives index of new equation *)
	differentiate_eqns(DAELOW(v,kv,eqns',seqns),m,mt,nv,nf,es) 
	  => (dae,m,mt,nv,nf,reqns)
	  ----------------------------
	differentiate_eqns(dae as DAELOW(v,kv,eqns,seqns),m,mt,nv,nf,e::es) 
	  => (dae,m,mt,nv,nf,leneqns::e::reqns)
	  
  rule	print "-differentiate_eqns failed\n" 
	----------------------------
	differentiate_eqns(_,_,_,_,_,_) => fail
end

(** relation time_varying_vars
 ** Returns a list of componentreference names of all variables that are time varying.
 **)
relation time_varying_vars: DAELow => Exp.ComponentRef list =

  rule	vector_list(varvec) => vars &
	time_varying_vars2(vars) => res
	------------------------------
	time_varying_vars(DAELOW(VARIABLES(varvec,bt),_,_,_)) => res
end

(** relation: time_varying_vars2
 ** helper relation to time_varying_vars
 **)
relation time_varying_vars2:(Var list) => Exp.ComponentRef list =
	
  axiom	time_varying_vars2([]) => []

  rule	time_varying_vars2(vs) => res 
	-----------------------------------------
	time_varying_vars2(VAR(cr,STATE,_,_,_ ,_,_,_,_,_,_)::vs) 
	  => cr::res
	  
  rule	time_varying_vars2(vs) => res 
	-----------------------------------------
	time_varying_vars2(VAR(cr,DUMMY_DER,_,_,_, _,_,_,_,_,_)::vs) 
	  => cr::res
	  
  rule	time_varying_vars2(vs) => res 
	-----------------------------------------
	time_varying_vars2(VAR(cr,VARIABLE,_,_,_, _,_,_,_,_,_)::vs) 
	  => cr::res
	  
  rule	time_varying_vars2(vs) => res 
	-----------------------------------------
	time_varying_vars2(VAR(cr,DUMMY_STATE,_,_,_, _,_,_,_,_,_)::vs) 
	  => cr::res

  rule	time_varying_vars2(vs) => res 
	-----------------------------------------
	time_varying_vars2(_::vs) => res
end

relation add_marked_vars:(DAELow, 
			  IncidenceMatrix, 
			  IncidenceMatrixT,
			  int, (* number of vars*)
			  int, (* number of eqns*)
			  int list) (* marked vars *) 
	=> (DAELow, 
	    IncidenceMatrix, 
	    IncidenceMatrixT,
	    int, (* number of vars*)
	    int) (* number of eqns*) =
  axiom	add_marked_vars(dae,m,mt,nv,nf,[]) => (dae,m,mt,nv,nf)
	
  rule	(* TODO remove variable from dae and m,mt and add der{variable} instead*)
	int_add(nv,1) => nv' &
	DAEEXT.set_v(v,nv') &
	
	add_marked_vars(dae,m,nt,nv',nf,vs) => (dae,m,mt,nv,nf)
	-------------------------------------------------------
	add_marked_vars(dae,m,nt,nv,nf,v::vs) => (dae,m,mt,nv,nf)
end

relation marked_vars: (int) => int list =
	
  rule	marked_vars2(0,size) => res
	----------------
	marked_vars(size) => res
end

relation marked_vars2: (int,int) => int list =
	
  rule	int_eq(size,pos) => true
	------------------------
	marked_vars2(pos,size) => []
	
  rule	DAEEXT.get_v_mark(pos) => true &
	int_add(pos,1) => v &
	marked_vars2(v,size) => res
	---------------------
	marked_vars2(pos,size) => pos::res
	
  rule	DAEEXT.get_v_mark(pos) => false &
	int_add(pos,1) => v &
	marked_vars2(v,size) => res
	---------------------
	marked_vars2(pos,size) => res
end

relation marked_eqns: (int) => int list  =
	
  rule	marked_eqns2(1,size) => res
	----------------
	marked_eqns(size) => res
	
  rule	print "-marked_eqns failed\n" 
	-----------------
	marked_eqns(_) => fail
end

relation marked_eqns2: (int,int) => int list =

  rule	int_eq(size,pos) => true &
	DAEEXT.get_e_mark(pos) => true 
	------------------------
	marked_eqns2(pos,size) => [pos]

  rule	int_eq(size,pos) => true &
	DAEEXT.get_e_mark(pos) => false
	------------------------
	marked_eqns2(pos,size) => []

  rule	DAEEXT.get_e_mark(pos) => true &
	int_add(pos,1) => v &
	marked_eqns2(v,size) => res
	---------------------
	marked_eqns2(pos,size) => pos::res

  rule	DAEEXT.get_e_mark(pos) => false &
	int_add(pos,1) => v &
	marked_eqns2(v,size) => res
	---------------------
	marked_eqns2(pos,size) => res
end

relation path_found: (IncidenceMatrix, IncidenceMatrixT, int, 
		      int list, int list) 
	=> (int list, int list) =


  rule	int_string  i => is &
	DAEEXT.e_mark(i) (*Sideeffect*) &
	assign_one_in_eqn(m,mt,i,ass1,ass2) => (ass1',ass2')
	------------
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2')

  rule	forall_unmarked_vars_in_eqn(m,mt,i,ass1,ass2) => (ass1',ass2')
	-----------------------------------------------------------
	path_found(m,mt,i,ass1,ass2) => (ass1',ass2')
end

relation assign_one_in_eqn: (IncidenceMatrix, IncidenceMatrixT, int, 
		      int list, int list) => (int list, int list) =
	
  rule  vars_in_eqn(m,i) => vars &
	assign_first_unassigned(i,vars,ass1,ass2) => (ass1',ass2') 
	----------------------------------------------------------
	assign_one_in_eqn(m,mt,i,ass1,ass2) => (ass1',ass2')

	(*  rule	print "assign_one_in_eqn failed\n" 
	 ----------------------------------
	 assign_one_in_eqn(_,_,_,_,_) => fail*)
end 

relation states_in_eqn: (Equation, Variables) => int list =

  rule	states_as_algebraic_vars(vars) => vars' &
	incidence_row(vars',eqn) => res
	-----------------
	states_in_eqn(eqn,vars) => res
end

(** relation: states_as_algebraic_vars
 ** Return the subset of variables consisting of all states, but changed varkind to variable.
 **)
relation states_as_algebraic_vars:( Variables) => Variables =
	 
  rule	(* Creates a new set of Variables from a Var list *)
	vector_list(varvec) => vars &
	states_as_algebraic_vars2(vars) => vars' &
	empty_vars() => v1 &
	Util.list_fold(vars',add_var,v1) => v1' 
	----------------------------------------------
	states_as_algebraic_vars(VARIABLES(varvec,bt))  => v1'
end

(** relation: states_as_algebraic_vars2
 ** helper relation to states_as_algebraic_vars
**)
relation states_as_algebraic_vars2: (Var list ) => Var list =

  axiom	states_as_algebraic_vars2 [] => []

  rule	(* states treated as algebraic variables *)
	states_as_algebraic_vars2(vs) => res 
	------------------------------------
	states_as_algebraic_vars2(VAR(cr,STATE,a,b,c,d,e,f,g,h,i)::vs) 
	  => (VAR(cr,VARIABLE,a,b,c,d,e,f,g,h,i)::res)

  rule	(* other variables treated as known *)
	states_as_algebraic_vars2(vs) => res 
	------------------------------------
	states_as_algebraic_vars2(VAR(cr,_,a,b,c,d,e,f,g,h,i)::vs) 
	  => (VAR(cr,CONST,a,b,c,d,e,f,g,h,i)::res)

  rule	states_as_algebraic_vars2(vs) => res 
	----------------------
	states_as_algebraic_vars2(_::vs) 
	  => res
end

relation vars_in_eqn: (IncidenceMatrix, int) => int list =

  rule	int_sub(n,1) => n' &
	list_nth(m,n') => res
	--------------------
	vars_in_eqn(m,n) => res 

  rule	print "vars_in_eqn failed, indx="  &
	int_string indx => s & print s & print "\n"
	----------------------------
	vars_in_eqn(_,indx) => fail
end

relation eqns_for_var: (IncidenceMatrixT, int) => int list =

  rule	int_sub(n,1) => n' &
	list_nth(mt,n') => res
	--------------------
	eqns_for_var(mt,n) => res 

  rule	print "eqns_for_var failed, indx="  &
	int_string indx => s & print s & print "\n"
	----------------------------
	eqns_for_var(_,indx) => fail
end

relation assign_first_unassigned: (int,int list, int list, int list) 
	  => (int list, int list) =

  rule	get_assigned(v,ass1,ass2) => 0 &
	assign(v,i,ass1,ass2) => (ass1',ass2')
	--------------------------------------
	assign_first_unassigned(i,v::vs,ass1,ass2) => (ass1',ass2')
 
  rule	assign_first_unassigned(i,vs,ass1,ass2) => (ass1',ass2')
	--------------------------------------------------------
	assign_first_unassigned(i,v::vs,ass1,ass2) => (ass1',ass2')
end

relation get_assigned: (int, int list, int list) => int =
	
  rule	int_sub(v,1) => v' &
	list_nth(m,v') => res
	-------------------
	get_assigned(v,m,_) => res
end

relation assign: (int,int, int list, int list) => (int list, int list) =

  rule	(*print "assign " & int_string v => vs &
	int_string e => es & print vs & print " to eqn " &
	print es & print "\n" &*)
	int_sub(v,1) => v' &
	int_sub(e,1) => e' &
	Util.list_replaceat(e,v',ass1) => ass1' &
	Util.list_replaceat(v,e',ass2) => ass2'
	----------------------------------------
	assign(v,e,ass1,ass2) => (ass1',ass2')
end

relation forall_unmarked_vars_in_eqn: (IncidenceMatrix, IncidenceMatrixT, int, 
		      int list, int list) 
	  => (int list, int list)  =
	
  rule	vars_in_eqn(m,i) => vars &
	Util.list_matching(vars,is_not_v_marked) => vars' &
	forall_unmarked_vars_in_eqn_body(m,mt,i,vars',ass1,ass2) 
	  => (ass1',ass2')
	-------------------------
	forall_unmarked_vars_in_eqn (m,mt,i,ass1,ass2) => (ass1',ass2')
end

relation is_not_v_marked: int => () =

  rule	DAEEXT.get_v_mark(i) => false
	------------------
	is_not_v_marked(i)
end

relation forall_unmarked_vars_in_eqn_body: (IncidenceMatrix, IncidenceMatrixT
					    , int
					    , int list (* var list*)
					    , int list (* assignment*) 
					    , int list (* assignment*) )  
	  => (int list, int list)  =

  rule	DAEEXT.v_mark(v) &
	get_assigned(v,ass1,ass2) => assarg &
	path_found(m,mt,assarg,ass1,ass2) => (ass1',ass2') &
	assign(v,i,ass1',ass2') => (ass1'',ass2'')
	----------------------------
	forall_unmarked_vars_in_eqn_body(m,mt,i,vars as (v::vs),ass1,ass2) 
	  => (ass1'',ass2'')
	
  rule	DAEEXT.v_mark(v) &
	forall_unmarked_vars_in_eqn_body(m,mt,i,vs,ass1,ass2) => (ass1',ass2')
	--------------------------------------------------------------------
	forall_unmarked_vars_in_eqn_body(m,mt,i,vars as (v::vs),ass1,ass2)
	  => (ass1',ass2')
end

relation strong_components: (IncidenceMatrix, IncidenceMatrixT,
			     int vector, int vector) => 
	(int list list ) (* list of components *) =

  rule	list_length(m) => n &
	DAEEXT.init_lowlink(n) &
	DAEEXT.init_number(n) &
	strong_connect_main(m,mt,ass1,ass2,n,0,1,[],[]) 
	  => (i,stack,comps) 

	-----------------------------------
	strong_components(m,mt,ass1,ass2) => (comps)

  rule	print "strong_components failed\n" 
	----------------------------------
	strong_components(_,_,_,_) => fail
end

relation strong_connect_main:(IncidenceMatrix,
			 IncidenceMatrixT,
			 int vector, (* Assignment *)
			 int vector, (* Assignment *)
			 int, (* n - number of equations *)
			 int, (* i *)
			 int, (* w *)
			 int list, (* stack *)
		         int list list) (* components *)
	  => (int, (* i *)
	      int list, (* stack *) 
	      int list list) (* components *) =
  rule	int_gt(w,n) => true
	-------------------
	strong_connect_main(m,mt,a1,a2,n,i,w,stack,comp) 
	  => (i,stack,comp)
	
  rule	DAEEXT.get_number(w) => 0 &
	strong_connect(m,mt,a1,a2,i,w,stack,comps)
	  =>(i,stack',comps) &
	int_add(w,1) => w' &
	strong_connect_main(m,mt,a1,a2,n,i,w',stack',comps)
	  => (i,stack'',comps) 
	-----------------------------
	strong_connect_main(m,mt,a1,a2,n,i,w,stack,comps)
	  => (i,stack'',comps)

  rule	DAEEXT.get_number(w) => num &
	int_eq(num,0) => false &
	int_add(w,1) => w' &
	strong_connect_main(m,mt,a1,a2,n,i,w',stack,comps)
	  => (i,stack',comps)
	---------------------------------
	strong_connect_main(m,mt,a1,a2,n,i,w,stack,comps)
	  =>(i,stack',comps)
end

relation strong_connect: (IncidenceMatrix,
			  IncidenceMatrixT,
			  int vector,
			  int vector,
			  int, (* i *)
			  int, (* v *)
			  int list, (* stack *)
			  int list list) (* components *)
	  => (int, (* i *)
	      int list, (* stack *)
	      int list list ) (* int list list*) =

  rule	int_add(i,1) => i' &
(*	set_number(number,v,i') => number' &
	set_lowlink(lowlink,v,i') => lowlink' &*)
	DAEEXT.set_number(v,i') &
	DAEEXT.set_lowlink(v,i') &
	let stack' = v::stack & 
	reachable_nodes(v,m,mt,a1,a2) => eqns &
	iterate_reachable_nodes(eqns,m,mt,a1,a2,i',v,stack',comps)
	  => (i',stack'',comps') &
	check_root(m,mt,a1,a2,i',v,stack'') 
	  => (i',stack''',comp) &
	cons_if_nonempty(comp,comps') => comps''
	---------------------------------------------
	strong_connect(m,mt,a1,a2,i,v,stack,comps) 
	  => (i',stack''',comps'')
end

relation cons_if_nonempty: (int list, int list list) => int list list =
  axiom	cons_if_nonempty ([],lst) => lst 

  axiom	cons_if_nonempty (e,lst) => e::lst
end 

relation reachable_nodes: (int,
			   IncidenceMatrix,
			   IncidenceMatrixT,
			   int vector,
			   int vector) => int list =
	
  rule	int_sub(eqn,1) => eqn' &
	vector_nth(a2,eqn') => var &
	int_sub(var,1) => var' &
	list_nth(mt,var') => reachable &
	Util.list_position(eqn,reachable) => pos &
	list_delete(reachable,pos) => reachable'
	----------------------------------------
	reachable_nodes(eqn,m,mt,a1,a2) => reachable'
end			  

relation iterate_reachable_nodes: (int list, 
				   IncidenceMatrix,
				   IncidenceMatrixT,
				   int vector,
				   int vector,
				   int, (* i *)
				   int, (* v *)
				   int list, (* stack *)
				   int list list) (* components *)
	  => (int, (* i *)
	      int list, (* stack *) 
	      int list list) (* components *) =
	
  rule	DAEEXT.get_number(w) => 0 &
	strong_connect(m,mt,a1,a2,i,w,stack,comps) 
	  => (i,stack,comps') &
	DAEEXT.get_lowlink(v) => lv &
	DAEEXT.get_lowlink(w) => lw &
	int_min(lv,lw) => minv &
	DAEEXT.set_lowlink(v,minv) &
	iterate_reachable_nodes(ws,m,mt,a1,a2,i,v,stack,comps') 
	  => (i,stack,comps'')
	  ----------------------------
	iterate_reachable_nodes(w::ws,m,mt,a1,a2,i,v,stack,comps) 
	  => (i, stack,comps'')
	  
  rule	DAEEXT.get_number(w) => nw &
	DAEEXT.get_number(v) => nv &
	int_lt(nw,nv) => true &
	list_member(w,stack) => true &
	DAEEXT.get_lowlink(w) => lowlinkw &
	int_min(nw,lowlinkw) => minv &
	DAEEXT.set_lowlink(v,minv) &
	iterate_reachable_nodes(ws,m,mt,a1,a2,i,v,stack,comps) 
	  => (i,stack,comps')
	  -----------------------
	iterate_reachable_nodes(w::ws,m,mt,a1,a2,i,v,stack,comps)
	  => (i,stack,comps')
	  
  rule	iterate_reachable_nodes(ws,m,mt,a1,a2,i,v,stack,comps) 
	  => (i,stack,comps')
	  -----------------------------
	iterate_reachable_nodes(w::ws,m,mt,a1,a2,i,v,stack,comps)
	  => (i,stack,comps')
	  
  axiom iterate_reachable_nodes([],m,mt,a1,a2,i,v,stack,comps)
	  => (i,stack,comps)
end

relation dump_list: (int list, string) => () =

  rule	Util.list_map(l,int_string) => s &
	Util.string_delimit_list(s,", ") => sl &
	print str & print sl & print "\n" 
	-------------------
	dump_list(l,str) => ()
end
	    
relation check_root: (IncidenceMatrix,
		      IncidenceMatrixT,
		      int vector,
		      int vector,
		      int, (* i *)
		      int, (* v *)
		      int list) (* stack *)
		     
	  => (int, (* i *)
	      int list, (* stack *) 
	      int list) (* comps *) =

  rule	DAEEXT.get_lowlink(v) => lv &
	DAEEXT.get_number(v) => nv &
	int_eq(lv,nv) => true &
	check_stack(m,mt,a1,a2,i,v,stack,[])
	=> (i,stack',comps) 
	------------------------------------
	check_root(m,mt,a1,a2,i,v,stack)
	  => (i, stack',comps)

  axiom	check_root(m,mt,a1,a2,i,v,stack) 
	  => (i,stack,[])	
end

relation check_stack: (IncidenceMatrix,
		       IncidenceMatrixT,
		       int vector,
		       int vector,
		       int, (* i *)
		       int, (* v *)
		       int list, (* stack *)
		       int list) (* component list*)
		     
	  => (int, (* i *) 
	      int list, (* stack *) 
	      int list) (* comps *) =

  rule	DAEEXT.get_number(top) => topn &
	DAEEXT.get_number(v) => vn &
	int_ge(topn,vn) => true &
	check_stack(m,mt,a1,a2,i,v,rest,comp) 
	  => (i,stack',comp') 
	  -----------------------------
	check_stack(m,mt,a1,a2,i,v,top::rest,comp)
	  => (i,stack',top::comp')
	  
  axiom	check_stack(m,mt,a1,a2,i,v,stack,comp) 
	  => (i,stack,comp)
end

relation dump_components: (int list list) => () =

  rule	print "Blocks\n" &
	print "=======\n" &
	Util.list_map_0(l,dump_components2)
	---------------------
	dump_components (l) => ()
end


relation dump_components2: (int list) => () =
	
  rule	print "{" & 
	Util.list_map(l,int_string) => ls &
	Util.string_delimit_list(ls,", ") =>  s &
	print s & print "}\n" 
	---------------------
	dump_components2(l) 
end
(* Translates the dae so variables are indexed into different arrays:
 xd for derivatives
 x for states
 dummy_der for dummy derivatives
 dummy for dummy states
 y for algebraic variables 
 p for parameters

 The equations are updated with the new variable names.
*)
relation translate_dae: DAELow => DAELow =
	
  rule	vector_list(varsvec) => vars &
	vector_list(kvvec) => kv &
	calculate_indexes(vars) => vars' &
	calculate_indexes(kv) => kv' &
	list_append(vars',kv') => totvars &
	variable_replacements(totvars,eqns) => (s,t) &
	(*Util.list_map(s,Exp.print_exp_str) => sl &
	 Util.string_delimit_list(sl,", ") => sstr &
	 Util.list_map(t,Exp.print_exp_str) => tl &
	 Util.string_delimit_list(tl,", ") => tstr &
	 print "replace " & print sstr & print " with " & print tstr & print "\n" &*)
	replace_variables(eqns,s,t) => eqns' &
	transform_variables(vars',s,t) => vars'' &
	transform_variables(kv',s,t) => kv''  &
	list_vector(vars'') => varsvec' &
	list_vector(kv'') => kvvec'
	------------------------------------
	translate_dae(DAELOW(VARIABLES(varsvec,bt1),VARIABLES(kvvec,bt2),eqns,seqns)) 
	  => DAELOW(VARIABLES(varsvec',bt1),VARIABLES(kvvec',bt2),eqns',seqns)
end

relation calculate_sizes: DAELow => (int, (* nx *)
				     int, (* ny *)
				     int) (* np *) =
  rule	vector_list(varsvec) => vars &
	vector_list(knvarsvec) => knvars &
	calculate_param_sizes(knvars) => np &
	calculate_var_sizes(vars,0,0) => (nx,ny)
	-----------------------------------
	calculate_sizes(DAELOW(VARIABLES(varsvec,bt1),VARIABLES(knvarsvec,bt2),_,_)) => (nx,ny,np)
end

relation calculate_param_sizes:( Var list) => (int) =

  axiom	calculate_param_sizes([]) => 0

  rule	calculate_param_sizes(vs) => s1 &
	int_add(s1,1) => s2 
	------------------
	calculate_param_sizes(VAR(_,PARAM,_,_,_, _,_,_,_,_,_)::vs) 
	  => (s2)

  rule	calculate_param_sizes(vs) => s1 
	------------------
	calculate_param_sizes(VAR(_,_,_,_,_ ,_,_,_,_,_,_)::vs) 
	  => (s1)
end
	
relation calculate_var_sizes:( Var list, int, int) => (int, int) =

  axiom	calculate_var_sizes([],nx,ny) => (nx,ny)

  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,VARIABLE,_,_,_, _,_,_,_,_,_)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	int_add(nx,1) => nx' &
	calculate_var_sizes(vs,nx',ny) => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,STATE,_,_,_ ,_,_,_,_,_,_)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,DUMMY_STATE,_,_,_ ,_,_,_,_,_,_)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	int_add(ny,1) => ny' &
	calculate_var_sizes(vs,nx,ny') => (nx'',ny'')
	----------------------------
	calculate_var_sizes(VAR(_,DUMMY_DER,_,_,_, _,_,_,_,_,_)::vs,nx,ny) 
	  => (nx'',ny'')

  rule	print "-calculate_var_sizes failed\n" 
	----------------------------
	calculate_var_sizes(_,_,_) 
	  => fail
end


(* Transforms the equations, given two lists with source and target expressions*)
relation replace_variables: (Equation list, Exp.Exp list, Exp.Exp list) => (Equation list) =
	
  axiom	replace_variables ([],_,_) => []
	
  rule	Exp.replace_exp_list(e1,s,t) => (e1',_) &
	Exp.replace_exp_list(e2,s,t) => (e2',_) &
	replace_variables(es,s,t) => es'
	---------------------------------------
	replace_variables(EQUATION(e1,e2)::es,s,t) => EQUATION(e1',e2')::es'

  rule	print "-replace_variables failed\n" 
	------------------
	replace_variables(_,_,_) => fail
end

(**
 ** This relation calculates the values from the parameter binding expressions.
 ** This is performed by building an environment and adding all the parameters and constants
 ** to it and then calling ceval to retreive the constant values of each parameter or constant.
 ** NOTE: This depends on the DAELow having the indexed forms of component references, since the 
 ** environmen requires simple names for each variable.
 **
**)
relation calculate_values: (DAELow) => DAELow =
	
  rule	Builtin.initial_env => env &
	vector_list(knvarsvec) => knvars &
	add_variables_to_env(knvars,env) => env' &
	update_variables(knvars,env') => knvars' &
	list_vector(knvars') => knvarsvec'
	--------------------------------------
	calculate_values(DAELOW(vars,VARIABLES(knvarsvec,bt),eqns,seqns)) 
	  => DAELOW(vars,VARIABLES(knvarsvec',bt),eqns,seqns)
end

relation add_variables_to_env: (Var list, Env.Env) => Env.Env =
	
  axiom	add_variables_to_env([],env) => env
	
  rule	(* Some of the attributes added to env here does not matter, defaults are used *)
	DAE.generate_dae_type(t) => t' &
	Env.extend_frame_v(env,Types.VAR(crn,Types.ATTR(false,SCode.RW,SCode.CONST,Absyn.BIDIR),false,t',Types.EQBOUND(e,true)),
			   NONE,false) 
	  => env' &
	add_variables_to_env(rest,env') => env'' 
	------------------
	add_variables_to_env(VAR(Exp.CREF_IDENT(crn,_),a,b,t,SOME(e),_,d,f,g,h,i)::rest,env) => env''
	
  rule	(* Some of the attributes added to env here does not matter, defaults are used *)
	DAE.generate_dae_type(t) => t' &
	Env.extend_frame_v(env,Types.VAR(crn,Types.ATTR(false,SCode.RW,SCode.CONST,Absyn.BIDIR),false,t',Types.UNBOUND),
			   NONE,false)
	  => env' &
	add_variables_to_env(rest,env') => env'' 
	-------------------------------------------
	add_variables_to_env(VAR(Exp.CREF_IDENT(crn,_),a,b,t,NONE,_,d,f,g,h,i)::rest,env) => env''

  rule	Print.print_buf "Warning, skipping a variable qualified:" &
	Exp.print_component_ref cr &
	add_variables_to_env(rest,env) => env'
	------------------
	add_variables_to_env(VAR(cr as Exp.CREF_QUAL(_,_,_),_,_,_,_,_,_,_,_,_,_)::rest,env) => env'

  rule	Print.print_buf "Warning, skipping a variable :" &
	add_variables_to_env(rest,env) => env'
	------------------
	add_variables_to_env(_::rest,env) => env'

end

relation update_variables:(Var list, Env.Env) => Var list =

  axiom	update_variables([],_) => []

  rule	update_variables(rest,env) => rest' &
	Ceval.ceval(env,e,false,NONE,NONE) => (v,_)
	-----------------------------------
	update_variables(VAR(cr,a,b,c,SOME(e),_,d,f,g,h,i)::rest,env)
	  => (VAR(cr,a,b,c,SOME(e),SOME(v),d,f,g,h,i)::rest')

  rule	update_variables(rest,env) => rest' &
	not Ceval.ceval(env,e,false,NONE,NONE) => (_,_) &
	Print.print_buf "Warning, ceval failed for parameter: " &
	Exp.print_component_ref cr & Print.print_buf "\n" 
	-----------------------------------
	update_variables(VAR(cr,a,b,c,SOME(e),v,d,f,g,h,i)::rest,env)
	  => (VAR(cr,a,b,c,SOME(e),v,d,f,g,h,i)::rest')

  rule	update_variables(rest,env) => rest'
	-----------------------------------
	update_variables(VAR(cr,a,b,c,NONE,v,d,f,g,h,i)::rest,env)
	  => (VAR(cr,a,b,c,NONE,v,d,f,g,h,i)::rest')
end

(* Returns a two list of replacement expressions for variable transformations.
 For instance, replacing state s with x[3] and der(s) with xd[3],
 NOTE: The derivative expressions must be first, so they are replaced first
 i.e der(s) is replaced before s is replaced which gives a wrong 
 variable like der(x[5])
 *)
 relation variable_replacements: (Var list, Equation list) => (Exp.Exp list, Exp.Exp list) =
	 
  rule	states_eqns(eqns,empty_bintree) => bt  &
	 bintree_to_list(bt) => (states,_) &
	 derivative_replacements(states,vars) => (s1,t1) &
	 alg_variable_replacements(vars) => (s2,t2) &
	 list_append(s1,s2) => s &
	 list_append(t1,t2) => t
	 ---------------------
	 variable_replacements(vars,eqns) =>  (s,t)
	 
  rule	print "-variable_replacements failed\n" 
	 ---------------------------------------
	 variable_replacements(vars,eqns) =>  fail
end

(* Build replacement "rules" for the variables, eg. states, algebraic variables, parameters, etc. *)
relation alg_variable_replacements: (Var list) => (Exp.Exp list, Exp.Exp list) =

  axiom	alg_variable_replacements([]) => ([],[])

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["y[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,VARIABLE,_,_,_ ,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["x[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,STATE,_,_,_, _,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["y[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,DUMMY_DER,_,_, _,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["y[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,DUMMY_STATE,_,_, _,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["y[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,DISCRETE,_,_, _,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["p[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,PARAM,_,_, _,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["p[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,STRUCTPARAM,_,_, _,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	alg_variable_replacements(vs) => (s1,t1) &
	int_string(indx) => indxs &
	Util.string_append_list(["p[",indxs,"]"]) => newid
	--------------------
	alg_variable_replacements(VAR(cr,CONST,_,_, _,_,_,_,indx,_,_)::vs)
	  => (Exp.CREF(cr,Exp.REAL)::s1,Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	print "-alg_variable_replacements failed\n" 
	-------------------------------------------
	alg_variable_replacements(_) => fail
end

(** relation: states_eqns
 ** Takes a list of equations and an (empty) BinTree and 
 ** fills the tree with the state variables present in the equations
 **)
relation states_eqns: (Equation list,BinTree) => BinTree =
	
 axiom	states_eqns([],bt) => bt
 
 rule	states_eqns(es,bt) => bt &
	states_exp(e1,bt) => bt &
	states_exp(e2,bt) => bt 
	-----------------------
	states_eqns(EQUATION(e1,e2)::es,bt) => bt
end

relation derivative_replacements: (Exp.ComponentRef list, Var list) 
	  => (Exp.Exp list, Exp.Exp list) =

  axiom	derivative_replacements([],_) => ([],[])
	
  rule	derivative_replacements(ss,vars)  => (s1,t1) &
	get_index(s,vars) => indx &
	int_string(indx) => indxs &
	Util.string_append_list(["xd[",indxs,"]"]) => newid
	------------------------------------------
	derivative_replacements(s::ss,vars) 
	  => (Exp.CALL(Absyn.IDENT("der"),
		       [Exp.CREF(s,Exp.REAL)],
		       false,
		       false
		       )::s1,
	      Exp.CREF(Exp.CREF_IDENT(newid,[]),Exp.REAL)::t1)

  rule	print "-derivative_replacements failed\n" 
	----------------------
	derivative_replacements(_,_) => fail
end

relation get_index: (Exp.ComponentRef, Var list) => int =

  rule	Exp.cref_equal(cr1,cr2) => true
	-------------------------------
	get_index(cr1,VAR(cr2,_,_,_,_, _,_,_,indx,_,_)::_) => indx

  rule	get_index(cr1,vs) => indx
	-------------------------
	get_index(cr1,_::vs) => indx
end

relation calculate_indexes: (Var list) => Var list =
	
  rule	calculate_indexes2(vars,0,0,0,0,0) => vars'
	----------------------------------------
	calculate_indexes(vars) => vars'

  rule	print "-calculate_indexes failed\n" 
	------------------------
	calculate_indexes(_) => fail
end

relation transform_variables: (Var list, Exp.Exp list, Exp.Exp list) => (Var list) =

  axiom transform_variables([],_,_) => []

  rule	transform_variables(vs,s,t) => vs' &
	transform_variable(i,kind) => cr' &
	Exp.print_component_ref_str(cr) => name &
	Exp.replace_exp_list(e,s,t) => (e',_) 
	-------------------
	transform_variables(VAR(cr,kind,a,b,SOME(e), c,d,f,i,_,j)::vs,s,t)
	=> (VAR(cr',kind,a,b,SOME(e'),c,d,f,i,name,j)::vs')

  rule	transform_variables(vs,s,t) => vs' &
	transform_variable(i,kind) => cr' &
	Exp.print_component_ref_str(cr) => name 
	---------------------------------------
	transform_variables(VAR(cr,kind,a,b,NONE, c,d,f,i,_,j)::vs,s,t)
	=> (VAR(cr',kind,a,b,NONE,c,d,f,i,name,j)::vs')

end

relation transform_variable: (int, VarKind) => Exp.ComponentRef =

  rule	int_string(i) => is &
	Util.string_append_list(["y[",is,"]"]) => id
	-------------------
 	transform_variable(i, VARIABLE) => Exp.CREF_IDENT(id,[])

  rule	int_string(i) => is &
	Util.string_append_list(["x[",is,"]"]) => id
	-------------------
 	transform_variable(i, STATE) => Exp.CREF_IDENT(id,[])

  rule	int_string(i) => is &
	Util.string_append_list(["y[",is,"]"]) => id
	-------------------
 	transform_variable(i, DUMMY_DER) => Exp.CREF_IDENT(id,[])

  rule	int_string(i) => is &
	Util.string_append_list(["y[",is,"]"]) => id
	-------------------
 	transform_variable(i, DUMMY_STATE) => Exp.CREF_IDENT(id,[])

  rule	int_string(i) => is &
	Util.string_append_list(["y[",is,"]"]) => id
	-------------------
 	transform_variable(i, DISCRETE) => Exp.CREF_IDENT(id,[])

  rule	int_string(i) => is &
	Util.string_append_list(["p[",is,"]"]) => id
	-------------------
 	transform_variable(i, PARAM) => Exp.CREF_IDENT(id,[])

  rule	int_string(i) => is &
	Util.string_append_list(["p[",is,"]"]) => id
	-------------------
 	transform_variable(i, CONST) => Exp.CREF_IDENT(id,[])
end

relation calculate_indexes2: (Var list,int,int,int,int,int) => Var list =

  axiom	calculate_indexes2([],_,_,_,_,_) => []
	
  rule	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,VARIABLE,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy) 
	  => VAR(cr,VARIABLE,d,tp,b,value,dim,start,y,name,cl)::vars'

  rule	int_add(x,1) => x' &
	calculate_indexes2(vs,x',xd,y,p,dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,STATE,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy) 
	  => VAR(cr,STATE,d,tp,b,value,dim,start,x,name,cl)::vars'

 rule	(* Dummy derivatives become algebraic variables *)
	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,DUMMY_DER,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy)
 	  => VAR(cr,DUMMY_DER,d,tp,b,value,dim,start,y,name,cl)::vars'


  rule	(* Dummy state become algebraic variables *)
	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,DUMMY_STATE,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy) 
	  => VAR(cr,DUMMY_STATE,d,tp,b,value,dim,start,y,name,cl)::vars'

  rule	int_add(y,1) => y' &
	calculate_indexes2(vs,x,xd,y',p,dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,DISCRETE,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy) 
	  => VAR(cr,DISCRETE,d,tp,b,value,dim,start,y,name,cl)::vars'

  rule	int_add(p,1) => p' &
	calculate_indexes2(vs,x,xd,y,p',dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,PARAM,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy) 
	  => VAR(cr,PARAM,d,tp,b,value,dim,start,p,name,cl)::vars'

  rule	int_add(p,1) => p' &
	calculate_indexes2(vs,x,xd,y,p',dummy) => vars' 
	----------------------------------------
	calculate_indexes2(VAR(cr,CONST,d,tp,b,value,dim,start,_,name,cl)::vs,x,xd,y,p,dummy) 
	  => VAR(cr,CONST,d,tp,b,value,dim,start,p,name,cl)::vars'
end

relation print_equations: (int list, DAELow) => () =

  axiom	print_equations ([],_) => ()

  rule	print_equations(rest,dae) => () &
	print_equation_no(n,dae) => ()
	----------------
	print_equations(n::rest,dae) => ()
end

relation print_equation_no: (int, DAELow) => () =

  rule	int_sub(eqno,1) => eqno' &
	list_nth(eqns,eqno') => eq &
	print_equation eq => ()
	----------------
	print_equation_no(eqno,DAELOW(_,_,eqns,_)) => ()
end

relation print_equation: Equation =>  () =

  rule	Exp.print_exp_str e1 => s1 &
	Exp.print_exp_str e2 => s2 &
	Util.string_append_list([s1, " = ", s2, "\n" ]) => res &
	print res
	-----------------
	print_equation(EQUATION(e1,e2))
 end
 
 
(** relation: tree_get
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string can not be uniquely mapped to an int. Therefore we need to compare two strings
 ** to get a unique ordering.
**)
relation tree_get: (BinTree, Key) => Value =
 
 rule	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr &
	System.strcmp(rkeystr,keystr) => 0 
	----------------------------------
	tree_get (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right), key)
	   => rval

  rule	(* Search to the right*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_get(right,key) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right)),key)
	  => res

  rule	(* Search to the left*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => false &
	tree_get(left,key) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left),right),key)
	  => res
	
(*  rule	print "tree_get failed\n" 
	---------------
	tree_get(_,_,_) => fail*)
end

(** relation: tree_add
 ** Copied from generic implementation. Changed that no hashrelation is passed
 ** since a string (ComponentRef) can not be uniquely mapped to an int. Therefore we need to compare two strings
 ** to get a unique ordering.
**)
relation tree_add: (BinTree, Key, Value) => (BinTree) =

  axiom	tree_add (TREENODE(NONE,NONE,NONE),key,value) 
	  => TREENODE(SOME(TREEVALUE(key,value)),NONE,NONE)

  rule	(* Replace this node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0
	----------------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),key,value)
	  => (TREENODE(SOME(TREEVALUE(rkey,value)),left,right))

  rule	(* Insert to right subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_add(t,key,value) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(t')))

  rule	(* Insert to right node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true & 
	tree_add(TREENODE(NONE,NONE,NONE),key,value) => right'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as NONE),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right')))

  rule	(* Insert to left subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add(t,key,value) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(t'),right))

  rule	(* Insert to left node*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_add(TREENODE(NONE,NONE,NONE),key,value) => left'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as NONE,right),key,value) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left'),right))

  rule	print "tree_add failed\n"
	-----------------------
	tree_add(_,_,_) => fail
 end 

(** relation: tree_delete
 ** This relation deletes an entry from the BinTree.
 **)
relation tree_delete: (BinTree, Key) => (BinTree) =

  axiom	tree_delete(bt as TREENODE(NONE,NONE,NONE),key) => bt

  rule	(* delete this node, when existing right node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0 &
	tree_delete_rightmost_value(right) => (rightmost,right') &
	tree_prune_empty_nodes(right') => optright'
	-------------------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),
			      left,
			      SOME(right)),
		     key)
	  => (TREENODE(SOME(rightmost),left,optright'))
	  
  rule	(* delete this node, when no right node, but left node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0 
	-------------------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),
			      SOME(TREENODE(leftval,lleft,lright)),
			      NONE),
		     key)
	  => (TREENODE(leftval,lleft,lright))
	  
  rule	(* delete this node, when no left or right node *)
	Exp.print_component_ref_str(rkey) => rkeystr &
	Exp.print_component_ref_str(key) => keystr & 
	System.strcmp(rkeystr,keystr) => 0 
	-------------------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),
			      NONE,
			      NONE),

		     key)
	  => (TREENODE(NONE,NONE,NONE))
	  
  rule	(* delete in right subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
        int_gt(cmpval,0) => true &
	tree_delete(t,key) => t' &
	tree_prune_empty_nodes(t') => topt'
	------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,topt'))
	  
  rule	(* delete in left subtree*)
	Exp.print_component_ref_str(key) => keystr &
	Exp.print_component_ref_str(rkey) => rkeystr &
	System.strcmp(rkeystr,keystr) => cmpval &
	int_gt(cmpval,0) => false &
	tree_delete(t,key) => t' &
	tree_prune_empty_nodes(t') => topt'
	------------------------
	tree_delete (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),topt',right))

  rule	print "tree_delete failed\n" 
	----------------------------
	tree_delete(_,_) => fail
end

(** relation: tree_delete_rightmost_value
 ** This relation takes a BinTree and deletes the rightmost value of the tree.
 ** Tt returns this value and the updated BinTree. This relation is used in 
 ** the binary tree deletion relation 'tree_delete'.
 **)
 relation tree_delete_rightmost_value: (BinTree) 
		     => (TreeValue,	(* deleted value*)  
			 BinTree) =	(* updated bintree*) 

  axiom	tree_delete_rightmost_value(TREENODE(SOME(treevalue),NONE,NONE)) 
	  => (treevalue,TREENODE(NONE,NONE,NONE))

  axiom	tree_delete_rightmost_value(TREENODE(SOME(treevalue),SOME(left),NONE))
	 => (treevalue,left)

  rule tree_delete_rightmost_value(right) => (value, right') &
	tree_prune_empty_nodes(right') => rightopt'
	--------------------------------------------
	tree_delete_rightmost_value(TREENODE(treeval,left,SOME(right)))
	  => (value,TREENODE(treeval,left,rightopt'))

  rule	not tree_delete_rightmost_value(right) => (_,_) &
	 print "right value was empty , left NONE\n" 
	--------------------------------------------
	tree_delete_rightmost_value(TREENODE(SOME(treeval),NONE,SOME(right))) 
	  => (treeval,TREENODE(NONE,NONE,NONE))


  rule	print "-tree_delete_rightmost_value failed\n" 
	 --------------------------------------------
	 tree_delete_rightmost_value(bt) => fail
end

(** relation: tree_prune_emtpy_nodes
 ** This relation is a helper relation to tree_delete
 ** It is used to delete empty nodes of the BinTree representation, that might be introduced
 ** when deleting nodes.
 **)
relation tree_prune_empty_nodes: (BinTree) => BinTree option =
  axiom	tree_prune_empty_nodes TREENODE(NONE,NONE,NONE) => NONE
  axiom	tree_prune_empty_nodes bt => SOME(bt)
end

(** relation: bintree_to_list
 ** This relation takes a BinTree and transform it into a list
 ** representation, i.e. two lists of keys and values
 **)
 relation bintree_to_list: (BinTree) => (Key list, Value list) =

  rule	bintree_to_list2(bt,[],[]) => (klst,vlst) 
	------------------------------------------
	bintree_to_list(bt) => (klst,vlst)
end

(** relation: bintree_to_list2
 ** helper relation to bintree_to_list
 **)
relation bintree_to_list2: (BinTree,Key list,Value list ) 
	  => (Key list, Value list) =

 axiom	bintree_to_list2( TREENODE(NONE,NONE,NONE),klst,vlst) => (klst,vlst)
 
  rule	bintree_to_list_opt(left,klst,vlst) => (klst,vlst) &
	bintree_to_list_opt(right,klst,vlst) => (klst,vlst) 
	------------------
	bintree_to_list2(TREENODE(SOME(TREEVALUE(key,value)),left,right),klst,vlst)
	  => (key::klst,value::vlst) 
	  
  rule	bintree_to_list_opt(left,klst,vlst) => (klst,vlst) &
	bintree_to_list_opt(left,klst,vlst) => (klst,vlst) 
	--------------------------------------------------
	bintree_to_list2(TREENODE(NONE,left,right),klst,vlst) => (klst,vlst)
end

(** relation: bintree_to_list_opt
 ** helper relation to bintree_to_list
 **)
relation bintree_to_list_opt: (BinTree option, Key list, Value list) 
	  => (Key list, Value list) =

  axiom	bintree_to_list_opt(NONE,klst,vlst) => (klst,vlst)

  rule	bintree_to_list2(bt,klst,vlst) => (klst,vlst) 
	---------------------------------------------
	bintree_to_list_opt(SOME(bt),klst,vlst) => (klst,vlst)
end
	