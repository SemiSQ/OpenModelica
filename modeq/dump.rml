(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 dump.rml
 ** module:      Dump
 ** description: debug printing
 **
 ** RCS: $Id$
 **
 ** Printing routines for debugging of the AST.  These relations do
 ** nothing but print the data structures to the standard output.
 **
 ** The implementation of the relations are excluded from the report,
 ** as they occupy a lot of space and do not convey any useful
 ** semantic information.
 **)


module Dump:

  with "absyn.rml"
  with "interactive.rml"							  
  with "debug.rml"

  type Ident = string

  (* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation unparse_str: Absyn.Program => string
  relation dump_istmt: Interactive.InteractiveStmts => ()
  relation print_exp: Absyn.Exp => ()
  relation print_exp_str: Absyn.Exp => string
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_component_ref_str : Absyn.ComponentRef => string
  relation print_path : Absyn.Path => ()
  relation print_subscripts : Absyn.Subscript list => ()
  relation print_arraydim: Absyn.ArrayDim => ()
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list_debug : (string, 'a list, 'a => (), string) => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation print_elementspec: Absyn.ElementSpec => ()
  relation print_named_arg: Absyn.NamedArg => () 
  relation op_symbol : Absyn.Operator => string
  relation print_bool : bool => ()
  relation print_select: (bool,string,string) => ()
  relation select_string: (bool,string,string) => string
  relation get_string_list : ('a list, 'a => string, string) => string
  relation get_option_str: ('a option, 'a => string) => string 
end




(*!ignorecode*)

with "classinf.rml"
with "rtopts.rml"

(* Relations *)

relation dump : Absyn.Program => () =
	
  axiom	dump Absyn.PROGRAM([],_) => ()
	
  rule	print_class c & print "\n" &
	dump Absyn.PROGRAM(cs,w)
	------------------------
	dump Absyn.PROGRAM(c::cs,w) => ()

end

relation unparse_str : Absyn.Program => string =
	
  axiom	unparse_str Absyn.PROGRAM([],_) => ""
	
  rule	unparse_within(w) => s1 &
	get_string_list(c,unparse_class_str,"\n") => s2 &
	string_append(s1,s2) => str
	------------------------
	unparse_str Absyn.PROGRAM(c,w) => str
end

relation unparse_within: Absyn.Within => string =
  axiom unparse_within Absyn.TOP => ""
	
  rule	Absyn.path_string p => s1 &
	string_append("within ",s1) => s2 &
	string_append(s2,";\n") => str
	------------------------------
	unparse_within Absyn.WITHIN(p) => str
end

relation unparse_class_str: Absyn.Class => string =
  rule	select_string(p, "partial ","") => s1 &
	unparse_restriction_str (r) => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," ") => s4 &
	string_append(s4,n) => s5 &
	string_append(s5,"\n") => s6 &
	get_string_list (parts,unparse_class_part_str,"") => s7 &
	string_append(s6,s7) => s8 &
	string_append(s8, "\n end ") => s9 &
        string_append(s9,n) => s10 &
	string_append(s10,";\n") => str			     
	-----------------------------
	unparse_class_str(Absyn.CLASS(n,p,e,r,Absyn.PARTS(parts))) => str

  rule	select_string(p, "partial ", "") => s1 &
	unparse_restriction_str (r)  => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," ") => s4 &
	string_append(s4,n) => s5 &
	string_append(s5,"= ") => s6 &
	Absyn.path_string i => s7 &
	get_option_str(dim,print_arraydim_str) => s8 &
	unparse_mod1_str m => s9 &
	string_append(s7,s8) => s10 &
	string_append(s10,s9) => s11 &
	string_append(s11,";\n") => str
	------------------------------
	unparse_class_str(Absyn.CLASS(n,p,e,r,Absyn.DERIVED(i,dim,m))) => str

  rule	select_string(p, "partial ", "") => s1 &
	unparse_restriction_str (r)  => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," ") => s4 &
	string_append(s4,n) => s5 &
	string_append(s5,"= enumeration(") => s6 &
	stringlist_append (l) => s7 &
	string_append(s6,s7) => s8 &
	string_append(s8,");\n") => str				      
	-------------------------------
	unparse_class_str(Absyn.CLASS(n,p,e,r,Absyn.ENUMERATION(l))) => str    
end 

relation unparse_restriction_str : Absyn.Restriction => string =

  axiom unparse_restriction_str Absyn.R_CLASS			=> "class"
  axiom	unparse_restriction_str Absyn.R_MODEL			=> "model"
  axiom	unparse_restriction_str Absyn.R_RECORD			=> "record"
  axiom unparse_restriction_str Absyn.R_BLOCK			=> "block"
  axiom unparse_restriction_str Absyn.R_CONNECTOR		=> "connector"
  axiom unparse_restriction_str Absyn.R_TYPE			=> "type"
  axiom unparse_restriction_str Absyn.R_PACKAGE			=> "package"
  axiom unparse_restriction_str Absyn.R_FUNCTION			=> "function"
  axiom unparse_restriction_str  Absyn.R_PREDEFINED_INT		=> "Integer"
  axiom unparse_restriction_str Absyn.R_PREDEFINED_REAL		=> "Real"
  axiom unparse_restriction_str Absyn.R_PREDEFINED_STRING	=> "String"
  axiom unparse_restriction_str Absyn.R_PREDEFINED_BOOL		=> "Boolean"

end

relation dump_istmt : Interactive.InteractiveStmts => () =
  rule	print ("IALG(") &
	print_algorithm(alg) => () &
	print ")\n" 
	--------------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IALG(alg)])) => ()
	    
  rule  print ("IEXP(") &
	print_exp(expr) &
	print ")\n" 
	----------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IEXP(expr)])) => ()
	
  rule print "IALG(" &
	print_algorithm(alg) => () &
	print "," &
	dump_istmt(Interactive.ISTMTS(l)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IALG(alg)::l)) => ()

  rule print "IEXP(" &
	print_exp(expr) => () &
	print "," &
	dump_istmt(Interactive.ISTMTS(l)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IEXP(expr)::l)) => ()

  axiom	dump_istmt(_) => ()
end
	(**)

relation print_class: Absyn.Class => () =

  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print_list_debug("print_class1",parts,print_class_part,",") & print ")"
	----------------------------------------
	print_class(Absyn.CLASS(n,p,e,r,Absyn.PARTS(parts))) => ()

  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print ") = " & print_path(i) &
	print_class_modification(m)
	----------------------------------------
	print_class(Absyn.CLASS(n,p,e,r,Absyn.DERIVED(i,_,m))) => ()

  rule	print_class_restriction(r) & print "(" &
	print n & print "," &
	print_select(p,"PARTIAL,","") &
	print "ENUMERATION(" &
	print_list_debug("print_class",l,print, ",") &
	print ")\n"
	----------
	print_class(Absyn.CLASS(n,p,e,r,Absyn.ENUMERATION(l))) => ()
end

(**)

relation print_class_restriction: Absyn.Restriction => () =

  rule	Absyn.print_restr re
	-----------------------
	print_class_restriction re

end


(**)

relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	print "(" & print_list_debug("print_class_modification",l,print_element_arg,",") & print ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

relation unparse_class_modification_str: Absyn.Modification => string =

  axiom	unparse_class_modification_str(Absyn.CLASSMOD([],_)) => ""
	
  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str 
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(l,_)) => str
	
end
(**)

relation print_element_arg =
	
  rule	print "ARG(" &
	print_select(f,"FINAL,",",") &
	print_component_ref(r) &
	print_modification(m) &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,r,m))
	
  rule	print "REDECLARATION(" &
	print_select(f,"FINAL,",",") &
	print_elementspec spec &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,spec))

end

relation unparse_element_arg_str: (Absyn.ElementArg) => string =
	
  rule	select_string(f,"final ","") => s1 &
	print_component_ref_str(r) => s2 &
	string_append(s1,s2) => s3 &
	unparse_modification_str(m) => s4 &
	string_append(s3,s4) => str
	-------------------------------------------
	unparse_element_arg_str(Absyn.MODIFICATION(f,r,m)) => str
	
  rule	print "REDECLARATION(" &
	select_string(f,"final ","")  => s1 &
	string_append("redeclare ",s1) => s2 &
	unparse_elementspec_str spec => s3 &
	string_append(s2,s3) => str
	-------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,spec)) => str
end

(**)



relation print_class_part: Absyn.ClassPart => () =

  rule	print "PUBLIC(" & print_elementitems(el) & print ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule	print "PROTECTED(" & print_elementitems(el) & print ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule	print "EQUATIONS(" &
	print_list_debug("print_class_part",eqs,print_equationitem,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))
	
  rule	print "ALGORITHM(" &
	print_list_debug("print_class_part",eqs,print_algorithm,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(eqs))

end

relation unparse_class_part_str: Absyn.ClassPart => string =

  rule	get_string_list(el,unparse_elementitem_str,"\n") => s1 & 
	string_append("public \n",s1) => str 
	-----------------------------------------------
	unparse_class_part_str(Absyn.PUBLIC(el)) => str
	
  rule	get_string_list(el,unparse_elementitem_str,"\n") => s1 & 
	string_append("protected \n",s1) => str 
	---------------------------------------
	unparse_class_part_str(Absyn.PROTECTED(el)) => str
	
  rule	get_string_list(eqs,unparse_equationitem_str,"\n") => s1 & 
	string_append("equation \n",s1) => str 
	--------------------------------------
	unparse_class_part_str(Absyn.EQUATIONS(eqs)) => str
	
  rule	get_string_list(eqs,unparse_algorithm_str,"\n") => s1 & 
	string_append("public \n",s1) => str 
	--------------------------------------
	unparse_class_part_str(Absyn.ALGORITHMS(eqs)) => str
end

(**)

relation print_elementitems: Absyn.ElementItem list => () =
  axiom print_elementitems [] => ()

  rule  print_element e
	---------------
	print_elementitems[ Absyn.ELEMENTITEM(e)]

  rule	print_annotation a
	------------------
	print_elementitems([Absyn.ANNOTATIONITEM(a)])
	
  rule	print_element e &
	print_elementitems els
	---------------
	print_elementitems Absyn.ELEMENTITEM(e)::els 

  rule	print_annotation a &
	print_elementitems els
	------------------
	print_elementitems Absyn.ANNOTATIONITEM(a)::els

  rule	print "Error print_elementitems\n"
	--------------
	print_elementitems _ 
end

relation print_annotation: Absyn.Annotation => () =	
  rule	print "ANNOTATION(" &
	print_modification Absyn.CLASSMOD(mod,NONE) &
	print ")"
	---------
	print_annotation(Absyn.ANNOTATION(mod))
end
	
relation unparse_elementitem_str: Absyn.ElementItem => string =

  rule  unparse_element_str e => str
	----------------------------
	unparse_elementitem_str Absyn.ELEMENTITEM(e) => str

  rule	unparse_annotation_str a => str
	-------------------------------
	unparse_elementitem_str Absyn.ANNOTATIONITEM(a) => str
	
end

relation unparse_annotation_str: Absyn.Annotation => string =	

  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	string_append("annotation(",s1) => s2 &
	string_append(s2,")") => str
	----------------------------
	unparse_annotation_str(Absyn.ANNOTATION(mod)) => str
end

(**)

relation print_element: Absyn.Element => () =
	
  rule	print "ELEMENT(" & print_select(final,"FINAL,","") &
	print_innerouter inout &
	print ", " &
	print_elementspec spec & print ")"
	----------------
	print_element (Absyn.ELEMENT(final,inout,_,spec))

end

relation unparse_element_str: Absyn.Element => string = 

  rule	select_string(final, "final ", "") => s1 &
	unparse_innerouter_str inout => s2 &
	unparse_elementspec_str spec => s3 &
	string_append(s1,s2) => s4 &
	string_append(s4,s3) => s5 &
	string_append(s5,";") => str
	----------------------------
	unparse_element_str Absyn.ELEMENT(final,inout,_,spec) => str
end


relation print_innerouter: Absyn.InnerOuter => () =
   rule print "INNER"
	----------------------------
	print_innerouter(Absyn.INNER)

   rule print "OUTER"
        ----------------------------
        print_innerouter(Absyn.OUTER)

   rule print " "
        ----------------------------------
        print_innerouter(Absyn.UNSPECIFIED)
end

relation unparse_innerouter_str: Absyn.InnerOuter => string =
	
  axiom	unparse_innerouter_str(Absyn.INNER) => "innner"

  axiom	unparse_innerouter_str(Absyn.OUTER) => "outer"

  axiom	unparse_innerouter_str(Absyn.UNSPECIFIED) => ""
end
(**)

relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	print "CLASSDEF(" & print_select(repl,"REPLACEABLE,","") &
	print_class cl & print ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
	
  rule	print "EXTENDS(" & print_path p & print "," &
	print_list_debug("print_elementspec",l,print_element_arg,",") & print ")"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	print "COMPONENTS(" &
	print_elementattr(attr) & print "," &
	print_path(t) & print "," &
	print_list_debug("print_elementspec",cs, print_componentitem, ",") &
	print ")"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	print "IMPORT(" &
	print_import i &
	print ")"
	--------
	print_elementspec(Absyn.IMPORT(i))

  rule	print " ##ERROR## "
	-------------------
	print_elementspec(_)

end

relation unparse_elementspec_str: Absyn.ElementSpec => string =
	
  rule	select_string(repl,"replaceable,","") => s1 &
	unparse_class_str cl => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_elementspec_str(Absyn.CLASSDEF(repl,cl)) => str
	
  rule	print "EXTENDS(" & Absyn.path_string p => s1 &
	string_append("extends ",s1) => s2 &
	get_string_list(l,unparse_element_arg_str,",") => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_elementspec_str(Absyn.EXTENDS(p,l)) => str

  rule	Absyn.path_string(t) => s1 &
	unparse_elementattr_str(attr) => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," ") => s4 &
	get_string_list(cs, unparse_componentitem_str, ",") => s5 &
	string_append(s4,s5) => s6 &
	string_append(s6,";") => str
	------------------------------------------
	unparse_elementspec_str(Absyn.COMPONENTS(attr,t,cs)) => str
	
  rule	unparse_import_str i => s1 &
	string_append("import ",s1) => s2 &
	string_append(s2,";") => str
	----------------------------
	unparse_elementspec_str(Absyn.IMPORT(i)) => str

  rule	print " ##ERROR## "
	-------------------
	unparse_elementspec_str(_) => ""

end

relation print_import : Absyn.Import => () =

  rule	print i & print " = " &
	print_path p
	-----------------------
	print_import(Absyn.NAMED_IMPORT(i,p))

  rule	print_path p
	-------------
	print_import(Absyn.QUAL_IMPORT(p))

  rule	print_path p & print ".*"
	--------------------------
	print_import(Absyn.UNQUAL_IMPORT(p))
		     
end
relation unparse_import_str : Absyn.Import => string =

  rule	string_append(i," = ") => s1 &
	Absyn.path_string p => s2 &
	string_append(s1,s2) => str
	-----------------------
	unparse_import_str(Absyn.NAMED_IMPORT(i,p)) => str

  rule	Absyn.path_string p => str
	-------------
	unparse_import_str(Absyn.QUAL_IMPORT(p)) => str

  rule	Absyn.path_string p => s1 &
	string_append(s1, ".*") => str
	--------------------------
	unparse_import_str(Absyn.UNQUAL_IMPORT(p)) => str
end

relation print_elementattr: Absyn.ElementAttributes => () =

  rule	print "ATTR(" &
	select_string(fl,"FLOW,","") => fs &
	variability_symbol(var) => vs &
	direction_symbol(dir) => ds &
	let sl = [fs,vs,ds] &
	print_list_debug("print_elementattr",sl, print, ",") &
	print ")"
	-----------------------------------
	print_elementattr(Absyn.ATTR(fl,var,dir,adim))

  rule	print " ##ERROR## print_elementattr"
	-------------------
	print_elementattr(_)

end

relation unparse_elementattr_str: Absyn.ElementAttributes => string =

  rule	
	select_string(fl,"flow ","") => fs &
	unparse_variability_symbol_str(var) => vs &
	unparse_direction_symbol_str(dir) => ds &
	string_append(fs,vs) => s1 &
	string_append(s1," ") => s2 &
	string_append(s2,ds) => s3 &
	string_append(s3," ") => str
	-----------------------------------
	unparse_elementattr_str(Absyn.ATTR(fl,var,dir,adim)) => str

  rule	print " ##ERROR## print_elementattr"
	-------------------
	unparse_elementattr_str(_) => ""

end

relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => ""
  axiom	variability_symbol(Absyn.DISCRETE) => "DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "PARAM"
  axiom	variability_symbol(Absyn.CONST) => "CONST"

end

relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => ""
  axiom	direction_symbol(Absyn.INPUT) => "INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "OUTPUT"

end

relation unparse_variability_symbol_str: Absyn.Variability => string =

  axiom unparse_variability_symbol_str(Absyn.VAR) => ""
  axiom	unparse_variability_symbol_str(Absyn.DISCRETE) => "discrete"
  axiom	unparse_variability_symbol_str(Absyn.PARAM) => "parameter"
  axiom	unparse_variability_symbol_str(Absyn.CONST) => "const"

end

relation unparse_direction_symbol_str: Absyn.Direction => string =

  axiom unparse_direction_symbol_str(Absyn.BIDIR) => ""
  axiom	unparse_direction_symbol_str(Absyn.INPUT) => "input"
  axiom	unparse_direction_symbol_str(Absyn.OUTPUT) => "output"

end

(**)

relation print_component: Absyn.Component => () =

  rule	print n &
	print_arraydim a &
	print_option(m,print_modification) 
	------------------------------------------
	print_component(Absyn.COMPONENT(n,a,m))

end

relation print_componentitem: Absyn.ComponentItem => () =

  rule	print "COMPONENTITEM(" &
	print_component c &
	print ", " &
	print_option(a, print_annotation) &
	print ")"
	------------------------------------------
	print_componentitem(Absyn.COMPONENTITEM(c,a))
end

relation unparse_component_str: Absyn.Component => string =

  rule	print_arraydim_str a => s1 &
	string_append(n,s1) => s2 &
	get_option_str(m,unparse_modification_str) => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_component_str(Absyn.COMPONENT(n,a,m)) => str
end

relation unparse_componentitem_str: Absyn.ComponentItem => string =

  rule	
	unparse_component_str c => s1 &
	get_option_str(a, unparse_annotation_str) => s2 &
	string_append(s1,s2) => str
	------------------------------------------
	unparse_componentitem_str(Absyn.COMPONENTITEM(c,a)) => str
end

(**)

relation print_arraydim: Absyn.ArrayDim => () =

  rule	print_subscripts(s)
	-------------------
	print_arraydim(s)
	
end

relation print_arraydim_str: Absyn.ArrayDim => string =

  rule	print_subscripts_str (s) => str
	-------------------------------
	print_arraydim_str(s) => str
	
end

relation print_subscript: Absyn.Subscript => () =

  rule	print ":"
	---------
	print_subscript(Absyn.NOSUB)

  rule	print_exp(e1)
	----------
	print_subscript(Absyn.SUBSCRIPT(e1))

end

relation print_subscript_str: Absyn.Subscript => string =

  axiom	print_subscript_str (Absyn.NOSUB) => ":"

  rule	print_exp_str (e1) => s
	-----------------------
	print_subscript_str (Absyn.SUBSCRIPT(e1)) => s

end

(* Modifications *)

relation print_modification: Absyn.Modification => () =
	
  rule	print_mod1 l & print_mod2 e
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	print "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	print "(" &
	print_list_debug("print_mod1",l,print_element_arg,",") &
	print ")"
	------------------------------------
	print_mod1 l

end

relation print_mod2 : Absyn.Exp option => () =

  axiom	print_mod2 NONE

  rule	print " = " & print_exp(e)
	-------------------------
	print_mod2 SOME(e)

end


relation unparse_modification_str: Absyn.Modification => string =
	
  rule	unparse_mod1_str l => s1 & 
	unparse_mod2_str e => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_modification_str(Absyn.CLASSMOD(l, e)) => str
	
  rule	print " Failure MODIFICATION \n"
	-------------
	unparse_modification_str(_) => ""
	
end

relation unparse_mod1_str: Absyn.ElementArg list => string =

  axiom	unparse_mod1_str [] => ""

  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str
	------------------------------------
	unparse_mod1_str l => str
end

relation unparse_mod2_str : Absyn.Exp option => string =

  axiom	unparse_mod2_str NONE => ""

  rule	print_exp_str(e) => s1 &
	string_append("=",s1) => str
	-------------------------
	unparse_mod2_str SOME(e) => str
end

(* Equations *)

relation print_equation: Absyn.Equation => () =
	
  rule	print "EQ_EXPR(" & print_exp(e) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EXPR(e))
	
  rule	print "IF (" & print_exp(e) & print ") THEN " &
	print_list_debug("print_equation",tb, print_equationitem, ";") &
	print_list_debug("print_equation",eb, print_eq_elseif, " ") &
	print " ELSE " & print_list_debug("print_equation",fb, print_equationitem, ";")
	----------------------------------------------------
	print_equation(Absyn.EQ_IF(e,tb,eb,fb))
	
  rule	print "EQ_EQUALS(" & print_exp(e1) & print "," &
	print_exp(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	print "EQ_CONNECT(" & print_component_ref(e1) & print "," &
	print_component_ref(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list_debug("print_equation",el, print_equationitem, ";") & print "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	print " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

relation print_equationitem: Absyn.EquationItem => () =
  rule	print "EQUATIONITEM(" &
	print_equation eq &
	print ", " &
	print_annotation ann &
	print ")\n"
	--------------
	print_equationitem Absyn.EQUATIONITEM(eq,SOME(ann))
	
  rule	print "EQUATIONITEM(" &
	print_equation eq &
	print ",NONE)\n"
	--------------
	print_equationitem Absyn.EQUATIONITEM(eq,NONE)
end

relation unparse_equation_str: Absyn.Equation => string =
	
  rule	print_exp_str(e) => str 
	-------------------------------------------
	unparse_equation_str(Absyn.EQ_EXPR(e)) => str
	
  rule	print "IF (" & print_exp_str(e) => s1 &
	string_append("if ",s1) => s2 &
	string_append(s2," then \n") => s3 &
	get_string_list(tb,unparse_equationitem_str, ";") => s4 &
	string_append(s3,s4) => s5 &
	get_string_list(eb,unparse_eq_elseif_str, " ") => s6 &
	string_append(s5,s6) => s7 &
	string_append(s7, "\n else") => s8 &
	get_string_list(fb,unparse_equationitem_str,";") => s9 &
	string_append(s8,s9) => str
	----------------------------------------------------
	unparse_equation_str(Absyn.EQ_IF(e,tb,eb,fb)) => str
	
  rule	print_exp_str(e1) => s1 &
	string_append(s1,"=") => s2 &
	print_exp_str(e2) => s3 &
	string_append(s2,s3) => str
	-------------------------------------------
	unparse_equation_str(Absyn.EQ_EQUALS(e1,e2)) => str
	
  rule	print_component_ref_str(e1) => s1  &
	string_append("connect(",s1) => s2 &
	string_append(s2,",") => s3 &
	print_component_ref_str(e2) => s4 &
	string_append(s3,s4) => s5 &
	string_append(s5,")") => str 
	-------------------------------------------
	unparse_equation_str(Absyn.EQ_CONNECT(e1,e2)) => str
	
  rule	string_append("for ",i) => s1 &
	string_append(s1, " in " ) => s2 &
	print_exp_str(e) => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4, "loop \n") => s5 &
	get_string_list(el,unparse_equationitem_str,";\n") => s6 &
	string_append(s5,s6) => s7 &
	string_append(s7,"\nend loop;\n") => str
	----------------------------------------------------------
	unparse_equation_str Absyn.EQ_FOR(i,e,el) => str
	
  rule	print " ** Failure! UNKNOWN EQUATION ** "
	--------------------------------
	unparse_equation_str(_) => ""
	
end
	
relation unparse_equationitem_str: Absyn.EquationItem => string =
  rule	
	unparse_equation_str eq => s1 &
	unparse_annotation_str ann => s2 &
	string_append(s1, " ") => s3 &
	string_append(s3,s2) => str
	---------------------------
	unparse_equationitem_str Absyn.EQUATIONITEM(eq,SOME(ann)) =>str 
	
  rule	unparse_equation_str eq => str 
	--------------
	unparse_equationitem_str Absyn.EQUATIONITEM(eq,NONE) => str
end
	
(**)
	
relation print_eq_elseif : (Absyn.Exp * Absyn.EquationItem list) => () =
	
  rule	print " ELSEIF " & print_exp e & print " THEN " &
	print_list_debug("print_eq_elseif",el, print_equationitem, ";")
	-----------------------------------
	print_eq_elseif((e,el))
end
	
relation unparse_eq_elseif_str : (Absyn.Exp * Absyn.EquationItem list) => string =
	    
  rule	print_exp_str e => s1 &
	string_append ("\n elseif ",s1) => s2 &
	string_append(s2," then \n") => s3 &
	get_string_list(el,unparse_equationitem_str, ";") => s4 &
 	string_append(s3,s4) => str 
	-----------------------------------
	unparse_eq_elseif_str((e,el)) => str
end

(* Algorithm clauses *)

relation print_algorithm: Absyn.Algorithm => () =
	
  rule	print "ALG_ASSIGN(" & print_component_ref cr &
	print " := " & print_exp(exp) & print ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	print "IF (" & print_exp(e) & print ") THEN " &
	print_list_debug("print_algorithm",tb, print_algorithm, ";") &
	print_list_debug("print_algorithm",eb, print_alg_elseif, " ") &
	print " ELSE " & print_list_debug("print_algorithm",fb, print_algorithm, ";")
	----------------------------------------------------
	print_algorithm(Absyn.ALG_IF(e,tb,eb,fb))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",el, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	print "WHILE " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
	(*  rule	print "WHEN_E " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithm, ";") & print "}"
	 ----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_E(e,al)
*)
  rule	print "WHEN_A " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_A(e,al)
	
  rule	print " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

relation unparse_algorithm_str: Absyn.Algorithm => string =
	
  rule	print_component_ref_str cr => s1 &
	string_append(s1,":=") => s2 &
	print_exp_str(exp) => s3 & 
	string_append(s2,s3) => str
	-------------------------------------------
	unparse_algorithm_str(Absyn.ALG_ASSIGN(cr,exp)) => str
	
  rule	
	print "IF (" & print_exp_str(e) => s1 &
	string_append("if ",s1) => s2 &
	string_append (s2," then \n") => s3 &
	get_string_list(tb,unparse_algorithm_str,";\n") => s4 &
	string_append(s3,s4) => s5 &
	get_string_list(eb,unparse_alg_elseif_str, " ") => s6 &
	string_append(s5,s6) => s7 &
	string_append(s7, "\n else") => s8 &
	get_string_list(fb,unparse_algorithm_str,";\n") => s9 &
	string_append(s8,s9) => s10 &
	string_append(s10,"\n") => str
	----------------------------------------------------
	unparse_algorithm_str(Absyn.ALG_IF(e,tb,eb,fb)) => str
	
  rule	print "FOR " &
	string_append("for ",i)=> s1 &
	string_append(s1, " in ") => s2 & 
	print_exp_str(e)=> s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," loop \n") => s5 &
	get_string_list(el,unparse_algorithm_str," ;\n") => s6 &
	string_append(s5,s6) => s7 &
	string_append(s7,"\n end for;\n") => str
	----------------------------------------------------------
        unparse_algorithm_str Absyn.ALG_FOR(i,e,el) => str
				     
  rule	print "WHILE " & print_exp_str(e) => s1 &
	string_append("while (",s1) => s2 &
	string_append(s2,") loop \n") => s3 &
	get_string_list(al,unparse_algorithm_str,";\n") => s4 &
	string_append(s3,s4) => s5 &
	string_append(s5,"\n end while;\n")=> str				     	----------------------------------------------------------
	unparse_algorithm_str Absyn.ALG_WHILE(e,al) => str
	
  rule	print "WHEN_A " & print_exp_str(e)=>s1 &
	string_append("when ",s1) => s2 &
	string_append(s2," then \n") => s3 &
	get_string_list(al,unparse_algorithm_str,";\n") => s4 &
	string_append(s3,s4) => s5 &
	string_append(s5,"\nend when;\n") => str
	----------------------------------------------------------
	unparse_algorithm_str Absyn.ALG_WHEN_A(e,al) => str
	
  rule	print " *Failure! UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	unparse_algorithm_str(_) => ""
	
end
(**)

relation print_alg_elseif : (Absyn.Exp * Absyn.Algorithm list) => () =

  rule	print " ELSEIF " & print_exp e & print " THEN " &
	print_list_debug("print_alg_elseif",el, print_algorithm, ";")
	-----------------------------------
	print_alg_elseif((e,el))

end


relation unparse_alg_elseif_str : (Absyn.Exp * Absyn.Algorithm list) => string =

  rule  print_exp_str e => s1 &
	string_append(" elseif ",s1) => s2 &
	string_append(s2, " then \n") => s3 &
	get_string_list(el,unparse_algorithm_str,";\n")=> s4 &
	string_append(s3,s4) => str
	-----------------------------------
	unparse_alg_elseif_str((e,el)) => str
end


(* Component references and paths *)

(* relation: print_component_ref
 *
 * Print a `ComponentRef'.
 *)

relation print_component_ref : Absyn.ComponentRef => () =

  rule	print s &
	print_subscripts subs
	---------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	print s &
	print_subscripts subs &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

relation print_subscripts : Absyn.Subscript list => () =

  axiom	print_subscripts []

  rule	print "[" & print_list_debug("print_subscripts",l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_subscripts l

end

(* relation: print_component_ref_str
 *
 * Print a `ComponentRef' and return as a string.
 *)

relation print_component_ref_str : Absyn.ComponentRef => string =

  rule	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s'
	--------------------------------
	print_component_ref_str Absyn.CREF_IDENT(s,subs) => s'

  rule	print_component_ref_str cr => crs &
	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s' &
	string_append (s', ".") => s'' &
	string_append (s'', crs) => s'''
	--------------------------------
	print_component_ref_str Absyn.CREF_QUAL(s,subs,cr) => s'''

end


relation print_subscripts_str : Absyn.Subscript list => string =

  axiom	print_subscripts_str [] => ""

  rule	print_list_str(l,print_subscript_str,",") => s &
	string_append ("[", s) => s' & 
	string_append (s', "]") => s''
	-------------------------------------------------------
	print_subscripts_str l => s''

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path : Absyn.Path => () =

  rule	Absyn.path_string p => s & print s
	----------------------------------
	print_path p

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path_str : Absyn.Path => string =

  rule	Absyn.path_string p => s
	----------------------------------
	print_path_str p => s

end

(* - Expressions *)

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp : Absyn.Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	print_component_ref(c)
	---------------------
	print_exp(Absyn.CREF(c))

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	print "FALSE"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	print "TRUE"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	op_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	---------------------------------------------------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	op_symbol(op) => sym &
	print sym & print_exp e
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	op_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	op_symbol(op) => sym & print sym & print_exp e
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	op_symbol(op) => sym & print_exp(e1) & print sym & print_exp(e2)
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	print "if " & print_exp(c) &
	print " then " & print_exp(t) &
	print " else " & print_exp(f)
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f))

  rule	print_component_ref(fcn) &
 	print "(" & 
	print_function_args(args) & print ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	print "[" &
	print_list_debug("print_exp",es, print_exp, ",") &
	print "]"
	---------
	print_exp Absyn.ARRAY(es)

	(* PR. *)
  rule	print "TUPLE" &
	print "(" &
	print_list_debug("print_exp",es, print_exp, ",") &
	print ")"
	---------
	print_exp Absyn.TUPLE(es)
	
  rule	print "[" &
	print_list_debug("print_exp",es, print_row, ";") &
	print "]"
	---------
	print_exp Absyn.MATRIX(es)

  rule	print "(" & print_exp start & print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	print "(" & print_exp start & print ":" & print_exp step &
 	print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule	print "#UNKNOWN EXPRESSION#"
	----------------------------------
	print_exp (_)
end

relation print_function_args: Absyn.FunctionArgs => () =
	
  rule  print "FUNCTIONARGS(" &
	print_list_debug("print_exp",expargs,print_exp,", ") &
	print ", " &
	print_list_debug("print_namedarg",nargs,print_named_arg,", ") &
	print ")"
	-------------------
	print_function_args Absyn.FUNCTIONARGS(expargs,nargs)
end

relation print_named_arg: Absyn.NamedArg => () =
  rule	print ident &
	print "=" &
	print_exp(e) 
	------------
	print_named_arg Absyn.NAMEDARG(ident,e)
end

	

(**)

relation print_row : Absyn.Exp list => () =

  rule	print_list_debug("print_row",es, print_exp, ",")
	------------------------------
	print_row es

end



(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp_str : Absyn.Exp => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp_str(Absyn.INTEGER(x)) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp_str(Absyn.REAL(x)) => s

  rule	print_component_ref_str (c) => s
	---------------------
	print_exp_str(Absyn.CREF(c)) => s

  rule	string_append("\"", s) => s' &
	string_append(s', "\"") => s''
	---------------------------------
	print_exp_str(Absyn.STRING(s)) => s''

  rule	print_bool_str b => s
	---------------------
	print_exp_str(Absyn.BOOL(b)) => s

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str(Absyn.BINARY(e1, op, e2)) => s1

  rule	op_symbol(op) => sym &
	print_exp_str e => s &
	string_append (sym, s) => s'
	----------------------------
	print_exp_str(Absyn.UNARY(op, e)) => s'

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str (Absyn.LBINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e => s &
	string_append (sym, s) => s'
	----------------------------
	print_exp_str(Absyn.LUNARY(op, e)) => s'

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str(Absyn.RELATION(e1, op, e2)) => s'

  rule	print_exp_str c => cs &
	print_exp_str t => ts &
	print_exp_str f => fs &
	string_append ("if ", cs) => s &
	string_append (s, " then ") => s' &
	string_append (s', ts) => s'' &
	string_append (s'', " else ") => s''' &
	string_append (s''', fs) => s''''
	---------------------------------
	print_exp_str(Absyn.IFEXP(c,t,f)) => s''''

  rule	print_component_ref_str(fcn) => fs &
	let argstr = "not implemented yet" & 
	string_append(fs, "(") => s &
	string_append(s, argstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp_str(Absyn.CALL(fcn, args)) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.ARRAY(es) => s''

	(* PR. *)
  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp_str Absyn.TUPLE(es) => s''
	
  rule	print_list_str(es, print_row_str, ";") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.MATRIX(es) => s''

  rule	print_exp_str (start) => s1 &
	print_exp_str (stop) => s3 &
	string_append ("(", s1) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ")") => s'''
	--------------------------------
	print_exp_str Absyn.RANGE(start,NONE,stop) => s'''

  rule	print_exp_str (start) => s1 &
	print_exp_str (step) => s2 &
	print_exp_str (stop) => s3 &
	string_append ("(", s1) => s &
	string_append (s, ":") => s' &
	string_append (s', s2) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s3) => s'''' &
	string_append (s'''', ")") => s'''''
	------------------------------------
	print_exp_str Absyn.RANGE(start,SOME(step),stop) => s'''''

  axiom	print_exp_str (_) =>  "#UNKNOWN EXPRESSION#"

end


relation print_row_str : Absyn.Exp list => string =

  rule	print_list_str (es, print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end


(* relation: op_symbol
 *
 * Make a string describing different operators.
 *)

relation op_symbol : Absyn.Operator => string =
  axiom	op_symbol(Absyn.ADD) => " + "
  axiom	op_symbol(Absyn.SUB) => " - "
  axiom	op_symbol(Absyn.MUL) => "*"
  axiom	op_symbol(Absyn.DIV) => "/"
  axiom	op_symbol(Absyn.POW) => "^"

  axiom	op_symbol(Absyn.UMINUS) => "-"
  axiom	op_symbol(Absyn.UPLUS) => "+"

  axiom	op_symbol(Absyn.AND) => " AND "
  axiom	op_symbol(Absyn.OR) => " OR "

  axiom	op_symbol(Absyn.NOT) => "NOT "

  axiom	op_symbol(Absyn.LESS)      => " < "
  axiom	op_symbol(Absyn.LESSEQ)    => " <= "
  axiom	op_symbol(Absyn.GREATER)   => " > "
  axiom	op_symbol(Absyn.GREATEREQ) => " >= "
  axiom	op_symbol(Absyn.EQUAL)     => " = "
  axiom	op_symbol(Absyn.NEQUAL)    => " <> "
end

(* - Utility relations
 *
 * These are utility relations used in some of the other
 * relations. *)

relation select_string: (bool,string,string) => string =

  axiom	select_string(true,a,b) => a
  axiom	select_string(false,a,b) => b

end

relation print_select: (bool,string,string) => () =

  rule	select_string(f,yes,no) => res &
	print res
	-------------------------
	print_select(f,yes,no)

end

relation print_option = (* : ('a option)*('a => 'b) = *)

  axiom	print_option(NONE,_)
	
  rule	r( x )
	------
	print_option(SOME(x),r)
	
end

relation print_list_debug : (string, 'a list, 'a => (), string) => () =

  rule	Debug.fprintln ("dumptr", "print_list_debug-1")
	-----------------------------------------------
	print_list_debug(_,[],_,_)
	
  rule	Debug.fprintl ("dumptr", ["print_list_debug-2 from ", caller, "\n"]) &
	r(h) &
	Debug.fprintln ("dumptr", "//print_list_debug-2")
	------------------
	print_list_debug(caller,[h],r,_)

  rule	string_append("print_list_debug-3 from ", caller) => s1 &
	Debug.fprintl ("dumptr", [s1, "\n"]) &
	r(h) & 
	print sep & 
	Debug.fprintln ("dumptr", "//print_list_debug-3") &
	print_list_debug(s1, rest, r, sep)
	-------------------------------------
	print_list_debug(caller, h::rest, r, sep)

end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep &
	print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end


relation get_string_list : ('a list, 'a => string, string) => string =

  axiom	get_string_list ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	get_string_list([h],r,_) => s

  rule	r(h) => s & 
	string_append (s, sep) => s' &
	get_string_list (t,r,sep) => srest &
	string_append (s', srest) => s''
	-------------------------------------
	get_string_list (h::t,r,sep) => s''

end

relation print_bool : bool => () =

  rule	print_select (b, "true", "false")
	---------------------------------
	print_bool b
end


relation get_option_str: ('a option, 'a => string) => string =
  rule  r (a) => str
	------------
	get_option_str (SOME(a),r) => str

  axiom	get_option_str(NONE,_) => ""
end

relation print_bool_str : bool => string =

  rule	select_string (b, "true", "false") => s
	---------------------------------
	print_bool_str b => s

end

relation stringlist_append : string list => string =

	axiom stringlist_append([]) => ""

  rule	stringlist_append(xs) => s2 &
	string_append(s1,s2) => str
	-----------------------------
        stringlist_append(s1::xs) => str
end