(* dump.rml *)

module Dump:

  with "exp.rml"
  with "types.rml"
  with "absyn.rml"

  type Ident = string

  (* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation dump_exp: Exp.Exp => ()
  relation dump_component_ref: Exp.ComponentRef => ()
  relation dump_list : ('a list, 'a => (), string) => ()

end

with "classinf.rml"

(*************************************************************************)
(* Dump routines for debugging of AST *)

relation dump_select: (bool,string,string) => () =

	rule	print no
		-------------------------
		dump_select(false,yes,no)

	rule	print yes
		-------------------------
		dump_select(true,yes,no)

end

relation dump_option = (* : ('a option)*('a => 'b) = *)

	axiom	dump_option(NONE,_)

	rule	r( x )
		---------------------
		dump_option(SOME(x),r)

end

relation dump_list : ('a list, 'a => (), string) => () =

	axiom	dump_list([],_,_)

	rule	r(h)
		------------------
		dump_list([h],r,_)

	rule	r(h) & print sep & dump_list(t,r,sep)
		-------------------------------------
		dump_list(h::t,r,sep)
end

(* Exp *)

relation dump_exp: Exp.Exp => () =

  rule	Exp.dump_exp e
	--------------
	dump_exp e

end 

(* Class *)

relation dump_class_restriction: Absyn.ClassRestriction => () =

  rule	ClassInf.print_restr re
	-----------------------
	dump_class_restriction re

end

relation dump: Absyn.Program => () =

	axiom	dump [] => ()

	rule	dump_class c & print "\n" &
		dump cs
		----------------
		dump c::cs => ()

end
and dump_class: Absyn.Class => () =

	rule	dump_class_restriction(r) & print "(" &
		print n & print "," & dump_select(p,"PARTIAL,","") &
		dump_list(parts,dump_class_part,",") & print ")"
		----------------------------------------
		dump_class(Absyn.CLASS(n,p,r,Absyn.PARTS(parts))) => ()

	rule	dump_class_restriction(r) & print "(" &
		print n & print "," & dump_select(p,"PARTIAL,","") &
		print ") = " & Exp.path_string(i) => is & print is &
		dump_class_modification(m)
		----------------------------------------
		dump_class(Absyn.CLASS(n,p,r,Absyn.DERIVED(i,_,m))) => ()

end
and dump_class_modification =

	axiom	dump_class_modification([])

	rule	print "(" & dump_list(l,dump_element_arg,",") & print ")"
		---------------------------------------------------------
		dump_class_modification(l)

end
and dump_element_arg =

	rule	print "ARG(" &
		dump_select(f,"FINAL,",",") &
		Exp.path_string(r) => s & print s &
		dump_modification(m) &
		print ")"
		-------------------------------------------
		dump_element_arg(Absyn.MODIFICATION(f,r,m))

end
and dump_class_part: Absyn.ClassPart => () =

	rule 	print "PUBLIC(" & dump_elements(el) & print ")"
		-----------------------------------------------
		dump_class_part(Absyn.PUBLIC(el))

	rule 	print "PROTECTED(" & dump_elements(el) & print ")"
		---------------------------------------
		dump_class_part(Absyn.PROTECTED(el))

	rule 	print "EQUATIONS(" &
		dump_list(eqs,dump_equation,",") &
		print ")"
		--------------------------------------
		dump_class_part(Absyn.EQUATIONS(eqs))

	rule 	print "ALGORITHMS(...)"
		---------------------------------------
		dump_class_part(Absyn.ALGORITHMS(_))

end
and dump_elements: Absyn.Element list => () =

	axiom	dump_elements [] => ()

	rule    dump_element e
		--------------------------
		dump_elements [e]

	rule    dump_element e & print "," &
		dump_elements els
		--------------------------
		dump_elements e::els

end
and dump_element: Absyn.Element => () =

	rule	print "ELEMENT(" & dump_select(final,"FINAL,","") &
		dump_elementspec spec & print ")"
		----------------
		dump_element (Absyn.ELEMENT(final,_,spec))

end
and dump_elementspec: Absyn.ElementSpec => () =

	rule	print "CLASSDEF(" & dump_select(repl,"REPLACEABLE,","") &
		dump_class cl & print ")"
		-------------------------
		dump_elementspec(Absyn.CLASSDEF(repl,cl))


	rule	Exp.path_string(p) => s &
		print "EXTENDS(" & print s & print "," &
		dump_list(l,dump_element_arg,",") & print ")"
		------------------------------------------
		dump_elementspec(Absyn.EXTENDS(p,l))

  rule	print "COMPONENTS(attr... ," &
	Exp.path_string(t) => ts & print ts & print "," &
	dump_list(cs, dump_component, ",") &
	print ")"
	------------------------------------------
	dump_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	print " ##ERROR## "
	-------------------
		dump_elementspec(_)

end
and dump_component: Absyn.Component => () =

	rule	print n &
		dump_arraydim a &
		dump_option(m,dump_modification)
		------------------------------------------
		dump_component(Absyn.COMPONENT(n,a,m))


end
and dump_arraydim: Absyn.ArrayDim => () =

  axiom dump_arraydim(Types.NODIM)

  rule	print "[" & dump_subscript(s) & print "]"
	-----------------------------------------
	dump_arraydim(Types.ONEDIM(s))
	
  rule	print "[" & dump_subscript(s1) &
	print "," & dump_subscript(s2) & print "]"
	-----------------------------------------
	dump_arraydim(Types.TWODIM(s1,s2))
	
end
and dump_subscript: Absyn.Subscript => () =

	rule	print ":"
		---------
		dump_subscript(Exp.NOSUB)

	rule	dump_exp(e1)
		----------
		dump_subscript(Exp.SUB1(e1))

	rule	dump_exp(e1) & print ":" & dump_exp(e2)
		-------------
		dump_subscript(Exp.SUB2(e1,e2))

	rule	dump_exp(e1) & print ":" &
		dump_exp(e2) & print ":" & dump_exp(e3)
		----------------------------------------------
		dump_subscript(Exp.SUB3(e1,e2,e3))

end
and dump_modification: Absyn.Modification => () =

	rule	dump_mod1 l & dump_mod2 e
		-------------------------
		dump_modification(Absyn.CLASSMOD(l, e))

	rule	print "( ** MODIFICATION ** )"
		-------------
		dump_modification(_)

end
and dump_mod1: Absyn.ElementArg list => () =

  axiom	dump_mod1 []

  rule	print "(" &
	dump_list(l,dump_element_arg,",") &
	print ")"
	------------------------------------
	dump_mod1 l

end
and dump_mod2 : Exp.Exp option => () =

  axiom	dump_mod2 NONE

  rule	print " = " & dump_exp(e)
	-------------------------
	dump_mod2 SOME(e)

end
and dump_equation: Absyn.Equation => () =

	rule	print "EQ_EXPR(" & dump_exp(e) & print ")"
		-------------------------------------------
		dump_equation(Absyn.EQ_EXPR(e))

	rule	print "EQ_EQUALS(" & dump_exp(e1) & print "," &
		dump_exp(e2) & print ")"
		-------------------------------------------
		dump_equation(Absyn.EQ_EQUALS(e1,e2))

	rule	print "EQ_CONNECT(" & dump_component_ref(e1) & print "," &
		dump_component_ref(e2) & print ")"
		-------------------------------------------
		dump_equation(Absyn.EQ_CONNECT(e1,e2))

	rule	print " ** UNKNOWN EQUATION ** "
		--------------------------------
		dump_equation(_)

end
and dump_component_ref : Exp.ComponentRef => () =

	rule	dump_list(cr,dump_component_ref2,".")
		-------------------------------------
		dump_component_ref(cr)

end
and dump_component_ref2 =

	rule	print s
		-------------------------
		dump_component_ref2((s,[]))

	rule	print s &
		print "[" & dump_list(l,dump_subscript,",") & print "]"
		-------------------------------------------------------------
		dump_component_ref2((s,l))

end
