(* dump.rml *)

module Dump:

  with "exp.rml"
  with "class.rml"
  with "absyn.rml"

  type Ident = string

  (* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation dump_exp: Exp.Exp => ()

end

(*************************************************************************)
(* Dump routines for debugging of AST *)

relation dump_select: (bool,string,string) => () =

	rule	print no
		-------------------------
		dump_select(false,yes,no)

	rule	print yes
		-------------------------
		dump_select(true,yes,no)

end

relation dump_option = (* : ('a option)*('a => 'b) = *)

	axiom	dump_option(NONE,_)

	rule	r( x )
		---------------------
		dump_option(SOME(x),r)

end

relation dump_list =

	axiom	dump_list([],_,_)

	rule	r(h)
		------------------
		dump_list([h],r,_)

	rule	r(h) & print sep & dump_list(t,r,sep)
		-------------------------------------
		dump_list(h::t,r,sep)
end

(* Exp *)

relation binop_symbol: Exp.BinOp => string =
	axiom	binop_symbol(Exp.ADD) => " + "
	axiom	binop_symbol(Exp.SUB) => " - "
	axiom	binop_symbol(Exp.MUL) => "*"
	axiom	binop_symbol(Exp.DIV) => "/"
end

relation unaryop_symbol: Exp.UnaryOp => string =
	axiom	unaryop_symbol(Exp.UMINUS) => "-"
	axiom	unaryop_symbol(Exp.UPLUS) => "+"
end

relation path_string: Exp.Path => string =
	axiom	path_string(Exp.IDENT(s)) => s

	rule	path_string(n) => ns &
		string_append(s,".") => s1 &
		string_append(s1,ns) => ss
		--------------------------------------------
		path_string(Exp.QUALIFIED(s,n)) => ss
end

relation dump_exp: Exp.Exp => () =
	rule	print "N"
		--------------
		dump_exp(Exp.NUMBER(x))

	rule	path_string(p) => s &
		print s
		---------------
		dump_exp(Exp.PATH(p))

	rule	binop_symbol(op) => sym &
		dump_exp e1 & print sym & dump_exp e2
		----------------------------
		dump_exp(Exp.BINARY(e1, op, e2))

	rule	unaryop_symbol(op) => sym &
		print sym & dump_exp e
		----------------------------
		dump_exp(Exp.UNARY(op, e))

	rule	path_string(fcn) => fs &
		print fs & print "(" & dump_list(args,dump_exp,",") & print ")"
		---------------------------------------------
		dump_exp(Exp.CALL(fcn, args))

	rule	print "EQUATION " & 
		dump_exp lhs &
		print " = " &
		dump_exp rhs
		------------------------
		dump_exp(Exp.EQU(lhs, rhs))

	rule	print "TIME"
		------------------
		dump_exp(Exp.TIME)

  	rule	print "#UNKNOWN EXPRESSION#"
        	----------------------------------
	        dump_exp (_)
end

(* Class *)

relation dump_class_restriction: Class.ClassRestriction => () =

	rule	print "CLASS"
		--------------------------------------------
		dump_class_restriction(Class.CL_CLASS) => ()

	rule	print "TYPE"
		----------------------------
		dump_class_restriction(Class.CL_TYPE) => ()

	rule	print "CONNECTOR"
		----------------------------
		dump_class_restriction(Class.CL_CONNECTOR) => ()

	rule	print "MODEL"
		----------------------------
		dump_class_restriction(Class.CL_MODEL) => ()

	rule	print "MODEL"
		------------------------------------------------
		dump_class_restriction(Class.CL_MODEL) => ()

	rule	print "BLOCK"
		------------------------------------------------
		dump_class_restriction(Class.CL_BLOCK) => ()

	rule	print "PACKAGE"
		--------------------------------------------------
		dump_class_restriction(Class.CL_PACKAGE) => ()

	rule	print "FUNCTION"
		---------------------------------------------------
		dump_class_restriction(Class.CL_FUNCTION) => ()

end

relation dump: Absyn.Program => () =

	axiom	dump [] => ()

	rule	dump_class c & print "\n" &
		dump cs
		----------------
		dump c::cs => ()

end
and dump_class: Class.Class => () =

	rule	dump_class_restriction(r) & print "(" &
		print n & print "," & dump_select(p,"PARTIAL,","") &
		dump_list(parts,dump_class_part,",") & print ")"
		----------------------------------------
		dump_class(Class.CLASS(n,p,r,parts)) => ()

end
and dump_class_part: Class.ClassPart => () =

	rule 	print "PUBLIC(" & dump_elements(el) & print ")"
		-----------------------------------------------
		dump_class_part(Class.PUBLIC(el))

	rule 	print "PROTECTED" & dump_elements(el) & print ")"
		---------------------------------------
		dump_class_part(Class.PROTECTED(el))

	rule 	print "EQUATIONS(" &
		dump_list(eqs,dump_equation,",") &
		print ")"
		--------------------------------------
		dump_class_part(Class.EQUATIONS(eqs))

	rule 	print "ALGORITHMS(...)"
		---------------------------------------
		dump_class_part(Class.ALGORITHMS(_))

end
and dump_elements: Class.Element list => () =

	axiom	dump_elements [] => ()

	rule    dump_element e
		--------------------------
		dump_elements [e]

	rule    dump_element e & print "," &
		dump_elements els
		--------------------------
		dump_elements e::els

end
and dump_element: Class.Element => () =

	rule	print "ELEMENT(" & dump_select(final,"FINAL,","") &
		dump_elementspec spec & print ")"
		----------------
		dump_element (Class.ELEMENT(final,spec))

end
and dump_elementspec: Class.ElementSpec => () =

	rule	print "CLASSDEF(" & dump_select(repl,"REPLACEABLE,","") &
		dump_class cl & print ")"
		-------------------------
		dump_elementspec(Class.CLASSDEF(repl,cl))


	rule	print "EXTENDS(" & print s & print ",...)"
		------------------------------------------
		dump_elementspec(Class.EXTENDS(s,l))

	rule	print "COMPONENT(" &
		dump_select(f,"FLOW,","") &
		dump_select(p,"PARAMETER,","") &
		dump_select(c,"CONSTANT,","") &
		dump_select(i,"INPUT,","") &
		dump_select(o,"OUTPUT,","") &
		path_string t => ts & print ts & print "," &
		print n &
		dump_option(a,dump_arraydim) &
		dump_option(m,dump_modification) &
		print ")"
		------------------------------------------
		dump_elementspec(Class.COMPONENT(f,p,c,i,o,t,n,a,m))

	rule	print " *** "
		-------------------
		dump_elementspec(_)

end
and dump_arraydim: Class.ArrayDim => () =

	rule	print "[" & dump_subscript(s) & print "]"
		-----------------------------------------
		dump_arraydim(Class.ONEDIM(s))

	rule	print "[" & dump_subscript(s1) &
		print "," & dump_subscript(s2) & print "]"
		-----------------------------------------
		dump_arraydim(Class.TWODIM(s1,s2))

end
and dump_subscript: Class.Subscript => () =

	rule	print ":"
		---------
		dump_subscript(NONE)

	rule	dump_exp(e1)
		----------
		dump_subscript(SOME((e1,NONE)))

	rule	dump_exp(e1) & print ":" & dump_exp(e2)
		-------------
		dump_subscript(SOME((e1,SOME((e2,NONE)))))

	rule	dump_exp(e1) & print ":" &
		dump_exp(e2) & print ":" & dump_exp(e3)
		----------------------------------------------
		dump_subscript(SOME((e1,SOME((e2,SOME(e3))))))

end
and dump_modification: Class.Modification => () =

	rule	print "(...)"
		-------------
		dump_modification(_)

end
and dump_equation: Class.Equation => () =

	rule	print "EQUATION(" & dump_exp(e) & print ")"
		-------------------------------------------
		dump_equation(Class.EQ_EXPR(e))

end
