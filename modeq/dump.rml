(** file: dump.rml
 **
 ** Dump routines for debugging of the AST.
 **)


module Dump:

  with "absyn.rml"

  type Ident = string

  (* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation print_exp: Absyn.Exp => ()
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list : ('a list, 'a => (), string) => ()

end

with "classinf.rml"

(** - Relations *)

relation dump: Absyn.Program => () =
	
  axiom	dump [] => ()
	
  rule	print_class c & print "\n" &
	dump cs
	----------------
	dump c::cs => ()

end

(**)

relation print_class: Absyn.Class => () =

  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print_list(parts,print_class_part,",") & print ")"
	----------------------------------------
	print_class(Absyn.CLASS(n,p,r,Absyn.PARTS(parts))) => ()

  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print ") = " & Absyn.path_string(i) => is & print is &
	print_class_modification(m)
	----------------------------------------
	print_class(Absyn.CLASS(n,p,r,Absyn.DERIVED(i,_,m))) => ()

end

(**)

relation print_class_restriction: Absyn.Restriction => () =

  rule	Absyn.print_restr re
	-----------------------
	print_class_restriction re

end

(**)

relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	print "(" & print_list(l,print_element_arg,",") & print ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

(**)

relation print_element_arg =
	
  rule	print "ARG(" &
	print_select(f,"FINAL,",",") &
	print_component_ref(r) &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,r,m))
	
  rule	print "REDECLARATION(" &
	print_select(f,"FINAL,",",") &
	print_elementspec spec &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,spec))

end

(**)

relation print_class_part: Absyn.ClassPart => () =

  rule 	print "PUBLIC(" & print_elements(el) & print ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule 	print "PROTECTED(" & print_elements(el) & print ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule 	print "EQUATIONS(" &
	print_list(eqs,print_equation,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))
	
  rule 	print "ALGORITHM(" &
	print_list(eqs,print_algorithm,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(eqs))
	
end

(**)

relation print_elements: Absyn.Element list => () =

  axiom	print_elements [] => ()

  rule	print_element e
	--------------------------
	print_elements [e]
	
  rule	print_element e & print "," &
	print_elements els
	--------------------------
	print_elements e::els
	
end

(**)

relation print_element: Absyn.Element => () =
	
  rule	print "ELEMENT(" & print_select(final,"FINAL,","") &
	print_elementspec spec & print ")"
	----------------
	print_element (Absyn.ELEMENT(final,_,spec))

end

(**)

relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	print "CLASSDEF(" & print_select(repl,"REPLACEABLE,","") &
	print_class cl & print ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
	
  rule	Absyn.path_string(p) => s &
	print "EXTENDS(" & print s & print "," &
	print_list(l,print_element_arg,",") & print ")"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	print "COMPONENTS(attr... ," &
	Absyn.path_string(t) => ts & print ts & print "," &
	print_list(cs, print_component, ",") &
	print ")"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	print " ##ERROR## "
	-------------------
		print_elementspec(_)

end

(**)

relation print_component: Absyn.Component => () =

	rule	print n &
		print_arraydim a &
		print_option(m,print_modification)
		------------------------------------------
		print_component(Absyn.COMPONENT(n,a,m))

end

(**)

relation print_arraydim: Absyn.ArrayDim => () =

  axiom print_arraydim(Absyn.NODIM)

  rule	print "[" & print_subscript(s) & print "]"
	-----------------------------------------
	print_arraydim(Absyn.ONEDIM(s))
	
  rule	print "[" & print_subscript(s1) &
	print "," & print_subscript(s2) & print "]"
	-----------------------------------------
	print_arraydim(Absyn.TWODIM(s1,s2))
	
end

relation print_subscript: Absyn.Subscript => () =

	rule	print ":"
		---------
		print_subscript(Absyn.NOSUB)

	rule	print_exp(e1)
		----------
		print_subscript(Absyn.SUB1(e1))

	rule	print_exp(e1) & print ":" & print_exp(e2)
		-------------
		print_subscript(Absyn.SUB2(e1,e2))

	rule	print_exp(e1) & print ":" &
		print_exp(e2) & print ":" & print_exp(e3)
		----------------------------------------------
		print_subscript(Absyn.SUB3(e1,e2,e3))

end

(** - Modifications *)

relation print_modification: Absyn.Modification => () =
	
  rule	print_mod1 l & print_mod2 e
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	print "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	print "(" &
	print_list(l,print_element_arg,",") &
	print ")"
	------------------------------------
	print_mod1 l

end

relation print_mod2 : Absyn.Exp option => () =

  axiom	print_mod2 NONE

  rule	print " = " & print_exp(e)
	-------------------------
	print_mod2 SOME(e)

end

(** - Equations *)

relation print_equation: Absyn.Equation => () =
	
  rule	print "EQ_EXPR(" & print_exp(e) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EXPR(e))
	
  rule	print "EQ_EQUALS(" & print_exp(e1) & print "," &
	print_exp(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	print "EQ_CONNECT(" & print_component_ref(e1) & print "," &
	print_component_ref(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list(el, print_equation, ";") & print "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	print " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

(** - Algorithm clauses *)

relation print_algorithm: Absyn.Algorithm => () =
	
  rule	print "ALG_ASSIGN(" & print_component_ref cr &
	print " := " & print_exp(exp) & print ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	print "ALG_COND(..." & print ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_COND)
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list(el, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	print "WHILE " & print_exp(e) &
	print " {" & print_list(al, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
  rule	print "WHEN " & print_exp(e) &
	print " {" & print_list(al, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN(e,al)
	
  rule	print " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

(** - Component references *)

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : Absyn.ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	print_component_ref2 (s,subs) &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

relation print_component_ref2 =

  rule	print s
	-------
	print_component_ref2 (s,[])

  rule	print s &
	print "[" & print_list(l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** - Expressions *)

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp: Absyn.Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	print_component_ref(c)
	---------------------
	print_exp(Absyn.CREF(c))

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	print "FALSE"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	print "TRUE"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	binop_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	---------------------------------------------------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	unaryop_symbol(op) => sym &
	print sym & print_exp e
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	lbinop_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	lunaryop_symbol(op) => sym & print sym & print_exp e
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	relop_symbol(op) => sym & print_exp(e1) & print sym & print_exp(e2)
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	print "IF " & print_exp(c) &
	print " THEN " & print_exp(t) &
	print " ELSE " & print_exp(f)
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f))

  rule	Absyn.path_string(fcn) => fs &
	print fs & print "(" & print_list(args,print_exp,",") & print ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	print "[" &
	print_list(es, print_exp, ",") &
	print "]"
	---------
	print_exp Absyn.ARRAY(es)
	
  rule	print "[MATRIX]"
	---------
	print_exp Absyn.MATRIX(es)

  rule	print "(" & print_exp start & print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	print "(" & print_exp start & print ":" & print_exp step &
 	print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule	print "#UNKNOWN EXPRESSION#"
        ----------------------------------
	print_exp (_)
end

(** relation: *_symbol
 **
 ** Make a string describing different operators.
 **)

relation binop_symbol : Absyn.BinOp => string =
  axiom	binop_symbol(Absyn.ADD) => " + "
  axiom	binop_symbol(Absyn.SUB) => " - "
  axiom	binop_symbol(Absyn.MUL) => "*"
  axiom	binop_symbol(Absyn.DIV) => "/"
  axiom	binop_symbol(Absyn.POW) => "^"
end

relation unaryop_symbol : Absyn.UnaryOp => string =
  axiom	unaryop_symbol(Absyn.UMINUS) => "-"
  axiom	unaryop_symbol(Absyn.UPLUS) => "+"
end

relation lbinop_symbol : Absyn.LBinOp => string =
  axiom	lbinop_symbol(Absyn.AND) => " AND "
  axiom	lbinop_symbol(Absyn.OR) => " OR "
end

relation lunaryop_symbol : Absyn.LUnaryOp => string =
  axiom	lunaryop_symbol(Absyn.NOT) => "NOT "
end

relation relop_symbol : Absyn.RelOp => string =
  axiom	relop_symbol(Absyn.LESS)      => " < "
  axiom	relop_symbol(Absyn.LESSEQ)    => " <= "
  axiom	relop_symbol(Absyn.GREATER)   => " > "
  axiom	relop_symbol(Absyn.GREATEREQ) => " >= "
  axiom	relop_symbol(Absyn.EQUAL)     => " = "
  axiom	relop_symbol(Absyn.NEQUAL)    => " <> "
end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

relation print_select: (bool,string,string) => () =

  rule	print no
	-------------------------
	print_select(false,yes,no)
	
  rule	print yes
	-------------------------
	print_select(true,yes,no)

end

relation print_option = (* : ('a option)*('a => 'b) = *)

  axiom	print_option(NONE,_)
	
  rule	r( x )
	------
	print_option(SOME(x),r)
	
end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end
