(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 env.rml
 ** module:      Env
 ** description: Environmane management
 **
 ** RCS: $Id$
 **
 ** An environment is a stack of frames, where each frame contains a
 ** number of class and variable bindings.
 **)

module Env:

  with "absyn.rml"
  with "values.rml"
  with "explode.rml"
  with "types.rml"
  with "classinf.rml"
  with "exp.rml"

  type Ident = string

  datatype Frame = FRAME of (Ident * Item) list

  datatype Item = VAR of Types.Var * SCode.Element option * bool
		| CLASS of SCode.Class * Env
		| TYPE of Types.Type

  type Env = Frame list

  val empty_frame : Frame
  val empty_env   : Env

  relation open_scope       : Env => Env
  relation extend_frame_c   : (Env, SCode.Class) => Env
  relation extend_frame_v   : (Env, Types.Var,SCode.Element option,bool) => Env
  relation update_frame_v   : (Env, Types.Var,bool) => Env
  relation extend_frame_t : (Env,Ident,Types.Type) => Env


  relation print_env        : Env => ()

  relation print_env_graphviz : (Env * string) => ()

  relation print_frame      : Frame => ()

end

with "dump.rml"
with "graphviz.rml"
with "dae.rml"

(** - Values *)

val empty_frame = FRAME([])
val empty_env = []

(** - Relations *)

(** relation: open_scope
 **
 ** Opening a new scope in the environment mans adding a new frame on
 ** top of the stack of frames.
 **)

relation open_scope: Env => Env =

  axiom	open_scope(env) => empty_frame::env

(*  rule
	print "\nOpens scope."
	-----------
	open_scope(env) => empty_frame::env
*)
end

(** relation: extend_frame_c
 **
 ** This relation adds a class definition to the environment.
 **)

relation extend_frame_c : (Env, SCode.Class) => Env =

(*
  rule	print "extend_frame_c:\n" &
	print_env env &
	print " + " &
	print n &
	print " = " &
	print_env ((FRAME((n,CLASS(c,env))::items)::fs)) &
	print "\n" 
	----------------
	extend_frame_c(env as (FRAME(items)::fs),c as SCode.CLASS(n,_,_,_))
	  => ((FRAME((n,CLASS(c,env))::items)::fs))
*)

  axiom	extend_frame_c(env as (FRAME(items)::fs),c as SCode.CLASS(n,_,_,_))
	  => ((FRAME((n,CLASS(c,env))::items)::fs))

end

(** relation: extend_frame_v
 **
 ** This relation adds a component to the environment.
 **)

relation extend_frame_v : (Env,Types.Var,SCode.Element option,bool) => Env =
	
(*
  rule	print "extend_frame_v:\n" &
   print_env env &
   print " + " &
   print n &
	print " = " &
   print_env (FRAME((n,VAR(v))::items)::fs) &
   print "\n" 
   ----------------
   extend_frame_v(env as (FRAME(items)::fs),v as Types.VAR(n,_,_,_,_))
   => (FRAME((n,VAR(v))::items)::fs)
 *)
	
  axiom extend_frame_v(FRAME(items)::fs,v as Types.VAR(n,_,_,_,_),c,i)
	    => (FRAME((n,VAR(v,c,i))::items)::fs)
	    
end
	
(** relation: update_frame_v
 **
 ** This relation updates a component already added to the environment, but that prior to the
 ** update did not have any binding. (I.e this relation is called in the second stage of 
 **  instantiation with declare before use.)
**)
	
	
relation update_frame_v : (Env,Types.Var,bool) => Env =
	
  rule	v = n
	---------------------------	
	update_frame_v(FRAME((id,VAR(Types.VAR(v,_,_,_,_),c,_))::rest)::rest2,v2 as Types.VAR(n,_,_,_,_),i) 
	    => (FRAME((id,VAR(v2,NONE,i))::rest)::rest2)
  rule	not v = n &
	update_frame_v(FRAME(rest)::rest2,v2,i) => FRAME(res)::reslst
	-------------------------------------------
	update_frame_v(FRAME((id,VAR(v1 as Types.VAR(v,_,_,_,_),c,i1))::rest)::rest2,v2 as Types.VAR(n,_,_,_,_),i)
	    => FRAME((id,VAR(v1,c,i1))::res)::reslst
	
	
  axiom update_frame_v(FRAME([])::fs,v as Types.VAR(n,_,_,_,_),_)
	    => (FRAME([])::fs)
end
	
(** relation: extend_frame_t
 **
 ** This relation adds a type to the environment.  Types in the
 ** environment are used for looking up constants etc. inside class
 ** definitions, such as packages.  For each type in the environment,
 ** there is a class definition with the same name in the
 ** environment.
 **)

relation extend_frame_t : (Env,Ident,Types.Type) => Env =

(*
  rule	print "extend_frame_t:\n" &
	print_env env &
	print " + " &
	print n &
	print " = " &
	print_env (FRAME((n,TYPE(t))::items)::fs) &
	print "\n" 
	----------------
	extend_frame_t(env as (FRAME(items)::fs), n, t)
	  => (FRAME((n,TYPE(t))::items)::fs)
*)

  axiom extend_frame_t(FRAME(items)::fs, n, t)
	  => (FRAME((n,TYPE(t))::items)::fs)

end

relation print_env : Env => () =

  rule	print "Empty env\n"
	-------------------
	print_env []

  rule	print_frame fr &
	print_env frs
	------------
	print_env fr::frs

end


relation print_frame : Frame => () =

  rule	print "FRAME: " &
	print_frame_contents cont &
	print "\n"
	--------------------------------------------
	print_frame FRAME(cont)

end


relation print_frame_contents: (Ident * Item) list => () =

  axiom	print_frame_contents [] 

  rule	print_frame_element e
	-------------------------
	print_frame_contents [e as (n,i)]

  rule	print_frame_element e & print "," & print_frame_contents rst
	------------------------------------------------
	print_frame_contents ((e as (n,i))::rst)
end


relation print_frame_element: (Ident * Item) => () =

  rule	print "v:" & print n & print "(" &  SCode.print_element elt & print ")" 
	-------
	print_frame_element ((n,VAR(_,SOME(elt),i)))
  rule	print "v:" & print n 
	-------
	print_frame_element ((n,VAR(_,NONE,i)))

  rule	print "c:" & print n
	-------
	print_frame_element ((n,CLASS(_,_)))

  rule	print "t:" & print n
	-------
	print_frame_element ((n,TYPE(_)))

end


relation print_env_graphviz : (Env * string) => () =

  rule	build_env_graphviz ((env,str)) => r &
	Graphviz.dump(r)
	----------------
	print_env_graphviz ((env,str))

end

relation build_env_graphviz : (Env * string) => Graphviz.Node =

  rule	string_append ("ROOT: ", str) => str' &
	build_env_graphviz_2 env => nodelist
	------------------------------------
	build_env_graphviz ((env,str)) => Graphviz.NODE(str',[],nodelist)

end

relation build_env_graphviz_2 : Env => Graphviz.Node list =

  axiom	build_env_graphviz_2 [] => []

  rule	build_env_graphviz_2 rest => nodelist &
	build_frame_graphviz frame => node
	----------------------------------
	build_env_graphviz_2 frame::rest => node::nodelist

end

relation is_var_item = 
  axiom	is_var_item ((_,VAR(_,_,_))) 
end

relation is_class_item = 
  axiom	is_class_item ((_,CLASS(_,_))) 
end

relation is_type_item = 
  axiom	is_type_item ((_,TYPE(_))) 
end

relation build_frame_graphviz : Frame => Graphviz.Node =

  rule	build_item_listnode (itemlist, is_var_item,"VARS") => varsnode &
	build_item_listnode (itemlist, is_class_item,"CLASSES") => classesnode &
	build_item_listnode (itemlist, is_type_item,"TYPES") => typesnode &
	let nodelist = [varsnode,classesnode,typesnode]
	-------------------------------------------
	build_frame_graphviz FRAME(itemlist) => Graphviz.NODE("FRAME",[],nodelist)
end

relation build_item_listnode : ((Ident * Item) list, (Ident * Item) => (), string) 
	  => Graphviz.Node =

  rule	DAE.get_matching (items, cond) => selitems &
	build_item_listnode_2 (selitems, 1) => node
	--------------------------------------------------------
	build_item_listnode (items, cond, name) 
	  => Graphviz.NODE(name, [], [node])

end

relation build_item_listnode_2 : ((Ident * Item) list, int) 
	  => Graphviz.Node =

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, []) &
	int_string count => cstr
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [])

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, ignored) &
	int_string count => cstr &
	int_add (count, 1) => count' &
	build_item_listnode_2 (ignored, count') => restnode 
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [restnode])

end

relation build_item_str : (Ident * Item) => string =

  rule	string_append ("VAR: ",id) => s
	------------------------------
	build_item_str ((id, VAR(_,_,_))) => s

  rule	(*build_env_graphviz env => r &*)
	string_append ("CLASS: ", id) => s
	----------------------------------
	build_item_str ((id, CLASS(cls, env))) => s

  rule	string_append ("TYPE: ", id) => s
	---------------------------------
	build_item_str ((id, TYPE(_))) => s

end

(*
relation build_item_graphviz : (Ident, Item) => Graphviz.Node =

  axiom	build_item_graphviz (id, VAR(_)) => Graphviz.LNODE("VAR",[id],[],[])

  axiom	build_item_graphviz (id, CLASS(cls, env)) => Graphviz.LNODE("CLASS",[id],[],[])

  axiom	build_item_graphviz (id, TYPE(_)) => Graphviz.LNODE("TYPE",[id],[],[])

end
*)
