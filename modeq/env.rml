(**********************************************************************
 *
 *   Environments
 *
 * An environment is a stack of frames, where each frame contains a
 * number of class and variable bindings.
 *
 **********************************************************************)

module Env:

  with "exp.rml"
  with "explode.rml"
  with "mod.rml"

  datatype FrameVar = FRAMEVAR of Explode.Ident
				* Explode.ArrayDim option
				* Explode.Class
				* bool	(* flow *)
				* bool	(* parameter *)
				* bool	(* constant *)
				* bool	(* input *)
				* bool	(* output *)
				* Exp.Exp option (* equation *)

  datatype Frame = FRAME of (Explode.Ident*FrameVar) list
			  * (Explode.Ident*Explode.Class*Mod.Mod) list

  type Env = Frame list

  val empty_frame : Frame
  val empty_env   : Env

  relation new_frame      : Env => Env
  relation extend_frame_c : (Env, Explode.Class, Mod.Mod) => Env
  relation extend_frame_v : (Env, FrameVar) => Env
  relation lookup_class   : (Env, Explode.Path) => (Explode.Class, Mod.Mod)
  relation lookup_var     : (Env, Explode.Ident) => ()

end

val empty_frame = FRAME([],[])
val empty_env = []

relation new_frame: Env => Env =

  axiom	new_frame(env) => empty_frame::env

end

(**********************************************************************
 *
 *   Lookup functions
 *
 * These relations look up class and variable names in the environment.
 * The names are supplied as a path, and if the path is qualified, a
 * variable named as the first part of the path is searched for, and the
 * nave is looked for in it.
 *
 **********************************************************************)

relation lookup_class_f: ((Explode.Ident * Explode.Class * Mod.Mod) list,
			  Explode.Ident)
	  => (Explode.Class,Mod.Mod) =

  rule	(* print "  lookup_class_f(" & print id & print "): " &
	print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_class_f((n,c,m)::_, id) => (c,m)

  rule	lookup_class_f(fs,id) => (c,m)
	------------------------------
	lookup_class_f(_::fs,id) => (c,m)

end

relation lookup_class: (Env,Explode.Path) => (Explode.Class,Mod.Mod) =

  rule	lookup_class_f(cs,id) => (c,m)
	---------------------
	lookup_class(FRAME(_,cs)::fs,Exp.IDENT(id)) => (c,m)

  rule	lookup_class(fs,id) => (c,m)
	---------------------
	lookup_class(f::fs,id) => (c,m)

end

relation lookup_var2: ((Explode.Ident*FrameVar) list,Explode.Ident) => () =

  rule	id = n
	--------------------------------------------
	lookup_var2((n,_)::_,id)

  rule	lookup_var2(fs,id)
	---------------------
	lookup_var2(_::fs,id)

end

relation lookup_var: (Env,Explode.Ident) => () =

  rule	lookup_var2(vs,id)
	--------------------
	lookup_var(FRAME(vs,_)::fs,id)

  rule	lookup_var(fs,id)
	--------------------
	lookup_var(_::fs,id)

end

relation extend_frame_c : (Env, Explode.Class, Mod.Mod) => Env =

  axiom	extend_frame_c(FRAME(vs,cs)::fs,c as Explode.CLASS(n,_,_,_),m)
	  => ((FRAME(vs,(n,c,m)::cs)::fs))

end

relation extend_frame_v : (Env,FrameVar) => Env =

  axiom extend_frame_v(FRAME(vs,cs)::fs,v as FRAMEVAR(n,_,_,_,_,_,_,_,_))
	  => (FRAME((n,v)::vs,cs)::fs)

end
