(**********************************************************************
 *
 *   Environments
 *
 * An environment is a stack of frames, where each frame contains a
 * number of class and variable bindings.
 *
 **********************************************************************)

module Env:

  with "exp.rml"
  with "absyn.rml"
  with "mod.rml"

  datatype FrameVar = FRAMEVAR of Absyn.Ident
				* Absyn.ArrayDim option
				* Absyn.Class
				* bool	(* flow *)
				* bool	(* parameter *)
				* bool	(* constant *)
				* bool	(* input *)
				* bool	(* output *)

  datatype Frame = FRAME of (Absyn.Ident*FrameVar) list
			  * (Absyn.Ident*Absyn.Class*Mod.Mod) list

  type Env = Frame list

  val empty_frame : Frame
  val empty_env   : Env

  relation new_frame      : Env => Env
  relation extend_frame_c : (Env, Absyn.Class, Mod.Mod) => Env
  relation extend_frame_v : (Env, FrameVar) => Env
  relation lookup_class   : (Env, Absyn.Path) => (Absyn.Class, Mod.Mod)
  relation lookup_var     : (Env, Absyn.Ident) => ()

end

val empty_frame = FRAME([],[])
val empty_env = []

relation new_frame: Env => Env =

  axiom	new_frame(env) => empty_frame::env

end

(**********************************************************************
 *
 *   Lookup functions
 *
 * These relations look up class and variable names in the environment.
 * The names are supplied as a path, and if the path is qualified, a
 * variable named as the first part of the path is searched for, and the
 * nave is looked for in it.
 *
 **********************************************************************)

relation lookup_class_f: ((Absyn.Ident * Absyn.Class * Mod.Mod) list,
			  Absyn.Ident)
	  => (Absyn.Class,Mod.Mod) =

  rule	(* print "  lookup_class_f(" & print id & print "): " &
	print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_class_f((n,c,m)::_, id) => (c,m)

  rule	lookup_class_f(fs,id) => (c,m)
	------------------------------
	lookup_class_f(_::fs,id) => (c,m)

end

relation lookup_class: (Env,Absyn.Path) => (Absyn.Class,Mod.Mod) =

(*
  rule  lookup_var(f,IDENT(n)) => v & &
	print "lookup_class: FIXME\n" &
	fail
	----------------
	lookup_class(f,Absyn.QUALIFIED(n,p))
	 => fail
*)

  rule	lookup_class_f(cs,id) => (c,m)
	---------------------
	lookup_class(FRAME(_,cs)::fs,Exp.IDENT(id)) => (c,m)

  rule	lookup_class(fs,id) => (c,m)
	---------------------
	lookup_class(f::fs,id) => (c,m)

end

relation lookup_var2: ((Absyn.Ident*FrameVar) list,Absyn.Ident) => () =

  rule	id = n
	--------------------------------------------
	lookup_var2((n,_)::_,id)

  rule	lookup_var2(fs,id)
	---------------------
	lookup_var2(_::fs,id)

end

relation lookup_var: (Env,Absyn.Ident) => () =

  rule	lookup_var2(vs,id)
	--------------------
	lookup_var(FRAME(vs,_)::fs,id)

  rule	lookup_var(fs,id)
	--------------------
	lookup_var(_::fs,id)

end

relation extend_frame_c : (Env, Absyn.Class, Mod.Mod) => Env =

  rule  print " extend_frame_c: " & print n & print "\n"
	------------------------------------------------
	extend_frame_c(FRAME(vs,cs)::fs,c as Absyn.CLASS(n,_,_,_),m)
	 => ((FRAME(vs,(n,c,m)::cs)::fs))

end

relation extend_frame_v : (Env,FrameVar) => Env =

  axiom extend_frame_v(FRAME(vs,cs)::fs,v as FRAMEVAR(n,_,_,_,_,_,_,_))
	 => (FRAME((n,v)::vs,cs)::fs)

end
