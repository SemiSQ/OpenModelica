(*
 * Exp - Modelica expression module
 *)

module Exp:
  
  type Ident = string
  
  datatype Subscript = NOSUB
		     | SUB1 of Exp
		     | SUB2 of Exp * Exp
		     | SUB3 of Exp * Exp * Exp
		 
  type ComponentRef = (Ident * (Subscript list)) list
  
  datatype Path = QUALIFIED of string * Path
	      	| IDENT of Ident
	      	
  datatype BinOp = ADD | SUB | MUL | DIV | POW
  datatype UnaryOp = UMINUS | UPLUS
  datatype LBinOp = AND | OR
  datatype LUnaryOp = NOT
  datatype RelOp = LESS | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  datatype Exp = NUMBER of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       
	       | BINARY of Exp * BinOp * Exp
	       | UNARY of UnaryOp * Exp
	       
	       | LBINARY of Exp * LBinOp * Exp
	       | LUNARY of LUnaryOp * Exp
	       
	       | RELATION of Exp * RelOp * Exp
	       
	       | IFEXP of Exp * Exp * Exp
	       
	       | CALL of Path * Exp list		(* Function call *)
	       | TIME
		  
  relation path_string : Path => string
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation eq_cref : (ComponentRef, ComponentRef) => ()
  
end

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref([], i, s) => [(i,s)]

  rule	extend_cref(xs, i, s) => xs'
	----------------------------
	extend_cref(x::xs, i, s) => x::xs'

end

relation eq_subscript : (Subscript, Subscript) => () =

  axiom	eq_subscript(NOSUB,NOSUB)

	(* FIXME *)
  rule	print "# Subscript expression\n" &
	fail
	--------------------------------
	eq_subscript(_,_)

end

relation eq_subscripts : (Subscript list, Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

relation eq_cref : (ComponentRef, ComponentRef) => () =

  axiom	eq_cref([],[])

  rule	n1 = n2 &
	eq_subscripts(s1,s2) &
	eq_cref(c1,c2)
	-------------------
	eq_cref((n1,s1)::c1, (n2,s2)::c2)

end
