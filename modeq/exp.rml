(*
 * Exp - Modelica expression module
 *)

module Exp:
  
  type Ident = string
  
  datatype Subscript = NOSUB
		     | SUB1 of Exp
		     | SUB2 of Exp * Exp
		     | SUB3 of Exp * Exp * Exp
		 
  type ComponentRef = (Ident * (Subscript list)) list
  
  datatype Path = QUALIFIED of string * Path
	      	| IDENT of Ident
	      	
  datatype BinOp = ADD | SUB | MUL | DIV | POW
  datatype UnaryOp = UMINUS | UPLUS
  datatype LBinOp = AND | OR
  datatype LUnaryOp = NOT
  datatype RelOp = LESS | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  datatype Exp = NUMBER of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       
	       | BINARY of Exp * BinOp * Exp
	       | UNARY of UnaryOp * Exp
	       
	       | LBINARY of Exp * LBinOp * Exp
	       | LUNARY of LUnaryOp * Exp
	       
	       | RELATION of Exp * RelOp * Exp
	       
	       | IFEXP of Exp * Exp * Exp
	       
	       | CALL of Path * Exp list		(* Function call *)
	       | TIME
		  
  relation path_string : Path => string
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation eq_cref : (ComponentRef, ComponentRef) => ()
  
end

(**********************************************************************
 * Constant evaluation
 **********************************************************************)

relation ceval : Exp => Exp =

  axiom	ceval (x as NUMBER(_)) => x
  axiom ceval (x as STRING(_)) => x
  axiom ceval (x as BOOL(_)) => x

  rule	ceval_cref c => exp
	-------------------
	ceval CREF(c) => exp

	(* Numerical *)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval BINARY(lh, ADD, rh) => NUMBER(sum)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_sub(lhv, rhv) => diff
	-------------------------
	ceval BINARY(lh, SUB, rh) => NUMBER(diff)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_mul(lhv, rhv) => prod
	-------------------------
	ceval BINARY(lh, MUL, rh) => NUMBER(prod)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_div(lhv, rhv) => quot
	--------------------------
	ceval BINARY(lh, DIV, rh) => NUMBER(quot)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_pow(lhv, rhv) => pow
	-------------------------
	ceval BINARY(lh, POW, rh) => NUMBER(pow)

  rule	ceval rh => NUMBER(rhv) &
	real_neg(rhv) => rhv'
	-------------------------
	ceval UNARY(UMINUS, rh) => NUMBER(rhv')

  rule	ceval rh => NUMBER(rhv)
	-----------------------
	ceval UNARY(UPLUS, rh) => NUMBER(rhv)

	(* Boolean *)

  rule	ceval lh => BOOL(lhv) &
	ceval rh => BOOL(rhv) &
	bool_and(lhv, rhv) => con
	-------------------------
	ceval LBINARY(lh, AND, rh) => BOOL(con)

  rule	ceval lh => BOOL(lhv) &
	ceval rh => BOOL(rhv) &
	bool_or(lhv, rhv) => disj
	-------------------------
	ceval LBINARY(lh, OR, rh) => BOOL(disj)

  rule	ceval rh => BOOL(rhv) &
	bool_not rhv => rhv'
	--------------------
	ceval LUNARY(NOT, rh) => BOOL(rhv')

	(* Relations *)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_lt(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, LESS, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_le(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, LESSEQ, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_gt(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, GREATER, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_ge(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, GREATEREQ, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_eq(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, EQUAL, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_ne(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, NEQUAL, rh) => BOOL(b)

end

and ceval_cref : ComponentRef => Exp =

  rule	print "# ceval_cref\n"
	----------------------
	ceval_cref c => fail

end

(**********************************************************************)

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref([], i, s) => [(i,s)]

  rule	extend_cref(xs, i, s) => xs'
	----------------------------
	extend_cref(x::xs, i, s) => x::xs'

end

relation eq_subscript : (Subscript, Subscript) => () =

  axiom	eq_subscript(NOSUB,NOSUB)

	(* FIXME *)
  rule	ceval s1 => v1 &
	ceval s2 => v2 &
	v1 = v2
	-------------------------------
	eq_subscript(SUB1(s1),SUB1(s2))

end

relation eq_subscripts : (Subscript list, Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

relation eq_cref : (ComponentRef, ComponentRef) => () =

  axiom	eq_cref([],[])

  rule	n1 = n2 &
	eq_subscripts(s1,s2) &
	eq_cref(c1,c2)
	-------------------
	eq_cref((n1,s1)::c1, (n2,s2)::c2)

end
