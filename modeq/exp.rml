(**
 ** file:	 exp.rml
 ** description: Expressions
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing Modelica expressions.  It is used throughout the
 ** semantic description, in the abstract syntax tree and elsewhere.
 ** All the other modules use this module.
 ** 
 **)

module Exp:

  with "absyn.rml"

  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  datatype BinOp = INT_ADD | REAL_ADD | STRING_ADD
		 | INT_SUB | REAL_SUB
		 | INT_MUL | REAL_MUL
		 | INT_ARRAY_SCALAR_MUL of int
		 | REAL_ARRAY_SCALAR_MUL of int
		 | REAL_DIV
		 | REAL_POW
  datatype UnaryOp = UMINUS | UPLUS
  datatype LBinOp = AND | OR
  datatype LUnaryOp = NOT
  datatype RelOp = INT_LESS      | REAL_LESS
		 | INT_LESSEQ    | REAL_LESSEQ
		 | INT_GREATER   | REAL_GREATER
		 | INT_GREATEREQ | REAL_GREATEREQ
		 | INT_EQUAL     | REAL_EQUAL  | BOOL_EQUAL  | STRING_EQUAL
		 | INT_NEQUAL    | REAL_NEQUAL | BOOL_NEQUAL | STRING_NEQUAL
  
  (** - Expressions *)
  datatype Exp = ICONST of int
	       | RCONST of real
	       | SCONST of string
	       | BCONST of bool
	       | CREF of ComponentRef
	       | BINARY of Exp * BinOp * Exp
	       | UNARY of UnaryOp * Exp
	       | LBINARY of Exp * LBinOp * Exp
	       | LUNARY of LUnaryOp * Exp
	       | RELATION of Exp * RelOp * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of Absyn.Path * Exp list		(* Function call *)
	       | ARRAY of Exp list
	       | MATRIX of Exp list list
	       | RANGE of Exp * Exp option * Exp
                 (* New constructors *)
	       | CAST_TO_REAL of Exp
	       | ASUB of Exp * int
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp' *)
  (** datatype, but is used for statically analyzed expressions.  It *)
  (** includes explicit type promotions and typed (non-overloaded) *)
  (** operators. *)

  (** - Component references *)
  datatype Subscript = NOSUB
		     | SLICE of Exp
		     | INDEX of Exp

  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)
  (** the `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Exp' module. *)

  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation int_subscripts : int list => Subscript list
  relation simplify : Exp => Exp

end

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **)

(*!ignorecode*)
 
(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref CREF_IDENT(s,subs)

  rule	print_component_ref2 (s,subs) &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)
end

relation print_component_ref2 =

  rule	print s
	-------
	print_component_ref2 (s,[])

  rule	print s &
	print "[" & print_list(l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** relation: print_subscript
 **
 ** Print a `Subscript'.
 **)

relation print_subscript: Subscript => () =
	
  rule	print ":"
	---------
	print_subscript(NOSUB)
	
  rule	print_exp(e1)
	-------------
	print_subscript(INDEX(e1))
	
  rule	print_exp(e1)
	-------------
	print_subscript(SLICE(e1))
	
end

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp: Exp => () =

  rule	print_exp2 (e,0)
	----------------
	print_exp e

end

relation print_exp2: (Exp,int) => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp2(ICONST(x),_)

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp2(RCONST(x),_)

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp2(SCONST(s),_)

  rule	print "false"
	-------------
	print_exp2(BCONST(false),_)

  rule	print "true"
	-------------
	print_exp2(BCONST(true),_)

  rule	print_component_ref(c)
	---------------------
	print_exp2(CREF(c),_)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & print sym & print_exp2 (e2,pri3) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op, e2),pri1)

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------
	print_exp2(UNARY(op, e),pri1)

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & print sym & print_exp2 (e2,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------------------------------------------
	print_exp2(LBINARY(e1, op, e2),pri1)

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	---------------------------------------------------
	print_exp2(LUNARY(op, e),pri1)

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print_exp2(e1,pri3) & print sym & print_exp2(e2,pri3) &
	print_rightpar(pri1,pri2)
	-----------------------------------------------------------------
	print_exp2(RELATION(e1, op, e2),pri1)

  rule	print "if " & print_exp2(c,0) &
	print " then " & print_exp2(t,0) &
	print " else " & print_exp2(f,0)
	----------------------------
	print_exp2(IFEXP(c,t,f),_)

  rule	Absyn.path_string(fcn) => fs &
	print fs & print "(" & print_list(args,print_exp,",") & print ")"
	---------------------------------------------
	print_exp2(CALL(fcn, args),_)

  rule	print "[" &
	print_list(es, print_exp, ",") &
	print "]"
	---------
	print_exp2 (ARRAY(es),_)
	
  rule	print "[" &
	print_list(es, print_row, ";") &
	print "]"
	---------
	print_exp2 (MATRIX(es),_)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & print ":" & print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------------------------------------------
	print_exp2 (RANGE(start,NONE,stop),pri1)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & print ":" &
	print_exp2 (step,pri3) & print ":" &
 	print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------
	print_exp2 (RANGE(start,SOME(step),stop),pri1)

  rule	print "Real(" & print_exp e & print ")"
	---------------------------------------
	print_exp2 (CAST_TO_REAL(e),_)

  rule	let pri2 = 51 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e,pri3) &
 	print_rightpar(pri1,pri2) &
 	print "[" &
 	int_string i => s & print s & print "]"
	---------------------------------------
	print_exp2 (ASUB(e,i),pri1)
	
  rule	print "#UNKNOWN EXPRESSION#"
        ----------------------------------
	print_exp2 (_,_)

end

relation print_leftpar : (int,int) => int =

  rule	int_gt(x,y) => true & print "("
	-----------------------
	print_leftpar(x,y) => 0

  axiom	print_leftpar(pri1,pri2) => pri2

end

relation print_rightpar : (int,int) => () =

  rule	int_gt(x,y) => true & print ")"
	-----------------------
	print_rightpar(x,y)

  axiom	print_rightpar(_,_)

end

(* priorities:
 *
 *   and, or				10
 *   not				11
 *   <, >, =, != etc.			21
 *   unary +, unary -			31
 *   +, -				32
 *   *					33
 *   /					34
 *   ^					35
 *   :					41
 *   []					51
 *
 *)

relation binop_priority : BinOp => int =
  axiom	binop_priority(INT_ADD)    	      	 => 32
  axiom	binop_priority(REAL_ADD)   	      	 => 32
  axiom	binop_priority(STRING_ADD) 	      	 => 32
  axiom	binop_priority(INT_SUB)    	      	 => 32
  axiom	binop_priority(REAL_SUB)   	      	 => 32
  axiom	binop_priority(INT_MUL)    	      	 => 32
  axiom	binop_priority(REAL_MUL)   	      	 => 33 
  axiom	binop_priority(INT_ARRAY_SCALAR_MUL(_))  => 33
  axiom	binop_priority(REAL_ARRAY_SCALAR_MUL(_)) => 33
  axiom	binop_priority(REAL_DIV)   	      	 => 34
  axiom	binop_priority(REAL_POW)   	      	 => 35      
end

relation unaryop_priority : UnaryOp => int =
  axiom	unaryop_priority(UMINUS)   => 31
  axiom	unaryop_priority(UPLUS)    => 31
end

relation lbinop_priority : LBinOp => int =
  axiom	lbinop_priority(AND) => 10
  axiom	lbinop_priority(OR) => 10
end

relation lunaryop_priority : LUnaryOp => int =
  axiom	lunaryop_priority(NOT) => 11
end

relation relop_priority : RelOp => int =
  axiom	relop_priority(INT_LESS)       => 21
  axiom	relop_priority(REAL_LESS)      => 21
  axiom	relop_priority(INT_LESSEQ)     => 21
  axiom	relop_priority(REAL_LESSEQ)    => 21
  axiom	relop_priority(INT_GREATER)    => 21
  axiom	relop_priority(REAL_GREATER)   => 21
  axiom	relop_priority(INT_GREATEREQ)  => 21
  axiom	relop_priority(REAL_GREATEREQ) => 21
  axiom	relop_priority(INT_EQUAL)      => 21
  axiom	relop_priority(REAL_EQUAL)     => 21
  axiom	relop_priority(STRING_EQUAL)   => 21
  axiom	relop_priority(BOOL_EQUAL)     => 21
  axiom	relop_priority(INT_NEQUAL)     => 21
  axiom	relop_priority(REAL_NEQUAL)    => 21
  axiom	relop_priority(STRING_NEQUAL)  => 21
  axiom	relop_priority(BOOL_NEQUAL)    => 21
end

(**)

relation binop_symbol : BinOp => string =
  axiom	binop_symbol(INT_ADD) => " + "
  axiom	binop_symbol(REAL_ADD) => " + "
  axiom	binop_symbol(STRING_ADD) => " + "
  axiom	binop_symbol(INT_SUB) => " - "
  axiom	binop_symbol(REAL_SUB) => " - "
  axiom	binop_symbol(INT_MUL) => " * "
  axiom	binop_symbol(REAL_MUL) => " * "
  axiom	binop_symbol(REAL_DIV) => " / "
  axiom	binop_symbol(REAL_POW) => " ^ "

  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "

end

relation unaryop_symbol : UnaryOp => string =
  axiom	unaryop_symbol(UMINUS) => "-"
  axiom	unaryop_symbol(UPLUS) => "+"
end

relation lbinop_symbol : LBinOp => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol : LUnaryOp => string =
  axiom	lunaryop_symbol(NOT) => "NOT "
end

relation relop_symbol : RelOp => string =
  axiom	relop_symbol(INT_LESS)       => " < "
  axiom	relop_symbol(REAL_LESS)      => " < "
  axiom	relop_symbol(INT_LESSEQ)     => " <= "
  axiom	relop_symbol(REAL_LESSEQ)    => " <= "
  axiom	relop_symbol(INT_GREATER)    => " > "
  axiom	relop_symbol(REAL_GREATER)   => " > "
  axiom	relop_symbol(INT_GREATEREQ)  => " >= "
  axiom	relop_symbol(REAL_GREATEREQ) => " >= "
  axiom	relop_symbol(INT_EQUAL)      => " = "
  axiom	relop_symbol(REAL_EQUAL)     => " = "
  axiom	relop_symbol(STRING_EQUAL)   => " = "
  axiom	relop_symbol(BOOL_EQUAL)     => " = "
  axiom	relop_symbol(INT_NEQUAL)     => " <> "
  axiom	relop_symbol(REAL_NEQUAL)    => " <> "
  axiom	relop_symbol(STRING_NEQUAL)  => " <> "
  axiom	relop_symbol(BOOL_NEQUAL)    => " <> "
end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(**)

relation print_row : Exp list =>() =

  rule	print_list(es,print_exp,",")
	----------------------------
	print_row es

end

(** relation: int_subscripts
 **
 ** This relation describes the relation between a list of integers
 ** and a list of `Exp.Subscript' where each integer is converted to
 ** an integer indexing expression.
 **)

relation int_subscripts : int list => Subscript list =

  axiom	int_subscripts [] => []

  rule	int_subscripts xs => xs'
	------------------------
	int_subscripts x::xs => INDEX(ICONST(x))::xs'

end

(** relation: simplify
 **
 ** This relation does some very basic simplification on expressions.
 ** It is not intended to be used to simplify expressions provided by
 ** the model, but to simplify unnecessarily complex expressions
 ** constructed during instantiation.
 **)

relation simplify : Exp => Exp =

  rule	int_sub (i,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify ASUB(ARRAY(exps),i) => exp

  axiom	simplify e => e

end
