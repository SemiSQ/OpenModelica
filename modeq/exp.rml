(**
 ** file:  exp.rml
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing Modelica expressions.  It is used throughout the
 ** semantic description, in the abstract syntax tree and elsewhere.
 ** All the other modules use this module.
 ** 
 **)

module Exp:

  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  (** - Types *)
  datatype Type = T_INTEGER | T_REAL | T_STRING | T_BOOL | T_OTHER
  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types. *)

  (** - Subscripts *)
  datatype Subscript = NOSUB
		     | SUB1 of Exp
		     | SUB2 of Exp * Exp
		     | SUB3 of Exp * Exp * Exp
  (** The `Subscript' datatype is used in variable references.  An *)
  (** one-dimensional array variable `a' can be supscriptet as `a[1]', *)
  (** `a[1:2]' or `a[1:2:3]'. *)

  (** - Component references and paths *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Path = QUALIFIED of Ident * Path
	      	| IDENT of Ident
  (** A component reference is the fully or partially qualified name of *)
  (** a component (variable).  It is represented as a list of *)
  (** identifier--subscript pairs.  The type `Path', on the other hand, *)
  (** is used to store references to class names, or components inside *)
  (** class definitions. *)
	      	
  (** - Expressions *)
  datatype BinOp = ADD | SUB | MUL | DIV | POW
  datatype UnaryOp = UMINUS | UPLUS
  datatype LBinOp = AND | OR
  datatype LUnaryOp = NOT
  datatype RelOp = LESS | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  datatype Exp = INTEGER of int
	       | REAL of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       | BINARY of Exp * BinOp * Exp
	       | UNARY of UnaryOp * Exp
	       | LBINARY of Exp * LBinOp * Exp
	       | LUNARY of LUnaryOp * Exp
	       | RELATION of Exp * RelOp * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of Path * Exp list		(* Function call *)
	       | TIME
	       | CAST_TO_REAL of Exp
  (** The `Exp' datatype is the container of a Modelica expression. *)

  relation path_string : Path => string
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation eq_cref : (ComponentRef, ComponentRef) => ()

  relation dump_exp: Exp => ()
  relation dump_component_ref : ComponentRef => ()
  relation print_type : Type => ()
  
end

(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (ComponentRef, ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (CREF_IDENT(n1,s1), CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (CREF_QUAL(n1,s1,c1), CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Subscript list, Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Subscript, Subscript) => () =

  axiom	eq_subscript(NOSUB,NOSUB)
 	
 	(* FIXME: this is not complete at all *)
  rule	s1 = s2
	-------------------------------
	eq_subscript(SUB1(s1),SUB1(s2))
	
  rule	print "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **
 ** relation: dump_exp
 **
 ** This relation prints a complete expression.
 **)

relation dump_exp: Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	dump_exp(INTEGER(x))

  rule	real_string(x) => s & print s
	-----------------------------
	dump_exp(REAL(x))

  rule	dump_component_ref(c)
	---------------------
	dump_exp(CREF(c))

  rule	print "\"" & print s & print "\""
	---------------------------------
	dump_exp(STRING(s))

  rule	print "FALSE"
	-------------
	dump_exp(BOOL(false))

  rule	print "TRUE"
	-------------
	dump_exp(BOOL(true))

  rule	binop_symbol(op) => sym & dump_exp e1 & print sym & dump_exp e2
	---------------------------------------------------------------
	dump_exp(BINARY(e1, op, e2))

  rule	unaryop_symbol(op) => sym &
	print sym & dump_exp e
	----------------------------
	dump_exp(UNARY(op, e))

  rule	lbinop_symbol(op) => sym & dump_exp e1 & print sym & dump_exp e2
	----------------------------------------------------------------
	dump_exp(LBINARY(e1, op, e2))

  rule	lunaryop_symbol(op) => sym & print sym & dump_exp e
	---------------------------------------------------
	dump_exp(LUNARY(op, e))

  rule	relop_symbol(op) => sym & dump_exp(e1) & print sym & dump_exp(e2)
	-----------------------------------------------------------------
	dump_exp(RELATION(e1, op, e2))

  rule	print "IF " & dump_exp(c) &
	print " THEN " & dump_exp(t) &
	print " ELSE " & dump_exp(f)
	----------------------------
	dump_exp(IFEXP(c,t,f))

  rule	path_string(fcn) => fs &
	print fs & print "(" & dump_list(args,dump_exp,",") & print ")"
	---------------------------------------------
	dump_exp(CALL(fcn, args))

  rule	print "TIME"
	------------------
	dump_exp(TIME)

  rule	print "real(" & dump_exp(e) & print ")"
	----------------------------------------
	dump_exp CAST_TO_REAL(e)

  rule	print "#UNKNOWN EXPRESSION#"
        ----------------------------------
	dump_exp (_)
end

(** relation: dump_list
 **
 ** This is a utility relation that prints a list of objects using a
 ** provided relation that does the printing of each list element.
 **)

relation dump_list : ('a list, 'a => (), string) => () =

  axiom	dump_list([],_,_)

  rule	r(h)
	------------------
	dump_list([h],r,_)

  rule	r(h) & print sep & dump_list(t,r,sep)
	-------------------------------------
	dump_list(h::t,r,sep)
end

(** relation: *_symbol
 **
 ** Make a string describing different operators.
 **)

relation binop_symbol: BinOp => string =
  axiom	binop_symbol(ADD) => " + "
  axiom	binop_symbol(SUB) => " - "
  axiom	binop_symbol(MUL) => "*"
  axiom	binop_symbol(DIV) => "/"
  axiom	binop_symbol(POW) => "^"
end

relation unaryop_symbol: UnaryOp => string =
  axiom	unaryop_symbol(UMINUS) => "-"
  axiom	unaryop_symbol(UPLUS) => "+"
end

relation lbinop_symbol: LBinOp => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol: LUnaryOp => string =
  axiom	lunaryop_symbol(NOT) => "NOT "
end

relation relop_symbol: RelOp => string =
  axiom	relop_symbol(LESS)      => " < "
  axiom	relop_symbol(LESSEQ)    => " <= "
  axiom	relop_symbol(GREATER)   => " > "
  axiom	relop_symbol(GREATEREQ) => " >= "
  axiom	relop_symbol(EQUAL)     => " == "
  axiom	relop_symbol(NEQUAL)    => " <> "
end

(** relation: dump_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation dump_component_ref : ComponentRef => () =

  rule	dump_component_ref2 (s,subs)
	----------------------------
	dump_component_ref CREF_IDENT(s,subs)

  rule	dump_component_ref2 (s,subs) &
	print "." &
	dump_component_ref cr
	---------------------
	dump_component_ref CREF_QUAL(s,subs,cr)
end

and dump_component_ref2 =

  rule	print s
	-------
	dump_component_ref2 (s,[])

  rule	print s &
	print "[" & dump_list(l,dump_subscript,",") & print "]"
	-------------------------------------------------------
	dump_component_ref2 (s,l)

end

and dump_subscript: Subscript => () =

  rule	print ":"
	---------
	dump_subscript(NOSUB)

  rule	dump_exp(e1)
	----------
	dump_subscript(SUB1(e1))

  rule	dump_exp(e1) & print ":" & dump_exp(e2)
	-------------
	dump_subscript(SUB2(e1,e2))

  rule	dump_exp(e1) & print ":" &
	dump_exp(e2) & print ":" & dump_exp(e3)
	----------------------------------------------
	dump_subscript(SUB3(e1,e2,e3))

end

(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `complex'.
 **)

relation print_type : Type => () =

  rule	print "integer"
	---------------
	print_type T_INTEGER

  rule	print "real"
	------------
	print_type T_REAL

  rule	print "string"
	--------------
	print_type T_STRING

  rule	print "bool"
	------------
	print_type T_BOOL

  rule	print "complex"
	------------
	print_type T_OTHER

end
