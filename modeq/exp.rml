(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 exp.rml
 ** module:      Exp
 ** description: Expressions
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing expressions, after they have been examined by the
 ** static analyzer in the module `StaticExp'.  There are of course
 ** great similarities with the expression types in the `Absyn'
 ** module, but there are also several important differences.
 **
 ** No overloading of operators occur, and subscripts have been
 ** checked to see if they are slices.  All expressions are also type
 ** consistent, and all implicit type conversions in the AST are made
 ** explicit here.
 **)

module Exp:

  with "absyn.rml"

  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  (** - Basic types *)
  datatype Type = INT | REAL | BOOL | STRING | ENUM | OTHER 
  (** These types are not used as expression types (see the `Types'
   ** module for expression types).  They are used to parameterize
   ** operators which may work on several simple types. *)

  (** - Expressions *)
  datatype Exp = ICONST of int
	       | RCONST of real
	       | SCONST of string
	       | BCONST of bool
	       | CREF of ComponentRef * Type
	       | BINARY of Exp * Operator * Exp
	       | UNARY of Operator * Exp
	       | LBINARY of Exp * Operator * Exp
	       | LUNARY of Operator * Exp
	       | RELATION of Exp * Operator * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of Absyn.Path * Exp list * bool * bool (* Function call *)
	       | ARRAY of Type * bool * Exp list
	       | MATRIX of Type * int * (Exp*bool) list list
	       | RANGE of Type * Exp * Exp option * Exp
	       | TUPLE of Exp list (*PR.*)
                 (* New constructors *)
	       | CAST of Type * Exp
	       | ASUB of Exp * int
               | SIZE of Exp * Exp
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp'
   ** datatype, but is used for statically analyzed expressions.  It
   ** includes explicit type promotions and typed (non-overloaded)
   ** operators. It also contains expression indexing with the `ASUB'
   ** constructor.  Indexing arbitrary array expressions is currently
   ** not supported in Modelica, but it is needed here. *)
  (** LS: Added size for external function interface **)

  datatype Operator = ADD    	  of Type
		    | SUB    	  of Type
		    | MUL    	  of Type
		    | DIV    	  of Type
		    | POW    	  of Type
		    | UMINUS 	  of Type
		    | UPLUS  	  of Type
		    | UMINUS_ARR  of Type
		    | UPLUS_ARR   of Type
		    | ADD_ARR     of Type
		    | SUB_ARR     of Type
		    | MUL_SCALAR_ARRAY of Type   (* a * { b, c }            *)
		    | MUL_ARRAY_SCALAR of Type   (* {a, b} * c              *)
		    | MUL_SCALAR_PRODUCT of Type (* {a, b} * {c, d}         *)
		    | MUL_MATRIX_PRODUCT of Type (* {{..},..} * {{..},{..}} *)
		    | DIV_ARRAY_SCALAR of Type   (* {a, b} / c              *)
		    | POW_ARR     of Type
		    | AND | OR
		    | NOT
		    | LESS        of Type
		    | LESSEQ      of Type
		    | GREATER     of Type
		    | GREATEREQ   of Type
		    | EQUAL       of Type
		    | NEQUAL      of Type
  (** Operators which are overloaded in the abstract syntax are here
   ** made type-specific.  The integer addition operator (`ADD(INT)')
   ** and the real addition operator (`ADD(REAL)') are two distinct
   ** operators. *)

  (** - Component references *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Subscript = WHOLEDIM     (* a[:,1] *)
		     | SLICE of Exp (* a[1:3,1], a[1:2:10,2] *)
		     | INDEX of Exp
  (** The `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Absyn' module. *)

  (** - Exported relations *)

  relation is_range : Exp => bool

  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation int_subscripts : int list => Subscript list
  relation simplify : Exp => Exp
  relation unelab_exp : Exp => Absyn.Exp 	   
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_component_ref_str : ComponentRef => string
  relation print_subscript: Subscript => ()
  relation print_subscript_str: Subscript => string
  relation print_list : ('a list, 'a => (), string) => ()
  relation cref_equal : (ComponentRef, ComponentRef) => bool
  relation cref_str : ComponentRef => string
  relation print_list_str : ('a list, 'a => string, string) => string
  relation print_exp_str : Exp => string

end
