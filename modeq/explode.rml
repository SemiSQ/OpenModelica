(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 scode.rml
 ** module:      SCode
 ** description: SCode intermediate form
 **
 ** RCS: $Id$
 **
 ** This module contains data structures to describe a Modelica model
 ** in a more convenient way than the `Absyn' module does.  The most
 ** important relation in this module is the `elaborate' relation
 ** which turns an abstract syntax tree into an SCode representation.
 **)

module SCode :

  with "absyn.rml"

  (** Some definitions are borrowed from `Absyn' *)
  type Ident = Absyn.Ident
  type Path = Absyn.Path
  type Subscript = Absyn.Subscript
  datatype Restriction =  R_CLASS
		   | R_MODEL
		   | R_RECORD
		   | R_BLOCK
		   | R_CONNECTOR
		   | R_TYPE
		   | R_PACKAGE
		   | R_FUNCTION
		   | R_EXT_FUNCTION   (* Added c.t. Absyn *)
		   | R_ENUMERATION	
		   | R_PREDEFINED_INT
		   | R_PREDEFINED_REAL
		   | R_PREDEFINED_STRING
		   | R_PREDEFINED_BOOL
		   | R_PREDEFINED_ENUM
							  
  (** - Modifications *)
  datatype Mod = MOD of bool * (SubMod list) * (Absyn.Exp option)
  	       | REDECL of bool * Element list
	       | NOMOD
  datatype SubMod = NAMEMOD of Ident * Mod         (* A named component *)
		  | IDXMOD of Subscript list * Mod (* An array element *)
  (** Modifications are represented in an more structured way than in 
   ** the `Absyn' module.  Modifications using qualified names
   ** (such as in `x.y =  z') are normalized (to `x(y = z)').  And a
   ** special case when arrays are subscripted in a modification.
   **)

  (** - Programs *)
  type Program = Class list
  (** As in the AST, a program is simply a list of class definitions. *)

  (** - Classes *)
  datatype Class = CLASS of Ident		(* Name *)
			  * bool		(* Partial *)
			  * bool		(* Encapsulated *)
			  * Restriction	        (* Restricion *)
			  * ClassDef		(* Parts *)

  datatype ClassDef = PARTS of Element list
			     * Equation list
			     * Equation list    (* InitialEquation *)
			     * Algorithm list
			     * Algorithm list   (* InitialAlgorithm *)
                             * Absyn.ExternalDecl option  (* Used by external functions*)
		    | DERIVED of Path
			       * Absyn.ArrayDim option
			       * Mod
		    | ENUMERATION of Ident list

  (** The major difference between these types and their `Absyn' *)
  (** counterparts is that the `PARTS' constructor contains separate *)
  (** lists for elements, equations and algorithms. *)


  (* - Equations *)
  datatype Equation = EQ_EXPR of Absyn.Exp	(* more later? *)
		    | EQ_IF of Absyn.Exp	(* conditional *)
			     * Equation list	(* true branch *)  
			     * Equation list	(* false branch *)
		    | EQ_EQUALS of Absyn.Exp * Absyn.Exp
		    | EQ_CONNECT of Absyn.ComponentRef * Absyn.ComponentRef
		    | EQ_FOR of Ident * Absyn.Exp * Equation list
		    | EQ_WHEN of Absyn.Exp * Equation list
  (** These are almost identical to the `Absyn' versions.  In `EQ_IF', *)
  (** the `elseif' branches are represented as normal `else' branches *)
  (** with a single `if' statement in them. *)

  (** - Algorithms *)
  datatype Algorithm = ALGORITHM of Absyn.Algorithm list
  (** The `Absyn' module uses the terminology from the grammar, where *)
  (** `algorithm' means an algorithmic statement.  But here, *)
  (** `Algorithm' means a whole algorithm section. *)

  (** - Elements *)
  datatype Element = EXTENDS of Path * Mod
		   | CLASSDEF of Ident		(* name *)
			       * bool		(* final *)
			       * bool		(* replaceable *)
			       * Class
		   | IMPORT    of Absyn.Import
		   | COMPONENT of Ident		(* component name *)
				* bool		(* final *)
				* bool		(* replaceable *)
				* bool		(* protected *)
				* Attributes
				* Path		(* type name *)
				* Mod
  (** There are three types of elements in a declaration, represented *)
  (** by the constructors `EXTENDS' (for `extends' clauses), *)
  (** `CLASSDEF' (for local class definitions) and `COMPONENT' (for *)
  (** local variables). *)

  (** - Attributes *)
  datatype Attributes = ATTR of Absyn.ArrayDim
			      * bool	(* flow *)
			      * Accessibility
	  		      * Absyn.Variability	(* parameter *)
			      * Absyn.Direction
			   
  datatype Accessibility = RW	(* read/write *)
			 | RO	(* read-only *)
			 | WO	(* write-only (not used) *)
  (** These are attributes that apply to a declared component. *)

  relation elaborate : Absyn.Program => Program
  relation elab_class: Absyn.Class => Class	
  relation build_mod : (Absyn.Modification option, bool) => Mod
  relation get_element_named: (Ident, Class) => Element
  relation print_mod : Mod => ()
  relation print_element : Element => ()
  relation print_element_list : Element list => ()	  
  relation print_restr: Restriction => ()
	  
end
