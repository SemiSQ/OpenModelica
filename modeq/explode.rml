(**
 ** file:	 scode.rml
 ** description: SCode intermediate form
 **
 ** RCS: $Id$
 **
 **)

module SCode :

  with "absyn.rml"

  type Ident = Absyn.Ident
  type Path = Absyn.Path
  type Subscript = Absyn.Subscript
  type Restriction = Absyn.Restriction

  datatype SubMod = NAMEMOD of Ident * Mod
		  | IDXMOD of Subscript list * Mod
  and Mod = MOD of bool * (SubMod list) * (Absyn.Exp option)
  	  | REDECL of bool * Absyn.ElementSpec
	  | NOMOD

  type Program = Class list

  (** - Classes *)
  datatype Class = CLASS of Ident		(* Name *)
			  * bool		(* Partial *)
			  * Restriction	        (* Restricion *)
			  * ClassDef		(* Parts *)
  (* FIXME: should the name really be part of the class type? *)

  datatype ClassDef = PARTS of Element list
			     * Equation list
			     * Algorithm list
		    | DERIVED of Path
			       * Absyn.ArrayDim option
			       * Mod

  (* - Equations *)
  datatype Equation = EQ_EXPR of Absyn.Exp	(* more later? *)
		    | EQ_IF of Absyn.Exp	(* conditional *)
			     * Equation list	(* true branch *)  
			     * Equation list	(* false branch *)
		    | EQ_EQUALS of Absyn.Exp * Absyn.Exp
		    | EQ_CONNECT of Absyn.ComponentRef * Absyn.ComponentRef
		    | EQ_FOR of Ident * Absyn.Exp * Equation list

  (** - Algorithms *)
  datatype Algorithm = ALGORITHM of Absyn.Algorithm list

  (** - Elements *)
  datatype Element = EXTENDS of Path * Mod
		   | CLASSDEF of Ident		(* name *)
			       * bool		(* final *)
			       * bool		(* replaceable *)
			       * Class
		   | COMPONENT of Ident		(* component name *)
				* bool		(* final *)
				* bool		(* protected *)
				* Attributes
				* Path		(* type name *)
				* Mod
  (** There are three types of elements in a declaration, represented *)
  (** by the constructors `EXTENDS' (for `extends' clauses), *)
  (** `CLASSDEF' (for local class definitions) and `COMPONENT' (for *)
  (** local variables). *)

  datatype Attributes = ATTR of Absyn.ArrayDim
			      * bool	(* flow *)
	  		      * Absyn.Variability	(* parameter *)
			      * Absyn.Direction

  relation elaborate : Absyn.Program => Program

  (* Modification handling *)
  relation build_mod : (Absyn.Modification option, bool) => Mod
  relation print_mod : Mod => ()
	  
end

with "dump.rml"

(** relation: elaborate
 **)

relation elaborate: Absyn.Program => Program =

  axiom	elaborate([]) => []

  rule	elab_class(c) => c' &
	elaborate(cs) => cs'
	-----------------------------
	elaborate(c::cs) => (c'::cs')

end

(** relation: elab_class
 **)

relation elab_class: Absyn.Class => Class =

  rule	elab_classdef d => d'
	--------------------------------------------
	elab_class(Absyn.CLASS(n,p,r,d)) => CLASS(n,p,r,d')

end

(** relation: elab_classdef
 **)

relation elab_classdef: Absyn.ClassDef => ClassDef =

  rule	build_mod(SOME(Absyn.CLASSMOD(a, NONE)), false) => mod
	------------------------------------------------
	elab_classdef(Absyn.DERIVED(p,d,a)) => DERIVED(p,d,mod)

  axiom	elab_classdef(Absyn.PARTS([])) => PARTS([],[],[])

	(* Lots of unnecessary consing ahead... *)
  rule	elab_classdef(Absyn.PARTS(ps)) => PARTS(els,eqs,als) &
	elab_equations(l) => l' &
	list_append(eqs,l') => eqs'
	------------------------------
	elab_classdef(Absyn.PARTS(Absyn.EQUATIONS(l)::ps))
	  => PARTS(els,eqs',als)

  rule	elab_classdef(Absyn.PARTS(ps)) => PARTS(els,eqs,als) &
	let als' = ALGORITHM(l)::als
	----------------------------
	elab_classdef(Absyn.PARTS(Absyn.ALGORITHMS(l)::ps))
	  => PARTS(els,eqs,als')

  rule	elab_classdef(Absyn.PARTS(ps)) => PARTS(els,eqs,als) &
  	elab_elist(es,false) => es' &
	list_append(els,es') => els'
	------------------------------
	elab_classdef(Absyn.PARTS(Absyn.PUBLIC(es)::ps))
	  => PARTS(els',eqs,als)

  rule	elab_classdef(Absyn.PARTS(ps)) => PARTS(els,eqs,als) &
  	elab_elist(es,true) => es' &
	list_append(els,es') => els'
	------------------------------
	elab_classdef(Absyn.PARTS(Absyn.PROTECTED(es)::ps))
	  => PARTS(els',eqs,als)

end

(** relation: elab_elist
 **)

relation elab_elist : (Absyn.Element list, bool) => Element list =

  axiom	elab_elist([],_) => []

  rule	elab_element(e, prot) => e' &
	elab_elist(es, prot) => es' &
	list_append(e',es') => l
	---------------------
	elab_elist(e::es, prot) => l

end

(** relation: elab_element
 **)

relation elab_element : (Absyn.Element, bool) => Element list =

  rule	elab_elementspec(f,prot,s) => es
	--------------------------------
	elab_element(Absyn.ELEMENT(f,_,s), prot) => es

end

(** relation: elab_elementspec
 **)

relation elab_elementspec: (bool,bool,Absyn.ElementSpec) => Element list =

  rule	elab_classdef(de) => de'
	-----------------------
	elab_elementspec(final,prot,Absyn.CLASSDEF(rp,Absyn.CLASS(n,pa,re,de)))
	  => [CLASSDEF(n,final,rp,CLASS(n,pa,re,de'))]

  rule	build_mod(SOME(Absyn.CLASSMOD(args, NONE)), false) => mod &
	Absyn.path_string(n) => ns &
	print "extends " & print ns & print_mod mod & print "\n"
	---------------------------------------------------
	elab_elementspec(final,prot,Absyn.EXTENDS(n,args))
	  => [EXTENDS(n,mod)]

  axiom	elab_elementspec(_,_,Absyn.COMPONENTS(_,_,[])) => []

  rule	elab_elementspec(final,prot,Absyn.COMPONENTS(attr,t,xs)) => xs' &
	build_mod(m,false) => mod
	--------------------------------------------------
	elab_elementspec(final,prot,
			 Absyn.COMPONENTS(attr as Absyn.ATTR(fl,pa,di),t,
					  (Absyn.COMPONENT(n,d,m))::xs))
	  => COMPONENT(n,final,prot,ATTR(d,fl,pa,di),t,mod)::xs'

end

(** relation: elab_equations
 **)

relation elab_equations : Absyn.Equation list => Equation list =

  axiom	elab_equations [] => []

  rule	elab_equation e => e' &
	elab_equations es => es'
	------------------------
	elab_equations e::es => e'::es'

end

(** relation: elab_equation
 **
 ** The translation of equations are straightforward, with one
 ** exception.  `If' clauses are translated so that the SCode only
 ** contains simple `if'-`else' constructs, and no `elseif'.
 **)

relation elab_equation : Absyn.Equation => Equation =

  axiom	elab_equation Absyn.EQ_EXPR(e) => EQ_EXPR(e)
	
  rule	elab_equations tb => tb' &
	elab_equations fb => fb'
	------------------------
	elab_equation Absyn.EQ_IF(e,tb,[],fb) => EQ_IF(e,tb',fb')

  rule	elab_equation Absyn.EQ_IF(e,tb,[],[Absyn.EQ_IF(ee,ei,eis,fb)]) => eq
	------------------------------------------------------------------
	elab_equation Absyn.EQ_IF(e,tb,(ee,ei)::eis,fb) => eq

  axiom	elab_equation Absyn.EQ_EQUALS(e1,e2) => EQ_EQUALS(e1,e2)

  axiom	elab_equation Absyn.EQ_CONNECT(c1,c2) => EQ_CONNECT(c1,c2)

  rule	elab_equations l => l'
	----------------------
	elab_equation Absyn.EQ_FOR(i,e,l) => EQ_FOR(i,e,l')

end

(** - Modification management *)

(** relation: build_mod
 **
 ** Builds an `SCode.Mod' from an `Absyn.Modification'.  The boolean
 ** argument flags whether the modification is `final'.
 **)

relation build_mod : (Absyn.Modification option, bool) => Mod =

  axiom build_mod(NONE, _) => NOMOD

  axiom	build_mod(SOME(Absyn.CLASSMOD([], e as SOME(_))), final)
	  => MOD(final,[],e)

  rule  build_args(l) => subs
	---------------------------------
	build_mod(SOME(Absyn.CLASSMOD(l,e)),final) => MOD(final,subs,e)

end

relation build_args : (Absyn.ElementArg list) => SubMod list =

  axiom build_args [] => []

  rule  build_args xs => subs &
	build_mod(SOME(mod),final) => mod' &
	build_sub(cref,mod') => sub
	----------------------
	build_args((Absyn.MODIFICATION(final,cref,mod)::xs)) => (sub::subs)

  rule  build_args xs => subs &
	Absyn.element_spec_name spec => n
	---------------------------
	build_args((Absyn.REDECLARATION(final,spec)::xs))
	  => (NAMEMOD(n,REDECL(final,spec))::subs)

end

(** relation: build_sub
 **
 ** This relation converts a `ComponentRef' into a number of nested
 ** `SUBMOD's.
 **)

relation build_sub : (Absyn.ComponentRef,Mod) => SubMod =

	(* First some rules to prevent bad modifications *)

  rule	print "# Illegal modification of " & Dump.print_component_ref c &
	Dump.print_component_ref c & print "\n"
	---------------------------------------
	build_sub(c as Absyn.CREF_IDENT(_,_::_),MOD(_,_::_,_)) => fail

  rule  print "# Illegal modification of " &
	Dump.print_component_ref c & print "\n"
	---------------------------------------
	build_sub(c as Absyn.CREF_QUAL(_,_::_,_),MOD(_,_::_,_)) => fail
	
	(* Then the normal rules *)
	
  rule	build_sub_sub (ss,mod) => mod'
	------------------------------
	build_sub(Absyn.CREF_IDENT(i,ss),mod) => NAMEMOD(i,mod')

  rule  build_sub(path,mod) => sub &
	let mod = MOD(false,[sub],NONE) &
	build_sub_sub(ss,mod) => mod'
	--------------------------
	build_sub(Absyn.CREF_QUAL(i,ss,path),mod) => NAMEMOD(i,mod')

end

(** relation: build_sub_sub *)

relation build_sub_sub : (Subscript list, Mod) => Mod =

  axiom	build_sub_sub ([], m) => m
  axiom	build_sub_sub (l, m) => MOD(false(*FIXME*),[IDXMOD(l,m)],NONE)

end

(** relation: print_mod *)

relation print_mod : Mod => () =

  axiom	print_mod(NOMOD)

  rule  print "(redeclared)"
	------------------------------
	print_mod REDECL(_,_)
	
  rule	print_final final &
	print_subs1 subs &
	print_eqmod ass
	------------
	print_mod MOD(final, subs, ass)

end

(**)

relation print_final : bool => () =

  axiom print_final false

  rule print " final "
       --------------
       print_final true

end

relation print_subs : SubMod list => () =

  axiom print_subs []

  rule  print n & print_mod mod
	-----------------------
	print_subs [NAMEMOD(n,mod)]

  rule  print n & print_mod mod & print ", " &
	print_subs subs
	---------------
	print_subs NAMEMOD(n,mod)::subs

  rule  Dump.print_subscripts ss & print_mod mod
	------------------
	print_subs [IDXMOD(ss,mod)]

  rule  Dump.print_subscripts ss & print_mod mod & print ", " &
	print_subs subs
	--------------
	print_subs IDXMOD(ss,mod)::subs

end

relation print_subs1 : SubMod list => () =

  axiom print_subs1 [] => ()

  rule	print "(" &
	print_subs l &
	print ")"
	-----------
	print_subs1 l

end

relation print_eqmod : Absyn.Exp option => () =

  axiom print_eqmod NONE

  rule  print " = " & Dump.print_exp e
	-----------------------------
	print_eqmod SOME(e)

end
	
