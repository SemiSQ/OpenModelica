Appendix B.1. Modelica Syntax

The following syntactic meta symbols are used (extended BNF):

     [ ]  optional
     { }  repeat zero or more times

The following lexical units are defined:

     IDENT = // Identifiers have the same definition as in Java

     STRING = // String constant as in C, except note below.

     UNSIGNED_NUMBER = // Decimal number notation

String constant concatenation "a" "b" becoming "ab" is replaced by the "+"
operator in Modelica.

Modelica uses the same comment syntax as C++ and Java. Inside a comment, the
sequence <HTML> .... </HTML> indicates HTML code which may be used by tools
to facilitate model documentation.

Keywords and built-in operators of the Modelica language are written in bold
face.


Model definition

     model_definition:
        {  [ final ] class_definition ";" | import STRING ";" }

Class definition

     class_definition :
        [ partial ]
        ( class | model | record | block | connector | type |
          package | function )
        IDENT comment
        ( composition end IDENT |
          "=" name [ array_dimensions ] [ class_modification ] )

     composition  :
        element_list
        { public element_list |
          protected element_list |
          equation_clause |
          algorithm_clause
        }
        [ external ]

     element_list :
        { element ";" | annotation  ";" }

     element :
        [ final ] ( [ replaceable ] class_definition | extends_clause |
                    component_clause )

Extends

     extends_clause :
        extends name [ array_subscripts ] [ class_modification ]

Component clause

     component_clause:
        type_prefix type_specifier component_list

     type_prefix :
        [ flow ] [ discrete | parameter | constant ] [ input | output ]

     type_specifier :
        name

     component_list :
        component_declaration { "," component_declaration }

     component_declaration :
        declaration comment

     declaration :
        IDENT [ array_subscripts ] [ modification ]

Modification

     modification :
        class_modification [ "=" expression ]
      | "=" expression


     class_modification :
        "(" { argument_list } ")"

     argument_list :
        argument { "," argument }

     argument :
        element_modification
      | element_redeclaration

     element_modification :
        [ final ] component_reference modification

     element_redeclaration :
        redeclare [ final ]
        ( [ replaceable ] class_definition | extends_clause | component_clause1 )

     component_clause1 :
        type_prefix type_specifier component_declaration

Equations

     equation_clause :
       equation { equation ";" | annotation  ";" }

     algorithm_clause :
        algorithm { algorithm ";" | annotation  ";" }

     equation :
       ( range_expression "=" expression
         | conditional_equation_e
         | for_clause_e
         | connect_clause )
       comment

     algorithm :
       ( component_reference ( ":=" expression | function_call )
         | conditional_equation_a
         | for_clause_a
         | while_clause
         | when_clause )
       comment

     conditional_equation_e :
        if expression then
          { equation ";" }
        { elseif expression then
          { equation ";" }
        }
        [ else
          { equation ";" }
        ]
        end if

     conditional_equation_a :
        if expression then
          { algorithm ";" }
        { elseif expression then
          { algorithm ";" }
        }
        [ else
          { algorithm ";" }
        ]
        end if

     for_clause_e :
       for IDENT in expression loop
          { equation ";" }
       end for

     for_clause_a :
       for IDENT in expression loop
          { algorithm ";" }
       end for

     while_clause :
       while expression loop
         { algorithm ";" }
       end while

     when_clause :
       when expression do
         { algorithm ";" }
       end when

     connect_clause :
       connect "(" connector_ref "," connector_ref ")"

     connector_ref :
       IDENT [ subscripts ] [ "." IDENT [ subscripts ] ]

Expressions

     expression :
        range_expression
      | if expression then expression else expression

     range_expression :
        simple_expression [ ":" simple_expression [ ":" simple_expression ] ]

     simple_expression :
        logical_term { or logical_term }

     logical_term :
        logical_factor { and logical_factor }

     logical_factor :
        [ not ] relation

     relation :
        arithmetic_expression [ rel_op arithmetic_expression ]

     rel_op :
        "<" | "<=" | ">" | ">=" | "==" | "<>"

     arithmetic_expression :
        [ add_op ] term { add_op term }

     add_op :
        "+" | "-"

     term :
        factor { mul_op factor }

     mul_op :
        "*" | "/"

     factor :
        primary [ "^" primary ]

     primary :
        UNSIGNED_NUMBER
      | STRING
      | false
      | true
      | component_reference [ function_call ]
      | "(" expression ")"
      | "[" row_expression { ";" row_expression } "]"

     name :
        IDENT [ "." name ]

     component_reference :
        IDENT [ array_subscripts ] [ "." component_reference ]

     function_call :
        "(" [ function_arguments ] ")"

     function_arguments :
        expression { "," expression }
      | IDENT "=" expression { "," IDENT "=" expression }

     row_expression :
        expression { "," expression }

     array_subscripts :
        "[" subscript { "," subscript } "]"

     subscript :
        ":" | expression

     comment :
        [ STRING { "+" STRING } ] [ annotation ]

     annotation :
        annotation class_modification

