(*
    Copyright PELAB, Linkoping University
 
    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 inst.rml
 ** module:      Inst
 ** description: Model instantiation
 **
 ** RCS: $Id$
 **
 ** This module exports only one relation. Not true anymore...
 **)

(** debug flags: inst *)

module Inst:
  with "classinf.rml"
  with "connect.rml"
  with "dae.rml"
  with "debug.rml"
  with "env.rml"
  with "exp.rml"
  with "explode.rml"
  with "mod.rml"
  with "prefix.rml"
  with "types.rml"

  type InstDims = Exp.Subscript list

  datatype DimExp = DIMINT of int
		  | DIMEXP of Exp.Subscript * Exp.Exp option

  relation instantiate: SCode.Program => DAE.DAElist
  
  relation make_binding : (Env.Env, SCode.Attributes, Mod.EqMod option)
	  => Types.Binding

  relation instantiate_class : (SCode.Program,SCode.Path) => DAE.DAElist

  relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env 
	
  relation inst_class: (Env.Env, Mod.Mod, Prefix.Prefix, 
			Connect.Sets, SCode.Class, InstDims)
	  => (DAE.Element list, Connect.Sets, Types.Type, ClassInf.State)


  relation inst_class_decl : (Env.Env, Mod.Mod, Prefix.Prefix,
			      Connect.Sets, SCode.Class, InstDims)
	  => (Env.Env, DAE.Element list)

  relation inst_class_in: (Env.Env, Mod.Mod, Prefix.Prefix, 
			   Connect.Sets, ClassInf.State,
			   SCode.Class, bool, InstDims)
	  => (DAE.Element list, Env.Env, Connect.Sets, 
	      ClassInf.State, Types.Var list)
  relation inst_record_constructor_elt : (Env.Env, SCode.Element) 
	 => (Types.Var)
  relation mktype : (ClassInf.State,Types.Var list) => Types.Type

  relation init_vars_modelica_output : DAE.Element list => DAE.Element list

  relation new_ident : () => Exp.ComponentRef
	
end

(** Other modules used by this module *)

with "absyn.rml"
with "algorithm.rml"
with "builtin.rml"
with "dump.rml"
with "lookup.rml"
with "modutil.rml"
with "rtopts.rml"
with "staticexp.rml"
with "values.rml"


(**
 ** These type aliases are introduced to make the code a little more
 ** readable.
 **)

type Prefix = Prefix.Prefix
type Mod = Mod.Mod
type Ident = Exp.Ident
type Env = Env.Env


(** relation: new_ident
 **
 ** This relation creates a new, unique identifer.  The same name is
 ** never returned twice.
 **)

relation new_ident : () => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append("__TMP__",is) => s
	-----------------------------------------------------------------
	new_ident => Exp.CREF_IDENT(s,[])

end


(** relation: select
 **
 ** This utility relation selects one of two objects depending on a
 ** boolean variable.
 **)

relation select : (bool, 'a, 'a) => 'a =

  axiom	select (true,x,_) => x
  axiom	select (false,_,x) => x

end

(** relation: instantiate
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAElist =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l 
	-----------------------------
	instantiate(p) => DAE.DAE(l)

end


(** relation: instantiate_class
 **
 **
 ** To enable interactive instantiation, an arbitrary class in the program needs to be
 ** possible to instantiate. This relation performs the same action as `inst_program', 
 **  but given a specific class to instantiate.
 **  First all the class
 ** definitions is added to the environment without modifications, and
 ** then the specified class is instantiated in the relation `inst_class'
 **)

relation instantiate_class : (SCode.Program, SCode.Path) => DAE.DAElist =

  rule	print "# Empty program\n"
	------------------------------
	instantiate_class([],cr) => fail

  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path) => (env',dae1) &
	inst_class_in_program(env',cdecls,path) => dae
	-----------------------------
	instantiate_class(cdecls, path as Absyn.IDENT(name2)) => DAE.DAE([DAE.COMP(name2,DAE.DAE(dae))]) 

  rule	print "- inst_program failed\n" 
	------------
	instantiate_class(_,_) => fail
end

relation inst_class_in_program: (Env, SCode.Program, SCode.Path ) => (DAE.Element list) =
	
  rule	name = name2 &
	inst_class(env,Mod.NOMOD,Prefix.NOPRE,[],c,[]) => (dae,_,_,_) 
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_))::cs,Absyn.IDENT(name2)) => dae

  rule	not name = name2 &
	inst_class_in_program(env,cs,path) => dae
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_))::cs, path as Absyn.IDENT(name2)) => dae
  axiom	inst_class_in_program(env,[],_) => []

end

relation inst_class_decls:(Env, SCode.Program, SCode.Path) => ( Env.Env, DAE.Element list) =
  rule	not name = name2 &
	inst_class_decl(env,Mod.NOMOD,Prefix.NOPRE,[],c,[]) => (env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env'',dae)

  rule	name = name2 &      
	inst_class_decls(env,cs,ref) => (env', dae2)
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env',dae2)

  axiom	inst_class_decls(env,[],_) => (env,[])
end

(** relation: make_env_from_program
 ** This relation takes a `SCode.Program' and builds an environment, excluding the class in A1.
**)

relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env = 
  rule	Builtin.initial_env => env &
	add_program_to_env(env,prog,c) => env'
	--------------------------------
	make_env_from_program (prog,c) => env'
end

relation add_program_to_env: (Env.Env,SCode.Program,SCode.Path) => Env.Env =
  rule	inst_class_decls(env,p,path) => (env' ,_) 
	-----------------------------------------
	add_program_to_env (env,p,path) => env'
end


(** relation: inst_program
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'
 **)

relation inst_program : (Env, SCode.Program) => DAE.Element list =

  rule	print "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail


  rule	Debug.fprintln ("insttr", "inst_program1") &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_class(env,Mod.NOMOD,Prefix.NOPRE,[],c,[]) => (dae,csets,_,_) 
	-----------------------------
	inst_program(env,[c as SCode.CLASS(n,_,_,_)])
	  => [DAE.COMP(n,DAE.DAE(dae))]

  rule	Debug.fprintln ("insttr", "inst_program2") &
	inst_class_decl(env,Mod.NOMOD,Prefix.NOPRE,[],c,[]) => (env',dae1) &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_program(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	----------------------
	inst_program(env,c::(cs as (_::_))) => dae

  rule	print "- inst_program failed\n" 
	------------
	inst_program(_,_) => fail
end

(** relation: inst_class
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class : (Env, Mod, Prefix, Connect.Sets, SCode.Class, InstDims)
	  => (DAE.Element list, Connect.Sets, Types.Type, ClassInf.State) =

  rule	print "# Can't instantiate partial class " & print n & print "\n"
	------------------------------------------------------	
	inst_class(env,mod,pre, csets, SCode.CLASS(n,true,_,_),_) => fail

  rule	Env.open_scope(env) => env' &
	ClassInf.start(r,n) => ci_state &
	inst_class_in(env', mod, pre, csets, ci_state, c, false,inst_dims)
	  => (dae1,_,csets',ci_state', tys) &
	Connect.equations csets' => dae2 &
	list_append(dae1, dae2) => dae &
	mktype(ci_state',tys) => ty
	-------------------------------------------
	inst_class(env, mod, pre, csets, c as SCode.CLASS(n,_,r,_),inst_dims)
	  => (dae, [], ty,ci_state')

  rule	print "- inst_class " & print n & print " failed\n"
	-----------------------------------------------------
	inst_class(_,_,_,_,SCode.CLASS(n,_,_,_),_) => fail
	
end

(** relation: inst_class_in
 **
 ** This rule instantiates the contents of a class definition, with a
 ** new environment already setup.
 **)

relation inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool, InstDims)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  rule	inst_classdef(env,mods,pre,csets,ci_state,d,r,prot,inst_dims)
	  => (l,env', csets', ci_state', tys) &
	Prefix.print_prefix_str pre => prestr &
	string_append(prestr, " : ") => prestr' &
	string_append(prestr', n) => prestr'' &
	Debug.fcall ("envgraph", Env.print_env_graphviz, (env,prestr'')) &
	Debug.fprintl ("envprint", ["------------ ", prestr'', "\n"]) &
	Debug.fcall ("envprint", Env.print_env, env') & 
	Debug.fprintl ("envprint", ["------------ /", prestr'', "\n"])
	-------------------------------------
	inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,r,d), prot, inst_dims)
	  => (l,env', csets', ci_state', tys)

  rule  print "- inst_class_in failed\n"
	----------------------------------
	inst_class_in(_,_,_,csets,_,_,_,_) => fail

end

(** relation: inst_classdef
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 **)

relation inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, Absyn.Restriction, bool,InstDims)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	Prefix.print_prefix_str pre => prestr &
	Debug.fprintl ("insttr", ["inst_class parts: pre=",prestr,"\n"]) &       
	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state' &
	inst_element_list(env,mods,pre,csets,ci_state', els, inst_dims)
	  => (dae1,env', csets', ci_state'', tys) &
	inst_list(env',mods,pre,csets',ci_state'',inst_equation, eqs)
	  => (dae2,env'',csets'', ci_state''') &
	inst_list(env'',mods,pre,csets'',ci_state''', inst_algorithm, als)
	  => (dae3,env''',csets''', ci_state'''') &
	list_append(dae1,dae2) => dae5 &
	list_append(dae5,dae3) => dae 
	------------------------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,als), re, prot, inst_dims)
	  => (dae,env''', csets''', ci_state'''', tys)

	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Prefix.print_prefix_str pre => prestr &
	Absyn.path_string cn => cnstr &
	Debug.fprintl ("insttr", ["inst_class derived: ", cnstr, ", pre=",prestr,"\n"]) &
	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,r,_), cenv) &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	Mod.merge(mods,m) => mods' &
	Mod.merge(mods',mod') => mods'' &
	inst_class_in(cenv, mods'', pre, csets, new_ci_state, c,prot,inst_dims)
	  => (dae,env'', csets', ci_state', tys) &

	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, inst_dims)
	  => (dae,env'', csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn) => (_,_) &
	Absyn.path_string(cn) => cns &
	print "# unknown class: " & print cns & print "\n"
	----------------------------------------
	inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, inst_dims)
	  => fail

  rule	print "- inst_classdef failed\n"
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_,_) => fail

end	

(** relation: inst_element_list
 **
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 **)

relation inst_element_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			      SCode.Element list, InstDims)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  axiom inst_element_list(env,_,_,csets,ci_state,[],_)
	  => ([], env, csets, ci_state, [])

  rule  inst_element(env,mod,pre,csets,ci_state,el, inst_dims)
	  => (dae1,env',csets',ci_state',tys1) &
	inst_element_list(env',mod,pre,csets',ci_state',els, inst_dims)
	  => (dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae 
	------------------------------
	inst_element_list(env,mod,pre,csets,ci_state,el::els, inst_dims)
	  => (dae, env'', csets'', ci_state'', tys)

  rule	print "- inst_element_list failed\n" &
	Dump.print_list (els, SCode.print_element, ", ") &
	print "\n"
	------------------------------------
	inst_element_list(_,_,_,_,_,els,_) => fail

end

(** relation: inst_element
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 **)

relation inst_element : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Element, InstDims)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(**  extends
	 **
	 ** Handle "extends" elements by instantiating the class definition
	 ** of the extended class.
	 **)

 (** LS: Is this really correct? First modifications are lookuped from mods and *)
 (** put into classmod, than classmod and mods are merged ??? **)
	 
  rule	Absyn.path_string(cn) => cns &
	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,restr,def), cenv) &
	Debug.fprintln ("insttr", "Base class found") &
	Mod.lookup_modification_p(mods,cn) => classmod &
	Debug.fprintln ("insttr", "Modifications fetched") &
	Mod.elab_mod(env,pre,m) => m' &
	Debug.fprintln ("insttr", "Modifications elaborated") &
	(* Build the combind set of modifications *)
	(* classmod is the modifications stored with the class *)
	(* mods     is the modifications passed to the relatio *)
	(* m        is the modification stored in the element *)
	Mod.merge(classmod,mods) => mods' &
	Debug.fprintln ("insttr", "Modifications merged") &
	Mod.merge(mods',m') => mods'' &
	Debug.fprintln ("insttr", "Modifications merged again") &
	
	(* Can't use inst_class, as that creates a new frame *)
	inst_class_in(cenv,mods'',pre,csets,ci_state,c,false,inst_dims)
	  => (dae,env',csets',ci_state',vars)
	  ----------------------------------
	inst_element(env,mods,pre,csets,ci_state,SCode.EXTENDS(cn,m),inst_dims)
	  => (dae,env',csets',ci_state',vars)
	  
  	  (**  Rules to catch redeclarations and name collsions
	   **)
	 
	(* If a variable is declared multiple times, the first is used *)
  rule	Lookup.lookup_ident_local(env,n) => _
	-------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,_,_),_)
	  => ([],env,csets,ci_state,[])
	  
  	  (* Illegal redeclarations *)

  rule	Lookup.lookup_ident_local(env,n) => _ &
	print "# Trying to redeclare the class " & print n &
	print " as a variable\n"
	------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.CLASSDEF(n,_,_,_),_)
	  => fail
	  
  rule	Lookup.lookup_class(env,Absyn.IDENT(n)) => (_,_) &
	print "# Trying to redeclare the variable " & print n &
	print " as a class\n"
	---------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,_,_,_,_,_),_)
	  => fail
	  
          (**  A new class definition
	   **
	   ** Put it in the current frame in the environment
	   **)

  rule	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Mod.REDECL(final, [SCode.CLASSDEF(n2,f2,repl2,cls2)])) &
	Debug.fprintln ("insttr", "*--*Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "*--*All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &
	inst_class_decl(env,classmod,pre,csets,cls2,inst_dims) => (env',dae)
	-------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state, 
		     SCode.CLASSDEF(n,_,_,c),inst_dims)
	  => (dae,env',csets,ci_state,[])

	
  rule	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) => classmod &
	Debug.fprintln ("insttr", "**Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "**All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &
	inst_class_decl(env,classmod,pre,csets,c,inst_dims) => (env',dae)
	-------------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state, 
		     SCode.CLASSDEF(n,_,_,c),inst_dims)
	  => (dae,env',csets,ci_state,[])
	  
	  (**  A component
	   **
	   ** This is the rule for instantiating a model component.  A
	   ** component can be a structured subcomponent or a variable,
	   ** parameter or constant.  All of these are treated in a
	   ** similar way.
	   **
	   ** Lookup the class name, apply modifications and add the
	   ** variable to the current frame in the environment. Then
	   ** instantiate the class with an extended prefix.
	   **)
	
  rule	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &
	
	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation_ is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)

	Lookup.lookup_class(env,t) => (cl,cenv) & 

	Debug.fprintl ("insttr", ["found type for: ", n, "\n"]) &
	Debug.fprintln ("insttr", "Looking up class modifications") &
	Mod.lookup_modification_p(mods,t) => classmod &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "Looking up component modifications") &
	Mod.lookup_comp_modification(mods,n) => mm &
	Debug.fcall ("insttr", Mod.print_mod, mm) &
	Debug.fprintln ("insttr", "Elaborating current modifications") &
	Mod.elab_mod(env,pre,m) => m' &
	Debug.fcall ("insttr", Mod.print_mod, m') &

	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m') => mod' &
	Debug.fprintln ("insttr", "Merged modifications") &
	Debug.fcall ("insttr", Mod.print_mod, mod') &
	
	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm, vn) &
	Debug.fprintln ("insttr", "Protection checked") &

	Mod.mod_equation mod' => eq &

	Debug.fprintln ("insttr", "mod equation done") &
	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)

	elab_arraydim(env,ad,eq) => dims &
					       
	Debug.fprintln ("insttr", "arraydim elabed") &

	(** Instantiate the component *)	
	inst_var(cenv,mod',pre,csets,n,cl,attr,dims,[],inst_dims)
	  => (dae1,csets',ty) &
	Debug.fprintl ("insttr", ["instantiated: ", n, "\n"]) &

	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env,attr,eq) => binding &
	Debug.fcall ("insttr", Types.print_binding, binding) &
	Debug.fcall ("insttr", print, "\n") &
	Env.extend_frame_v(env,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding)) => env' &

	(** If the type is one of the simple, predifined types a *)
	(** simple variable declaration is added to the DAE. *)
					       
(*	dae_declare (vn,cl,attr) => dae3 & *)
	let dae = dae1 &
	(*list_append(dae1, dae2) => dae4 & *)
(*	list_append(dae1, dae3) => dae *)
	Debug.fprint("insttr","inst_element Component succeeded\n") 
	-----------------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m),inst_dims)
          => (dae, env',csets',ci_state,
	      [Types.VAR(n,Types.ATTR(flow,acc,param,dir), prot, ty, binding)])
	

	(** If the class lookup in the previous rule fails, this
	 ** rule catches the error and prints an error message about
	 ** the unknown class. 
	 **)

	(**  Failure *)
  rule	not Lookup.lookup_class(env,t) => (cl,cenv) &
	Absyn.path_string(t) => s &
	print "# unknown class '" & print s & print "' while instantiating " &
	Prefix.prefix_add(n,[],pre) => pre' &
	Prefix.print_prefix_str pre' => ns &
	print ns & print "\n" &
	Debug.fcall ("instdb", Env.print_env, env)
	--------------------------
	inst_element(env,_,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,t,_),_)
         => ([],env,csets,ci_state,[])

  rule	print "- inst_element failed\n" &
	SCode.print_element el &
	print "\n"
	-----------------------------------------------------------------
	inst_element(_,_,_,_,_,el,_) => fail

end	

(** relation: inst_var
 **
 ** A component element in a class may consist of several subcomponents
 ** or array elements.  This relation is used to instantiate a
 ** component, instantiating all subcomponents and array elements
 ** separately.
 **)

relation inst_var : (Env.Env,
		     Mod.Mod,
		     Prefix.Prefix,
		     Connect.Sets,
		     Ident,
		     SCode.Class,
		     SCode.Attributes,
		     DimExp list, 
		     int list,
		     InstDims)
	  => (DAE.Element list,Connect.Sets,Types.Type) =

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)


	(** LS: Removed the part which checks if modelica_output is true
	 ** and generates variables with initialization expression from the
	 ** modifications, because it cannot handle right hand side which is a
	 ** component (T_COMPLEX) anyway. This case is handled by the rule below
	 ** which generates correct equations according to the modification.
	 ** Separate code can parse the DAE and put the rhs of the latest
	 ** equation inside the variable declaration, and discard all the
	 ** equations.
	 **)


  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	(* This is where redeclare should be handled *)
	Debug.fprintl ("insttr", ["instantiating var class: ", n, "\n"]) &
	Debug.fcall ("envprint", Env.print_env, env) & 
	inst_class(env,mod,pre',csets,cl,inst_dims) => (dae1,csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	inst_mod_equation(cr,ty,mod) => dae2 &
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), NONE,inst_dims)
	  => dae3 &

	list_append(dae1',dae2) => daex &
	list_append(daex,dae3) => dae
	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))
	--------------------------
	inst_var(env,mod,pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt,dir),
		 [],idxs,inst_dims)
          => (dae,csets',ty)



  rule	inst_dim_exp dim => dime &
	list_append(inst_dims,[dime]) => inst_dims' &
	inst_array(env,mod,pre,csets,n,(cl,attr),1,dim,dims,idxs,inst_dims')
	  => (dae, csets', ty) &
	inst_dim_type dim => dimt &
	Types.lift_array(ty,dimt) => ty'
	-------------------------------
	inst_var(env,mod,pre,csets,n,cl,attr,dim::dims,idxs,inst_dims)
          => (dae,csets',ty')

  rule	print "- inst_var failed: " & print n & print "\n"
	--------------------------------------------------
	inst_var(_,_,_,_,n,_,_,_,_,_) => fail
	
end

relation inst_dim_exp : DimExp => Exp.Subscript =

  axiom	inst_dim_exp DIMINT(i) => Exp.INDEX(Exp.ICONST(i))
  axiom	inst_dim_exp DIMEXP(e,_) => e

end

relation inst_dim_type : DimExp => int option =

  axiom	inst_dim_type DIMINT(i) => SOME(i)
  axiom	inst_dim_type DIMEXP(_,_) => NONE

end

relation fix_direction : (DAE.Element list, Absyn.Direction)
	  => DAE.Element list =


  axiom	fix_direction ([],_) => []

  rule	absyn_dir_to_dae_dir dir => dir' &
	fix_direction (r,dir) => r'
	-----
	fix_direction (DAE.VAR(cr,vk,_,t,e,id)::r,dir) 
	  => DAE.VAR(cr,vk,dir',t,e,id)::r'

  rule	fix_direction(r,dir) => r'
	---------------------------
	fix_direction (x::r,dir) => x::r'

end

relation absyn_dir_to_dae_dir : Absyn.Direction => DAE.VarDirection =
	
  axiom	absyn_dir_to_dae_dir Absyn.INPUT  => DAE.INPUT
  axiom	absyn_dir_to_dae_dir Absyn.OUTPUT => DAE.OUTPUT
  axiom	absyn_dir_to_dae_dir Absyn.BIDIR  => DAE.BIDIR

end

(** relation: inst_array
 **
 ** When an array is instantiated by `inst_var', this relation is used
 ** to go through all the array elements and instantiate each array
 ** element separately.
 **)

relation inst_array : (Env.Env,
		       Mod.Mod,
		       Prefix.Prefix,
		       Connect.Sets,
		       Ident,
		       (SCode.Class*SCode.Attributes),
		       int,
		       DimExp,
		       DimExp list,
		       int list,
		       InstDims
		       )
	  => (DAE.Element list,Connect.Sets,Types.Type) =

  rule	inst_var(env,mod,pre,csets,n,cl,attr,dims,i::idxs,inst_dims)
	  => (dae,csets,ty)
	-----------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,DIMEXP(_,_),dims,idxs,inst_dims)
	  => (dae,csets,ty)

  rule	int_gt(i,stop) => true
	----------------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims)
	  => ([], csets, Types.T_NOTYPE)

  rule	Mod.lookup_idx_modification(mod,i) => mod' &
	inst_var(env,mod',pre,csets,n,cl,attr,dims,i::idxs,inst_dims)
	  => (dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,mod,pre,csets',n,(cl,attr),i',DIMINT(stop),dims,idxs,inst_dims)
	  => (dae2, csets'',_) &

	list_append(dae1,dae2) => dae
	-----------------------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims)
          => (dae,csets'',ty)

  rule	print "- inst_array failed: " & print n & print "\n"
	--------------------------------------------------
	inst_array(_,_,_,_,n,(_,_),_,_,_,_,_) => fail
	
end

(** relation: elab_arraydim
 **
 ** This relations examines both an `Absyn.ArrayDim' and an `Mod.EqMod
 ** option' argument to find out the dimensions af a component.  If
 ** no equation modifications is given, only the declared dimension is
 ** used.
 **
 ** When the size of a dimension in the type is undefined, the
 ** corresponding size in the type of the modification is used.
 **
 ** All this is accomplished by examining the two arguments separately
 ** and then using `complete_arraydime' or `compatible_arraydim' to
 ** check that that the dimension sizes are compatible and complete.
 **)

relation elab_arraydim : (Env.Env, Absyn.ArrayDim, Mod.EqMod option)
	  => DimExp list =

  rule	elab_arraydim_decl(env,ad) => dim &
	complete_arraydim(dim) => dim'
	------------------------------
	elab_arraydim(env,ad,NONE) => dim'

  rule	elab_arraydim_decl(env,ad) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3
	---------------------------------
	elab_arraydim(env,ad,SOME((e,Static.PROP(t,c)))) => dim3

  rule	elab_arraydim_decl(env,ad) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	not compatible_arraydim(dim1,dim2) => dim3 &
	print "# Array dimension mismatch\n" &
	print "    expression " & Exp.print_exp e &
	print " has type " & Types.print_type t & print "\n" &
	print "    expected array dimensions [" &
	print_dim dim1 & print "]\n"
	---------------------------------
	elab_arraydim(env,ad,SOME((e,Static.PROP(t,c)))) => fail


  rule	print "- elab_arraydim failed\n"
	-------------------------------------
	elab_arraydim(_,_,_) => fail

end

(** relation: print_dim
 **
 ** This relation prints array dimensions.  The code is not included
 ** in the report.
 **)

(*!ignorecode*)
relation print_dim : (DimExp option) list => () =

  rule	print ":"
	---------
	print_dim [NONE]

  rule	int_string x => s & print s
	---------------------------
	print_dim [SOME(DIMINT(x))]

  rule	Exp.print_subscript x
	---------------------------
	print_dim [SOME(DIMEXP(x,_))]

  rule	print ":," & print_dim xs
	-------------------------
	print_dim NONE::xs

  rule	int_string x => s & print s & print "," & print_dim xs
	------------------------------------------------
	print_dim SOME(DIMINT(x))::xs

rule	Exp.print_subscript x & print "," & print_dim xs
	------------------------------------------------
	print_dim SOME(DIMEXP(x,_))::xs

end
(*!includecode*)

(** relation: elab_arraydim_decl
 **
 ** Given an `Absyn.ArrayDim', this relation evaluates all dimension
 ** size specifications, creating a list of (optional) integers.  When
 ** the array dimension size is specified as `:', the result will
 ** contain `NONE'.
 **)

relation elab_arraydim_decl : (Env.Env, Absyn.ArrayDim) => (DimExp option) list =

  axiom	elab_arraydim_decl(_,[]) => []

  rule	elab_arraydim_decl(env,ds) => l
	-------------------------------
	elab_arraydim_decl(env,Absyn.NOSUB::ds) => NONE::l

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(Types.T_INTEGER,true)) &
	Static.ceval(env,e) => Values.INTEGER(i) &
	elab_arraydim_decl(env,ds) => l
	-------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => SOME(DIMINT(i))::l

  rule	Static.elab_exp(env, d) => (e,Static.PROP(Types.T_INTEGER,false)) &
	elab_arraydim_decl(env,ds) => l
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) 
	  => SOME(DIMEXP(Exp.INDEX(e),NONE))::l

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(t,_)) &
	print "# Array dimensions must be integer\n" &
	print "    expression: " & Exp.print_exp e &
 	print " (" & Types.print_type t & print ")\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => fail

  rule	print "- elab_arraydim_decl failed\n"
	-------------------------------------
	elab_arraydim_decl(_,_) => fail
	
end

(** relation: complete_arraydim
 **
 ** This relation converts a list of optional integers to a list of
 ** integers.  If one element of the list is `NONE', this relation
 ** will fail.
 **
 ** This is used to check that an array specification contain fully
 ** specified array dimension sizes.
 **)

relation complete_arraydim : (DimExp option) list => DimExp list =

  axiom	complete_arraydim [] => []

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim SOME(x)::xs => x::xs'

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim NONE::xs => DIMEXP(Exp.WHOLEDIM,NONE)::xs'

end

(** relation: compatible_arraydim
 **
 ** Given two, possibly incomplete, array dimension size
 ** specifications as list of optional integers, this relation checks
 ** whether they are compatible.  Being compatible means that they
 ** have the same number of dimension, and for every dimension at
 ** least one of the lists specifies its size.  If both lists specify
 ** a dimension size, they have to specify the same size.
 **)

relation compatible_arraydim : ((DimExp option) list,(DimExp option) list)
	  => DimExp list =

  axiom	compatible_arraydim([],[]) => []

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(SOME(x)::xs,NONE::ys) => x::l

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(NONE::xs,SOME(y)::ys) => y::l

  rule	x = y &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMINT(y))::ys) 
	  => DIMINT(x)::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(x)),NONE),DIMEXP(y,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMEXP(y,e))::ys)
	  => de::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(y)),NONE),DIMEXP(x,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e))::xs,SOME(DIMINT(y))::ys) 
	  => de::l

  rule	arraydim_condition(DIMEXP(x,e1),DIMEXP(y,e2))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e1))::xs,SOME(DIMEXP(y,e2))::ys)
	  => de::l


  rule	compatible_arraydim(xs,ys) => l
	--------------------------------
	compatible_arraydim (NONE::xs,NONE::ys) 
	  => DIMEXP(Exp.WHOLEDIM,NONE)::l

  rule	print "- compatible_arraydim failed\n"
	--------------------------------------
	compatible_arraydim (_,_) => fail

end

relation arraydim_condition : (DimExp, DimExp) => DimExp =
	
  axiom arraydim_condition (de,_) => de

end
(** relation: elab_arraydim_type
 **
 ** Find out the dimension sizes of a type.  The second argument is
 ** used to know how many dimensions should be extracted from the
 ** type.
 **)

relation elab_arraydim_type : (Types.Type, Absyn.ArrayDim)
	  => DimExp option list =

  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type(Types.T_ARRAY(Types.DIM(NONE),t), _::ad) 
	  => NONE::l
	
  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type(Types.T_ARRAY(Types.DIM(SOME(i)),t), _::ad) 
	  => SOME(DIMINT(i))::l
	
 axiom elab_arraydim_type(_,[]) => []

 (* PR, for debugging *)
  rule	print "Undefined!" &
	print " The type detected: " &
  	Types.print_type t 
       --------------------
	elab_arraydim_type(t,_::ad) => fail
end

(** relation: inst_class_decl
 **
 ** The class definition is instantiated although no variable
 ** is declared with it.  After instantiating it, it is
 ** checked to see if it can be used as a package, and if it
 ** can, then it is added as a variable under the same name as
 ** the class.  This makes it possible to use a unified lookup
 ** mechanism.  And since packages only can contain constants
 ** and class definition, instantiating a package does not do
 ** anything else.
 **)

relation inst_class_decl : (Env.Env, Mod.Mod, Prefix.Prefix,
			    Connect.Sets, SCode.Class,InstDims)
	  => (Env.Env, DAE.Element list) =

  rule	Env.extend_frame_c(env,c) => env' &
	implicit_instantiation(env',Mod.NOMOD,pre,csets,c,inst_dims) => (env'',dae)
	----------------------------------
	inst_class_decl(env,mod,pre,csets,c as SCode.CLASS(n,_,restr,_),inst_dims)
	  => (env'', dae)

  rule	print "- inst_class_decl failed\n"
	----------------------------------
	inst_class_decl(_,_,_,_,_,_) => fail
end

(** relation implicit_instantiation
 **
 ** If a class definition is a function or a package or an enumeration , 
 ** it is implicitly instantiated and added as a type binding under the
 ** same name as the class name.
 **)

relation implicit_instantiation : (Env.Env, Mod.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims)
	  => (Env.Env, DAE.Element list) =

(* LS:This rule extends the frame with the package as a type, but
inst_class also extends the frame with the package as a class. Is this
correct?
*)

  rule	Prefix.prefix_add(n,[],pre) => pre' &
(*	let pre' = pre & *)
	inst_class(env,mod,pre',csets,c,inst_dims) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
(*	let env' = env & *)
	Debug.fprintl ("insttr", ["implicit_instantiation done:", n, "\n"])
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_PACKAGE,_),
			       inst_dims)
	  => (env', dae)

(* LS: changed from returning empty dae to returning a DAE.FUNCTION *)
(* LS: removed prefix because function elements shouldn't have
   one. They will contain the elements locally *)

  rule	(*Prefix.prefix_add(n,[],pre) => pre' &*)
	inst_class(env,mod,pre,csets,c,inst_dims) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
	Prefix.prefix_path (Absyn.IDENT(n), pre) => fpath
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_FUNCTION,_),
			       inst_dims)
	  => (env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])

  rule	(*	Prefix.prefix_add(n,[],pre) => pre' & *)
	inst_class(env,mod,pre,csets,c,inst_dims) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
	Prefix.prefix_to_path pre => fpath
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_FUNCTION,_),
			       inst_dims)
	  => (env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])

  rule	(*let ty = Types.T_ENUMERATION(l) &
	Env.extend_frame_t(env,n,ty) => env' & *)
	inst_enumeration(n,l) => enumclass &
	Env.extend_frame_c(env,enumclass) => env'' 
	-----------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_TYPE, SCode.ENUMERATION(l)),inst_dims)
	=> (env'', [])

  axiom	implicit_instantiation(env,mod,pre,csets,c,_) => (env,[])

end

(** relation: inst_enumeration
 ** This relation takes an 'Ident' and list of strings, and returns an enumeration class.
**)
relation inst_enumeration: (SCode.Ident, string list) => SCode.Class =
  rule	make_enum_components(l) => comp
	--------------------------------
	inst_enumeration(n,l) => SCode.CLASS(n,false,Absyn.R_ENUMERATION,SCode.PARTS(comp,[],[]))
end

(** relation: make_enum_components
 ** This relation takes a list of strings and returns the elements of 
 ** type 'EnumType' each corresponding to one of the enumeration values.
 **)
relation make_enum_components: string list => SCode.Element list =
  axiom make_enum_components ([str]) 
	  =>  [SCode.COMPONENT(str,true,false,SCode.ATTR([],false,SCode.RO,Absyn.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD)]
	  
  rule	make_enum_components(x) => els
	----------------------------
	make_enum_components (str::(x as (_::_)))
	  => SCode.COMPONENT(str,true,false,SCode.ATTR([],false,SCode.RO,Absyn.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD):: els
end

(** relation: dae_declare
 **
 ** Given a global component name, a type, and a set of attributes,
 ** this relation declares a component for the DAE result.  Altough
 ** this relation returns a list of `DAE.Element's, only one component
 ** is actually declared.
 **
 ** The relations `dae_declare2' and `dae_declare3' below are helper
 ** relations that perform parts of the task.
 **)

(* LS: Added direction so that function elements can be defined
   correctly *)
relation dae_declare : (Exp.ComponentRef,
			Types.Type, 
			SCode.Attributes, 
			Exp.Exp option,
			InstDims
			) 
	  => DAE.Element list =

  rule	Debug.fprint( "insttr", "dae_declare(") &
	Debug.fcall ( "insttr", Exp.print_component_ref,vn) &
	Debug.fprint ( "insttr", ",") &
	Debug.fcall ( "insttr", Types.print_type,ty)  &
	Debug.fprint ("insttr", "...)\n") &
	dae_declare2 (vn, ty, par, dir, e, inst_dims) => dae
	-----------------------------------
	dae_declare (vn, ty, SCode.ATTR(_,_,_,par,dir), e, inst_dims) => dae

  rule	print "- dae_declare failed\n"
	------------------------------
	dae_declare(_,_,_,_,_) => fail

end

(**)
(* LS: Added direction so that function elements can be defined
   correctly *)
relation dae_declare2 : (Exp.ComponentRef, Types.Type, Absyn.Variability,
			 Absyn.Direction, Exp.Exp option,InstDims)
	  => DAE.Element list =

  rule	dae_declare3 (vn, ty, DAE.VARIABLE, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.VAR, dir, e,inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.DISCRETE, dir, e,inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.DISCRETE, dir, e, inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.PARAM, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.PARAM, dir, e, inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.CONST, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.CONST, dir, e, inst_dims) => dae

  rule	print "- dae_declare2 failed\n"
	------------------------------
	dae_declare2(_,_,_,_,_,_) => fail

end



relation dae_declare3 : (Exp.ComponentRef, Types.Type, DAE.VarKind,
			 Absyn.Direction, Exp.Exp option, InstDims)
	  => DAE.Element list =

  rule	dae_declare4 (vn, ty, vk, DAE.INPUT, e, inst_dims) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, vk, Absyn.INPUT, e, inst_dims) => dae

  rule	dae_declare4 (vn, ty, vk, DAE.OUTPUT, e, inst_dims) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, vk, Absyn.OUTPUT, e, inst_dims) => dae

  rule	dae_declare4 (vn, ty, vk, DAE.BIDIR, e, inst_dims) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, vk, Absyn.BIDIR, e, inst_dims) => dae

  rule	print "#- dae_declare3 failed\n"
	------------------------------
	dae_declare3(_,_,_,_,_,_) => fail

end



(**)

relation dae_declare4 : (Exp.ComponentRef, Types.Type, DAE.VarKind,
			 DAE.VarDirection, Exp.Exp option, InstDims)
	  => DAE.Element list =

  axiom	dae_declare4 (vn, Types.T_INTEGER, kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.INT, e, inst_dims)]
	
  axiom	dae_declare4 (vn, Types.T_REAL, kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.REAL, e, inst_dims)]

  axiom	dae_declare4 (vn, Types.T_BOOL, kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.BOOL, e, inst_dims)]
	
  axiom	dae_declare4 (vn, Types.T_STRING, kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.STRING, e, inst_dims)]
axiom dae_declare4 (vn, Types.T_ENUM, kind, dir, e, inst_dims)
	=> []
	(* We should not declare each enumeration value of an enumeration when instantiating,e.g Myenum my !=> constant EnumType my.enum1,... *)
	(*[DAE.VAR(vn, kind, dir, DAE.ENUM, e, inst_dims)]*)

  axiom	dae_declare4 (vn, Types.T_ENUMERATION(l), kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.ENUMERATION(l), e, inst_dims)]

  axiom	dae_declare4 (c,ty,_,_,_,_) => []

end

(** relation: inst_equation
 **
 ** The DAE output of the translation contains equations which
 ** in most cases directly corresponds to equations in the source.
 ** Some of them are also generated from `connect' clauses.
 **
 ** This relation takes an equation from the source and generates DAE
 ** equations and connection sets.
 **)

relation inst_equation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

	(**  connect
	 **
	 ** Handle connct statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2) => csets' &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------------
	inst_equation(env,mods,pre, csets, ci_state, SCode.EQ_CONNECT(c1,c2))
	  => ([],env,csets',ci_state')
	  
	(**  assert
	 **)

  rule	Static.elab_exp(env,e) => (e', Static.PROP(t, c)) &
	inst_assertion (env, e', t, c, d, pre) => dae &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	--------------------------------------------------------------
	inst_equation(env,mods,pre,csets, ci_state,
		      SCode.EQ_EXPR(Absyn.CALL(Absyn.CREF_IDENT("assert",[]),
					       Absyn.FUNCTIONARGS([e,Absyn.STRING(d)],[]))))
	  => (dae,env,csets,ci_state')

	(**  Normal equations *)

  rule	print "- No expression equations yet\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,SCode.EQ_EXPR(_)) => fail

	(** The following rule handles shadowed (replaced) equations. *)
	(** If an equation has a simple name on the left-hand side, *)
	(** and that component has an equation modifier, this equation *)
	(** is discared. *)
  rule	Lookup.lookup_ident_local(env,n)
	  => Types.VAR(_,_,_,_,Types.EQBOUND(_,_)) &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,
		      SCode.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2))
	  => ([],env,csets,ci_state')

(* PR. This is probably where type checking of functions happen.*)
  rule	(*PR. propx contains the type/types(for functions) of the
	 resulting expression. But why are e1', e2' needed? They are
	 used to generate the dae's. Probably their type may have been
	 modified.  *)
	Debug.print("\n Expressions matched in inst equation:") &

(*	Absyn.print_absyn_exp(e1) &
*)	
	Debug.print(", ") &

(*	Absyn.print_absyn_exp(e2) &
*)	
	Debug.print("\n") &

	(* 
	 Do static analysis and constant evaluation of expressions. 
	 Gives expression and properties 
	 (Type * bool | (Type * Const as (bool | Const list))).
	 For a function, it checks the funtion name. 
	 Also the function call's in parameters are type checked with
	 the functions definition's inparameters. This is done with
	 regard to the position of the input arguments.

	 Returns the output parameters from the funktion.
	*)

	Static.elab_exp(env,e1) => (e1',prop1) &

	Debug.print("\nDebug: did left elab.") &
	Static.elab_exp(env,e2) => (e2',prop2) &
	Debug.print("\nDebug: did right elab.") &
	(*Exp.print_exp(e1') &*)
	Debug.print(", ") &
	(*Exp.print_exp(e2') & *)
	Debug.print("\n") &

	
	Prefix.prefix_exp(env,e1',pre) => e1'' &
	Prefix.prefix_exp(env,e2',pre) => e2'' &
	Debug.print("\nDebug: did prefixes.") &
(*
 put params-> in front of parameters
 doesn't work after prefix_exp, because of lookup failure

 prefix_params (env, e1'') => e1''' &
 prefix_params (env, e2'') => e2''' & 
*)
	(*PR. Check that the lefthandside and the righthandside get along. *)
	inst_eq_equation(e1'',prop1,e2'',prop2) => dae &
	Debug.print("\nDebug: did inst_eq_equation.") &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'  &
	Debug.print("\nDebug: did ClassInf trans.")
	& Prefix.print_prefix_str pre => prestr &
	Exp.print_exp_str e1' => e1str &
	Exp.print_exp_str e2' => e2str &
	string_append (prestr, ": ") => debugstr &
	string_append (debugstr, e1str) => debugstr2 &
	string_append (debugstr2, " = ") => debugstr3 &
	string_append (debugstr3, e2str) => debugstr4 &
	Debug.fcall ("expenvgraph", Env.print_env_graphviz, (env,debugstr4)) &
	Debug.fprintl ("expenvprint", ["------------ ", debugstr4, "\n"]) &
	Debug.fcall ("expenvprint", Env.print_env, env) &
	Debug.fprintl ("expenvprint", ["------------ /", debugstr4, "\n"])
	--------------------------------------------------------------
	inst_equation(env, mods, pre, csets, ci_state, SCode.EQ_EQUALS(e1,e2))
	  => (dae, env, csets, ci_state')

	(**  `if' statements
	 **
	 ** If statements are instantiated by evaluating the
	 ** conditional expression, and selecting the branch that
	 ** should be used.
	 **)

  rule	Static.elab_exp(env,e) => (e',Static.PROP(Types.T_BOOL,true)) &
	Static.ceval(env,e') => Values.BOOL(cond) &
	Debug.print("\nEQ_IF: ") &
(*!!	print(cond) &
*)
(*	Dump.print_exp(cond) &
	*)
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_equation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb))
	  => (dae,env',csets', ci_state')


	(**  `when equation' statement, modelica 1.1 
	 **
	 ** When statements are instantiated by evaluating the
	 ** conditional expression.
	 **)

(* Test this! 1.1*)
  rule	(* This is only done for 'for' loops. 
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND)  &  *)

 	Static.elab_exp (env,e)
	  => (e',Static.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER),
			     true)) &
	(* FIXEM: Check bounds *)
	Static.ceval (env,e') => v &
	(* Not possilbe for 'when'.unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') & *)
	inst_list(env,mod,pre,csets,ci_state,inst_equation, el)
	  => (dae,env',csets', ci_state') (*&
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
*)	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el))
	  => (dae, env',csets', ci_state')







	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **
	 **)

  rule	Debug.fprintln ("insttr", "inst_equation_eqfor_1") &
	Static.elab_exp (env,e)
	  => (e',Static.PROP(Types.T_ARRAY(Types.DIM(_),
					   id_t),
			     true)) &
	Debug.fprintln ("insti", "for expression elaborated") &
	add_for_loop_scope(env,i,id_t) => env' &
	Debug.fprintln ("insti", "loop-variable added to scope") &
	
	Lookup.lookup_var(env', Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND) &
	Debug.fprintln ("insti", "loop variable looked up") &
	
	(* FIXEM: Check bounds *)
	Static.ceval (env,e') => v &
	Debug.fprintln ("insti", "for expression evaluated") &
	unroll(env',mod,pre,csets,ci_state,i,v,el) => (dae, csets') &
	Debug.fprintln ("insti", "for expression unrolled") &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state' &
	Debug.fprintln ("insttr", "inst_equation_eqfor_1 succeeded")
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el))
	  => (dae, env,csets', ci_state')

  rule	Debug.fprintln ("insttr", "inst_equation_eqfor_2") &
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND) &
	Debug.fprintln ("insti", "loop variable looked up") &
	Static.elab_exp (env,e)
	  => (e',Static.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER),
			     false)) &
	print "#-- Error: Non-constant iteration bounds not supported\n" &
	Debug.fprintln ("insttr", "inst_equation_eqfor_2 succeeded")
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el))
	  => fail

  rule	not Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND) &
	print "# Invalid loop variable: " & print i & print "\n"
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el))
	  => fail

  rule	print "- inst_equation failed\n"
	----------------------------------
	inst_equation(_,_,_,_,_,_) => fail

end


(** HJ: **)
relation add_for_loop_scope : (Env.Env, Ident, Types.Type) => Env.Env =

  rule	Env.open_scope env => env' &
	Env.extend_frame_v(env',
			   Types.VAR(i,
				     Types.ATTR(false,
						SCode.RW,
						Absyn.VAR,
						Absyn.BIDIR),
				     false,
				     typ, 
				     Types.UNBOUND)
			   ) => env''
	---------------
	add_for_loop_scope(env, i,typ) => env''

end

(** LS: **)
relation is_parameter : (Exp.ComponentRef, Env.Env) => () =

  rule	Env.print_env env &
	Lookup.lookup_var (env, cr) 
	  => (Types.ATTR(fl, acc, Absyn.PARAM,dir), ty, bnd)
	----------------------------------------------------
	is_parameter (cr, env)

end 

(** LS: **)
relation prefix_params : (Env.Env, Exp.Exp) => Exp.Exp =

  rule	ModUtil.string_prefix_component_ref ("params->", is_parameter, env, e) => e'
	-----------------------------------------------------------------------
	prefix_params (env, e) => e'

end

(** relation: inst_eq_equation
 **
 ** Equations follow the same typing rules as equality expressions.
 ** This relation adds the equation to the DAE.
 **
 **)

relation inst_eq_equation : (Exp.Exp, Static.Properties,
			     Exp.Exp, Static.Properties) => DAE.Element list =
	(*PR. e1= lefthandside, e2=righthandside
	* This seem to be a strange relation. 
	* wich rule is matched? or is both rules matched?
	*)

        (* LS: Static.type_convert in Static.match_prop can probably fail,
	 * then the first rule will not match. Question if whether the second
	 * rule can match in that case.
	 *)
	
	(* This rule is matched first, if it fail the next rule is matched.
	 *)
  rule	Debug.print("\ninst_eq_equation (match e1) PROP, PROP") &
	Static.match_prop(e1, p1, p2) => e1' &
	inst_eq_equation_2(e1', e2, t2) => dae 

	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP(t1,_),
			 e2,p2 as Static.PROP(t2,_))
	  => dae

	(* If it fails then this rule is matched. *)
  rule	Debug.print("\ninst_eq_equation (match e2) PROP, PROP") &
	Static.match_prop(e2, p2, p1) => e2'&
	Debug.print("\n Second rule of relation_ inst_eq_equation ") &
	inst_eq_equation_2(e1, e2', t1) => dae &
	Debug.print("\n Second rule complete. ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP(t1,_),
			 e2,p2 as Static.PROP(t2,_))
	  => dae



  rule	Debug.print("\ninst_eq_equation(e1) PROP_TUPLE, PROP_TUPLE") &
	(*Exp.print_exp (e1) & *)
	Static.match_prop(e1, p1, p2) => e1' &
	(*Exp.print_exp (e1') & *)
	inst_eq_equation_2(e1', e2, t2) => dae 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP_TUPLE(t1,_),
			 e2,p2 as Static.PROP_TUPLE(t2,_))
	  => dae


(*
  rule
	print("\n So far so good.") &
	
	print("\n  ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP_TUPLE(t1,_),
			 e2,Static.PROP_TUPLE(t2,_))
	  => fail
*)



	(* PR. *)	
  rule	Debug.print("\ninst_eq_equation(e2) PROP_TUPLE, PROP_TUPLE") &
	Debug.print "\n About to do a static match e2. " &
	Static.match_prop(e2, p2, p1) => e2'&
	Debug.print("\n Second rule of relation_ inst_eq_equation ") &
	inst_eq_equation_2(e1, e2', t1) => dae &
	Debug.print("\n Second rule complete. ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP_TUPLE(t1,_),
			 e2,p2 as Static.PROP_TUPLE(t2,_))
	  => dae

	  (* An assignment to a varaible of T_ENUMERATION type is an explicit 
	     assignment to the value componnent of the enumeration, i.e. having a type T_ENUM*)
	
  rule	Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM.\n") &
	inst_eq_equation_2(e1,e2,t) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Static.PROP(Types.T_ENUMERATION(_),_),
	    e2,Static.PROP(t as Types.T_ENUM,_)) => dae

  rule	(* Types.equivtypes(t1,t2) => false & *)
	print "# Illegal types in equation\n"&
	print "    lhs: " & Exp.print_exp e1 &
	print " :: " & Types.print_type t1 & print "\n" &
	print "    rhs: " & Exp.print_exp e2 &
	print " :: " & Types.print_type t2 & print "\n"
	----------
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2,Static.PROP(t2,_)) => fail


(* PR To debug*)

  rule	Debug.print("\ne1 is PROP and e2 is PROP_TUPLE.  ")
	---------------------------------	
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2, Static.PROP_TUPLE(_,_)) => fail

  rule	Debug.print("e2 is PROP")
	---------------------------------
	inst_eq_equation(e1,_,
			 e2,Static.PROP(t2,_)) => fail

  rule	Debug.print("e1 is PROP")
	---------------------------------
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2, _) => fail




(* No match. *)
  rule	print ("\n No match in inst_eq_equation. ")
	---------------------------------	
	inst_eq_equation(_,_,_,_) => fail

end

(** relation: inst_eq_equation_2
 **
 ** This is the second stage of `inst_eq_equation', when the types are
 ** checked.
 **)

relation inst_eq_equation_2 : (Exp.Exp, Exp.Exp, Types.Type)
	=> DAE.Element list =

  axiom	inst_eq_equation_2(e1,e2,Types.T_INTEGER)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_REAL)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_STRING)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_BOOL)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_ENUM)
	=> [DAE.EQUATION(e1,e2)]

  rule	RTOpts.split_arrays => true &
	(* For debugging.
	print "  Array equation: " &
	Exp.print_exp e1 & print " = " &
	Exp.print_exp e2 & print "\n" & *)
	inst_array_equation(e1,e2,ad,t) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t)) => dae


	(* PR. The muliple outputs from functions is outputed as is. *)

  axiom	inst_eq_equation_2(e1,e2,Types.T_TUPLE(_))
	  => [DAE.EQUATION(e1,e2)]


  rule	RTOpts.split_arrays => false
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t))
	  => [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1, e2, Types.T_COMPLEX(_,[])) => []

  rule	Exp.extend_cref(c1,n,[]) => c1' &
	Exp.extend_cref(c2,n,[]) => c2' &
	inst_eq_equation_2(Exp.CREF(c1',t1), Exp.CREF(c2',t2), t) => dae1 &
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   Types.T_COMPLEX(cs,vs)) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   Types.T_COMPLEX(cs,Types.VAR(n,_,_,t,_)::vs)) => dae

	(** When the type of the expressions is a complex type, and *)
	(** the left-hand side of the equation is not a component *)
	(** reference, a new variable is introduced to be able to *)
	(** dereference components of the expression. *)
	(** *)
	(** This is rather ugly, since it doesn't really solve the *)
	(** problem of describing the semantics.  Now the semantics of *)
	(** composite equations are defined in terms of other *)
	(** composite equations.  To make this a little cleaner, the *)
	(** equation that equates the new name to the expression is *)
	(** stored using DAE.DEFINE rather than DAE.EQUATION.  This *)
	(** makes it a little clearer. *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     Absyn.VAR, Absyn.BIDIR), NONE,[])
	  => decl &
	inst_eq_equation_2(Exp.CREF(n,Exp.OTHER), e2, t) => dae1 &
	list_append(decl, DAE.DEFINE(n, e1)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2 as Exp.CREF(_,_),
			   t as Types.T_COMPLEX(_,_)) => dae

	(** When the right-hand side is not a component reference a *)
	(** similar trick is applied.  This also catched the case *)
	(** where none of the sides is a component reference *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     Absyn.VAR, Absyn.BIDIR), NONE,[])
	  => decl &
	inst_eq_equation_2(e1, Exp.CREF(n,Exp.OTHER), t) => dae1 &
	list_append(decl, DAE.DEFINE(n, e2)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2, t as Types.T_COMPLEX(_,_)) => dae

  rule	print "- inst_eq_equation_2 failed\n"
	-------------------------------------
	inst_eq_equation_2(_,_,_) => fail

end

(** relation: inst_array_equation
 **
 ** This checks the array size and uses `inst_array_el_eq' to create
 ** equations for each array element.
 **)

relation inst_array_equation : (Exp.Exp, Exp.Exp,
				Types.ArrayDim, Types.Type)
	  => DAE.Element list =

  rule	print "# Cannot instantiate equations with arrays of unknown size\n" &
	print "    " & Exp.print_exp e1 & print " = " & Exp.print_exp e2&
	print "\n"
	----------
	inst_array_equation(e1, e2, Types.DIM(NONE), t) => fail

  rule	inst_array_el_eq(e1, e2, t, 1, sz) => dae
	---------------------------------------------
	inst_array_equation(e1, e2, Types.DIM(SOME(sz)), t) => dae

  rule	print "- inst_array_equation failed\n"
	--------------------------------------
	inst_array_equation (_,_,_,_) => fail

end

(** relation: inst_array_el_eq
 **
 ** This relation loops recursively through all indexes in the two
 ** arrays and generates an equation for each pair of elements.
 **)

relation inst_array_el_eq : (Exp.Exp, Exp.Exp, Types.Type, int, int)
	  => DAE.Element list =

  rule	int_le(i,sz) => true &
	Exp.simplify(Exp.ASUB(e1,i)) => e1' &
	Exp.simplify(Exp.ASUB(e2,i)) => e2' &
	inst_eq_equation_2(e1',e2',t) => dae1 &
	int_add(i,1) => i' &
	inst_array_el_eq(e1,e2,t,i',sz) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_array_el_eq(e1, e2, t, i, sz) => dae

  rule	int_le(i,sz) => false
	---------------------
	inst_array_el_eq(e1, e2, t, i, sz) => []

  rule	print "- inst_array_el_eq failed\n"
	-----------------------------------
	inst_array_el_eq(_,_,_,_,_) => fail

end

(** relation: inst_assertion
 **
 ** Instantiate an assertion.  There are not assertions in the output
 ** currently.
 **)

relation inst_assertion : (Env.Env, Exp.Exp, Types.Type,
			   bool, string, Prefix)
	  => DAE.Element list =

	(* Constant assertions *)
  axiom	inst_assertion (env, e, Types.T_BOOL, true, d, pre) => [(* lost *)]

  axiom	inst_assertion (env, e, Types.T_BOOL, _, d, pre) => [(* lost *)]

  rule	print "# Assertions have to be of type Boolean\n" &
	print "  assertion: (" &
	Prefix.prefix_exp(env,e,pre) => e' & Exp.print_exp e' & print "): " &
 	print d & print "\n"
	-----------------------------
	inst_assertion (env, e, _, _, d, pre) => fail
	
end

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, SCode.Equation list)
	  => (DAE.Element list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_) => ([], csets)

  rule	Env.open_scope env => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    Absyn.CONST,
						    Absyn.BIDIR),
				      true,
				      Types.T_INTEGER,
				      Types.VALBOUND(fst))) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_equation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs)
	  => (dae, csets'')

  rule	print "- unroll " & Values.print_val v & print " failed\n"
	-------------------------
	unroll (_,_,_,_,_,_,v,_) => fail

end

(** relation: inst_algorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_statements(env,statements) => statements'
	----------------------------------------------
	inst_algorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements))
	  => ([DAE.ALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	print "- inst_algorithm failed\n"
	---------------------------------
	inst_algorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_statements
 **
 ** This relation converts a list of algorithm statements.
 **)

relation inst_statements : (Env, Absyn.Algorithm list)
	  => Algorithm.Statement list =

  axiom	inst_statements(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_statements(env,xs) => xs'
	------------------------------
	inst_statements(env,x::xs) => x'::xs'

end

(** relation: inst_statement
 **
 ** This relation Looks at an algorithm statement and uses relations
 ** in the `Algorithm' module to build a representation of it that can
 ** be used in the DAE output.
 **)

relation inst_statement : (Env, Absyn.Algorithm) => Algorithm.Statement =

  rule	Static.elab_cref (env,cr) => (ce, cprop, acc) &
	Static.elab_exp (env,e) => (e', eprop) &
	Algorithm.make_assignment(ce,cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e)) => stmt

  rule	Static.elab_exp(env,e) => (e',prop) &
	inst_statements(env,tb) => tb' &
	inst_elseifs(env,eib) => eib' &
	inst_statements(env,fb) => fb' &
	Algorithm.make_if(e',prop,tb',eib',fb') => stmt
	--------------------------------------------
	inst_statement(env,Absyn.ALG_IF(e,tb,eib,fb)) => stmt

  rule	Static.elab_exp (env,e)  =>
	(e', prop as Static.PROP(Types.T_ARRAY(_,t),_)) &
	
	add_for_loop_scope(env,i,t) => env' &
	
	inst_statements(env',sl) => sl' &
	Algorithm.make_for(i,e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_FOR(i,e,sl)) => stmt

  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_while(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHILE(e,sl)) => stmt


  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_when_a(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN_A(e,sl)) => stmt

(* 1.0
 rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_when(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN(e,sl)) => stmt
*)
  rule	print "- inst_statement failed\n"
	---------------------------------
	inst_statement(_,_) => fail

end

(** relation: inst_elseifs
 **
 ** This relation helps `inst_statement' to handle `elseif' parts.
 **)

relation inst_elseifs : (Env.Env, (Absyn.Exp * Absyn.Algorithm list) list)
	=> (Exp.Exp * Static.Properties * Algorithm.Statement list) list =

  axiom	inst_elseifs (env,[]) => []

  rule	Static.elab_exp(env,e) => (e',prop) &
	inst_statements(env,l) => stmts &
	inst_elseifs(env,tail) => tail'
	-------------------------------
	inst_elseifs(env,(e,l)::tail) => ((e',prop,stmts)::tail')

  rule	print "- inst_elseifs failed\n"
	-------------------------------
	inst_elseifs(_,_) => fail

end

(** relation: inst_connect
 **)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef)
	  => Connect.Sets =

  rule	Static.elab_cref(env, c1) => (Exp.CREF(c1',t1),prop1,acc) &
	Static.elab_cref(env, c2) => (Exp.CREF(c2',t2),prop2,acc) &
	Static.canon_cref(env, c1') => c1'' &
	Static.canon_cref(env, c2') => c2'' &
	Lookup.lookup_var_local(env,c1'')
	  => (attr1 as Types.ATTR(flow1,_,_,_),ty1,_) &
	Lookup.lookup_var_local(env,c2'') => (attr2,ty2,_) &
	
	(** Check that the types of the connectors are good. *)
	valid_connector(ty1) &
	valid_connector(ty2) &
	check_connect_types(c1'',ty1,attr1,c2'',ty2,attr2) &
	
	component_face(c1'') => f1 &
	component_face(c2'') => f2 &
	connect_components(sets, pre, c1'', f1, ty1, c2'', f2, ty2, flow1)
	  => sets'
	---------------------------------
	inst_connect(sets, env,pre,c1,c2) => sets'

  rule	print "# could not connect\n"
	---------------------------------
	inst_connect(sets,_,_,_,_) => fail

end

(** relation: valid_connector
 **
 ** This relation tests whether a type is a eligible to be used in
 ** connections.
 **
 **)

relation valid_connector : Types.Type => () =

  axiom	valid_connector Types.T_REAL

  rule	ClassInf.valid(state,Absyn.R_CONNECTOR)
	---------------------------------------
	valid_connector Types.T_COMPLEX(state,_)

  rule	print "# Can't connect objects of type " &
	Types.print_type t & print "\n"
	-------------------------------
	valid_connector t => fail
end

(** relation: check_connect_types
 **
 ** Check that the type and type attributes of two connectors match,
 ** so that they really may be connected.
 **
 **)

relation check_connect_types : (Exp.ComponentRef, Types.Type,
				Types.Attributes,
			       	Exp.ComponentRef, Types.Type,
				Types.Attributes) => () =

  rule	print "# Can't connect two input variables\n" &
	print "    while connecting " & Exp.print_component_ref c1 &
	print " to " & Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.INPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.INPUT)) => fail

  rule	print "# Can't connect two output variables\n" &
	print "    while connecting " & Exp.print_component_ref c1 &
	print " to " & Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.OUTPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.OUTPUT)) => fail

  rule	flow1 = flow2 &
	Types.equivtypes(t1, t2) => true
	-------------------------------
	check_connect_types(_,t1,Types.ATTR(flow1,_,_,_),
			    _,t2,Types.ATTR(flow2,_,_,_))

  rule	print "# Can't connect flow component " &
 	Exp.print_component_ref c1 &
	print " to non-flow component " &
 	Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(true,_,_,_),
			    c2,_,Types.ATTR(false,_,_,_)) => fail

  rule	print "# Can't connect non-flow component " &
 	Exp.print_component_ref c1 &
	print " to flow component " &
 	Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(false,_,_,_),
			    c2,_,Types.ATTR(true,_,_,_)) => fail

  rule	print "- check_connect_types(" & Exp.print_component_ref c1 &
	print " <-> " & Exp.print_component_ref c2 & print ") failed\n"
	------------------------------------------------------
	check_connect_types(c1,_,_,c2,_,_) => fail

end

(** relation: connect_components
 **
 ** This relation connects two components and generates connection
 ** sets along the way.  For simple components (of type `Real') it
 ** adds the components to the set, and for complex types it traverses
 ** the subcomponents and recursively connects them to each other.
 **)

relation connect_components: (Connect.Sets,
			      Prefix,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      bool) => Connect.Sets =
	
	(**  Flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_flow(sets, c1', f1, c2', f2) => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, f1, Types.T_REAL,
			   c2, f2, Types.T_REAL, true) => sets'
	
	(**  Non-flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, _, Types.T_REAL,
			   c2, _, Types.T_REAL, false) => sets'

	(**  Complex types *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	connect_vars(sets,c1',f1,l1,c2',f2,l2) => sets'
	----------------------------------------
	connect_components(sets,pre,c1,f1, Types.T_COMPLEX(_,l1),
			   c2,f2, Types.T_COMPLEX(_,l2),_) => sets'

	(**  Error *)
	
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	print "# Wrong type in connection\n"&
 	print "  while making connectiion " &
	Exp.print_component_ref c1 & print " <-> " &
	Exp.print_component_ref c2 & print "\n" &
	print "  The type `" & Types.print_type t1 &
	print "' is not allowed in connections\n"
	----------------------------------------
	connect_components(_,pre,c1,_,t1,c2,_,t2,_) => fail
	
end

(** relation: connect_vars
 **
 ** This relation connects two subcomponents by adding the component
 ** name to the current path and recursively connecting the components
 ** using the relation `connet_components'.
 **)

relation connect_vars : (Connect.Sets,
			 Exp.ComponentRef, Connect.Face, Types.Var list,
			 Exp.ComponentRef, Connect.Face, Types.Var list)
	  => Connect.Sets =

  axiom	connect_vars(sets,_,_,[],_,_,[]) => sets

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	check_connect_types(c1', ty1, attr1, c2', ty2, attr2) &
	connect_components(sets,Prefix.NOPRE,
			   c1',f1, ty1,
			   c2',f2, ty2, flow1) => sets' &
	connect_vars(sets',c1,f1,xs1,c2,f2,xs2) => sets''
	--------------------------------------
	connect_vars(sets,
		     c1,f1, Types.VAR(n,attr1 as Types.ATTR(flow1,_,vt1,_),
				      _,ty1,_)::xs1,
		     c2,f2, Types.VAR(_,attr2 as Types.ATTR(flow2,_,vt2,_),
				      _,ty2,_)::xs2)
	  => sets''

end

(** relation: mktype **
 ** From a class inference state, and a list of subcomponents, this
 ** relation returns `Types.Type'.  If the class inference state
 ** indicates that the type should be a built-in type, one of the
 ** built-in type constructors is used.  Otherwise, a `T_COMPLEX' is
 ** built.
 **)

relation mktype : (ClassInf.State,Types.Var list) => Types.Type =

  axiom	mktype(ClassInf.TYPE_INTEGER(_),_) => Types.T_INTEGER
  axiom	mktype(ClassInf.TYPE_REAL(_),_)    => Types.T_REAL
  axiom	mktype(ClassInf.TYPE_STRING(_),_)  => Types.T_STRING
  axiom	mktype(ClassInf.TYPE_BOOL(_),_)    => Types.T_BOOL
  axiom	mktype(ClassInf.TYPE_ENUM(_),_)    => Types.T_ENUM

	(* Insert function type construction here
	   after checking input/output arguments? 
	   see types.rml T_FUNCTION *)

  rule	Types.make_function_type (vl) => functype
	--------------------------
	mktype(st as ClassInf.FUNCTION(name), vl) => functype

  rule	Types.make_enumeration_type (v1) => enumtype
	--------------------------------------------
	mktype(ClassInf.ENUMERATION(name),v1) => enumtype
(*
  rule	print " <function " & print name & print "> <" &
	Dump.print_list (vl, Types.print_var, ", ") &
	print " >"
	--------------------------
	mktype(st as ClassInf.FUNCTION(name), vl) => Types.T_COMPLEX(st,vl)
*)

  axiom	mktype(st,l) => Types.T_COMPLEX(st,l)

end

(** relation: inst_list
 **
 ** This is a utility used to do instantiation of list of things,
 ** collecting the result in another list.
 **)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list)
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[]) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es)
	  => (l'',env'',csets'',ci_state'')

end

(** relation: component_face
 ** 
 ** This relation determines whether a component reference refers to an
 ** inner or outer connector.
 **)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

  rule	print "# While connecting " &
	Exp.print_component_ref c & print "\n" &
	print "# Only local or child connectors allowed.\n"
	---------------------------------------------------
	component_face c => fail

end



(** relation: inst_mod_equation
 **
 ** This relation adds the equation in the declaration of a variable,
 ** if such an equation exists.
 **)

relation inst_mod_equation : (Exp.ComponentRef, Types.Type, Mod)
	  => DAE.Element list =

(*  rule	print "inst_mod_equation\n" &
	Exp.cref_str cr => str &
	print "cref = " & print str &
	print "\nmod=" &
	Mod.print_mod mod &
	int_eq(1,0) => true
	----------
	inst_mod_equation(cr,ty1,mod) => [] *)
	  
  rule	Static.elab_type ty1 => t &
	inst_eq_equation(Exp.CREF(cr,t),
			 Static.PROP(ty1,false(*FIXME*)), e,prop2) => dae
	-----------------------------------------------
	inst_mod_equation(cr,ty1, mod as Mod.MOD(_,_,SOME((e,prop2))))
	  => dae

  axiom inst_mod_equation(_,_,Mod.MOD(_,_,NONE)) => []
  axiom inst_mod_equation(_,_,Mod.NOMOD) => []

  rule	print "- inst_mod_equation failed\n"
	------------------------------------
  	inst_mod_equation (_,_,_) => fail

end






(** relation: check_prot
 **
 ** This relation is used to check that a protected element is not
 ** modified.
 **)

relation check_prot : (bool, Mod.Mod, Exp.ComponentRef) => () =

  axiom	check_prot(false,_,cref)
	
  axiom check_prot(_,Mod.NOMOD,_)

  rule	print "# Trying to modify protected element " &
	Exp.print_component_ref cref & print "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(** relation: make_binding
 **
 ** This relation looks at the equation part of a modification, and if
 ** there is a declaration equation builds a `Types.Binding' for it.
 **
 **)

relation make_binding : (Env.Env, SCode.Attributes, Mod.EqMod option)
	  => Types.Binding =

  axiom	make_binding (_,_,NONE) => Types.UNBOUND

(* Numerical values becoms VALBOUND *)
  axiom	make_binding (env, _, SOME((Exp.ICONST(i),_))) 
	    => Types.VALBOUND(Values.INTEGER(i))
	    
  axiom make_binding (env, _, SOME((Exp.RCONST(r),_)))
	    => Types.VALBOUND(Values.REAL(r))
	    
  axiom	make_binding (env, _, SOME((Exp.SCONST(s),_)))
	=> Types.VALBOUND(Values.STRING(s))
	    
  axiom	make_binding (env, _, SOME((Exp.BCONST(b),_)))
	=> Types.VALBOUND(Values.BOOL(b))

	(* Constant binding *)
  axiom	make_binding (env, SCode.ATTR(_,_,_,Absyn.CONST,_), SOME((e,prop)))
	  => Types.EQBOUND(e,true)

	(* default *)

  axiom	make_binding (_,_, SOME((e,Static.PROP(t,c)))) => Types.EQBOUND(e,c)

  rule	print "- make_binding failed\n"
	-------------------------------
	make_binding(_,_,_) => fail

end


relation canon_cref_list : (Env, Exp.Exp list) => Exp.Exp list =

  axiom	canon_cref_list (_, []) => []

  rule	canon_cref_list (env, rest) => elist &
	Static.canon_cref (env, cr) => cr'
	---------------------------------
	canon_cref_list (env, Exp.CREF(cr,t)::rest) => Exp.CREF(cr',t)::elist

end

(** LS:
 ** This rule goes through the elements and for each variable, searches the rest
 ** of the list for "equations" which refer to that variable on the LHS, and puts
 ** their RHS in the variable as the initialization expression. This is needed
 ** for modelica output where parameters must be "assigned" (?) during
 ** declaration.
 **)

relation init_vars_modelica_output : DAE.Element list => DAE.Element list =

  rule	init_vars_modelica_output_1 ([], l) => l'
	---------------------------------------
	init_vars_modelica_output l => l'
end


relation init_vars_modelica_output_1 : (DAE.Element list, DAE.Element list) 
	  => DAE.Element list =

  axiom init_vars_modelica_output_1 (done, []) => done

  rule	init_vars_modelica_output_2 (cr, exp, done) => (exp', done') &
	init_vars_modelica_output_2 (cr, exp', todorest) => (exp'', todorest') &
	list_append (done', [DAE.VAR(cr, vk, vd, ty, exp'',inst_dims)]) => done'' &
	init_vars_modelica_output_1 (done'', todorest') => done'''
	--------------------------------------------------------
	init_vars_modelica_output_1 (done, (v as DAE.VAR(cr, vk, vd, ty, exp,inst_dims)) :: todorest)
	  => done'''


  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.COMP(n, DAE.DAE(dae'))]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.COMP(n, DAE.DAE(dae)) :: rest)
	  =>  done''

  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.FUNCTION(fpath, DAE.DAE(dae'), ty)]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.FUNCTION(fpath, DAE.DAE(dae), ty) :: rest)
	  =>  done''


  rule	list_append (done, [e]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	---------------------------------------
	init_vars_modelica_output_1 (done,  e :: rest) => done''

end


(** LS:
 ** Search the list for equations with LHS as componentref = cr, remove from the
 ** list and return the RHS of the last of those equations
 **)

relation init_vars_modelica_output_2 : (Exp.ComponentRef, Exp.Exp option, DAE.Element list) 
	  => (Exp.Exp option, DAE.Element list) =

  axiom init_vars_modelica_output_2 (cr, exp, []) => (exp, [])


  rule	Exp.cref_equal (cr, e1cr) => true &
	init_vars_modelica_output_2 (cr, SOME(exp'), rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, DAE.EQUATION(Exp.CREF(e1cr,_ (*Exp.OTHER*)), exp') :: rest)
	  => (exp'', rest')


  rule	Exp.cref_equal (cr, e1cr) => false &
	init_vars_modelica_output_2 (cr, exp, rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, (e1 as DAE.EQUATION(Exp.CREF(e1cr,_(* Exp.OTHER*)), exp')) :: rest)
	  => (exp'', e1 :: rest')

  rule	init_vars_modelica_output_2 (excr, exp, rest) => (exp', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (excr, exp, e1 :: rest) => (exp', e1 :: rest')

end
(** relation: inst_record_constructor_elt
 ** This relation takes an Env and an Element and builds a input argument to a record constructor.
   ** E.g if the element is Real x; the resulting Var is "input Real x;"
**)
relation inst_record_constructor_elt : (Env.Env,SCode.Element) =>
	Types.Var =
	  
  rule	elab_arraydim(env,dim,NONE) => dimexp &
	Lookup.lookup_class(env,t) => (cl,cenv) &
	Mod.elab_mod(env,Prefix.NOPRE,mod) => mod' &
	
	elab_arraydim(env,dim,NONE) => dimexp &
	inst_var(cenv,mod',Prefix.NOPRE,[],id,cl,attr,dimexp,[],[]) => (_,_,tp') &
	Debug.fprint ("recconst", "Type of argument:") &
	Debug.fcall ("recconst",Types.print_type,tp') &
	Debug.fprint ("recconst","\n") &
	Mod.mod_equation mod' => eq &
	make_binding(env,attr,eq) => bind
	---------------------------------------
	inst_record_constructor_elt (env,SCode.COMPONENT(id,_,prot,attr as SCode.ATTR(dim,f,acc,var,dir),t,mod)) 
	    => Types.VAR(id,Types.ATTR(f,acc,var,Absyn.INPUT),prot,tp',bind)

  rule	print "#Error, inst_record_constructor_elt failed\n"
	------------------
	inst_record_constructor_elt(_,_) => fail
end
