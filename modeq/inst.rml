(* inst.rml *)

module Inst:

  with "exp.rml"
  with "absyn.rml"
  (* with "lform.rml" *)
  with "dae.rml"

  relation instantiate: Absyn.Program => DAE.DAEform

end

with "prefix.rml"
with "env.rml"
with "mod.rml"
with "builtin.rml"
with "dump.rml"

(* These make the code a little more readable *)
type Prefix = Prefix.Prefix
type Mod = Mod.Mod
type Ident = Exp.Ident


(**********************************************************************)

relation inst_list (* : (Env.Env, Mod, Prefix, =>, foo list) *)
	 =

  axiom inst_list(env,mod,pre,r,[]) => ([],env)

  rule	r(env,mod,pre,e) => (l,env') &
	inst_list(env',mod,pre,r,es) => (l',env'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,r,e::es) => (l'',env'')

end

relation inst_connect: (Exp.Exp,Exp.Exp) => DAE.DAEcomp list =

  rule	print "No connect() yet\n" & fail
	---------------------------------
	inst_connect(_,_) => []

end

relation inst_equation: (Env.Env,Mod,Prefix,Absyn.Equation)
	  => (DAE.DAEcomp list, Env.Env) =

  (* connect
   *
   * Handle connct statements
   *)

  rule	inst_connect(o1,o2) => l
	------------------------
	inst_equation(env,mods,pre,
		      Absyn.EQ_EXPR(Exp.CALL(Exp.IDENT("connect"),[o1,o2])))
	 => (l,env)

  (* assert
   *
   * FIXME: Handle assertions
   *)

  rule	Prefix.prefix_exp(e,pre) => e' &
	print " ASSERTION(" & Dump.dump_exp(e') & print "): " &
	print d & print "\n"
	------------------------
	inst_equation(env,mods,pre,
		      Absyn.EQ_EXPR(Exp.CALL(Exp.IDENT("assert"),
					     [e,Exp.STRING(d)])))
	  => ([],env)

  rule	print "No expression equations yet\n" & fail
	--------------------------------------------
	inst_equation(env,mods,pre,Absyn.EQ_EXPR(_)) => ([],env)

  rule	print " equation\n" &
	Prefix.prefix_exp(e1,pre) => e1' &
	Prefix.prefix_exp(e2,pre) => e2'
	------------------------
	inst_equation(env,mods,pre,Absyn.EQ_EQUALS(e1,e2)) =>
		([DAE.EQUATION(Exp.RELATION(e1',Exp.EQUAL,e2'))],env)

end

relation inst_mod_assignment : (Prefix, Ident, Mod) => DAE.DAEcomp list =

  rule  Prefix.prefix_path(Exp.IDENT(v), pre) => v' &
	
	Exp.path_string(v') => vn &
	print "  assignment modification: " & Mod.dump(mod, vn) &
	print "\n" &

	Prefix.prefix_exp(e, pre) => e'
	-------------------------------
	inst_mod_assignment(pre,v,mod as Mod.MOD(_,_,SOME(e)))
	  => [DAE.EQUATION(Exp.RELATION(Exp.PATH(v'), Exp.EQUAL, e'))]

  axiom inst_mod_assignment(_,_,_) => []

end

relation inst_element: (Env.Env, Mod, Prefix, Absyn.Element)
	  => (DAE.DAEcomp list, Env.Env) =

  (* extends
   *
   * Handle "extends" elements by instantiating the class definition
   * of the extended class.
   *)

  rule	Env.lookup_class(env,cn) => (Absyn.CLASS(_,partial,restr,d),classmod) &

	(* Can't extend partial classes *)
	partial = false &

	(* Build the combind set of modifications *)
	(* FIXME: verify order *)
	Mod.build(SOME(Absyn.CLASSMOD(m)), false) => mod2 &
	Mod.merge(mods,mod2) => mods' &
	Mod.merge(mods',classmod) => mods'' &

	(*Mod.simple_maybe_modify_class(env,mods',pre,c) *)
	(*  => (Absyn.CLASS(n,_,r,d), dae1) & *)

	(* Can't use inst_class, as that creates a new frame *)
	inst_classdef(env,mods'',pre,d) => (dae,env')
	----------------------------------
	inst_element(env,mods,pre,Absyn.ELEMENT(_,_,Absyn.EXTENDS(cn,m)))
	  => (dae,env')

  (* components
   *
   * Rules for instantiating components.
   *)

  (* If a variable is declared multiple times, the first is used *)
  rule	Env.lookup_var(env,n) &
	print " ignoring shadowed variable " & print n & print "\n"
	--------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,n,Absyn.COMPONENTS(_,_,_,_,_,_,_)))
	  => ([],env)

  (* Illegal redeclarations *)
  rule	Env.lookup_var(env,n) &
	print "Trying to redeclare the class " & print n &
	print " as a variable\n" &
	fail
	------------------------
	inst_element(env,mods,pre, Absyn.ELEMENT(_,n,Absyn.CLASSDEF(_,_)))
	  => ([],env)

  rule	Env.lookup_class(env,Exp.IDENT(n)) => (v,_) &
	print "Trying to redeclare the variable " & print n &
	print " as a class\n" &
	fail
	------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,n,Absyn.COMPONENTS(_,_,_,_,_,_,_)))
	  => ([],env)

  (* A new class definition
   *
   * Put it in the current frame in the environment
   *)
   
  rule	(* Absyn.convert(c) => c' & *)
	Mod.lookup_modification(mods,n) => classmod &
	print "  adding " & Mod.dump(classmod,n) & print "\n" &
	(* Mod.simple_maybe_modify_class(env,mm,pre,c') => (c'',dae) & *)
	Env.extend_frame_c(env,c,classmod) => env'
	----------------------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,n,Absyn.CLASSDEF(_,c)))
	 => ([],env')

  (* A variable
   *
   * Lookup the class name, apply specializations and add the variable
   * to the current frame in the environment. Then instantiate the class
   * with an extended prefix.
   *)

  rule	Prefix.prefix_path(Exp.IDENT(n),pre) => vn &

	Exp.path_string(vn) => ns &
	print " variable " & print ns & print "\n" &

	(* Find the set of modifications *)
	(* FIXME: merge order *)
	Env.lookup_class(env,t) => (cl,classmod) &
	print "  modification 1: " & Mod.dump(classmod,ns) & print "\n" &

	Mod.lookup_modification(mods,n) => mm &
	print "  modification 2: " & Mod.dump(mm,ns) & print "\n" &

	Mod.build(m,final) => m' &
	print "  modification 3: " & Mod.dump(m',ns) & print "\n" &

	(* classmod is the modifications stored with the class *)
	(* mm       is the modifications passed to the relation *)
	(* m'       is the modification stored in the element *)
	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m') => mod' &
	print "  modification: " & Mod.dump(mod',ns) & print "\n" &

	Prefix.prefix_add(n,pre) => pre' &

	(* Mod.maybe_modify_class(env,vn,m'',pre',cl) => (cl',dae1) & *)

	(* print "        modified\n" & *)

	Env.extend_frame_v(env,Env.FRAMEVAR(n,ad,cl,f,p,c,i,o)) => env' &

	print "        added\n" &

	inst_class(env,mod',pre',cl) => dae1 &
	print "        instantiated\n" &

	(* If the modification assigns a value to this variable, add an
	   equation *)
	inst_mod_assignment(pre,n,mod') => dae2 &
	print "        assigned\n" &

	list_append(dae1, dae2) => dae
	--------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(final,_,Absyn.COMPONENTS(f,p,c,i,o,t,
						[Absyn.COMPONENT(n,ad,m)])))
         => (dae,env')

  (*
   * If the class lookup in the previous rule fails, this rule catches
   * the error and prints an error message about the unknown class.
   *)

  rule	not Env.lookup_class(env,t) => (cl,_) &
	Exp.path_string(t) => s &
	print "# unknown class '" & print s & print "' while instantiating " &
	Prefix.prefix_path(Exp.IDENT(n),pre) => n' &
	Exp.path_string(n') => ns &
	print ns & print "\n"
	--------------------------
	inst_element(env,_,pre,
		     Absyn.ELEMENT(_,n,Absyn.COMPONENTS(_,_,_,_,_,t,_)))
         => ([],env)

end

and inst_classpart: (Env.Env,Mod,Prefix,Absyn.ClassPart)
	  => (DAE.DAEcomp list,Env.Env) =

  rule	inst_list(env,mods,pre,inst_element,l) => (dae,env')
	-------------------------------------------
	inst_classpart(env,mods,pre,Absyn.PUBLIC(l)) => (dae,env')

  rule	print "FOO\n" & inst_list(env,mods,pre,inst_element,l) => (dae,env') & print "BAR\n"
	-------------------------------------------
	inst_classpart(env,mods,pre,Absyn.PROTECTED(l)) => (dae,env')

  rule	print "No algorithms yet\n" & fail
	----------------------------------
	inst_classpart(env,mods,pre,Absyn.ALGORITHMS(l)) => ([],env)

  rule	inst_list(env,mods,pre,inst_equation,el) => (dae,el')
	------------------------------------
	inst_classpart(env,mods,pre,Absyn.EQUATIONS(el)) => (dae,el')

end

and inst_classdef: (Env.Env, Mod, Prefix, Absyn.ClassDef)
	  => (DAE.DAEcomp list, Env.Env) =

  rule	inst_list(env,mods,pre,inst_classpart,pl) => (dae,env')
	------------------------------------------------
	inst_classdef(env,mods,pre, Absyn.PARTS(pl)) => (dae,env')

  rule	Mod.build(SOME(Absyn.CLASSMOD(m)), false) => mod &
	Env.lookup_class(env,cn) => (c,m) &
	(* FIXME order *)
	Mod.merge(mods,m) => mods' &
	Mod.merge(mods',mod) => mods'' &
	inst_class_in(env, mods'', pre, c) => (dae,env)
	----------------------------------------
	inst_classdef(env,mods,pre, Absyn.DERIVED(cn,ad,m)) => (dae,env)

end

and inst_class_in: (Env.Env, Mod, Prefix, Absyn.Class)
	  => (DAE.DAEcomp list, Env.Env) =

  rule	print " instantiating " & print n & print "\n" &
	inst_classdef(env,mods,pre,d) => (l,env')
	------------------------------------------------------	
	inst_class_in(env,mods,pre,c as Absyn.CLASS(n,false,r,d)) => (l,env')

  rule	print "Can't instantiate partial class " & print n & print "\n" &
	fail
	------------------------------------------------------	
	inst_class_in(env,mod,pre, Absyn.CLASS(n,true,_,_))
	  => ([],Env.empty_env)

	(* FIXME *)
  rule  print "# Fallthru in inst_class_in\n"
	----------------------------------
	inst_class_in(_,_,_,_) => ([],Env.empty_env)

end

and inst_class: (Env.Env, Mod, Prefix, Absyn.Class) => DAE.DAEcomp list =

  rule	Env.new_frame(env) => env' &
	inst_class_in(env', mod, pre, c) => (dae,_)
	-------------------------------------------
	inst_class(env, mod, pre, c) => dae

end

relation inst_program : (Env.Env, Absyn.Program) => DAE.DAEcomp list =

  rule	print "Empty program\n" & fail
	------------------------------
	inst_program(env,[]) => []

  rule	Env.extend_frame_c(env,c,Mod.NOMOD) => env' &
	inst_class(env',Mod.NOMOD,[],c) => l
	-----------------------------
	inst_program(env,[c]) => l

  rule	Env.extend_frame_c(env,c,Mod.NOMOD) => env' &
	inst_program(env',cs) => l
	----------------------
	inst_program(env,c::cs) => l

end

relation instantiate: Absyn.Program => DAE.DAEform =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l
	-----------------------------
	instantiate(p) => DAE.DAE(l)

end
