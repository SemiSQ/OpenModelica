(**
 ** file:	 inst.rml
 ** description: Model instantiation
 **
 ** RCS: $Id$
 **
 ** This module exports only one relation. *)

module Inst:

  with "explode.rml"
  with "dae.rml"

  relation instantiate: SCode.Program => DAE.DAElist

end

(** Other modules used by this module *)

with "exp.rml"
with "algorithm.rml"
with "values.rml"
with "absyn.rml"
with "prefix.rml"
with "env.rml"
with "lookup.rml"
with "builtin.rml"
with "dump.rml"
with "types.rml"
with "connect.rml"
with "classinf.rml"
with "staticexp.rml"
with "mod.rml"
with "rtopts.rml"

(** These type aliases are introduced to make the code a little more
 ** readable.
 ** FIXME: maybe they should be removed? *)

type Prefix = Prefix.Prefix
type Mod = Mod.Mod
type Ident = Exp.Ident
type Env = Env.Env


(** relation: new_ident
 **
 ** This relation creates a new, unique identifer.  The same name is
 ** never returned twice.
 **)

relation new_ident : () => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append("__TMP__",is) => s
	-----------------------------------------------------------------
	new_ident => Exp.CREF_IDENT(s,[])

end


(** relation: select
 **
 ** This utility relation selects one of two objects depending on a
 ** boolean variable.
 **)

relation select : (bool, 'a, 'a) => 'a =

  axiom	select (true,x,_) => x
  axiom	select (false,_,x) => x

end

(** relation: instantiate
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAElist =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l
	-----------------------------
	instantiate(p) => DAE.DAE(l)

end

(** relation: inst_program
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'
 **)

relation inst_program : (Env, SCode.Program) => DAE.Element list =

  rule	print "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail

  rule	(* Env.extend_frame_c(env,c) => env' & *)
	inst_class(env,Mod.NOMOD,Prefix.NOPRE,[],c) => (dae,csets,_,_)
	-----------------------------
	inst_program(env,[c as SCode.CLASS(n,_,_,_)])
	  => [DAE.COMP(n,DAE.DAE(dae))]

  rule	inst_class_decl(env,Mod.NOMOD,Prefix.NOPRE,[],c) => (env',dae1) &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_program(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	----------------------
	inst_program(env,c::(cs as (_::_))) => dae

end

(** relation: inst_class
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class: (Env, Mod, Prefix, Connect.Sets, SCode.Class)
	  => (DAE.Element list, Connect.Sets, Types.Type, ClassInf.State) =

  rule	print "# Can't instantiate partial class " & print n & print "\n"
	------------------------------------------------------	
	inst_class(env,mod,pre, csets, SCode.CLASS(n,true,_,_)) => fail

  rule	Env.open_scope(env) => env' &
	ClassInf.start(r,n) => ci_state &
	inst_class_in(env', mod, pre, csets, ci_state, c, false)
	  => (dae1,_,csets',ci_state', tys) &
	Connect.print_sets csets' &
	Connect.equations csets' => dae2 &
	list_append(dae1, dae2) => dae &
	mktype(ci_state',tys) => ty
	-------------------------------------------
	inst_class(env, mod, pre, csets, c as SCode.CLASS(n,_,r,_))
	  => (dae, [], ty,ci_state')

  rule	print "- inst_class " & print n & print " failed\n"
	-----------------------------------------------------
	inst_class(_,_,_,_,SCode.CLASS(n,_,_,_)) => fail
	
end

(** relation: inst_class_in
 **
 ** This rule instantiates the contents of a class definition, with a
 ** new environment already setup.
 **
 ** FIXME: This relation is just a wrapper around `inst_classdef', and could probably be removed.
 **)

relation inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  rule	print " instantiating " & print n & print "\n" &
	inst_classdef(env,mods,pre,csets,ci_state,d,r,prot)
	  => (l,env', csets', ci_state', tys) &
	print " " & print n & print " has state " &
 	ClassInf.print_state ci_state' & print "\n"
	-------------------------------------------
	inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,r,d), prot)
	  => (l,env', csets', ci_state', tys)

	(* FIXME *)
  rule  print "- inst_class_in failed\n"
	----------------------------------
	inst_class_in(_,_,_,csets,_,_,_) => fail

end

(** relation: inst_classdef
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 **)

relation inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, Absyn.Restriction, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)

	(** FIXME: propagate prot *)
  rule	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state' &
	inst_element_list(env,mods,pre,csets,ci_state', els)
	  => (dae1,env', csets', ci_state'', tys) &
	inst_list(env',mods,pre,csets',ci_state'',inst_equation, eqs)
	  => (dae2,env'',csets'', ci_state''') &
	inst_list(env'',mods,pre,csets'',ci_state''', inst_algorithm, als)
	  => (dae3,env''',csets''', ci_state'''') &
	list_append(dae1,dae2) => dae5 &
	list_append(dae5,dae3) => dae
	-----------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,als), re, prot)
	  => (dae,env''', csets''', ci_state'''', tys)

	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,r,_)) &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	print " deriving from " & Absyn.print_restr r & print " : " &
	ClassInf.print_state new_ci_state & print "\n" &
	(* FIXME order *)
	Mod.merge(mods,m) => mods' &
	Mod.merge(mods',mod') => mods'' &
	inst_class_in(env, mods'', pre, csets, new_ci_state, c, prot)
	  => (dae,env, csets', ci_state', tys) &

	print "  " & ClassInf.print_state ci_state' & print "\n" &
	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot)
	  => (dae,env, csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn) => _ &
	Absyn.path_string(cn) => cns &
	print "# unknown class: " & print cns & print "\n"
	----------------------------------------
	inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot)
	  => fail

  rule	print "- inst_classdef failed\n"
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_) => fail

end	

(** relation: inst_element_list
 **
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 **)

relation inst_element_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			      SCode.Element list)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  axiom inst_element_list(env,_,_,csets,ci_state,[])
	  => ([], env, csets, ci_state, [])

  rule  inst_element(env,mod,pre,csets,ci_state,el)
	  => (dae1,env',csets',ci_state',tys1) &
	inst_element_list(env',mod,pre,csets',ci_state',els)
	  => (dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_element_list(env,mod,pre,csets,ci_state,el::els)
	  => (dae, env'', csets'', ci_state'', tys)

  rule	print "- inst_element_list failed\n"
	------------------------------------
	inst_element_list(_,_,_,_,_,_) => fail

end

(** relation: inst_element
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 **)

relation inst_element : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Element)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(**  extends
	 **
	 ** Handle "extends" elements by instantiating the class definition
	 ** of the extended class.
	 **)
	 
  rule	Absyn.path_string(cn) => cns &
	print "  extending class " & print cns & print "\n" &
	
	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,restr,def)) &
	Mod.lookup_modification_p(mods,cn) => classmod &
	Mod.elab_mod(env,pre,m) => m' &

	(* Build the combind set of modifications *)
	(* classmod is the modifications stored with the class *)
	(* mods     is the modifications passed to the relation *)
	(* m        is the modification stored in the element *)
	(* FIXME: verify order *)
	(* print "  mod 1: " & print cns & Mod.print_mod classmod & print "\n" &
	   print "  mod 2: " & print cns & Mod.print_mod mods & print "\n" &
	   print "  mod 3: " & print cns & Mod.print_mod m' & print "\n" & *)
	Mod.merge(classmod,mods) => mods' &
	Mod.merge(mods',m') => mods'' &
	
	(* Can't use inst_class, as that creates a new frame *)
	inst_class_in(env,mods'',pre,csets,ci_state,c,false(*FIXME: FOO?*))
	  => (dae,env',csets',ci_state',vars)
	----------------------------------
	inst_element(env,mods,pre,csets, ci_state, SCode.EXTENDS(cn,m))
	  => (dae,env',csets',ci_state',vars)
	
  	(**  Rules to catch redeclarations and name collsions
	 **)
	 
	 (* If a variable is declared multiple times, the first is used *)
  rule	Lookup.lookup_ident_local(env,n) => _ &
	print " ignoring shadowed variable " & print n & print "\n"
	--------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,_,_))
	  => ([],env,csets,ci_state,[])
	
  	(* Illegal redeclarations *)
  rule	Lookup.lookup_ident_local(env,n) => _ &
	print "Trying to redeclare the class " & print n &
	print " as a variable\n"
	------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.CLASSDEF(n,_,_,_))
	  => fail

  rule	Lookup.lookup_class(env,Absyn.IDENT(n)) => v &
	print "Trying to redeclare the variable " & print n &
	print " as a class\n"
	---------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,_,_,_,_,_))
	  => fail

        (**  A new class definition
	 **
	 ** Put it in the current frame in the environment
	 **)
   
  rule	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) => classmod &
	inst_class_decl(env,classmod,pre,csets,c) => (env',dae)
	-------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state, SCode.CLASSDEF(n,_,_,c))
	  => (dae,env',csets,ci_state,[])

	(**  A variable
	 **
	 ** This is the rule for instantiating a model component.  A
	 ** component can be a structured subcomponent or a variable,
	 ** parameter or constant.  All of these are treated in a
	 ** similar way.
	 **
	 ** FIXME: doc
	 ** Lookup the class name, apply modifications and add the
	 ** variable to the current frame in the environment. Then
	 ** instantiate the class with an extended prefix.
	 **)

  rule	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &

	print " variable " & Exp.print_component_ref vn & print "\n" &
	(** FIXME: merge order *)

	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)

	Lookup.lookup_class(env,t) => cl &
	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.elab_mod(env,pre,m) => m' &
	(* print "  mod 1: " & Mod.print_mod classmod & print "\n" &
	   print "  mod 2: " & Mod.print_mod mm & print "\n" &
	   print "  mod 3: " & Mod.print_mod m' & print "\n" & *)

	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m') => mod' &
	print "  modification: " & Mod.print_mod mod' & print "\n" &

	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm, vn) &

	Mod.mod_equation mod' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	elab_arraydim(env,ad,eq) => dims &

	(** Instantiate the component *)
	inst_var(env,mod',pre,csets,n,cl,attr,eq,dims,[])
	  => (dae1,csets',ty) &

	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env,attr,eq,cl) => binding &
	Env.extend_frame_v(env,Types.VAR(n,attr,prot,ty,binding)) => env' &
	print " extended frame with variable " & Exp.print_component_ref vn &
	print " :: " & Types.print_type ty & print "\n" &

	(** If the modification includes an equation, it is added. *)
	(* FIXME: use env or env'? *)
	(* inst_mod_equation(env',pre,n,ty,mod') => dae2 & *)

	(** If the type is one of the simple, predifined types a *)
	(** simple variable declaration is added to the DAE. *)
	(* dae_declare (vn,cl,attr) => dae3 & *)

	let dae = dae1
	(*list_append(dae1, dae2) => dae4 &
	list_append(dae4, dae3) => dae*)
	-----------------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m))
          => (dae, env',csets',ci_state,
	      [Types.VAR(n,SCode.ATTR([(* FIXME: why? *)],flow,acc,param,dir),
			 prot, ty, binding)])
	

	(** If the class lookup in the previous rule fails, this
	 ** rule catches the error and prints an error message about
	 ** the unknown class. 
	 **)

	(**  Failure *)
  rule	not Lookup.lookup_class(env,t) => cl &
	Absyn.path_string(t) => s &
	print "# unknown class '" & print s & print "' while instantiating " &
	Prefix.prefix_path(Absyn.IDENT(n),pre) => n' &
	Absyn.path_string(n') => ns &
	print ns & print "\n"
	--------------------------
	inst_element(env,_,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,t,_))
         => ([],env,csets,ci_state,[])

  rule	Prefix.prefix_path(Absyn.IDENT(n),pre) => n' &
	Absyn.path_string(n') => ns &
	print "- inst_element COMPONENT(" & print ns & print ") failed\n"
	-----------------------------------------------------------------
	inst_element(_,_,pre,_,_,SCode.COMPONENT(n,_,_,_,_,_))
         => fail

end	

(** relation: inst_var *)

relation inst_var : (Env.Env,Mod.Mod,Prefix.Prefix,Connect.Sets,Ident,
		     SCode.Class,SCode.Attributes,Mod.EqMod option,
		     int list, int list)
	  => (DAE.Element list,Connect.Sets,Types.Type) =

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)

  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	(** FIXME: Redeclarations! *)
	inst_class(env,mod,pre',csets,cl) => (dae1,csets',ty,st) &

	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	inst_mod_equation(cr,ty,mod) => dae2 &
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir)) => dae3 &

	list_append(dae1,dae2) => daex &
	list_append(daex,dae3) => dae
	--------------------------
	inst_var(env,mod,pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt,dir),
		 eq,[],idxs)
          => (dae,csets',ty)

  rule	inst_array(env,mod,pre,csets,n,(cl,attr),1,dim,dims,idxs)
	  => (dae, csets', ty) &
	Types.lift_array(ty,SOME(dim)) => ty'
	-------------------------------
	inst_var(env,mod,pre,csets,n,cl,attr,eq,dim::dims,idxs)
          => (dae,csets',ty')

  rule	print "- inst_var failed: " & print n & print "\n"
	--------------------------------------------------
	inst_var(_,_,_,_,n,_,_,_,_,_) => fail
	
end

(**)

relation inst_array : (Env.Env,Mod.Mod,Prefix.Prefix,Connect.Sets,Ident,
		       (SCode.Class*SCode.Attributes),int,int,int list,int list)
	  => (DAE.Element list,Connect.Sets,Types.Type) =

  rule	int_gt(i,stop) => true
	----------------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,stop,dims,idxs)
	  => ([], csets, Types.T_NOTYPE)

  rule	Mod.lookup_idx_modification(mod,i) => mod' &
	print "  modification[]: " & Mod.print_mod mod' & print "\n" &
	inst_var(env,mod',pre,csets,n,cl,attr,NONE(*FIXME*),dims,i::idxs)
	  => (dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,mod,pre,csets',n,(cl,attr),i',stop,dims,idxs)
	  => (dae2, csets'',_) &

	list_append(dae1,dae2) => dae
	-----------------------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,stop,dims,idxs)
          => (dae,csets'',ty)

  rule	print "- inst_array failed: " & print n & print "\n"
	--------------------------------------------------
	inst_array(_,_,_,_,n,(_,_),_,_,_,_) => fail
	
end

(** relation: elab_arraydim
 **
 ** This relations examines both an `Absyn.ArrayDim' and an `Mod.EqMod
 ** option' argument to find out the dimensions af a component.  If
 ** no equation modifications is given, only the declared dimension is
 ** used.
 **
 ** When the size of a dimension in the type is undefined, the
 ** corresponding size in the type of the modification is used.
 **
 ** All this is accomplished by examining the two arguments separately
 ** and then using `complete_arraydime' or `compatible_arraydim' to
 ** check that that the dimension sizes are compatible and complete.
 **)

relation elab_arraydim : (Env.Env, Absyn.ArrayDim, Mod.EqMod option)
	  => int list =

  rule	elab_arraydim_decl(env,ad) => dim &
	complete_arraydim(dim) => dim'
	------------------------------
	elab_arraydim(env,ad,NONE) => dim'

  rule	elab_arraydim_decl(env,ad) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3
	---------------------------------
	elab_arraydim(env,ad,SOME((e,Static.PROP(t,c)))) => dim3

  rule	elab_arraydim_decl(env,ad) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	not compatible_arraydim(dim1,dim2) => dim3 &
	print "# Array dimension mismatch\n" &
	print "    expression " & Exp.print_exp e &
	print " has type " & Types.print_type t & print "\n" &
	print "    expected array dimensions [" &
	print_dim dim1 & print "]\n"
	---------------------------------
	elab_arraydim(env,ad,SOME((e,Static.PROP(t,c)))) => fail

  rule	print "- elab_arraydim failed\n"
	-------------------------------------
	elab_arraydim(_,_,_) => fail

end

(** relation: print_dim *)

(*!ignorecode*)
relation print_dim : (int option) list => () =

  rule	print ":"
	---------
	print_dim [NONE]

  rule	int_string x => s & print s
	---------------------------
	print_dim [SOME(x)]

  rule	print ":," & print_dim xs
	-------------------------
	print_dim NONE::xs

  rule	int_string x => s & print s & print "," & print_dim xs
	------------------------------------------------
	print_dim SOME(x)::xs

end
(*!includecode*)

(** relation: elab_arraydim_decl *)

relation elab_arraydim_decl : (Env.Env, Absyn.ArrayDim) => (int option) list =

  axiom	elab_arraydim_decl(_,[]) => []

  rule	elab_arraydim_decl(env,ds) => l
	-------------------------------
	elab_arraydim_decl(env,Absyn.NOSUB::ds) => NONE::l

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(Types.T_INTEGER,true)) &
	Static.ceval(env,e) => Values.INTEGER(i) &
	elab_arraydim_decl(env,ds) => l
	-------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => SOME(i)::l

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(Types.T_INTEGER,false)) &
	print "# Variable array sizes are not allowed\n" &
	print "    expression: " & Exp.print_exp e & print "\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => fail

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(t,_)) &
	print "# Array dimensions must be integer\n" &
	print "    expression: " & Exp.print_exp e &
 	print " (" & Types.print_type t & print ")\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => fail

  rule	print "- elab_arraydim_decl failed\n"
	-------------------------------------
	elab_arraydim_decl(_,_) => fail
	
end

(** relation: complete_arraydim *)

relation complete_arraydim : (int option) list => int list =

  axiom	complete_arraydim [] => []

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim SOME(x)::xs => x::xs'

end

(** relation: elab_arraydim *)

relation compatible_arraydim : ((int option) list,(int option) list)
	  => int list =

  axiom	compatible_arraydim([],[]) => []

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(SOME(x)::xs,NONE::ys) => x::l

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(NONE::xs,SOME(y)::ys) => y::l

  rule	x = y &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(x)::xs,SOME(y)::ys) => x::l

  rule	print "- compatible_arraydim failed\n"
	--------------------------------------
	compatible_arraydim (NONE::_,NONE::_) => fail

end

(** relation: elab_arraydim_type
 **
 ** Find out the dimension sizes of a type.  The second argument is
 ** used to know how many dimensions should be extracted from the
 ** type.
 **)

relation elab_arraydim_type : (Types.Type, Absyn.ArrayDim)
	  => int option list =

  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type(Types.T_ARRAY(Types.DIM(i),t), _::ad) => i::l
	
  axiom	elab_arraydim_type(_,[]) => []

end

(** relation: inst_class_decl
 **
 ** The class definition is instantiated although no variable
 ** is declared with it.  After instantiating it, it is
 ** checked to see if it can be used as a package, and if it
 ** can, then it is added as a variable under the same name as
 ** the class.  This makes it possible to use a unified lookup
 ** mechanism.  And since packages only can contain constants
 ** and class definition, instantiating a package does not do
 ** anything else.
 **)

relation inst_class_decl : (Env.Env, Mod.Mod, Prefix.Prefix,
			    Connect.Sets, SCode.Class)
	  => (Env.Env, DAE.Element list) =

  rule	print "  adding " & print n & print "\n" &
	Env.extend_frame_c(env,c) => env' &
	implicit_instantiation(env',Mod.NOMOD,pre,csets,c) => (env'',dae)

	(*
	Prefix.prefix_add(n,[],pre) => pre' &
	inst_class(env,mod,pre',csets,c) => (dae,csets',ty,st) &
	add_package(env',n,ty,st,dae) => (env'', dae')
	*)
	----------------------------------
	inst_class_decl(env,mod,pre,csets,c as SCode.CLASS(n,_,restr,_))
	  => (env'', dae)

end

(** relation implicit_instantiation
 **
 ** If a class definition is a function or a package, it is implicitly
 ** instantiated and added as a type binding under the same name
 ** as the class name.
 **)

relation implicit_instantiation : (Env.Env, Mod.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class)
	  => (Env.Env, DAE.Element list) =

  rule	Prefix.prefix_add(n,[],pre) => pre' &
	inst_class(env,mod,pre',csets,c) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env'
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_PACKAGE,_))
	  => (env', dae)

  rule	Prefix.prefix_add(n,[],pre) => pre' &
	inst_class(env,mod,pre',csets,c) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env'
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_FUNCTION,_))
	  => (env', (*dae*) [])

  axiom	implicit_instantiation(env,mod,pre,csets,c) => (env,[])

end

(** relation: add_package
 **)

relation add_package : (Env.Env, Absyn.Ident, Types.Type, ClassInf.State,
			DAE.Element list)
	  => (Env.Env, DAE.Element list) =

  rule	ClassInf.valid(st, Absyn.R_PACKAGE) &
	Env.extend_frame_v(env,
			   Types.VAR(n, SCode.ATTR([],
						   false,SCode.RO,Absyn.CONST,
						   Absyn.BIDIR),
				     false,
				     ty,Types.UNBOUND)) => env' &
	print "  added package " & print n & print "\n"
	--------------------------------------------------------
	add_package(env,n,ty,st,dae) => (env',dae)

  axiom	add_package(env,_,_,_,_) => (env,[])

end

(** relation: dae_declare
 **)

relation dae_declare : (Exp.ComponentRef,
			Types.Type, SCode.Attributes) => DAE.Element list =

  rule	dae_declare2 (vn, ty, par) => dae
	-----------------------------------
	dae_declare (vn, ty, SCode.ATTR(_,_,_,par,_)) => dae

  rule	print "- dae_declare failed\n"
	------------------------------
	dae_declare(_,_,_) => fail

end

(**)

relation dae_declare2 : (Exp.ComponentRef, Types.Type, Absyn.Variability)
	  => DAE.Element list =

  rule	dae_declare3 (vn, ty, DAE.VARIABLE) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.VAR) => dae

  rule	dae_declare3 (vn, ty, DAE.DISCRETE) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.DISCRETE) => dae

  rule	dae_declare3 (vn, ty, DAE.PARAM) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.PARAM) => dae

  rule	dae_declare3 (vn, ty, DAE.CONST) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.CONST) => dae

  rule	print "- dae_declare2 failed\n"
	------------------------------
	dae_declare2(_,_,_) => fail

end

(**)

relation dae_declare3 : (Exp.ComponentRef, Types.Type, DAE.VarKind)
	  => DAE.Element list =

  axiom	dae_declare3 (vn, Types.T_INTEGER, kind)
	  => [DAE.VAR(vn, kind, DAE.INT)]
	
  axiom	dae_declare3 (vn, Types.T_REAL, kind)
	  => [DAE.VAR(vn, kind, DAE.REAL)]
	
  axiom	dae_declare3 (vn, Types.T_BOOL, kind)
	  => [DAE.VAR(vn, kind, DAE.BOOL)]
	
  axiom	dae_declare3 (vn, Types.T_STRING, kind)
	  => [DAE.VAR(vn, kind, DAE.STRING)]

  rule	print "  not declaring variable " &
	Exp.print_component_ref c & print " :: " &
	Types.print_type ty & print "\n"
	--------------------------------------
	dae_declare3 (c,ty,_) => []

end

(** relation: inst_equation
 **)

relation inst_equation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

	(**  connect
	 **
	 ** Handle connct statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2) => csets' &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------------
	inst_equation(env,mods,pre, csets, ci_state, SCode.EQ_CONNECT(c1,c2))
	  => ([],env,csets',ci_state')
	  
	(**  assert
	 **
	 ** FIXME: Handle assertions
	 **)

  rule	Static.elab_exp(env,e) => (e', Static.PROP(t, c)) &
	inst_assertion (env, e', t, c, d, pre) => dae &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	--------------------------------------------------------------
	inst_equation(env,mods,pre,csets, ci_state,
		      SCode.EQ_EXPR(Absyn.CALL(Absyn.CREF_IDENT("assert",[]),
					       [e,Absyn.STRING(d)])))
	  => (dae,env,csets,ci_state')

  rule	print "- No expression equations yet\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,SCode.EQ_EXPR(_)) => fail

  rule	Lookup.lookup_ident_local(env,n)
	  => Types.VAR(_,_,_,_,Types.EQBOUND(_,_)) &
	print " shadowed equation for " & print n & print "\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,
		      SCode.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2))
	  => ([],env,csets,ci_state')

  rule	print " equation\n" &
	Static.elab_exp(env,e1) => (e1',prop1) &
	Static.elab_exp(env,e2) => (e2',prop2) &
	Prefix.prefix_exp(env,e1',pre) => e1'' &
	Prefix.prefix_exp(env,e2',pre) => e2'' &
	inst_eq_equation(e1'',prop1,e2'',prop2) => dae &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	--------------------------------------------------------------
	inst_equation(env, mods, pre, csets, ci_state, SCode.EQ_EQUALS(e1,e2))
	  => (dae, env, csets, ci_state')

	(**  `if' statements
	 **
	 **)

  rule	Static.elab_exp(env,e) => (e',Static.PROP(Types.T_BOOL,true)) &
	Static.ceval(env,e') => Values.BOOL(cond) &
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_equation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb))
	  => (dae,env',csets', ci_state')

	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **)

  rule	Static.elab_exp (env,e)
	  => (e',Static.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER),
			     true)) &
	(* FIXEM: Check bounds *)
	Static.ceval (env,e') => v &
	print "  Unrolling " & print i & print " in " &
 	Dump.print_exp e & print " = " &
 	Values.print_val v & print "\n" &
	unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el))
	  => (dae, env,csets', ci_state')

  rule	print "- inst_equation failed\n"
	----------------------------------
	inst_equation(_,_,_,_,_,_) => fail

end

(** relation: inst_eq_equation
 **
 ** Equations follow the same typing rules as equality expressions.
 ** This relation adds the equation to the DAE.
 **
 ** FIXME: type conversions (use Static.match_prop)
 **)

relation inst_eq_equation : (Exp.Exp, Static.Properties,
			     Exp.Exp, Static.Properties) => DAE.Element list =

  rule	Static.match_prop(e1, p1, p2) => e1' &
	inst_eq_equation_2(e1', e2, t2) => dae
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP(t1,_),
			 e2,p2 as Static.PROP(t2,_))
	  => dae
	
  rule	Static.match_prop(e2, p2, p1) => e2'&
	inst_eq_equation_2(e1, e2', t1) => dae
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP(t1,_),
			 e2,p2 as Static.PROP(t2,_))
	  => dae
	
  rule	(* Types.equivtypes(t1,t2) => false & *)
	print "# Illegal types in equation\n"&
	print "    lhs: " & Exp.print_exp e1 &
	print " :: " & Types.print_type t1 & print "\n" &
	print "    rhs: " & Exp.print_exp e2 &
	print " :: " & Types.print_type t2 & print "\n"
	----------
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2,Static.PROP(t2,_)) => fail

end

(** relation: inst_eq_equation_2
 **
 ** FIXME: doc
 **)

relation inst_eq_equation_2 : (Exp.Exp, Exp.Exp, Types.Type)
	=> DAE.Element list =

  axiom	inst_eq_equation_2(e1,e2,Types.T_INTEGER)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_REAL)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_STRING)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_BOOL)
	=> [DAE.EQUATION(e1,e2)]

  rule	RTOpts.split_arrays => true &
	inst_array_equation(e1,e2,ad,t) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t)) => dae

  rule	RTOpts.split_arrays => false
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t))
	  => [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1, e2, Types.T_COMPLEX(_,[])) => []

  rule	Exp.extend_cref(c1,n,[]) => c1' &
	Exp.extend_cref(c2,n,[]) => c2' &
	inst_eq_equation_2(Exp.CREF(c1'), Exp.CREF(c2'), t) => dae1 &
	inst_eq_equation_2(Exp.CREF(c1), Exp.CREF(c2),
			   Types.T_COMPLEX(cs,vs)) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_eq_equation_2(Exp.CREF(c1), Exp.CREF(c2),
			   Types.T_COMPLEX(cs,Types.VAR(n,_,_,t,_)::vs)) => dae

	(** When the type of the expressions is a complex type, and *)
	(** the left-hand side of the equation is not a component *)
	(** reference, a new variable is introduced to be able to *)
	(** dereference components of the expression. *)
	(** *)
	(** This is rather ugly, since it doesn't really solve the *)
	(** problem of describing the semantics.  Now the semantics of *)
	(** composite equations are defined in terms of other *)
	(** composite equations.  To make this a little cleaner, the *)
	(** equation that equates the new name to the expression is *)
	(** stored using DAE.DEFINE rather than DAE.EQUATION.  This *)
	(** makes it a little clearer. *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     Absyn.VAR, Absyn.BIDIR))
	  => decl &
	inst_eq_equation_2(Exp.CREF(n), e2, t) => dae1 &
	list_append(decl, DAE.DEFINE(n, e1)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2 as Exp.CREF(_),
			   t as Types.T_COMPLEX(_,_)) => dae

	(** When the right-hand siade is not a component reference a *)
	(** similar trick is applied.  This also catched the case *)
	(** where none of the sides is a component reference *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     Absyn.VAR, Absyn.BIDIR))
	  => decl &
	inst_eq_equation_2(e1, Exp.CREF(n), t) => dae1 &
	list_append(decl, DAE.DEFINE(n, e2)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2, t as Types.T_COMPLEX(_,_)) => dae

  rule	print "- inst_eq_equation_2 failed\n"
	-------------------------------------
	inst_eq_equation_2(_,_,_) => fail

end

(** relation: inst_array_equation
 **
 ** FIXME: doc
 **)

relation inst_array_equation : (Exp.Exp, Exp.Exp,
				Types.ArrayDim, Types.Type)
	  => DAE.Element list =

  rule	print "# Cannot instantiate equations with arrays of unknown size\n" &
	print "    " & Exp.print_exp e1 & print " = " & Exp.print_exp e2&
	print "\n"
	----------
	inst_array_equation(e1, e2, Types.DIM(NONE), t) => fail

  rule	inst_array_el_eq(e1, e2, t, 1, sz) => dae
	---------------------------------------------
	inst_array_equation(e1, e2, Types.DIM(SOME(sz)), t) => dae

  rule	print "- inst_array_equation failed\n"
	--------------------------------------
	inst_array_equation (_,_,_,_) => fail

end

(** relation: inst_array_el_eq
 **
 ** FIXME: doc
 **)

relation inst_array_el_eq : (Exp.Exp, Exp.Exp, Types.Type, int, int)
	  => DAE.Element list =

  rule	int_le(i,sz) => true &
	Exp.simplify(Exp.ASUB(e1,i)) => e1' &
	Exp.simplify(Exp.ASUB(e2,i)) => e2' &
	inst_eq_equation_2(e1',e2',t) => dae1 &
	int_add(i,1) => i' &
	inst_array_el_eq(e1,e2,t,i',sz) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_array_el_eq(e1, e2, t, i, sz) => dae

  rule	int_le(i,sz) => false
	---------------------
	inst_array_el_eq(e1, e2, t, i, sz) => []

  rule	print "- inst_array_el_eq failed\n"
	-----------------------------------
	inst_array_el_eq(_,_,_,_,_) => fail

end

(** relation: inst_assertion
 **
 ** Instantiate an assertion.
 **)

relation inst_assertion : (Env.Env, Exp.Exp, Types.Type,
			   bool, string, Prefix)
	  => DAE.Element list =

  rule	Prefix.prefix_exp(env,e,pre) => e' &
	print " (constant) ASSERTION(" & Exp.print_exp e' & print "): " &
	print d & print "\n"
	--------------------
	inst_assertion (env, e, Types.T_BOOL, true, d, pre) => [(*FIXME*)]

  rule	Prefix.prefix_exp(env,e,pre) => e' &
	print " ASSERTION(" & Exp.print_exp e' & print "): " &
	print d & print "\n"
	--------------------
	inst_assertion (env, e, Types.T_BOOL, _, d, pre) => [(*FIXME*)]

  rule	print "# Assertions have to be of type Boolean\n" &
	print "  assertion: (" &
	Prefix.prefix_exp(env,e,pre) => e' & Exp.print_exp e' & print "): " &
 	print d & print "\n"
	-----------------------------
	inst_assertion (env, e, _, _, d, pre) => fail
	
end

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, SCode.Equation list)
	  => (DAE.Element list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_) => ([], csets)

  rule	print "   unroll: " & Values.print_val fst & print "\n" &
	Env.open_scope env => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, SCode.ATTR([],
						    false,
						    SCode.RO,
						    Absyn.CONST,
						    Absyn.BIDIR),
				      true,
				      Types.T_INTEGER,
				      Types.VALBOUND(fst))) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_equation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs)
	  => (dae, csets'')

  rule	print "- unroll " & Values.print_val v & print " failed\n"
	-------------------------
	unroll (_,_,_,_,_,_,v,_) => fail

end

(** relation: inst_algorithm
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_statements(env,statements) => statements'
	----------------------------------------------
	inst_algorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements))
	  => ([DAE.ALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	print "- inst_algorithm failed\n"
	---------------------------------
	inst_algorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_statements *)

relation inst_statements : (Env, Absyn.Algorithm list)
	  => Algorithm.Statement list =

  axiom	inst_statements(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_statements(env,xs) => xs'
	------------------------------
	inst_statements(env,x::xs) => x'::xs'

end

(** relation: inst_statement *)

relation inst_statement : (Env, Absyn.Algorithm) => Algorithm.Statement =

  rule	Static.elab_cref (env,cr) => (ce, cprop, acc) &
	Static.elab_exp (env,e) => (e', eprop) &
	Algorithm.make_assignment(ce,cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e)) => stmt

  rule	Static.elab_exp(env,e) => (e',prop) &
	inst_statements(env,tb) => tb' &
	inst_elseifs(env,eib) => eib' &
	inst_statements(env,fb) => fb' &
	Algorithm.make_if(e',prop,tb',eib',fb') => stmt
	--------------------------------------------
	inst_statement(env,Absyn.ALG_IF(e,tb,eib,fb)) => stmt

  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_for(i,e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_FOR(i,e,sl)) => stmt

  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_while(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHILE(e,sl)) => stmt

  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_when(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN(e,sl)) => stmt

  rule	print "- inst_statement failed\n"
	---------------------------------
	inst_statement(_,_) => fail

end

(** relation: inst_elseifs *)

relation inst_elseifs : (Env.Env, (Absyn.Exp * Absyn.Algorithm list) list)
	=> (Exp.Exp * Static.Properties * Algorithm.Statement list) list =

  axiom	inst_elseifs (env,[]) => []

  rule	Static.elab_exp(env,e) => (e',prop) &
	inst_statements(env,l) => stmts &
	inst_elseifs(env,tail) => tail'
	-------------------------------
	inst_elseifs(env,(e,l)::tail) => ((e',prop,stmts)::tail')

  rule	print "- inst_elseifs failed\n"
	-------------------------------
	inst_elseifs(_,_) => fail

end

(**)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef)
	  => Connect.Sets =

  rule	print " connecting " &
	Dump.print_component_ref(c1) & print " with " &
	Dump.print_component_ref(c2) & print "\n" &
	Static.elab_cref(env, c1) => (Exp.CREF(c1'),prop1,acc) &
	Static.elab_cref(env, c2) => (Exp.CREF(c2'),prop2,acc) &
	Static.canon_cref(env, c1') => c1'' &
	Static.canon_cref(env, c2') => c2'' &
	Lookup.lookup_var_local(env,c1'')
	  => (SCode.ATTR(_,flow1,_,vt1,_),ty1,_) &
	Lookup.lookup_var_local(env,c2'')
	  => (SCode.ATTR(_,flow2,_,vt2,_),ty2,_) &
	print "  looked up connectors\n" &

	(** Check that the types of the connectors are good. *)
	valid_connector(ty1) &
	valid_connector(ty2) &
	check_connect_types(c1'',ty1,vt1,flow1,c2'',ty2,vt2,flow2) &
	print "  they are valid connectors\n" &

	component_face(c1'') => f1 &
	component_face(c2'') => f2 &
	connect_components(sets, pre, c1'', f1, ty1, c2'', f2, ty2, flow1)
	  => sets'
	---------------------------------
	inst_connect(sets, env,pre,c1,c2) => sets'

  rule	print "# could not connect\n"
	---------------------------------
	inst_connect(sets,_,_,_,_) => fail

end

(** relation: valid_connector
 **
 ** This relation tests whether a type is a eligible to be used in
 ** connections.
 **
 ** FIXME: It is unknown whether `Real' is a valid connector.
 **)

relation valid_connector : Types.Type => () =

  axiom	valid_connector Types.T_REAL

  rule	ClassInf.valid(state,Absyn.R_CONNECTOR)
	---------------------------------------
	valid_connector Types.T_COMPLEX(state,_)

  rule	print "# Can't connect objects of type " &
	Types.print_type t & print "\n"
	-------------------------------
	valid_connector t => fail
end

(** relation: check_connect_types
 **
 ** Check that the type and type attributes of two connectors match,
 ** so that they really may be connected.
 **
 ** FIXME: This checks the `flow' attribute on the top variable. This depends on whether connections are allowed on Reals.
 **)

relation check_connect_types : (Exp.ComponentRef, Types.Type,
				Absyn.Variability, bool,
			       	Exp.ComponentRef, Types.Type,
				Absyn.Variability, bool) => () =

  rule	flow1 = flow2 &
	Types.equivtypes(t1, t2) => true
	-------------------------------
	check_connect_types(_,t1,_,flow1,_,t2,_,flow2)

  rule	print "# Can't connect flow component " &
 	Exp.print_component_ref c1 &
	print " to non-flow component " &
 	Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,_,true,c2,_,_,false) => fail

  rule	print "# Can't connect non-flow component " &
 	Exp.print_component_ref c1 &
	print " to flow component " &
 	Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,_,false,c2,_,_,true) => fail

  rule	print "- check_connect_types(" & Exp.print_component_ref c1 &
	print " <-> " & Exp.print_component_ref c2 & print ") failed\n"
	------------------------------------------------------
	check_connect_types(c1,_,_,_,c2,_,_,_) => fail

end

(** relation: connect_components
 **
 ** This relation connects two components and generates connection
 ** sets along the way.  For simple components (of type `Real') it
 ** adds the components to the set, and for complex types it traverses
 ** the subcomponents and recursively connects them to each other.
 **)

relation connect_components: (Connect.Sets,
			      Prefix,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      bool) => Connect.Sets =
	
	(**  Flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	print "  connect_components flow: " &
	Exp.print_component_ref c1' & print " <-> " &
	Exp.print_component_ref c2' &
	print "\n" &
	Connect.add_flow(sets, c1', f1, c2', f2) => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, f1, Types.T_REAL,
			   c2, f2, Types.T_REAL, true) => sets'
	
	(**  Non-flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	print "  connect_components non-flow: " &
	Exp.print_component_ref c1' & print " <-> " &
	Exp.print_component_ref c2' &
	print "\n" &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, _, Types.T_REAL,
			   c2, _, Types.T_REAL, false) => sets'

	(**  Complex types *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	print "  connect_components 2: " &
	Exp.print_component_ref c1' & print " <-> " &
	Exp.print_component_ref c2' &
	print "\n" &
	connect_vars(sets,c1',f1,l1,c2',f2,l2) => sets'
	----------------------------------------
	connect_components(sets,pre,c1,f1, Types.T_COMPLEX(_,l1),
			   c2,f2, Types.T_COMPLEX(_,l2),_) => sets'

	(**  Error *)
	
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	print "# Wrong type in connection\n"&
 	print "  while making connectiion " &
	Exp.print_component_ref c1 & print " <-> " &
	Exp.print_component_ref c2 & print "\n" &
	print "  The type `" & Types.print_type t1 &
	print "' is not allowed in connections\n"
	----------------------------------------
	connect_components(_,pre,c1,_,t1,c2,_,t2,_) => fail
	
end

(** relation: connect_vars
 **
 ** This relation connects two subcomponents by adding the component
 ** name to the current path and recursively connecting the components
 ** using the relation `connet_components'.
 **)

relation connect_vars : (Connect.Sets,
			 Exp.ComponentRef, Connect.Face, Types.Var list,
			 Exp.ComponentRef, Connect.Face, Types.Var list)
	  => Connect.Sets =

  axiom	connect_vars(sets,_,_,[],_,_,[]) => sets

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	check_connect_types(c1', ty1, vt1, flow1, c2', ty2, vt2, flow2) &
	(* print "  connect_vars: " &
	 * Dump.print_component_ref c1' & print " <-> " &
	 * Dump.print_component_ref c2' &
	 * print "\n" & *)
	connect_components(sets,Prefix.NOPRE,
			   c1',f1, ty1,
			   c2',f2, ty2, flow1) => sets' &
	connect_vars(sets',c1,f1,xs1,c2,f2,xs2) => sets''
	--------------------------------------
	connect_vars(sets,
		     c1,f1, Types.VAR(n,SCode.ATTR(_,flow1,_,vt1,_),
				      _,ty1,_)::xs1,
		     c2,f2, Types.VAR(_,SCode.ATTR(_,flow2,_,vt2,_),
				      _,ty2,_)::xs2)
	  => sets''

end

(**)

relation mktype : (ClassInf.State,Types.Var list) => Types.Type =

  axiom	mktype(ClassInf.TYPE_INTEGER(_),_) => Types.T_INTEGER
  axiom	mktype(ClassInf.TYPE_REAL(_),_)    => Types.T_REAL
  axiom	mktype(ClassInf.TYPE_STRING(_),_)  => Types.T_STRING
  axiom	mktype(ClassInf.TYPE_BOOL(_),_)    => Types.T_BOOL

  axiom	mktype(st,l) => Types.T_COMPLEX(st,l)

end

(**)

relation assert : (bool, bool, string) => () =

  rule  x = y
	-----
	assert(x,y,_)

  rule  not x = y &
	print "# " & print m & print "\n"
	--------------------------------------
	assert(x,y,m)

end

(**)

relation optional_cons : ('a option, 'a list) => 'a list =

  axiom optional_cons(NONE, l) => l

  axiom optional_cons(SOME(x), l) => x::l

end

(**)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list)
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[]) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es)
	  => (l'',env'',csets'',ci_state'')

end

(**)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

  rule	print "# While connecting " &
	Exp.print_component_ref c & print "\n" &
	print "# Only local or child connectors allowed.\n"
	(* FIXME: This only checks the syntactic properties. *)
	---------------------------------------------------
	component_face c => fail

end

(** relation: inst_mod_equation
 **
 ** This relation adds the equation in the declaration of a variable,
 ** if such an equation exists.
 ***)

relation inst_mod_equation : (Exp.ComponentRef, Types.Type, Mod)
	  => DAE.Element list =

  rule  print "  equation modification: " & Exp.print_component_ref cr &
 	Mod.print_mod mod & print "\n" &
	inst_eq_equation(Exp.CREF(cr),Static.PROP(ty1,false(*FIXME*)),
			 e,prop2) => dae
	-----------------------------------------------
	inst_mod_equation(cr,ty1, mod as Mod.MOD(_,_,SOME((e,prop2))))
	  => dae
	  
  axiom inst_mod_equation(_,_,Mod.MOD(_,_,NONE)) => []
  axiom inst_mod_equation(_,_,Mod.NOMOD) => []

  rule	print "- inst_mod_equation failed\n"
	------------------------------------
  	inst_mod_equation (_,_,_) => fail

end

(**)

relation check_prot : (bool, Mod.Mod, Exp.ComponentRef) => () =

  rule  print "  public variable " & Exp.print_component_ref cref & print "\n"
	--------------------------------------------------
	check_prot(false,_,cref)
	
  axiom check_prot(_,Mod.NOMOD,_)

  rule  print "# Trying to modify protected element " &
	Exp.print_component_ref cref & print "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(** relation: make_binding
 **
 ** This relation looks at the equation part of a modification, and if
 ** there is a declaration equation builds a `Types.Binding' for it.
 ** If the component being declared is declared to be constant, the
 ** relation `make_const_binding' is used.
 **
 ** FIXME: Why is the result from make_const_binding ignored?
 **)

relation make_binding : (Env.Env, SCode.Attributes, Mod.EqMod option, SCode.Class)
	  => Types.Binding =

  axiom	make_binding (_,_,NONE,_) => Types.UNBOUND

  rule	print "  constant binding: " & Exp.print_exp e & print "\n" &
	class_type cl => ct &
	make_const_binding (env,e, prop, ct) => binding
	----------------------------------------
	make_binding (env,
		      SCode.ATTR(_,_,_,Absyn.CONST,_),
		      SOME((e,prop)),
		      cl)
	  => (* binding *) Types.EQBOUND(e,true)

	(* default *)

  rule	print "  nonconstant binding: " & Exp.print_exp e & print "\n"
	-----------------------------------------------------------
	make_binding (_,_, SOME((e,Static.PROP(t,c))),_) => Types.EQBOUND(e,c)

  rule	print "- make_binding failed\n"
	-------------------------------
	make_binding(_,_,_,_) => fail

end

(** relation: make_const_binding *)

relation make_const_binding : (Env.Env, Exp.Exp, Static.Properties,
			       Types.Type) => Types.Binding =

  rule	Static.match_prop(e, prop, Static.PROP(ct,true)) => e' &
	Static.ceval (env, e') => v &
	print "  constant expression " & Exp.print_exp e &
 	print " = " & Values.print_val v & print " detected\n"
	---------------------------------
	make_const_binding (env,e,prop as Static.PROP(t,true),ct)
	  => Types.VALBOUND(v)

  rule	print "# Incompatible types in binding\n"
	--------------------------------------
	make_const_binding (env,e,Static.PROP(t,true),ct) => fail

  rule	print "# Non-constant equation for constant\n"
	---------------------------------
	make_const_binding (env,e,Static.PROP(t,false),ct) => fail

  rule	print "- make_const_binding failed\n"
	-------------------------------
	make_const_binding(_,_,_,_) => fail

end

(** relation: class_type *)

relation class_type : SCode.Class => Types.Type =

  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_INT,_) => Types.T_INTEGER
  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_STRING,_)
	  => Types.T_STRING
  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_REAL,_) => Types.T_REAL
  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_BOOL,_) => Types.T_BOOL

	(* FIXME: Should instantiate the class *)
  axiom	class_type _ => Types.T_COMPLEX(ClassInf.UNKNOWN("---"),[(* FIXME *)])

end
