(** file: inst.rml
 **
 ** This module exports only one relation. *)

module Inst:

  with "explode.rml"
  with "dae.rml"

  relation instantiate: SCode.Program => DAE.DAEform

end

(** Other modules used by this module *)

with "exp.rml"
with "values.rml"
with "absyn.rml"
with "prefix.rml"
with "env.rml"
with "lookup.rml"
with "builtin.rml"
with "dump.rml"
with "types.rml"
with "connect.rml"
with "classinf.rml"
with "staticexp.rml"
with "mod.rml"

(** These type aliases are introduced to make the code a little more *)
(** readable. FIXME: maybe they should be removed? *)

type Prefix = Prefix.Prefix
type Mod = SCode.Mod
type Ident = Exp.Ident
type Env = Env.Env


(** relation: instantiate
 ** purpose:  Instantiate a Modelica program
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAEform =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l
	-----------------------------
	instantiate(p) => DAE.DAE(l)

end

(** relation: inst_program
 ** purpose:  Instantiate a Modelica program using a provided environment.
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'
 **)

relation inst_program : (Env, SCode.Program) => DAE.DAEcomp list =

  rule	print "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail

  rule	Env.extend_frame_c(env,c,SCode.NOMOD) => env' &
	inst_class(env',SCode.NOMOD,Prefix.NOPRE,[],c) => (dae,csets,_,_)
	-----------------------------
	inst_program(env,[c]) => dae

  rule	Env.extend_frame_c(env,c,SCode.NOMOD) => env' &
	inst_program(env',cs) => l
	----------------------
	inst_program(env,c::(cs as (_::_))) => l

end

(** relation: inst_class
 ** purpose:  Instantiate a complete class definition.
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class: (Env, Mod, Prefix, Connect.Sets, SCode.Class)
	  => (DAE.DAEcomp list, Connect.Sets, Types.Type, ClassInf.State) =

  rule	print "# Can't instantiate partial class " & print n & print "\n"
	------------------------------------------------------	
	inst_class(env,mod,pre, csets, SCode.CLASS(n,true,_,_)) => fail

  rule	Env.open_scope(env) => env' &
	ClassInf.start(r,n) => ci_state &
	inst_class_in(env', mod, pre, csets, ci_state, c, false)
	  => (dae1,_,csets',ci_state', tys) &
	Connect.print_sets csets' &
	Connect.equations csets' => dae2 &
	list_append(dae1, dae2) => dae &
	mktype(ci_state',tys) => ty
	-------------------------------------------
	inst_class(env, mod, pre, csets, c as SCode.CLASS(n,_,r,_))
	  => (dae, [], ty,ci_state')

  rule	print "- inst_class " & print n & print " failed\n"
	-----------------------------------------------------
	inst_class(_,_,_,_,SCode.CLASS(n,_,_,_)) => fail
	
end

(** relation: inst_class_in
 ** purpose:  Instantiate the contents of a class definition, with a
 ** new environment already setup.
 **
 ** This relation is just a wrapper around `inst_classdef', and could
 ** probably be removed.
 **)

relation inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool)
	  => (DAE.DAEcomp list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  rule	print " instantiating " & print n & print "\n" &
	inst_classdef(env,mods,pre,csets,ci_state,d,r,prot)
	  => (l,env', csets', ci_state', tys)
	------------------------------------------------------	
	inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,r,d), prot)
	  => (l,env', csets', ci_state', tys)

	(* FIXME *)
  rule  print "- inst_class_in failed\n"
	----------------------------------
	inst_class_in(_,_,_,csets,_,_,_) => fail

end

(** relation: inst_classdef
 ** purpose:  Instantiate the contents of a class definition.
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 **)

relation inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, Absyn.Restriction, bool)
	  => (DAE.DAEcomp list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)

	(* FIXME: propagate prot *)
  rule	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state' &
	inst_element_list(env,mods,pre,csets,ci_state', els)
	  => (dae1,env', csets', ci_state'', tys) &
	inst_list(env',mods,pre,csets',ci_state'',inst_equation, eqs)
	  => (dae2,env'',csets'', ci_state''') &
	inst_list(env'',mods,pre,csets'',ci_state''', inst_algorithm, als)
	  => (dae3,env''',csets''', ci_state'''') &
	list_append(dae1,dae2) => dae5 &
	list_append(dae5,dae3) => dae
	-----------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,als), re, prot)
	  => (dae,env''', csets''', ci_state'''', tys)

	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,r,_),_) &
	Mod.lookup_modification_p(mods,cn) => m &
	ClassInf.start(r, cn2) => new_ci_state &
	(* FIXME order *)
	Mod.merge(mods,m) => mods' &
	Mod.merge(mods',mod) => mods'' &
	inst_class_in(env, mods'', pre, csets, new_ci_state, c, prot)
	  => (dae,env, csets', ci_state', tys) &
	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot)
	  => (dae,env, csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn) => (_,_) &
	Absyn.path_string(cn) => cns &
	print "# unknown class: " & print cns & print "\n"
	----------------------------------------
	inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot)
	  => fail

  rule	print "- inst_classdef failed\n"
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_) => fail

end	

(** relation: inst_element_list
 ** purpose:  Instantiate a list of elements
 **
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 **)

relation inst_element_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			      SCode.Element list)
	  => (DAE.DAEcomp list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  axiom inst_element_list(env,_,_,csets,ci_state,[])
	  => ([], env, csets, ci_state, [])

  rule  inst_element(env,mod,pre,csets,ci_state,el)
	  => (dae1,env',csets',ci_state',tys1) &
	inst_element_list(env',mod,pre,csets',ci_state',els)
	  => (dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_element_list(env,mod,pre,csets,ci_state,el::els)
	  => (dae, env'', csets'', ci_state'', tys)

end

(** relation: inst_element
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 **)

relation inst_element: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			SCode.Element)
	  => (DAE.DAEcomp list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(**  extends
	 **
	 ** Handle "extends" elements by instantiating the class definition
	 ** of the extended class.
	 **)
	 
  rule	Absyn.path_string(cn) => cns &
	print "  extending class " & print cns & print "\n" &
	
	Lookup.lookup_class(env,cn)
	  => (c as SCode.CLASS(cn2,_,restr,def), _) &
	Mod.lookup_modification_p(mods,cn) => classmod &

	(* Build the combind set of modifications *)
	(* classmod is the modifications stored with the class *)
	(* mods     is the modifications passed to the relation *)
	(* m        is the modification stored in the element *)
	(* FIXME: verify order *)
	(* print "  mod 1: " & print cns & SCode.print_mod classmod & print "\n" &
	print "  mod 2: " & print cns & SCode.print_mod mods & print "\n" &
	print "  mod 3: " & print cns & SCode.print_mod m & print "\n" & *)
	Mod.merge(classmod,mods) => mods' &
	Mod.merge(mods',m) => mods'' &
	
	(* Can't use inst_class, as that creates a new frame *)
	inst_class_in(env,mods'',pre,csets,ci_state,c,false(*FIXME: FOO?*))
	  => (dae,env',csets',ci_state',vars)
	----------------------------------
	inst_element(env,mods,pre,csets, ci_state, SCode.EXTENDS(cn,m))
	  => (dae,env',csets',ci_state',vars)
	
  	(**  Rules to catch redeclarations and name collsions
	 **)
	 
	 (* If a variable is declared multiple times, the first is used *)
  rule	Lookup.lookup_var_local(env,n) => _ &
	print " ignoring shadowed variable " & print n & print "\n"
	--------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,_,_))
	  => ([],env,csets,ci_state,[])
	
  	(* Illegal redeclarations *)
  rule	Lookup.lookup_var_local(env,n) => _ &
	print "Trying to redeclare the class " & print n &
	print " as a variable\n"
	------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.CLASSDEF(n,_,_,_))
	  => fail

  rule	Lookup.lookup_class(env,Absyn.IDENT(n)) => (v,_) &
	print "Trying to redeclare the variable " & print n &
	print " as a class\n"
	---------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,_,_,_,_,_))
	  => fail

        (**  A new class definition
	 **
	 ** Put it in the current frame in the environment
	 **)
   
  rule	(* SCode.convert(c) => c' & *)
	Mod.lookup_modification(mods,n) => classmod &
	print "  adding " & print n & SCode.print_mod classmod & print "\n" &
	(* Mod.simple_maybe_modify_class(env,mm,pre,c') => (c'',dae) & *)
	Env.extend_frame_c(env,c,classmod) => env'
	----------------------------------------
	inst_element(env,mods,pre,csets,ci_state, SCode.CLASSDEF(n,_,_,c))
	  => ([],env',csets,ci_state,[])

	(**  A variable
	 **
	 ** Lookup the class name, apply modifications and add the
	 ** variable to the current frame in the environment. Then
	 ** instantiate the class with an extended prefix.
	 **)

  rule	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &

	print " variable " & Exp.print_component_ref vn & print "\n" &
	(* FIXME: merge order *)

	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)

	Lookup.lookup_class(env,t) => (cl,_) &
	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_modification(mods,n) => mm &
	print "  mod 1: " & SCode.print_mod classmod & print "\n" &
	print "  mod 2: " & SCode.print_mod mm & print "\n" &
	print "  mod 3: " & SCode.print_mod m & print "\n" &

	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m) => mod' &
	print "  modification: " & SCode.print_mod mod' & print "\n" &

	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm, vn) &

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)

	Prefix.prefix_add(n,[],pre) => pre' &

	(* FIXME: Redeclarations! *)
	
	inst_class(env,mod',pre',csets,cl) => (dae1,csets',ty,st) &

	(** The environment is extended with the new variable *)
	(** binding. *)

	Mod.mod_equation mod' => eq &
	make_binding (env,attr,eq,cl) => binding &
	Env.extend_frame_v(env,Env.FRAMEVAR(n,attr,ty,binding)) => env' &
	print " extended frame with variable " & Exp.print_component_ref vn &
 	print "\n" &

	(** If the modification includes an equation, it is added. *)
	inst_mod_equation(env',pre,n,mod') => dae2 &

	list_append(dae1, dae2) => dae
	--------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,attr,t,m))
         => ((*DAE.VAR(vn, DAE.LOCAL)::*)dae,
	     env',csets',ci_state,[Types.VAR(n,attr,ty,eq)])

	(** If the class lookup in the previous rule fails, this
	 ** rule catches
	 ** the error and prints an error message about the unknown class.
	 **)

  rule	not Lookup.lookup_class(env,t) => (cl,_) &
	Absyn.path_string(t) => s &
	print "# unknown class '" & print s & print "' while instantiating " &
	Prefix.prefix_path(Absyn.IDENT(n),pre) => n' &
	Absyn.path_string(n') => ns &
	print ns & print "\n"
	--------------------------
	inst_element(env,_,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,t,_))
         => ([],env,csets,ci_state,[])

  rule	print "- inst_element failed\n"
	-------------------------------
	inst_element (_,_,_,_,_,_) => fail

end	

(** relation: inst_equation
 **)

relation inst_equation: (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			 Absyn.Equation)
	  => (DAE.DAEcomp list, Env, Connect.Sets, ClassInf.State) =

	(**  connect
	 **
	 ** Handle connct statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2) => csets' &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------------
	inst_equation(env,mods,pre, csets, ci_state, Absyn.EQ_CONNECT(c1,c2))
	  => ([],env,csets',ci_state')
	  
	(**  assert
	 **
	 ** FIXME: Handle assertions
	 **)

  rule	StaticExp.elab_exp(env,e) => (e', t, c) &
	inst_assertion (e', t, c, d, pre) => dae &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	--------------------------------------------------------------
	inst_equation(env,mods,pre,csets, ci_state,
		      Absyn.EQ_EXPR(Absyn.CALL(Absyn.IDENT("assert"),
					       [e,Absyn.STRING(d)])))
	  => (dae,env,csets,ci_state')

  rule	print "- No expression equations yet\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,Absyn.EQ_EXPR(_)) => fail

  rule	Lookup.lookup_var_local(env,n)
	  => Env.FRAMEVAR(_,_,_,Env.EQBOUND(_)) &
	print " shadowed equation for " & print n & print "\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,
		      Absyn.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2))
	  => ([],env,csets,ci_state')

  rule	print " equation\n" &
	StaticExp.elab_exp(env,Absyn.RELATION(e1,Absyn.EQUAL,e2))
	  => (e, ty1, c1) &
	print " - equation\n" &
	Prefix.prefix_exp(e,pre) => e' & (* FIXME: remove *)
	print " -- equation\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------
	inst_equation(env, mods, pre, csets, ci_state, Absyn.EQ_EQUALS(e1,e2))
	  => ([DAE.EQUATION(e')], env, csets, ci_state')

	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **)

  rule	StaticExp.elab_exp (env,e)
	  => (e',Types.T_ARRAY(1,Types.T_INTEGER),true) &
	StaticExp.ceval (env,e') => (v,_) &
	print "  Unrolling " & print i & print " in " &
 	Dump.print_exp e & print " = " &
 	Values.print_val v & print "\n" &
	unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,Absyn.EQ_FOR(i,e,el))
	  => (dae, env,csets', ci_state')

  rule	print "- inst_equation failed\n"
	----------------------------------
	inst_equation(_,_,_,_,_,_) => fail

end

(** relation: inst_assertion
 **
 ** Instantiate an assertion.
 **)

relation inst_assertion : (Exp.Exp, Types.BasicType, bool, string, Prefix)
	  => DAE.DAEcomp list =

  rule	Prefix.prefix_exp(e,pre) => e' &
	print " (constant) ASSERTION(" & Exp.print_exp e' & print "): " &
	print d & print "\n"
	--------------------
	inst_assertion (e, Types.T_BOOL, true, d, pre) => [(*FIXME*)]

  rule	Prefix.prefix_exp(e,pre) => e' &
	print " ASSERTION(" & Exp.print_exp e' & print "): " &
	print d & print "\n"
	--------------------
	inst_assertion (e, Types.T_BOOL, _, d, pre) => [(*FIXME*)]

  rule	print "# Assertions have to be of type Boolean\n" &
	print "  assertion: (" &
	Prefix.prefix_exp(e,pre) => e' & Exp.print_exp e' & print "): " &
 	print d & print "\n"
	-----------------------------
	inst_assertion (e, _, _, d, pre) => fail
	
end

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, Absyn.Equation list)
	  => (DAE.DAEcomp list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_) => ([], csets)

  rule	print "   unroll: " & Values.print_val fst & print "\n" &
	Env.open_scope env => env' &
	Env.extend_frame_v (env',
			    Env.FRAMEVAR(i, Absyn.ATTR(Absyn.NODIM,
						       false,
						       Absyn.CONST,
						       Absyn.BIDIR),
					 Types.TYPE(ClassInf.TYPE_INTEGER
						    ("<for loop>"),[]),
					 Env.VALBOUND(fst))) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_equation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs)
	  => (dae, csets'')

  rule	print "- unroll " & Values.print_val v & print " failed\n"
	-------------------------
	unroll (_,_,_,_,_,_,v,_) => fail

end

(** relation: inst_algorithm
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   Absyn.Algorithm)
	  => (DAE.DAEcomp list, Env, Connect.Sets, ClassInf.State) =

  rule  print "# no algorithms yet\n"
	-----------------------------
	inst_algorithm(env,_,_,csets,ci_state,_) => ([],env,csets,ci_state)

end

(**)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef)
	  => Connect.Sets =

  rule	print " connecting " &
	Dump.print_component_ref(c1) & print " with " &
	Dump.print_component_ref(c2) & print "\n" &
	StaticExp.elab_cref(env, c1) => (c1',t1,con1) &
	StaticExp.elab_cref(env, c2) => (c2',t2,con2) &
	Lookup.lookup_var(env,c1')
	  => (Absyn.ATTR(_,_,_,_),ty1 as Types.TYPE(st1,_),_) &
	Lookup.lookup_var(env,c2')
	  => (Absyn.ATTR(_,_,_,_),ty2 as Types.TYPE(st2,_),_) &
	check_connect_vars(c1',ty1,con1,c2',ty2,con2) &
	ClassInf.assert_valid(st1,Absyn.R_CONNECTOR) &
	ClassInf.assert_valid(st2,Absyn.R_CONNECTOR) &
	component_face(c1') => f1 &
	component_face(c2') => f2 &
	connect_components(sets, pre, c1', f1, c2', f2, ty1, false) => sets'
	---------------------------------
	inst_connect(sets, env,pre,c1,c2) => sets'

  rule	print "# could not connect\n"
	---------------------------------
	inst_connect(sets,_,_,_,_) => fail

end

relation check_connect_vars : (Exp.ComponentRef, Types.Type, bool,
			       Exp.ComponentRef, Types.Type, bool) => () =

  rule	Types.same_type(t1, t2)
	-----------------------
	check_connect_vars(_,t1,false,_,t2,false)

  rule	print "# Can't connect " & Exp.print_component_ref c1 &
	print " to " & Exp.print_component_ref c2 & print "\n"
	(* FIXME: Better message *)
	------------------------------------------------------
	check_connect_vars(c1,_,_,c2,_,_) => fail

end

(**)

relation connect_components: (Connect.Sets,
			      Prefix,
			      Exp.ComponentRef, Connect.Face,
			      Exp.ComponentRef, Connect.Face,
			      Types.Type, bool) => Connect.Sets =
	
	(* flow type *)

  rule	ClassInf.valid(st, Absyn.R_TYPE) &
	(* Prefix.prefix_cref(pre, c1) => c1' &
	   Prefix.prefix_cref(pre, c2) => c2' &
	   print "  connect_components flow: " &
	   Dump.dump_component_ref c1' & print " <-> " &
	   Dump.dump_component_ref c2' &
	   print "\n" & *)
	Connect.add_flow(sets, c1, f1, c2, f2) => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, f1, c2, f2, Types.TYPE(st,_), true)
	  => sets'
	
	(* non-flow type *)

  rule	ClassInf.valid(st, Absyn.R_TYPE) &
	(* Prefix.prefix_cref(pre, c1) => c1' &
	   Prefix.prefix_cref(pre, c2) => c2' &
	   print "  connect_components non-flow: " &
	   Dump.dump_component_ref c1' & print " <-> " &
	   Dump.dump_component_ref c2' &
	   print "\n" & *)
	Connect.add_equ(sets, c1, c2) => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, _, c2, _, Types.TYPE(st,_), false)
	  => sets'

	(* Not a TYPE *)

  rule	(* Prefix.prefix_cref(pre, c1) => c1' &
	   Prefix.prefix_cref(pre, c2) => c2' &
	   print "  connect_components 2: " &
	   Dump.dump_component_ref c1' & print " <-> " &
	   Dump.dump_component_ref c2' &
	   print "\n" & *)
	connect_vars(sets,c1,f1,c2,f2, l) => sets'
	----------------------------------------
	connect_components(sets,pre,c1,f1,c2,f2,Types.TYPE(_,l),_) => sets'
	
end

(**)

relation connect_vars : (Connect.Sets,
			 Exp.ComponentRef, Connect.Face,
			 Exp.ComponentRef, Connect.Face,
			 Types.Var list) => Connect.Sets =

  axiom	connect_vars(sets,_,_,_,_,[]) => sets

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	(* print "  connect_vars: " &
	 * Dump.dump_component_ref c1' & print " <-> " &
	 * Dump.dump_component_ref c2' &
	 * print "\n" & *)
	connect_components(sets,Prefix.NOPRE, c1',f1, c2',f2, ty, flow)
	  => sets' &
	connect_vars(sets',c1,f1,c2,f2,xs) => sets''
	--------------------------------------
	connect_vars(sets,c1,f1,c2,f2,
		     Types.VAR(n,Absyn.ATTR(_,flow,_,_),ty,_)::xs)
	  => sets''

end

(**)

relation mktype : (ClassInf.State,Types.Var list) => Types.Type =

  axiom	mktype(st,l) => Types.TYPE(st,l)

end

(**)

relation assert : (bool, bool, string) => () =

  rule  x = y
	-----
	assert(x,y,_)

  rule  not x = y &
	print "# " & print m & print "\n"
	--------------------------------------
	assert(x,y,m)

end

(**)

relation optional_cons : ('a option, 'a list) => 'a list =

  axiom optional_cons(NONE, l) => l

  axiom optional_cons(SOME(x), l) => x::l

end

(**)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list)
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[]) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es)
	  => (l'',env'',csets'',ci_state'')

end

(**)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

  rule	print "# While connecting " &
	Exp.print_component_ref c & print "\n" &
	print "# Only local or child connectors allowed.\n"
	(* FIXME: This only checks the syntactic properties. *)
	---------------------------------------------------
	component_face c => fail

end

(**)

relation inst_mod_equation : (Env, Prefix, Ident, Mod) => DAE.DAEcomp list =

  rule  print "  equation modification: " & print v & SCode.print_mod mod &
	print "\n" &

	(*
	StaticExp.elab_exp(env,
			   Absyn.RELATION(Absyn.CREF(Absyn.CREF_IDENT(v,[])),
					  Absyn.EQUAL,e))
	  => (e', ty1, c1) &
	Prefix.prefix_exp(e',pre) => e'' (* FIXME: remove *)
	*)

	StaticExp.elab_exp (env, e) => (e',t,_) &
	(* FIXME: Check type *)
	StaticExp.elab_relop (Absyn.EQUAL, t) => op &
	let e'' = Exp.RELATION(Exp.CREF(Exp.CREF_IDENT(v,[])), op, e') &
	Prefix.prefix_exp(e'', pre) => e'''
	-----------------------------------------
	inst_mod_equation(env,pre,v,mod as SCode.MOD(_,_,SOME(e)))
	  => [DAE.EQUATION(e''')]
	  
  axiom inst_mod_equation(_,_,_,SCode.MOD(_,_,NONE)) => []
  axiom inst_mod_equation(_,_,_,SCode.NOMOD) => []

  rule	print "- inst_mod_equation failed\n"
	------------------------------------
  	inst_mod_equation (_,_,_,_) => fail

end

(**)

relation check_prot : (bool, Mod, Exp.ComponentRef) => () =

  rule  print "  public variable " & Exp.print_component_ref cref & print "\n"
	--------------------------------------------------
	check_prot(false,_,cref)
	
  axiom check_prot(_,SCode.NOMOD,_)

  rule  print "# Trying to modify protected element " &
	Exp.print_component_ref cref & print "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(**)

relation make_binding : (Env.Env, Absyn.VarAttr, Absyn.Exp option, SCode.Class)
	  => Env.Binding =

  axiom	make_binding (_,_,NONE,_) => Env.UNBOUND

  rule	class_type cl => ct &
	StaticExp.elab_exp (env, e) => (e', t, c) &
	make_const_binding (env,e', t, ct, c) => binding
	----------------------------------------
	make_binding (env,Absyn.ATTR(_,_,Absyn.CONST,_),SOME(e),cl)
	  => binding

	(* default *)

  axiom make_binding (_,_, SOME(e),_) => Env.EQBOUND(e)

end

relation make_const_binding : (Env.Env, Exp.Exp,
			       Types.BasicType, Types.BasicType, bool)
	  => Env.Binding =

	(* Cast the value to real if necessary *)
  rule	make_const_binding (env,Exp.CAST_TO_REAL(e),
			    Types.T_REAL, Types.T_REAL,c) => b
	------------------------------------------------------
	make_const_binding (env,e,Types.T_INTEGER,Types.T_REAL,c) => b

  rule	t = ct &
	StaticExp.ceval (env, e) => (v,_) &
	print "  constant expression " & Exp.print_exp e &
 	print " = " & Values.print_val v & print " detected\n"
	---------------------------------
	make_const_binding (env,e,t,ct,true) => Env.VALBOUND(v)

  rule	not t = ct &
	print "# Different types in binding\n"
	--------------------------------------
	make_const_binding (env,e,t,ct,true) => fail

  rule	print "# Non-constant equation for constant\n"
	---------------------------------
	make_const_binding (env,e,t,ct,false) => fail

end

relation class_type : SCode.Class => Types.BasicType =

  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_INT,_) => Types.T_INTEGER
  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_STRING,_)
	  => Types.T_STRING
  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_REAL,_) => Types.T_REAL
  axiom	class_type SCode.CLASS(_,_,Absyn.R_PREDEFINED_BOOL,_) => Types.T_BOOL
  axiom	class_type _ => Types.T_OTHER

end
