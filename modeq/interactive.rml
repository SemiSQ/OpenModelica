(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(* $Name$ *)

module Interactive:
  with "absyn.rml"
  with "inst.rml"
  with "explode.rml" 
  with "dae.rml" 							  
  datatype InteractiveStmt = IALG of Absyn.Algorithm
			   | IEXP of Absyn.Exp
  datatype InteractiveStmts = ISTMTS of InteractiveStmt list
							  
  datatype InstantiatedClass =  INSTCLASS of Absyn.Path * (* The F.Q. name of the instantiated class*)
					     DAE.Element list (* The list of DAE elements *)
  datatype InteractiveVariable = IVAR of Absyn.Ident * (* The variable identifier *)
					 Absyn.Exp (* The expression containing the value *)

  datatype InteractiveSymbolTable = SYMBOLTABLE of Absyn.Program * (*The ast*)
						   SCode.Program * (* The exploded ast *)
						   InstantiatedClass list * (* List of instantiated classes*)
						   InteractiveVariable	list (* List of variables with values*)  
  relation evaluate: (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable) 

  relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program
  relation add_component: (string,Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program,string)
  relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int
end
with "dump.rml"
with "debug.rml"
with "rtopts.rml"
with "util.rml"
(** relation: evaluate
 ** This relation evaluates expressions feeded interactively to the compiler.
**)

relation evaluate:  (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable) =

  rule	let newst = SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[])
	-------------------------------------------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("clear",_),_))]),_) 
	    => ("Clearing symbol table\n", newst)
  rule	Dump.dump(p)
	------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("list",_),_))]),st as SYMBOLTABLE(p,_,_,_))
	    => (" symboltable :",st)

  rule	SCode.elaborate(p) => p' &
	Absyn.cref_to_path(cr) => path &
	Inst.instantiate_class(p',path) => dae &
	DAE.dump_debug dae &
	print "dumped dae:\n" &
	DAE.dump_str (dae) => str 
	--------------------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("translateClass",_),Absyn.FUNCTIONARGS([ Absyn.CREF(cr)],[])))]),st as SYMBOLTABLE(p,_,_,_))
	    => (str,st)
	    

  rule	evaluate_graphical_api(stmts,st) => (str,newst)
	----------------------------------------------------
	evaluate(stmts as ISTMTS([IEXP(Absyn.CALL(_,_))]),st) => (str,newst)
  axiom	evaluate(_,st) => ("Not implemented yet\n",st)
end


(** relation: evaluate_graphical_api
 ** This relation evaluates all primitives in the graphical api.
 **)

relation evaluate_graphical_api: (InteractiveStmts, InteractiveSymbolTable) => 
	(string, InteractiveSymbolTable) = 
	
  rule	let resstr="GAPI function not implemented yet\n" & let newst = st
	---------------------------------------------------
	evaluate_graphical_api(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("loadModel",_),_))]),st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	
	
  rule	let resstr="GAPI function not implemented yet\n" & let newst = st
	---------------------------------------------------
	evaluate_graphical_api(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("saveModel",_),_))]),st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	
  rule update_program(
      Absyn.PROGRAM([Absyn.CLASS(name,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])]))],Absyn.TOP),
      p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv) &
	string_append(name,"\n") => resstr
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("newModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_))],[])))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	    
  rule	componentref_to_path(cr) => path &
	update_program(
	    Absyn.PROGRAM([Absyn.CLASS(name,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])]))],Absyn.WITHIN(path)),
	    p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv) &
	string_append(name,"\n") => resstr
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("newModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(cr)],[])))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	
	
  rule	add_component(name,tp,model,annlst,p) => (newp,resstr)
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("addComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],annlst)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,SYMBOLTABLE(newp,s,ic,iv))

  rule	get_component_count(cr,p) => count &
	int_string count => str &
	string_append(str,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getComponentCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_component(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_component_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponentAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)
end

relation componentref_to_path: Absyn.ComponentRef => Absyn.Path = 

  axiom componentref_to_path(Absyn.CREF_IDENT(ident,_)) => Absyn.IDENT(ident)
	
  rule	componentref_to_path(x) => px
	-----------------------------
	componentref_to_path(Absyn.CREF_QUAL(id,_,x)) => Absyn.QUALIFIED(id,px)
end	

(** relation: update_program
 **
 ** This relation takes an old program (second argument), i.e. the old symboltable, 
 ** and a new program (first argument), i.e. a new set of classes and updates the old 
 ** program with the definitions in the new one
 **)     
relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program =
     
  axiom	update_program (Absyn.PROGRAM([],_),prg) => prg
     
  rule	class_in_program(name,p2) => false &
	update_program(Absyn.PROGRAM(c2,w),Absyn.PROGRAM((c1::c3),w)) => pnew
	---------------------------------------------------------
	update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_))::c2,w as Absyn.TOP),p2 as Absyn.PROGRAM(c3,_)) => pnew

  rule	class_in_program(name,p2) => true &
	update_program(Absyn.PROGRAM(c2,w),p2) => pnew &
        replace_class_in_program(c1,pnew) => pnew' 
	------------------------------------------
	update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_))::c2,w as Absyn.TOP),p2) => pnew'
	
  rule	insert_class_in_program(c1,w,p2) => pnew &
	update_program(Absyn.PROGRAM(c2,w),pnew) => pnew' 
	---------------------------------------------
	update_program(Absyn.PROGRAM(c1::c2,w as Absyn.WITHIN(path)),p2) => pnew'
	
  rule	print "Further program merging not implemented yet\n"
	------------------------
	update_program (a,b) => b
end
	
(** relation add_component
 ** This relation takes:  arg1 - string giving the instancename, arg2 - `ComponentRef' giving the component type
 ** arg3 - ComponentRef giving the model to instantiate the component within, arg4 - `NamedArg' list of annotations 
 ** and arg5 - a Program. The result is an updated program with the component and its annotations inserted, and a string
 ** "OK" for success. If the insertion fails, a suitable error string is given along with the input Program.
 **)
relation add_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program ,string) =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	path_in_program(modelpath,p) => false
	---------------------------------
	add_component (name,tp,model,annlst,p) => (p,"Error, No such model\n")
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	annotation_list_to_absyn(annlst) => annotation &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[Absyn.NOSUB]),tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],NONE),SOME(annotation))])))) => newcdef &	
	update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	------------------------------------------------
	add_component( name,tp,model,annlst,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")
	
  axiom	add_component (_,_,_,_,p) => (p,"Not implemented yet\n")
	
end

(** relation: get_component_count
 ** This relation takes a `ComponentRef' and a `Program' and returns the number of public components in the 
 ** class referenced by the `ComponentRef'.
   **)
relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int = 
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_public_components(cdef) => count
	-------------------------------------------------
	get_component_count( model,p) => count
end

(** relation: count_components
 ** This relation takes a `Class' and returns the number of components in that class
**)

relation count_public_components: Absyn.Class => int =

  rule	count_public_components Absyn.CLASS(a,b,c,Absyn.PARTS(lst)) => c1 &
	count_components(elt) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_public_components Absyn.CLASS(a,b,c,Absyn.PARTS(Absyn.PUBLIC(elt)::lst)) 
	    => res

  rule	count_public_components Absyn.CLASS(a,b,c,Absyn.PARTS(lst)) => res
	-----------------------------------------------------
	count_public_components Absyn.CLASS(a,b,c,Absyn.PARTS(_::lst)) => res
	
  axiom count_public_components Absyn.CLASS(a,b,c,Absyn.PARTS([])) => 0
  axiom count_public_components Absyn.CLASS(a,b,c,Absyn.DERIVED(_,_,_)) => -1
end

relation count_components: Absyn.ElementItem list => int =

  rule	count_components(lst) => c1 &
	int_add(c1,1) => res
	--------------------------
	count_components(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,_,_)))::lst) => res
	
  rule	count_components(lst) => res
	----------------------------
	count_components(_::lst) => res

  axiom	count_components([]) => 0
end


(** relation: get_nth_component
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of names
 ** containing the name, and type of that component.
 **)
relation get_nth_component: (Absyn.ComponentRef,Absyn.Program, int) => string = 
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_component_in_class(cdef,n) => comp &
	get_component_name_and_type (comp) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	-------------------------------------------------
	get_nth_component( model,p,n) => str

	axiom get_nth_component(_,_,_) => "-1"
end

(** relation: get_nth_component_annotation
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of values
 ** corresponding to the flat record for component annotations.
 **)
relation get_nth_component_annotation: (Absyn.ComponentRef,Absyn.Program, int) => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_component_in_class(cdef,n) => comp &
	get_component_annotation(comp) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	---------------------------------------------- 
	get_nth_component_annotation( model,p,n) => str

	axiom get_nth_component_annotation(_,_,_) => "-1"
end

(** relation: get_component_annotation
 ** This relation takes an `Element' and returns a comma separated string of values
 ** corresponding to the flat record for a component annotation. If several components are declared 
 ** within the eleement, a list of values is given for each of them.
**)
relation get_component_annotation: Absyn.Element => string =
	
  rule	get_componentitems_annotation(lst) => str
	-----------------------------------------
	get_component_annotation(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,_,lst))) => str
	axiom get_component_annotation _ => ""
end 

relation get_componentitems_annotation: Absyn.ComponentItem list => string =
	
  rule	get_annotation_string ann => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"},") => s3 &
	get_componentitems_annotation(rest) => str &
	string_append(s3,str) => res
	----------------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,SOME(ann))::(rest as (_::_))) => res
	
  rule	get_annotation_string ann => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => res 
	----------------------------
	get_componentitems_annotation ([Absyn.COMPONENTITEM(_,SOME(ann))]) => res

  rule	get_componentitems_annotation(rest) => str &
	string_append("{},",str) => res
	-----------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,NONE)::(rest as (_::_))) => res

  rule	let res = "{}"
	-----------------------
	get_componentitems_annotation ([Absyn.COMPONENTITEM(_,NONE)]) => res
end

(** relation_ get_annotation_string
** This relation takes an annotation and returns a comma separates string of values
   representing the flat record of the specific annotation.
**)

relation get_annotation_string: Absyn.Annotation => string =

  rule	SCode.build_mod(SOME(Absyn.CLASSMOD([mod],NONE)),false) => mod' & 
	let pstring = "record Placement Boolean visible=true; Transformation transformation; Transformation iconTransformation" &
	let tstring = "record Transformation Real x=0; Real y=0; Real scale=1; Real aspectRatio=1; Boolean flipHorizontal=false; Boolean flipVertical=false; Real rotation=0; end Transformation;" &
	string_append(tstring,pstring) => totstring &	
        Parse.parsestring totstring => p &
	Scode.elaborate p => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("Placement")) => env  & 
	inst_class(env,mod',Prefix.NOPRE,[],placementclass,[]) => (dae,cs,t,state) &
	DAE.get_variable_bindings_str dae => str 
	---------------------------
	get_annotation_string(Absyn.ANNOTATION([(mod as (Absyn.MODIFICATION(_,Absyn.CREF_IDENT("Placement",_),_)))])) => str

  rule	print "get_annotation_string failed!\n"
	---------------------------------------
	get_annotation_string(_) => fail
end
	
relation get_nth_public_component_in_class:  (Absyn.Class,int) => Absyn.Element =
	
  rule	get_nth_component_in_elementitems(elt,n) => res
	-----------------------------------------------
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.PARTS(Absyn.PUBLIC(elt)::lst)),n) 
	    => res
	    
	    (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	    (* subtract and try next public list *)
  rule	count_components(elt) => c1 &
	int_sub(n,c1) => newn &
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.PARTS(rest)),newn) => res
	------------------------------------------------------------------------------------
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.PARTS(Absyn.PUBLIC(elt)::rest)),n) => res

  rule	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.PARTS(lst)),n) => res
	-----------------------------------------------------------------------
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.PARTS(_::lst)),n) => res
	
  axiom get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.PARTS([])),_) => fail
  axiom get_nth_public_component_in_class (Absyn.CLASS(a,b,c,Absyn.DERIVED(_,_,_)),_) => fail

end

(** relation: get_nth_component_in_elementintems 
 ** This relation takes an `ElementItem' list and and integer and returns the nth component 
 ** in the list
**)
relation get_nth_component_in_elementitems: (Absyn.ElementItem list, int) => Absyn.Element =
	
  axiom	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,1) => elt

  rule	int_ge(n,1) => true &
	int_sub(n,1) => newn &
	get_nth_component_in_elementitems(rest,newn) => res
	---------------------------------------------------
	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,n) => res

  rule	get_nth_component_in_elementitems(rest,n) => res
	------------------------------------------------
	get_nth_component_in_elementitems(_::rest,n) => res

  axiom	get_nth_component_in_elementitems([],_) => fail
end

(** relation: get_component_name_and_type
 ** This relation takes an `Element' and returns a string of comma separated values of the 
 **  type and name of the component, e.g. "Resistor,R1" or "Resistor,R1,R2"
 ** If Element is not a component, the empty string is returned
**)
relation get_component_name_and_type: Absyn.Element => string =

  rule	Absyn.path_string(p) => typename &
	get_componentitems_name(lst) => names &
	string_append(typename,",") => s1 &
	string_append(s1,names) => str
	-------------------------------------------
	get_component_name_and_type(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,p,lst))) => str
end

(** relation_get_componentitems_name
 ** This relation takes a `ComponentItems' list and returns a comma separated list of all
 ** component names.
**)


relation get_componentitems_name: Absyn.ComponentItem list => string =
	
  rule	string_append(c1,",") => s1 &
	get_componentitems_name(c2::rest) => s2 &
	string_append(s1,s2) => str
	----------------------------
	get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_)::(c2::rest)) => str
  rule	get_componentitems_name(rest) => res
	------------------------------------
	get_componentitems_name(_::rest) => res

  axiom	get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_)]) => c1

  axiom	get_componentitems_name([_]) => ""
end
(** relation: add_to_public
 ** This relation takes a 'Class' definition and adds an `ElementItem' to the first public list in the class.
 ** If no public list is available in the class one is created.
 **)
relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

  rule	get_public_list(parts) => publst &
	let publst2 = eitem::publst &
	replace_public_list(parts,publst2) => parts2 
	--------------------------------------------
	add_to_public ( Absyn.CLASS(i,p,r,Absyn.PARTS(parts)), eitem) 
	    => Absyn.CLASS(i,p,r,Absyn.PARTS(parts2))

  axiom	add_to_public ( Absyn.CLASS(i,p,r,Absyn.DERIVED(_,_,_)),eitem) => fail

  axiom	add_to_public(Absyn.CLASS(i,p,r,Absyn.PARTS(parts)),eitem)
	    => Absyn.CLASS(i,p,r,Absyn.PARTS(Absyn.PUBLIC([eitem])::parts))

end
(** relation: replace_class_in_program
 ** This relation takes a `Class' and a `Program' and replaces the class definition 
 ** at the top level in the program by the class definition of the `Class'.
 **)
relation replace_class_in_program: (Absyn.Class, Absyn.Program) => Absyn.Program =
  axiom replace_class_in_program(c, Absyn.PROGRAM([],w)) => Absyn.PROGRAM([c],w)
  rule	name1 = name2
	-------------
	replace_class_in_program(c as Absyn.CLASS(name1,_,_,_),Absyn.PROGRAM(Absyn.CLASS(name2,_,_,_)::clst,w))
	    => Absyn.PROGRAM(c::clst,w)
	    
  rule	not name1 = name2 &
	replace_class_in_program(c, Absyn.PROGRAM(clst,w)) => Absyn.PROGRAM(newclst,w)
	-------------------------------------------------------
	replace_class_in_program(c as Absyn.CLASS(name1,_,_,_),
	    Absyn.PROGRAM((c1 as Absyn.CLASS(name2,_,_,_))::clst,w)) 
	    => Absyn.PROGRAM(c1::newclst,w)

  rule	print "replace_class_in_program failed \n class:" &
	Debug.fcall ("dump", Dump.dump, Absyn.PROGRAM([c],Absyn.TOP)) &
	print "\nprogram: \n" &
	Debug.fcall ("dump", Dump.dump, p)
	----------------------------
	replace_class_in_program(c,p) => fail
end
	
(** relation: insert_class_in_program 
 ** This relation inserts the class into the Program at the scope given by the 
 ** within argument. If the class referenced by the within argument is not 
 **  defined, the relation prints an error message and fails.
 **)
	
relation insert_class_in_program: (Absyn.Class, Absyn.Within, Absyn.Program) => Absyn.Program =

  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &

	update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1,w as Absyn.WITHIN(Absyn.QUALIFIED(n1,_)),p) => pnew
	
  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &
	update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1, w as Absyn.WITHIN(Absyn.IDENT(n1)),p) => pnew
	
  rule	print "Error inserting in class, within name, where name is not defined\n" 
	-------------------
	insert_class_in_program(c1,_,p) => fail	
end

(** relation: insert_class_in_class
 ** This relation takes a class to update (the first argument)  and an inner 
 ** class (which is either replacing
 ** an earlier class or is a new inner definition) and a within statement
 ** pointing inside the class (including the class itself in the reference), and updates the class with the inner class.
 **)
relation insert_class_in_class: (Absyn.Class, Absyn.Within, Absyn.Class) => Absyn.Class =
	
  rule  replace_inner_class(c1,c2) => cnew  	
	----------------------------------
	insert_class_in_class(c1,Absyn.WITHIN(Absyn.IDENT(name)),c2) => cnew

  rule  get_first_ident_from_path(path) => name2 &
        get_inner_class(c2,name2) => cinner &
	insert_class_in_class(c1,Absyn.WITHIN(path),cinner) => cnew &
        replace_inner_class(cnew,c2) => cnew' 
	---------------------------------------------
	insert_class_in_class(c1,Absyn.WITHIN(Absyn.QUALIFIED(name,path)),c2) => cnew'
	
  rule print "insert_class_in_class failed\n"
	-------------------------------------
	insert_class_in_class(_,_,_) => fail
end

(** relation: get_first_ident_from_path
 ** This relation takes a `Path` as argument and returns the first `Ident' of the path.
 **)
relation get_first_ident_from_path: Absyn.Path => Absyn.Ident =
     axiom get_first_ident_from_path (Absyn.IDENT(name)) => name
     axiom get_first_ident_from_path (Absyn.QUALIFIED(name,path)) => name
end

(** relation: replace_inner_class 
 ** This relation takes two class definitions. The first one is inserted/replaced as a local class inside the second one.
 **)
relation replace_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

  rule	get_public_list(parts) => publst &
	replace_class_in_elementitemlist(publst,c1) => publst2 &
	replace_public_list(parts,publst2) => parts2 
	-----------------------------------------------
	replace_inner_class (c1,Absyn.CLASS(a,b,c,Absyn.PARTS(parts))) 
	    => Absyn.CLASS(a,b,c,Absyn.PARTS(parts2))
  rule	print "Failed in replace_inner_class\n"
	---------------------------------------
	replace_inner_class (_,_) => fail
end

(** relation: replace_class_in_elementitemlist
 ** This relation takes an Element list and a Class and returns a modified element list
 ** where the class definition of the class is updated or added.
  **)
relation replace_class_in_elementitemlist: (Absyn.ElementItem list, Absyn.Class) => Absyn.ElementItem list =
	
  rule	replace_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	replace_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

  rule	not name1 = name &
	replace_class_in_elementitemlist(xs,c) => res
	------------------------------------------
	replace_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_)))))::xs,c as Absyn.CLASS(name,_,_,_)) => e1::res
	

  rule name1 = name 
	-----------------------------
	replace_class_in_elementitemlist(
	    (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,Absyn.CLASSDEF(d, Absyn.CLASS(name1,_,_,_)))))::xs,
	    c2 as Absyn.CLASS(name,_,_,_))
	    => Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,Absyn.CLASSDEF(d,c2)))::xs
	
  axiom	 replace_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c)))]
end

(** relation: get_inner_class
 ** This relation takes a class name and a class and return the inner class definition 
 ** having that name.
**)
relation get_inner_class: (Absyn.Class, Absyn.Ident) => Absyn.Class =
  rule	get_public_list(parts) => publst &
	get_class_from_elementitemlist(publst,name) => c1
	-----------------------------------------------
	get_inner_class (Absyn.CLASS(_,_,_,Absyn.PARTS(parts)), name) => c1

  rule	print "get_inner_class failed, c:" &
	Debug.fcall ("dump", Dump.dump,Absyn.PROGRAM([c],Absyn.TOP)) &
	print "name :" & print name 
	--------------
	get_inner_class (c,name) => fail
end

(** relation: replace_public_list
 ** This relation replaces the `ElementItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_public_list: (Absyn.ClassPart list,Absyn.ElementItem list) => Absyn.ClassPart list =

  axiom replace_public_list ((lst as Absyn.PUBLIC(_))::rest,newpublst) => Absyn.PUBLIC(newpublst)::rest
	
  rule	replace_public_list(xs,new) => ys
	---------------------------------
	replace_public_list(x::xs,new) => x::ys

  axiom replace_public_list([],_) => []
end

(** relation: get_public_list
 ** This relation takes a ClassPart List and returns the first public ElementItem list of the class.
 **
*)
relation get_public_list: Absyn.ClassPart list => Absyn.ElementItem list =

  axiom get_public_list Absyn.PUBLIC(lst)::rest => lst
	
  rule	get_public_list(xs) => ys
	---------------------------
	get_public_list(x::xs) => ys

  axiom get_public_list(_) => fail
end

(** relation: get_class_from_elementitemlist
 ** This relation takes an ElementItem list and an Ident and returns the class definition
 ** among the element list having that identifier
  **)
relation get_class_from_elementitemlist: (Absyn.ElementItem list, Absyn.Ident) => Absyn.Class =
	
  rule	get_class_from_elementitemlist(xs,name) => res
	----------------------------------------------
	get_class_from_elementitemlist(Absyn.ANNOTATIONITEM(_)::xs,name) => res

  rule	name1 = name2
	------------------------------
	get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_))))::xs,name2) => c1

  rule	not name1 = name &
	get_class_from_elementitemlist(xs,name) => res
	------------------------------------------
	get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_))))::xs,name) => res

  axiom	 get_class_from_elementitemlist([],_) => fail
end

(** relation: class_in_program
 ** This relation takes a name and a Program and returns true if the name exists as a top class in the program.
**)

relation class_in_program:(string,Absyn.Program) => bool = 

  axiom class_in_program (str,Absyn.PROGRAM([],_)) => false
	
  rule	not str = c1 &
	class_in_program(str,Absyn.PROGRAM(p,w)) => res
	-----------------------
	class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_)::p,w)) => res
	
  axiom class_in_program (_,_) => true
end

(** relation: path_in_program
 ** This relation takes a path and a program and returns true if the class
 ** referenced by the path exist in the program
*)
relation path_in_program: (Absyn.Path, Absyn.Program) => bool =
	
  rule	Absyn.path_string(path) => pathstr &
	class_in_program(pathstr,p) => res
	-----------------------------------
	path_in_program (path as Absyn.IDENT(name),p) => res
	
  rule	class_in_program(c1,p) => true &
	get_class_in_program(c1,p) => c1def &
	path_in_program(prest,Absyn.PROGRAM([c1def],w)) => res
	------------------------------------
	path_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res
end

(** relation: get_pathed_class_in_program
 ** This relation takes a `Path' and a `Program` and retrieves the class definition referenced 
 ** by the `Path' from the `Program'.
*)
relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) => Absyn.Class =

  rule	get_class_in_program(str,p) => c1
	---------------------------------
	get_pathed_class_in_program (Absyn.IDENT(str),p) => c1
	
  rule	get_class_in_program(c1,p) => c1def &
	get_pathed_class_in_program(prest,Absyn.PROGRAM([c1def],w)) => res
	------------------------------------------------------------
	get_pathed_class_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res
end

(** relation: get_class_in_program
 ** This relation takes a Path and a Program and returns the class with the name `Path'.
 ** If that class does not exist, the relation fail
**)

relation get_class_in_program:(string, Absyn.Program) => Absyn.Class = 

  axiom get_class_in_program (str,Absyn.PROGRAM([],_)) => fail
	
  rule	not str = c1 &
	get_class_in_program(str,Absyn.PROGRAM(p,w)) => res
	-----------------------------------------
	get_class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_)::p,w)) => res
	
  rule  str = c1name
	------------
	get_class_in_program (str, Absyn.PROGRAM((c1 as Absyn.CLASS(c1name,_,_,_))::p,w)) => c1
end

(** relation: annotation_list_to_absyn
 ** This relation takes a list of `NamedArg' and returns an absyn `Annotation'.
 ** for instance [annotation = Placement( ...) ] is converted to ANNOTATION(Placement(...)) 
 **)
relation annotation_list_to_absyn: (Absyn.NamedArg list) => Absyn.Annotation =
  axiom annotation_list_to_absyn( [] ) => Absyn.ANNOTATION([])
	
  rule	record_constructor_to_modification(e) => eltarg
	------------------------------------
	annotation_list_to_absyn(Absyn.NAMEDARG("annotate",e)::_) => Absyn.ANNOTATION([eltarg])
	
  rule	annotation_list_to_absyn(al) => annres
	--------------------------------------
	annotation_list_to_absyn(a::al) => annres
end
	
(** relation:record_constructor_to_modification
 ** This relation takes a record constructor expression and translates it into a `ElementArg'.
 ** Since modifications must be named, only named arguments are treated in the record constructor.
 **)
relation record_constructor_to_modification: (Absyn.Exp ) => Absyn.ElementArg =

  rule	Util.list_map(nargs,namedarg_to_modification) => eltarglst &
        let res = Absyn.MODIFICATION(false,cr,Absyn.CLASSMOD(eltarglst,NONE))
	-----------------------------------
	record_constructor_to_modification(Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs))) => res	
end

(** relation: namedarg_to_modification
 ** This relation takes a `NamedArg' and translates it into a `ElementArg'.
 **)
relation namedarg_to_modification: (Absyn.NamedArg) => Absyn.ElementArg = 

  rule	record_constructor_to_modification(c) => elt &
	let res = Absyn.MODIFICATION(false,cr,Absyn.CLASSMOD([elt],NONE))
	----------------------------
	namedarg_to_modification( Absyn.NAMEDARG(id,c as Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs)))) => res

  rule	let res = Absyn.MODIFICATION(false,Absyn.CREF_IDENT(id,[]),Absyn.CLASSMOD([],SOME(e)))
	----------------------------------------------------------------
	namedarg_to_modification( Absyn.NAMEDARG(id,e)) => res
end






