(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(* $Name$ *)

module Interactive:
  with "absyn.rml"
  with "explode.rml" 
  with "dae.rml" 							  
  with "types.rml"
  with "values.rml"							  

  datatype InteractiveStmt = IALG of Absyn.Algorithm
			   | IEXP of Absyn.Exp
  datatype InteractiveStmts = ISTMTS of InteractiveStmt list
							  
  datatype InstantiatedClass =  INSTCLASS of Absyn.Path * (* The F.Q. name of the instantiated class*)
					     DAE.Element list (* The list of DAE elements *)
  datatype InteractiveVariable = IVAR of Absyn.Ident * (* The variable identifier *)
					 Values.Value *  (* The expression containing the value *)
					 Types.Type  (* The type of the expression *)

  datatype InteractiveSymbolTable = SYMBOLTABLE of Absyn.Program * (*The ast*)
						   SCode.Program * (* The exploded ast *)
						   InstantiatedClass list * (* List of instantiated classes*)
						   InteractiveVariable	list (* List of variables with values*)  
  relation evaluate: (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable) 

  relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program
  relation add_component: (string,Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program,string)
  relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int
end
with "dump.rml"
with "debug.rml"
with "rtopts.rml"
with "util.rml"
with "parse.rml"
with "prefix.rml"
with "mod.rml"
with "env.rml"
with "lookup.rml"
with "classinf.rml"
with "exp.rml"
with "inst.rml"
with "staticexp.rml"							  
with "modutil.rml"
with "codegen.rml"
with "print.rml"
with "system.rml"

val Placement_records = "record Transformation Real x=0.0; Real y=0.0; Real scale=1.0; Real aspectRatio=1.0; Boolean flipHorizontal=false; Boolean flipVertical=false; Real rotation=0.0; end Transformation; record Placement Boolean visible=true; Transformation transformation; Transformation iconTransformation; end Placement;" 

val Line_records = "type LinePattern=enumeration(None,Solid,Dash,Dot,DashDot,DashDotDot); type Arrow=enumeration(None,Open,Filled,Half); record Line  Boolean visible=true;  Real points[2,:]; Integer color[3]={0,0,0}; LinePattern pattern = LinePattern.Solid; Real thickness=0.25; Arrow arrow[2]={Arrow.None,Arrow.None};  Real arrowSize = 3.0;  Boolean smooth=false; end Line;"

val Icon_records = "record GraphicItem Boolean visible=true; end GraphicItem; record CoordinateSystem Real extent[2,2]; end CoordinateSystem; record Icon CoordinateSystem coordinateSystem(extent ={{-10.0, -10.0}, {10.0, 10.0}}); GraphicItem graphics[:]; end Icon;"
val Diagram_records = "record GraphicItem Boolean visible=true; end GraphicItem; record CoordinateSystem Real extent[2,2]; end CoordinateSystem; record Diagram CoordinateSystem coordinateSystem(extent ={{-100.0, -100.0}, {100.0, 100.0}}); GraphicItem graphics[:]; end Diagram;"

(* This variable contains all records needed for the graphical primitives, such as Line, Ellipse, etc. *)
val Graphics_records = "type LinePattern=enumeration(None,Solid,Dash,Dot,DashDot,DashDotDot); type Arrow=enumeration(None,Open,Filled,Half); type FillPattern=enumeration(None,Solid,Horizontal,Vertical,Cross,Forward,Backward,CrossDiag,HorizontalCylinder,VerticalCylinder,Sphere); type BorderPattern=enumeration(None,Raised,Sunken,Engraved); type TextStyle=enumeration(Bold,Italic,Underline); record Line  Boolean visible=true;  Real points[:,2]; Integer color[3]={0,0,0}; LinePattern pattern = LinePattern.Solid; Real thickness=0.25; Arrow arrow[2]={Arrow.None,Arrow.None};  Real arrowSize = 3.0;  Boolean smooth=false; end Line; record Polygon Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; Real points[:]; Boolean smooth=false; end Polygon; record Rectangle Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; BorderPattern borderPattern=BorderPattern.None; Real extent[2,2]; Real radius=0.0; end Rectangle; record Ellipse Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; Real extent[2,2]; end Ellipse; record Text Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; Real extent[2,2]; String textString; Real fontSize; String fontName; TextStyle textStyle[:]; end Text;"

(** relation: evaluate
 ** This relation evaluates expressions feeded interactively to the compiler.
**)

relation evaluate:  (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable) =

  rule	let newst = SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[])
	-------------------------------------------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("clear",_),_))]),_) 
	    => ("Clearing symbol table\n", newst)

  rule	Dump.unparse_str(p) => str
	------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("list",_),Absyn.FUNCTIONARGS([],[])))]),st as SYMBOLTABLE(p,_,_,_))
	    => (str,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str
	------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("list",_),Absyn.FUNCTIONARGS([ Absyn.CREF(cr)],[])))]),st as SYMBOLTABLE(p,_,_,_))
	    => (str,st)


  rule	SCode.elaborate(p) => p' &
	Absyn.cref_to_path(cr) => path &
	Inst.instantiate_class(p',path) => dae &
	DAE.dump_debug dae &
	Print.print_buf "dumped dae:\n" &
	DAE.dump_str (dae) => str 
	--------------------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("translateClass",_),Absyn.FUNCTIONARGS([ Absyn.CREF(cr)],[])))]),st as SYMBOLTABLE(p,_,_,_))
	    => (str,st)
	    
  rule	SCode.elaborate(p) => p' &
	Absyn.cref_to_path(cr) => path &
	Absyn.path_string path => pathstr &
	Inst.instantiate_implicit(p') => d &
	DAE.dump2 d &
	ModUtil.string_prefix_params d => d' &
	Print.get_string() => errstr &
	Print.clear_buf & 
	Codegen.generate_functions(d') &
	string_append(pathstr,".c") => filename &
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf "\nint main(int argc, char** argv)\n{\n\n  if (argc != 3)\n    {\n      fprintf(stderr,\"# Incorrrect number of arguments\n\");\n      return 1;\n    }\n" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
	Print.write_buf(filename)&
	System.compile_c_file(filename) 
	--------------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("generateCode",_),Absyn.FUNCTIONARGS([ Absyn.CREF(cr)],[])))]),st as SYMBOLTABLE(p,_,_,_))
	  => (errstr,st)
	  
  rule	System.set_c_compiler(str)
	--------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("setCompiler",_),Absyn.FUNCTIONARGS([ Absyn.STRING(str)],[])))]),st as SYMBOLTABLE(p,_,_,_))
	  => ("Ok\n",st)

  rule	System.set_c_flags(str)
	--------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("setCompilerFlags",_),Absyn.FUNCTIONARGS([ Absyn.STRING(str)],[])))]),st as SYMBOLTABLE(p,_,_,_))
	  => ("Ok\n",st)

  rule	Print.get_string() => str &
	Print.clear_buf() => () 
	--------------------------
	evaluate(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("getErrorMsg",_),Absyn.FUNCTIONARGS([],[])))]),st as SYMBOLTABLE(p,_,_,_))
	    => (str,st)
	    
  rule	evaluate_graphical_api(stmts,st) => (str,newst)
	----------------------------------------------------
	evaluate(stmts as ISTMTS([IEXP(Absyn.CALL(_,_))]),st) => (str,newst)
	
  rule	Print.clear_buf &
	evaluate_expr(exp,st) => (s1,newst) &
	string_append(s1,"\n") => str
	------------------------------------------------------
	evaluate(stmts as ISTMTS([exp]),st) => (str,newst)
	
  axiom	evaluate(_,st) => ("Not implemented yet\n",st)
end


(** relation: evaluate_expr
 ** This relation takes an 'InteractiveStmt´ and a symboltable and 
 ** evaluates the expression using Staticexp.
 **)
		 
relation evaluate_expr: (InteractiveStmt, InteractiveSymbolTable) =>
	(string,InteractiveSymbolTable) =
	
  rule	build_env_from_symboltable(st) => env &
	
	Static.elab_exp(env,exp) => (sexp,prop) &
	Print.print_buf "elabed exp:" &
	Exp.print_exp sexp &
	Static.ceval (env,sexp,true) => value &
	Print.print_buf "value:" & Values.print_val value &
	Print.print_buf "\n" &
	Values.val_string value =>  str 
	--------------------
	evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_)) => (str,st)
	
  rule	build_env_from_symboltable(st) => env &
	Static.elab_exp(env,exp) => (sexp,Static.PROP(t,_))  &
	Static.ceval(env,sexp,true) => value &
	add_var_to_symboltable(ident,value,t,st) => newst
	-----------------------------------------------
	evaluate_expr(IALG(Absyn.ALG_ASSIGN(Absyn.CREF_IDENT(ident,[]),exp)),st) => ("",newst)
	
  axiom	evaluate_expr(stmt,st) => ("Error evaluating expr.",st)
end
	
relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	    => InteractiveSymbolTable =
	    
  rule	ident = id2
	-----------
	add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,ic,IVAR(id2,_,_)::rest)) 
	    => SYMBOLTABLE(p,sp,ic,IVAR(ident,v,t)::rest)

  rule	not ident = id2 &
	add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,ic,rest))
	    => SYMBOLTABLE(p',sp',ic',vars)
	    ------------------------------------
	add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,ic,IVAR(id2,val2,t2)::rest))
	    => SYMBOLTABLE(p,sp,ic,IVAR(id2,val2,t2)::vars)

  axiom	add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,ic,[])) 
	    => SYMBOLTABLE(p,sp,ic,[IVAR(ident,v,t)])
end

relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env =
	
  rule	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	add_vars_to_env(vars,env) => env'
	------------------------------------------
	build_env_from_symboltable(SYMBOLTABLE(p,sp,ic,vars)) => env'
end

relation add_vars_to_env: (InteractiveVariable list, Env.Env) => Env.Env =

  rule	Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	Env.update_frame_v(env,
	    Types.VAR(
		id,
		Types.ATTR(false,SCode.RW,Absyn.VAR,Absyn.BIDIR),
		false,
		tp,
		Types.VALBOUND(v)
	    ),false) => env' &
	add_vars_to_env(rest,env') => env''
	---------------------------------------
	add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''
	
  rule	not Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	Env.extend_frame_v(env,
	    Types.VAR(
		id,
		Types.ATTR(false,SCode.RW,Absyn.VAR,Absyn.BIDIR),
		false,
		tp,
		Types.VALBOUND(v)
	    ),NONE,false) => env' &
	add_vars_to_env(rest,env') => env''
	---------------------------------------
	add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''

  axiom	 add_vars_to_env([],env) => env

end

(** relation: evaluate_graphical_api
 ** This relation evaluates all primitives in the graphical api.
 **)

relation evaluate_graphical_api: (InteractiveStmts, InteractiveSymbolTable) => 
	(string, InteractiveSymbolTable) = 
	
  rule	let resstr="GAPI function not implemented yet\n" & let newst = st
	---------------------------------------------------
	evaluate_graphical_api(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("loadModel",_),_))]),st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	
  rule	Parser.parse(name) => p1 &
	update_program(p1,p) => newp 
	---------------------------------------------------
	evaluate_graphical_api(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("loadFile",_),
	    Absyn.FUNCTIONARGS([Absyn.STRING(name)],_)))]),st as SYMBOLTABLE(p,s,ic,iv))
	    => ("OK\n",SYMBOLTABLE(newp,s,ic,iv))
	
  rule	let resstr="GAPI function not implemented yet\n" & let newst = st
	---------------------------------------------------
	evaluate_graphical_api(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("saveModel",_),_))]),st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	
  rule update_program(
      Absyn.PROGRAM([Absyn.CLASS(name,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])]))],Absyn.TOP),
      p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv) &
	string_append(name,"\n") => resstr
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("createModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_))],[])))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	    
  rule	componentref_to_path(cr) => path &
	update_program(
	    Absyn.PROGRAM([Absyn.CLASS(name,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])]))],Absyn.WITHIN(path)),
	    p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv) &
	string_append(name,"\n") => resstr
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("newModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(cr)],[])))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,newst)
	
	
  rule	add_component(name,tp,model,annlst,p) => (newp,resstr)
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("addComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],annlst)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,SYMBOLTABLE(newp,s,ic,iv))

  rule	get_component_count(cr,p) => count &
	int_string count => str &
	string_append(str,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getComponentCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_component(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_component_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponentAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_connection_count(cr,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getConnectionCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_connection(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnection",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	add_connection(cr,c1,c2,p) => (s1,newp) &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("addConnection",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,SYMBOLTABLE(newp,s,ic,iv))


  rule	get_nth_connection_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnectionAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_connector_count(cr,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getConnectorCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_connector(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnector",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_nth_connector_icon_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnectorIconAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)


  rule	Absyn.cref_to_path(cr) => path &
	get_icon_annotation(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getIconAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_diagram_annotation(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getDiagramAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_packages_in_path(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getPackages",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_top_packages(p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getPackages",_),
		Absyn.FUNCTIONARGS([],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_models_in_path(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getModels",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)

  rule	get_top_models(p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getModels",_),
		Absyn.FUNCTIONARGS([],_)))]
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv)) => (resstr,st)
end

relation componentref_to_path: Absyn.ComponentRef => Absyn.Path = 

  axiom componentref_to_path(Absyn.CREF_IDENT(ident,_)) => Absyn.IDENT(ident)
	
  rule	componentref_to_path(x) => px
	-----------------------------
	componentref_to_path(Absyn.CREF_QUAL(id,_,x)) => Absyn.QUALIFIED(id,px)
end	

(** relation: update_program
 **
 ** This relation takes an old program (second argument), i.e. the old symboltable, 
 ** and a new program (first argument), i.e. a new set of classes and updates the old 
 ** program with the definitions in the new one
 **)     
relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program =
     
  axiom	update_program (Absyn.PROGRAM([],_),prg) => prg
     
  rule	class_in_program(name,p2) => false &
	update_program(Absyn.PROGRAM(c2,w),Absyn.PROGRAM((c1::c3),w)) => pnew
	---------------------------------------------------------
	update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_))::c2,w as Absyn.TOP),p2 as Absyn.PROGRAM(c3,_)) => pnew

  rule	class_in_program(name,p2) => true &
	update_program(Absyn.PROGRAM(c2,w),p2) => pnew &
        replace_class_in_program(c1,pnew) => pnew' 
	------------------------------------------
	update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_))::c2,w as Absyn.TOP),p2) => pnew'
	
  rule	insert_class_in_program(c1,w,p2) => pnew &
	update_program(Absyn.PROGRAM(c2,w),pnew) => pnew' 
	---------------------------------------------
	update_program(Absyn.PROGRAM(c1::c2,w as Absyn.WITHIN(path)),p2) => pnew'
	
  rule	Print.print_buf "Further program merging not implemented yet\n"
	------------------------
	update_program (a,b) => b
end

(** relation: lookup_classdef
 ** This relation takes a Path of a class to lookup and a Path as a starting point for the lookup rules and a Program.
 ** It returns the Class definition and the complete Path to the class.
**)
relation lookup_classdef: (Absyn.Path, Absyn.Path, Absyn.Program) => (Absyn.Class, Absyn.Path) =
	
  rule	(* Look first inside 'inmodel' *)
	get_pathed_class_in_program(inmodel,p) => inmodeldef &
	get_pathed_class_in_program(path,Absyn.PROGRAM([inmodeldef],Absyn.TOP)) => cdef &
	Absyn.join_paths(inmodel,path) => newpath
	--------------------------------
	lookup_classdef(path, inmodel,p) => (cdef,newpath)

	(* Then look inside next level *)
  rule	Absyn.strip_last(inmodel) => innewpath &
	lookup_classdef(path,innewpath,p) => (cdef,respath)
	------------------------------
	lookup_classdef(path,inmodel,p) => (cdef,respath)
	
  rule	(* Finally look in top level *)
	get_pathed_class_in_program(path,p) => cdef
	------------------------------------------
	lookup_classdef(path,_,p) => (cdef,path)

  axiom	lookup_classdef(Absyn.IDENT("Real"),_,_) => 
	(Absyn.CLASS("Real",false,false,Absyn.R_PREDEFINED_REAL,Absyn.PARTS([])), 
	 Absyn.IDENT("Real"))

  axiom	lookup_classdef(Absyn.IDENT("Integer"),_,_) => 
	(Absyn.CLASS("Integer",false,false,Absyn.R_PREDEFINED_INT,Absyn.PARTS([])), 
	 Absyn.IDENT("Integer"))

  axiom	lookup_classdef(Absyn.IDENT("String"),_,_) => 
	(Absyn.CLASS("String",false,false,Absyn.R_PREDEFINED_STRING,Absyn.PARTS([])), 
	 Absyn.IDENT("String"))

  axiom	lookup_classdef(Absyn.IDENT("Boolean"),_,_) => 
	(Absyn.CLASS("Boolean",false,false,Absyn.R_PREDEFINED_BOOL,Absyn.PARTS([])), 
	 Absyn.IDENT("Boolean"))

  rule	Print.print_buf "#Error, lookup_classdef failed\n" &
	Absyn.path_string path => s1 &
	Absyn.path_string inpath => s2 &
	Print.print_buf s1 & Print.print_buf " in " & Print.print_buf s2 &
	Print.print_buf "\n" 
	---------------------
	lookup_classdef(path,inpath,_) => fail
end
	
(** relation add_component
 ** This relation takes:  arg1 - string giving the instancename, arg2 - `ComponentRef' giving the component type
 ** arg3 - ComponentRef giving the model to instantiate the component within, arg4 - `NamedArg' list of annotations 
 ** and arg5 - a Program. The result is an updated program with the component and its annotations inserted, and a string
 ** "OK" for success. If the insertion fails, a suitable error string is given along with the input Program.
 **)
relation add_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program ,string) =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	path_in_program(modelpath,p) => false
	---------------------------------
	add_component (name,tp,model,annlst,p) => (p,"Error, No such model\n")
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],NONE),NONE)])))) => newcdef &	
	update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	------------------------------------------------
	add_component( name,tp,model,[],p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	annotation_list_to_absyn(annlst) => annotation &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[Absyn.NOSUB]),tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],NONE),SOME(annotation))])))) => newcdef &	
	update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	------------------------------------------------
	add_component( name,tp,model,annlst,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")
	
  axiom	add_component (_,_,_,_,p) => (p,"Not implemented yet\n")
	
end

(** relation: get_component_count
 ** This relation takes a `ComponentRef' and a `Program' and returns the number of public components in the 
 ** class referenced by the `ComponentRef'.
   **)
relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int = 
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_public_components(cdef) => count
	-------------------------------------------------
	get_component_count( model,p) => count
end

(** relation: count_components
 ** This relation takes a `Class' and returns the number of components in that class
**)

relation count_public_components: Absyn.Class => int =

  rule	count_public_components Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst)) => c1 &
	count_components(elt) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_public_components Absyn.CLASS(a,b,c,d,Absyn.PARTS(Absyn.PUBLIC(elt)::lst)) 
	    => res

  rule	count_public_components Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst)) => res
	-----------------------------------------------------
	count_public_components Absyn.CLASS(a,b,c,d,Absyn.PARTS(_::lst)) => res
	
  axiom count_public_components Absyn.CLASS(a,b,c,d,Absyn.PARTS([])) => 0
  axiom count_public_components Absyn.CLASS(a,b,c,d,Absyn.DERIVED(_,_,_)) => -1
end

relation count_components: Absyn.ElementItem list => int =

  rule	count_components(lst) => c1 &
	int_add(c1,1) => res
	--------------------------
	count_components(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,_,_)))::lst) => res
	
  rule	count_components(lst) => res
	----------------------------
	count_components(_::lst) => res

  axiom	count_components([]) => 0
end


(** relation: get_nth_component
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of names
 ** containing the name, and type of that component.
 **)
relation get_nth_component: (Absyn.ComponentRef,Absyn.Program, int) => string = 
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_component_in_class(cdef,n) => comp &
	get_component_name_and_type (comp) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	-------------------------------------------------
	get_nth_component( model,p,n) => str

	axiom get_nth_component(_,_,_) => "-1"
end

(** relation: get_nth_component_annotation
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of values
 ** corresponding to the flat record for component annotations.
 **)
relation get_nth_component_annotation: (Absyn.ComponentRef,Absyn.Program, int) => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_component_in_class(cdef,n) => comp &
	get_component_annotation(comp) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	---------------------------------------------- 
	get_nth_component_annotation( model,p,n) => str

	axiom get_nth_component_annotation(_,_,_) => "-1"
end

(** relation: get_connection_count
 ** This relation takes a `ComponentRef' and a `Program' and returns a string containing
 ** the number of connections in the model identified by the `ComponentRef'.
**)
relation get_connection_count: (Absyn.ComponentRef, Absyn.Program) => string =

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_connections cdef => numconn &
	int_string numconn => res
	-------------------------
	get_connection_count (model,p) => res
	
	axiom get_connection_count(_,_) => "-1"
end

(** relation: get_nth_connection
 ** This relation takes a `ComponentRef' and a `Program' and an int and 
** returns a comma separated string for the nth connection, e.g. "R1.n,C.p".
**)
relation get_nth_connection: (Absyn.ComponentRef, Absyn.Program, int) => string =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => Absyn.EQUATIONITEM(eq,_) &
	get_connection_str eq => str
	----------------------------
	get_nth_connection (model,p,n) => str

	axiom get_nth_connection(_,_,_) => "-1"
end

relation add_connection: (Absyn.ComponentRef, Absyn.ComponentRef, Absyn.ComponentRef,Absyn.Program) => 
	(string,Absyn.Program) =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	  => newcdef &
	update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	---------------------------------------------------
	add_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

end

(** relation: get_nth_connection_annotation
 ** This relation takes a `ComponentRef' and a `Program' and an int and 
** returns a comma separated string  of values for the annotation of the the nth connection.
**)
relation get_nth_connection_annotation: (Absyn.ComponentRef, Absyn.Program, int) => string =

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => citem &
	get_connection_annotation_str (citem) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	--------------
	get_nth_connection_annotation(model,p,n) => str

  axiom	get_nth_connection_annotation(_,_,_) => "-1"
end

(** relation: get_connector_count
 ** This relation takes a ComponentRef and a Program and returns the number
 ** of connector components in the class given by the classname in the 
 ** ComponentRef. A partial instantiation of the inheritance structure is performed in order 
 ** to find all connectors of the class
 **)
relation get_connector_count: ((* Env.Env, *) Absyn.ComponentRef, Absyn.Program) => string =
	(** A complete elaboration is far too expensive. Instead we only look through the components of
	 ** the class for types declared using the "connector" restricted class keyword. We also look in
	 ** base classes  (recursively)  
	 **)

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_public_connectors(modelpath,p,cdef) => count &
	int_string(count) => countstr
	-------------------
	get_connector_count (model,p) => countstr

	axiom get_connector_count(_,_) => "-1"
end

(** relation: get_nth_connector
 ** This relation takes a ComponentRef and a Program and an int and returns a string with the name of the nth
 ** connector component in the class given by ComponentRef in the Program.
 **)
relation get_nth_connector: (Absyn.ComponentRef, Absyn.Program, int) => string =
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_connector_str(modelpath,cdef,p,n) => (str,tp) &
	Absyn.path_string tp => tpstr &
	string_append(str,",") => s1 &
	string_append(s1,tpstr) => resstr
	-----------------
	get_nth_connector(model,p,n)=> resstr

  axiom get_nth_connector(_,_,_) => "-1"
end

(** relation: get_nth_connector
 ** This relation takes a ComponentRef and a Program and an int and returns a string with the name of the nth
 ** connectors icon annotation in the class given by ComponentRef in the Program.
 **)
relation get_nth_connector_icon_annotation: (Absyn.ComponentRef, Absyn.Program, int) => string =
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_connector_str(modelpath,cdef,p,n) => (resstr,tp) &
	get_icon_annotation(tp,p) => resstr
	--------------------------
	get_nth_connector_icon_annotation(model,p,n)=> resstr

  axiom get_nth_connector_icon_annotation(_,_,_) => "-1"	
end

(** relation: get_diagram_annotation
 ** This relation takes a Path and a Program and returns a comma separated 
   string of values for the diagram annotation for the class named by the first argument.
**)
relation get_diagram_annotation: (Absyn.Path, Absyn.Program) => string =

  rule	get_pathed_class_in_program (modelpath,p) => cdef &
	get_base_classes(cdef) => crefs &
	get_diagram_annotation_from_baseclasses(crefs,p) => baseannlst &
	get_diagram_annotation_in_class(cdef) => s1 &
	Util.string_append_list(baseannlst) => s2 &
	string_append(s1,s2) => str
	---------------------------
	get_diagram_annotation(modelpath,p) => str

  axiom get_diagram_annotation(_,_) => "get_icon_annotation failed!"
end

(** relation: get_icon_annotation
 ** This relation takes a Path and a Program and returns a comma separated
 ** string of values for the icon annotation for the class named by the first argument. 	
 **  Icon annotation is composed of several things:
 **   1. Annotations in the class definition.
 **	2. Annotations in base classes. This implies performing a partial instantiation
 ** removing inheritance (and applying modifications there, but we skip applying modifications 
 ** for now, since dymola does not either.)
 *)
relation get_icon_annotation: (Absyn.Path, Absyn.Program) => string =
   rule	get_pathed_class_in_program(modelpath,p) => cdef &
	get_base_classes(cdef) => crefs &
	get_icon_annotation_from_baseclasses(crefs,p) => baseannlst &
	get_icon_annotation_in_class(cdef) => s1 &
	Util.string_append_list(baseannlst) => s2 &
	string_append(s1,s2) => str
	-----------------------------------------
	get_icon_annotation(modelpath,p) => str
  axiom get_icon_annotation(_,_) => "get_icon_annotation failed!"
end

(** relation: get_packages_in_path
 ** This relation takes a Path and a Program and returns a list of the names of the packages found in the Path.
**)

relation get_packages_in_path: (Absyn.Path,Absyn.Program) => string =

  rule	get_pathed_class_in_program(modelpath,p) => cdef &
	get_packages_in_class(modelpath,p,cdef) => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	----------------------
	get_packages_in_path (modelpath,p) => res
  axiom	 get_packages_in_path(_,_) => "-1"
end
(** relation: get_top_packages
 ** This relation takes a Path and a Program and returns a list of the names of the packages found in the Path.
 **)
relation get_top_packages: (Absyn.Program) => string =

  rule	get_top_packages_in_program(p) => strlist &
	Util.string_delimit_list(strlist,",") => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	-------------------------
	get_top_packages(p) => res

  axiom	get_top_packages(_) => "-1"
end

relation get_top_packages_in_program: Absyn.Program => string list =
	
  axiom	get_top_packages_in_program Absyn.PROGRAM([],_) => []
	
  rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	-----------------------------------------
	get_top_packages_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_PACKAGE,_)::rest,w)) => id::res

  rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	------------------------------------------
	get_top_packages_in_program (Absyn.PROGRAM(_::rest,w)) => res
end

(** relation: get_packages_in_class
 ** This relation takes a `Class' definition and a Path identifying th elcass. 
 ** It returns a string containing comma separated package names found 
 ** in the class definition.
 **)
relation get_packages_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) => string =

  rule	get_packages_in_parts(parts) => strlist &
	Util.string_delimit_list(strlist,",") => res
	-------------------------------------
	get_packages_in_class(_,_,Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts))) => res

  rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	get_packages_in_class(newpath,p,cdef) => res 
	--------------------------------------------
	get_packages_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,Absyn.DERIVED(path,_,_))) => res
end


relation get_packages_in_parts:(Absyn.ClassPart list ) => string list =

  axiom	get_packages_in_parts [] => []

  rule	get_packages_in_elts(elts) => l1 &
	get_packages_in_parts(rest) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_packages_in_parts(Absyn.PUBLIC(elts)::rest) => res	
	
  rule	get_packages_in_parts(rest) => res
	-----------------------------------
	get_packages_in_parts(_::rest) => res
end

relation get_packages_in_elts: (Absyn.ElementItem list) => string list =
  axiom	 get_packages_in_elts [] => []
	
  rule	get_packages_in_elts(rest) => res
	--------------------------------
	get_packages_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_PACKAGE,_))))::rest) => id::res

  rule	get_packages_in_elts(rest) => res
	--------------------------------
	get_packages_in_elts (_::rest) => res
end

relation get_models_in_path: (Absyn.Path,Absyn.Program) => string =

  rule	get_pathed_class_in_program(modelpath,p) => cdef &
	get_models_in_class(modelpath,p,cdef) => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	----------------------
	get_models_in_path (modelpath,p) => res
  axiom	 get_models_in_path(_,_) => "-1"
end
(** relation: get_top_models
 ** This relation takes a Path and a Program and returns a list of the names of the packages found in the Path.
 **)
relation get_top_models: (Absyn.Program) => string =

  rule	get_top_models_in_program(p) => strlist &
	Print.print_buf "program =" &
	Dump.dump p & Print.print_buf "\n" &
	Util.string_delimit_list(strlist,",") => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	-------------------------
	get_top_models(p) => res

  axiom	get_top_models(_) => "-1"
end

relation get_top_models_in_program: Absyn.Program => string list =
	
  axiom	get_top_models_in_program Absyn.PROGRAM([],_) => []
	
  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res &
	Print.print_buf "R_CLASS succeded\n"
	-----------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_CLASS,_)::rest,w)) => id::res

  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res
	& Print.print_buf "R_MODEL succeded\n"
	-----------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_MODEL,_)::rest,w)) => id::res

  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res
	& Print.print_buf "R_CONNECTOR succeded\n"
	-----------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_CONNECTOR,_)::rest,w)) => id::res

  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res
	& Print.print_buf "R_BLOCK succeded\n"
	-----------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_BLOCK,_)::rest,w)) => id::res

  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res
	& Print.print_buf "R_RECORD succeded\n"
	-----------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_RECORD,_)::rest,w)) => id::res

  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res
	& Print.print_buf "R_FUNCTION succeded\n"
	-----------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,Absyn.R_FUNCTION,_)::rest,w)) => id::res

  rule	get_top_models_in_program (Absyn.PROGRAM(rest,w)) => res
	------------------------------------------
	get_top_models_in_program (Absyn.PROGRAM(_::rest,w)) => res
end

(** relation: get_models_in_class
 ** This relation takes a `Class' definition and a Path identifying th elcass. 
 ** It returns a string containing comma separated package names found 
 ** in the class definition.
 **)
relation get_models_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) => string =

  rule	get_models_in_parts(parts) => strlist &
	Util.string_delimit_list(strlist,",") => res
	-------------------------------------
	get_models_in_class(_,_,Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts))) => res

  rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	get_models_in_class(newpath,p,cdef) => res 
	--------------------------------------------
	get_models_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,Absyn.DERIVED(path,_,_))) => res
end


relation get_models_in_parts:(Absyn.ClassPart list ) => string list =

  axiom	get_models_in_parts [] => []

  rule	get_models_in_elts(elts) => l1 &
	get_models_in_parts(rest) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_models_in_parts(Absyn.PUBLIC(elts)::rest) => res	
	
  rule	get_models_in_parts(rest) => res
	-----------------------------------
	get_models_in_parts(_::rest) => res
end

relation get_models_in_elts: (Absyn.ElementItem list) => string list =
  axiom	 get_models_in_elts [] => []
	
  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_CLASS,_))))::rest) => id::res
  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_MODEL,_))))::rest) => id::res
  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_RECORD,_))))::rest) => id::res
  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_BLOCK,_))))::rest) => id::res
  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_CONNECTOR,_))))::rest) => id::res

  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,Absyn.R_FUNCTION,_))))::rest) => id::res
  rule	get_models_in_elts(rest) => res
	--------------------------------
	get_models_in_elts (_::rest) => res
end

(* This relation gets all base classes of a class, NOT Recursive.*)
relation get_base_classes : (Absyn.Class) => Absyn.ComponentRef list =

  rule	get_base_classes_from_parts(parts) => res 
	-----------------------------------------
	get_base_classes (Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts))) =>res

  axiom	get_base_classes (_) => []
end

relation get_base_classes_from_parts: (Absyn.ClassPart list) => Absyn.ComponentRef list =

  rule	get_base_classes_from_elts(elts) => c1 &
	get_base_classes_from_parts(rest) => c2 &
	list_append(c1,c2) => res 
	----------------------------
	get_base_classes_from_parts(Absyn.PUBLIC(elts)::rest) => res

  rule	get_base_classes_from_parts(rest) => res
	----------------------------------------
	get_base_classes_from_parts(_::rest) => res

  axiom	get_base_classes_from_parts([]) => []
end

relation get_base_classes_from_elts : (Absyn.ElementItem list) => Absyn.ComponentRef list =
  rule	get_base_classes_from_elts(rest) => cl &
	Absyn.path_to_cref(path) => cref 
	------------------------
	get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.EXTENDS(path,_)))::rest )
	    => cref::cl
  rule	get_base_classes_from_elts(rest) => cl
	--------------------------------------
	get_base_classes_from_elts (_::rest) => cl

  axiom	get_base_classes_from_elts([]) => []
end

relation get_icon_annotation_from_baseclasses :(Absyn.ComponentRef list, Absyn.Program) 
	=> string list =
  axiom	get_icon_annotation_from_baseclasses([],p) => []

  rule	Absyn.cref_to_path cr => path &
	get_icon_annotation(path,p) => s1 &
	get_icon_annotation_from_baseclasses(rest,p) => s2
	------------------------------------------------
	get_icon_annotation_from_baseclasses(cr::rest,p) => s1::s2
end


relation get_icon_annotation_in_class : (Absyn.Class) => string =

  rule	get_public_list(parts) => publst &
	get_icon_annotation_in_elementitemlist(publst) => str
	----------------------------
	get_icon_annotation_in_class (Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts))) => str	
end


relation get_icon_annotation_in_elementitemlist: (Absyn.ElementItem list) => string =
  axiom	get_icon_annotation_in_elementitemlist [] => ""
	
  rule	get_icon_annotation_str(annlst) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str	
	----------------------------
	get_icon_annotation_in_elementitemlist (Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(annlst))::_) => str
	
  rule	get_icon_annotation_in_elementitemlist(xs) => str
	------------------------------------------------
	get_icon_annotation_in_elementitemlist(_::xs) => str
end

relation get_icon_annotation_str: (Absyn.ElementArg list) => string =

  rule	string_append(Icon_records,Graphics_records) => records &
	get_annotation_string (records,Absyn.ANNOTATION([ann])) => str 
	-----------------------------------------------
	get_icon_annotation_str ( (ann as Absyn.MODIFICATION(_,Absyn.CREF_IDENT("Icon",_),mod))::_) => str

  rule	get_icon_annotation_str (xs) => str
	-------------------------------
	get_icon_annotation_str( _::xs) => str
end

relation get_diagram_annotation_from_baseclasses :(Absyn.ComponentRef list, Absyn.Program) 
	=> string list =
  axiom	get_diagram_annotation_from_baseclasses([],p) => []

  rule	Absyn.cref_to_path cr => path &
	get_diagram_annotation(path,p) => s1 &
	get_diagram_annotation_from_baseclasses(rest,p) => s2
	------------------------------------------------
	get_diagram_annotation_from_baseclasses(cr::rest,p) => s1::s2
end

relation get_diagram_annotation_in_class : (Absyn.Class) => string =

  rule	get_public_list(parts) => publst &
	get_diagram_annotation_in_elementitemlist(publst) => str
	----------------------------
	get_diagram_annotation_in_class (Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts))) => str	
end

relation get_diagram_annotation_in_elementitemlist: (Absyn.ElementItem list) => string =
  axiom	get_diagram_annotation_in_elementitemlist [] => ""
	
  rule	get_diagram_annotation_str(annlst) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str	
	----------------------------
	get_diagram_annotation_in_elementitemlist (Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(annlst))::_) => str
	
  rule	get_diagram_annotation_in_elementitemlist(xs) => str
	------------------------------------------------
	get_diagram_annotation_in_elementitemlist(_::xs) => str
end

relation get_diagram_annotation_str: (Absyn.ElementArg list) => string =

  rule	string_append(Diagram_records,Graphics_records) => records &
	get_annotation_string (records,Absyn.ANNOTATION([ann])) => str 
	-----------------------------------------------
	get_diagram_annotation_str ( (ann as Absyn.MODIFICATION(_,Absyn.CREF_IDENT("Diagram",_),mod))::_) => str

  rule	get_diagram_annotation_str (xs) => str
	-------------------------------
	get_diagram_annotation_str( _::xs) => str
end

relation get_nth_public_connector_str: (Absyn.Path, Absyn.Class, Absyn.Program,  int) => (string,Absyn.Path) =
	
  rule	get_nth_connector_str (p, modelpath, elt, n) => (str,tp)
	------------------------------------------
	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,Absyn.PARTS(Absyn.PUBLIC(elt)::lst)), p, n)  
	  => (str,tp)
	
	(** The rule above failed, count the number of connectors in the first public list, subtract the number 
	 ** and try the rest of the list **)
  rule	count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,Absyn.PARTS([Absyn.PUBLIC(elt)]))) => c1 &
	int_sub(n,c1) => c2 &
	get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst)),p,c2) => (str,tp)
	--------------------------------------------------
	get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,Absyn.PARTS(Absyn.PUBLIC(elt)::lst)), p, n) => (str,tp)
	
  rule	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst)), p, n) => (str,tp)
	-----------------------------------------------------
	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,Absyn.PARTS(_::lst)), p, n) => (str,tp)
	
end

(** relation: get_nth_connector_str
 ** This relation takes an ElementItem list and an int and  returns the name of the nth connector component
 ** in that list. 
 **)

relation get_nth_connector_str: (Absyn.Program, Absyn.Path, Absyn.ElementItem list
				 ,int)
	  => (string, Absyn.Path) =

  rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	get_nth_public_connector_str(newmodelpath,cdef,p,n) => (str,tp)
	-----------------
	get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.EXTENDS(tp,_)))::lst,n) => (str,tp)

  rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	count_public_connectors(newmodelpath,p,cdef) => c1 &
	int_sub(n,c1) => c2 &
	get_nth_connector_str(p,modelpath,lst,c2) => (str,tp)
	-----------------
	get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.EXTENDS(tp,_)))::lst,n) => (str,tp) 

  rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,Absyn.R_CONNECTOR,_), newmodelpath) &
	get_nth_compname(complst,n) => str 
	----------------------------------
	get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,tp,complst)))::lst, n) 
	  => (str,tp)

  rule	(** Not so fast, since we lookup and instantiate two times just because this was not 
	 ** the connector we were looking for. **)
	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,Absyn.R_CONNECTOR,_), newmodelpath) &
	list_length(complst) => c1 &
	int_sub(n,c1) => newn &
	get_nth_connector_str(p,modelpath,lst,newn) => (str,tp)
	---------------------------------------
	get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,tp,complst)))::lst, n)
	  => (str,tp)
	
  rule	get_nth_connector_str(p,modelpath,lst,n) => (str,tp)
	---------------------------------------
	get_nth_connector_str(p,modelpath,_::lst,n) => (str,tp)

  axiom	get_nth_connector_str(p,modelpath,[],n) => fail
end

relation get_nth_compname: (Absyn.ComponentItem list, int) => string =

  axiom	get_nth_compname (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_)::lst,1) => id
	
  rule	int_sub(n,1) => n1 &
	get_nth_compname (xs, n1) => res
	--------------------------------
	get_nth_compname (_::xs,n ) => res
  axiom	get_nth_compname ([],_) => fail
end

(* This relation takes a Class and counts the number of connector components in the class. 
 * This also includes counting in inherited classes.
 *)
relation count_public_connectors: (Absyn.Path, Absyn.Program, Absyn.Class) => int =
	
  rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst))) => c1 &
	count_connectors(modelpath,p,elt) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_public_connectors (modelpath, p,  Absyn.CLASS(a,b,c,d,Absyn.PARTS(Absyn.PUBLIC(elt)::lst))) 
	    => res
	    
  rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst))) => res
	-----------------------------------------------------
	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,Absyn.PARTS(_::lst))) => res
	
  axiom count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,Absyn.PARTS([]))) => 0

  rule	lookup_classdef(cname,modelpath,p) => (cdef,newmodelpath) &
	count_public_connectors (newmodelpath,p,cdef) => res
	--------------------------------------------------
	count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,Absyn.DERIVED(cname,_,_))) => res
end

(** relation: count_connectors
 ** This relation takes a Path to the current model and a ElementItem list and returns the number 
 ** of connector components in that list.
 **)
relation count_connectors: (Absyn.Path, Absyn.Program, Absyn.ElementItem list) => int =

  rule	lookup_classdef(tp, modelpath,p) => (cdef,newmodelpath) &
	count_public_connectors(newmodelpath,p,cdef) => c1 &
	count_connectors(modelpath,p,lst) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.EXTENDS(tp,_)))::lst) => res

  rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,Absyn.R_CONNECTOR,_), newmodelpath) &
	list_length(complst) => c1 &
	count_connectors(modelpath,p,lst) => c2 &
	int_add(c1,c2) => res
	--------------------
	count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,tp,complst)))::lst) => res

	
	(* Rule above didn't match => element not connector components, try rest of list*)
  rule	count_connectors(modelpath, p, lst) => res 
	---------------------
	count_connectors(modelpath, p, _::lst) => res

  axiom	count_connectors(_, _, []) => 0
end

(** relation: get_connection_annotation_str
 ** This relation takes an `EquationItem' and returns a comma separated string of values 
 ** from the flat record of a connection annotation that is found in the `EquationItem'.
 **)
relation get_connection_annotation_str: Absyn.EquationItem => string =
	
  rule	get_annotation_string(Line_records,ann) => annstr
	-------------------------------------------------
	get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_), SOME(ann))) => annstr
	
	
  axiom	get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),NONE)) => fail
      
end

(**relation: get_nth_connectionitem_in_class
 ** This relation takes a `Class' and  an int ane returns the nth `EquationItem' containing a
 ** connect statement in that class.
**)
relation get_nth_connectionitem_in_class: (Absyn.Class, int) => Absyn.EquationItem =

  rule	get_nth_connectionitem_in_classparts(parts,n) => eq
	-------------------------
	get_nth_connectionitem_in_class ( Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts)),n) => eq
end

(**relation: get_nth_connectionitem_in_classparts
 ** This relation takes a `ClassPart' list and an int and returns 
** the nth connections as an `EquationItem'.
**)

relation get_nth_connectionitem_in_classparts: (Absyn.ClassPart list, int) => Absyn.EquationItem =
	
  rule	get_nth_connectionitem_in_equations(e,n) => eq
	-------------------------------------
	get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

	(* The rule above failed, subtract the number of connections in the first equation section *)
	(* and try with the rest of the classparts*)
  rule	count_connections_in_equations(e) => c1 &
	int_sub(n,c1)=> newn &
	get_nth_connectionitem_in_classparts(xs,newn) => eq
	-----------------------------------------------
	get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

  rule	get_nth_connectionitem_in_classparts(xs,n) => eq
	--------------------------------------------
	get_nth_connectionitem_in_classparts(_::xs,n) => eq

end

(** relation: get_nth_connection_in_equations
   ** This relation takes  an `Equation' list and an int and 
   ** returns the nth connection as an `Equation'. If the number is larger than the number of connections
 ** in the list, the relation fails.
**)
relation get_nth_connectionitem_in_equations: (Absyn.EquationItem list, int) => Absyn.EquationItem =

axiom	get_nth_connectionitem_in_equations ((eq as Absyn.EQUATIONITEM((Absyn.EQ_CONNECT(_,_)),_))::xs,1) => eq

  rule	int_sub (n,1) => newn &
	get_nth_connectionitem_in_equations (xs,newn) => eq
	-----------------------------------------------
	get_nth_connectionitem_in_equations (Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs,n) => eq

  rule	get_nth_connectionitem_in_equations (xs,n) => eq
	--------------------------------------------
	get_nth_connectionitem_in_equations (_::xs,n) => eq

  axiom get_nth_connectionitem_in_equations([],_) => fail
end

(** relation: get_connection_str
   ** This relation takes an `Equation' assumed to contain a connection and returns a 
   ** comma separated string of componentreferences, e.g "R1.n,C.p" for  connect(R1.n,C.p).
   **)
relation get_connection_str:  Absyn.Equation => string =
  rule	Absyn.cref_to_path cr1 => p1 &
	Absyn.cref_to_path cr2 => p2 &
	Absyn.path_string p1 => s1 &
	Absyn.path_string p2 => s2 &
	string_append(s1,",") => s3 &
	string_append(s3,s2) => str
	---------------------------
	get_connection_str Absyn.EQ_CONNECT(cr1,cr2) => str
end 

(** relation: count_connections
 ** This relation takes a `Class' and returns an int with the number of connections
** in the `Class'.
**)
relation count_connections: Absyn.Class => int =
	
  rule	count_connections_in_classparts(parts) => count
	-----------------------------------------------
	count_connections Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts)) => count
end

(** relation: count_connections_in_classparts
 ** This relation takes a `ClassPart' list and returns an int with the number of connections in that list.
**)
relation count_connections_in_classparts: Absyn.ClassPart list => int =

  rule	count_connections_in_equations(eqlist) => r1 &
	count_connections_in_classparts(xs) => r2 &
	int_add (r1,r2) => res
	----------------------
	count_connections_in_classparts( Absyn.EQUATIONS(eqlist)::xs) => res

  rule	count_connections_in_classparts(xs) => res
	------------------------------------------
	count_connections_in_classparts( _::xs) => res
	
	axiom count_connections_in_classparts([]) => 0
end

(** relation: count_connections_in_equations
 ** This relation takes an `Equation' list and returns  an int 
 ** with the number of connect statements in that list.
**)
relation count_connections_in_equations: Absyn.EquationItem list => int =
	
  rule	count_connections_in_equations(xs) => r1 &
	int_add(r1,1)  => res 
	---------------------
	count_connections_in_equations(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs) => res
	
  rule	count_connections_in_equations(xs) => res
	-----------------------------------------
	count_connections_in_equations(_::xs) => res
	
  axiom	count_connections_in_equations([]) => 0
end

(** relation: get_component_annotation
 ** This relation takes an `Element' and returns a comma separated string of values
 ** corresponding to the flat record for a component annotation. If several components are declared 
 ** within the eleement, a list of values is given for each of them.
**)
relation get_component_annotation: Absyn.Element => string =
	
  rule	get_componentitems_annotation(lst) => str
	-----------------------------------------
	get_component_annotation(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,_,lst))) => str
	axiom get_component_annotation _ => ""
end 

relation get_componentitems_annotation: Absyn.ComponentItem list => string =
	
  rule	get_annotation_string(Placement_records, ann) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"},") => s3 &
	get_componentitems_annotation(rest) => str &
	string_append(s3,str) => res
	----------------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,SOME(ann))::(rest as (_::_))) => res
	
  rule	get_annotation_string(Placement_records, ann) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => res 
	----------------------------
	get_componentitems_annotation ([Absyn.COMPONENTITEM(_,SOME(ann))]) => res

  rule	get_componentitems_annotation(rest) => str &
	string_append("{},",str) => res
	-----------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,NONE)::(rest as (_::_))) => res

  rule	let res = "{}"
	-----------------------
	get_componentitems_annotation ([Absyn.COMPONENTITEM(_,NONE)]) => res
end

(** relation_ get_annotation_string
 ** This relation takes an annotation and returns a comma separates string of values
 ** representing the flat record of the specific annotation.
 ** The relation as two special rules for handling of Icon and Diagram annotations since these 
 ** two contain graphic primitives, which must be handled specially because Modelica does not have 
 ** the possibility to store polymorphic values (e.g. different record classes with the same base class)
 ** in for instance an array.
**)

relation get_annotation_string: (string,Absyn.Annotation) => string =

  rule	strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,Absyn.CLASSMOD(_,SOME(graphicexp)))]) &
	SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &
	
        Parser.parsestring totstring => p &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("Icon")) => env  & 
	get_class_in_program("Icon",p) => placementc &
	SCode.elab_class(placementc) => placementclass &
	Mod.elab_mod (env,Prefix.NOPRE,mod') => mod'' &
	Inst.inst_class(env,mod'',Prefix.NOPRE,[],placementclass,[]) => (dae,cs,t,state) &
	Print.print_buf "Instantiated Icon class, without graphics primitives\n" &
	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
     	DAE.get_variable_bindings_str dae' => str  &
	
	Static.elab_graphics_exp(env,graphicexp) => (graphicexp2,prop) &
	Exp.print_exp_str(graphicexp2) => gexpstr &
	string_append(str,",") => s1 &
	string_append(s1,gexpstr) => totstr
	-----------------------------------
	get_annotation_string(totstring,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,Absyn.CREF_IDENT("Icon",_),Absyn.CLASSMOD(mod,_)))])) => totstr

  rule	strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,Absyn.CLASSMOD(_,SOME(graphicexp)))]) &
	SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &
	
        Parser.parsestring totstring => p &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("Diagram")) => env  & 
	get_class_in_program("Diagram",p) => placementc &
	SCode.elab_class(placementc) => placementclass &
	Mod.elab_mod (env,Prefix.NOPRE,mod') => mod'' &
	Inst.inst_class(env,mod'',Prefix.NOPRE,[],placementclass,[]) => (dae,cs,t,state) &
	Print.print_buf "Instantiated Diagram class, without graphics primitives\n" &
	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
     	DAE.get_variable_bindings_str dae' => str  &
	
	Static.elab_graphics_exp(env,graphicexp) => (graphicexp2,prop) &
	Exp.print_exp_str(graphicexp2) => gexpstr &
	string_append(str,",") => s1 &
	string_append(s1,gexpstr) => totstr
	-----------------------------------
	get_annotation_string(totstring,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,Absyn.CREF_IDENT("Diagram",_),Absyn.CLASSMOD(mod,_)))])) => totstr

  rule	SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false) => mod' & 

        Parser.parsestring totstring => p &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT(anncname)) => env  & 
	get_class_in_program(anncname,p) => placementc &
	SCode.elab_class(placementc) => placementclass &
	Mod.elab_mod (env,Prefix.NOPRE,mod') => mod'' &
	Inst.inst_class(env,mod'',Prefix.NOPRE,[],placementclass,[]) => (dae,cs,t,state) &
	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
	Debug.fprint ("interactivedump","Annotation DAE = ") &
	Debug.fcall ("interactivedump", DAE.dump2, DAE.DAE(dae)) &
	Debug.fprint ("interactivedump","Mod =") &
	Debug.fcall ("interactivedump",SCode.print_mod, mod') &
     	DAE.get_variable_bindings_str dae' => str 
	-----------------------------------------
	get_annotation_string(totstring, Absyn.ANNOTATION([(Absyn.MODIFICATION(_,Absyn.CREF_IDENT(anncname,_),Absyn.CLASSMOD(mod,_)))])) => str

  rule	Print.print_buf "get_annotation_string failed!\n"
	---------------------------------------
	get_annotation_string(_,_) => fail
end

(** relation: strip_graphics_modification
 ** This relation strips out the `graphics' modification from an ElementArg list and return 
 ** two lists, one with the other modifications and the second with the `graphics' modification
**)
relation strip_graphics_modification: (Absyn.ElementArg list) => (Absyn.ElementArg list, Absyn.ElementArg list) =
	
  axiom	strip_graphics_modification((mod as Absyn.MODIFICATION(_,Absyn.CREF_IDENT("graphics",_),_))::rest) => (rest, [mod])
	
  rule	strip_graphics_modification(rest) => (l1,l2) 
	------------------------------------------
	strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,_))::rest) => (mod::l1,l2)

  axiom	strip_graphics_modification([]) => ([],[])
end
	
relation get_nth_public_component_in_class:  (Absyn.Class,int) => Absyn.Element =
	
  rule	get_nth_component_in_elementitems(elt,n) => res
	-----------------------------------------------
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.PARTS(Absyn.PUBLIC(elt)::lst)),n) 
	    => res
	    
	    (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	    (* subtract and try next public list *)
  rule	count_components(elt) => c1 &
	int_sub(n,c1) => newn &
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.PARTS(rest)),newn) => res
	------------------------------------------------------------------------------------
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.PARTS(Absyn.PUBLIC(elt)::rest)),n) => res

  rule	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.PARTS(lst)),n) => res
	-----------------------------------------------------------------------
	get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.PARTS(_::lst)),n) => res
	
  axiom get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.PARTS([])),_) => fail
  axiom get_nth_public_component_in_class (Absyn.CLASS(a,b,c,d,Absyn.DERIVED(_,_,_)),_) => fail

end

(** relation: get_nth_component_in_elementintems 
 ** This relation takes an `ElementItem' list and and integer and returns the nth component 
 ** in the list
**)
relation get_nth_component_in_elementitems: (Absyn.ElementItem list, int) => Absyn.Element =
	
  axiom	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,1) => elt

  rule	int_ge(n,1) => true &
	int_sub(n,1) => newn &
	get_nth_component_in_elementitems(rest,newn) => res
	---------------------------------------------------
	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,n) => res

  rule	get_nth_component_in_elementitems(rest,n) => res
	------------------------------------------------
	get_nth_component_in_elementitems(_::rest,n) => res

  axiom	get_nth_component_in_elementitems([],_) => fail
end

(** relation: get_component_name_and_type
 ** This relation takes an `Element' and returns a string of comma separated values of the 
 **  type and name of the component, e.g. "Resistor,R1" or "Resistor,R1,R2"
 ** If Element is not a component, the empty string is returned
**)
relation get_component_name_and_type: Absyn.Element => string =

  rule	Absyn.path_string(p) => typename &
	get_componentitems_name(lst) => names &
	string_append(typename,",") => s1 &
	string_append(s1,names) => str
	-------------------------------------------
	get_component_name_and_type(Absyn.ELEMENT(_,_,_,Absyn.COMPONENTS(_,p,lst))) => str
end

(** relation_get_componentitems_name
 ** This relation takes a `ComponentItems' list and returns a comma separated list of all
 ** component names.
**)


relation get_componentitems_name: Absyn.ComponentItem list => string =
	
  rule	string_append(c1,",") => s1 &
	get_componentitems_name(c2::rest) => s2 &
	string_append(s1,s2) => str
	----------------------------
	get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_)::(c2::rest)) => str
  rule	get_componentitems_name(rest) => res
	------------------------------------
	get_componentitems_name(_::rest) => res

  axiom	get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_)]) => c1

  axiom	get_componentitems_name([_]) => ""
end
(** relation: add_to_public
 ** This relation takes a 'Class' definition and adds an `ElementItem' to the first public list in the class.
 ** If no public list is available in the class one is created.
 **)
relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

  rule	get_public_list(parts) => publst &
	let publst2 = eitem::publst &
	replace_public_list(parts,publst2) => parts2 
	--------------------------------------------
	add_to_public ( Absyn.CLASS(i,p,e,r,Absyn.PARTS(parts)), eitem) 
	    => Absyn.CLASS(i,p,e,r,Absyn.PARTS(parts2))

  axiom	add_to_public ( Absyn.CLASS(i,p,e,r,Absyn.DERIVED(_,_,_)),eitem) => fail

  axiom	add_to_public(Absyn.CLASS(i,p,e,r,Absyn.PARTS(parts)),eitem)
	    => Absyn.CLASS(i,p,e,r,Absyn.PARTS(Absyn.PUBLIC([eitem])::parts))

end

(** relation: add_to_equation
 ** This relation takes a 'Class' definition and adds an `EquationItem' to the first equation list in the class.
 ** If no public list is available in the class one is created.
 **)
relation add_to_equation: (Absyn.Class, Absyn.EquationItem) => Absyn.Class = 

  rule	get_equation_list(parts) => eqlst &
	let eqlst2 = eitem::eqlst &
	replace_equation_list(parts,eqlst2) => parts2 
	--------------------------------------------
	add_to_equation ( Absyn.CLASS(i,p,e,r,Absyn.PARTS(parts)), eitem) 
	    => Absyn.CLASS(i,p,e,r,Absyn.PARTS(parts2))

  axiom	add_to_equation ( Absyn.CLASS(i,p,e,r,Absyn.DERIVED(_,_,_)),eitem) => fail

  rule	(* Add the equations last, to make nicer output if public section present *)
	list_append(parts,[Absyn.EQUATIONS([eitem])]) => newparts
	------------------
	add_to_equation(Absyn.CLASS(i,p,e,r,Absyn.PARTS(parts)),eitem)
	    => Absyn.CLASS(i,p,e,r,Absyn.PARTS(newparts))
end


(** relation: replace_class_in_program
 ** This relation takes a `Class' and a `Program' and replaces the class definition 
 ** at the top level in the program by the class definition of the `Class'.
 **)
relation replace_class_in_program: (Absyn.Class, Absyn.Program) => Absyn.Program =
  axiom replace_class_in_program(c, Absyn.PROGRAM([],w)) => Absyn.PROGRAM([c],w)
  rule	name1 = name2
	-------------
	replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_),Absyn.PROGRAM(Absyn.CLASS(name2,_,_,_,_)::clst,w))
	    => Absyn.PROGRAM(c::clst,w)
	    
  rule	not name1 = name2 &
	replace_class_in_program(c, Absyn.PROGRAM(clst,w)) => Absyn.PROGRAM(newclst,w)
	-------------------------------------------------------
	replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_),
	    Absyn.PROGRAM((c1 as Absyn.CLASS(name2,_,_,_,_))::clst,w)) 
	    => Absyn.PROGRAM(c1::newclst,w)

  rule	Print.print_buf "replace_class_in_program failed \n class:" &
	Debug.fcall ("dump", Dump.dump, Absyn.PROGRAM([c],Absyn.TOP)) &
	Print.print_buf "\nprogram: \n" &
	Debug.fcall ("dump", Dump.dump, p)
	----------------------------
	replace_class_in_program(c,p) => fail
end
	
(** relation: insert_class_in_program 
 ** This relation inserts the class into the Program at the scope given by the 
 ** within argument. If the class referenced by the within argument is not 
 **  defined, the relation prints an error message and fails.
 **)
	
relation insert_class_in_program: (Absyn.Class, Absyn.Within, Absyn.Program) => Absyn.Program =

  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &

	update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1,w as Absyn.WITHIN(Absyn.QUALIFIED(n1,_)),p) => pnew
	
  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &
	update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1, w as Absyn.WITHIN(Absyn.IDENT(n1)),p) => pnew
	
  rule	Print.print_buf "Error inserting in class, within name, where name is not defined\n" 
	-------------------
	insert_class_in_program(c1,_,p) => fail	
end

(** relation: insert_class_in_class
 ** This relation takes a class to update (the first argument)  and an inner 
 ** class (which is either replacing
 ** an earlier class or is a new inner definition) and a within statement
 ** pointing inside the class (including the class itself in the reference), and updates the class with the inner class.
 **)
relation insert_class_in_class: (Absyn.Class, Absyn.Within, Absyn.Class) => Absyn.Class =
	
  rule  replace_inner_class(c1,c2) => cnew  	
	----------------------------------
	insert_class_in_class(c1,Absyn.WITHIN(Absyn.IDENT(name)),c2) => cnew

  rule  get_first_ident_from_path(path) => name2 &
        get_inner_class(c2,name2) => cinner &
	insert_class_in_class(c1,Absyn.WITHIN(path),cinner) => cnew &
        replace_inner_class(cnew,c2) => cnew' 
	---------------------------------------------
	insert_class_in_class(c1,Absyn.WITHIN(Absyn.QUALIFIED(name,path)),c2) => cnew'
	
  rule Print.print_buf "insert_class_in_class failed\n"
	-------------------------------------
	insert_class_in_class(_,_,_) => fail
end

(** relation: get_first_ident_from_path
 ** This relation takes a `Path` as argument and returns the first `Ident' of the path.
 **)
relation get_first_ident_from_path: Absyn.Path => Absyn.Ident =
     axiom get_first_ident_from_path (Absyn.IDENT(name)) => name
     axiom get_first_ident_from_path (Absyn.QUALIFIED(name,path)) => name
end

(** relation: replace_inner_class 
 ** This relation takes two class definitions. The first one is inserted/replaced as a local class inside the second one.
 **)
relation replace_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

  rule	get_public_list(parts) => publst &
	replace_class_in_elementitemlist(publst,c1) => publst2 &
	replace_public_list(parts,publst2) => parts2 
	-----------------------------------------------
	replace_inner_class (c1,Absyn.CLASS(a,b,c,d,Absyn.PARTS(parts))) 
	    => Absyn.CLASS(a,b,c,d,Absyn.PARTS(parts2))
  rule	Print.print_buf "Failed in replace_inner_class\n"
	---------------------------------------
	replace_inner_class (_,_) => fail
end

(** relation: replace_class_in_elementitemlist
 ** This relation takes an Element list and a Class and returns a modified element list
 ** where the class definition of the class is updated or added.
  **)
relation replace_class_in_elementitemlist: (Absyn.ElementItem list, Absyn.Class) => Absyn.ElementItem list =
	
  rule	replace_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	replace_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

  rule	not name1 = name &
	replace_class_in_elementitemlist(xs,c) => res
	------------------------------------------
	replace_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_)))))::xs,c as Absyn.CLASS(name,_,_,_,_)) => e1::res
	

  rule name1 = name 
	-----------------------------
	replace_class_in_elementitemlist(
	    (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,Absyn.CLASSDEF(d, Absyn.CLASS(name1,_,_,_,_)))))::xs,
	    c2 as Absyn.CLASS(name,_,_,_,_))
	    => Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,Absyn.CLASSDEF(d,c2)))::xs
	
  axiom	 replace_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c)))]
end

(** relation: get_inner_class
 ** This relation takes a class name and a class and return the inner class definition 
 ** having that name.
**)
relation get_inner_class: (Absyn.Class, Absyn.Ident) => Absyn.Class =
  rule	get_public_list(parts) => publst &
	get_class_from_elementitemlist(publst,name) => c1
	-----------------------------------------------
	get_inner_class (Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts)), name) => c1

  rule	Print.print_buf "get_inner_class failed, c:" &
	Debug.fcall ("dump", Dump.dump,Absyn.PROGRAM([c],Absyn.TOP)) &
	Print.print_buf "name :" & Print.print_buf name 
	--------------
	get_inner_class (c,name) => fail
end

(** relation: replace_public_list
 ** This relation replaces the `ElementItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_public_list: (Absyn.ClassPart list,Absyn.ElementItem list) => Absyn.ClassPart list =

  axiom replace_public_list ((lst as Absyn.PUBLIC(_))::rest,newpublst) => Absyn.PUBLIC(newpublst)::rest
	
  rule	replace_public_list(xs,new) => ys
	---------------------------------
	replace_public_list(x::xs,new) => x::ys

  axiom replace_public_list([],_) => []
end

(** relation: replace_equation_list
 ** This relation replaces the `EquationItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_equation_list: (Absyn.ClassPart list,Absyn.EquationItem list) => Absyn.ClassPart list =

  axiom replace_equation_list ((lst as Absyn.EQUATIONS(_))::rest,newpublst) 
	  => Absyn.EQUATIONS(newpublst)::rest
	
  rule	replace_equation_list(xs,new) => ys
	---------------------------------
	replace_equation_list(x::xs,new) => x::ys

  axiom replace_equation_list([],_) => []
end


(** relation: get_public_list
 ** This relation takes a ClassPart List and returns the first public ElementItem list of the class.
 **
*)
relation get_public_list: Absyn.ClassPart list => Absyn.ElementItem list =

  axiom get_public_list Absyn.PUBLIC(lst)::rest => lst
	
  rule	get_public_list(xs) => ys
	---------------------------
	get_public_list(x::xs) => ys

  axiom get_public_list(_) => fail
end

(** relation: get_equation_list
 ** This relation takes a ClassPart List and returns the first EquationItem list of the class.
 **
*)
relation get_equation_list: Absyn.ClassPart list => Absyn.EquationItem list =

  axiom get_equation_list Absyn.EQUATIONS(lst)::rest => lst
	
  rule	get_equation_list(xs) => ys
	---------------------------
	get_equation_list(x::xs) => ys

  axiom get_equation_list(_) => fail
end


(** relation: get_class_from_elementitemlist
 ** This relation takes an ElementItem list and an Ident and returns the class definition
 ** among the element list having that identifier
  **)
relation get_class_from_elementitemlist: (Absyn.ElementItem list, Absyn.Ident) => Absyn.Class =
	
  rule	get_class_from_elementitemlist(xs,name) => res
	----------------------------------------------
	get_class_from_elementitemlist(Absyn.ANNOTATIONITEM(_)::xs,name) => res

  rule	name1 = name2
	------------------------------
	get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_))))::xs,name2) => c1

  rule	not name1 = name &
	get_class_from_elementitemlist(xs,name) => res
	------------------------------------------
	get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_))))::xs,name) => res

  axiom	 get_class_from_elementitemlist([],_) => fail
end

(** relation: class_in_program
 ** This relation takes a name and a Program and returns true if the name exists as a top class in the program.
**)

relation class_in_program:(string,Absyn.Program) => bool = 

  axiom class_in_program (str,Absyn.PROGRAM([],_)) => false
	
  rule	not str = c1 &
	class_in_program(str,Absyn.PROGRAM(p,w)) => res
	-----------------------
	class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_)::p,w)) => res
	
  axiom class_in_program (_,_) => true
end

(** relation: path_in_program
 ** This relation takes a path and a program and returns true if the class
 ** referenced by the path exist in the program
*)
relation path_in_program: (Absyn.Path, Absyn.Program) => bool =
	
  rule	Absyn.path_string(path) => pathstr &
	class_in_program(pathstr,p) => res
	-----------------------------------
	path_in_program (path as Absyn.IDENT(name),p) => res
	
  rule	class_in_program(c1,p) => true &
	get_class_in_program(c1,p) => c1def &
	path_in_program(prest,Absyn.PROGRAM([c1def],w)) => res
	------------------------------------
	path_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res
end

(** relation: get_pathed_class_in_program
 ** This relation takes a `Path' and a `Program` and retrieves the class definition referenced 
 ** by the `Path' from the `Program'.
*)
relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) => Absyn.Class =

  rule	get_class_in_program(str,p) => c1
	---------------------------------
	get_pathed_class_in_program (Absyn.IDENT(str),p) => c1
	
  rule	get_class_in_program(c1,p) => c1def &
	get_classes_in_class(Absyn.IDENT(c1),p,c1def) => classes &
	get_pathed_class_in_program(prest,Absyn.PROGRAM(classes,w)) => res
	------------------------------------------------------------
	get_pathed_class_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res
end

(** relation: get_classes_in_class
 ** This relation takes a `Class' definition and returns a list of local `Class' definitions of that class.-
 **)
relation get_classes_in_class: (Absyn.Path, Absyn.Program,Absyn.Class) => Absyn.Class list =

  rule	get_classes_in_parts(parts)  => res
	--------------------------
	get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,Absyn.PARTS(parts))) => res

  rule	lookup_classdef(path, modelpath,p) => (cdef,newpath) &
	get_classes_in_class(newpath,p,cdef) => res
	--------------------------------------------
	get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,Absyn.DERIVED(path,_,_))) => res
end

relation get_classes_in_parts: Absyn.ClassPart list => Absyn.Class list =

  axiom	 get_classes_in_parts [] => []	

  rule	get_classes_in_parts(rest) => l1 &
	get_classes_in_elts(elts) => l2 &
	list_append(l1,l2) => res
	------------------------
	get_classes_in_parts (Absyn.PUBLIC(elts)::rest) => res

  rule	get_classes_in_parts(rest) => res
	---------------------------------
	get_classes_in_parts(_::rest) => res
end

relation get_classes_in_elts: Absyn.ElementItem list => Absyn.Class list =
  axiom	get_classes_in_elts [] => []
  rule	get_classes_in_elts (rest) => res
	---------------------------------
	get_classes_in_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,Absyn.CLASSDEF(_,class)))::rest)
	    => class::res
  rule	get_classes_in_elts (rest) => res
	---------------------------------
	get_classes_in_elts (_::rest)
	    => res
end

(** relation: get_class_in_program
 ** This relation takes a Path and a Program and returns the class with the name `Path'.
 ** If that class does not exist, the relation fail
**)

relation get_class_in_program:(string, Absyn.Program) => Absyn.Class = 

  axiom get_class_in_program (str,Absyn.PROGRAM([],_)) => fail

  rule	not str = c1 &
	get_class_in_program(str,Absyn.PROGRAM(p,w)) => res
	-----------------------------------------
	get_class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_)::p,w)) => res
	
  rule  str = c1name
	------------
	get_class_in_program (str, Absyn.PROGRAM((c1 as Absyn.CLASS(c1name,_,_,_,_))::p,w)) => c1
end

(** relation: annotation_list_to_absyn
 ** This relation takes a list of `NamedArg' and returns an absyn `Annotation'.
 ** for instance [annotation = Placement( ...) ] is converted to ANNOTATION(Placement(...)) 
 **)
relation annotation_list_to_absyn: (Absyn.NamedArg list) => Absyn.Annotation =
  axiom annotation_list_to_absyn( [] ) => Absyn.ANNOTATION([])
	
  rule	record_constructor_to_modification(e) => eltarg
	------------------------------------
	annotation_list_to_absyn(Absyn.NAMEDARG("annotate",e)::_) => Absyn.ANNOTATION([eltarg])
	
  rule	annotation_list_to_absyn(al) => annres
	--------------------------------------
	annotation_list_to_absyn(a::al) => annres
end
	
(** relation:record_constructor_to_modification
 ** This relation takes a record constructor expression and translates it into a `ElementArg'.
 ** Since modifications must be named, only named arguments are treated in the record constructor.
 **)
relation record_constructor_to_modification: (Absyn.Exp ) => Absyn.ElementArg =

  rule	Util.list_map(nargs,namedarg_to_modification) => eltarglst &
        let res = Absyn.MODIFICATION(false,cr,Absyn.CLASSMOD(eltarglst,NONE))
	-----------------------------------
	record_constructor_to_modification(Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs))) => res	
end

(** relation: namedarg_to_modification
 ** This relation takes a `NamedArg' and translates it into a `ElementArg'.
 **)
relation namedarg_to_modification: (Absyn.NamedArg) => Absyn.ElementArg = 

  rule	record_constructor_to_modification(c) => elt &
	let res = Absyn.MODIFICATION(false,cr,Absyn.CLASSMOD([elt],NONE))
	----------------------------
	namedarg_to_modification( Absyn.NAMEDARG(id,c as Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs)))) => res

  rule	let res = Absyn.MODIFICATION(false,Absyn.CREF_IDENT(id,[]),Absyn.CLASSMOD([],SOME(e)))
	----------------------------------------------------------------
	namedarg_to_modification( Absyn.NAMEDARG(id,e)) => res
end
