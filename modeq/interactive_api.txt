TODO: Add comments and modifications to appropriate functinons, such
as addComponent, newModel, etc. (Low priority)
TODO: Add functions for retrieval of icon information. (High Priority)

API for interactive environment
===============================

The API for interactive/incremental development consist of a set of
Modelica functions. They are sent to the interactive environment as
plain text and parsed using an expression parser for Modelica. The API
will be used by humans when interactively building models, directly or
by using scripts, but also by for instance a model editor who wants to
interact with the symbol table for adding/changing/removing models and
components, etc.

When a function fails to perform its action the string "-1" is returned.


Definitions:
------------
An == Argument no. n
<cref> == Component Reference, e.g. `A.B.C' or `A'
<ident> == identifier, e.g. `A' or `Modelica'
<string> == Modelica string, e.g. `"Nisse"' or `"foo"' 
<expr> == Arbitrary Modelica expression
The following functions are provided:

Function				Meaning
===========				=======
saveModel(<cref>,<string>)		Saves the model (A0) in a file
					given by a string (A1).

loadFile(<string>)			Loads all models in the file.

loadModel(<cref>)			Loads the model (A0) by looking up the 
					correct file to load in $MODELICAPATH. 
					Loads all models in that file into 
					the symbol table.

createModel(<cref>)			Creates an empty model.

deleteModel(<cref>)			Deletes the model from the
					symbol table.

addComponent(<ident>,<cref>,		Adds a component with name (A0),
	<cref>,annotate=<expr>)		type (A1), and class (A2) as
					arguments. Optional
					annotations are given with
					the named argument `annotate'.

deleteComponent(<ident>,<cref>)		Deletes a component (A0)
					within a class (A1).

updateComponent(<ident>,<cref>,		Updates an already existing component.
	<cref>,annotate=<expr>)

getComponentCount(<cref>)		Returns the number of
					components in a class.

getNthComponent(<cref>,<int>)		Returns the belonging class, 
					component name and  type name
					of the nth component of a class.
					e.g. "A.B.C,R2,Resistor"


getNthComponentAnnotation(<cref>,<int>) Returns the flattened
					annotation record of the nth
					component.
					Consists of a comma separated
					string of 15 values, see
					Annotations below, e.g "false,10,30,..."

getConnectionCount(<cref>)		Returns the number of
					connections in the model.

getNthConnection(<cref>,<int>)		Returns the nth connection,
					as a comma separated pair of
					connectors, e.g. "R1.n,R2.p".
deleteConnection(<cref>,<cref>,<cref>)	Deletes the connection between the two 
					connectors given as arguments A1,A2. A0 is 
					the model name.
deleteNthConnection(<cref>,<int>)	Deletes the nth connection in class given 
					by A0. 
getNthConnectionAnnotation(<cref>,<int>)
					Returns the nth connection
					annotation as comma separated
					list of values of a flattened
					record, see Annotation below.
addConnection(<cref>,<cref>,<cref>, annotate=<expr>)
					Adds connection connect(A0,A1)
					to model A2, with annotation
					given by the named argument
					annotate.

updateConnection(<cref>,<cref>,<cref>, annotate=<expr>)
					Updates an allready existing
					connection

addEquation(<cref>,<expr>,<expr>)	Adds the equation A1=A2 to the
					model named by A0.
getEquationCount(<cref>)		returns the number of
					equations in the model named
					A0. (This includes connections)
getNthEquation(<cref>,<int>)		returns the nth (A1) equation of
					the model named by A0. e.g
					"der(x)=-1" or
					"connect(A.b,C.a)"
deleteNthEquation(<cref>,<int>)		Deletes	the nth (A1) equation
					in the model named by A0.
					
getConnectorCount(<cref>)		Returns the number of
					connectors of a class.
					NOTE: partial instantiation of
					inheritance performed

getNthConnector(<cref>,<int>)		Returns the name of the nth
					connector, e.g "n".

getNthConnectorIconAnnotation(<cref>,<int>)	
					Returns the nth connector
					icon layer annotation as comma separated
					list of values of a flat
					record, see Annotation below.
					NOTE: Since connectors can be
					inherited, a partial
					instantiation of the
					inheritance structure is performed.

getNthConnectorDiagramAnnotation(<cref>,<int>)
					Returns the nth connector
					diagram layer annotation as comma separated
					list of values of a flat
					record, see Annotation below.
					NOTE: Since connectors can be
					inherited, a partial
					instantiation of the
					inheritance structure is
					performed.

getIconAnnotation(<cref>)		Returns the Icon Annotation of 
					the class named by A0. 

getDiagramAnnotation(<cref>)		Returns the Diagram annotation of 
					the class named by A0. 
					NOTE: Since the Diagram 
					annotations can be found in base
					classes a partial instantiation is 
					performed that flattens the inheritance 
					hierarchy in order to find all annotations.

ERROR Handling
==============
When an error occur in any of the functions above, the string
"-1" is returned.

Annotations
===========
1. Component annotations.
------------------------
Component annotations are modifications of the following (flattened)
Modelica record:
record Placement
       Boolean visible = true;
       Real transformation.x=0;
       Real transformation.y=0;
       Real transformation.scale=1;	
       Real transformation.aspectRatio=1;	
       Boolean transformation.flipHorizontal=false;
       Boolean transformation.flipVertical=false;
       Real transformation.rotation=0;
       Real iconTransformation.x=0;
       Real iconTransformation.y=0;
       Real iconTransformation.scale=1;	
       Real iconTransformation.aspectRatio=1;	
       Boolean iconTransformation.flipHorizontal=false;
       Boolean iconTransformation.flipVertical=false;
       Real iconTransformation.rotation=0;
end Placement;

Connection annotations are modifications of the following (flattened)
Modelica record:

record Line
  Real points[2][:];
  Integer color[3]={0,0,0};
  enumeration(None,Solid,Dash,Dot,DashDot,DashDotDot) pattern = Solid;
  Real thickness=0.25;
  enumeration(None,Open,Filled,Half) arrow[2] = {None, None};
  Real arrowSize=3.0;
  Boolean smooth=false;
end Line;

This is the Flat record Icon, used for Icon layer annotations
record Icon 
  Real  coordinateSystem.extent[2,2] = {{-10, -10}, {10, 10}});
  GraphicItem[:] graphics;
end Icon;
The textual representation of this flat record is somewhat more
complicated, since the graphics vector can conceptually contain
different subclasses, like Line, Text, Rectangle, etc. To solve this,
we will use record constructor functions as the expressions of these.
For instance, the following annotation
annotation (
Icon(coordinateSystem={{-10,-10}, {10,10}},
graphics={Rectangle(extent={{-10,-10}, {10,10}}),
Text({{-10,-10}, {10,10}}, textString=”Icon”)}));

will produce the following string representation of the flat record
Icon:
{{{-10,-10},{10,10}},{Rectangle(true,{0,0,0},{0,0,0},LinePattern.Solid,FillPattern.None,0.25,BorderPattern.None,{{-10,-10},{10,10}},0),Text({{-10,-10},{10,10}},textString="Icon")}}

This is the flat record for the Diagram annotation:

record Diagram
  Real  coordinateSystem.extent[2,2] = {{-10, -10}, {10, 10}});
  GraphicItem[:] graphics;
end Diagram;

The flat records string representation is identical to the flat record 
of the Icon annotation.

Flat records for Graphic Primitives.
====================================
record Line
  Boolean visible = true;
  Real points[2,:];
  Integer color[3] = {0,0,0};
  LinePattern pattern = LinePattern.Solid;
  Real thickness = 0.25;
  Arrow arrow[2] = {Arrow.None, Arrow.None};
  Real arrowSize = 3.0;
  Boolean smooth = false;
end Line;

record Polygon
  Boolean visible = true;
  Integer lineColor[3]={0,0,0};
  Integer fillColor[3]={0,0,0};
  LinePattern pattern = LinePattern.Solid;
  FillPattern fillPattern = FillPattern.None;
  Real lineThickness = 0.25;
  Real points[2,:];
  Boolean smooth = false;
end Polygon;
  
record Rectangle
  Boolean visible=true;
  Integer lineColor[3]={0,0,0};
  Integer fillColor[3]={0,0,0};
  LinePattern pattern = LinePattern.Solid;
  FillPattern fillPattern = FillPattern.None;
  Real lineThickness = 0.25;
  BorderPattern borderPattern = BorderPattern.None;
  Real extent[2,2];
  Real radius;
end Rectangle;

record Ellipse
  Boolean visible = true;
  Integer lineColor[3]={0,0,0};
  Integer fillColor[3]={0,0,0};
  LinePattern pattern = LinePattern.Solid;
  FillPattern fillPattern = FillPattern.None;
  Real lineThickness = 0.25;
  Real extent[2,2];
end Ellipse;

record Text
  Boolean visible = true;
  Integer lineColor[3]={0,0,0};
  Integer fillColor[3]={0,0,0};
  LinePattern pattern = LinePattern.Solid;
  FillPattern fillPattern = FillPattern.None;
  Real lineThickness = 0.25;
  Real extent[2,2];
  String textString;
  Real fontSize;
  String fontName;
  TextStyle textStyle[:];  //Problem, fails to instantiate if 
			   // styles are given as modification
end Text;
  
record BitMap
  Boolean visible = true;
  Real extent[2,2];
  String fileName;
  String imageSource;
end BitMap;
