(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "explode.rml"
  with "cache.rml"

  relation lookup_type       : (Env.Env, Absyn.Path) => (Types.Type,Env.Env)
  relation lookup_class      : (Cache.Cache, Env.Env, Absyn.Path,bool) 
				=> (Cache.Cache, SCode.Class, Env.Env)
  relation complete_path     : (Env.Env, Absyn.Path) => Absyn.Path
  relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) 
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool)
  relation lookup_ident : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool)
  relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) 
end

with "parse.rml"
with "debug.rml"
with "dump.rml"
with "inst.rml"
with "mod.rml"
with "prefix.rml"
with "print.rml"
with "builtin.rml"
with "util.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 **)

relation lookup_type: (Env.Env,Absyn.Path) => (Types.Type, Env.Env) =

	(* Lookup of simple names *)
  rule	Debug.fprint ("lotype","lookup_type(")	&
	Debug.fcall ("lotype",Env.print_env, env) &
	Debug.fprint ("lotype",", ") & 
	Debug.fcall ("lotype",Dump.print_path,path) &
	Debug.fprint ("lottype",")\n") &
	lookup_type_in_env(env,path) => (t,env') &
	Debug.fprint ("lotype", "found type:") &
	Debug.fcall ("lotype",Types.print_type, t) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_)) => (t,env')

  rule	 (* If we didn't find the type, but found a class definition 
	  * that is a function with the same name then we implicitly instantiate that
	  function, and try again. *)
	lookup_class(Cache.CACHE([],[]), env, path, true) 
	  => (_,c as SCode.CLASS(id, _, encflag, SCode.R_FUNCTION,_),env') &
	Inst.implicit_function_instantiation(Cache.CACHE([],[]), env', Mod.NOMOD,
					       Prefix.NOPRE, [], c, [], false) 
	  => (_,env'',_) &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_)) => (t,env3)


  rule	 (* If we didn't find the type, but found a class definition 
	  * that is an external function with the same name then we implicitly 
	  * instantiate that function, and try again. *)
	lookup_class(Cache.CACHE([],[]), env, path, true) 
	  => (_,c as SCode.CLASS(id, _, encflag, SCode.R_EXT_FUNCTION,_),env') &
	Inst.implicit_function_instantiation(Cache.CACHE([],[]), env', Mod.NOMOD,
					       Prefix.NOPRE, [], c, [], false) 
	  => (_,env'',_) &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_)) => (t,env3)

	(* Lookup of qualified name *)
  rule	lookup_class(Cache.CACHE([],[]),env, Absyn.IDENT(pack), true) 
	  => (_,c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr, id) => ci_state &
	(* Instantiate implicit (last argument = true) *)
	Inst.inst_class_in(Cache.CACHE([],[]), env2', Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,_,env'',_,cistate1,_) &
        not ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has to do additional check for encapsulated classes, see rule below *)
	lookup_type_in_class(env'', c, path, true) => (t, env''') 
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack, path)) => (t, env''')


  rule	lookup_class(Cache.CACHE([],[]),env, Absyn.IDENT(pack), true) 
	  => (_,c as SCode.CLASS(id, _, encflag, restr, _), env') &
	Env.open_scope(env', encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(Cache.CACHE([],[]), env2', Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false)
	  => (_,_, env'', _, cistate1, _) &
        ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has NOT to do additional check for encapsulated classes, see rule above *)
	lookup_type_in_class(env'', c, path, false) => (c', env''') 
	--------------------------------------
	lookup_type(env, p as Absyn.QUALIFIED(pack, path)(*, msgflag*)) => (c', env''')

  rule	Absyn.path_string path => s1 & 
	Util.string_append_list(["# Error, type ", s1, " not found.\n"]) => s2 &
	Print.print_buf s2
	---------------------
	lookup_type(_,path) => fail
end

(** relation: lookup_class
 **)

relation lookup_class: (Cache.Cache, Env.Env, Absyn.Path, bool) => (Cache.Cache, SCode.Class, Env.Env) =

(*  rule	(* Try to find the class in the cache *)
	Env.get_env_path(env) => envpath &
	Cache.get_class(cache,envpath,path) => (c,env) 
(*	& Cache.print_cache cache *)
	----------------------------------------
	lookup_class(cache,env,path,_) => (cache,c,env)
*)
  
  rule	Debug.fprint ("lotr","TRIES lookup_class(1)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr","\n") &
        Debug.fcall ("lotr",Env.print_env,env) &
        lookup_class_in_env(env,path,msgflag) => (c, env') &
        Debug.fprint ("lotr","IN lookup_class(1)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	&Print.print_buf "Found class " & Print.print_buf name &
	Print.print_buf "in envpath:" &
	Env.print_env_path env' &
	Print.print_buf "\n:" *)
(*	Env.get_env_path(env') => envpath &
	Cache.add_class(cache,c,env',envpath,path) => cache'*)
	--------------------------------------
	lookup_class(cache, env, path as Absyn.IDENT(name),msgflag) => (cache, c, env')

  rule	Debug.fprint ("lotr","TRIES lookup_class(2)\n") &
        lookup_qualified_imported_class_in_env(cache,env,env,path) 
	  => (cache', c, env') &
        Debug.fprint ("lotr","IN lookup_class(2)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	Env.get_env_path(env') => envpath &
	Cache.add_class(cache',c,env',envpath,path) => cache''*)
	----------------------------------------------------------
	lookup_class(cache, env, path, _) => (cache, c, env')

  rule	Debug.fprint ("lotr","TRIES lookup_class(3)\n") &
        lookup_unqualified_imported_class_in_env(cache, env, env, path) 
	  => (cache', c, env') &
        Debug.fprint ("lotr","IN lookup_class(3)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	Env.get_env_path(env') => envpath &
	Cache.add_class(cache',c,env',envpath,path) => cache''*)
	----------------------------------------------------------
	lookup_class(cache, env, path, _) => (cache, c, env')

  rule	Debug.fprint ("lotr","TRIES lookup_class(4)\n") &
        lookup_class(cache, env,Absyn.IDENT(pack),msgflag) => (cache', c as SCode.CLASS(id,_,encflag,restr,_),env') &
	Env.open_scope(env',encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr,id) => ci_state &
	Inst.inst_class_in(cache', env2',Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (cache'',_,env'',_,cistate1,_) &
        not ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has to do additional check for encapsulated classes, see rule below *)

	lookup_class_in_class(cache'', env'', c, path, true) => (cache''', c', env''') &

	Debug.fprint ("lotr","IN lookup_class(4)\n") &
        Debug.fcall  ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	Env.get_env_path(env''') => envpath &
	Cache.add_class(cache''',c,env''',envpath,p) => cache4*)
	--------------------------------------
	lookup_class(cache,env, p as Absyn.QUALIFIED(pack,path),msgflag) 
	  => (cache, c', env''')

rule	Debug.fprint ("lotr","TRIES lookup_class(5)\n") &
        lookup_class(cache,env,Absyn.IDENT(pack),msgflag) 
	  => (cache', c as SCode.CLASS(id,_,encflag,restr,_),env1) &
	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env3) &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(cache',env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (cache'',_,env4,_,cistate1,_) &
        ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has NOT to do additional check for encapsulated classes, see rule above *)
	lookup_class_in_class(cache'', env4, c, path, false) 
	  => (cache''', c', env5) &

	Debug.fprint ("lotr","IN lookup_class(5)\n") &
        Debug.fcall  ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	Env.get_env_path(env5) => envpath &
	Cache.add_class(cache''',c',env5,envpath,p) => cache4*)
	--------------------------------------
	lookup_class(cache,env, p as Absyn.QUALIFIED(pack,path), msgflag) 
	  => (cache, c', env5)

  rule	Print.print_buf "- lookup_class failed\n" &
	Print.print_buf "  - looked for " & Absyn.path_string path => s & 
 	Print.print_buf s & Print.print_buf "\n"  &
	print "- lookup_class failed looked for " & print s & 
	print "\nenv:" & Print.get_string() => str &
	Print.clear_buf & Env.print_env env & Print.get_string() => envstr &
	Print.clear_buf & Print.print_buf str &
	print envstr 
	--------------
	lookup_class(cache,env,path,true)=> fail 
end

(** relation: lookup_qualified_imported_class_in_env
 ** This relation looks up imported names on the qualified form: import A.B;
**)

relation lookup_qualified_imported_class_in_env:(Cache.Cache, Env.Env, Env.Env,
						 Absyn.Path) 
	  => (Cache.Cache, SCode.Class, Env.Env) =

  rule	lookup_qualified_imported_class_in_frame(cache,items,totenv,name) => (cache',c,env')
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(cache, env as (Env.FRAME(sid,items,_)::fs),totenv,Absyn.IDENT(name)) 
	  => (cache', c, env')

  rule	Debug.fprint("loimp","lookup_qualified_imp_cl_in_env QUAL\n") &
	lookup_qualified_imported_class_in_frame(cache, items, totenv, pack) 
	  => (cache', c as SCode.CLASS(id,_,encflag,restr,_), env') &
	Debug.fprint("loimp","Found package. Instantiating.\n") &  
       	Env.open_scope(env',encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
	Inst.inst_class_in(cache', env3, Mod.NOMOD, Prefix.NOPRE, [], ci_state,
			   c, false, [], true, true) 
	  => (cache'',_,env4,_,_,_) &  
	Debug.fprint("loimp","Instantiated\n") &

	lookup_class_in_class(cache'', env4, c, path, false) 
	  => (cache''', c', env'')
	& Debug.fprint("loimp","Done\n") 
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(cache, env as (Env.FRAME(sid,items,_)::fs),totenv, Absyn.QUALIFIED(pack,path)) 
	  => (cache''', c', env'')

  rule	lookup_qualified_imported_class_in_env(cache, fs, env, id) => (cache', c, env')
	---------------------------------------------
	lookup_qualified_imported_class_in_env(cache, f::fs, env, id) => (cache', c, env')
end

relation lookup_qualified_imported_class_in_frame: (Cache.Cache, (SCode.Ident * Env.Item) list,Env.Env,
    SCode.Ident)
	    => (Cache.Cache, SCode.Class, Env.Env) =

  rule	(* For imported paths A, not possible to assert sub-path package*)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class(cache,[fr],Absyn.IDENT(id),true) => (cache', c, env') 
	------------------------------------------
	lookup_qualified_imported_class_in_frame(cache, (_,Env.IMPORT(Absyn.QUAL_IMPORT(Absyn.IDENT(id))))::fs,env,ident)
	    => (cache', c, env')
	    
  rule	(* For imported path A.B.C, assert A.B is package*)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class(cache,[fr],path,true) => (cache', c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class(cache',[fr],strippath,true) =>  (cache'', c2, _) &
	assert_package(c2) 
	----------------------------------
	lookup_qualified_imported_class_in_frame(cache, (_,Env.IMPORT(Absyn.QUAL_IMPORT(path)))::fs,env,ident)
	    => (cache'', c, env')

  rule	(* If not package, error *)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class(cache,[fr],path,true) => (cache', c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class(cache', [fr], strippath, true) =>  (cache'', c2,_) &
	not assert_package(c2) &
	Print.print_buf "# Error, " & Dump.print_path strippath & Print.print_buf " is not a package\n"  
	----------------------------------
	lookup_qualified_imported_class_in_frame(cache, (_,Env.IMPORT(Absyn.QUAL_IMPORT(path)))::fs,env,ident)
	    => fail

  rule	(* Named imports*)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class(cache, [fr], path, true) => (cache', c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class(cache', [fr], strippath, true) =>  (cache'', c2, _) &
	assert_package(c2) 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(cache, (_,Env.IMPORT(Absyn.NAMED_IMPORT(id,path)))::fs,env,ident)
	    => (cache'', c, env')

  rule	(* Assert package for Named imports *)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class(cache, [fr],path,true) => (cache', c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class(cache', [fr], strippath, true) =>  (cache'', c2, _) &
	not assert_package(c2) &
	Print.print_buf "# Error, " & Dump.print_path strippath & Print.print_buf " is not a package\n"  
	& print "# Error xxx is not a package\n" 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(cache, (_,Env.IMPORT(Absyn.NAMED_IMPORT(id,path)))::fs,env,ident)
	    => fail
	    
  rule	lookup_qualified_imported_class_in_frame(cache, fs, env, ident) 
	  => (cache', c, env')
	-----------------------
	lookup_qualified_imported_class_in_frame(cache, (_,_)::fs,env,ident) 
	  => (cache', c, env')
end

relation lookup_unqualified_imported_class_in_env:(Cache.Cache, Env.Env, 
						   Env.Env, Absyn.Path)
	  => (Cache.Cache, SCode.Class, Env.Env) =

  rule	lookup_unqualified_imported_class_in_frame(cache, items, totenv, name) 
	  => (cache', c, _)
	-----------------------------------------------------------------
	lookup_unqualified_imported_class_in_env(cache, env as (Env.FRAME(sid,items,_)::fs),totenv,Absyn.IDENT(name)) 
	  => (cache', c, env)

  rule	lookup_unqualified_imported_class_in_env(cache, fs, env, id) => (cache', c, _)
	---------------------------------------------
	lookup_unqualified_imported_class_in_env(cache, f::fs,env,id) => (cache', c,f::fs)
end

relation lookup_unqualified_imported_class_in_frame: (Cache.Cache, (SCode.Ident * Env.Item) list,Env.Env,
    SCode.Ident)
	    => (Cache.Cache, SCode.Class, Env.Env) =
	    
  rule	Env.top_frame(env) => fr & 
	lookup_class_in_env([fr],path,true) => (c, env') &
	lookup_class_in_class(cache, env, c, Absyn.IDENT(ident), false) 
	  => (cache', c', env'') &
	not lookup_unqualified_imported_class_in_frame(cache', fs, env, ident) => (_,_,_) 
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame(cache, (_,Env.IMPORT(Absyn.UNQUAL_IMPORT(path)))::fs,env,ident)
	    => (cache', c', env'')

  rule	Env.top_frame(env) => fr & 
	lookup_class_in_env([fr], path, true) => (c, env') &
	lookup_class_in_class(cache, env, c, Absyn.IDENT(ident), false) 
	  => (cache', c', env'') &
	lookup_unqualified_imported_class_in_frame(cache', fs, env, ident) => (_,_,_) &
	Print.print_buf "# Error, class found in several unqualified import statements\n"
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame(cache,(_,Env.IMPORT(Absyn.UNQUAL_IMPORT(path)))::fs,env,ident)
	    => fail

  rule	lookup_unqualified_imported_class_in_frame(cache, fs, env, ident) 
	  => (cache', c, env')
	-----------------------
	lookup_unqualified_imported_class_in_frame(cache, (_,_)::fs, env, ident) 
	  => (cache', c, env')
end

relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	Debug.fprint("lotr","lookup_record_constructor_class(") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr",") called\n") &
	
	lookup_recconst_in_env(env,path) => (c, env') &
	Debug.fprint("lotr", "lookup_class_in_env => ") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr","\n")
	--------------------------------------
	lookup_record_constructor_class(env, path) => (c, env')

end

(** relation: complete_path
 **
 ** This relation takes a type name and an env and looks up the class.
 ** Then it determines the full path for the type, such that it can be looked up
** from any environment.
**)

relation complete_path: (Env.Env, Absyn.Path) => Absyn.Path =

  rule	(* Class found on top level. Nothing to complete. *)
	lookup_class(Cache.CACHE([],[]),env,path,true) => (_,_,Env.FRAME(NONE,_,_)::_)
	----------------------------------------------
	complete_path(env,path) => path

  rule	lookup_class(Cache.CACHE([],[]), env, path, true) 
	  => (_,SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,path) => path' 
(*	& Print.print_buf "completed to " &
	Absyn.path_string path' => s1 & Print.print_buf s1 &
	Print.print_buf " class = " & Print.print_buf id & 
	Print.print_buf "\nenv =" &
	Env.print_env env'  *)
	------------------
	complete_path(env,path as Absyn.IDENT(_)) => path'

  rule	lookup_class(Cache.CACHE([],[]), env, Absyn.IDENT(pack), true) 
	  => (_,_,Env.FRAME(NONE,_,_)::_)
	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path 

  rule	lookup_class(Cache.CACHE([],[]),env,(*Absyn.IDENT(pack)*)path,true) 
	  => (_,SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,Absyn.IDENT(id)) => path' 
	
(*	& Print.print_buf "Qualified completed to " 
	& Absyn.path_string path' => s1 & Print.print_buf s1 &
	Print.print_buf " class = " & Print.print_buf id & 
	Print.print_buf "\n" &
	Print.print_buf "\nenv =" &
	Env.print_env env'  *)

	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path'

  rule	Print.print_buf "-complete_path failed\n env=" &
	Env.print_env env & Print.print_buf "\ntype: " &
	Absyn.path_string path => str & Print.print_buf str &
	Print.print_buf "\n" 
	--------------------
	complete_path(env,path) => fail

end

(* LS: when looking up qualified component reference, lookup_var only
checks variables when looking for the prefix, i.e. for Constants.PI
where Constants is a package and is implicitly instantiated, PI is not
found since Constants is not a variable (it is a type and/or class).

1) One option is to make it a variable and put it in the global frame.
2) Another option is to add a lookup rule that also looks in types.

Now implicitly instantiated packages exists both as a class and as a
type (see implicit_instantiation in inst.rml). Is this correct?

lookup_var is modified to implement 2. Is this correct?

old lookup_var is changed to lookup_var_internal and a new lookup_var
is written, that first tests the old lookup_var, and if not found
looks in the types
 *)

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env, Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

	  (* try the old lookup_var *)
  rule	lookup_var_internal (env,cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr, ty, binding)

	(* then look in classes (implicitly instantiated packages)
	 *)
  rule	lookup_var_in_packages (env, cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr,ty,binding)

  rule	print "- lookup_var failed\n"
	--------------------
	lookup_var(_,_) => fail
end

relation lookup_var_internal : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	Debug.fprint ("lotr", "lookup_var: Looking in frame\n") &
	lookup_var_f(items,ref) => (attr,ty,binding) &
	Debug.fprint ("lotr", "lookup_var: Done frame\n") 
	--------------------------------------------
	lookup_var_internal (Env.FRAME(sid,items,_)::fs,ref) => (attr,ty,binding)

  rule	Debug.fprint ("lotr", "lookup_var: next frame\n") &
	lookup_var_internal (fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var_internal (_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_in_packages
 ** This relation is called when a lookup of a variable with qualified names does 
 ** not have the first element as a component, e.g. A.B.C is looked up where A is not a component.
 ** This implies that A is a class, and this class should be temporary instantiated, and the lookup should ** be performed within that class.
**)

relation lookup_var_in_packages : (Env.Env, Exp.ComponentRef) 
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_class_in_env(env, Absyn.IDENT(id),true) => (c as SCode.CLASS(n,_,encflag,r,_), env2) &
	Debug.fprintl ("lotr", ["lookup_var_in_packages. instantiating class", n, "\n"]) &
	Env.open_scope(env2,encflag) => env3 &
	Env.name_scope (env3,n) => env4 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (Cache.CACHE([],[]), env4,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],
			    true,true) 
	  => (_,_,env5,_,_,types) &
	lookup_var_in_packages(env5,cref) => (attr,ty,bind) &
	Debug.fprint ("lotr", "found var " ) &
	Debug.fcall("lotr", Exp.print_component_ref, cref)  &
	Debug.fprint ("lotr", " = ") &
	Debug.fcall("lotr", Types.print_binding, bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id, [], cref)) => (attr,ty,bind)


  rule	lookup_var_local(env,cr) => (attr,ty,bind)
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => (attr,ty,bind)

  rule	not lookup_var_local(env,cr) => (attr,ty,bind) &
	print "lookup_var_in_packages failed\n" 
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => fail

end


(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **)

relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(sid,items,_)::fs,ref) => (attr,ty,binding)

end

relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool) =

  rule  lookup_var2(items, id) => (fv,c,i)
	----------------------------
	lookup_ident_local(Env.FRAME(sid,items,_)::_, id) => (fv,c,i)

end

(* Same as lookup_ident_local, except check all frames *)
relation lookup_ident : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool) =

	

  rule	lookup_var2(items, id) => (fv,c,i) 
	----------------------------
	lookup_ident(Env.FRAME(sid,items,_)::_, id) => (fv,c,i)

  rule	lookup_ident(rest,id) => (fv,c,i)
	---------------------------------
	lookup_ident(_::rest,id) => (fv,c,i)

  rule	Print.print_buf "# Error lookup_ident: " &
	Print.print_buf id &
	Print.print_buf " failed\n"
	--------------
	lookup_ident(_,id) => fail	
end


(**  Function lookup *)

(* PR. Returns a list of types that the function has. *)
relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) =

        (* PR. Do nothing, could have used a axiom. But this led to an
	 bug unexpected error before. I do not take my chances at the moment.
	 *)
  rule  Debug.fprint ("li", "\n lookup_functions_in_env terminated." )
	---------------------
	lookup_functions_in_env([],id) => []


  rule	Debug.fprint ("lotr", "lookup_functions_in_env") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, items) &
	lookup_functions_in_frame(items,env,id) => c1 &
(*	Print.print_buf "\n Found type." & *)
	lookup_functions_in_env(fs,iid) => c2 &
	list_append (c1,c2) => reslist
	---------------------
	lookup_functions_in_env(env as (Env.FRAME(sid,items,_)::fs), iid as Absyn.IDENT(id)) => reslist

	(* Did not match. Continue*)
  rule	lookup_functions_in_env(fs,id) => c
	---------------------
	lookup_functions_in_env(f::fs,id) => c

end


(** - Internal relations *)


(**  Type lookup *)

relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type,Env.Env) =

  rule	lookup_type_in_frame(items,env,id) => (c,env')
	---------------------
	lookup_type_in_env(env as (Env.FRAME(sid,items,_)::fs),Absyn.IDENT(id)) => (c,env')

  rule	lookup_type_in_env(fs,id) => (c,env')
	-------------------------------------
	lookup_type_in_env(f::fs,id) => (c,f::env')

end
(**)

relation lookup_type_in_frame: ((SCode.Ident * Env.Item) list,
				 Env.Env,
				 SCode.Ident)
	  => (Types.Type, Env.Env) =

  rule	(* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_type_in_frame((n,Env.TYPE(t))::_,env, id) => (t,env)

  rule	id = n & Print.print_buf "# Error while looking up type " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_type_in_frame((n,Env.VAR(_,_,_))::_,env,id) => fail

  rule	(* Each time a record constructor function is looked up, this rule will create the function.*)
	(* An improvement (perhaps needing lot of code) is to add the function to the environment, which is *)
	(* returned from this relation.*)
	id = n & 
	build_record_constructor_varlst (cdef,env) => varlst &
	Types.make_function_type(varlst) => ftype 
	----------------------------------------
	lookup_type_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_RECORD,_),_))::rest,env,id) 
	    => (ftype,env)

  rule	id = n & 
	not lookup_type_in_frame(rest,env,id) => (_,_) &
	Inst.inst_class(Cache.CACHE([],[]),env,Mod.NOMOD,Prefix.NOPRE,[],cdef,[],true) =>(_,_,_,ty,_)  &
	(* This rule is applied when a class definition, "below" in the code is a function and its type is 
	   requested. We should really add the type `ty' to the environment in the future, but that means 
	   a lot of changes......*)
	Env.extend_frame_t(env,id,ty) => (env')
	----------------------------------------
	lookup_type_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),_))::rest,env,id) => (ty,env')

  rule	(* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): not " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	lookup_type_in_frame(fs,env,id) => (t,env')
	------------------------------
	lookup_type_in_frame((n,_)::fs,env,id) => (t,env')
end
(**)

(*PR. This actually only looks up the function name and find all
 corresponding types that have this function name.  *)
relation lookup_functions_in_frame: ((SCode.Ident * Env.Item) list,
				 Env.Env,
				 SCode.Ident)
	  => Types.Type list =

(*
  rule  Print.print_buf "\n FRAME IS FINSHED"
	------------------------------------
	lookup_functions_in_frame([],id) => []
*)
  axiom	lookup_functions_in_frame([],env,id) => []

  rule	(* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): " &
	   Print.print_buf n & Print.print_buf "\n" & *)
(*	Print.print_buf ("\n found id in frame.") & *)
	id = n &
	lookup_functions_in_frame(rest, env, id) => t2
	---------------------------------------------------------
	lookup_functions_in_frame((n,Env.TYPE(t))::rest, env, id) => t::t2

  rule	id = n & Print.print_buf "# Error while looking up type " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_functions_in_frame((n,Env.VAR(_,_,_))::_,env,id) => fail

  rule	id = n & Print.print_buf "Found record when looking for function. Assuming implicit record constructor\n" &
	build_record_constructor_varlst (cdef,env) => varlst &
	lookup_functions_in_frame(rest,env,id) => t2 &
	Types.make_function_type(varlst) => ftype
	----------------------------------------
	lookup_functions_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_RECORD,_),_))::rest,env,id) => ftype::t2

  rule	 (* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): not " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	lookup_functions_in_frame(fs,env,id) => t
	------------------------------
	lookup_functions_in_frame((n,_)::fs,env,id) => t

end

relation lookup_recconst_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_frame(items,env,id) => (c, _) 
	---------------------
	lookup_recconst_in_env(env as (Env.FRAME(sid,items,_)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_recconst_in_env(fs,id) => (c, _)
	---------------------
	lookup_recconst_in_env(f::fs,id) => (c, f::fs)

end

(** relation: lookup_recconst_in_frame
 **This relation lookups the implicit record constructor class (function) of a record in a frame
**)
relation lookup_recconst_in_frame: ((SCode.Ident * Env.Item) list,
				 Env.Env,
				 SCode.Ident)
	  => (SCode.Class, Env.Env) =



  rule	id = n &
	lookup_recconst_in_frame(rest, env, id) => (c2,env')
	---------------------------------------------------------
	lookup_recconst_in_frame((n,Env.TYPE(t))::rest, env, id) => (c2,env')

  rule	id = n & Print.print_buf "# Error while looking up record constructor class " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_recconst_in_frame((n,Env.VAR(_,_,_))::_,env,id) => fail

  rule	id = n & Print.print_buf "Found record when looking for function. Assuming implicit record constructor\n" &
	build_record_constructor_class (cdef,env) => cdef 
	----------------------------------------
	lookup_recconst_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_RECORD,_),_))::rest,env,id) => (cdef,env)

  rule	 (* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): not " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	lookup_recconst_in_frame(fs,env,id) => (c,env)
	------------------------------
	lookup_recconst_in_frame((n,_)::fs,env,id) => (c,env)

end

(**)

relation build_record_constructor_class :(SCode.Class, Env.Env) => SCode.Class =

  rule	build_record_constructor_elts(elts,env) => funcelts &
	build_record_constructor_result_elt(elts,id,env) => reselt
	---------------------------------------------------
	build_record_constructor_class (cl as SCode.CLASS(id,_,_,restr,SCode.PARTS(elts,_,_,_,_,_)),env) 
	    => SCode.CLASS(id,false,false,SCode.R_FUNCTION,SCode.PARTS(reselt::funcelts,[],[],[],[],NONE))
end
	
relation build_record_constructor_elts: (SCode.Element list, Env.Env) => SCode.Element list =
  rule	build_record_constructor_elts (rest,env) => res
	-------------------------------------------
	build_record_constructor_elts((comp as SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,dir),tp,mod))::rest,env)
	    => SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,Absyn.INPUT),tp,mod)::res
  axiom	build_record_constructor_elts([],_) => []
end
	
(** This relation builds the result element of a record constructor function, i.e. the returned variable *)
relation build_record_constructor_result_elt: (SCode.Element list, SCode.Ident, Env.Env) => SCode.Element =
	
  rule	build_record_constructor_result_mod(elts) => submodlst
	-------------------------------------------------
	build_record_constructor_result_elt (elts,id,env) 
	    => SCode.COMPONENT("result",false,false,false,SCode.ATTR([],false,SCode.RW,SCode.VAR,Absyn.OUTPUT),Absyn.IDENT(id),SCode.MOD(false,submodlst,NONE))
end
	
(* This relation builds up the modification list for the output element of a record constructor.
 ** Example: 
 **   record foo
 **      Real x;
 **      String y;
 **      end foo;
 **  => modifier list become 'result.x=x, result.y=y'
 *)
relation build_record_constructor_result_mod: (SCode.Element list) => SCode.SubMod list =
	
  rule	build_record_constructor_result_mod(rest) => restmod
	---------------------------------------------------
	build_record_constructor_result_mod (SCode.COMPONENT(id,_,_,_,_,_,_)::rest) 
	    => SCode.NAMEMOD("result",SCode.MOD(false,[SCode.NAMEMOD(id,SCode.MOD(false,[],SOME(Absyn.CREF(Absyn.CREF_IDENT(id,[])))))],NONE))::restmod

  axiom	build_record_constructor_result_mod([]) => []
end
(** 
 ** This relation takes a class  (`SCode.Class') which holds a definition of a record
   ** and builds a list of variables of the record used for constructing a record constructor function.
*)
relation build_record_constructor_varlst : (SCode.Class,Env.Env) => Types.Var list =

  rule	build_varlst_from_elts(elts,env) => inputvarlst &
	Inst.inst_class(Cache.CACHE([],[]), env, Mod.NOMOD, Prefix.NOPRE, [], cl, [], true) 
	  => (_,_,_,ty,_) 
	--------------------------------------
	build_record_constructor_varlst (cl as SCode.CLASS(_,_,_,_,SCode.PARTS(elts,_,_,_,_,_)),env) 
	(* Add the return type of the record constructor *)
	    => Types.VAR("result",Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.OUTPUT),false,ty,Types.UNBOUND)::inputvarlst
end

relation build_varlst_from_elts: (SCode.Element list,Env.Env ) => Types.Var list =

  rule	build_varlst_from_elts(rest,env) => vars &
  (*P.A Here we need to do a lookup of the type. Therefore we need the env passed along from lookup_xxxx function. *)
	Inst.inst_record_constructor_elt(env,comp) => var
	-------------------------------------
	build_varlst_from_elts ((comp as SCode.COMPONENT(_,_,_,_ ,_,_,_))::rest,env) 
	    => var::vars

  axiom	build_varlst_from_elts ([],_) => []

  rule	Print.print_buf "ERROR build_varlst_from_elts failed!\n"
	----------------------------------------------
	build_varlst_from_elts(_,_) => fail
end

(**  Class lookup *)

relation lookup_class_in_env: (Env.Env,Absyn.Path,bool) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_frame(items,id,msg) => (c,_)  
	---------------------
	lookup_class_in_env(env as (Env.FRAME(sid,items,_)::fs),Absyn.IDENT(id),msg)
	    => (c,env)

(*  rule	lookup_class_in_frame(items, id, msg) => (c, _) &
	lookup_class_in_class(env, c, path,false) => (c2, env')
	-------------------------------------------	
	lookup_class_in_env(env as (Env.FRAME(sid,items,_)::fs), Absyn.QUALIFIED(id,path),msg) 
	    => (c2,env')*)
(*
  NOW THIS RULES IS SEPARATED INTO TWO CASES

  rule	lookup_class_in_env(fs,id,msgflag) => (c, _)
	---------------------
	lookup_class_in_env(f::fs,id,msgflag) => (c, f::fs)
*)

(*  rule	lookup_class_in_env(fs,id,msgflag) => (c, env')
	---------------------
	lookup_class_in_env(f::fs,id as Absyn.QUALIFIED(_,_),msgflag) => (c, env')*)
	

  rule	Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_) &
        Print.print_buf "Class " &
        Print.print_buf id       &
        Print.print_buf " not found and the lookup reached an encapsulated class\n"
	---------------------
	lookup_class_in_env(Env.FRAME(sid,items,true)::fs, aid as Absyn.IDENT(id),true) => fail

  rule	Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_) &
        Print.print_buf "No message in this case.\n" 
	---------------------
	lookup_class_in_env(Env.FRAME(sid,items,true)::fs, 
			    aid as Absyn.IDENT(id),false) => fail

 rule	Builtin.initial_env() => i_env & 
        lookup_class_in_env(  i_env, aid,msgflag)=> (c,env')
       	---------------------
	lookup_class_in_env(Env.FRAME(sid,items,true)::fs, 
			    aid as Absyn.IDENT(id),msgflag ) => (c,env')

  rule  lookup_class_in_env(fs,id,msgflag) => (c, env')
	---------------------
	lookup_class_in_env(  (f as Env.FRAME(sid,items,false)) ::fs,
			    id as Absyn.IDENT(_),msgflag ) 
	  => (c, env')
end

(** relation: lookup_class_in_class
 ** This relation looks up an inner class of a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 ** bool determines whether we restrict lookup for encapsulated class (true).
 **  
 **)
relation lookup_class_in_class: (Cache.Cache, Env.Env, SCode.Class, Absyn.Path, bool) 
	  => (Cache.Cache, SCode.Class, Env.Env) =

  rule	lookup_class_in_env(env,classname,true) => (c as SCode.CLASS(_,_,true,_,_) ,env') 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_class_in_class (cache, env, cdef,classname as Absyn.IDENT(_),true) 
	  => (cache, c, env')

  rule	lookup_class_in_env(env,classname,true) => (c as SCode.CLASS(_,_,false,_,_) ,env') &
        (* false means here non-encapsulated *)
        Print.print_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is already a simple name)\n")
      	----------------------------------------------------
	lookup_class_in_class (cache, env, cdef, classname as Absyn.IDENT(_),true) => fail
	
  rule	lookup_class_in_env(env,classname,true) => (c ,env') 
        (* false means that we do not restrict lookup to encapsulated classes *)
(*	&Print.print_buf " (class in class) Found class " & Print.print_buf name &
	Print.print_buf "in envh:" &
	Env.print_env env' &
	Print.print_buf "\n:" *)

      	----------------------------------------------------
	lookup_class_in_class (cache, env, cdef, classname as Absyn.IDENT(name) ,false) 
	  => (cache, c, env')

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),true) => (c as SCode.CLASS(id,_,encflag as true,restr,_) ,env1) &
       	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env3) &
	Print.print_buf "\n" &*)
	Inst.inst_class_in(cache, env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (cache',_,env4,_,_,_) &
  	lookup_class_in_class (cache', env4, c, p1, false) => (cache'', c', env5)
	-------------------------------------------
	lookup_class_in_class (cache, env, cdef, Absyn.QUALIFIED(c1,p1),true) 
	  => (cache'', c',env5)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),true) => (c as SCode.CLASS(id,_,encflag as false,restr,_) ,env) &
        Print.print_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is still qualified)\n")
	-------------------------------------------
	lookup_class_in_class (cache, env, cdef, Absyn.QUALIFIED(c1,p1),true) => fail

  rule	(* Lookup not restricted to encapsulated elts. only *)
	lookup_class_in_env (env, Absyn.IDENT(c1), true) => (c as SCode.CLASS(id,_,encflag,restr,_) ,env1) &
       	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env3) &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(cache, env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (cache',_,env4,_,_,_) &
  	lookup_class_in_class (cache', env4, c, p1, false) => (cache'', c', env5)
	-------------------------------------------
	lookup_class_in_class (cache, env, cdef, Absyn.QUALIFIED(c1,p1),false) 
	  => (cache'', c', env5)

  rule	lookup_qualified_imported_class_in_env(cache,env,env,path) 
	  => (cache', c, env') 
	-------------------------
	lookup_class_in_class (cache, env, cdef, path,_) 
	  => (cache', c, env')

  rule	lookup_unqualified_imported_class_in_env(cache, env, env, path) 
	  => (cache', c, env') 
	-------------------------
	lookup_class_in_class (cache, env, cdef, path ,_) 
	  => (cache', c, env')

  rule	Print.print_buf "- lookup_class_in_class failed\n" &
	Print.print_buf "  - class = " & Print.print_buf cname &
	Print.print_buf "\n  - looked for: " & Absyn.path_string path => s & 
	Print.print_buf s & Print.print_buf "\n env:"  &
	Env.print_env env & Print.print_buf "\n" 
	-----------------
	lookup_class_in_class(cache, env, SCode.CLASS(cname,_,_,_,_), path, _) => fail
end

(** relation: lookup_type_in_class
 ** This relation looks up an type inside a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 ** bool determines whether we restrict lookup for encapsulated class (true).
 **  
 **)
relation lookup_type_in_class: (Env.Env, SCode.Class, Absyn.Path, bool) => (Types.Type, Env.Env) =

  rule	lookup_type_in_env(env, classname(*, true*)) => (tp, env')
        (* encapsulated does not matter, _ *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (tp, env')

  rule	(* If not found, look for classdef that is function and instantiate. *)
	lookup_class_in_env(env, classname, true) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_FUNCTION, _), env') &
	Inst.implicit_function_instantiation(Cache.CACHE([],[]), env', Mod.NOMOD,
					     Prefix.NOPRE, [], c, [], false) 
	  => (_,env'',_) &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* If not found, look for classdef that is external function and instantiate. *)
	lookup_class_in_env(env, classname, true) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_EXT_FUNCTION, _), env') &
	Inst.implicit_function_instantiation(Cache.CACHE([],[]), env', Mod.NOMOD,
					     Prefix.NOPRE, [], c, [], false) 
	  => (_,env'',_) &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),true) => (c as SCode.CLASS(id,_,encflag as true,restr,_) ,env) &
       	Env.open_scope(env, encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(Cache.CACHE([],[]), env3, Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,_,env4,_,_,_) &
  	lookup_type_in_class (env4, c, p1, false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => (t, env5)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),true) => (c as SCode.CLASS(id,_,encflag as false,restr,_) ,env) &
        Print.print_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is still qualified)\n")
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => fail

  rule	(* Lookup not restricted to encapsulated elts. only *)
	lookup_class_in_env (env, Absyn.IDENT(c1), true) => (c as SCode.CLASS(id,_,encflag,restr,_) ,env1) &
       	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env2') &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(Cache.CACHE([],[]), env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,false) 
	  => (_,_,env4,_,_,_) &
  	lookup_type_in_class (env4,c,p1,false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),false) => (t, env5)

  rule	Print.print_buf "- lookup_type_in_class failed\n" &
	Print.print_buf "  - class = " & Print.print_buf cname &
	Print.print_buf "\n  - looked for: " & Absyn.path_string path => s & 
	Print.print_buf s & Print.print_buf "\n" 
	-----------------
	lookup_type_in_class(_, SCode.CLASS(cname,_,_,_,_), path, _) => fail
end
	
(** relation: lookup_class_in_parts
 ** This relation takes an `Env' and an `Ident' and an `Element' list, and returns the `Class' 
 ** having the name specified by the `Ident'. If not found, the relation fails.
 **)
relation lookup_class_in_parts: (Env.Env, SCode.Ident, SCode.Element list) => (SCode.Class, Env.Env) =
	
  rule	name = name2
	------------
	lookup_class_in_parts(env, name,  SCode.CLASSDEF(name2,_,_,c)::xs) => (c, env)


  rule	lookup_class_in_parts(env, name, xs) => (c,env)
	-----------------------------------------------
	lookup_class_in_parts(env, name, _::xs) => (c,env)

  axiom	lookup_class_in_parts(env, name, []) => fail
end

(**)
relation lookup_class_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident,bool)
	  => (SCode.Class, Env.Env) =

  rule	(*Debug.fprint("lotr", "  lookup_class_in_frame(") & 
	Debug.fprint("lotr", id) & Debug.fprint ("lotr", "): ") &
	Debug.fprint("lotr", n) & Debug.fprint("lotr", "\n") &*)
	id = n
	---------------------------------------------------------
	lookup_class_in_frame((n,Env.CLASS(c, env))::_, id,_) => (c, env)


  rule	id = n & Print.print_buf "# Error while looking up class " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_class_in_frame((n,Env.VAR(_,_,_))::_,id,true) => fail


  rule	lookup_class_in_frame(fs,id,msg) => (c, env)
	------------------------------
	lookup_class_in_frame(_::fs,id,msg) => (c, env)
end

(**)
relation lookup_var2 : ((SCode.Ident * Env.Item) list,SCode.Ident)
	  => (Types.Var,SCode.Element option, bool) =

  rule	Debug.fprintl ("locom", ["Comparing: ", n, " <=> ", id, "\n"]) &
	id = n
	--------------------------------------------
	lookup_var2((n,Env.VAR(fv,c,i))::_,id) => (fv,c,i)

  rule	lookup_var2(fs,id) => (fv,c,i)
	------------------------
	lookup_var2(_::fs,id) => (fv,c,i)
end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)

relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(dim,t),
			 Exp.WHOLEDIM::ys)
	  => Types.T_ARRAY(dim,t')

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.SLICE(Exp.ARRAY(_,_,se))::ys)
	  => Types.T_ARRAY(Types.DIM(SOME(dim)),t')

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

	(* HJ: Subscrits needn't be constant. No range-checking can
	       be done *)

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(NONE),t),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(NONE),t),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.SLICE(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(NONE),t),
			 Exp.SLICE(_)::ys) => t'

  rule	Print.print_buf "- check_subscripts failed (" &
	Types.print_type t & Print.print_buf ", [" &
 	Exp.print_list(s,Exp.print_subscript,",") & Print.print_buf "])\n"
	& print "- check_subscripts failed\n"
	-----------------------------------
	check_subscripts(t,s) => fail

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_)) &
	Print.print_buf "- lookup of protected element not allowed\n" 
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	Print.print_buf "- lookup_in_var failed\n"
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)

relation lookup_var_f : ((SCode.Ident * Env.Item) list,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule  Debug.fprint ("lotr", "lookup_var_f IDENT:") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, f) &
	lookup_var2(f, id)
	  => (Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind),_,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(f,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

  rule	Debug.fprint ("lotr", "lookup_var_f QUAL:") &
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, f) &
	lookup_var2(f, id) => (Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_),_,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(f,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)


  rule	Debug.fprintln ("lotr", "lookup_var_f failed")
	--------------------------------
	lookup_var_f(_,_) => fail

end


relation print_frame : ((SCode.Ident * Env.Item) list) => () =

  rule	Print.print_buf "FRAME: " &
	print_frame_contents cont &
	Print.print_buf "\n"
	--------------------------------------------
	print_frame cont

end


relation print_frame_contents: ((SCode.Ident * Env.Item) list) => () =

  axiom	print_frame_contents [] 

  rule	print_frame_element e
	-------------------------
	print_frame_contents [e as (n,i)]

  rule	print_frame_element e & Print.print_buf "," & print_frame_contents rst
	------------------------------------------------
	print_frame_contents ((e as (n,i))::rst)
end


relation print_frame_element: (SCode.Ident * Env.Item) => () =

  rule	Print.print_buf "v:" & Print.print_buf n
	-------
	print_frame_element ((n,Env.VAR(_,_,_)))

  rule	Print.print_buf "c:" & Print.print_buf n
	-------
	print_frame_element ((n,Env.CLASS(_,_)))

  rule	Print.print_buf "t:" & Print.print_buf n
	-------
	print_frame_element ((n,Env.TYPE(_)))

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,_,SCode.R_PACKAGE,_)

end

(** relation: lookup_class_in_package
 ** 
 ** This relation searches a class definition for a named class
 ** definition.
 **
 ** The class is returned together with an empty environment, which
 ** might cause problems.  This should be solved using implicit
 ** instantiation, but that is future work.
 **)
 
relation lookup_class_in_package : (SCode.Class, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,_,
					       SCode.PARTS(els,_,_,_,_,_)),
				 path) => (c, Env.empty_env)

end
(** relation: lookup_class_in_elements
 ** 
 ** This relation helps `lookup_class_in_package' to do its thing.
 **)

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => (c', env)
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	