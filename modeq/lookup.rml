(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "explode.rml"

  relation lookup_type       : (Env.Env, Absyn.Path) => (Types.Type)
  relation lookup_class      : (Env.Env, Absyn.Path) => (SCode.Class, Env.Env)
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) => Types.Var
  relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) 
end

with "parse.rml"
with "debug.rml"
with "dump.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 **)

relation lookup_type: (Env.Env,Absyn.Path) => Types.Type =

  rule	lookup_type_in_env(env,path) => t
	--------------------------------------
	lookup_type(env, path) => t

  rule	lookup_package_type (env,pack,path) => t
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack,path)) => t

end

(** relation: lookup_class
 **)

relation lookup_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	Debug.fprint("lotr","lookup_class(") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr",") called\n") &
	
	lookup_class_in_env(env,path) => (c, env') &
	Debug.fprint("lotr", "lookup_class_in_env => ") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr","\n")
	--------------------------------------
	lookup_class(env, path) => (c, env')

  rule	lookup_package_class (env,pack,path) => (c, env')&
	Debug.fprint("lotr", "lookup_package_class => ") &
	Debug.fcall("lotr",Dump.print_path,path)
	--------------------------------------
	lookup_class(env, Absyn.QUALIFIED(pack,path)) => (c, env')

end

(* LS: when looking up qualified component reference, lookup_var only
checks variables when looking for the prefix, i.e. for Constants.PI
where Constants is a package and is implicitly instantiated, PI is not
found since Constants is not a variable (it is a type and/or class).

1) One option is to make it a variable and put it in the global frame.
2) Another option is to add a lookup rule that also looks in types.

Now implicitly instantiated packages exists both as a class and as a
type (see implicit_instantiation in inst.rml). Is this correct?

lookup_var is modified to implement 2. Is this correct?

old lookup_var is changed to lookup_var_internal and a new lookup_var
is written, that first tests the old lookup_var, and if not found
looks in the types
 *)

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env, Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

	  (* try the old lookup_var *)
  rule	lookup_var_internal (env,cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr, ty, binding)

	(* then look in classes (implicitly instantiated packages)
	 *)
  rule	lookup_var_in_packages (env, cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr,ty,binding)

end

relation lookup_var_internal : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	Debug.fprint ("lotr", "lookup_var: Looking in frame\n") &
	lookup_var_f(items,ref) => (attr,ty,binding) &
	Debug.fprint ("lotr", "lookup_var: Done frame\n") 
	--------------------------------------------
	lookup_var_internal (Env.FRAME(items)::fs,ref) => (attr,ty,binding)

  rule	Debug.fprint ("lotr", "lookup_var: next frame\n") &
	lookup_var_internal (fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var_internal (_::fs,ref) => (attr,ty,binding)

end

relation lookup_var_in_packages : (Env.Env, Exp.ComponentRef) 
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_class_in_env(env, Absyn.IDENT(id)) => (c, env) &
	lookup_var_in_class(env, c, cref) => (attr,ty,bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id, [], cref)) => (attr,ty,bind)
end

relation lookup_var_in_class: (Env.Env, SCode.Class, Exp.ComponentRef)
	    => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_in_parts(id,parts) => (attr,ty,bind)
	-----------------------------------------------
	lookup_var_in_class(env, SCode.CLASS(_,_,_,SCode.PARTS(parts,_,_)), Exp.CREF_IDENT(id,_))
	    => (attr, ty, bind)

  rule	lookup_class_in_class(env,c,Absyn.IDENT(id)) => (c2,env) &
	lookup_var_in_class(env,c2,cref) => (attr, ty, bind) 
	--------------
	lookup_var_in_class(env, c as SCode.CLASS(_,_,_,SCode.PARTS(parts,_,_)), Exp.CREF_QUAL(id,_,cref))
	    => (attr, ty, bind)
end

relation lookup_var_in_parts: (Absyn.Ident, SCode.Element list) 
	    => (Types.Attributes, Types.Type, Types.Binding) =

(* Fortsätt här...*)

end

(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **)

relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(items)::fs,ref) => (attr,ty,binding)

end

relation lookup_ident_local : (Env.Env, SCode.Ident) => Types.Var =

  rule  lookup_var2(items, id) => fv
	----------------------------
	lookup_ident_local(Env.FRAME(items)::_, id) => fv

end


(**  Function lookup *)

(* PR. Returns a list of types that the function has. *)
relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) =

        (* PR. Do nothing, could have used a axiom. But this led to an
	 bug unexpected error before. I do not take my chances at the moment.
	 *)
  rule  Debug.fprint ("li", "\n lookup_functions_in_env terminated." )
	---------------------
	lookup_functions_in_env([],id) => []


  rule	Debug.fprint ("lotr", "lookup_functions_in_env") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, items) &
	lookup_functions_in_frame(items,id) => c1 &
(*	print "\n Found type." & *)
	lookup_functions_in_env(fs,iid) => c2 &
	list_append (c1,c2) => reslist
	---------------------
	lookup_functions_in_env(Env.FRAME(items)::fs, iid as Absyn.IDENT(id)) => reslist

	(* Did not match. Continue*)
  rule	lookup_functions_in_env(fs,id) => c
	---------------------
	lookup_functions_in_env(f::fs,id) => c

end


(** - Internal relations *)


(**  Type lookup *)

relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type) =

  rule	lookup_type_in_frame(items,id) => c
	---------------------
	lookup_type_in_env(Env.FRAME(items)::fs,Absyn.IDENT(id)) => c

  rule	lookup_type_in_env(fs,id) => c
	---------------------
	lookup_type_in_env(f::fs,id) => c

end
(**)

relation lookup_type_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => Types.Type =

  rule	(* print "  lookup_type_in_frame(" & print id & print "): " &
	   print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_type_in_frame((n,Env.TYPE(t))::_, id) => t

  rule	id = n & print "# Error while looking up type " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_type_in_frame((n,Env.VAR(_))::_,id) => fail

  rule	(* print "  lookup_type_in_frame(" & print id & print "): not " &
	   print n & print "\n" & *)
	lookup_type_in_frame(fs,id) => t
	------------------------------
	lookup_type_in_frame((n,_)::fs,id) => t
end
(**)

(*PR. This actually only looks up the function name and find all
 corresponding types that have this function name.  *)
relation lookup_functions_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => Types.Type list =

(*
  rule  print "\n FRAME IS FINSHED"
	------------------------------------
	lookup_functions_in_frame([],id) => []
*)
  axiom	lookup_functions_in_frame([],id) => []

  rule	(* print "  lookup_type_in_frame(" & print id & print "): " &
	   print n & print "\n" & *)
(*	print ("\n found id in frame.") & *)
	id = n &
	lookup_functions_in_frame(rest, id) => t2
	---------------------------------------------------------
	lookup_functions_in_frame((n,Env.TYPE(t))::rest, id) => t::t2

  rule	id = n & print "# Error while looking up type " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_functions_in_frame((n,Env.VAR(_))::_,id) => fail

  rule	 (* print "  lookup_type_in_frame(" & print id & print "): not " &
	   print n & print "\n" & *)
	lookup_functions_in_frame(fs,id) => t
	------------------------------
	lookup_functions_in_frame((n,_)::fs,id) => t

end
(**)
relation lookup_package_type : (Env.Env, string, Absyn.Path) => Types.Type =
	
  rule	locate_package (env,packname) => pack &
 	print "- package lookup of types not implemented\n"
	(* lookup_type_in_package (pack, path) => t *)
	-------------------------------------
	lookup_package_type (env, packname, path) => (* t *) fail

end

(**  Class lookup *)

relation lookup_class_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_frame(items,id) => (c, _) 
	---------------------
	lookup_class_in_env(env as (Env.FRAME(items)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_class_in_frame(items, id) => (c,  _) &
	lookup_class_in_class(env, c, path) => (c2, _)
	-------------------------------------------	
	lookup_class_in_env(env as (Env.FRAME(items)::fs), Absyn.QUALIFIED(id,path)) 
	    => (c2,env)

  rule	lookup_class_in_env(fs,id) => (c, _)
	---------------------
	lookup_class_in_env(f::fs,id) => (c, f::fs)

end

(** relation: lookup_class_in_class
 ** This relation looks up an inner class of a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 **)
relation lookup_class_in_class: (Env.Env, SCode.Class, Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_parts(env,classname,parts) => (c,env)
	----------------------------------------------------
	lookup_class_in_class (env, SCode.CLASS(_,_,_,SCode.PARTS(parts,_,_)),Absyn.IDENT(classname)) => (c,env)
	    
  rule	lookup_class_in_parts (env, c1, parts) => (c,env) &
	lookup_class_in_class (env,c,p1) => (c',env)
	-------------------------------------------
	lookup_class_in_class (env, SCode.CLASS(_,_,_,SCode.PARTS(parts,_,_)), Absyn.QUALIFIED(c1,p1)) => (c',env)
	
end
	
(** relation: lookup_class_in_parts
 ** This relation takes an `Env' and an `Ident' and an `Element' list, and returns the `Class' 
 ** having the name specified by the `Ident'. If not found, the relation fails.
 **)
relation lookup_class_in_parts: (Env.Env, SCode.Ident, SCode.Element list) => (SCode.Class, Env.Env) =
	
  rule	name = name2
	------------
	lookup_class_in_parts(env, name,  SCode.CLASSDEF(name2,_,_,c)::xs) => (c, env)


  rule	lookup_class_in_parts(env, name, xs) => (c,env)
	-----------------------------------------------
	lookup_class_in_parts(env, name, _::xs) => (c,env)

  axiom	lookup_class_in_parts(env, name, []) => fail
end

(**)
relation lookup_class_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => (SCode.Class, Env.Env) =

  rule	(*Debug.fprint("lotr", "  lookup_class_in_frame(") & 
	Debug.fprint("lotr", id) & Debug.fprint ("lotr", "): ") &
	Debug.fprint("lotr", n) & Debug.fprint("lotr", "\n") &*)
	id = n
	---------------------------------------------------------
	lookup_class_in_frame((n,Env.CLASS(c, env))::_, id) => (c, env)

(*
  rule	id = n & print "# Error while looking up class " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_class_in_frame((n,Env.VAR(_))::_,id) => fail
*)

  rule	lookup_class_in_frame(fs,id) => (c, env)
	------------------------------
	lookup_class_in_frame(_::fs,id) => (c, env)

end
(**)
relation lookup_package_class : (Env.Env, string, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	locate_package (env,packname) => pack &
	lookup_class_in_package (pack, path) => (c, _)
	-------------------------------------
	lookup_package_class (env, packname, path) => (c, env)

end
(**)
relation lookup_var2 : ((SCode.Ident * Env.Item) list,SCode.Ident)
	  => Types.Var =

  rule	Debug.fprintl ("locom", ["Comparing: ", n, " <=> ", id, "\n"]) &
	id = n
	--------------------------------------------
	lookup_var2((n,Env.VAR(fv))::_,id) => fv

  rule	lookup_var2(fs,id) => fv
	------------------------
	lookup_var2(_::fs,id) => fv

end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)

relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(dim,t),
			 Exp.WHOLEDIM::ys)
	  => Types.T_ARRAY(dim,t')

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.SLICE(Exp.ARRAY(_,_,se))::ys)
	  => Types.T_ARRAY(Types.DIM(SOME(dim)),t')

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

	(* HJ: Subscrits needn't be constant. No range-checking can
	       be done *)

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(NONE),t),
			 Exp.INDEX(_)::ys) => t'

  rule	print "- check_subscripts failed (" &
	Types.print_type t & print ", [" &
 	Exp.print_list(s,Exp.print_subscript,",") & print "])\n"
	-----------------------------------
	check_subscripts(t,s) => fail

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_))
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	print "- lookup_in_var failed\n"
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)

relation lookup_var_f : ((SCode.Ident * Env.Item) list,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule  Debug.fprint ("lotr", "lookup_var_f IDENT:") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, f) &
	lookup_var2(f, id)
	  => Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(f,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

  rule	Debug.fprint ("lotr", "lookup_var_f QUAL:") &
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, f) &
	lookup_var2(f, id) => Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(f,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)


  rule	Debug.fprintln ("lotr", "lookup_var_f failed")
	--------------------------------
	lookup_var_f(_,_) => fail

end


relation print_frame : ((SCode.Ident * Env.Item) list) => () =

  rule	print "FRAME: " &
	print_frame_contents cont &
	print "\n"
	--------------------------------------------
	print_frame cont

end


relation print_frame_contents: ((SCode.Ident * Env.Item) list) => () =

  axiom	print_frame_contents [] 

  rule	print_frame_element e
	-------------------------
	print_frame_contents [e as (n,i)]

  rule	print_frame_element e & print "," & print_frame_contents rst
	------------------------------------------------
	print_frame_contents ((e as (n,i))::rst)
end


relation print_frame_element: (SCode.Ident * Env.Item) => () =

  rule	print "v:" & print n
	-------
	print_frame_element ((n,Env.VAR(_)))

  rule	print "c:" & print n
	-------
	print_frame_element ((n,Env.CLASS(_,_)))

  rule	print "t:" & print n
	-------
	print_frame_element ((n,Env.TYPE(_)))

end




(**
 **  Package handling
 **)

(** relation: locate_package
 **
 ** This relation finds a package in a file and loads it.
 **
 ** It appends `.mo' to the name of the package and tries to load a
 ** file of that name.  This relation should be memoized, as it
 ** currently reloads the package each time it is used.
 **)

relation locate_package : (Env.Env, string) => SCode.Class =

  rule	lookup_class(env, Absyn.IDENT(pack)) => (c, env) &
	assert_package c
	----------------
	locate_package (env, pack) => c

  rule	string_append (pack, ".mo") => filename &
	print "Loading " & print filename & print "...\n" &
	Parser.parse filename => (Absyn.PROGRAM((c as Absyn.CLASS(classname,_,_,_))::_,w)) &
	pack = classname &
	SCode.elaborate Absyn.PROGRAM([c],w) => [c'] &
	assert_package c'
	--------------------------------------------
	locate_package(env, pack) => c'

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,Absyn.R_PACKAGE,_)

end

(** relation: lookup_class_in_package
 ** 
 ** This relation searches a class definition for a named class
 ** definition.
 **
 ** The class is returned together with an empty environment, which
 ** might cause problems.  This should be solved using implicit
 ** instantiation, but that is future work.
 **)
 
relation lookup_class_in_package : (SCode.Class, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,
					       SCode.PARTS(els,_,_)),
				 path) => (c, Env.empty_env)

end
(** relation: lookup_class_in_elements
 ** 
 ** This relation helps `lookup_class_in_package' to do its thing.
 **)

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => (c', env)
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	

