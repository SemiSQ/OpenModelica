(**
 ** file:	 lookup.rml
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "explode.rml"

  relation lookup_type       : (Env.Env, Absyn.Path) => (Types.Type)
  relation lookup_class      : (Env.Env, Absyn.Path) => (SCode.Class)
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (SCode.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (SCode.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, Absyn.Ident) => Types.Var

end

with "parse.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 **)

relation lookup_type: (Env.Env,Absyn.Path) => Types.Type =

  rule	lookup_type_in_env(env,path) => t
	--------------------------------------
	lookup_type(env, path) => t

  rule	lookup_package_type (env,pack,path) => t
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack,path)) => t

end

(** relation: lookup_class
 **)

relation lookup_class: (Env.Env,Absyn.Path) => SCode.Class =

  rule	lookup_class_in_env(env,path) => c
	--------------------------------------
	lookup_class(env, path) => c

  rule	lookup_package_class (env,pack,path) => c
	--------------------------------------
	lookup_class(env, Absyn.QUALIFIED(pack,path)) => c

end

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env,Exp.ComponentRef)
	  => (SCode.Attributes, Types.Type, Types.Binding) =

  rule	(* print " lookup_var: looking in frame\n" & *)
	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var(Env.FRAME(items)::fs,ref) => (attr,ty,binding)

  rule	(* print " lookup_var: next frame\n" & *)
	lookup_var(fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var(_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_local
 **)

relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (SCode.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(items)::fs,ref) => (attr,ty,binding)

end

relation lookup_ident_local : (Env.Env, SCode.Ident) => Types.Var =

  rule  lookup_var2(items, id) => fv
	----------------------------
	lookup_ident_local(Env.FRAME(items)::_, id) => fv

end

(** - Internal relations *)

(**  Type lookup *)

relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type) =

  rule	lookup_type_in_frame(items,id) => c
	---------------------
	lookup_type_in_env(Env.FRAME(items)::fs,Absyn.IDENT(id)) => c

  rule	lookup_type_in_env(fs,id) => c
	---------------------
	lookup_type_in_env(f::fs,id) => c

end
(**)
relation lookup_type_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => Types.Type =

  rule	(* print "  lookup_type_in_frame(" & print id & print "): " &
	   print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_type_in_frame((n,Env.TYPE(t))::_, id) => t

  rule	id = n & print "# Error while looking up type " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_type_in_frame((n,Env.VAR(_))::_,id) => fail

  rule	(* print "  lookup_type_in_frame(" & print id & print "): not " &
	   print n & print "\n" & *)
	lookup_type_in_frame(fs,id) => t
	------------------------------
	lookup_type_in_frame((n,_)::fs,id) => t

end
(**)
relation lookup_package_type : (Env.Env, string, Absyn.Path) => Types.Type =
	
  rule	locate_package (env,packname) => pack &
 	print "- package lookup of types not implemented\n"
	(* lookup_type_in_package (pack, path) => t *)
	-------------------------------------
	lookup_package_type (env, packname, path) => (* t *) fail

end

(**  Class lookup *)

relation lookup_class_in_env: (Env.Env,Absyn.Path) => (SCode.Class) =

  rule	lookup_class_in_frame(items,id) => c
	---------------------
	lookup_class_in_env(Env.FRAME(items)::fs,Absyn.IDENT(id)) => c

  rule	lookup_class_in_env(fs,id) => c
	---------------------
	lookup_class_in_env(f::fs,id) => c

end
(**)
relation lookup_class_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => SCode.Class =

  rule	(* print "  lookup_class_in_frame(" & print id & print "): " &
	   print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_class_in_frame((n,Env.CLASS(c))::_, id) => c

(*
  rule	id = n & print "# Error while looking up class " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_class_in_frame((n,Env.VAR(_))::_,id) => fail
*)

  rule	lookup_class_in_frame(fs,id) => c
	------------------------------
	lookup_class_in_frame(_::fs,id) => c

end
(**)
relation lookup_package_class : (Env.Env, string, Absyn.Path)
	  => SCode.Class =

  rule	locate_package (env,packname) => pack &
	lookup_class_in_package (pack, path) => c
	-------------------------------------
	lookup_package_class (env, packname, path) => c

end
(**)
relation lookup_var2: ((SCode.Ident * Env.Item) list,SCode.Ident)
	  => Types.Var =

  rule	id = n
	--------------------------------------------
	lookup_var2((n,Env.VAR(fv))::_,id) => fv

(*
  rule	id = n & print "# Error while looking up component " &
	print id & print ": found a class\n"
	------------------------------------
	lookup_var2((n,Env.CLASS(_))::_,id) => fail

  rule	id = n & print "# Error while looking up component " &
	print id & print ": found a type\n"
	------------------------------------
	lookup_var2((n,Env.TYPE(_))::_,id) => fail
*)

  rule	lookup_var2(fs,id) => fv
	------------------------
	lookup_var2(_::fs,id) => fv

end
(**)
relation check_subscripts : (Absyn.ArrayDim, Exp.Subscript list)
	  => (Absyn.ArrayDim) =

  axiom check_subscripts(x, []) => []

  rule	check_subscripts(xs, ys) => ad
	(* FIXME: Check range too? Yes! *)
	------------------------------
	check_subscripts(x::xs,y::ys) => ad

  rule	print "- check_subscripts failed\n"
	-----------------------------------
	check_subscripts(_,_) => fail

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (SCode.Attributes,Types.Type,Types.Binding) =

	(* FIXME: Check protected flag *)

	(* FIXME: Should I really strip the ArrayDim? *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,SCode.ATTR(ad,fl,vt,di),_,ty',binding)) &
	check_subscripts(ad, ss) => dim
	------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (SCode.ATTR(dim,fl,vt,di),ty',binding)

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,SCode.ATTR(ad,fl,vt,di),_,ty',_)) &
	check_subscripts(ad, ss) => _ &
	lookup_in_var(ty', vs) => (attr, ty'',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty'',binding)

end	
(**)
relation lookup_var_f : ((SCode.Ident * Env.Item) list,
			 Exp.ComponentRef)
	  => (SCode.Attributes, Types.Type, Types.Binding) =

  rule  (* print " lookup_var_f 1: " & print id & print "\n" & *)
	lookup_var2(f, id) => Types.VAR(n,SCode.ATTR(ad,f,vt,di),_,ty,bind) &
	check_subscripts(ad,ss) => dim
	----------------------------------
	lookup_var_f(f,Exp.CREF_IDENT(id,ss))
	  => (SCode.ATTR(dim,f,vt,di),ty,bind)

  rule	(* print " lookup_var_f 2: " & print id & print "\n" & *)
	lookup_var2(f, id) => Types.VAR(n,SCode.ATTR(ad,f,vt,di),_,ty,_) &
	check_subscripts(ad,ss) => [] & (* FIXME: error message *)
	lookup_in_var(ty, ids) => (attr,ty,binding)
	----------------------------------
	lookup_var_f(f,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty,binding)

end

(**
 **  Package handling
 **)

relation locate_package : (Env.Env, string) => SCode.Class =

  rule	lookup_class(env, Absyn.IDENT(pack)) => c &
	(* FIXME: modifications? *)
	assert_package c
	----------------
	locate_package (env, pack) => c

  rule	string_append (pack, ".mo") => filename &
	print "Loading " & print filename & print "...\n" &
	Parser.parse filename => ((c as Absyn.CLASS(classname,_,_,_))::_) &
	pack = classname &
	SCode.elaborate [c] => [c'] &
	assert_package c'
	--------------------------------------------
	locate_package(env, pack) => c'

end

relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,Absyn.R_PACKAGE,_)

end

relation lookup_class_in_package : (SCode.Class, Absyn.Path) => SCode.Class =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,
					       SCode.PARTS(els,_,_)),
				 path) => c

end

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

	(* FIXME: Doesn't complain about an identifier being used for *)
	(* both a variable and a class *)
  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => c'
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	

