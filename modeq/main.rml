(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:        main.rml
 ** module:      Main
 ** description: Modelica main program
 **
 ** RCS: $Id$
 **
 ** This is the main program in the Modelica specification.
 **)

module Main:
	relation main: string list => ()
end

with "absyn.rml"
with "modutil.rml"
with "parse.rml"
with "dump.rml"
with "dumpgraphviz.rml"
with "explode.rml"
with "dae.rml"
with "inst.rml"
with "interactive.rml"
with "rtopts.rml"
with "debug.rml"
with "codegen.rml"
with "socket.rml"
with "print.rml"

(** relation: server_loop
 **
 ** This relation is the main loop of the server listening to a port
    which recieves modelica expressions,  
**)

relation server_loop: (int,Interactive.InteractiveSymbolTable)  => Interactive.InteractiveSymbolTable =

  rule	Socket.handlerequest shandle => str &
	Debug.fprint ("interactivedump" ,"------- Recieved Data from client -----\n") &
	Debug.fprint ("interactivedump" , str ) &
	Debug.fprint ("interactivedump", "------- End recieved Data-----\n") &
	handle_command (str,isymb)  => (true,replystr,newsymb) &
	Socket.sendreply(shandle,replystr) &
	server_loop (shandle,newsymb) => ressymb
	-----------------------------
	server_loop (shandle,isymb) => ressymb

  rule  Print.print_buf "Exiting\n" &
	Socket.sendreply(shandle, "quit requested, shutting server down\n") &
 	Socket.close shandle &
	Socket.cleanup 
	---------------------
	server_loop (shandle,isymb) => isymb
end

relation charlistcompare: (char list, char list, int) => bool =

  rule	a = b
	-------------------
	charlistcompare(a::_,b::_,1) => true

  rule	not a = b
	------------
	charlistcompare(a::_,b::_,1) => false

  rule	int_sub(n,1) => n1 &
	a = b &
	charlistcompare(l1,l2,n1) => true
	-------------------------------------
	charlistcompare(a::l1,b::l2,n) => true
	
  axiom	charlistcompare(_,_,_) => false
end

relation strncmp: (string,string,int)=>bool =
  rule	string_list(s1) => clst1 &
	string_list(s2) => clst2 &
	string_length(s1) => s1len &
	string_length(s2) => s2len &
	int_ge(s1len,n) => true &
	int_ge(s2len,n) => true &
	charlistcompare(clst1,clst2,n) => true
	-------------------------------------
	strncmp (s1,s2,n) => true
	axiom strncmp(_,_,_) => false
end

relation check_classdef: string => bool =

  rule	strncmp(" ",str,1) => true & 
	string_list(str) => clst &
	list_delete(clst,0) => clst' &
	list_string(clst') => str' &
	check_classdef(str')=> res
	--------------------------
	check_classdef(str) => res

  rule	strncmp ("type",str,4) => false &
	strncmp ("class",str,5) => false &
	strncmp ("model",str,5) => false &
	strncmp ("block",str,5) => false &
	strncmp ("within",str,6) => false &
	strncmp ("record",str,6) => false &
 	strncmp ("package",str,7) => false &
	strncmp ("partial",str,7) => false &
	strncmp ("function",str,8) => false &
	strncmp ("connector",str,9) => false &
	strncmp ("encapsulated",str,11) => false 
	-------------------------------
	check_classdef str => false

  axiom	check_classdef _ => true
end

(** relation handle_command
 **
 ** This relation handles the commands in form of strings send to the server
 ** If the command is quit, the relation returns false, otherwise it sends the string to the parse relation and returns true.
**)
relation handle_command: (string,Interactive.InteractiveSymbolTable)  => 
	(bool, string, Interactive.InteractiveSymbolTable) =

  rule	strncmp("quit()",str,6) => true 
	-------------------------------
	handle_command (str, isymb) => (false,"Ok\n",isymb)
	
  rule	check_classdef str => true &
	Debug.fprint ("dump","\nDetected class definition, parsing...\n") &
	Parser.parsestring str => p &
	Interactive.update_program (p,iprog) => newprog &
	Interactive.remove_compiled_functions(p,cf) => cf' &
 	Debug.fprint ("dump", "\n--------------- Parsed program ---------------\n") &
	Debug.fcall ("dumpgraphviz", DumpGraphviz.dump, newprog) &
	Debug.fcall ("dump", Dump.dump, newprog) 
	----------------------------------
	handle_command (str, Interactive.SYMBOLTABLE(iprog,a,b,c,cf)) => 
	(true, "Ok\n",Interactive.SYMBOLTABLE(newprog,a,b,c,cf'))

  rule	Debug.fprint ("dump","\nNot a class definition, trying expresion parser\n") &
	Parser.parsestringexp str => exp &
	Interactive.evaluate(exp,isymb) => (resultstr,newisymb) &
	Print.clear_buf()  &
	Debug.fprint ("dump", "\n--------------- Parsed expression ---------------\n") &
	Debug.fcall ("dump", Dump.dump_istmt, exp)
	--------------------------------------------------
	handle_command (str, isymb) => (true, resultstr, newisymb)

  rule  Print.print_buf "Error occured building AST\n"
	----------------------------------
	handle_command (_,isymb) => (true,"Syntax Error\n", isymb)
end

(** relation: translate_file
 **
 ** This relation invokes the translator on a source file.  The
 ** argument should be a list with a single file name.
 **)

relation translate_file : string list => () =

  rule	(*Print.print_buf "Parsing\n" &
*)	
	Parser.parse f => p

	& Debug.fprint ("dump", "\n--------------- Parsed program ---------------\n")
	& Debug.fcall ("dumpgraphviz", DumpGraphviz.dump, p)
	& Debug.fcall ("dump", Dump.dump, p)

	& Debug.fprint ("info", "\n------------------------------------------------------------ \n")
	& Debug.fprint ("info", "---elaborating\n")
	& SCode.elaborate(p) => p'

	(* & Dump.dump p' *)

	& Debug.fprint ("info", "---instantiating\n")
	& Inst.instantiate(p') => d'
	& Debug.fcall ("beforefixmodout", DAE.dump_debug, d')
	& fix_modelica_output (d') => d
(* & Debug.	print "\nJust instantiated" *)
	& Debug.fprint ("info", "---dumping\n")
	& Debug.fcall ("daedump", DAE.dump, d)
	& Debug.fcall ("daedump2", DAE.dump2, d)
	& Debug.fcall ("daedumpdebug", DAE.dump_debug, d)
	& Debug.fcall ("daedumpgraphv", DAE.dump_graphviz, d)
	& ModUtil.string_prefix_params d => d'
	& Debug.fcall ("codegen", Codegen.generate_functions, d') &
	Print.get_string() => str &
	print str 
	------------------------------
	translate_file [f]
	
  rule	Print.print_buf "# Too many arguments\n"
	----------------------------
	translate_file _::_::_ => fail

  rule	Print.print_buf "# Supply a file name\n"
	----------------------------
	translate_file [] => fail

  rule	Print.print_buf "# An error occured\n" &
	Print.get_string () => str &
	print str 
	----------------------------
	translate_file _ => fail

end


relation fix_modelica_output : DAE.DAElist => DAE.DAElist =

  rule	RTOpts.modelica_output => true &
	Inst.init_vars_modelica_output dae => dae'
	-------------------------------
	fix_modelica_output DAE.DAE(dae) => DAE.DAE(dae')

  rule	RTOpts.modelica_output => false
	-------------------------------
	fix_modelica_output (d as DAE.DAE(dae)) => d

end


relation interactivemode: string list => () =

  rule	Socket.waitforconnect 29500  => shandle &
	server_loop (shandle, Interactive.SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[],[])) => _
	-------------------
	interactivemode _
end
	

(** relation: main
 **
 ** This is the main relation that the RML runtime system calls to
 ** start the translation.
 **)

relation main : string list => () =

  rule	RTOpts.args args => args' &
	Debug.fcall ("interactive", interactivemode, args' ) &
	Debug.notfcall ("interactive", translate_file, args')
	--------------------
	main args

end
