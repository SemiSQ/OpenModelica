(**********************************************************************
 *
 *   Modifications
 *
 * Modifications are simply the same kind of modifications used in
 * Absyn.
 *
 **********************************************************************)

module Mod:

  with "exp.rml"
  with "absyn.rml"
  (* with "env.rml" *)
  (* with "lform.rml" *)
  with "dae.rml"
  with "prefix.rml"

  datatype SubMod = SUBMOD of Exp.Ident * Mod
  and Mod = MOD of bool * (SubMod list) * (Exp.Exp option)
  	  | REDECL of bool * Absyn.ElementSpec
	  | NOMOD

  val empty_mod : Mod

  relation dump : (Mod,string) => ()
  relation build : (Absyn.Modification option, bool) => Mod
  relation lookup_modification: (Mod,Absyn.Ident) => Mod
  relation merge : (Mod, Mod) => Mod

(*
  relation modify_class: (Env.Env, Exp.Path, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation maybe_modify_class: (Env.Env, Exp.Path, Mod,
				Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_maybe_modify_class : (Env.Env, Mod,
				        Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
*)

end

(**********************************************************************)

val empty_mod = MOD(false,[],NONE)

(**********************************************************************)

relation dump_final : bool => () =

  axiom dump_final false

  rule print "final "
       --------------
       dump_final true

end

relation dump_subs : SubMod list => () =

  axiom dump_subs []

  rule  dump(mod,n)
	-----------
	dump_subs [SUBMOD(n,mod)]

  rule  dump(mod,n) &
	dump_subs subs
	--------------
	dump_subs SUBMOD(n,mod)::subs

end

relation dump_ass : Exp.Exp option => () =

  axiom dump_ass NONE

  rule  print " = XXX"
	--------------
	dump_ass SOME(e)

end
	
	
relation dump : (Mod,string) => () =

  rule  print n
	-------
	dump(NOMOD,n)

  rule  print n & print "(redeclared)"
	------------------------------
	dump(REDECL(_,_),n)

  rule  dump_final final &
	print n &
	print "(" &
	dump_subs subs &
	print ")" &
	dump_ass ass
	------------
	dump(MOD(final, subs, ass),n)

end

(**********************************************************************)

relation expand_nomod : Mod => Mod =

  axiom expand_nomod(m as MOD(_,_,_)) => m

  axiom expand_nomod NOMOD => empty_mod

end

relation build_sub : (Exp.Path,Mod) => SubMod =

  axiom build_sub(Exp.IDENT(i),mod) => SUBMOD(i,mod)

  rule  build_sub(path,mod) => sub
	--------------------------
	build_sub(Exp.QUALIFIED(i,path),mod)
	  => SUBMOD(i,MOD(false,[sub],NONE))

end

relation build_args : (Absyn.ElementArg list) => SubMod list =

  axiom build_args [] => []

  rule  build_args xs => subs &
	build(SOME(mod),final) => mod' &
	build_sub(path,mod') => sub
	----------------------
	build_args((Absyn.MODIFICATION(final,path,mod)::xs)) => (sub::subs)

  rule  build_args xs => subs &
	Absyn.element_spec_name spec => n
	---------------------------
	build_args((Absyn.REDECLARATION(final,spec)::xs))
	  => (SUBMOD(n,REDECL(final,spec))::subs)

end

and build : (Absyn.Modification option, bool) => Mod =

  axiom build(NONE, _) => NOMOD

  axiom build(SOME(Absyn.EQUALMOD(exp)),final) => MOD(final,[],SOME(exp))

  axiom	build(SOME(Absyn.CLASSMOD([])),_) => NOMOD

  rule  build_args(l) => subs
	---------------------------
	build(SOME(Absyn.CLASSMOD(l)),final) => MOD(final,subs,NONE)

end


(**********************************************************************)

relation lookup_modification2 : (SubMod list,Absyn.Ident) => Mod =

  axiom lookup_modification2([],_) => NOMOD

  rule  n = m
	-----
	lookup_modification2(SUBMOD(n,mod)::_,m) => mod
	
	(* FIXME: Redeclaration *)

  rule  lookup_modification2(xs,n) => mod
	---------------------------------
	lookup_modification2(x::xs,n) => mod

end

relation lookup_modification: (Mod,Absyn.Ident) => Mod =

  axiom lookup_modification(NOMOD,_) => NOMOD

  rule  lookup_modification2(subs,n) => mod
	---------------------------------
	lookup_modification(MOD(_,subs,_),n) => mod

end

(**********************************************************************
 *
 *   Merging
 *
 * The merge relation merges to modifications to one. The first
 * argument is the "outer" modification that should take effect after
 * the "inner" modifications. FIXME: correct?
 *
 **********************************************************************)

relation merge_subs2 : (SubMod list, SubMod) => (SubMod list, SubMod) =

  axiom merge_subs2([],m) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2
	-------
	merge_subs2((s1 as SUBMOD(n1,m1))::ss, SUBMOD(n2,m2)) => (ss, s1)

  rule  merge_subs2(ss, s2) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2) => (s1::ss',s)

end

relation merge_subs : (SubMod list, SubMod list) => SubMod list =

  axiom merge_subs(s1,[]) => s1

  rule  merge_subs2(s1,s) => (s1',s') &
	merge_subs(s1',s2) => ss
	------------------------
	merge_subs(s1,s::s2) => ss

end

relation merge_ass : (Exp.Exp option, Exp.Exp option) => Exp.Exp option =

	(* Outer assignments take precedence *)

  axiom merge_ass(e as SOME(_), _) => e

  axiom merge_ass(NONE,e) => e

end

relation merge : (Mod, Mod) => Mod =

  axiom merge(NOMOD,NOMOD) => NOMOD

  axiom merge(NOMOD,m) => m

  axiom merge(m,NOMOD) => m

  rule  print " ignoring inner modification\n"
	--------------------------------------
	merge(m as REDECL(_,_),_) => m

  rule  print "# can't merge modification with a redeclaration\n" & fail
	----------------------------------------------------------------
	merge(_,REDECL(_,_)) => NOMOD

  rule  print "# trying to modify final element\n" & fail
	-------------------------------------------------
	merge(_,m as MOD(true,_,_)) => m

  rule  merge_subs(subs1, subs2) => subs &
	merge_ass(ass1, ass2) => ass
	----------------------------
	merge(MOD(final,subs1,ass1), MOD(false,subs2,ass2))
	  => MOD(final,subs,ass)

  rule	print "# incomplete handling of modification merging\n"
	-----------------------------------------------------
	merge(outer,inner) => outer

end

(**********************************************************************)
(* To EOF

relation check_mod : (Mod.Mod, string,Absyn.Element, bool) => () =

  axiom check_mod(NOMOD,_,_,_)

  rule	print "Error: Trying to modify protected element " &
	print n & print "\n" &
	fail
	--------------------------------------------------------------
	check_mod(MOD(_,_),n,e,false)

  rule	print "Error: Trying to modify final element " & print n & print "\n" &
	fail
	---------------------------------------------------------------------
	check_mod(MOD(_,_),n,e as Absyn.ELEMENT(true,_,_),_)

  axiom check_mod(_,_,_,_)

end

relation modify_element : (Mod,Prefix.Prefix,Absyn.Element,bool)
	  => (Lform.Element, DAE.DAEcomp list) =

  rule	(* Prefix.prefix_exp(exp,pre) => exp' & *)
	Prefix.prefix_path(Exp.IDENT(n),pre) => np &
	Exp.path_string(np) => nps &

	check_mod(mod,nps,e,prot) &

	Prefix.prefix_add(pre, n) => pre' &
	modify_element_spec(mod, pre', spec) => spec'

	(* print "  modify_element: adding equation " & *)
	(* print nps & print " = ...\n" & *)
	(* Lform.convert_element(e) => e' *)
	-----------------------------------
	modify_element(mod,pre,e as Absyn.ELEMENT(final,n,spec),pub)
	 => (Lform.ELEMENT(final,n,spec'),
	     [(* DAE.EQUATION(Exp.RELATION(Exp.PATH(np),Exp.EQUAL,exp')) *)])

  rule	Prefix.prefix_path(Exp.IDENT(n),pre) => np &
	Exp.path_string(np) => nps &

	check_mod(mod,nps,e,prot) &

	Prefix.prefix_add(pre, n) => pre' &
	modify_element_spec(NONE, pre', spec) => spec' &

	Prefix.prefix_exp(exp,pre) => exp'
	(* print "  modify_element: adding equation " & *)
	(* print nps & print " = ...\n" & *)
	(* Lform.convert_element(e) => e' *)
	-----------------------------------
	modify_element(SOME(Absyn.EQUALMOD(exp)),pre,
		       e as Absyn.ELEMENT(final,n,spec),pub)
	 => (Lform.ELEMENT(final,n,spec'),
	     [(* DAE.EQUATION(Exp.RELATION(Exp.PATH(np),Exp.EQUAL,exp')) *)])

(*
  rule	Prefix.prefix_path(Exp.IDENT(en),pre) => np &

	print "  modify_element: modify_class( " &
	Exp.path_string(np) => nps &
	print nps & print ", ...)\n" &

	modify_class(env,np,m,pre,c) => (c',dae)
	-----------------------------------------------------------
	modify_element(SOME(m),pre, e as Absyn.ELEMENT(f,en,
					  Absyn.COMPONENTS(_,_,_,_,_,t,
					  [Absyn.COMPONENT(])),_))
	 => (Lform.ELEMENT(f,en,Lform.COMPONENTS))
*)
  rule	Prefix.prefix_path(Exp.IDENT(en),pre) => np &
	Exp.path_string(np) => ns &
	print "# ignoring modification of " & print ns & print "\n" &
	Lform.convert_element(e) => e'
	-----------------------------------------------------------
	modify_element(SOME(m),pre,e as Absyn.ELEMENT(_,en,_),_) => (e',[])

end

relation modify_classpart : (Mod,Prefix.Prefix,Absyn.ClassPart)
	  => (Lform.ClassPart, DAE.DAEcomp list) =

  axiom	modify_classpart(_,_,p as Absyn.EQUATIONS(_))  => (p,[])
  axiom	modify_classpart(_,_,p as Absyn.ALGORITHMS(_)) => (p,[])
  axiom	modify_classpart(_,_,p as Absyn.PUBLIC([]))    => (p,[])
  axiom	modify_classpart(_,_,p as Absyn.PROTECTED([])) => (p,[])

  rule	element_name(e) => en &
	lookup_modification(mod,en) => mod' &
	modify_element(mod',pre,e,true) => (e',eq1) &
	modify_classpart(mod,pre,Absyn.PUBLIC(es))
	 => (Lform.PUBLIC(es'),eq2) &
	list_append(eq1,eq2) => eq
	---------------------------------------
	modify_classpart(mod,pre,Absyn.PUBLIC(e::es))
	 => (Lform.PUBLIC(e'::es'),eq)

  rule	element_name(e) => en &
	lookup_modification(mod,en) => mod' &
	modify_element(mod',pre,e,false) => (e',eq1) &
	modify_classpart(mod,pre,Absyn.PROTECTED(es))
	 => (Lform.PUBLIC(es'),eq2) &
	list_append(eq1,eq2) => eq
	---------------------------------------
	modify_classpart(mod,pre,Absyn.PROTECTED(e::es)) =>
	  (Lform.PROTECTED(e'::es'), eq)

end

relation modify_classdef : (Env.Env,Mod,Prefix.Prefix,Absyn.ClassDef)
	  => (Lform.ClassDef, DAE.DAEcomp list) =

  axiom	modify_classdef(_,_,_,p as Absyn.PARTS([])) => (p,[])

  rule	modify_classpart(mod,pre,p) => (p',eq1) &
	modify_classdef(env,mod,pre,Absyn.PARTS(ps))
	 => (Lform.PARTS(ps'),eq2) &
	list_append(eq1,eq2) => eq
	------------------------------------
	modify_classdef(env,mod,pre,Absyn.PARTS(p::ps))
	 => (Lform.PARTS(p'::ps'), eq)

  rule	(* FIXME: Check restriction *)
	modify_classdef(env,mod,pre,d) => (d',eq)
	---------------------------------
	modify_classdef(env,mod,pre,Absyn.DERIVED(Absyn.CLASS(n,_,r,d),
						  ad,es)) => (d',eq)

end

relation modify_class: (Env.Env, Exp.Path, Mod, Prefix.Prefix, Absyn.Class)
	  => (Lform.Class, DAE.DAEcomp list) =

  rule	print "  modify_class: Adding equation " &
	Exp.path_string(vn) => s &
	print s & print " = ...\n"
	---------------------------------------------------
	modify_class(env,vn,Absyn.EQUALMOD(e), pre, c)
	 => (c,[DAE.EQUATION(Exp.RELATION(Exp.PATH(vn),Exp.EQUAL,e))])

  rule	modify_classdef(env,mod,pre,d) => (d',eq)
	---------------------------------
	modify_class(env,_,mod, pre, Absyn.CLASS(n,p,r,d))
	 => (Lform.CLASS(n,p,r,d'),eq)

end

relation maybe_modify_class: (Env.Env, Exp.Path, Mod, Prefix.Prefix, Absyn.Class)
	  => (Lform.Class, DAE.DAEcomp list) =

  axiom	maybe_modify_class(_,_,NONE,pre,c) => (c, [])

  rule	modify_class(env,vn,mod,pre,c) => (c',l)
	------------------------------
	maybe_modify_class(env,vn,SOME(mod),pre,c) => (c',l)

end

relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	  => (Lform.Class, DAE.DAEcomp list) =

  rule	modify_classdef(env,mod,pre,d) => (d',dae)
	---------------------------------
	simple_modify_class(env,mod,pre,Absyn.CLASS(n,p,r,d))
	 => (Lform.CLASS(n,p,r,d'),dae)

end

relation simple_maybe_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	  => (Lform.Class, DAE.DAEcomp list) =

  axiom	simple_maybe_modify_class(_,NONE,_,c) => (c,[])

  rule	modify_classdef(env,mod,pre,d) => (d',dae)
	--------------------------------------
	simple_maybe_modify_class(env,SOME(mod),pre,Absyn.CLASS(n,p,r,d))
	 => (Lform.CLASS(n,p,r,d'),dae)

end
*)
