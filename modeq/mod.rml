(**********************************************************************
 *
 *   Modifications
 *
 * Modifications are simply the same kind of modifications used in
 * Absyn.
 *
 **********************************************************************)

module Mod:

  with "exp.rml"
  with "absyn.rml"
  with "env.rml"
  with "dae.rml"
  with "prefix.rml"

  type Mod = Absyn.Modification

  val empty_mod : Mod

  relation modify_class: (Env.Env, Exp.Path, Mod, Prefix.Prefix, Absyn.Class)
	    => (Absyn.Class, DAE.DAEcomp list)
  relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	    => (Absyn.Class, DAE.DAEcomp list)
  relation maybe_modify_class: (Env.Env, Exp.Path, Mod option, Prefix.Prefix, Absyn.Class)
	    => (Absyn.Class, DAE.DAEcomp list)
  relation simple_maybe_modify_class : (Env.Env, Mod option, Prefix.Prefix, Absyn.Class)
	    => (Absyn.Class, DAE.DAEcomp list)
  relation lookup_modification: (Mod,Absyn.Ident) => Mod option

  relation merge : (Mod option, Mod option) => Mod option

end

val empty_mod = Absyn.CLASSMOD([])

(**********************************************************************)

relation inst_list =

  axiom	inst_list(_,[],_) => []

  rule	r(x,p) => x' &
	inst_list(r,xs,p) => xs' &
	list_append(x',xs') => y
	----------------------
	inst_list(r,x::xs,p) => y

end

(* utility *)

relation element_name : Absyn.Element => Exp.Ident =

  axiom  element_name(Absyn.ELEMENT(_,n,_)) => n

end

(**********************************************************************)

relation lookup_classmod : (Absyn.ElementArg list, Absyn.Ident)
	  => Mod option =

  axiom lookup_classmod([],_) => NONE

  rule	mn = n
	------
	lookup_classmod(Absyn.MODIFICATION(f,Exp.IDENT(mn),m)::_,n)
	 => SOME(m)

  rule  mn = n
	------
	lookup_classmod(Absyn.MODIFICATION(f,Exp.QUALIFIED(mn,p),m)::_,n)
	 => SOME(Absyn.CLASSMOD([Absyn.MODIFICATION(f,p,m)]))

  rule  print "FIXME: lookup_classmod(REDECLARATION)\n" &
	fail
	-----------------------------------------------
	lookup_classmod(Absyn.REDECLARATION(f,_)::_,n) => NONE

  rule	lookup_classmod(es,n) => m
	--------------------------
	lookup_classmod(_::es,n) => m

end	

relation lookup_modification: (Mod,Absyn.Ident) => Mod option =

  rule	print "Error: lookup_modification(EQUALMOD(_)," &
	print n & print ")\n"
	----------------------------------------------
	lookup_modification(Absyn.EQUALMOD(_),n) => NONE

  rule  lookup_classmod(cm,n) => m
	------------------------
	lookup_modification(Absyn.CLASSMOD(cm),n) => m

end

relation modifies: (Mod,Absyn.Ident) => () =

  rule	lookup_modification(mod,n) => m
	-------------------------------
	modifies(mod,n)

end

relation modify_element : (Mod option,Prefix.Prefix,Absyn.Element,bool)
	  => (Absyn.Element, DAE.DAEcomp list) =

  axiom modify_element(NONE,_,e,_) => (e,[])

  rule	element_name(e) => n &
	modifies(mod,n) &
	print "Error: Trying to modify protected element " &
	print n & print "\n"
	--------------------------------------------------------------
	modify_element(SOME(mod),_,e,false) => (e,[])

  rule	modifies(mod,n) &
	print "Error: Trying to modify final element " & print n & print "\n"
	---------------------------------------------------------------------
	modify_element(SOME(mod),_,e as Absyn.ELEMENT(true,n,_),_) => (e,[])

  rule	Prefix.prefix_exp(exp,pre) => exp' &
	element_name(e) => n &
	Prefix.prefix_path(Exp.IDENT(n),pre) => np
	-----------------------------------
	modify_element(SOME(Absyn.EQUALMOD(exp)),pre, e,_)
	 => (e,[DAE.EQUATION(Exp.RELATION(Exp.PATH(np),Exp.EQUAL,exp'))])

end

relation modify_classpart : (Mod,Prefix.Prefix,Absyn.ClassPart)
	  => (Absyn.ClassPart, DAE.DAEcomp list) =

  axiom	modify_classpart(_,_,p as Absyn.EQUATIONS(_))  => (p,[])
  axiom	modify_classpart(_,_,p as Absyn.ALGORITHMS(_)) => (p,[])
  axiom	modify_classpart(_,_,p as Absyn.PUBLIC([]))    => (p,[])
  axiom	modify_classpart(_,_,p as Absyn.PROTECTED([])) => (p,[])

  rule	element_name(e) => en &
	lookup_modification(mod,en) => mod' &
	modify_element(mod',pre,e,true) => (e',eq1) &
	modify_classpart(mod,pre,Absyn.PUBLIC(es))
	 => (Absyn.PUBLIC(es'),eq2) &
	list_append(eq1,eq2) => eq
	---------------------------------------
	modify_classpart(mod,pre,Absyn.PUBLIC(e::es))
	 => (Absyn.PUBLIC(e'::es'),eq)

  rule	element_name(e) => en &
	lookup_modification(mod,en) => mod' &
	modify_element(mod',pre,e,false) => (e',eq1) &
	modify_classpart(mod,pre,Absyn.PROTECTED(es))
	 => (Absyn.PUBLIC(es'),eq2) &
	list_append(eq1,eq2) => eq
	---------------------------------------
	modify_classpart(mod,pre,Absyn.PROTECTED(e::es)) =>
	  (Absyn.PROTECTED(e'::es'), eq)

end

relation modify_classdef : (Env.Env,Mod,Prefix.Prefix,Absyn.ClassDef)
	  => (Absyn.ClassDef, DAE.DAEcomp list) =

  axiom	modify_classdef(_,_,_,p as Absyn.PARTS([])) => (p,[])

  rule	modify_classpart(mod,pre,p) => (p',eq1) &
	modify_classdef(env,mod,pre,Absyn.PARTS(ps))
	 => (Absyn.PARTS(ps'),eq2) &
	list_append(eq1,eq2) => eq
	------------------------------------
	modify_classdef(env,mod,pre,Absyn.PARTS(p::ps))
	 => (Absyn.PARTS(p'::ps'), eq)

  rule	Env.lookup_class(env,p) => Absyn.CLASS(n,_,r,d) &
	(* FIXME: Check restriction *)
	modify_classdef(env,mod,pre,d) => (d',eq)
	---------------------------------
	modify_classdef(env,mod,pre,Absyn.DERIVED(p,ad,es)) => (d',eq)

end

relation modify_class: (Env.Env, Exp.Path, Mod, Prefix.Prefix, Absyn.Class)
	  => (Absyn.Class, DAE.DAEcomp list) =

  rule	print "  modify_class: Adding equation " &
	Exp.path_string(vn) => s &
	print s & print " = ...\n"
	---------------------------------------------------
	modify_class(env,vn,Absyn.EQUALMOD(e), pre, c)
	 => (c,[DAE.EQUATION(Exp.RELATION(Exp.PATH(vn),Exp.EQUAL,e))])

  rule	modify_classdef(env,mod,pre,d) => (d',eq)
	---------------------------------
	modify_class(env,_,mod, pre, Absyn.CLASS(n,p,r,d))
	 => (Absyn.CLASS(n,p,r,d'),eq)

end

relation maybe_modify_class: (Env.Env, Exp.Path, Mod option, Prefix.Prefix, Absyn.Class)
	  => (Absyn.Class, DAE.DAEcomp list) =

  axiom	maybe_modify_class(_,_,NONE,pre,c) => (c, [])

  rule	modify_class(env,vn,mod,pre,c) => (c',l)
	------------------------------
	maybe_modify_class(env,vn,SOME(mod),pre,c) => (c',l)

end

relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	  => (Absyn.Class, DAE.DAEcomp list) =

  rule	modify_classdef(env,mod,pre,d) => (d',dae)
	---------------------------------
	simple_modify_class(env,mod,pre,Absyn.CLASS(n,p,r,d))
	 => (Absyn.CLASS(n,p,r,d'),dae)

end

relation simple_maybe_modify_class : (Env.Env, Mod option, Prefix.Prefix, Absyn.Class)
	  => (Absyn.Class, DAE.DAEcomp list) =

  axiom	simple_maybe_modify_class(_,NONE,_,c) => (c,[])

  rule	modify_classdef(env,mod,pre,d) => (d',dae)
	--------------------------------------
	simple_maybe_modify_class(env,SOME(mod),pre,Absyn.CLASS(n,p,r,d))
	 => (Absyn.CLASS(n,p,r,d'),dae)

end


relation merge : (Mod option, Mod option) => Mod option =

  axiom merge(NONE,NONE) => NONE

  axiom merge(NONE,m) => m

  axiom merge(m,NONE) => m

  rule	print "Incomplete handling of modification merging\n"
	-----------------------------------------------------
	merge(outer,inner) => outer

end
