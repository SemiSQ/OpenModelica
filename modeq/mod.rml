(**
 ** file: mod.rml
 **
 ** $Id$
 **
 ** Modifications are simply the same kind of modifications used in
 ** the `Absyn' module.
 **
 **)

module Mod:

  with "absyn.rml"
  with "dae.rml"
  with "env.rml"
  with "exp.rml"
  with "prefix.rml"
  with "explode.rml"
  with "types.rml"
  with "staticexp.rml"
  with "values.rml"

  type Ident = string

  (** - Modification datatype *)
  datatype SubMod = SUBMOD of Ident * int list * Mod
  and Mod = MOD of bool * (SubMod list) * (Exp.Exp * Types.Type * bool) option
  	  | REDECL of bool * Absyn.ElementSpec
	  | NOMOD
  (** This type is very similar to `SCode.Mod'.  The main difference is
   ** that it uses `Exp.Exp' for the expressions.  Expressions stored
   ** here are prefixed and typechecked.
   **)

  val empty_mod : Mod

  relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod) => Mod

  relation lookup_modification: (Mod,Absyn.Ident,int list) => Mod
  relation lookup_modification_p: (Mod,Absyn.Path) => Mod
  relation merge : (Mod, Mod) => Mod
  relation mod_equation : Mod => (Exp.Exp * Types.Type * bool) option

(*
  relation modify_class: (Env.Env, Absyn.Path, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation maybe_modify_class: (Env.Env, Absyn.Path, Mod,
				Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_maybe_modify_class : (Env.Env, Mod,
				        Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
*)

end

(** relation: elab_mod
 **
 ** This relation elaborates on the expressions in a modification and
 ** turns them into global expressions.  This is done because the
 ** expressions in modifications must be elaborated on in the context
 ** they are provided in, and not the context they are used in.
 **)
 
relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod) => Mod =

  axiom	elab_mod (_,_,SCode.NOMOD) => NOMOD

  rule	elab_submods (env,pre,subs) => subs'
	------------------------------------
	elab_mod (env,pre,MOD(final,subs,NONE)) => MOD(final,subs',NONE)
	
  rule	elab_submods (env,pre,subs) => subs' &
	StatixExp.elab_exp(env,e) => (e',t,c) &
	Prefix.prefix_exp(env,e',pre) => e''
	------------------------------------
	elab_mod (env,pre,MOD(final,subs,SOME(e)))
	  => MOD(final,subs',SOME(e'',t,c))

end

relation elab_submods : (Env.Env, Prefix.Prefix, SCode.SubMod list)
	  => SubMod list =

  axiom	elab_submods (_,_,[]) => []

  rule	elab_submod (env,pre,x) => x' &
	elab_submods (env,pre,xs) => xs'
	--------------------------------
	elab_submods (env,pre,x::xs) => x'::xs'

end

relation elab_submod : (Env.Env, Prefix.Prefix, SCode.SubMod) => SubMod =

  rule	elab_subscripts (env,pre,ss) => ss' &
	Prefix.prefix_add (i,ss',pre) => pre' &
	elab_mod (env,pre',m) => m'
	---------------------------
	elab_submod (env,pre,SCode.SUBMOD(i,ss,m)) => SUBMOD(i,ss',m')

end

relation elab_subscripts : (Env.Env, Prefix.Prefix, SCode.Subscript list)
	=> int list =

  axiom	elab_subscripts (_,_,[]) => []
	
  rule	print "# Use of colon subscript subscripts is not allowed" &
	print " in modifications\n"
	--------------------------------
	elab_subscripts (env,pre,Absyn.NOSUB::xs) => fail
	
  rule	StaticExp.elab_exp(env,e) => (e',t,c) &
	eval_subscript (env,e',t,c) => i &
	elab_subscripts (env,pre,xs) => xs'
	-----------------------------------
	elab_subscripts (env,pre,Absyn.SUBSCRIPT(e)::xs) => i::xs'
	
end

relation eval_subscript : (Env.Env, Exp.Exp, Types.Type, bool) => int =

  rule	StaticExp.ceval (env,e) => Values.INTEGER(i)
	--------------------------------------------
	eval_subscript (env,e,Types.T_INTEGER,true) => i

  rule	not t = Types.T_INTEGER &
	print "# Non-integer subscript " & Exp.print_exp e &
	print " in modification\n"
	--------------------------
	eval_subscript (_,e,t,_) => fail

  rule	print "# Non-constant subscript " & Exp.print_exp e &
	print " in modification\n"
	--------------------------
	eval_subscript (_,e,_,false) => fail

  rule	print "- Mod.eval_subscript failed\n"
	-------------------------------------
	eval_subscript(_,_,_,_) => fail

end

(**)

with "dump.rml"

val empty_mod = MOD(false,[],NONE)

(**)

relation expand_nomod : Mod => Mod =

  axiom expand_nomod(m as MOD(_,_,_)) => m

  axiom expand_nomod NOMOD => empty_mod

end

(**
 ** - Lookup
 **)

(** relation: lookup_modification_p *)

relation lookup_modification_p: (Mod,Absyn.Path) => Mod =

  rule	lookup_modification (m,n,[]) => mod
	--------------------------------
	lookup_modification_p (m,Absyn.IDENT(n)) => mod

  rule	lookup_modification (m,n,[]) => mod &
	lookup_modification_p (mod,p) => mod'
	-------------------------------------
	lookup_modification_p (m,Absyn.QUALIFIED(n,p)) => mod'

end

(** relation: lookup_modification *)

relation lookup_modification: (Mod,Absyn.Ident,int list) => Mod =

  axiom lookup_modification(NOMOD,_,_) => NOMOD

	(* FIXME: Is this correct? *)
  axiom	lookup_modification(REDECL(_,_),_,_) => NOMOD

  rule  lookup_modification2(subs,n,s) => mod
	-----------------------------------
	lookup_modification(MOD(_,subs,_),n,s) => mod
	
  rule	print "# Mod.lookup_modification(" &
	(* print_mod mod & print "," & print i & *)
	print ") failed\n"
	--------------------
	lookup_modification(mod,i,s) => fail

end	

relation lookup_modification2 : (SubMod list,Absyn.Ident,int list)
	  => Mod =

  axiom lookup_modification2([],_,_) => NOMOD

  rule  n = m (* & ss = s FIXME: subscripts *)
	--------------------------------------
	lookup_modification2(SUBMOD(n,ss,mod)::_,m,s) => mod
	
	(* FIXME: Redeclaration *)

  rule  lookup_modification2(xs,n,s) => mod
	---------------------------------
	lookup_modification2(x::xs,n,s) => mod

end

(**
 **
 ** - Merging
 **
 ** The merge relation merges to modifications to one. The first
 ** argument is the "outer" modification that should take precedence over
 ** the "inner" modifications. FIXME: correct?
 **
 **)
(** relation: merge
 **)

relation merge : (Mod, Mod) => Mod =

  axiom merge(NOMOD,NOMOD) => NOMOD

  axiom merge(NOMOD,m) => m

  axiom merge(m,NOMOD) => m

  rule  print " ignoring inner modification\n"
	--------------------------------------
	merge(m as REDECL(_,_),_) => m

  rule  print "# can't merge modification with a redeclaration\n"
	---------------------------------------------------------
	merge(_,REDECL(_,_)) => fail

  rule  print "# trying to modify final element\n"
	------------------------------------------
	merge(_,m as MOD(true,_,_)) => fail

  rule  merge_subs(subs1, subs2) => subs &
	merge_eq(ass1, ass2) => ass
	----------------------------
	merge(MOD(final,subs1,ass1), MOD(false,subs2,ass2))
	  => MOD(final,subs,ass)

  rule	print "# incomplete handling of modification merging\n"
	-----------------------------------------------------
	merge(outer,inner) => outer

end

(** relation: merge_subs
 **)

relation merge_subs : (SubMod list, SubMod list)
	  => SubMod list =

  axiom merge_subs(s1,[]) => s1

  rule  merge_subs2(s1,s) => (s1',s') &
	merge_subs(s1',s2) => ss
	------------------------
	merge_subs(s1,s::s2) => s'::ss

end

(** relation: merge_subs2
 **)

relation merge_subs2 : (SubMod list, SubMod)
	  => (SubMod list, SubMod) =

  axiom merge_subs2([],m) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2 & print "   merge clash in " & print n1 & print "\n"
	(* FIXME: check subscripts? *)
	-------
	merge_subs2((s1 as SUBMOD(n1,subs1,m1))::ss,
		    SUBMOD(n2,subs2,m2)) => (ss, s1)

  rule  merge_subs2(ss, s2) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2) => (s1::ss',s)

end

(** relation: merge_eq
 **)

relation merge_eq : ((Exp.Exp * Types.Type * bool) option,
		     (Exp.Exp * Types.Type * bool) option)
	  => (Exp.Exp * Types.Type * bool) option =

	(* Outer assignments take precedence *)

  axiom merge_eq(e as SOME((_,_,_)), _) => e

  axiom merge_eq(NONE,e) => e

end

(** relation: mod_equation
 **)

relation mod_equation : Mod => (Exp.Exp * Types.Type * bool) option =

  axiom mod_equation NOMOD => NONE

  axiom mod_equation REDECL(_,_) => NONE

  axiom mod_equation MOD(_,_,e) => e

end
