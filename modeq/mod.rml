(**********************************************************************
 *
 *   Modifications
 *
 * Modifications are simply the same kind of modifications used in
 * Absyn.
 *
 **********************************************************************)

module Mod:

  with "exp.rml"
  with "absyn.rml"
  (* with "env.rml" *)
  (* with "lform.rml" *)
  with "dae.rml"
  with "prefix.rml"

  datatype SubMod = SUBMOD of Exp.Ident * Mod
  and Mod = MOD of bool * (SubMod list) * (Exp.Exp option)
  	  | REDECL of bool * Absyn.ElementSpec
	  | NOMOD

  val empty_mod : Mod

  relation dump : Mod => ()
  relation build : (Absyn.Modification option, bool) => Mod
  relation lookup_modification: (Mod,Absyn.Ident) => Mod
  relation merge : (Mod, Mod) => Mod
  relation mod_assignment : Mod => Exp.Exp option

(*
  relation modify_class: (Env.Env, Exp.Path, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation maybe_modify_class: (Env.Env, Exp.Path, Mod,
				Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_maybe_modify_class : (Env.Env, Mod,
				        Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
*)

end

with "dump.rml"

(**********************************************************************)

val empty_mod = MOD(false,[],NONE)

(**********************************************************************)

relation dump_final : bool => () =

  axiom dump_final false

  rule print " final "
       --------------
       dump_final true

end

relation dump_subs : SubMod list => () =

  axiom dump_subs []

  rule  print n & dump mod
	------------------
	dump_subs [SUBMOD(n,mod)]

  rule  print n & dump mod & print ", " &
	dump_subs subs
	--------------
	dump_subs SUBMOD(n,mod)::subs

end

relation dump_subs1 : SubMod list => () =

  axiom dump_subs1 [] => ()

  rule	print "(" &
	dump_subs l &
	print ")"
	-----------
	dump_subs1 l

end

relation dump_ass : Exp.Exp option => () =

  axiom dump_ass NONE

  rule  print " = " & Dump.dump_exp e
	-----------------------------
	dump_ass SOME(e)

end
	
relation dump : Mod => () =

  axiom	dump(NOMOD)

  rule  print "(redeclared)"
	------------------------------
	dump REDECL(_,_)
	
  rule	dump_final final &
	dump_subs1 subs &
	dump_ass ass
	------------
	dump MOD(final, subs, ass)

end

(**********************************************************************)

relation expand_nomod : Mod => Mod =

  axiom expand_nomod(m as MOD(_,_,_)) => m

  axiom expand_nomod NOMOD => empty_mod

end

relation build_sub : (Exp.Path,Mod) => SubMod =

  axiom build_sub(Exp.IDENT(i),mod) => SUBMOD(i,mod)

  rule  build_sub(path,mod) => sub
	--------------------------
	build_sub(Exp.QUALIFIED(i,path),mod)
	  => SUBMOD(i,MOD(false,[sub],NONE))

end

relation build_args : (Absyn.ElementArg list) => SubMod list =

  axiom build_args [] => []

  rule  build_args xs => subs &
	build(SOME(mod),final) => mod' &
	build_sub(path,mod') => sub
	----------------------
	build_args((Absyn.MODIFICATION(final,path,mod)::xs)) => (sub::subs)

  rule  build_args xs => subs &
	Absyn.element_spec_name spec => n
	---------------------------
	build_args((Absyn.REDECLARATION(final,spec)::xs))
	  => (SUBMOD(n,REDECL(final,spec))::subs)

end

and build : (Absyn.Modification option, bool) => Mod =

  axiom build(NONE, _) => NOMOD

  axiom build(SOME(Absyn.EQUALMOD(exp)),final) => MOD(final,[],SOME(exp))

  axiom	build(SOME(Absyn.CLASSMOD([])),_) => NOMOD

  rule  build_args(l) => subs
	---------------------------
	build(SOME(Absyn.CLASSMOD(l)),final) => MOD(final,subs,NONE)

end


(**********************************************************************)

relation lookup_modification2 : (SubMod list,Absyn.Ident) => Mod =

  axiom lookup_modification2([],_) => NOMOD

  rule  n = m
	-----
	lookup_modification2(SUBMOD(n,mod)::_,m) => mod
	
	(* FIXME: Redeclaration *)

  rule  lookup_modification2(xs,n) => mod
	---------------------------------
	lookup_modification2(x::xs,n) => mod

end

relation lookup_modification: (Mod,Absyn.Ident) => Mod =

  axiom lookup_modification(NOMOD,_) => NOMOD

  rule  lookup_modification2(subs,n) => mod
	---------------------------------
	lookup_modification(MOD(_,subs,_),n) => mod

end

(**********************************************************************
 *
 *   Merging
 *
 * The merge relation merges to modifications to one. The first
 * argument is the "outer" modification that should take precedence over
 * the "inner" modifications. FIXME: correct?
 *
 **********************************************************************)

relation merge_subs2 : (SubMod list, SubMod) => (SubMod list, SubMod) =

  axiom merge_subs2([],m) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2 & print "   merge clash in " & print n1 & print "\n"
	-------
	merge_subs2((s1 as SUBMOD(n1,m1))::ss, SUBMOD(n2,m2)) => (ss, s1)

  rule  merge_subs2(ss, s2) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2) => (s1::ss',s)

end

relation merge_subs : (SubMod list, SubMod list) => SubMod list =

  axiom merge_subs(s1,[]) => s1

  rule  merge_subs2(s1,s) => (s1',s') &
	merge_subs(s1',s2) => ss
	------------------------
	merge_subs(s1,s::s2) => s'::ss

end

relation merge_ass : (Exp.Exp option, Exp.Exp option) => Exp.Exp option =

	(* Outer assignments take precedence *)

  axiom merge_ass(e as SOME(_), _) => e

  axiom merge_ass(NONE,e) => e

end

relation merge : (Mod, Mod) => Mod =

  axiom merge(NOMOD,NOMOD) => NOMOD

  axiom merge(NOMOD,m) => m

  axiom merge(m,NOMOD) => m

  rule  print " ignoring inner modification\n"
	--------------------------------------
	merge(m as REDECL(_,_),_) => m

  rule  print "# can't merge modification with a redeclaration\n" & fail
	----------------------------------------------------------------
	merge(_,REDECL(_,_)) => NOMOD

  rule  print "# trying to modify final element\n" & fail
	-------------------------------------------------
	merge(_,m as MOD(true,_,_)) => m

  rule  merge_subs(subs1, subs2) => subs &
	merge_ass(ass1, ass2) => ass
	----------------------------
	merge(MOD(final,subs1,ass1), MOD(false,subs2,ass2))
	  => MOD(final,subs,ass)

  rule	print "# incomplete handling of modification merging\n"
	-----------------------------------------------------
	merge(outer,inner) => outer

end

(**********************************************************************)

relation mod_assignment : Mod => Exp.Exp option =

  axiom mod_assignment NOMOD => NONE

  axiom mod_assignment REDECL(_,_) => NONE

  axiom mod_assignment MOD(_,_,e) => e

end
