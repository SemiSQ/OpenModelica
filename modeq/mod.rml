(**
 ** file: mod.rml
 **
 ** Modifications are simply the same kind of modifications used in
 ** the `Absyn' module.
 **
 **)

module Mod:

  (* with "exp.rml" *)
  with "absyn.rml"
  (* with "env.rml" *)
  (* with "lform.rml" *)
  with "dae.rml"
  with "prefix.rml"
  with "explode.rml"

  type Ident = string


  val empty_mod : SCode.Mod

  relation lookup_modification: (SCode.Mod,Absyn.Ident) => SCode.Mod
  relation merge : (SCode.Mod, SCode.Mod) => SCode.Mod
  relation mod_equation : SCode.Mod => Absyn.Exp option

(*
  relation modify_class: (Env.Env, Absyn.Path, SCode.Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_modify_class : (Env.Env, SCode.Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation maybe_modify_class: (Env.Env, Absyn.Path, SCode.Mod,
				Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_maybe_modify_class : (Env.Env, SCode.Mod,
				        Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
*)

end

(**)

with "dump.rml"

val empty_mod = SCode.MOD(false,[],NONE)

(**)

relation dump_final : bool => () =

  axiom dump_final false

  rule print " final "
       --------------
       dump_final true

end

relation dump_subs : SCode.SubMod list => () =

  axiom dump_subs []

  rule  print n & dump mod
	------------------
	dump_subs [SCode.SUBMOD(n,mod)]

  rule  print n & dump mod & print ", " &
	dump_subs subs
	--------------
	dump_subs SCode.SUBMOD(n,mod)::subs

end

relation dump_subs1 : SCode.SubMod list => () =

  axiom dump_subs1 [] => ()

  rule	print "(" &
	dump_subs l &
	print ")"
	-----------
	dump_subs1 l

end

relation dump_ass : Absyn.Exp option => () =

  axiom dump_ass NONE

  rule  print " = " & Dump.dump_exp e
	-----------------------------
	dump_ass SOME(e)

end
	
(**)

relation expand_nomod : SCode.Mod => SCode.Mod =

  axiom expand_nomod(m as SCode.MOD(_,_,_)) => m

  axiom expand_nomod SCode.NOMOD => empty_mod

end

(**
 ** - Lookup
 **)

(** relation: lookup_modification *)

relation lookup_modification: (SCode.Mod,Absyn.Ident) => SCode.Mod =

  axiom lookup_modification(SCode.NOMOD,_) => SCode.NOMOD

	(* FIXME: Is this correct? *)
  axiom	lookup_modification(SCode.REDECL(_,_),_) => SCode.NOMOD

  rule  lookup_modification2(subs,n) => mod
	---------------------------------
	lookup_modification(SCode.MOD(_,subs,_),n) => mod

  rule	print "# Mod.lookup_modification(" &
	dump mod & print "," & print i &
	print ") failed\n"
	--------------------
	lookup_modification(mod,i) => fail

end	

relation lookup_modification2 : (SCode.SubMod list,Absyn.Ident) => Mod =

  axiom lookup_modification2([],_) => SCode.NOMOD

  rule  n = m
	-----
	lookup_modification2(SCode.SUBMOD(n,mod)::_,m) => mod
	
	(* FIXME: Redeclaration *)

  rule  lookup_modification2(xs,n) => mod
	---------------------------------
	lookup_modification2(x::xs,n) => mod

end

(**
 **
 ** - Merging
 **
 ** The merge relation merges to modifications to one. The first
 ** argument is the "outer" modification that should take precedence over
 ** the "inner" modifications. FIXME: correct?
 **
 **)
(** relation: merge
 **)

relation merge : (SCode.Mod, SCode.Mod) => SCode.Mod =

  axiom merge(SCode.NOMOD,SCode.NOMOD) => SCode.NOMOD

  axiom merge(SCode.NOMOD,m) => m

  axiom merge(m,SCode.NOMOD) => m

  rule  print " ignoring inner modification\n"
	--------------------------------------
	merge(m as SCode.REDECL(_,_),_) => m

  rule  print "# can't merge modification with a redeclaration\n"
	---------------------------------------------------------
	merge(_,SCode.REDECL(_,_)) => fail

  rule  print "# trying to modify final element\n"
	------------------------------------------
	merge(_,m as SCode.MOD(true,_,_)) => fail

  rule  merge_subs(subs1, subs2) => subs &
	merge_ass(ass1, ass2) => ass
	----------------------------
	merge(SCode.MOD(final,subs1,ass1), SCode.MOD(false,subs2,ass2))
	  => SCode.MOD(final,subs,ass)

  rule	print "# incomplete handling of modification merging\n"
	-----------------------------------------------------
	merge(outer,inner) => outer

end

(** relation: merge_subs
 **)

relation merge_subs : (SCode.SubMod list, SCode.SubMod list)
	  => SCode.SubMod list =

  axiom merge_subs(s1,[]) => s1

  rule  merge_subs2(s1,s) => (s1',s') &
	merge_subs(s1',s2) => ss
	------------------------
	merge_subs(s1,s::s2) => s'::ss

end

(** relation: merge_subs2
 **)

relation merge_subs2 : (SCode.SubMod list, SCode.SubMod)
	  => (SCode.SubMod list, SCode.SubMod) =

  axiom merge_subs2([],m) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2 & print "   merge clash in " & print n1 & print "\n"
	-------
	merge_subs2((s1 as SCode.SUBMOD(n1,m1))::ss,
		    SCode.SUBMOD(n2,m2)) => (ss, s1)

  rule  merge_subs2(ss, s2) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2) => (s1::ss',s)

end

(** relation: merge_ass
 **)

relation merge_ass : (Absyn.Exp option, Absyn.Exp option) => Absyn.Exp option =

	(* Outer assignments take precedence *)

  axiom merge_ass(e as SOME(_), _) => e

  axiom merge_ass(NONE,e) => e

end

(** relation: mod_equation
 **)

relation mod_equation : SCode.Mod => Absyn.Exp option =

  axiom mod_equation SCode.NOMOD => NONE

  axiom mod_equation SCode.REDECL(_,_) => NONE

  axiom mod_equation SCode.MOD(_,_,e) => e

end
