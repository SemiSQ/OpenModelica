(**
 ** file:        mod.rml
 ** description: Modification handling
 **
 ** RCS: $Id$
 **
 ** Modifications are simply the same kind of modifications used in
 ** the `Absyn' module.
 **
 **)

module Mod:

  with "absyn.rml"
  with "dae.rml"
  with "env.rml"
  with "exp.rml"
  with "prefix.rml"
  with "explode.rml"
  with "types.rml"
  with "staticexp.rml"
  with "values.rml"

  type Ident = string

  (** - Modification datatype *)
  type EqMod = (Exp.Exp * Static.Properties)
  datatype SubMod = NAMEMOD of Ident * Mod
		  | IDXMOD of int list * Mod
  and Mod = MOD of bool * (SubMod list) * EqMod option
  	  | REDECL of bool * Absyn.ElementSpec
	  | NOMOD
  (** This type is very similar to `SCode.Mod'.  The main difference is
   ** that it uses `Exp.Exp' for the expressions.  Expressions stored
   ** here are prefixed and typechecked.
   **)

  relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod) => Mod

  relation lookup_comp_modification: (Mod, Absyn.Ident) => Mod
  relation lookup_idx_modification: (Mod, int) => Mod
  relation lookup_modification_p: (Mod,Absyn.Path) => Mod
  relation merge : (Mod, Mod) => Mod
  relation mod_equation : Mod => EqMod option

  relation print_mod : Mod => ()

(*
  relation modify_class: (Env.Env, Absyn.Path, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_modify_class : (Env.Env, Mod, Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation maybe_modify_class: (Env.Env, Absyn.Path, Mod,
				Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
  relation simple_maybe_modify_class : (Env.Env, Mod,
				        Prefix.Prefix, Absyn.Class)
	    => (Lform.Class, DAE.DAEcomp list)
*)

end

(** relation: elab_mod
 **
 ** This relation elaborates on the expressions in a modification and
 ** turns them into global expressions.  This is done because the
 ** expressions in modifications must be elaborated on in the context
 ** they are provided in, and not the context they are used in.
 **)
 
relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod) => Mod =

  axiom	elab_mod (_,_,SCode.NOMOD) => NOMOD

  rule	elab_submods (env,pre,subs) => subs' &
	let res = MOD(final,subs',NONE) &
	print "   elab_mod " & SCode.print_mod m &
	print " => " & print_mod res & print "\n"
	------------------------------------
	elab_mod (env,pre,m as SCode.MOD(final,subs,NONE)) => res
	
  rule	elab_submods (env,pre,subs) => subs' &
	Static.elab_exp(env,e) => (e',prop) &
	Prefix.prefix_exp(env,e',pre) => e'' &
	let res = MOD(final,subs',SOME((e'',prop))) &
	print "   elab_mod " & SCode.print_mod m &
	print " => " & print_mod res & print "\n"
	------------------------------------
	elab_mod (env,pre,m as SCode.MOD(final,subs,SOME(e))) => res

end

(**)

relation elab_submods : (Env.Env, Prefix.Prefix, SCode.SubMod list)
	  => SubMod list =

  axiom	elab_submods (_,_,[]) => []

  rule	elab_submod (env,pre,x) => x' &
	elab_submods (env,pre,xs) => xs' &
	insert_submods (x',xs') => res
	-----------------------------
	elab_submods (env,pre,x::xs) => res

end

(**)

relation elab_submod : (Env.Env, Prefix.Prefix, SCode.SubMod) => SubMod  list =

  rule	elab_mod (env,pre,m) => m'
	--------------------------
	elab_submod (env,pre,SCode.NAMEMOD(i,m)) => [NAMEMOD(i,m')]

  rule	elab_subscripts (env,pre,ss) => ss' &
	elab_mod (env,pre,m) => m' &
	make_idxmods (ss',m') => smods
	---------------------------
	elab_submod (env,pre,SCode.IDXMOD(ss,m)) => smods

end

(** relation: make_idxmods
 **
 ** From a list of list of integers, this relation creates a list of
 ** sub-modifications of the `IDXMOD' variety.
 **)

relation make_idxmods : (int list list, Mod) => SubMod list =

  axiom	make_idxmods ([],_) => []

  rule	make_idxmods (xs,m) => subs
	---------------------------
	make_idxmods (x::xs,m) => IDXMOD(x,m)::subs

end

(**)

relation elab_subscripts : (Env.Env, Prefix.Prefix, SCode.Subscript list)
	=> int list list =

  axiom	elab_subscripts (_,_,[]) => [[]]
	
  rule	print "# Use of colon subscript subscripts is not allowed" &
	print " in modifications\n"
	--------------------------------
	elab_subscripts (env,pre,Absyn.NOSUB::xs) => fail
	
  rule	Static.elab_exp(env,e) => (e',prop) &
	eval_subscript (env,e',prop) => is &
	elab_subscripts (env,pre,xs) => xs' &
	expand_list (is,xs') => l
	-----------------------------------
	elab_subscripts (env,pre,Absyn.SUBSCRIPT(e)::xs) => l
	
end

(** relation: expand_int_list
 **
 ** This utility relation takes a list of integer values and a list of
 ** list of integers, and for each integer in the first and each list
 ** in the second list creates a
 ** list with that integer as head and the second list as tail. All
 ** resulting lists are collected in a list and returned.
 **)

relation expand_list : (Values.Value list, int list list) => int list list =

  axiom	expand_list([],_) => []

  axiom	expand_list(_,[]) => []

  rule	expand_list(xx,ys) => l1 &
	expand_list(xs,yy) => l2 &
	list_append(l1,l2) => l
	-----------------------
	expand_list(xx as (Values.INTEGER(x)::xs),yy as (y::ys))
		    => ((x::y)::l)

end

(**)

relation eval_subscript : (Env.Env, Exp.Exp, Static.Properties)
	  => Values.Value list =

  rule	Static.ceval (env,e) => i
	--------------------------------------------
	eval_subscript (env,e,Static.PROP(Types.T_INTEGER,true)) => [i]

	(* FIXME *)
  rule	Static.ceval (env,e) => Values.ARRAY(xs) &
	print "- Ignoring all but the first index in modification\n"
	--------------------------------------------
	eval_subscript (env,e,
			Static.PROP(Types.T_ARRAY(Types.DIM(SOME(sz),
							       Types.NODIM),
						     Types.T_INTEGER),true))
	  => xs

  rule	not t = Types.T_INTEGER &
	print "# Non-integer subscript " & Exp.print_exp e &
	print " in modification\n"
	--------------------------
	eval_subscript (_,e,Static.PROP(t,_)) => fail

  rule	print "# Non-constant subscript " & Exp.print_exp e &
	print " in modification\n"
	--------------------------
	eval_subscript (_,e,Static.PROP(_,false)) => fail

  rule	print "- Mod.eval_subscript failed\n"
	-------------------------------------
	eval_subscript(_,_,_) => fail

end

(** relation: insert_submods
 **
 ** This relation repeatedly calls `insert_submod' to incrementally
 ** insert several sub-modifications.
 **)

relation insert_submods : (SubMod list, SubMod list) => SubMod list =

  axiom	insert_submods ([],_) => []

  rule	insert_submod (x,y) => x' &
	insert_submods (xs,y) => xs' &
	list_append(x', xs') => l
	-------------------------
	insert_submods (x::xs,y) => l

end

(** relation: insert_submod
 **
 ** This relation inserts a `SubMod' into a list of unique `SubMod's,
 ** while keeping the uniqueness, merging the submod if necessary.
 **)

relation insert_submod : (SubMod, SubMod list) => SubMod list =

  axiom	insert_submod (sub,[]) => [sub]

  rule	n1 = n2 &
	merge (m1,m2) => m
	----------------------
	insert_submod (NAMEMOD(n1,m1),NAMEMOD(n2,m2)::tail)
	  => (NAMEMOD(n1,m)::tail)

  rule	i1 = i2 &
	merge (m1,m2) => m
	----------------------
	insert_submod (IDXMOD(i1,m1),IDXMOD(i2,m2)::tail)
	  => (IDXMOD(i1,m)::tail)

  axiom	insert_submod (sub1, sub2) => sub1::sub2

end

(**
 ** - Lookup
 **)

(** relation: lookup_modification_p *)

relation lookup_modification_p: (Mod,Absyn.Path) => Mod =

  rule	lookup_comp_modification (m,n) => mod
	--------------------------------
	lookup_modification_p (m,Absyn.IDENT(n)) => mod

  rule	lookup_comp_modification (m,n) => mod &
	lookup_modification_p (mod,p) => mod'
	-------------------------------------
	lookup_modification_p (m,Absyn.QUALIFIED(n,p)) => mod'

end

(** relation: lookup_comp_modification
 **
 ** This relation is used to look up an identifier in a modification.
 **)

relation lookup_comp_modification: (Mod, Absyn.Ident) => Mod =

  axiom lookup_comp_modification(NOMOD,_) => NOMOD

	(* FIXME: Is this correct? *)
  axiom	lookup_comp_modification(REDECL(_,_),_) => NOMOD

  rule  lookup_comp_modification2(subs,n) => mod
	-----------------------------------
	lookup_comp_modification(MOD(_,subs,_),n) => mod
	
  rule	print "# Mod.lookup_comp_modification(" &
	print_mod mod & print "," & print i &
	print ") failed\n"
	--------------------
	lookup_comp_modification(mod,i) => fail

end	

(**)

relation lookup_comp_modification2 : (SubMod list,Absyn.Ident) => Mod =

  axiom lookup_comp_modification2([],_) => NOMOD

  rule  n = m
	--------------------------------------
	lookup_comp_modification2(NAMEMOD(n,mod)::_,m) => mod
	
	(* FIXME: Redeclaration *)

  rule  lookup_comp_modification2(xs,n) => mod
	---------------------------------
	lookup_comp_modification2(x::xs,n) => mod

  rule	print "- lookup_comp_modification2 failed\n"
	---------------------------------------
	lookup_comp_modification2 (_,_) => fail

end

(** relation: lookup_idx_modification
 **
 **)

relation lookup_idx_modification: (Mod, int) => Mod =

  axiom lookup_idx_modification(NOMOD,_) => NOMOD

	(* FIXME: Is this correct? *)
  axiom	lookup_idx_modification(REDECL(_,_),_) => NOMOD

  rule  lookup_idx_modification2(subs,NONE,idx) => (mod',subs') &
	merge (MOD(f,subs',NONE),mod') => mod'' &

	index_eqmod (eq,[idx]) => eq' & (* FIXME *)
	merge (mod'',MOD(false,[],eq')) => mod''' (* FIXME: order *)
	-----------------------------------
	lookup_idx_modification(MOD(f,subs,eq),idx) => mod'''
	
  rule	print "# Mod.lookup_idx_modification(" &
	print_mod mod & print "," & int_string idx => s & print s &
	print ") failed\n"
	--------------------
	lookup_idx_modification(mod,idx) => fail

end	

(** relation: lookup_idx_modification2
 **
 ** FIXME: This relation depends heavily on the matrix/array typing
 **)

relation lookup_idx_modification2 : (SubMod list, EqMod option, int)
	  => (Mod, SubMod list) =

  axiom lookup_idx_modification2([],_,_) => (NOMOD, [])

	(* FIXME: Redeclaration *)

  rule  x = y &
	lookup_idx_modification2(subs,eq,y) => (NOMOD,subs')
	--------------------------------------
	lookup_idx_modification2(IDXMOD([x],mod)::subs,eq,y)
	  => (mod,subs')
	
  rule  x = y &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(IDXMOD(x::xs,mod)::subs,eq,y)
	  => (mod',IDXMOD(xs,mod)::subs')

  rule  not x = y &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(IDXMOD(x::xs,mod)::subs,eq,y)
	  => (mod',subs')

  rule  lookup_idx_modification2(xs,eq,idx) => (mod,xs')
	---------------------------------
	lookup_idx_modification2(x::xs,eq,idx) => (mod,x::xs')

  rule	print "- lookup_idx_modification2 failed\n"
	---------------------------------------
	lookup_idx_modification2 (_,_,_) => fail

end

(** relation: index_eqmod
 **
 ** If there is an equation modification, this relation can subscript
 ** it using the provided indexing expressions.  This is used when a
 ** modification equates an array variable with an array expression.
 ** This expression will be expanded to produce one equation
 ** expression per array component.
 **)

relation index_eqmod : (EqMod option, int list) => EqMod option =

  axiom	index_eqmod (NONE,_) => NONE

  axiom	index_eqmod (e,[]) => e

  rule	Types.unlift_array t => t' &
	Exp.simplify Exp.ASUB(e,x) => exp &
	index_eqmod (SOME((exp,Static.PROP(t',c))),xs) => e
	------------------------------------------
	index_eqmod (SOME((e,Static.PROP(t,c))),x::xs) => e

end

(**
 **
 ** - Merging
 **
 ** The merge relation merges to modifications to one. The first
 ** argument is the "outer" modification that should take precedence over
 ** the "inner" modifications.
 **
 **)

(** relation: merge
 **)

relation merge : (Mod, Mod) => Mod =

  axiom merge(NOMOD,NOMOD) => NOMOD

  axiom merge(NOMOD,m) => m

  axiom merge(m,NOMOD) => m

  rule  print " ignoring inner modification\n"
	--------------------------------------
	merge(m as REDECL(_,_),_) => m

  rule  print "# can't merge modification with a redeclaration\n"
	---------------------------------------------------------
	merge(_,REDECL(_,_)) => fail

  rule  print "# trying to modify final element\n"
	------------------------------------------
	merge(_,m as MOD(true,_,_)) => fail

  rule  merge_subs(subs1, subs2) => subs &
	merge_eq(ass1, ass2) => ass
	----------------------------
	merge(MOD(final,subs1,ass1), MOD(false,subs2,ass2))
	  => MOD(final,subs,ass)

  rule	print "# incomplete handling of modification merging\n"
	-----------------------------------------------------
	merge(outer,inner) => outer

end

(** relation: merge_subs
 **)

relation merge_subs : (SubMod list, SubMod list)
	  => SubMod list =

  axiom merge_subs(s1,[]) => s1

  rule  merge_subs2(s1,s) => (s1',s') &
	merge_subs(s1',s2) => ss
	------------------------
	merge_subs(s1,s::s2) => s'::ss

end

(** relation: merge_subs2
 **)

relation merge_subs2 : (SubMod list, SubMod)
	  => (SubMod list, SubMod) =

  axiom merge_subs2([],m) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2 & print "   merge clash in " & print n1 & print "\n"
	------------------------------------------------------------
	merge_subs2((s1 as NAMEMOD(n1,m1))::ss,
		    NAMEMOD(n2,m2)) => (ss, s1)

  rule  merge_subs2(ss, s2) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2) => (s1::ss',s)

end

(** relation: merge_eq
 **)

relation merge_eq : (EqMod option, EqMod option) => EqMod option =

	(* Outer assignments take precedence *)

  axiom merge_eq(e as SOME((_,_)), _) => e

  axiom merge_eq(NONE,e) => e

end

(** relation: mod_equation
 **)

relation mod_equation : Mod => EqMod option =

  axiom mod_equation NOMOD => NONE
  axiom mod_equation REDECL(_,_) => NONE
  axiom mod_equation MOD(_,_,e) => e

end

(** - Printing *)
(*!ignorecode*)

(** relation: print_mod
 **
 ** This relation prints a modification. It uses a few other relation
 ** to do its stuff.
 **
 ** The relations are excluded from the report for brevity.
 **)

relation print_mod : Mod => () =

  axiom	print_mod(NOMOD)

  rule  print "(redeclared)"
	------------------------------
	print_mod REDECL(_,_)
	
  rule	print_final final &
	print_subs1 subs &
	print_eqmod eq
	--------------
	print_mod MOD(final, subs, eq)

end

(**)

relation print_final : bool => () =

  axiom print_final false

  rule print " final "
       --------------
       print_final true

end

(**)

relation print_subs1 : SubMod list => () =

  axiom print_subs1 [] => ()

  rule	print "(" & print_sub x & print_subs2 xs & print ")"
	------------------------------------
	print_subs1 x::xs

end

(**)

relation print_subs2 : SubMod list => () =

  axiom print_subs2 []

  rule  print "," & print_sub sub & print_subs2 subs
	----------------------------------------------
	print_subs2 sub::subs

end

(**)

relation print_sub : SubMod => () =

  rule  print n & print_mod mod
	------------------
	print_sub NAMEMOD(n,mod)

  rule  print_subscripts ss & print_mod mod
	------------------
	print_sub IDXMOD(ss,mod)

end

(**)

relation print_subscripts : int list => () =

  rule	print "[]"
  	---------------
	print_subscripts []

  rule	print "[" &
	int_string x => s & print s &
	print_subscripts2 xs &
	print "]"
	-----------------------------------------------------
	print_subscripts x::xs

end

(**)

relation print_subscripts2 : int list => () =

  axiom	print_subscripts2 []

  rule	print "," & int_string x => s & print s &
	print_subscripts2 xs
	--------------------
	print_subscripts2 x::xs

end

(**)

relation print_eqmod : EqMod option => () =

  axiom print_eqmod NONE

  rule  print " = " & Exp.print_exp e
	-----------------------------
	print_eqmod SOME((e,prop))

end
	
