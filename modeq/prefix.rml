(** file: prefix.rml
 **
 ** When instantiating an expression, there is a prefix that has to be
 ** added to each variable name to be able to use it in the flattened
 ** equation set. These relations take care of adding the prefixes.
 **)

module Prefix:

  with "absyn.rml"
  
  type Prefix = (string * Absyn.Subscript list) list

  relation prefix_add : (Absyn.Ident, Absyn.Subscript list, Prefix) => Prefix
  relation prefix_cref : (Prefix, Absyn.ComponentRef) => Absyn.ComponentRef
  relation prefix_exp  : (Absyn.Exp,Prefix) => Absyn.Exp
  relation prefix_path : (Absyn.Path,Prefix) => Absyn.Path

end

(** relation: prefix_add
 **
 ** This relation is used to extend a prefix with another level.  If
 ** the prefix `a.b[10].c' is extended with `d' and an empty subscript
 ** list, the resulting prefix is `a.b[10].c.d'.  Remember that
 ** prefixes components are stored in the opposite order from the
 ** normal order used when displaying them.
 **)

relation prefix_add : (Absyn.Ident, Absyn.Subscript list, Prefix) => Prefix =

  axiom prefix_add(i,s,p) => (((i,s)::p))

end

(** relation: prefix_path
 **
 ** Prefix a `Path' variable by adding the supplied prefix to it and
 ** returning a new `Path'.
 **)

relation prefix_path: (Absyn.Path,Prefix) => Absyn.Path =

  axiom	prefix_path(p,[]) => p
  
  rule	prefix_path(Absyn.QUALIFIED(s,p),ss) => p'
	---------------------------
	prefix_path(p,(s,_)::ss) => p'

end

(** relation: prefix_path
 **
 ** Prefix a `ComponentRef' variable by adding the supplied prefix to
 ** it and returning a new `ComponentRef'.
 **)

relation prefix_cref : (Prefix, Absyn.ComponentRef) => Absyn.ComponentRef =

  axiom	prefix_cref([], cref) => cref

  rule	prefix_cref(xs, Absyn.CREF_QUAL(i,s,cref)) => cref'
	---------------------------------
	prefix_cref((i,s)::xs, cref) => cref'

end

(** relation: prefix_exp
 **
 ** Add the supplied prefix to all component references in an
 ** expression.
 **)

relation prefix_exp: (Absyn.Exp,Prefix) => Absyn.Exp =

  rule	list_reverse(p) => p' &
	prefix_exp2(e,p') => e'
	-----------------------
	prefix_exp(e,p) => e'

  rule	print "- prefix_exp fallthru\n"
	-------------------------------
	prefix_exp (_,_) => fail

end

(**)

relation prefix_exp2: (Absyn.Exp,Prefix) => Absyn.Exp =

  axiom	prefix_exp2(e as Absyn.INTEGER(_),_) => e
  axiom	prefix_exp2(e as Absyn.REAL(_),_) => e
  axiom	prefix_exp2(e as Absyn.STRING(_),_) => e
  axiom	prefix_exp2(e as Absyn.BOOL(_),_) => e

  rule	prefix_cref(pre,p) => p'
	--------------------------
	prefix_exp2(Absyn.CREF(p),pre) => Absyn.CREF(p')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2'
	-----------------------
	prefix_exp2(Absyn.BINARY(e1,o,e2),p) => Absyn.BINARY(e1',o,e2')

  rule	prefix_exp2(e1,p) => e1'
	-----------------------
	prefix_exp2(Absyn.UNARY(o,e1),p) => Absyn.UNARY(o,e1')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2'
	-----------------------
	prefix_exp2(Absyn.LBINARY(e1,o,e2),p) => Absyn.LBINARY(e1',o,e2')

  rule	prefix_exp2(e1,p) => e1'
	-----------------------
	prefix_exp2(Absyn.LUNARY(o,e1),p) => Absyn.LUNARY(o,e1')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2'
	-----------------------
	prefix_exp2(Absyn.RELATION(e1,o,e2),p) => Absyn.RELATION(e1',o,e2')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2' &
	prefix_exp2(e3,p) => e3'
	-----------------------
	prefix_exp2(Absyn.IFEXP(e1,e2,e3),p) => Absyn.IFEXP(e1',e2',e3')

  rule	prefix_explist(es,p) => es'
	-----------------------
	prefix_exp2(Absyn.CALL(f,es),p) => Absyn.CALL(f,es')

  rule	prefix_exp2 (start, p) => start' &
	prefix_exp2 (stop, p) => stop'
	------------------------------
	prefix_exp2 (Absyn.RANGE(start,NONE,stop), p)
	  => Absyn.RANGE(start',NONE,stop')

  rule	prefix_exp2 (start, p) => start' &
	prefix_exp2 (step, p) => step' &
	prefix_exp2 (stop, p) => stop'
	------------------------------
	prefix_exp2 (Absyn.RANGE(start,SOME(step),stop), p)
	  => Absyn.RANGE(start',SOME(step'),stop')

end

(**)

relation prefix_explist: (Absyn.Exp list,Prefix) => Absyn.Exp list =

  axiom	prefix_explist([],_) => []

  rule	prefix_exp2(e,p) => e' &
	prefix_explist(es,p) => es'
	---------------------------
	prefix_explist(e::es,p) => (e'::es')

end	
