(**
 ** file:	 prefix.rml
 ** description: Prefix management
 **
 ** RCS: $Id$
 **
 ** When instantiating an expression, there is a prefix that has to be
 ** added to each variable name to be able to use it in the flattened
 ** equation set. These relations take care of adding the prefixes.
 **)

module Prefix:

  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "lookup.rml"
  
  datatype Prefix = NOPRE
		  | PRE of string * int list * Prefix

  relation prefix_add : (Exp.Ident, int list, Prefix) => Prefix
  relation prefix_cref : (Prefix, Exp.ComponentRef) => Exp.ComponentRef
  relation prefix_exp  : (Env.Env,Exp.Exp,Prefix) => Exp.Exp
  relation prefix_path : (Absyn.Path,Prefix) => Absyn.Path

end

(** relation: prefix_add
 **
 ** This relation is used to extend a prefix with another level.  If
 ** the prefix `a.b[10].c' is extended with `d' and an empty subscript
 ** list, the resulting prefix is `a.b[10].c.d'.  Remember that
 ** prefixes components are stored in the opposite order from the
 ** normal order used when displaying them.
 **)

relation prefix_add : (Exp.Ident, int list, Prefix) => Prefix =

  axiom prefix_add(i,s,p) => PRE(i,s,p)

end

(** relation: prefix_path
 **
 ** Prefix a `Path' variable by adding the supplied prefix to it and
 ** returning a new `Path'.
 **)

relation prefix_path: (Absyn.Path,Prefix) => Absyn.Path =

  axiom	prefix_path(p,NOPRE) => p
  
  rule	prefix_path(Absyn.QUALIFIED(s,p),ss) => p'
	---------------------------
	prefix_path(p,PRE(s,_,ss)) => p'

end

(** relation: prefix_path
 **
 ** Prefix a `ComponentRef' variable by adding the supplied prefix to
 ** it and returning a new `ComponentRef'.
 **)

relation prefix_cref : (Prefix, Exp.ComponentRef) => Exp.ComponentRef =

  axiom	prefix_cref (NOPRE, cref) => cref

  rule	subscript_list s => s' &
	prefix_cref(xs, Exp.CREF_QUAL(i,s',cref)) => cref'
	---------------------------------
	prefix_cref (PRE(i,s,xs), cref) => cref'

end

(** relation: subscript_list
 **
 ** This relations describes the relation between a list of integers
 ** and a list of `Exp.Subscript' where each integer is converted to
 ** an integer constant expression.
 **)

relation subscript_list : int list => Exp.Subscript list =

  axiom	subscript_list [] => []

  rule	subscript_list xs => xs'
	------------------------
	subscript_list x::xs => Exp.SUB1(Exp.ICONST(x))::xs'

end

(** relation: prefix_exp
 **
 ** Add the supplied prefix to all component references in an
 ** expression.
 **)

relation prefix_exp: (Env.Env,Exp.Exp,Prefix) => Exp.Exp =

  rule	(* list_reverse(p) => p' & *)
	prefix_exp2(env,e,p(*'*)) => e'
	-----------------------
	prefix_exp(env,e,p) => e'

  rule	print "- prefix_exp failed\n"
	-------------------------------
	prefix_exp (_,_,_) => fail

end

(**)

relation prefix_exp2: (Env.Env,Exp.Exp,Prefix) => Exp.Exp =

  axiom	prefix_exp2(_,e as Exp.ICONST(_),_) => e
  axiom	prefix_exp2(_,e as Exp.RCONST(_),_) => e
  axiom	prefix_exp2(_,e as Exp.SCONST(_),_) => e
  axiom	prefix_exp2(_,e as Exp.BCONST(_),_) => e

  rule	Lookup.lookup_var_local(env,p) => (_,_,_) &
	prefix_cref(pre,p) => p'
	--------------------------
	prefix_exp2(env,Exp.CREF(p),pre) => Exp.CREF(p')

  rule	not Lookup.lookup_var_local(env,p) => (_,_,_)
	--------------------------
	prefix_exp2(env,e as Exp.CREF(p),pre) => e

  rule	prefix_exp2(env,e1,p) => e1' &
	prefix_exp2(env,e2,p) => e2'
	-----------------------
	prefix_exp2(env,Exp.BINARY(e1,o,e2),p) => Exp.BINARY(e1',o,e2')

  rule	prefix_exp2(env,e1,p) => e1'
	-----------------------
	prefix_exp2(env,Exp.UNARY(o,e1),p) => Exp.UNARY(o,e1')

  rule	prefix_exp2(env,e1,p) => e1' &
	prefix_exp2(env,e2,p) => e2'
	-----------------------
	prefix_exp2(env,Exp.LBINARY(e1,o,e2),p) => Exp.LBINARY(e1',o,e2')

  rule	prefix_exp2(env,e1,p) => e1'
	-----------------------
	prefix_exp2(env,Exp.LUNARY(o,e1),p) => Exp.LUNARY(o,e1')

  rule	prefix_exp2(env,e1,p) => e1' &
	prefix_exp2(env,e2,p) => e2'
	-----------------------
	prefix_exp2(env,Exp.RELATION(e1,o,e2),p) => Exp.RELATION(e1',o,e2')

  rule	prefix_exp2(env,e1,p) => e1' &
	prefix_exp2(env,e2,p) => e2' &
	prefix_exp2(env,e3,p) => e3'
	-----------------------
	prefix_exp2(env,Exp.IFEXP(e1,e2,e3),p) => Exp.IFEXP(e1',e2',e3')

  rule	prefix_explist(env,es,p) => es'
	-----------------------
	prefix_exp2(env,Exp.CALL(f,es),p) => Exp.CALL(f,es')

  axiom	prefix_exp2(env,Exp.ARRAY([]),p) => Exp.ARRAY([])

  rule	prefix_exp2(env,e,p) => e' &
	prefix_exp2(env,Exp.ARRAY(es),p) => Exp.ARRAY(es')
	----------------------------
	prefix_exp2(env,Exp.ARRAY(e::es),p) => Exp.ARRAY(e'::es')

  rule	prefix_exp2(env,start, p) => start' &
	prefix_exp2(env,stop, p) => stop'
	------------------------------
	prefix_exp2(env,Exp.RANGE(start,NONE,stop), p)
	  => Exp.RANGE(start',NONE,stop')

  rule	prefix_exp2(env,start, p) => start' &
	prefix_exp2(env,step, p) => step' &
	prefix_exp2(env,stop, p) => stop'
	------------------------------
	prefix_exp2(env,Exp.RANGE(start,SOME(step),stop), p)
	  => Exp.RANGE(start',SOME(step'),stop')

  rule	prefix_exp2(env,e,p) => e'
	-----------------------
	prefix_exp2(env,Exp.CAST_TO_REAL(e), p) => Exp.CAST_TO_REAL(e')

  rule	print "- prefix_exp2 failed\n" &
	print "  expression: " & Exp.print_exp e & print "\n"
	-----------------------------------------------------
	prefix_exp2(_,e,_) => fail

end

(**)

relation prefix_explist: (Env.Env,Exp.Exp list,Prefix) => Exp.Exp list =

  axiom	prefix_explist(_,[],_) => []

  rule	prefix_exp2(env,e,p) => e' &
	prefix_explist(env,es,p) => es'
	---------------------------
	prefix_explist(env,e::es,p) => (e'::es')

end	
