(** file: prefix.rml
 **
 ** When instantiating an expression, there is a prefix that has to be
 ** added to each variable name to be able to use it in the flattened
 ** equation set. These relations take care of adding the prefixes.
 **)

module Prefix:

  with "absyn.rml"
  with "exp.rml"
  
  datatype Prefix = NOPRE
		  | PRE of string * Exp.Subscript list * Prefix

  relation prefix_add : (Exp.Ident, Exp.Subscript list, Prefix) => Prefix
  relation prefix_cref : (Prefix, Exp.ComponentRef) => Exp.ComponentRef
  relation prefix_exp  : (Exp.Exp,Prefix) => Exp.Exp
  relation prefix_path : (Absyn.Path,Prefix) => Absyn.Path

end

(** relation: prefix_add
 **
 ** This relation is used to extend a prefix with another level.  If
 ** the prefix `a.b[10].c' is extended with `d' and an empty subscript
 ** list, the resulting prefix is `a.b[10].c.d'.  Remember that
 ** prefixes components are stored in the opposite order from the
 ** normal order used when displaying them.
 **)

relation prefix_add : (Exp.Ident, Exp.Subscript list, Prefix) => Prefix =

  axiom prefix_add(i,s,p) => PRE(i,s,p)

end

(** relation: prefix_path
 **
 ** Prefix a `Path' variable by adding the supplied prefix to it and
 ** returning a new `Path'.
 **)

relation prefix_path: (Absyn.Path,Prefix) => Absyn.Path =

  axiom	prefix_path(p,NOPRE) => p
  
  rule	prefix_path(Absyn.QUALIFIED(s,p),ss) => p'
	---------------------------
	prefix_path(p,PRE(s,_,ss)) => p'

end

(** relation: prefix_path
 **
 ** Prefix a `ComponentRef' variable by adding the supplied prefix to
 ** it and returning a new `ComponentRef'.
 **)

relation prefix_cref : (Prefix, Exp.ComponentRef) => Exp.ComponentRef =

  axiom	prefix_cref (NOPRE, cref) => cref

  rule	prefix_cref(xs, Exp.CREF_QUAL(i,s,cref)) => cref'
	---------------------------------
	prefix_cref (PRE(i,s,xs), cref) => cref'

end

(** relation: prefix_exp
 **
 ** Add the supplied prefix to all component references in an
 ** expression.
 **)

relation prefix_exp: (Exp.Exp,Prefix) => Exp.Exp =

  rule	(* list_reverse(p) => p' & *)
	prefix_exp2(e,p(*'*)) => e'
	-----------------------
	prefix_exp(e,p) => e'

  rule	print "- prefix_exp fallthru\n"
	-------------------------------
	prefix_exp (_,_) => fail

end

(**)

relation prefix_exp2: (Exp.Exp,Prefix) => Exp.Exp =

  axiom	prefix_exp2(e as Exp.ICONST(_),_) => e
  axiom	prefix_exp2(e as Exp.RCONST(_),_) => e
  axiom	prefix_exp2(e as Exp.SCONST(_),_) => e
  axiom	prefix_exp2(e as Exp.BCONST(_),_) => e

  rule	prefix_cref(pre,p) => p'
	--------------------------
	prefix_exp2(Exp.CREF(p),pre) => Exp.CREF(p')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2'
	-----------------------
	prefix_exp2(Exp.BINARY(e1,o,e2),p) => Exp.BINARY(e1',o,e2')

  rule	prefix_exp2(e1,p) => e1'
	-----------------------
	prefix_exp2(Exp.UNARY(o,e1),p) => Exp.UNARY(o,e1')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2'
	-----------------------
	prefix_exp2(Exp.LBINARY(e1,o,e2),p) => Exp.LBINARY(e1',o,e2')

  rule	prefix_exp2(e1,p) => e1'
	-----------------------
	prefix_exp2(Exp.LUNARY(o,e1),p) => Exp.LUNARY(o,e1')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2'
	-----------------------
	prefix_exp2(Exp.RELATION(e1,o,e2),p) => Exp.RELATION(e1',o,e2')

  rule	prefix_exp2(e1,p) => e1' &
	prefix_exp2(e2,p) => e2' &
	prefix_exp2(e3,p) => e3'
	-----------------------
	prefix_exp2(Exp.IFEXP(e1,e2,e3),p) => Exp.IFEXP(e1',e2',e3')

  rule	prefix_explist(es,p) => es'
	-----------------------
	prefix_exp2(Exp.CALL(f,es),p) => Exp.CALL(f,es')

  rule	prefix_exp2 (start, p) => start' &
	prefix_exp2 (stop, p) => stop'
	------------------------------
	prefix_exp2 (Exp.RANGE(start,NONE,stop), p)
	  => Exp.RANGE(start',NONE,stop')

  rule	prefix_exp2 (start, p) => start' &
	prefix_exp2 (step, p) => step' &
	prefix_exp2 (stop, p) => stop'
	------------------------------
	prefix_exp2 (Exp.RANGE(start,SOME(step),stop), p)
	  => Exp.RANGE(start',SOME(step'),stop')

  rule	prefix_exp2 (e,p) => e'
	-----------------------
	prefix_exp2 (Exp.CAST_TO_REAL(e), p) => Exp.CAST_TO_REAL(e')

end

(**)

relation prefix_explist: (Exp.Exp list,Prefix) => Exp.Exp list =

  axiom	prefix_explist([],_) => []

  rule	prefix_exp2(e,p) => e' &
	prefix_explist(es,p) => es'
	---------------------------
	prefix_explist(e::es,p) => (e'::es')

end	
