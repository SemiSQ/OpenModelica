\documentclass[a4paper]{report}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{verbatim}
%\usepackage{boxedminipage}

\author{David Kågedal}
\title{Blahonga Blahonga}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\codebox}[1]{\fbox{\code{#1}}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\firstref}[1]{\textit{#1}}
\newcommand{\note}[1]{[\textsc{#1}]}

\newtheorem{Def}{Definition}[chapter]

\newcommand{\codefont}{\normalfont\ttfamily\fontsize{8}{9}\selectfont}

\makeatletter

% See the verbatim package for info about this
\def\boxedverbatim{\begingroup%
  \parskip=0pt\topsep=0pt\partopsep=0pt%
  \def\verbatim@processline{%
    \setbox1=\hbox{\the\verbatim@line}%
    \setbox0=\vbox{{\box0}{\box1}}%
    }%
  \def\verbatim@font{%
    \codefont
    \let\do\do@noligs
    \verbatim@nolig@list}
   \verbatim}
\def\endboxedverbatim{\endverbatim\framebox[\linewidth][l]{\box0}%
  \endgroup\vspace{2ex}}

\makeatother
  

\begin{document}

\titlepage
\maketitle{}
\endtitlepage

\begin{abstract}
\label{abs}

Formal descriptions of the syntax of programming languages has long
been accepted as a natural way of describing the syntacical form of
the language. Today everobody expects a BNF-like grammar for a new
language. But that is not the case when it comes to describing the
semantics of languages. Formalisms for the specifications of semantics
hase been avaiable for many years, but are not often used by others
than researchers.

One advantage of using a formal description of the semantics is of
course that the specification becomes more strict and unambiguous. But
there is also the possibility of using the semantic specification to
generate a language translator, or compiler, in an automatic way.

This paper describes a formal semantics for Modelica, an
equation-based language used for modeling. The notation used enables
it to be passed to a compiler generator that generates a Modelica
translator.

\end{abstract}

\tableofcontents

\chapter{Background}
\label{cha:bg}


\section{Introduction}
\label{sec:intro}


\section{Overview of formal semantics}
\label{sec:semoverview}


\section{RML}
\label{sec:rml}


\section{Modelica}
\label{sec:modelicabg}


\chapter{Goals, motivation and stuff}
\label{cha:goals}


\chapter{Development environment}
\label{cha:devenv}


\section{Compiling RML}
\label{sec:rmlc}


\section{Parser}
\label{sec:parser}

The Modelica parser was generated by the PCCTS\note{ref} compiler
generation system.  It generates a parser in C, which is linked with
the RML object files.

\section{The report}
\label{sec:report}

This report was writting using the \LaTeX{} text formatting system.

To produce the annotated semantics in chapter \ref{cha:formsem} a
small program was written to convert the RML source files with
comments to \LaTeX{} source with the comments converted to ordinary
text. This program is a quick'n'dirty Pike\note{ref} hack, and is
provided in appendix\note{ref}.


\chapter{System overview}
\label{cha:system}


\section{Lexical analysis and parsing}
\label{sec:laxparse}

The lexical analyzer and parser are not really part of the semantic
specification, and this report will not go into detail about the
parsing of Moedlica.

The Modelica source file being translated is first passed to the
lexical analyzer that scans the source for tokens, which it then
passes on to the parser.  The parser uses its grammar to build the
abstract syntax tree (AST).  The abstract syntax tree is an RML data
structure described in the module \code{Absyn} (see section
\ref{src:absyn}).

\section{Preparing the AST}
\label{sec:asttoscode}

The AST closely corresponds to the parse tree and keeps the structure
of the source file.  This has several disadvantages when it comes to
translating the program, and especially if the translation rules
should be easy to read for a human.  For this reason a preparatory
translation pass is introduced which translates the AST into an
intermediate form, called SCode.  Besides some minor simplifications
the SCode structure differs from the AST in the following respects:
\note{Move this to design chapter}

\begin{description}
\item[All components are described separately]
  In the source and in
  the AST several components in a class definition can be declared at
  once, as in \codebox{Real x, y[17];}.  In the SCode this is
  represented as two unrelated declarations, as if it had been written
  \codebox{Real x; Real y[17];}.

\item[Class declaration sections]
  In a Modelica class declaration the \code{public}, \code{protected},
  \code{equation} and \code{algorithm} sections may be included in any
  number and in any order, with an implicit \code{public} section
  first.  In the SCode these sections are collected so that all
  \code{public} and \code{protected} sections are combined into one
  section, while keeping the order of the elements.  The information
  about which elements were in a \code{protected} section is stored
  with the element itself.

\item[Modifications]
  Modifications are stored using the datatypes in the \code{Mod}
  module.
\end{description}

One might have thought that more work could be done at this stage,
like analyzing expression types and resolving names.  But due to the
nature of the Modelica language, the only way to know anything about
how the names will be resolved during instantiation is to do a more or
less full instantiation.  It is possible to analyze a class
declaration and find out what the parts of the declaration would mean
if the class was to be instantiated as-is, but since it is possible to
modify much of the class while instantiating it that analysis would
not be of much use.

\section{Instantiation}
\label{sec:instantiation}

The major part of the translation procedure, as described by the RML
specification is the translation from SCode to hybrid
differential-algebraic equations (hybrid DAEs).  As a Modelica source
files simply contain declarations of models and other kinds of
classes, there is a convention that the last class, which should be a
model, is instantiated as the top-level model.

\section{Output of equations}
\label{sec:output}

As the last stage of the translation the internal representation of
the hybrid DAEs are written out in the format described in chapter
\ref{cha:target}.


\note{Parameters}

\chapter{Informal semantics}
\label{cha:semantics}


\section{Introduction}
\label{sec:semintro}

The Modelica specification contains an informal description of the
intended semantics of the language. Unfortunately, the description
lacks considerably in detail, which means that this work needs to
formalize things not covered by the specification. In some cases, the
semantics was easy to guess, but in other cases, discussions with the
authors and reading of design meeting minutes was the needed to find
out what was really intended.

This chapter complements the Modelica specification by providing a
more comprehensive informal description of the language semantics.  It
is indended to help the understanding of the formal semantics in
chapter \ref{cha:formsem}.

\section{Types}
\label{sec:types}


\subsection{Overview of the type system in Modelica}
\label{sec:typeoverview}

The type system is based on \firstref{classes}. A class is the basic
unit of modelling. It is used to modularize the model description and
to \ldots{}


\subsection{Type equality and subtypes}
\label{sec:typeq}


\subsection{Class restrictions}
\label{sec:clrestr}

A class can either be declared with the \code{class} keyword, or with
one of its restricted forms, listed below.  The restricted forms are
used to indicate the intended use of the class, and to impose certain
restrictions on what the class definition can contain, and how it can
be used.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \hline
      \code{record} & No equations are allowed in the definition or in any
      of its components. A \code{record} instance may not be used in
      connections. \\
      \hline
      \code{type}   & May only be declared as derived from one of the
      predefined types, or as a matrix of a \code{type}. \\
      \hline
      \code{connector} & No equations are allowed in the definition or
      in any of its components. \\
      \hline
      \code{model} & A \code{model} instance may not be used in
      connections. \\
      \hline
      \code{block} & Each public component must be declared with one
      of the modifiers \code{input} or \code{output}. \\
      \hline
      \code{package} & May only contain declarations of classes and
      constants. \\
      \hline
      \code{function} & Each public component must be declared with one
      of the modifiers \code{input} or \code{output}. No equations are
      allowed and only one algorithm secion is allowed. \\
      \hline
    \end{tabular}
    \caption{Class restrictions}
    \label{tab:clrestr}
  \end{center}
\end{table}

A valid program can always be transformed into another valid program
by replacing all occurences of the restricted class keywords with the
keyword \code{class}.  For a class declared with the keyword
\code{class} to be able to be used as if it was declared with a
restricted keyword \note{Fel men nästan rätt}, it has to adher to the
restrictions for that keyword.

As an example, this means that if a variable is used in a connection,
its type has to be either a class declared with \code{connector}, or a
class declared with \code{class} which contains no equations.  Another
implication is that an invalid program can be transformed into a valid
program by replacing all restricted keywords with \code{class}, e.g.
when incorrectly trying to use a \code{record} in a connection,
because the keyword \code{record} has the same restrictions as the
\code{connector} keyword, except that \code{record} is explicitly not
allowed in connections, but \code{class} is, as long as it fulfills
the restrictions.

\subsection{Arrays and matrices}
\label{sec:arrays}


\section{Connections}
\label{sec:connections}

Connections between objects are introduced by the \code{connect}
construct in the equation part of a class declaration.  The
\code{connect} construct takes two references to connectors, each of
which is either an element of the same class as the \code{connect}
construct or an element of one of its components. The connectors are
connected to produce equation according to the rules below.  Each
connector reference has either the syntactic form \code{c}, where
\code{c} is a connector instance in the class containing the
\code{connect} construct, or \code{m.c}, where \code{m} is the name of
a component or an array of components \note{Stämmer det?} of the class
containing the \code{connect} construct, and \code{c} is the name of a
connector variable in the component \code{m}.


\subsection{Connection sets}
\label{sec:connectsets}

To create equations from the \code{connect} constructs, the connected
variables are collected in \firstref{connection sets}.

\begin{Def}[Connection sets]
  A connection set is a set $C$ of variables connected by means of
  \code{connect} constructs. A connection set contains either flow or
  non-flow variables, but never both.
\end{Def}

\begin{Def}[Inner and outer connectors]
  In an object $M$, each connector element of that class is called an
  \emph{outer connector} with respect to $M$. Each connector element of
  elements of $M$ is called an \emph{inner connector} with respect to
  $M$.
\end{Def}

When a \code{connect(a,b)} construct is encountered while
instantiating a class \code{C}, the component names \code{a} and
\code{b} are checked to be of the same type (see section
\ref{sec:typeq}). Then \code{a} and \code{b} are decomposed into their
public primitive components. Each subcomponent of \code{a} forms a
connection set with its corresponding subcomponent of \code{b}.

If several \code{connect(a,b)} constructs are encountered during
instantiation of a class, the resulting connection sets are merged to
a collection of connection sets $C$ so that if a component $x$ is
in two different connection sets $S_1$ and $S_2$, they the union $S_1
\cup S_2$ is a subset of one of the sets in $C$. Each component is in
exactly one of the sets in $C$.

\subsection{Equations}
\label{sec:coneq}

Each connection set is used to generate one or more equations. In the
case of variables declared with the \code{flow} type modifier, the
equation generated is a sum-to-zero equation, as in equation
\ref{eq:flow}.  The coefficient $d_v$ is $1$ if the component $v$ was
added to the connection set from an inner connector, and $-1$ if it
was added from an outer connector. \note{Clear?}

\begin{equation}
  \label{eq:flow}
  \sum_{v \in C} d_v v = 0
\end{equation}

In the case of non-flow components a number of simple equations is
generated. If the connection set contains $n$ components $c_1 \ldots
c_n$, equations to the effect of $c_1=c_2=\cdots=c_n$ are generated,
as in \ref{eqn:nonflow}.

\begin{eqnarray}
  \label{eqn:nonflow}
  c_1     & =      & c_2 \notag\\
  c_2     & =      & c_3 \notag\\
          & \vdots & \notag\\
  c_{n-1} & =      & c_n  
\end{eqnarray}


\subsection{Example}
\label{sec:csetex}

This section contains a short example of the use of connections in
Modelica, and shows the corresponding connection sets and generated
equations.  The Modelica source is shown in figure \ref{fig:csetex1}
and declares a connector \code{C} and models \code{A} and \code{M}.
The model that is instantiated at the top level is \code{M}, as it is
the last model in the file.

\begin{figure}[htbp]
\begin{boxedverbatim}
connector C
  Real x;
  flow Real y;
end C;

model A
  C con1, con2;
end A;

model M
  C con;
  A a1, a2;
  Real y;
equation
  connect(con,a1.con1);
  connect(a1.con1,a2.con1);
  connect(a1.con2,a2.con2);
  y = con.y;
end M;
\end{boxedverbatim}
  \caption{\code{connect} example}
  \label{fig:csetex1}
\end{figure}

Connection sets are generated at two different levels in this example.
While instantiating the model \code{M}, the three \code{connect}
statements creates the connection sets described in figure
\ref{fig:csetex2}, and the two instances of the model \code{A}
(components \code{a1} and \code{a2} in model \code{M}) create the
connectsion sets in figure \ref{fig:csetex3}.  Each component in the
sets are marked with a label indicating whether they were added from
an inner or an outer connector.

\newcommand{\Outer}[1]{\code{#1}^{\text{outer}}}
\newcommand{\inner}[1]{\code{#1}^{\text{inner}}}

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \Outer{con.x}, \inner{a1.con1.x}, \inner{a2.con1.x} \right\}$
    $\left\{ \inner{con.y}, \inner{a1.con1.y}, \inner{a2.con1.y} \right\}$
    $\left\{ \inner{a1.con2.x}, \inner{a2.con2.x} \right\}$
    $\left\{ \inner{a1.con2.y}, \inner{a2.con2.y} \right\}$
    \caption{Connection sets from \code{M}}
    \label{fig:csetex2}
  \end{center}
\end{figure}

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \Outer{a1.con1.x}, \Outer{a1.con2.x} \right\}$
    $\left\{ \Outer{a1.con1.y}, \Outer{a1.con2.y} \right\}$
    $\left\{ \Outer{a2.con1.x}, \Outer{a2.con2.x} \right\}$
    $\left\{ \Outer{a2.con1.y}, \Outer{a2.con2.y} \right\}$
    \caption{Connection sets from \code{A}}
    \label{fig:csetex3}
  \end{center}
\end{figure}

The equations generated from these connection sets, together with the
last equation in the model \code{M} is shown in figure
\ref{fig:csetex4}.

\begin{figure}[htbp]
  \begin{center}
    \begin{eqnarray*}
      \code{con.x}     &=& \code{a1.con1.x} \\
      \code{a1.con1.x} &=& \code{a2.con1.x} \\
      -\code{con.y} + \code{a1.con1.y} + \code{a2.con1.y} &=& 0 \\
      \code{a1.con2.x} &=& \code{a2.con2.x} \\
      \code{a1.con2.y} + \code{a2.con2.y} &=& 0 \\
      \code{a1.con1.x} &=& \code{a1.con2.x} \\
      -\code{a1.con1.y} - \code{a1.con2.x} &=& 0 \\
      \code{a2.con1.x} &=& \code{a2.con2.x} \\
      -\code{a2.con1.y} - \code{a2.con2.x} &=& 0
    \end{eqnarray*}
    \caption{Equations}
    \label{fig:csetex4}
  \end{center}
\end{figure}

\chapter{Design}
\label{cha:design}


\section{Abstract syntax}
\label{sec:absyndesign}

The abstract syntax is closely modelled after the syntactic
structure.  Unfortunately, this form is not very convenient for
the semantic description of the instantiation process.  To address
this problem, a second internal form, called the \firstref{exploded
  form} \note{Hmmm} is introduced. The main difference are that each
variable declaration is a separate entity with type, attributes and
modifications, instead of declaring several variables at once. Another
difference is that the class parts (\code{public}, \code{protected},
\code{equation} and \code{algorithm}) are sorted and collected in a
more structured fashion.


\section{Class restriction inference}
\label{sec:classinf}

To be able to determine if a class definition or a variable can be
used under certain circumstances it is necessary to check whether it
adhers the restrictions currently imposed on it. If the class is
declared with one of the restricted keywords listen in table
\ref{tab:clrestr}, it is immediately known, but when the class is
declared using the \code{class} keyword, the definition has to be
scanned to see what restrictions it breaks.

This is done for each variable as it is instantiated, using the state
machine in the file \filename{classinf.rml} (see section
\ref{src:classinf}).  While instantiating a class the current state is
kept in a variable of type \code{ClassInf.State}.  It is initialized
with the keyword used to declare the class using the relation
\code{ClassInf.start}.  If the keyword was one of the restricted
forms, the state will be initialized to a state that directly
corresponds to that form, and it will never change to another state.
If the keyword was \code{class}, the state is initialized to
\code{ClassInf.UNKNOWN}.

Transitions in the state machine are triggered by events signalled
during instantiation indicating that some piece of information has been
encountered which affects the class restriction. The defined events
are listed in table \ref{tab:classinfevents}.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \hline
      \code{FOUND\_EQUATION} & The class is now known to contain at
      least one equation. \\
      \hline
      \note{Fyll på} & \ldots
    \end{tabular}
    \caption{Class restriction inference events}
    \label{tab:classinfevents}
  \end{center}
\end{table}

\note{Skriv nåt om \code{ClassInf.valid}}


\chapter{Target language}
\label{cha:target}

The formal semantic specification in chapter \ref{cha:formsem}
specifies the semantics of Modelica by showing how it is translated
into another, simpler, language.  The translation is a sort of
flattening of the object-oriented structure of the model.  This
chapter describes the format of the output of the translator.

\section{Requirements}

There are different requirements that can be placed on the output
format, all of which are not possible to meet simultaneously.

\begin{enumerate}
\item The output should contain all the information gathered from the
  analysis of the Modelica source.
\item The output should be easily read by a human.
\item The output should be easily parsed by a computer.
\item The output should be able to be fed to an existing equation
  solver.
\item The target language needs to be able to express everything that
  can be expressed by the Modelica language
\end{enumerate}



The target language needs to be able to express everything that can be
expressed by the Modelica language, but it may do so in a much less
structured way.  The major part of the translator output consists of a
flat list of equations which are the result of instantiating the main
model of the source file and its subcomponents.

\note{structural parameters}


\chapter{Annotated formal semantics}
\label{cha:formsem}

This chapter contains the complete formal semantics of Modelica.  This
includes the RML source files, but the comments in the files are
converted to more readable text.

\section{Overview}

The specification is separated into a number of files, to modularize
it and to make it easier to maintain and to make the structure
clearer.  

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{llp{8cm}}
      \hline
      \ref{src:exp} & \code{exp.tex}            & Expressions \\
      \ref{src:classinf} & \code{classinf.tex}  & Class inference \\
      \ref{src:dae} & \code{dae.tex}            & Output \\
      \ref{src:types} & \code{types.tex}        &  \\
      \ref{src:absyn} & \code{absyn.tex}        & Abstract syntax \\
      \ref{src:explode} & \code{explode.tex}    &  \\
      \ref{src:dump} & \code{dump.tex}          &  \\
      \ref{src:prefix} & \code{prefix.tex}      &  \\
      \ref{src:mod} & \code{mod.tex}            &  \\
      \ref{src:env} & \code{env.tex}            &  \\
      \ref{src:lookup} & \code{lookup.tex}      &  \\
      \ref{src:builtin} & \code{builtin.tex}    &  \\
      \ref{src:connect} & \code{connect.tex}    &  \\
      \ref{src:staticexp} & \code{staticexp.tex}&  \\
      \ref{src:inst} & \code{inst.tex}          &  \\
      \ref{src:main} & \code{main.tex}          &  \\
      \hline
    \end{tabular}
    \caption{Files in the specification}
    \label{tab:files}
  \end{center}
\end{table}

\input{main.tex}
\input{absyn.tex}
\input{exp.tex}
\input{classinf.tex}
\input{types.tex}
\input{explode.tex}
\input{inst.tex}
\input{prefix.tex}
\input{mod.tex}
\input{env.tex}
\input{lookup.tex}
\input{builtin.tex}
\input{connect.tex}
\input{staticexp.tex}
\input{dae.tex}
%\input{dump.tex}


\chapter{rmldoc \note{appendix}}

{\codefont\verbatiminput{../tools/rmldoc}}

\begin{thebibliography}{99}
\bibitem[FOO]{Hm}
\end{thebibliography}

\end{document}
