\documentclass[a4paper]{report}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}

\author{David Kågedal}
\title{Blahonga Blahonga}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\firstref}[1]{\textit{#1}}

\newtheorem{Def}{Definition}[chapter]

\begin{document}

\titlepage
\maketitle{}
\endtitlepage


\begin{abstract}
\label{abs}

Formal descriptions of the syntax of programming languages has long
been accepted as a natural way of describing the syntacical form of
the language. Today everobody expects a BNF-like grammar for a new
language. But that is not the case when it comes to describing the
semantics of languages. Formalisms for the specifications of semantics
hase been avaiable for many years, but are not often used by others
than researchers.

One advantage of using a formal description of the semantics is of
course that the specification becomes more strict and unambiguous. But
there is also the possibility of using the semantic specification to
generate a language translator, or compiler, in an automatic way.

This paper describes a formal semantics for Modelica, an
equation-based language used for modeling. The notation used enables
it to be passed to a compiler generator that generates a Modelica
translator.

\end{abstract}

\tableofcontents

\chapter{Background}
\label{cha:bg}


\section{Introduction}
\label{sec:intro}


\section{Overview of formal semantics}
\label{sec:semoverview}


\section{RML}
\label{sec:rml}


\section{Modelica}
\label{sec:modelicabg}


\chapter{Goals, motivation and stuff}
\label{cha:goals}


\chapter{Development environment}
\label{cha:devenv}


\chapter{Semantics}
\label{cha:semantics}


\section{Introduction}
\label{sec:semintro}

The Modelica specification contains an informal description of the
intended semantics of the language. Unfortunately, the description
lacks considerably in detail, which means that this work needs to
formalize things not covered by the specification. In some cases, the
semantics was easy to guess, but in other cases, discussions with the
authors was the only way to find out what was really intended.

This chapter complements the Modelica specification by providing a
more comprehensive informal description of the language semantics.

\section{Types}
\label{sec:types}


\section{Overview of the type system in Modelica}
\label{sec:typeoverview}


\subsection{Type equality and subtypes}
\label{sec:typeq}


\section{Connections}
\label{sec:connections}

Connections between objects are introduced by the \code{connect}
construct in the equation part of a class declaration.  The
\code{connect} construct takes two references to connectors, each of
which is either an element of the same class as the \code{connect}
construct or an element of one of its components. The connectors are
connected to produce equation according to the rules below.  Each
connector reference has either the syntactic form \code{c}, where
\code{c} is a connector instance in the class containing the
\code{connect} construct, or \code{m.c}, where \code{m} is the name of
a component or an array of components (??) of the class containing the
\code{connect} construct, and \code{c} is the name of a connector
variable in the component \code{m}.


\subsection{Connection sets}
\label{sec:connectsets}

To create equations from the \code{connect} constructs, the connected
variables are collected in \firstref{connection sets}.

\begin{Def}[Connection sets]
  A connection set is a set $C$ of variables connected by means of
  \code{connect} constructs. A connection set contains either across
  or through variables, but never both.
\end{Def}

\begin{Def}[Inner and outer connectors]
  In an object $M$, each connector element of that class is called an
  \emph{outer connector} with respect to $M$. Each connector element of
  elements of $M$ is called an \emph{inner connector} with respect to
  $M$.
\end{Def}

When a \code{connect(a,b)} construct is encountered, the component
names \code{a} and \code{b} are checked to be of the same type
(see section \ref{sec:typeq}).


\subsection{Equations}
\label{sec:coneq}

In the case of variables declared with the \code{flow} type modifier,
the equation generated is a sum-to-zero equation. \[\sum_{v \in C} d_v
v = 0\]


\begin{thebibliography}{99}
\bibitem[FOO]{Hm}
\end{thebibliography}

\end{document}
