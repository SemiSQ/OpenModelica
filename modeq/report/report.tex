\documentclass[a4paper]{report}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim}
%\usepackage{boxedminipage}
%\usepackage{lscape}
\usepackage{makeidx}
\usepackage{palatino}
\usepackage{euler}

\author{David Kågedal}
\title{Blahonga Blahonga}

\makeindex

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\codebox}[1]{\fbox{\code{#1}}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\term}[1]{\textit{\bfseries#1}}
\newcommand{\firstref}[1]{\term{#1}\index{#1}}
\newcommand{\note}[1]{[\textsc{#1}]}
\newcommand{\fixme}[1]{\mbox{}\marginpar{$\blacktriangleleft$}\note{#1}}
\newcommand{\unfinished}{\fixme{\ldots}}

\newtheorem{defth}{Definition}[chapter]
\newtheorem{example}{Example}[chapter]

\newenvironment{Def}[1]{\begin{defth}[#1]\index{#1|textbf}}{\end{defth}}

\newcommand{\codefont}{\normalfont\ttfamily\fontsize{8}{9}\selectfont}

\makeatletter

\newcommand{\sourcefile}[2]{%
  \clearpage
  \section{File \code{#1.rml}}
  \label{src:#1}
  \addcontentsline{stc}{sourcefile}{%
    \protect\numberline{\thesection}\protect\makebox[8em][l]{\code{#1.rml}}#2}}
\newcommand{\listofsources}{\@starttoc{stc}}
\newcommand{\l@sourcefile}{%
  \@dottedtocline{1}{2em}{3em}%
  }

% Some magic from Tommy Pettersson
\def\dedu#1#2{{\setbox0=\hbox{\ensuremath{#1}}\dimen0=\wd0\setbox1=\hbox
    to\dimen0{\hss\ensuremath{#2}\hss}\vbox{\box0\vspace{1mm}\hrule
      width\dimen0\vspace{1mm}\box1}}}

% See the verbatim package for info about this
\def\boxedverbatim{\begingroup%
  \parskip=0pt\topsep=0pt\partopsep=0pt%
  \def\verbatim@processline{%
    \setbox1=\hbox{\the\verbatim@line}%
    \setbox0=\vbox{{\box0}{\box1}}%
    }%
  \def\verbatim@font{%
    \codefont
    \let\do\do@noligs
    \verbatim@nolig@list}
   \verbatim}
\def\endboxedverbatim{\endverbatim\framebox[\linewidth][l]{\box0}%
  \endgroup\vspace{2ex}}

\makeatother
  

\begin{document}

\titlepage
\maketitle{}
\endtitlepage

\begin{abstract}
\label{abs}

Modelica is a new modeling language.  It is an object-oriented,
equation-based languages that is designed to incorporate features from
several previous modeling languages and form a common ground for
modeling and simulation implementors.  As a part of the design
process, the exact semantics of the language needs to be defined.

Formal descriptions of the syntax of programming languages has long
been accepted as a natural way of describing the syntactical form of
the language. Today everybody expects a BNF-like grammar for a new
language. But that is not the case when it comes to describing the
semantics of languages. Formalisms for the specifications of semantics
has been available for many years, but are not often used by others
than researchers.

One advantage of using a formal description of the semantics is of
course that the specification becomes more strict and unambiguous. But
there is also the possibility of using the semantic specification to
generate a language translator, or compiler, in an automatic way.

This report describes a partial formal semantics for Modelica. The
notation used enables it to be passed to a compiler generator that
generates a Modelica translator, that translates a Modelica model into
a simple set of equations.

The language used for the specification is called RML, and is based on
Natural semantics, an operational semantic specification formalism.

\end{abstract}

\tableofcontents

\chapter{Background}
\label{cha:bg}


\section{Introduction}
\label{sec:intro}

This chapter tries to give some background information outlining why
this work was done, and what the basic concepts used are.

\section{Overview of formal semantics}
\label{sec:semoverview}

Any new programming language needs to be described in one way or
another.  The syntax of the language is conveniently described by a
grammar in a common format, such as BNF\cite{drakboken}.  However,
when it comes to the semantics of a programming language, things are
not so straightforward.

The semantics of the language describes what any particular program
written in the language ``means'', i.e. what should happen when the
program is executed, or evaluated in some form.

Most programming language semantic definitions are given by a standard
text written in English which tries to give a complete an unambiguous
specification of the language.  Unfortunately, this is often not
enough.  Natural language is inherently not very exact, and it is hard
to make sure that all special cases are covered.  One of the most
important requirements of a language specification is that two
different language implementors should be able to read the
specification and make implementations that interpret the
specification in the same way.  This implies that the specification
must be exact and unambiguous.

For this reason formalisms for writing formal specifications of
languages have been invented\cite{pagan}.  These formalisms
allow for a mathematical semantic description, which as a consequence
is exact, unambiguous and easier to verify.

Several approaches has been explored as to how the semantics should be
described formally.  See \cite{pi} for a good introduction to the
various approaches.


\section{Natural semantics}
\label{sec:natsem}
\index{foobar}

The formalism that we use is called \firstref{Natural Semantics}.
The ``natural'' in Natural semantics is intended to indicate its
similarities to natural deduction, which is a way of constructing
proofs in formal logic systems.  A specification in Natural semantics
is usually given a proof-theoretic interpretation, meaning that it is
used to construct proofs.

There are many different presentations of Natural semantics in the
literature, and I choose to present the simple form that RML uses.

Natural semantics uses \firstref{inference rules} to describe the
semantics.  These rules consist of a \firstref{consequence} and a
number of \firstref{premises}.

$$
\dedu{ p_1 \Rightarrow q_1 \hspace{1em}
       \ldots \hspace{1em} p_n \Rightarrow q_1 }
     { p \Rightarrow q }
$$

The number of premises may be zero, in which case we say that the rule
is an \firstref{axiom}.

$$
p \Rightarrow q
$$

\subsection{A simple expression evaluator}

The proof construction mechanism is described by a small example,
describing a very basic expression language, with numbers and addition
and multiplication operators.  First, we define the abstract syntax of
the expression language:

\begin{gather}
  n \in \text{Int} \\
  e \in \text{Exp} ::= n \;|\; e + e \;|\; e \cdot e
\end{gather}

Then we give the rules for the evaluation of expressions to integer
values.

\begin{gather}
  \label{eq:int}
  n => n \\
  \label{eq:add}
  \dedu{ e_1 \Rightarrow n_1 \hspace{1em}
         e_2 \Rightarrow n_2 \hspace{1em}
         n = n_1 + n_2 }
       { e_1 + e_2 \Rightarrow n } \\
  \label{eq:mul}
  \dedu{ e_1 \Rightarrow n_1 \hspace{1em}
         e_2 \Rightarrow n_2 \hspace{1em}
         n = n_1 \cdot n_2 }
       { e_1 \cdot e_2 \Rightarrow n }
\end{gather}

If we want to prove, using these rules, that the expression $3 \cdot
(4 + 5)$ has a value, we do this by finding a rule, whose consequence
can be instantiated to match this expression.  Such an instance is
called a \firstref{sequent}.

The only rule that matches is rule \ref{eq:mul}, leading to the
following rule instance, where $3$ is substituted for $e_1$ and $(4 +
5)$ is for $e_2$:

$$
  \dedu{ 3 \Rightarrow n_1 \hspace{1em}
         (4 + 5) \Rightarrow n_2 \hspace{1em}
         n = n_1 \cdot n_2 }
       { 3 \cdot (4 + 5) \Rightarrow n }
$$

This is not a complete proof.  We need to prove the sequent $3
\Rightarrow n_1$, and the only rule matching that is rule
\ref{eq:int}, leading to the following proof tree where $3$ is
substituted for $n_3$:

$$
  \dedu{ 3 \Rightarrow 3 \hspace{1em}
         (4 + 5) \Rightarrow n_2 \hspace{1em}
         n = 3 \cdot n_2 }
       { 3 \cdot (4 + 5) \Rightarrow n }
$$

The sequent labeled with a $3$ also need to be proved, and this can be
done by instantiating rule \ref{eq:add}.

$$
  \dedu{ 3 \Rightarrow 3 \hspace{1em}
         \dedu{ 4 \Rightarrow n_3 \hspace{1em}
                5 \Rightarrow n_4 \hspace{1em}
                n_2 = n_3 + n_4 }
              { 4 + 5 \Rightarrow n_2} \hspace{1em}
                n = 3 \cdot n_2 }
       { 3 \cdot (4 + 5) \Rightarrow n }
$$

Instantiating rule \ref{eq:int} twice leads to the following proof
tree:

$$
  \dedu{ 3 \Rightarrow 3 \hspace{1em}
         \dedu{ 4 \Rightarrow 4 \hspace{1em}
                5 \Rightarrow 5 \hspace{1em}
                n_2 = 4 + 5 }
              { 4 + 5 \Rightarrow n_2} \hspace{1em}
                n = 3 \cdot n_2 }
       { 3 \cdot (4 + 5) \Rightarrow n }
$$

Now we can substitute $9$ for $n_2$, and consequently $27$ for $n$,
leading to the complete proof tree.

$$
  \dedu{ 3 \Rightarrow 3 \hspace{1em}
         \dedu{ 4 \Rightarrow 4 \hspace{1em}
                5 \Rightarrow 5 \hspace{1em}
                9 = 4 + 5 }
              { 4 + 5 \Rightarrow 9} \hspace{1em}
                27 = 3 \cdot 9 }
       { 3 \cdot (4 + 5) \Rightarrow 27 }
$$

Not only does this prove that the initial expression $3 \cdot (4+5)$
has a value, it also computes the value $27$.

\section{RML}
\label{sec:rml}

One of the nice properties of Natural semantics is that it lends
itself to efficient implementation in a computer.  The semantic
specification can be regarded as an operational description of how a
language is interpreted or translated.

This is what RML\cite{rml,petfrrml,pirml} is all about.  The RML
language provides a simple text syntax for specifying rules and data
types.  This specification can then be compiled into an executable
that can be used to interpret or translate any file in the described
language.


\subsection{RML syntax}
\label{sec:rmlsyn}

The RML syntax borrows elements from languages like SML\cite{sml} to
introduce a strict type system and a module system.  The syntax for
rules looks like the normal Natural semantics rule layout, adjusted
for ASCII text.

The rules are grouped in \firstref{relations}.  A relation is a set of
rules that have the same \firstref{signature}, meaning that they
perform the same operation, but are applicable at different times.

The type system includes basic types, such as \code{int}, \code{real}
and \code{bool}.  User-defined algebraic types may be declared in a
SML-like syntax, as in the following example that declares the
expression type used in the previous section.

\begin{boxedverbatim}
  datatype Exp = INT of int | ADD of Exp * Exp | MUL of Exp * Exp
\end{boxedverbatim}

With this type declaration, the expression $1*(2+3)$ is represented as
the RML value \codebox{MUL(INT(1),ADD(NUM(2),NUM(3)))}.

The signature of a relation can also be described as an RML type,
using the \code{=>} type constructor.  A relation has a name, and each
rule has a number of input arguments on the left side of the arrow,
and a number of output arguments on the right side.  The types of
these arguments form the signature.  The rules in the example above
can be grouped in a relation that we call \code{eval}, with the
following signature:

\begin{boxedverbatim}
  relation eval : Exp => int
\end{boxedverbatim}

The rules are placed inside the relation definition.  It uses the
built-in relations \code{int\_add} and \code{int\_mul} that perform
integer addition an multiplication, respectively.

\begin{boxedverbatim}
  relation eval : Exp => int =

    axiom eval NUM(i) => i

    rule  eval e1 => n1  &  eval e2 => n2  &  int_add(n1,n2) => n
          -------------------------------------------------------
          eval ADD(e1,e2) => n

    rule  eval e1 => n1  &  eval e2 => n2  &  int_mul(n1,n2) => n
          -------------------------------------------------------
          eval MUL(e1,e2) => n

  end
\end{boxedverbatim}

\section{Modelica}
\label{sec:modelicabg}

Modelica\cite{modelicawww} is an object-oriented language for modeling
of physical systems for the purpose of efficient simulation.  The
language unifies and generalizes previous object-oriented modeling
languages designed by different companies and research institutions.

Compared with the widespread simulation languages previously
available, this language offers three important advances:

\begin{itemize}
\item Non-causal modeling based on differential and algebraic
  equations.

\item Multi-domain modeling capability, i.e. it is possible to combine
  electrical, mechanical, thermodynamic, hydraulic etc. model
  components within the same application model
  
\item A general type system that unifies object-orientation, multiple
  inheritance, and templates within a single class construct.
\end{itemize}

A Modelica model is defined in terms of classes containing equations
and definitions.  The semantics of such a model is defined via
translation of classes, instances, connections and functions into a
flat set of constants, variables and equations.  Equations are sorted
and converted to assignment statements when possible.  Strongly
connected sets of equations are solved by using a symbolic or numeric
solver.

\fixme{More stuff}

\section{The Modelica design group}
\label{sec:designgroup}

The Modelica language is designed by a group of people.  The work on
designing a new modeling language began in 1996 when a number of
experts formed a group to design a new multi-paradigm modeling
language for hybrid systems.  Since the start, the group has expanded
to include many new members from around Europe.

A first version of the Modelica language definition was finalized in
September 1997, and there was much rejoicing.  But no complete
implementation existed yet, and there was actually a lot more work
needed to make the specification comprehensive enough to be able to
build a implementation for it.

The work on the RML specification for Modelica began in November 1997.


\section{PELAB}
\label{sec:pela}

The Programming Environment Laboratory, PELAB, (Fritzson, professor)
is concerned with research in software engineering, i.e. tools and
methods for the specification, development and maintenance of computer
programs. Some examples are: programming languages, debuggers,
incremental programming environments and compilers, compiler
generators, tools for debugging and maintenance of distributed and
real-time systems, compilers and programming environments for parallel
computers, high-level environments and mathematical modeling languages
and systems for scientific computing, program transformation systems,
etc.  The view of programming environment research is rather
pragmatic, and the primary interest is in developing and investigating
new methods and tools that have potential for practical applications,
e.g. in support systems for software specialists. Developing such
tools is very important, since most of the rising cost of computer
systems is due to development, debugging and maintenance of software.

\chapter{Motivation and scope of the thesis}
\label{cha:goals}

This chapter describes the goals and the scope of this thesis.

\section{Goal}

The initial assignment was very simple in its formulation: ``Write a
formal semantic specification for Modelica using RML.''  There were at
least three important reasons for doing exactly this.

\subsection{A Modelica specification is needed}

The Modelica design process was, and still is, in dire need of a
formalized description of the language.  The language specification
available at the time (version 1.0 from September
1997)\cite{modelica10} did not contain much about the semantics of the
language.  This meant that nobody knew exactly how the language
worked, and it was not certain that everybody in the design group
agreed on the semantical details, since they were not clearly
described anywhere.

Peter Fritzson is a member of the Modelica design group and there are
several projects at PELAB that concerns Modelica.  This project would
be an important contribution to the Modelica design effort.

\subsection{Gaining experience with RML}

The RML language and compiler were developed at PELAB by Mikael
Pettersson.  They were new, and only a few language specifications had
yet been written using it.  More experience with various language
specifications was desired to gain experience with its advantages and
shortcomings.

\subsection{Natural semantics and equation-based\\ languages}

Modelica is not a programming language, such as C or LISP.  Instead it
is a modeling language, with basically only static semantics.  For
this reason it was interesting to see how a formalism like Natural
semantics, and more specifically RML, which is usually used to
specify programming languages, could be applied to it.


\section{Scope of the thesis}
\label{sec:scope}

The work that is forms the basis for this thesis only concerns the
formal specification of the Modelica semantics.  The initial goal was
to write a complete semantic specification for Modelica 1.0.
Unfortunately, Modelica 1.0 was not very well-defined, which means
that considerable effort has been needed to figure out what the
semantics were.  This has been done by taking part of the Modelica
design effort, including participation in design meetings and
electronic discussions.

These discussions lay outside the scope of the thesis, and was not
directly part of the work.  However, it was needed to be able to write
the formal semantics.  Unfortunately, this lead to a chicken-and-egg
problem, because until I had tried to write the specification I didn't
know what the problems with the Modelica semantics were.  These
problems could then be discussed with the design group, leading to new
ideas about how the semantics should have been written in the first
place.

Another goal of the formal specification was to build a usable
Modelica translator, which could be used for real-world applications.
Since this partly conflicts with the desire to produce a clear
semantical description, which not necessarily gives translation
efficiency high priority, a decision needed to be made on what to
focus on.  I chose to concentrate on the semantical description, which
shows in things like describing the semantics of equations between to
matrices as a number of simple equations between the individual
elements of the two matrices.

\section{Limitations of the semantic specification}
\label{sec:limitations}

For the reasons outlined above, the semantic specification is far from
complete.  Even the language Modelica itself is still very incomplete.

Most of the work has been put into describing the most important
aspects of instantiation and expression analysis, while other things,
like functions and other algorithmic aspects needs more attention.
Also more work is needed to add the polish to fix all the details with
preventing things like instantiation of partial classes.  But this is
something that should not be done before the overall structure is
fixed.

Below is a list of issues that is not covered by the semantic
specification, or were implemented before it was decided how it should
have been done.  The limitations are listen in no particular order.

\begin{enumerate}

\item Class names can only denote classes, which means that it is not
  possible to define a ``type synonym'' for an array type, as in
  \codebox{type Point Real[3]}.
  
\item Modifying array slices does not work, as in \codebox{AModel
    a(x[3:5] = [1.0,2.0,3.0])}.

\item Array slices are note expanded in array equations.

\item The built-in pseudo-functions (size etc.) are not implemented.

\item Actually no evaluation of function calls are performed during
  translation.  This would be needed when the value of a constant (or
  parameter) is defined in terms of a function call.

\item Functions are implemented in a pretty brain-damaged way.  There
  is a proposal where function calls are defined in terms of
  ``implicit instantiation'', but this is hard to implement because of
  RML limitations.

\item The checking of component attributes is severely lacking.  For
  instance, it is currently possible to use a variable in an outer
  scope.  This should only be possible with constants, if at all.

\item Modifying class names is done even for non-local class names.

\item Unused modifications are simply discarded.  They should produce
  an error.

\item Redeclarations are not implemented.

\item The builtin type attributes are not completely implemented.

\item Assertions are lost during translation.
  
\item There are some remaining bugs with the parts that are
  implemented.  And some of the most recent design decisions and
  clarifications of the Modelica semantics are not incorporated into
  the design.

\end{enumerate}

\chapter{Development environment}
\label{cha:devenv}


\section{Compiling RML}
\label{sec:rmlc}

The RML compiler is currently at version 2.0.  When the work on the
Modelica semantics began, the RML version was at 1.5.  The new
compiler provided much improved error messages and freedom in writing
source files.

The RML compiler first translates the RML specification to a C
program.  The RML compiler driver \code{rmlc} then compiles this,
using a C compiler.  We have used the GNU C compiler (GCC), but most
modern C compilers should be usable.

\section{Parser}
\label{sec:parser}

The Modelica parser was generated by the PCCTS\cite{pccts} compiler
generation system.  It generates a parser in C, which is linked with
the RML object files.  The glue between the languages is a special RML
relation \code{parse}, which is implemented in C, rather than RML.

The parser only builds an abstract syntax tree (AST), and leaves the
rest of the transformation logic to the RML code.  Therefore, the
parser itself is not further described in this report.

The parser generator in PCCTS is powerful, but it has a few problems,
and is currently not maintained very actively.  Because of problems
with error handlers, the translator does not deal very well with
syntax errors.  If an error occurs while parsing, an error message
will be printed, but the translator will try to translate the result of
parsing anyway.  Since the resulting AST will be severely broken, this
will fail.

\section{The report}
\label{sec:report}

This report was written using the \LaTeX{}\cite{Lamport86} text
formatting system.

To produce the annotated semantics in chapter \ref{cha:formsem} a
small program was written to convert the RML source files with
comments to \LaTeX{} source with the comments converted to ordinary
text. This program is a quick'n'dirty Pike\cite{pike} hack, and is
provided in appendix \ref{cha:rmldoc}


\chapter{Some thoughts on the informal semantics of Modelica}
\label{cha:semantics}


\section{Introduction}
\label{sec:semintro}

The Modelica specification\cite{modelica1f} contains an informal
description of the intended semantics of the language. Unfortunately,
the description lacks considerably in detail, which means that this
work needs to formalize things not covered by the specification. In
some cases, the semantics was easy to guess, but in other cases,
discussions with the authors and reading of design meeting minutes was
the needed to find out what was really intended.

This chapter complements the Modelica specification by filling in some
of the larger holes in the informal language semantics.  It is
intended to help the understanding of the formal semantics in chapter
\ref{cha:formsem}.


\section{Terminology}
\label{sec:terminology}

There has been some confusion about the terminology regarding Modelica
language elements, and currently the language definition is not very
strict on this point.  This will hopefully improve, but for now it is
necessary to include a short list of terms here to specify what they
mean.

\begin{Def}{Element}
  The term \term{element} corresponds closely to the non-terminal
  \texttt{element} in the grammar in the Modelica specification, which
  is a part of a class declaration.  It can be either a class
  definition, a component declaration or an extends clause, that
  appears inside a class definition.
\end{Def}

\begin{example}
  The following class definition contains four elements.  One
  \code{extends} statement, one class definition, and two class
  definitions.   Note that the definitions of \code{width} and
  \code{height} are separate elements, but the grammar only needs one
  \code{element} rule to match them.

  \begin{boxedverbatim}
    class C
      extends OtherClass;
      type Length = Real(unit = "m");
      Length width, height;
    end C;
  \end{boxedverbatim}
\end{example}

\begin{Def}{Instantiation}
  The word \term{instantiate} is used in many language
  descriptions, with slightly different meaning.  In the specification
  it is used in two related, but slightly different, meanings.
  
  Instantiating a class means creating an object (or class instance)
  from the description contained in the class definition, possibly
  modified by any given modifiers.  This instance is not a run-time
  object that needs an allocated piece of memory, as in many dynamic
  object-oriented languages, but the principle is the same.

  For every component declaration in the class definition (possible
  inherited from another class definitions using an \code{extends}
  element), the component declarations class is also instantiated.

  When instantiating a class all of the elements in the definition of
  that class are also said to be instantiated.  Instantiating an
  element means different things depending of what kind of element is
  instantiated.  Basically it means to add the element to the
  partially instantiated parent (see the Modelica specification for an
  explanation of this).
  \begin{itemize}
  \item Instantiating a class definition simply means adding the class
    definition to the partially instantiated parent.
  \item Instantiation a component declaration means instantiating the
    class of the component and add that object to the partially
    instantiated parent.
  \item Instantiating an extends element means instantiating all the
    elements in the extended class.
  \end{itemize}
\end{Def}

\begin{example}
  The following Modelica example contains three class definitions.  If
  the last one (\code{C}) is instantiated, it means that the class
  \code{B} needs to be instantiated twice to create the subcomponents
  \code{b1} and \code{b2}.

  \begin{boxedverbatim}
    class B
      Real x;
    end B;

    class C
      B b1,b2;
    end C;
  \end{boxedverbatim}
\end{example}

\begin{Def}{Component}
  The term \term{Component} refers to an class instance.  Many
  components are composed of several other components.
\end{Def}

\begin{Def}{Immediate Subcomponent}
  If component $A$ is a structure which is composed of other
  components, each of these components is an \term{immediate
    subcomponent} of $A$.
\end{Def}

\begin{Def}{Subcomponent}
  This is a recursive definition of \term{subcomponent}.  A
  subcomponent of a component $A$ is either

  \begin{enumerate}
  \item An immediate subcomponent of $A$.
  \item A subcomponent of an immediate subcomponent of $A$.
  \end{enumerate}
\end{Def}

\begin{example}
  
  Consider the following Modelica model:
  
  \begin{boxedverbatim}
    model A
      Real x;
    end A;

    model B
      A a;
      Real y;
    end B;
  \end{boxedverbatim}

  If an instance of \code{B} is created under the name, \code{B} will
  contain two subcomponents referred to as \code{B.a.x} and
  \code{B.y}.  Only \code{B.y} will be an immediate subcomponent of
  \code{B}.
  
\end{example}


\section{Types}
\label{sec:types}


\subsection{Overview of the type system in Modelica}
\label{sec:typeoverview}

The type system is based on \firstref{classes}. A class is the basic
unit of modeling. It is used to modularize the model description and
to give the models a hierarchical structure.  Another important
concept in the type system is that of \firstref{arrays}.

The type system used in Modelica is based on a type system described
by Luca Cardelli\cite{cardelli}.

The definition of what a type is has been the subject of discussion in
the Modelica group, but the following definition is used in this
specification.

\begin{Def}{Type}
  A type is a property of components and expressions.  It is defined
  as one of the following:

  \begin{enumerate}
  \item A built-in type (Real, Integer, String or Boolean).  These
    correspond to the Modelica predefined classes \code{RealType},
    \code{IntegerType}, \code{StringType} and \code{BooleanType}.
    
  \item A structured type, containing a set of public components
    $(N,T)$, where $N$ is an identifier and $T$ is a type.  No two
    components in the set can have the same identifier.
    
  \item An array of a type, with a undefined or non-negative, integer
    size.
  \end{enumerate}
\end{Def}

Note that there is no special provision for multi-dimensional arrays.
They are regarded as equal to arrays of arrays.  A Modelica
implementation might do it the other way around, regard arrays of
arrays as multidimensional arrays.  The important thing is that they
are the same.  Synonyms for two classes of arrays are used both in
this specification and the Modelica language definition.

\begin{Def}{Array synonyms}
  The term \term{vector}\index{vector} is a synonym for a
  one-dimensional array.  The term \term{matrix}\index{matrix} is a
  synonym for a two-dimensional array.
\end{Def}

\begin{Def}{Incomplete types}
  If a type includes an undefined array size, it is an
  \term{incomplete type}.  If not, it is a \term{complete type}.
\end{Def}

All components must have a complete type.  All expressions also have
complete types.  Incomplete types only appear as the input argument
types of function (see the discussion in section \ref{sec:functions}).

\subsection{Type equivalence and subtypes}
\label{sec:typeq}

The concepts of equivalent types and subtypes appears in several
places in the specification.

\begin{Def}{Subtype}
  A type $T_1$ is a \term{subtype} of another type $T_2$ if and
  only if one of the following hold:
  \begin{enumerate}
  \item $T_1$ and $T_2$ are the same built-in type
  \item $T_1$ and $T_2$ are structured types, where all public
    components in $T_2$ appear in $T_1$.  The type of the component in
    $T_1$ must be a subtype of the type of the corresponding component
    in $T_2$.
  \item $T_1$ is an array of type $T_1'$ and $T_2$ is an array of type
    $T_2'$, where $T_1'$ is a subtype of $T_2'$.  Also either the size
    of $T_2$ is undefined or the size of $T_1$ is equal to the size of
    $T_2$.
  \end{enumerate}
\end{Def}

\begin{Def}{Supertype}
  If $T_1$ is a subtype of $T_2$, then $T_2$ is a \term{supertype}
  of $T_1$.
\end{Def}

\begin{Def}{Equivalent types}
  Two types $T_1$ and $T_2$ are said to be \term{equivalent types}
  if and only if $T_1$ is a subtype of $T_2$ and $T_2$ is a subtype of
  $T_1$.
\end{Def}

\subsection{Class restrictions}
\label{sec:clrestr}

A class can either be declared with the \code{class} keyword, or with
one of its restricted forms, listed below.  The restricted forms are
used to indicate the intended use of the class, and to impose certain
restrictions on what the class definition can contain, and how it can
be used.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \hline
      \code{record} & No equations are allowed in the definition or in any
      of its components. A \code{record} instance may not be used in
      connections. \\
      \hline
      \code{type}   & May only be declared as derived from one of the
      predefined types, or as a matrix of a \code{type}. \\
      \hline
      \code{connector} & No equations are allowed in the definition or
      in any of its components. \\
      \hline
      \code{model} & A \code{model} instance may not be used in
      connections. \\
      \hline
      \code{block} & Each public component must be declared with one
      of the modifiers \code{input} or \code{output}. \\
      \hline
      \code{package} & May only contain declarations of classes and
      constants. \\
      \hline
      \code{function} & Each public component must be declared with one
      of the modifiers \code{input} or \code{output}. No equations are
      allowed and only one algorithm section is allowed. \\
      \hline
    \end{tabular}
    \caption{Class restrictions}
    \label{tab:clrestr}
  \end{center}
\end{table}

A goal of the Modelica design is that a valid program can always be
transformed into another valid program by replacing all occurrences of
the restricted class keywords with the keyword \code{class}.  For a
class declared with the keyword \code{class} to be able to be used as
if it was declared with a restricted keyword, it has to adhere to the
restrictions for that keyword.

As an example, this means that if a variable is used in a connection,
its type has to be either a class declared with \code{connector}, or a
class declared with \code{class} which contains no equations.  Another
implication is that an invalid program can be transformed into a valid
program by replacing all restricted keywords with \code{class}, e.g.
when incorrectly trying to use a \code{record} in a connection,
because the keyword \code{record} has the same restrictions as the
\code{connector} keyword, except that \code{record} is explicitly not
allowed in connections, but \code{class} is, as long as it fulfills
the restrictions.

It is currently not known if this goal will be fully met.  In most
cases it could be done, but things like \code{package} and
\code{function} might be problematic.

\section{Arrays and matrices}
\label{sec:arrays}

The concept of arrays in Modelica have not been thoroughly examined as
of writing.  Most of the basic properties of the type system should be
clear, but there are some points worth noting.


\subsection{Overloaded array operations}
\label{sec:arrayop}

The exact meaning of multiplication where one or more of the operands
are arrays is currently being defined.  Similarly for other
operations.  The semantics specified here should not be regarded as an
absolute reference to what these operations should mean, but rather as
a description of how the overloading of operators works.


\section{Functions}
\label{sec:functions}

The semantics of functions are yet to be defined.  What is cleared is
that it should be possible to use positional arguments that depends on
the order of the \code{input} components of the function definition.
It should also be possible to use named arguments matching against the
names of the components in the definition.  Furthermore, all uses of a
function should be type-checked to some extent.

How all this integrates into the type system and the general semantics
of Modelica is yet to be determined.  For simple cases a very
simplistic semantic description can be used, but for some cases, where
the sizes of array dimensions are unknown and depend of each other,
either an extended type system is needed, or the concept of implicit
function instantiation probably needs to be introduced.

For the purposes of this specification, a simplistic model where all
formal parameter types needs to be fully determinable from the
definition is used.  The algorithmic (runtime) semantics is left
unspecified.


\section{Connections}
\label{sec:connections}

Connections between objects are introduced by the \code{connect}
construct in the equation part of a class declaration.  The
\code{connect} construct takes two references to connectors, each of
which is either an element of the same class as the \code{connect}
construct or an element of one of its components. The connectors are
connected to produce equation according to the rules below.  Each
connector reference has either the syntactic form \code{c}, where
\code{c} is a connector instance in the class containing the
\code{connect} construct, or \code{m.c}, where \code{m} is the name of
a component or an array of components of the class containing the
\code{connect} construct, and \code{c} is the name of a connector
variable in the component \code{m}.


\subsection{Connection sets}
\label{sec:connectsets}

To create equations from the \code{connect} constructs, the connected
variables are collected in \firstref{connection sets}.

\begin{Def}{Connection sets}
  A connection set is a set $C$ of variables connected by means of
  \code{connect} constructs. A connection set contains either flow or
  non-flow variables, but never both.
\end{Def}

\begin{Def}{Inner and outer connectors}
  In an object $M$, each connector element of that class is called an
  \emph{outer connector} with respect to $M$. Each connector element of
  elements of $M$ is called an \emph{inner connector} with respect to
  $M$.
\end{Def}

When a \code{connect(a,b)} construct is encountered while
instantiating a class \code{C}, the component names \code{a} and
\code{b} are checked to be of the same type (see section
\ref{sec:typeq}). Then \code{a} and \code{b} are decomposed into their
public primitive components. Each subcomponent of \code{a} forms a
connection set with its corresponding subcomponent of \code{b}.

If several \code{connect(a,b)} constructs are encountered during
instantiation of a class, the resulting connection sets are merged to
a collection of connection sets $C$ so that if a component $x$ is
in two different connection sets $S_1$ and $S_2$, they the union $S_1
\cup S_2$ is a subset of one of the sets in $C$. Each component is in
exactly one of the sets in $C$.

\subsection{Equations}
\label{sec:coneq}

Each connection set is used to generate one or more equations. In the
case of variables declared with the \code{flow} type modifier, the
equation generated is a sum-to-zero equation, as in equation
\ref{eq:flow}.  The coefficient $d_v$ is $1$ if the component $v$ was
added to the connection set from an inner connector, and $-1$ if it
was added from an outer connector.

\begin{equation}
  \label{eq:flow}
  \sum_{v \in C} d_v v = 0
\end{equation}

In the case of non-flow components a number of simple equations is
generated. If the connection set contains $n$ components $c_1 \ldots
c_n$, equations to the effect of $c_1=c_2=\cdots=c_n$ are generated,
as in \ref{eqn:nonflow}.

\begin{eqnarray}
  \label{eqn:nonflow}
  c_1     & =      & c_2 \notag\\
  c_2     & =      & c_3 \notag\\
          & \vdots & \notag\\
  c_{n-1} & =      & c_n  
\end{eqnarray}


\subsection{Example}
\label{sec:csetex}

This section contains a short example of the use of connections in
Modelica, and shows the corresponding connection sets and generated
equations.  The Modelica source is shown in figure \ref{fig:csetex1}
and declares a connector \code{C} and models \code{A} and \code{M}.
The model that is instantiated at the top level is \code{M}, as it is
the last model in the file.

\begin{figure}[htbp]
\begin{boxedverbatim}
connector C
  Real x;
  flow Real y;
end C;

model A
  C con1, con2;
end A;

model M
  C con;
  A a1, a2;
  Real y;
equation
  connect(con,a1.con1);
  connect(a1.con1,a2.con1);
  connect(a1.con2,a2.con2);
  y = con.y;
end M;
\end{boxedverbatim}
  \caption{\code{connect} example}
  \label{fig:csetex1}
\end{figure}

Connection sets are generated at two different levels in this example.
While instantiating the model \code{M}, the three \code{connect}
statements creates the connection sets described in figure
\ref{fig:csetex2}, and the two instances of the model \code{A}
(components \code{a1} and \code{a2} in model \code{M}) create the
connection sets in figure \ref{fig:csetex3}.  Each component in the
sets are marked with a label indicating whether they were added from
an inner or an outer connector.

\newcommand{\couter}[1]{\code{#1}^{\text{outer}}}
\newcommand{\cinner}[1]{\code{#1}^{\text{inner}}}

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \couter{con.x}, \cinner{a1.con1.x}, \cinner{a2.con1.x} \right\}$
    $\left\{ \cinner{con.y}, \cinner{a1.con1.y}, \cinner{a2.con1.y} \right\}$
    $\left\{ \cinner{a1.con2.x}, \cinner{a2.con2.x} \right\}$
    $\left\{ \cinner{a1.con2.y}, \cinner{a2.con2.y} \right\}$
    \caption{Connection sets from \code{M}}
    \label{fig:csetex2}
  \end{center}
\end{figure}

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \couter{a1.con1.x}, \couter{a1.con2.x} \right\}$
    $\left\{ \couter{a1.con1.y}, \couter{a1.con2.y} \right\}$
    $\left\{ \couter{a2.con1.x}, \couter{a2.con2.x} \right\}$
    $\left\{ \couter{a2.con1.y}, \couter{a2.con2.y} \right\}$
    \caption{Connection sets from \code{A}}
    \label{fig:csetex3}
  \end{center}
\end{figure}

The equations generated from these connection sets, together with the
last equation in the model \code{M} is shown in figure
\ref{fig:csetex4}.

\begin{figure}[htbp]
  \begin{center}
    \begin{eqnarray*}
      \code{con.x}     &=& \code{a1.con1.x} \\
      \code{a1.con1.x} &=& \code{a2.con1.x} \\
      -\code{con.y} + \code{a1.con1.y} + \code{a2.con1.y} &=& 0 \\
      \code{a1.con2.x} &=& \code{a2.con2.x} \\
      \code{a1.con2.y} + \code{a2.con2.y} &=& 0 \\
      \code{a1.con1.x} &=& \code{a1.con2.x} \\
      -\code{a1.con1.y} - \code{a1.con2.x} &=& 0 \\
      \code{a2.con1.x} &=& \code{a2.con2.x} \\
      -\code{a2.con1.y} - \code{a2.con2.x} &=& 0
    \end{eqnarray*}
    \caption{Equations}
    \label{fig:csetex4}
  \end{center}
\end{figure}

\chapter{The Target language: Flat Modelica}
\label{cha:target}

The formal semantic specification in chapter \ref{cha:formsem}
specifies the semantics of Modelica by showing how it is translated
into another, simpler, language.  The translation is a sort of
flattening of the object-oriented structure of the model.  This
chapter describes the format of the output of the translator.

\section{Requirements}

There are different requirements that can be placed on the output
format, all of which are not possible to meet simultaneously.

\begin{enumerate}
\item The output should contain all the information gathered from the
  analysis of the Modelica source.
\item The output should be easily read by a human.
\item The output should be easily parsed by a computer.
\item The output should be able to be fed to an existing equation
  solver.
\item The target language needs to be able to express everything that
  can be expressed by the Modelica language
\end{enumerate}



The target language needs to be able to express everything that can be
expressed by the Modelica language, but it may do so in a much less
structured way.  The major part of the translator output consists of a
flat list of equations which are the result of instantiating the main
model of the source file and its subcomponents.


\section{Flat Modelica}
\label{sec:flatform}

The language produced by the translator is similar to Modelica, but
with a few restrictions and extensions.

The following restrictions apply:

\begin{itemize}
  
\item Flat models contain only components of predefined types.
  Predefined attributes, e.g. \code{start}, \code{unit}, \code{min},
  \code{max}, \ldots{} are declared as separate variables.
  
\item A flat model has one declaration section, optionally followed by
  an equation section, which is followed by zero or more algorithm
  sections.
  
\item No modifications are used, i.e. equation modifications made in
  the Modelica source code are stated in the equation section of the
  flat representation.  Redeclarations are taken care of while
  flattening the model.
  
\item No connect statements are used, i.e. the corresponding
  connection equations are stated.
  
\item For loops are not used in equations.  They are unrolled in the
  flat representation.

\end{itemize}

The following extensions are made:

\begin{itemize}
  
\item All array components are declared separately.  If the Modelica
  model contains the declaration

\begin{boxedverbatim}
    Real x[2,3];
\end{boxedverbatim}
  
  the flat model will contain the following declarations:
  
\begin{boxedverbatim}
    Real x[1,1];
    Real x[1,2];
    Real x[1,3];
    Real x[2,1];
    Real x[2,2];
    Real x[2,3];
\end{boxedverbatim}
  
  This means that the brackets in declaration do not denote array
  size, as they do in normal Modelica.
  
  This is a consequence of how the semantic specification looks at the
  components.  Using the simple \codebox{x[2,3]} could be done instead, as it
  is shorter and introduces no ambiguities.
  
\item Identifiers may contain dots (\code{.}) (resulting from
  subcomponents in the originating Modelica code).  Identifiers may
  also contain subscripts, as in \code{x[1]}.  This is a consequence
  of the fact that all array components are declared separately.

\item Automatic type conversions defined in the Modelica semantics,
  e.g.  from an \code{Integer} \code{i} to \code{Real}, are stated
  using the target type name as conversion operator, i.e.
  \code{Real(i)}.
  
\item A new postfix subscripting operator is introduced.  In the flat
  model, it is necessary to be able to subscript expression, so the
  syntax \code{expression[x]} is allowed.  This is not allowed in
  Modelica.

\item A a special kind of equation \codebox{ident ::= expression} is
  used to indicate that \code{ident} is not equal to
  \code{expression}, but rather \emph{defined as} \code{expression}.
  This is used for splitting up equations between two expressions
  which contain subcomponents.  If one of the expressions are not a
  simple name, a temporary name is introduced for that expression, and
  the name is used instead.

\item Almost no overloading of operators occurs in the flat Modelica.
  If a model contains an array multiplied by a scalar, the flat model
  does not use the multiplication sign, but an operator that is
  specialized for that particular operation.
  
  The normal integer and real arithmetic operators are still
  overloaded, but they should not, really.
  
\item Due to the extensions a flat model representation is not valid
  Modelica.  Therefore, the class definition in the flat code is
  declared as \code{fclass} to differentiate it from Modelica's
  \code{class}.

\end{itemize}

The output of the translator also has the following properties:

\begin{itemize}

\item The order of equations is undefined.
  
\item The order of statements in each algorithm section is kept
  intact, but the order in which the algorithm sections appear is
  undefined.
  
\end{itemize}

The flat Modelica does not exactly meet the requirements described in
the previous section.

\begin{enumerate}
  
\item Most information gathered from the analysis is included.  Some
  type information is lost, though.  The arithmetic operations on
  scalars and the equality sign are still overloaded.  This is to
  improve readability.  Changing the syntax to include this
  information is very easy.

\item The output looks reasonably much like Modelica, so a person
  knowledgeable of Modelica syntax should have no problem understanding
  the output.
  
\item Parsing of the flat Modelica has not been explored. It should
  possible to write a parser that will accept and understand flat
  Modelica.  One thing that may cause trouble is the extension where
  array subscripting may be allowed on arbitrary expressions.

\item Feeding the output to an equation solver needs either a special
  parser for the solver or a filtering step to rewrite the flat
  Modelica to a syntax understood by the solver.

  
\item Everything in Modelica is expressible in flat Modelica, although
  obviously, structural information is lost.

\end{enumerate}


\chapter{Translation overview}
\label{cha:system}


The semantic specification is written as a translation from Modelica
to a target language called flat Modelica (see chapter \ref{cha:target}).  The
translation is performed in several steps, which are outlined in this
chapter.

\begin{figure}[htbp]
  \begin{center}
    \input{transfig.tex}
    \centerline{\box\graph}
    \caption{Translation steps}
    \label{fig:transsteps}
  \end{center}
\end{figure}

A schematic view of the translation steps are show in figure
\ref{fig:transsteps}.  The box labeled ``RML'' shows what parts of the
translation are performed and handled by the RML specification.

\section{Lexical analysis and parsing}
\label{sec:laxparse}

The lexical analyzer and parser are not really part of the semantic
specification, and this report will not go into detail about the
parsing of Modelica.  It is based on the Modelica grammar as specified
in the Modelica specification, and is written using a parser generator
called PCCTS\cite{pccts}.  This generates a parser in C, which is
separately compiled and linked with the RML specification.

The Modelica source file being translated is first passed to the
lexical analyzer that scans the source for tokens, which it then
passes on to the parser.  The parser uses its grammar to build an RML
representation of the contents of the source file, which is then used
in the RML specification for further processing.


\section{Abstract syntax}
\label{sec:absyndesign}

The \firstref{abstract syntax} is closely modeled after the syntactic
structure, and is defined in the module \code{Absyn} (section
\ref{src:absyn}).  It basically defines data structures for
representing the structure of the source file (the \firstref{abstract
  syntax tree}, or \firstref{AST}), which are used by the parser to
build a tree describing the source file.  There is a datatype for
representing a class definition, and the whole file is represented
using the datatype \code{Program}, which is defined as a list of
classes.

\section{Preparing the AST: SCode}
\label{sec:asttoscode}

That the AST keeps the structure of the source file has several
disadvantages when it comes to translating the program, especially if
the translation rules should be easy to read for a human.  To address
this problem, a preparatory transformation pass is introduced which
transforms the AST into an intermediate form, called \firstref{SCode}.
This intermediate form contains no more information than the abstract
syntax, but merely restructures the tree representation in it.
Besides some minor simplifications the SCode structure differs from
the abstract syntax in the following important respects:

\begin{description}
\item[All components are described separately]
  
  In the source and in the abstract syntax several components in a
  class definition can be declared at once, as in \codebox{Real x,
    y[17];}.  In the SCode this is represented as two unrelated
  declarations, as if it had been written \codebox{Real x; Real
    y[17];}.

\item[Class declaration sections]
  In a Modelica class declaration the \code{public}, \code{protected},
  \code{equation} and \code{algorithm} sections may be included in any
  number and in any order, with an implicit \code{public} section
  first.  In the SCode these sections are collected so that all
  \code{public} and \code{protected} sections are combined into one
  section, while keeping the order of the elements.  The information
  about which elements were in a \code{protected} section is stored
  with the element itself.

\item[Modifications]
  Modifications are stored using the data types in the \code{Mod}
  module (section \ref{src:mod}).
\end{description}

One might have thought that more work could be done at this stage,
such as expression type analysis and name resolution.  But due to the
nature of the Modelica language, the only way to know anything about
how the names will be resolved during instantiation is to do a more or
less full instantiation.  It is possible to analyze a class
declaration and find out what the parts of the declaration would mean
if the class was to be instantiated as-is, but since it is possible to
modify much of the class while instantiating it that analysis would
not be of much use.

\section{Instantiation}
\label{sec:instantiation}

The major part of the translation procedure, as described by the RML
specification is the translation from SCode to hybrid
differential-algebraic equations (hybrid DAEs).

A Modelica source file contains only definitions of models and other
classes, which does not really have any semantic meaning in terms of
equations, since the equations appear when a model definition is
\emph{used} to create an instance of that model.
                                                 
To give a Modelica source file a meaning there is a convention that
the last class, which should be a model, is instantiated as the
top-level model.  In a graphical modeling environment the situation
will of course be different.

To go into detail exactly how the instantiation works here would be
too lengthy, but a brief overview is given below.


\subsection{Instantiation environment}
\label{sec:instenv}

When instantiating a class, certain information is available about
what has been instantiated before, and what set of modifiers are
currently applicable to the class being instantiated.

\subsection{Class instantiation}
\label{sec:eleminst}

Instantiation of a class is done by the relation \code{Inst.inst\_class}


\section{Static expression analysis}
\label{sec:static}

The module \code{Static} contains relations that perform static
analysis and constant propagation on expressions.  The primary reason
to analyze expressions is to check their types, and make sure that
there are no type errors.  Constant propagation is used whenever the
translator needs to know the actual value of an expression.  The
module is described in section \ref{src:static}, with the following
highlights.

\begin{itemize}
\item The relation \code{elab\_exp} (\ref{src:static:elabexp})
  analyzes an expression and produces two results: a new expression
  and a set of properties.  The new expression is of type
  \code{Exp.Exp} (\ref{src:exp}) and is much more specific than the
  abstract syntax expressions.  For each needed type conversion in the
  expression, an explicit type conversion operation is inserted, and
  the operators that are overloaded in the abstract syntax are
  replaced by non-overloaded counterparts.
  
  The set of properties describes the type of the expression (see
  section \ref{sec:types}), and its \firstref{variability}, which
  basically indicates whether the expression is constant or not.

\item The relation \code{ceval} evaluates an expression and gives the
  result as a \code{Values.Value} (section \ref{src:values}).  This
  can obviously only be done for constant expressions.
\end{itemize}

\section{Equation transformations}
\label{sec:eqtrans}

An equation in the equation section of a Modelica model can take
several forms, and to describe the semantics of an equation, different
transformations are applied to them.


\subsection{Subcomponent equation expansion}

\begin{figure}[htbp]
  \begin{center}
    \begin{boxedverbatim}
      model M
        real x[3], y[3];
      equation
        x = y;
      end M;
    \end{boxedverbatim}
    \caption{Array component equation}
    \label{fig:arreq}
  \end{center}
\end{figure}

\begin{figure}[htbp]
  \begin{center}
    \begin{boxedverbatim}
      model M
        real x[3], y[3];
      equation
        x[1] = y[1];
        x[2] = y[2];
        x[3] = y[3];
      end M;
    \end{boxedverbatim}
    \caption{Expanded array equations}
    \label{fig:arreqexp}
  \end{center}
\end{figure}

When two arrays are equated, as in figure \ref{fig:arreq}, the
equation has the same meaning as if all the array elements were
equated.  Thus, in the output the equation is split into one equation
for each pair of array elements, as in figure \ref{fig:arreqexp}.

To be able to accomplish this, the possibility to index arbitrary
array expressions, and not only components, needed to be added to the
output language.

Likewise, if two structured components are equated, the equation is
expanded to one equation for each pair of public
components.

These two transformations causes problems in the output if either the
left-hand side or the right-hand side of the equation is a complex
expression and not a name of a component.  The Modelica syntax does
not allow the concept of expression subscripting or of picking
subcomponent from complex expressions.  In the flat Modelica output
(see chapter \ref{cha:target}) this is solved in two different ways.
For arrays, an expression subscripting operator is introduced, which
allowd things like \codebox{(A*B)[3,4]}.  For expressions of a
composite type, a new identifier is introduced, which is defined to be
identical to the expression.  Then this name is used to look up
subcomponents.  The name is constructed by concatenating the name
\code{\_\_TMP\_\_} with a unique integer, forming a name that looks
something like \code{\_\_TMP\_\_17}.

\section{Class restriction inference}
\label{sec:classinf}

To be able to determine if a class definition or a variable can be
used under certain circumstances it is necessary to check whether it
adheres the restrictions currently imposed on it. If the class is
declared with one of the restricted keywords listen in table
\ref{tab:clrestr}, it is immediately known, but when the class is
declared using the \code{class} keyword, the definition has to be
scanned to see what restrictions it breaks.

This is done for each variable as it is instantiated, using the state
machine in the file \filename{classinf.rml} (see section
\ref{src:classinf}).  While instantiating a class the current state is
kept in a variable of type \code{ClassInf.State}.  It is initialized
with the keyword used to declare the class using the relation
\code{ClassInf.start}.  If the keyword was one of the restricted
forms, the state will be initialized to a state that directly
corresponds to that form, and it will never change to another state.
If the keyword was \code{class}, the state is initialized to
\code{ClassInf.UNKNOWN}.

Transitions in the state machine are triggered by events signaled
during instantiation indicating that some piece of information has been
encountered which affects the class restriction. The defined events
are listed in table \ref{tab:classinfevents}.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \hline
      \code{FOUND\_EQUATION} & The class is now known to contain at
      least one equation. \\
      \code{NEWDEF} & This class is not derived from another class
      with the \code{class A = B} construct. \\
      \hline
    \end{tabular}
    \caption{Class restriction inference events}
    \label{tab:classinfevents}
  \end{center}
\end{table}

After instantiation of a class is complete, the state of the machine
can be checked against a desired restriction to see if the class
definition fulfills it, using the relation \code{valid}
(\ref{src:classinf:valid}).

\section{Representation of types}
\label{sec:typerep}

When instantiating, each component is assigned a type descriptor which
is constructed from the type used in the component declaration
combined with all applicable modifications.

The type descriptors are used in several places in the semantic
specification, but two distinct types of usage can be noted.

\begin{description}
\item[Subcomponent lookup] To look up components inside a component, a
  description of all its subcomponents are needed.  This description
  must contain information about which components are protected.  This
  kind of lookup is usually done in places where all type and
  component attributes are needed to determine such things as what
  components can be connected to each other.
\item[Type checking of expressions] Expressions are checked for type
  incompatibilities, which means that information about the types of
  components has to be known.  In this context less information is
  needed.  Either a component is of one of the built-in types, or it
  is a complex type, but then only the names and types of the public
  subcomponents need to be known.
\end{description}

These two needs could be met by two different data types, and a
previous version of the specification did it this way.  But having two
data types that essentially does the same thing is more confusing than
helpful, so they were reduced to only one.


\section{DAE representation}
\label{sec:dearep}

The DAEs are collected in a data structure defined in the module
\code{DAE} (see section \ref{src:dae}).  This structure is basically a
linear list where each element is either a variable declaration, an
equation or an algorithm.



\section{Output of equations}
\label{sec:output}

As the last stage of the translation the internal representation of
the hybrid DAEs are written out in the format described in chapter
\ref{cha:target}.


\section{An example}

To show how the translation of a Modelica model is done in a more
visual manner, this section gives a small example of a model, and how
it is translated to a flat representation.


\subsection{The model}

The source model is given in figure \ref{fig:modelsource}.  It is a
very simple electrical circuit, with a AC voltage source and two
capacitors.

\begin{figure}[htbp]
  \input{example-1.tex}
  \caption{Model source}
  \label{fig:modelsource}
\end{figure}


\subsection{First transformation}

Th first this the translator does it to transform the abstract syntax
tree representing the model into an SCode representation.  This mainly
effects the \code{Circuit} model definition, giving something that is
described in figure \ref{fig:ex-scode}, using a pseudo-Modelica
representation.

\begin{figure}[htbp]
  \input{example-2.tex}
  \caption{SCode for \code{Circuit}}
  \label{fig:ex-scode}
\end{figure}


\subsection{Flattening}

The main translation step does several things simultaneously.  One
important part is the flattening of the hierarchical structure.  This
means that all composite components are split up in subcomponents, and
all ``atomic'' components \fixme{terminology} will receive a new name
that identifies it with a unique identifier in the global name space.
For instance, the voltage variable in the positive connector in the
capacitor named \code{C2} will get the global name \code{C2.p.v}.

The set of all components is listen with their global name in figure
\ref{fig:ex-flatname}.

\begin{figure}[htbp]
  \input{example-3}
  \caption{Global component names}
  \label{fig:ex-flatname}
\end{figure}


\subsection{Connection equations}

Generating equations from the connections in the model is done by
collecting the connected variables into connection sets (see section
\ref{sec:connectsets}).  There will be one set for each set of
connected voltage variables and one set for each set of connected
current variables, giving the connection sets in figure
\ref{fig:ex-csets}.  All connectors are inner connectors, which means
that the connection sets will generate the equations given in figure
\ref{fig:ex-eq}.

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \code{AC.p.v}, \code{C1.p.v}, \code{C2.p.v} \right\}$
    $\left\{ \code{AC.p.i}, \code{C1.p.i}, \code{C2.p.i} \right\}$
    $\left\{ \code{AC.n.v}, \code{C1.n.v}, \code{C2.n.v} \right\}$
    $\left\{ \code{AC.n.i}, \code{C1.n.i}, \code{C2.n.i} \right\}$
    \caption{Connection sets}
    \label{fig:ex-csets}
  \end{center}
\end{figure}

\subsection{Flat Modelica}

The output of the translator is shown in figure \ref{fig:ex-eq}, which
is the Flat Modelica version of the source model.  All the components
are expanded into their simple components.

\begin{figure}[htbp]
  \begin{center}
    \input{example-4}
    \caption{Flat Modelica output}
    \label{fig:ex-eq}
  \end{center}
\end{figure}

\chapter{Annotated formal semantics}
\label{cha:formsem}

This chapter contains the complete formal semantics of Modelica.  This
includes the RML source files, but the comments in the files are
converted to more readable text.

\section{Overview}

The specification is separated into a number of files, to modularize
it and to make it easier to maintain and to make the structure
clearer.  

\subsection*{Source files}

\listofsources

%\begin{landscape}
  
\input{main.tex}
%\input{absyn.tex}
%\input{exp.tex}
%\input{classinf.tex}
%\input{types.tex}
%\input{explode.tex}
%\input{inst.tex}
%\input{prefix.tex}
%\input{mod.tex}
%\input{algorithm.tex}
%\input{env.tex}
%\input{lookup.tex}
%\input{builtin.tex}
%\input{connect.tex}
%\input{staticexp.tex}
%\input{dae.tex}
%\input{dump.tex}

%\end{landscape}

\chapter{rmldoc \note{appendix}}
\label{cha:rmldoc}

{\codefont\verbatiminput{../tools/rmldoc}}

\bibliographystyle{plain}
\bibliography{report}

\begin{thebibliography}{blah}
 
% \bibitem{key:foo}
% I. M. Author, 
% ``Some Related Article I Wrote,''
% {\em Some Fine Journal}, Vol. 17, pp. 1-100, 1987.
 
\bibitem{drakboken}
A. V. Aho, R. Sethi, and J. D. Ullman,
{\em Compilers -- Principles, Techniques, and Tools,}
Addison-Wesley, 1986.
 
\bibitem{pf}
Peter Fritzson,
{\em Generating Practical Compilers from Natural Semantics,}
Draft, 1996.
 
\bibitem{pi}
Mikael Pettersson,
{\em Compiling Natural Semantics,}
Ph.D. thesis,
Linköping University, Dec 1995.
To appear as a volume in {\em LNCS},
Springer-Verlag, 1997.
 
\bibitem{pike}
Idonex AB,
{\em The Pike programming language},
{\tt http://pike.idonex.se/}

\bibitem{modelicawww}
Modelica, {\tt http://www.dynasim.se/Modelica/}

\end{thebibliography}

\printindex

\end{document}
