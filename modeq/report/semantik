Semantik-noteringar	-*- outline -*-

* redeclare extends

Vad betyder "redeclare extends ..."

* Typer i ekvationer

Vilka variabler får man ha i ekvationer? Bara Real(Type) och
Integer(type)?

Hur hanteras strängar i ekvationer.

* connect

Exakt hur fungerar connect()?

Sista raden i connect-semantiken (B.2) måste vara fel.

* Kvalificerade identifierare

Vilka olika saker kan foo vara i "foo.bar"?

** En variabel (eller konstant) i scopet

    module Resistor
      Pin p,n;
      parameter Real r;
    equation
      p.i = n.i;
      (p.v - n.v) = p.i * r;
    end Resistor;

** En klass i scopet

Klassen kommer ofta att vara ett package.

    package Foo
      constant Real x = 17.0;
    end Foo;

    model Bar
      Real y = Foo.x;
    end Bar;

Men t.ex. i specialiseringar kan det vara vanligt med andra klasser.

    model Foo

      type Bar
        constant Real x = 17.0;
      end Bar;

      Bar b;
    end Foo;

    model Baz
      extends Foo(Bar.x = 4711.0);
    end Baz;

** Ett package i en fil "foo.mdc"

    module Foo
      Modelica.SIunit.Area a;
    end Foo;

* Hur funkar = i deklarationer

Om man deklarerar

    model M
      Foo x = y;
    end M;

Är det samma sak som:

    model M
      Foo x;
    equation
      x = y;
    end M;

eller är det bara startvärdet på x som påverkas?

* Allt är ekvationer

Tydligen så ska tilldelningar vid variabeldeklarationer betraktas som
ekvationer. Så

	model Foo
	  Real x = 17.0;
	end Foo;

är ekvavilent med

	model Foo
	  Real x;
	equation
	  x = 17.0;
	end Foo;

* Ersättning av ekvationer

Hilding tyckte visst att "x = 17" skulle ersättas av "x = 15" i N.

    model M
      Real x;
    equation
      x = 17;
    end M;

    model N
      M a(x=15);
    end N;

* EQUALMOD

    Type var = val;

Jag kommer på två olika fall.

** Type är en komplex typ eller en inbyggd typ

Skriv om till följande:

      Type var;
    equation
      var = val;

** Type är en specialtyp

Om Type är Real, Integer, String eller Boolean, eller ett derivat av
dem skrivs det om som om det stod:

    Type var(value = val);

Frågan är hur man ser om det är ett derivat. En lösning är ju att
alltid göra så här om det finns en variabel "value", men det är nog
ett dåligt sätt. Man skulle också kunna ha en "special"-flagga i
klassen som sedan ärvs.

* Conflicting modifications

If the grammar change of the "modification" production rule is made,
what are the semantic consequences?

Consider the following program:

	class Foo
	  parameter Real x = 17;
	end;

	class Bar
	  Foo a(x = 4711);
	  Foo b(x = 1) = a;
	end;

Does this even make sense when the class is not Real, Integer, String
or Boolean? The normal semantics for equality modifications is to
rewrite it as a separate equation, so it might not be a problem, other
than an implementation hassle.

	class Foo
	  parameter Real x = 17;
	end;

	class Bar
	  Foo a(x = 4711);
	  Foo b(x = 1);
	equation
	  b = a;
	end;

* What can you modify?

Both variables and class declarations?

* connect and array subscripts

If you write

	connect(a[<expression>],x)

does <expression> have to be a constant expression? Otherwise it seems
a little hard to generate connection sets.

* Inconsistencies

	constant input Real foo
