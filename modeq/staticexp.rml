module StaticExp :

  with "exp.rml"
  with "env.rml"
  with "lookup.rml"
  with "prefix.rml"
  with "types.rml"
  with "classinf.rml"

  relation elab_exp : (Env.Env, Prefix.Prefix, Exp.Exp)
	  => (Exp.Exp, Exp.Type, bool)
  relation elab_cref : (Env.Env, Prefix.Prefix, Exp.ComponentRef)
	  => (Exp.Exp, Exp.Type, bool)

end

(**
 ** Constant evaluation
 **)

relation elab_exp : (Env.Env, Prefix.Prefix, Exp.Exp)
	  => (Exp.Exp, Exp.Type, bool) =

  axiom	elab_exp(_,_, x as Exp.INTEGER(_)) => (x, Exp.T_INTEGER, true)
  axiom	elab_exp(_,_, x as Exp.REAL(_))    => (x, Exp.T_REAL,    true)
  axiom	elab_exp(_,_, x as Exp.STRING(_))  => (x, Exp.T_STRING,  true)
  axiom	elab_exp(_,_, x as Exp.BOOL(_))    => (x, Exp.T_BOOL,    true)

  rule	elab_cref(env, pre, cr) => (ce,t,c)
	---------------------------------------
	elab_exp(env, pre, Exp.CREF(cr)) => (ce,t,c)

  rule	elab_exp (env,pre,e1) => (e1', t1, c1) &
	elab_exp (env,pre,e2) => (e2', t2, c2) &
	elab_numtypes (e1',t1,e2',t2) => (e1'',e2'',t) &
	elab_binary (e1'', t, c1, op, e2'', t, c2) => (e, t', c)
	-------------------------------------------------------
	elab_exp (env,pre,Exp.BINARY(e1,op,e2)) => (e,t',c)

  rule	elab_exp (env,pre,e1) => (e1', t1, c1) &
	elab_exp (env,pre,e2) => (e2', t2, c2) &
	elab_numtypes (e1',t1,e2',t2) => (e1'',e2'',t)
	----------------------------------------------
	elab_exp (env,pre,Exp.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op,e2''),t,false)

  rule	(* FIXME: lookup function *)
	elab_exp_list (env,pre,args) => args'
	-------------------------------------
	elab_exp (env,pre,Exp.CALL(fn,args)) => (Exp.CALL(fn,args'),
						 Exp.T_REAL (*FIXME*),
						 false)

  axiom	elab_exp (_,_,Exp.TIME) => (Exp.TIME, Exp.T_REAL, false)

  rule	print "- elab_exp failed: " & Exp.dump_exp e & print "\n"
	---------------------------------------------------------
	elab_exp(_,_,e) => fail

end

(**)

relation elab_exp_list : (Env.Env, Prefix.Prefix, Exp.Exp list)
	  => Exp.Exp list =

  axiom	elab_exp_list (_,_,[]) => []

  rule	elab_exp (env,pre,e) => (e',_,_) &
	elab_exp_list (env,pre,es) => es'
	---------------------------------
	elab_exp_list (env,pre,e::es) => e'::es'

end

(**)

relation elab_cref : (Env.Env, Prefix.Prefix, Exp.ComponentRef)
	  => (Exp.Exp, Exp.Type, bool) =

  rule	elab_cref_subs (env,pre,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,_,vartype,_),
				       Types.TYPE(st, _),
				       ass) &
	Types.known_type st => t &
	elab_cref2 (env, pre, c', vartype, t, ass) => (exp,const) &
	print "    elab_cref " & Exp.dump_component_ref c &
	print " => " & Exp.dump_exp exp & print " (" &
	Exp.print_type t & print ")\n"
	-------------------------
	elab_cref(env, pre, c) => (exp, t, const)

  rule	print "- elab_cref fallthru\n"
	------------------------------
	elab_cref (_,_,_) => fail

end

(**)

relation elab_cref2 : (Env.Env, Prefix.Prefix,
		       Exp.ComponentRef, Types.VarType,
		       Exp.Type, Exp.Exp option) => (Exp.Exp, bool) =

	(* FIXME: Check type of expression anyway? *)
  axiom	elab_cref2 (_,_,cr, Types.VAR, _, _) => (Exp.CREF(cr), false)

  rule	elab_exp (env,pre,exp) => (exp', t', c) &
	c = true (* & *)
	(* t = t' *) (* FIXME: cast *)
	------------------------
	elab_cref2 (env,pre,cr,_,t, SOME(exp)) => ((*exp'*) Exp.CREF(cr), true)

  rule	print "# Constant or parameter without a value (I think)\n" &
	print "# component: " & Exp.dump_component_ref cr & print "\n"
	----------------------------------------------
	elab_cref2 (_,_,cr, _,_,_) => fail

end	

(**)

relation elab_cref_subs : (Env.Env, Prefix.Prefix, Exp.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, pre, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,pre,Exp.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, pre, ss) => (ss', const1) &
	elab_cref_subs(env,pre,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,pre,Exp.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(**)

relation elab_subscripts : (Env.Env, Prefix.Prefix, Exp.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,_,[]) => ([], true)

  rule	elab_subscript (env,pre,sub) => (sub',const1) &
	elab_subscripts (env,pre,subs) => (subs',const2) &
	bool_and (const1, const2) => const
	----------------------------------
	elab_subscripts (env,pre,sub::subs) => (sub'::subs',const)

end

(**)

relation elab_subscript : (Env.Env, Prefix.Prefix, Exp.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,_,Exp.NOSUB) => (Exp.NOSUB, true)

  rule	elab_exp (env,pre,sub1) => (sub1', T_INTEGER, const)
	----------------------------------------------------
	elab_subscript (env,pre,Exp.SUB1(sub1)) => (Exp.SUB1(sub1'), const)

  rule	elab_exp (env,pre,sub1) => (sub1', T_INTEGER, const1) &
	elab_exp (env,pre,sub2) => (sub2', T_INTEGER, const2) &
	bool_and(const1, const2) => const
	---------------------------------
	elab_subscript (env,pre,Exp.SUB2(sub1,sub2))
	  => (Exp.SUB2(sub1',sub2'), const)

  rule	elab_exp (env,pre,sub1) => (sub1', T_INTEGER, const1) &
	elab_exp (env,pre,sub2) => (sub2', T_INTEGER, const2) &
	elab_exp (env,pre,sub3) => (sub3', T_INTEGER, const3) &
	bool_and(const1, const2) => const3 &
	bool_and(const3, const2) => const
	---------------------------------
	elab_subscript (env,pre,Exp.SUB3(sub1,sub2,sub3))
	  => (Exp.SUB3(sub1',sub2',sub3'), const)

end

(**)

relation elab_numtypes : (Exp.Exp, Exp.Type, Exp.Exp, Exp.Type)
	  => (Exp.Exp, Exp.Exp, Exp.Type) =

  axiom	elab_numtypes (e1, Exp.T_INTEGER, e2, Exp.T_INTEGER)
	  => (e1, e2, Exp.T_INTEGER)
  axiom	elab_numtypes (e1, Exp.T_REAL, e2, Exp.T_REAL) => (e1, e2, Exp.T_REAL)

  rule	cast_to_real e1 => e1'
	----------------------
	elab_numtypes (e1, Exp.T_INTEGER, e2, Exp.T_REAL) => (e1', e2,
							      Exp.T_REAL)

  rule	cast_to_real e2 => e2'
	----------------------
	elab_numtypes (e1, Exp.T_REAL, e2, Exp.T_INTEGER) => (e1, e2',
							      Exp.T_REAL)

  rule	print "- elab_numtypes fallthru\n"
	----------------------------------
	elab_numtypes (_,_,_,_) => fail

end

(**)

relation cast_to_real : Exp.Exp => Exp.Exp =

  rule	print "  casting " & int_string i => is & print is &
 	print " to real\n" &
	int_real i => r
	---------------
	cast_to_real Exp.INTEGER(i) => Exp.REAL(r)

  rule	print "  Casting " & Exp.dump_exp e & print " to real\n"
	-------
	cast_to_real e => Exp.CAST_TO_REAL(e)

end

(**)

relation elab_binary : (Exp.Exp, Exp.Type, bool,
			Exp.BinOp,
			Exp.Exp, Exp.Type, bool) => (Exp.Exp, Exp.Type, bool) =

	(* ADD *)

  rule	int_add(i1,i2) => i
	------------------------------------------------
	elab_binary (Exp.INTEGER(i1),_,true,Exp.ADD,Exp.INTEGER(i2),_,true)
	  => (Exp.INTEGER(i), Exp.T_INTEGER, true)
			
  rule	real_add(i1,i2) => i
	------------------------------------------------
	elab_binary (Exp.REAL(i1),_,true,Exp.ADD,Exp.REAL(i2),_,true)
	  => (Exp.REAL(i), Exp.T_REAL, true)
			
  axiom	elab_binary (e1,Exp.T_INTEGER,_,Exp.ADD,e2,Exp.T_INTEGER,_)
	  => (Exp.BINARY(e1,Exp.ADD,e2), Exp.T_INTEGER, false)
			
  axiom	elab_binary (e1,Exp.T_REAL,_,Exp.ADD,e2,Exp.T_REAL,_)
	  => (Exp.BINARY(e1,Exp.ADD,e2), Exp.T_REAL, false)
			
	(* SUB *)

  rule	int_sub(i1,i2) => i
	------------------------------------------------
	elab_binary (Exp.INTEGER(i1),_,true,Exp.SUB,Exp.INTEGER(i2),_,true)
	  => (Exp.INTEGER(i), Exp.T_INTEGER, true)
			
  rule	real_sub(i1,i2) => i
	------------------------------------------------
	elab_binary (Exp.REAL(i1),_,true,Exp.SUB,Exp.REAL(i2),_,true)
	  => (Exp.REAL(i), Exp.T_REAL, true)
			
  axiom	elab_binary (e1,Exp.T_INTEGER,_,Exp.SUB,e2,Exp.T_INTEGER,_)
	  => (Exp.BINARY(e1,Exp.SUB,e2), Exp.T_INTEGER, false)
			
  axiom	elab_binary (e1,Exp.T_REAL,_,Exp.SUB,e2,Exp.T_REAL,_)
	  => (Exp.BINARY(e1,Exp.SUB,e2), Exp.T_REAL, false)

	(* MUL *)

  rule	int_mul(i1,i2) => i
	------------------------------------------------
	elab_binary (Exp.INTEGER(i1),_,true,Exp.MUL,Exp.INTEGER(i2),_,true)
	  => (Exp.INTEGER(i), Exp.T_INTEGER, true)
			
  rule	real_mul(i1,i2) => i
	------------------------------------------------
	elab_binary (Exp.REAL(i1),_,true,Exp.MUL,Exp.REAL(i2),_,true)
	  => (Exp.REAL(i), Exp.T_REAL, true)
			
  rule	print "elab_binary int " & Exp.dump_exp e1 & print " * " &
	Exp.dump_exp e2 & print "\n" &
	bool_and (c1,c2) => const
	-------------------------
	elab_binary (e1,Exp.T_INTEGER,c1,Exp.MUL,e2,Exp.T_INTEGER,c2)
	  => (Exp.BINARY(e1,Exp.MUL,e2), Exp.T_INTEGER, false)
			
  rule	print "elab_binary real " & Exp.dump_exp e1 & print " * " &
	Exp.dump_exp e2 & print "\n" &
	bool_and (c1,c2) => const
	-------------------------
	elab_binary (e1,Exp.T_REAL,c1,Exp.MUL,e2,Exp.T_REAL,c2)
	  => (Exp.BINARY(e1,Exp.MUL,e2), Exp.T_REAL, const)

	(* failure *)
  rule	print "- elab_binary failed " &
	Exp.dump_exp e1 & print " (" & Exp.print_type t1 & print ") o " &
	Exp.dump_exp e2 & print " (" & Exp.print_type t2 & print ")\n"
	---------------------------------------------
	elab_binary(e1, t1, c1, op, e2, t2, c2) => fail
			
end

(**)

relation is_const : Exp.Exp => () =

  axiom	is_const Exp.INTEGER(_)
  axiom	is_const Exp.REAL(_)
  axiom	is_const Exp.STRING(_)
  axiom	is_const Exp.BOOL(_)

end

(**)

relation ceval : (Exp.Exp, Exp.Type) => Exp.Exp =

  axiom	ceval (x as Exp.INTEGER(_), t) => x
  axiom	ceval (x as Exp.REAL(_), t) => x
  axiom ceval (x as Exp.STRING(_), t) => x
  axiom ceval (x as Exp.BOOL(_), t) => x

(*
  rule	ceval_cref c => exp
	-------------------
	ceval (Exp.CREF(c), t) => exp

	(* Numerical *)

  rule	ceval (lh, T_REAL) => REAL(lhv) &
	ceval (rh, T_REAL) => REAL(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (BINARY(lh, ADD, rh), T_REAL) => REAL(sum)

  rule	ceval (lh, T_INTEGER) => INTEGER(lhv) &
	ceval (rh, T_INTEGER) => INTEGER(rhv) &
	int_add(lhv, rhv) => sum
	------------------------
	ceval (BINARY(lh, ADD, rh), T_INTEGER) => INTEGER(sum)


  rule	ceval (lh, T_REAL) => REAL(lhv) &
	ceval (rh, T_REAL) => REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (BINARY(lh, SUB, rh), T_REAL) => REAL(sum)

  rule	ceval (lh, T_INTEGER) => INTEGER(lhv) &
	ceval (rh, T_INTEGER) => INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (BINARY(lh, SUB, rh), T_INTEGER) => INTEGER(sum)

  rule	ceval lh => REAL(lhv) &
	ceval rh => REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval ((BINARY(lh, MUL, rh), T_REAL)) => REAL(sum)

  rule	ceval lh => INTEGER(lhv) &
	ceval rh => INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval ((BINARY(lh, MUL, rh), T_INTEGER)) => INTEGER(sum)


  rule	ceval lh => REAL(lhv) &
	ceval rh => REAL(rhv) &
	real_div(lhv, rhv) => sum
	-------------------------
	ceval ((BINARY(lh, DIV, rh), T_REAL)) => REAL(sum)

  rule	ceval lh => INTEGER(lhv) &
	ceval rh => INTEGER(rhv) &
	int_div(lhv, rhv) => sum
	------------------------
	ceval ((BINARY(lh, DIV, rh), T_INTEGER)) => INTEGER(sum)


  rule	ceval lh => REAL(lhv) &
	ceval rh => REAL(rhv) &
	real_pow(lhv, rhv) => sum
	-------------------------
	ceval ((BINARY(lh, POW, rh), T_REAL)) => REAL(sum)

  rule	ceval lh => INTEGER(lhv) &
	ceval rh => INTEGER(rhv) &
	int_pow(lhv, rhv) => sum
	------------------------
	ceval ((BINARY(lh, POW, rh), T_INTEGER)) => INTEGER(sum)


  rule	ceval rh => REAL(rhv) &
	real_neg(rhv) => rhv'
	-------------------------
	ceval ((UNARY(UMINUS, rh), T_REAL)) => REAL(rhv')

  rule	ceval rh => INTEGER(rhv) &
	int_neg(rhv) => rhv'
	--------------------
	ceval ((UNARY(UMINUS, rh), T_INTEGER)) => INTEGER(rhv')


  rule	ceval rh => REAL(rhv)
	---------------------
	ceval ((UNARY(UPLUS, rh), T_REAL)) => REAL(rhv)

  rule	ceval rh => INTEGER(rhv)
	------------------------
	ceval ((UNARY(UPLUS, rh), T_INTEGER)) => INTEGER(rhv)


	(* Boolean *)

  rule	ceval lh => BOOL(lhv) &
	ceval rh => BOOL(rhv) &
	bool_and(lhv, rhv) => con
	-------------------------
	ceval LBINARY(lh, AND, rh) => BOOL(con)

  rule	ceval lh => BOOL(lhv) &
	ceval rh => BOOL(rhv) &
	bool_or(lhv, rhv) => disj
	-------------------------
	ceval LBINARY(lh, OR, rh) => BOOL(disj)

  rule	ceval rh => BOOL(rhv) &
	bool_not rhv => rhv'
	--------------------
	ceval LUNARY(NOT, rh) => BOOL(rhv')

	(* Relations *)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_lt(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, LESS, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_le(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, LESSEQ, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_gt(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, GREATER, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_ge(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, GREATEREQ, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_eq(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, EQUAL, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_ne(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, NEQUAL, rh) => BOOL(b)
*)
end

(**)

and ceval_cref : Exp.ComponentRef => Exp.Exp =

  rule	print "# ceval_cref\n"
	----------------------
	ceval_cref c => fail

end

