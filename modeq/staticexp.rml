(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 static.rml
 ** module:      Static
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module does static analysis and constant evaluation of
 ** expressions.  The analyzed expressions are built using the
 ** constructors in the `Exp' module.  Also, a set of properties of
 ** the expressions is calculated during analysis.
 **)

module Static :

  with "absyn.rml"
  with "exp.rml"
  with "explode.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "interactive.rml"
  with "cache.rml"

  type Ident = string


  datatype Slot = SLOT of Types.FuncArg *  (* An argument to a function *)
			  bool *	   (* True if the slot has been filled, *)
					   (* i.e. argument has been given a value*)
			  Exp.Exp option   (* Contain the elaborated expression *)
                                           (* for the actual argument *)


  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp,bool,Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option)
  relation elab_graphics_exp : (Env.Env, Absyn.Exp) => (Exp.Exp,
							Types.Properties) 
	  (* Special relation for graphics annotations, because of inhomogenous *)
	  (* array of graphics primitives *) 
  relation elab_exp_list : (Env.Env, Absyn.Exp list,bool (* Implicit inst *)
			    , Interactive.InteractiveSymbolTable option) 
	    => (Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option)

  relation elab_exp_list_list : (Env.Env, Absyn.Exp list list, bool (* Implicit inst *)
				 , Interactive.InteractiveSymbolTable option) 
	  => (Exp.Exp list list, Types.Properties list list, Interactive.InteractiveSymbolTable option)

  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Types.Properties, SCode.Accessibility)
  relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	  => (Exp.Exp list, Types.Properties list, SCode.Accessibility list)
  relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool)

  (* Constant propagation *)
  relation ceval : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Values.Value, Interactive.InteractiveSymbolTable option)
  relation ceval_list : (Env.Env, Exp.Exp list, bool,
			 Interactive.InteractiveSymbolTable option) 
	  => Values.Value list
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef

  (* Property matching (type conversions etc.) *)

  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : (Absyn.Operator, Env.Env, Types.Type, Types.Type)
	  => (Exp.Operator * Types.Type list * Types.Type) list

  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp
end


with "dump.rml"
with "print.rml"
with "system.rml"
with "lookup.rml"
with "debug.rml"
with "inst.rml"
with "codegen.rml"
with "modutil.rml"
with "dae.rml"
with "util.rml"
with "rtopts.rml"
with "parse.rml"
with "classloader.rml"
with "mod.rml"
with "prefix.rml"

(** LS:
 ** - Expression elaboration
 **)

relation elab_exp_list : (Env.Env, Absyn.Exp list, bool, Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option ) =

  axiom	elab_exp_list (_,[],impl,st) => ([],[],st)

  rule	elab_exp (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list (env, e::rest,impl,st) => (exp::exps, p::props,st'') 
end

relation elab_exp_list_list : (Env.Env, Absyn.Exp list list, bool
			       , Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list list, Types.Properties list list, Interactive.InteractiveSymbolTable option ) =

  axiom	elab_exp_list_list (_,[],impl,st) => ([],[],st)

  rule	elab_exp_list (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list_list (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list_list (env, e::rest,impl,st) => (exp::exps, p::props,st'') 
end

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Types.Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

(* The types below should contain the default values of the attributes of the builtin
 * types. But since they are default, we can leave them out for now, unit="" is not 
* that interesting to find out.
*)
  axiom	elab_exp(_, Absyn.INTEGER(x),impl,st)
	  => (Exp.ICONST(x), Types.PROP(Types.T_INTEGER([]),true),st)
  axiom	elab_exp(_, Absyn.REAL(x),impl,st)
	  => (Exp.RCONST(x), Types.PROP(Types.T_REAL([]),   true),st)
  axiom	elab_exp(_, Absyn.STRING(x),impl,st)
	  => (Exp.SCONST(x), Types.PROP(Types.T_STRING([]), true),st)
  axiom	elab_exp(_, Absyn.BOOL(x),impl,st)
	  => (Exp.BCONST(x), Types.PROP(Types.T_BOOL([]),   true),st)

  rule	Debug.fprintln("setr", "elab_exp_cref") &
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr),impl,st) => (exp,prop,st) 

	(**  Binary and unary operations *)

  rule	Debug.fprintln("setr", "elab_exp_binary") &
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') &
	Debug.fprintln("eexpbin","types of binary exp t1:") &
	Debug.fcall("eexpbin",Types.print_type,t1) & 
	Debug.fprintln("eexpbin","\nt2:") &
	Debug.fcall("eexpbin",Types.print_type,t2) & 
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.BINARY(e1'',op',e2''),c) => exp' &
	Debug.fprintln("eexpbin", "operator deoverloaded, resulting type:") &
	Debug.fcall("eexpbin",Types.print_type,rtype) 
	---------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2),impl,st)
	  => (exp',Types.PROP(rtype,c),st'')

  rule	Debug.fprintln("setr", "elab_exp_unary") &
	elab_exp (env,e,impl,st) => (e',Types.PROP(t,c),st') &
 	operators(op, env, t, Types.T_NOTYPE) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	replace_operator_with_fcall(Exp.UNARY(op',e''),c) => exp'
	---------------------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e),impl, st)
	  => (exp', Types.PROP(rtype,c),st')
	
  rule	Debug.fprintln("setr", "elab_exp_lbinary") &
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.LBINARY(e1'',op',e2''),c) => exp'
	-----------------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2),impl,st)
	  => (exp', Types.PROP(rtype,c),st'')

  rule	Debug.fprintln("setr", "elab_exp_lunary") &
	elab_exp (env,e,impl,st) => (e',Types.PROP(t,c),st') &
 	operators(op, env, t, Types.T_NOTYPE) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	replace_operator_with_fcall(Exp.LUNARY(op',e''),c) => exp'
	----------------------------------------------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e),impl,st)
	  => (exp',Types.PROP(rtype,c),st')

  rule	Debug.fprintln("setr", "elab_exp_relation") &
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') & 
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.RELATION(e1'',op',e2''),c) => exp'
	-----------------------------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2),impl,st)
	  => (exp', Types.PROP(rtype,c),st'')

	(**  Conditional expressions *)

  rule	Debug.fprintln("setr", "elab_exp_ifexp") &
	elab_exp (env,e1,impl,st) => (e1', prop1,st') &
	elab_exp (env,e2,impl,st') => (e2', prop2,st'') &
	elab_exp (env,e3,impl,st'') => (e3', prop3,st''') &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	(*TODO elseif part *)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3,_),impl,st) => (e,prop,st''')

	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)

  rule	Dump.print_component_ref_str fn => fnstr &
	Debug.fprintl("setr", ["elab_exp_call: ",fnstr,"\n"]) &
	elab_call(env,fn,args,nargs,impl,st) => (e,prop,st') 
	--------------------------------------
	elab_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs)),impl,st) 
		=> (e,prop,st')

	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	Debug.fprintln("setr", "elab_exp_tuple") &
	Debug.print "\n#####################elab_exp tuple.####################" &
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
	Debug.print "\nThe elaborated tuple." &
	split_props(props) => (types, consts) &
	Debug.print "\n split_props was just executed."
	-------------------------------------
	elab_exp (env,Absyn.TUPLE(e as e1::rest),impl,st) 
	  => (Exp.TUPLE(e'),Types.PROP_TUPLE(Types.T_TUPLE(types), Types.TUPLE_CONST(consts)),st)


	(**  Array-related expressions *)

  rule	Debug.fprintln("setr", "elab_exp_range1") &
	elab_exp (env, start,impl,st) => (start', Types.PROP(start_t, c_start),st') &
	elab_exp (env, stop,impl,st') => (stop', Types.PROP(stop_t, c_stop),st'') &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop),impl,st)
	  => (Exp.RANGE(rt,start',NONE,stop'), Types.PROP(t, const),st'')

  rule	Debug.fprintln("setr", "elab_exp_range2") &
	elab_exp (env,start,impl,st) => (start', Types.PROP(start_t, c_start),st') &
	elab_exp (env,step,impl,st') => (step', Types.PROP(step_t, c_step),st'') &
	elab_exp (env,stop,impl,st'') => (stop', Types.PROP(stop_t, c_stop),st''') &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop),impl,st)
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), Types.PROP(t, const),st''')

  rule	Debug.fprintln("setr", "elab_exp_array") &
	elab_array (env, es,impl,st) => (es', Types.PROP(t, const)) & list_length es' => l&
	Types.elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es),impl,st)
	  => (Exp.ARRAY(at,a,es'),
	      Types.PROP(Types.T_ARRAY(Types.DIM(SOME(l)), t),
		   const),st)
	
  rule	Debug.fprintln("setr", "elab_exp_matrix") &
	elab_exp_list_list(env,es,impl,st) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	Debug.fprintln("setr", "calculated havereal\n") &
	elab_matrix_semi (env,es,impl,st,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	Types.elab_type t => at
	------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es),impl,st)
	  => (Exp.MATRIX(at,nmax,es'),
	      Types.PROP(Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 Types.T_ARRAY(Types.DIM(SOME(dim2)), t)),
		   c),st)

  rule	elab_code_type(env,c) => tp &
	Types.elab_type tp => tp'
	-------------------
	elab_exp (env, Absyn.CODE(c),impl,st) =>  (Exp.CODE(c,tp'),Types.PROP(tp,true),st)

  rule	Debug.fprint("failtrace", "- elab_exp failed: ") & 
	Debug.fcall("failtrace", Dump.print_exp, e) & 
	Debug.fprint("failtrace", "\n") 
	-----------------------------------------------------------
	elab_exp(_,e,_,_) => fail

end

(** relation: replace_operator_with_fcall
 ** Replaces a userdefined operator expression with a corresponding function call expression.
 ** Other expressions just passes through.
**)
relation replace_operator_with_fcall: (Exp.Exp,bool (*const*)) => Exp.Exp =

  axiom	replace_operator_with_fcall(Exp.BINARY(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,c))
	  
  axiom	replace_operator_with_fcall(Exp.UNARY(Exp.USERDEFINED(funcname),e1),c) 
	  => (Exp.CALL(funcname,[e1],false,c))

  axiom	replace_operator_with_fcall(Exp.LBINARY(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,c))

  axiom	replace_operator_with_fcall(Exp.LUNARY(Exp.USERDEFINED(funcname),e1),c) 
	  => (Exp.CALL(funcname,[e1],false,c))

  axiom	replace_operator_with_fcall(Exp.RELATION(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,c))
	  
  axiom	replace_operator_with_fcall(e,_) => e
end

(** relation: elab_code_type
 ** This relation will construct the correct type for the given Code expression.
 ** The types are built-in classes of different types. E.g. the class TypeName is the type
 ** of Code expressions corresponding to a type name Code expression. 
**)
relation elab_code_type: (Env.Env, Absyn.Code) => Types.Type =

  axiom	elab_code_type(env, Absyn.C_TYPENAME(_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("TypeName"),[])
  axiom	elab_code_type(env, Absyn.C_VARIABLENAME(_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("VariableName"),[])
  axiom	elab_code_type(env, Absyn.C_EQUATIONSECTION(_,_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("EquationSection"),[])
  axiom	elab_code_type(env, Absyn.C_ALGORITHMSECTION(_,_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("AlgorithmSection"),[])
  axiom	elab_code_type(env, Absyn.C_ELEMENT(_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("Element"),[])
  axiom	elab_code_type(env, Absyn.C_EXPRESSION(_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("Expression"),[])

  axiom	elab_code_type(env, Absyn.C_MODIFICATION(_)) => Types.T_COMPLEX(Absyn.IDENT("$TOP$"),ClassInf.UNKNOWN("Modification"),[])

end

relation elab_graphics_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Types.Properties) =

  axiom	elab_graphics_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), Types.PROP(Types.T_INTEGER([]),true))
  axiom	elab_graphics_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), Types.PROP(Types.T_REAL([]),   true))
  axiom	elab_graphics_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), Types.PROP(Types.T_STRING([]), true))
  axiom	elab_graphics_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), Types.PROP(Types.T_BOOL([]),   true))

  rule	Debug.fprintln("setr", "elab_graphics_exp_cref") &
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_graphics_exp(env, Absyn.CREF(cr)) => (exp,prop) 

	(**  Binary and unary operations *)

  rule	Debug.fprintln("setr", "elab_graphics_exp_binary") &
	elab_graphics_exp (env,e1) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2) => (e2', Types.PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),Types.PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_graphics_exp_unary") &
	elab_graphics_exp (env,e) => (e',Types.PROP(t,c)) &
 	operators(op, env, t, Types.T_NOTYPE) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),Types.PROP(rtype,c))
	
  rule	Debug.fprintln("setr", "elab_graphics_exp_lbinary") &
	elab_graphics_exp (env,e1) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2) => (e2', Types.PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),Types.PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_graphics_exp_lunary") &
	elab_graphics_exp (env,e) => (e',Types.PROP(t,c)) &
 	operators(op, env, t, Types.T_NOTYPE) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),Types.PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_graphics_exp_relation") &
	
	elab_graphics_exp (env,e1) => (e1', Types.PROP(t1, c1)) &
	
	elab_graphics_exp (env,e2) => (e2', Types.PROP(t2, c2)) &
	
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_graphics_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),Types.PROP(rtype,c))

	(**  Conditional expressions *)

  rule	Debug.fprintln("setr", "elab_graphics_exp_ifexp") &
	elab_graphics_exp (env,e1) => (e1', prop1) &
	elab_graphics_exp (env,e2) => (e2', prop2) &
	elab_graphics_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	(* TODO elseif part*)
	------------------------------------------------------
	elab_graphics_exp (env,Absyn.IFEXP(e1,e2,e3,_)) => (e,prop)

	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)

  rule	Dump.print_component_ref_str fn => fnstr &
	Debug.fprintl("setr", ["elab_graphics_exp_call: ",fnstr,"\n"]) &
	elab_call(env,fn,args,nargs,true,NONE) => (e,prop,_) 
	--------------------------------------
	elab_graphics_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs))) 
		=> (e,prop)

	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	Debug.fprintln("setr", "elab_graphics_exp_tuple") &
	Debug.print "\n#####################elab_graphics_exp tuple.####################" &
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
	Debug.print "\nThe elaborated tuple." &
	split_props(props) => (types, consts) &
	Debug.print "\n split_props was just executed."
	-------------------------------------
	elab_graphics_exp (env,Absyn.TUPLE(e as e1::rest)) 
	  => (Exp.TUPLE(e'),Types.PROP_TUPLE(Types.T_TUPLE(types), Types.TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	Debug.fprintln("setr", "elab_graphics_exp_range1") &
	elab_graphics_exp (env, start) => (start', Types.PROP(start_t, c_start)) &
	elab_graphics_exp (env, stop) => (stop', Types.PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt) => t
	--------------------------------------------------
	elab_graphics_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(rt,start',NONE,stop'), Types.PROP(t, const))

  rule	Debug.fprintln("setr", "elab_graphics_exp_range2") &
	elab_graphics_exp (env, start) => (start', Types.PROP(start_t, c_start)) &
	elab_graphics_exp (env, step) => (step', Types.PROP(step_t, c_step)) &
	elab_graphics_exp (env, stop) => (stop', Types.PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt) => t
	---------------------
	elab_graphics_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), Types.PROP(t, const))

  rule	Debug.fprintln("setr", "elab_graphics_exp_array") &
	elab_graphics_array (env, es) => (es', Types.PROP(t, const)) & list_length es' => l&
(*	ceval_list(env,es',false,NONE) => vl &
	Util.list_map(vl, value_exp) => es'' &*)
	Types.elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_graphics_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(at,a,es'),
	      Types.PROP(Types.T_ARRAY(Types.DIM(SOME(l)), t),
		   const))
	
  rule	Debug.fprintln("setr", "elab_graphics_exp_matrix") &
	elab_exp_list_list(env,es,false,NONE) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	elab_matrix_semi (env,es,false,NONE,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	Types.elab_type t => at
	------------------------------------------------------------
	elab_graphics_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(at,nmax,es'),
	      Types.PROP(Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 Types.T_ARRAY(Types.DIM(SOME(dim2)), t)),
		   c))

  rule	Print.print_buf "- elab_graphics_exp failed: " & Dump.print_exp e & Print.print_buf "\n"
	-----------------------------------------------------------
	elab_graphics_exp(_,e) => fail

end

relation deoverload_range : ((Exp.Exp*Types.Type), 
			     (Exp.Exp*Types.Type) option,
			     (Exp.Exp*Types.Type)) 
	  => (Exp.Exp, Exp.Exp option, Exp.Exp, Exp.Type) =
	  
  axiom	deoverload_range((e1,Types.T_INTEGER(_)),
			 NONE,
			 (e3,Types.T_INTEGER(_))) => (e1,NONE,e3,Exp.INT)
  axiom	deoverload_range((e1,Types.T_INTEGER(_)),
			 SOME((e2,Types.T_INTEGER(_))),
			 (e3,Types.T_INTEGER(_)))  => (e1,SOME(e2),e3,Exp.INT)

  rule	elab_arglist([Types.T_REAL([]),Types.T_REAL([])],
		     [(e1,t1),(e3,t3)]) => ([e1',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),NONE,(e3,t3)) => (e1',NONE,e3',Exp.REAL)

  rule	elab_arglist([Types.T_REAL([]),Types.T_REAL([]),Types.T_REAL([])],
		     [(e1,t1),(e2,t2),(e3,t3)]) => ([e1',e2',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),SOME((e2,t2)),(e3,t3)) 
	  => (e1',SOME(e2'),e3',Exp.REAL)

end
(** relation: elab_range_type *)

relation elab_range_type : (Env.Env, Exp.Exp,
			    Exp.Exp option, Exp.Exp, bool,Exp.Type) => Types.Type =

  rule	ceval (env,start,false,NONE) => (Values.INTEGER(startv),_) &
	ceval (env,stop,false,NONE) => (Values.INTEGER(stopv),_) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n')), Types.T_INTEGER([]))

  rule	ceval (env,start,false,NONE) => (Values.INTEGER(startv),_) &
	ceval (env,step,false,NONE) => (Values.INTEGER(stepv),_) &
	ceval (env,stop,false,NONE) => (Values.INTEGER(stopv),_) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n'')), Types.T_INTEGER([]))

  rule	ceval (env,start,false,NONE) => (Values.REAL(startv),_) &
	ceval (env,stop,false,NONE) => (Values.REAL(stopv),_) &
	real_sub (stopv,startv) => n &
	real_floor n => n'' &
	real_int n'' => n''' &
	int_add (n''',1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n')), Types.T_REAL([]))

  rule	ceval (env,start,false,NONE) => (Values.REAL(startv),_) &
	ceval (env,step,false,NONE) => (Values.REAL(stepv),_) &
	ceval (env,stop,false,NONE) => (Values.REAL(stopv),_) &
	real_sub (stopv,startv) => n &
	real_div (n,stepv) => n' &
	real_floor n' => n''' &
	real_int n''' => n'''' &
 	int_add (n'''',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n'')), Types.T_REAL([]))

  axiom	elab_range_type (_,_,_,_,false,Exp.INT)
	  => Types.T_ARRAY(Types.DIM(NONE), Types.T_INTEGER([]))

  axiom	elab_range_type (_,_,_,_,false,Exp.REAL)
	  => Types.T_ARRAY(Types.DIM(NONE), Types.T_REAL([]))

end

relation elab_tuple : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Types.Properties list) =

  rule	Debug.print "\nEntered elab_tuple." &
	elab_exp (env,e,false,NONE) => (e',p,_) &
	Debug.print "\nElaborated expression." &
	elab_tuple(env,exps) => (exps',props) &
	Debug.print "\nThe last element was just elaborated."
	-----------------------------
	elab_tuple(env,e::exps) => (e'::exps', p::props) 

(*PR.  rule	elab_exp (env,e) => (e',p) 
	-----------------------------
	elab_tuple(env,e::[]) => (e', p) 
*)
  rule 	Debug.print "elaborating last element."
	----------------
	elab_tuple(env,[]) => ([], []) 

(*  axiom elab_tuple(env,[]) => ([], []) 
*)
end


(** relation: elab_array *)

relation elab_array : (Env.Env, Absyn.Exp list,bool,Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties) =

  rule	elab_exp (env,e,impl,st) => (e',prop,_)
	-----------------------------
	elab_array (env,[e],impl,st) => ([e'],prop)

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t1,c1),_) &
	elab_array (env,es,impl,st) => (es',Types.PROP(t2,c2)) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es,impl,st) => (e'::es',Types.PROP(t1,c))

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t1,c1),_) &
	elab_array (env,es,impl,st) => (es',Types.PROP(t2,c2)) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in array expression\n" &
	Print.print_buf "  " & Dump.print_exp e & Print.print_buf " is of type " &
 	Types.print_type t1 & Print.print_buf "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	Print.print_buf "] are of type " & Types.print_type t2 & Print.print_buf "\n"
	---------------------------------------------------------
	elab_array (env,e::es,impl,st) => fail

  rule	Print.print_buf "- elab_array failed\n"
	-----------------------------
	elab_array (_,_,_,_) => fail

end

relation elab_graphics_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Types.Properties) =

  rule	elab_graphics_exp (env,e) => (e',prop)
	-----------------------------
	elab_graphics_array (env,[e]) => ([e'],prop)

  rule	elab_graphics_exp (env,e) => (e',Types.PROP(t1,c1)) &
	elab_graphics_array (env,es) => (es',Types.PROP(t2,c2)) &
	bool_and (c1,c2) => c
	---------------------------------
	elab_graphics_array (env,e::es) => (e'::es',Types.PROP(t1,c))

  rule	Print.print_buf "- elab_graphics_array failed\n"
	-----------------------------
	elab_graphics_array (_,_) => fail

end

relation elab_matrix_comma : (Env.Env, Absyn.Exp list, bool(*implicit inst.*)
			      , Interactive.InteractiveSymbolTable option, bool (*have real*))
	=> ((Exp.Exp*bool) list, Types.Properties, int, int) =


  rule	elab_exp (env,el,impl,st) => (el', Types.PROP(t,c),_) &
	Types.ndims t => ndims &
	int_max(2,ndims) => maxn &
	int_gt(ndims,0) => array
	----------------------------------------
	elab_matrix_comma (env,[el],impl,st,havereal) => ([(el',array)],Types.PROP(t,c),1,maxn)


  rule	elab_exp (env,el,impl,st) => (el', Types.PROP(t1,c1),_) &
	elab_matrix_comma(env,els,impl,st,havereal) => (els', Types.PROP(t2,c2), _,maxn2) &

	Types.match_with_promote(Types.PROP(t1,c1),Types.PROP(t2,c2),havereal) => props &

	list_length el::els => dim &

	Types.ndims t1 => maxn1 &
	int_max (maxn1,maxn2) => maxn &
	int_gt(maxn1,0) => array
	-------------------------------------
	elab_matrix_comma (env,el::els,impl,st,havereal) 
	  => ((el',array)::els',props,dim,maxn)
	  
  rule	Debug.fprint("failtrace","- elab_matrix_comma failed\n")
	-------------------------------------
	elab_matrix_comma (_,_,_,_,_) => fail
end

(** relation: elab_matrix_semi *)

relation elab_matrix_semi : (Env.Env, Absyn.Exp list list, bool(*implicit inst.*), Interactive.InteractiveSymbolTable option, bool(*contain real*))
	=> ((Exp.Exp*bool) list list, Types.Properties, int, int, int) =
	  

  rule	elab_matrix_comma(env,el,impl,st,havereal) => (el', props, dim, maxn)
	---------------------------------
	elab_matrix_semi(env,[el],impl,st,havereal) => ([el'], props, 1, dim, maxn)

  rule	list_length(el) => dim &
	elab_matrix_comma(env,el,impl,st,havereal) => (el',props1,dim1,maxn1) &
	elab_matrix_semi(env,els,impl,st,havereal) => (els',props2,_,dim2,maxn2) &

	dim1 = dim2 &
			
	Types.match_with_promote(props1,props2,havereal) => props &

	int_max(maxn1,maxn2) => maxn
	--------------------
	elab_matrix_semi(env,el::els,impl,st,havereal) => (el'::els',props,dim,dim1,maxn)

  rule	Debug.fprint("failtrace", "- elab_matrix_semi failed\n" )
	-------------------
	elab_matrix_semi(_,_,_,_,_) => fail

	(**  Error messages *)
(*
  rule	Print.print_buf "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix_semi(_,[]) => fail

  rule	elab_array(env,el) => (el',Types.PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in matrix rows\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix is of " &
	Types.print_type t2 & Print.print_buf "\n"
	--------------------------------
	elab_matrix_semi(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	Print.print_buf "# Incompatible row length in matrix expression\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of size " &
	int_string dim1 => s & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix rows are of size " &
	int_string dim2 => s & Print.print_buf s & Print.print_buf "\n"
	--------------------------------------------
	elab_matrix_semi(env,el::els) => fail
*)
end


relation elab_builtin_size : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

	(** LS: size(A) that returns an array of sizes for all dimensions is not *)
	(** implemented, just size(A,x) that returns size of x:th dimension *)
(*
  rule	elab_exp(env,dim,false,NONE) => (dimp,_,_) &
	elab_exp(env,arraycr,false,NONE) => (arraycrefe,_,_) &
	let exp = Exp.SIZE(arraycrefe,dimp)
	---------------------------------------------------------------
	elab_builtin_size (env, [arraycr,dim]) => (exp,Types.PROP(Types.T_INTEGER,false))
*)

  rule	elab_exp (env,ind,false,NONE) => (indexp, Types.PROP(indty, true),_) &
	ceval (env, indexp,false,NONE) => (Values.INTEGER(value),_) &
	elab_exp (env,arraycr,false,NONE) => (Exp.CREF(cr,crt), crprop,_) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	elab_builtin_size_2 (env, ty, value) => (exp, prop) 
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) => (exp, prop)


  rule	elab_exp (env,ind,false,NONE) => (indexp, Types.PROP(indty, true),_) &
	ceval (env, indexp,false,NONE) => (Values.INTEGER(value),_) &
	elab_exp (env,arraycr,false,NONE) 
	  => (exp, Types.PROP(arrtp,_),_) &
	elab_builtin_size_2 (env, arrtp, value) => (exp, prop) 
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) => (exp, prop)

  rule	elab_exp (env,arraycr,false,NONE) => (crefe as Exp.CREF(cr,crt), crprop,_) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	Types.array_element_type ty => Types.T_INTEGER(_) &
	elab_exp (env,ind,false,NONE) => (indexp, Types.PROP(indty, ind_const),_) &
	let exp = Exp.CALL(Absyn.IDENT("size_of_dimension_integer_array"),
			   [crefe,indexp],false,true) &
	let prop = Types.PROP(Types.T_INTEGER([]),false)
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) 
	  => (exp, 
	      prop)

  rule	elab_exp (env,arraycr,false,NONE) => (crefe as Exp.CREF(cr,crt), crprop,_) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	Types.array_element_type ty => Types.T_REAL(_) &
	elab_exp (env,ind,false,NONE) => (indexp, Types.PROP(indty, ind_const),_) &
	let exp = Exp.CALL(Absyn.IDENT("size_of_dimension_real_array"),
			   [crefe,indexp],false,true) &
	let prop = Types.PROP(Types.T_INTEGER([]),false)
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) 
	  => (exp, prop)

  rule	print "elab_builtin_size failed\n" &
	Print.print_buf "#-- elab_builtin_size: Couldn't elaborate size()\n" &
	Print.print_buf "#-- Wrong args or non-constant dimension\n" 
	----------------------------------------------------------
	elab_builtin_size (env,expl) => fail

end

relation elab_builtin_size_2 : (Env.Env, Types.Type, int) => (Exp.Exp, Types.Properties) =

  rule	(*Print.print_buf "# Error non-constant dimension\n" *)
	---------------------------------------
	elab_builtin_size_2(env, Types.T_ARRAY(Types.DIM(NONE),ty), 1) => fail

 axiom	elab_builtin_size_2 (env, Types.T_ARRAY(Types.DIM(SOME(dim)),ty), 1) 
	  => (Exp.ICONST(dim), Types.PROP(Types.T_INTEGER([]), true))

  rule	int_sub (ind, 1) => ind' &
	elab_builtin_size_2 (env, ty, ind') => (exp, prop)
	--------------------------------------------------
	elab_builtin_size_2 (env, Types.T_ARRAY(_, ty), ind) => (exp, prop)

end


relation elab_builtin_fill : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties)	=

  rule	elab_exp (env,s,false,NONE) => (s', Types.PROP(sty, sconst),_) &
	elab_exp_list (env,dims,false,NONE) => (dims', dimprops,_) &
	ceval_list (env, dims',false,NONE) => dimvals &
	elab_builtin_fill_2 (env, s', sty, dimvals) => (exp, prop) 
	--------------------------------------------------
	elab_builtin_fill (env, s::dims) => (exp, prop)

  rule	print"#-- elab_builtin_fill: Couldn't elaborate fill()\n"
	---------------------------------------------------------
	elab_builtin_fill (_,_) => fail

end


relation elab_builtin_fill_2 : (Env.Env, Exp.Exp, Types.Type, Values.Value list) 
	  => (Exp.Exp, Types.Properties) =

  rule	build_exp_list (s, v) => arraylist &
	Types.elab_type sty => at &
	Types.is_array sty => a
	----------------------------------
	elab_builtin_fill_2 (env, s, sty, [Values.INTEGER(v)])
	  => (Exp.ARRAY(at,a,arraylist), Types.PROP(Types.T_ARRAY(Types.DIM(SOME(v)), sty), true))
			     
  rule	elab_builtin_fill_2 (env, s, sty, rest) 
	  => (exp, Types.PROP(ty,con)) &
        build_exp_list (exp, v) => arraylist &
	Types.elab_type ty => at &
	Types.is_array ty => a
	----------------------------------------------------------
	elab_builtin_fill_2 (env, s, sty, Values.INTEGER(v)::rest) 
	  => (Exp.ARRAY(at,a,arraylist), Types.PROP(Types.T_ARRAY(Types.DIM(SOME(v)), ty), true))
	
  rule	Print.print_buf "#-- elab_builtin_fill_2: Failed to elaborate fill()\n"
	-------------------------------------------------------------
	elab_builtin_fill_2 (_,_,_,_) => fail

end

relation elab_builtin_transpose : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,matexp,false,NONE) => (matexp', Types.PROP(matty, true),_) &
	elab_builtin_transpose_2(env,matexp',matty) => (exp,prop)
	------------------------------------------------------
	elab_builtin_transpose (env, [matexp]) => (exp, prop)

  rule	elab_exp (env,matexp,false,NONE) 
	  => (exp', Types.PROP(Types.T_ARRAY(d1,Types.T_ARRAY(d2,eltp)),_),_) &
	let newtp = Types.T_ARRAY(d2,Types.T_ARRAY(d1,eltp)) &
	let exp = Exp.CALL(Absyn.IDENT("transpose"),
			   [exp'],false,true) &
	let prop = Types.PROP(newtp,false)
	------------------------------------
	elab_builtin_transpose (env, [matexp]) => (exp, prop)
end

relation elab_builtin_transpose_2 : (Env.Env, Exp.Exp, Types.Type) => 
	(Exp.Exp, Types.Properties) =

  rule	print "- elab_builtin_transpose_2 not implemented yet\n" &
	Print.print_buf "- elab_builtin_transpose_2 not implemented yet\n" 
	------------------------
	elab_builtin_transpose_2(env, exp, tp) => fail
end

relation build_exp_list : (Exp.Exp, int) => Exp.Exp list =

  axiom	build_exp_list(e,0) => []
  axiom	build_exp_list (e,1) => [e]

  rule	int_sub (c,1) => c' &
	build_exp_list (e, c') => rest
	------------------------------
	build_exp_list (e, c) => e::rest

end

relation elab_builtin_sum : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  rule	(* For constant expressions *)
	elab_exp(env,arrexp,false,NONE) => (exp',Types.PROP(Types.T_ARRAY(dim,tp),c as true),_) &
	ceval(env, exp',false,NONE) => (Values.ARRAY(vals),_) &
	Values.sum_arrayelt(vals) => value &
	value_exp value => exp''
	----------------------
	elab_builtin_sum(env,[arrexp]) => (exp'', Types.PROP(tp,c))

  rule	(* For non-constant expressions *)
	elab_exp(env,arrexp,false,NONE) => (exp',Types.PROP(Types.T_ARRAY(dim,tp),c as false),_) &
	let exp'' = Exp.CALL(Absyn.IDENT("sum"),
			   [exp'],false,false) 
	---------------------------------------
	elab_builtin_sum(env,[arrexp]) => (exp'', Types.PROP(tp,c))
end

relation elab_builtin_pre : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp(env,exp,false,NONE) => (exp',Types.PROP(tp,c),_) &
	Types.basic_type(tp) => true &
	let exp'' = Exp.CALL(Absyn.IDENT("pre"),
			   [exp'],false,false) 
	------------------------------------
	elab_builtin_pre(env,[exp]) => (exp'', Types.PROP(tp,c))

  rule	elab_exp(env,exp,false,NONE) => (exp,Types.PROP(tp,c),_) &
	Types.basic_type(tp) => false &
	Print.print_buf "#Error, operand of pre must be of built-in type.\n"
	------------------------------------
	elab_builtin_pre(env,[exp]) => fail

  rule	Print.print_buf "#Error, wrong type or wrong number of arguments to pre operator.\n"
	------------------------------------
	elab_builtin_pre(env,_) => fail
end

relation elab_builtin_initial : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_builtin_initial(env,[]) 
	  => (Exp.CALL(Absyn.IDENT("initial"),
			   [],false,false), Types.PROP(Types.T_BOOL([]),false))

  rule	Print.print_buf "#Error, initial takes no arguments.\n"
	------------------
	elab_builtin_initial(env,_) => fail
end

relation elab_builtin_terminal : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_builtin_terminal(env,[]) 
	  => (Exp.CALL(Absyn.IDENT("terminal"),
			   [],false,false), Types.PROP(Types.T_BOOL([]),false))

  rule	Print.print_buf "#Error, terminal takes no arguments.\n"
	------------------
	elab_builtin_terminal(env,_) => fail

end


relation elab_builtin_array : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =
  rule	elab_exp_list(env, expl, false, NONE) 
	  => (exp', typel, _) &
	elab_builtin_array2 (exp',  typel) => (exp'', Types.PROP(tp,c)) &  
	list_length(expl) => len &
	let newtp = Types.T_ARRAY(Types.DIM(SOME(len)),tp) &
	Types.elab_type(newtp) => newtp' &
	let exp = Exp.ARRAY(newtp',c,exp') 
	---------------------------------
	elab_builtin_array(env,expl) => (exp, Types.PROP(newtp,c))
end

(* Asserts that all types are of same dimensionality and of same builtin types *)
relation elab_builtin_array2: (Exp.Exp list, Types.Properties list)
	=> (Exp.Exp list, Types.Properties) =

  rule	same_dimensions(tpl) => false &
	Print.print_buf "#Error, different dimension sizes in arguments to array.\n"
	------------------------
	elab_builtin_array2(expl,tpl) => fail

  rule	(* If first elt is Integer but arguments contain Real, convert all to Real *)
	Util.list_map(tpl,Types.get_prop_type) => tpl' &
	Types.contain_real(tpl') => true &
	elab_builtin_array3(expl,tpl,Types.PROP(Types.T_REAL([]),false)) => (expl', tp)
	-------------------------------------------
	elab_builtin_array2(expl,tpl) => (expl', tp)
	
  rule	elab_builtin_array3(expl,tpl,tp) => (expl',tp)
	---------------------------
	elab_builtin_array2(expl,tpl as (tp::_)) => (expl', tp)
end

relation elab_builtin_array3: (Exp.Exp list, Types.Properties list, Types.Properties)
	=> (Exp.Exp list, Types.Properties) =
  axiom	elab_builtin_array3([],[],tp) => ([],tp)

  rule	Types.match_prop(e1,t1,tp) => e1' &
	elab_builtin_array3(expl,tpl,tp) => (expl',_)
	----------------------------------------
	elab_builtin_array3(e1::expl,t1::tpl,tp) => (e1'::expl', t1)
end

relation elab_builtin_zeros : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(0)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_zeros (env, args) => (e,p)
end

relation same_dimensions: (Types.Properties list ) => bool =

  rule	Util.list_map(tpl,Types.get_prop_type) => tpl' &
	Util.list_map(tpl',Types.get_dimension_sizes) => dimsizes &
	same_dimensions2(dimsizes) => res
	--------------------------------
	same_dimensions(tpl) => res
end

relation same_dimensions2:( int list list) => bool =

  rule	Util.list_flatten(l) => []
	------------------
	same_dimensions2(l) => true
	
  rule	Util.list_map(l,Util.list_first) => elts &
	Util.list_map(l,Util.list_rest) => restelts &
	same_dimensions3(elts) => true &
	same_dimensions2(restelts) => true
	----------------------------------
	same_dimensions2(l) => true
  axiom	same_dimensions2(_) => false
end
			
relation same_dimensions3: (int list) => bool =

  axiom same_dimensions3([]) => true
  axiom	same_dimensions3([_]) => true

  rule	int_eq(i1,i2) => res 
	--------------------
	same_dimensions3([i1,i2]) => res

  rule	same_dimensions3(i2::rest) => res &
	int_eq(i1,i2) => res2 &
	bool_and(res,res2) => res'
	--------------------------
	same_dimensions3(i1::i2::rest) => res'

  axiom	same_dimensions3(_) => false
end

relation elab_builtin_ones : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(1)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_ones (env, args) => (e,p)
end

relation elab_builtin_max : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	ceval(env,arrexp',false,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_max_2 (Values.ARRAY(vals)) => (Values.INTEGER(i),ty)
	-------------------------------------------------------
	elab_builtin_max(env, [arrexp]) => (Exp.ICONST(i),Types.PROP(ty,true))

  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	ceval(env,arrexp',false,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_max_2 (Values.ARRAY(vals)) => (Values.REAL(r),ty)
	-------------------------------------------------------
	elab_builtin_max(env, [arrexp]) => (Exp.RCONST(r),Types.PROP(ty,true))

	(* max(x,y) where x & y are scalars *)
  rule	elab_exp (env,s1,false,NONE) 
	  => (s1', Types.PROP(arrty, arrconst),_) &
	ceval(env,s1',false,NONE) => (Values.INTEGER(i1),_) &
	elab_exp (env,s2,false,NONE) 
	  => (s2', Types.PROP(arrty, arrconst),_) &
	ceval(env,s2',false,NONE) => (Values.INTEGER(i2),_) &
	int_max(i1,i2) => res
	-------------------------------------------------------
	elab_builtin_max(env, [s1, s2]) 
	  => (Exp.ICONST(res),Types.PROP(Types.T_INTEGER([]),true))

  rule	elab_exp (env,s1,false,NONE) 
	  => (s1', Types.PROP(arrty, arrconst),_) &
	ceval(env,s1',false,NONE) => (Values.REAL(r1),_) &
	elab_exp (env,s2,false,NONE) 
	  => (s2', Types.PROP(arrty, arrconst),_) &
	ceval(env,s2',false,NONE) => (Values.REAL(r2),_) &
	real_max(r1,r2) => res
	-------------------------------------------------------
	elab_builtin_max(env, [s1, s2]) 
	  => (Exp.RCONST(res),Types.PROP(Types.T_REAL([]),true))
end

relation elab_builtin_max_2 : (Values.Value) => (Values.Value, Types.Type) =

  rule	elab_builtin_max_2(v1) => (Values.INTEGER(i1),Types.T_INTEGER(_)) &
	elab_builtin_max_2(Values.ARRAY(vls)) => (Values.INTEGER(i2),Types.T_INTEGER(_)) &
	int_max(i1,i2) => res
	---------------------
	elab_builtin_max_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res),Types.T_INTEGER([]))

  rule	elab_builtin_max_2(v1) => (Values.REAL(i1),Types.T_REAL(_)) &
	elab_builtin_max_2(Values.ARRAY(vls)) => (Values.REAL(i2),Types.T_REAL(_)) &
	real_max(i1,i2) => res
	---------------------
	elab_builtin_max_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.REAL(res),Types.T_REAL([]))

  rule	elab_builtin_max_2(vl) => (v,t)
	------------------
	elab_builtin_max_2(Values.ARRAY([vl]))
	  => (v,t)

  axiom	elab_builtin_max_2(Values.INTEGER(i))
	  => (Values.INTEGER(i),Types.T_INTEGER([]))

  axiom	elab_builtin_max_2(Values.REAL(i))
	  => (Values.REAL(i),Types.T_REAL([]))
end

relation elab_builtin_min : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	ceval(env,arrexp',false,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_min_2 (Values.ARRAY(vals)) => (Values.INTEGER(i),ty)
	-------------------------------------------------------
	elab_builtin_min(env, [arrexp]) => (Exp.ICONST(i),Types.PROP(ty,true))

  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	ceval(env,arrexp',false,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_min_2 (Values.ARRAY(vals)) => (Values.REAL(r),ty)
	-------------------------------------------------------
	elab_builtin_min(env, [arrexp]) => (Exp.RCONST(r),Types.PROP(ty,true))
end

relation elab_builtin_min_2 : (Values.Value) => (Values.Value, Types.Type) =

  rule	elab_builtin_min_2(v1) => (Values.INTEGER(i1),Types.T_INTEGER(_)) &
	elab_builtin_min_2(Values.ARRAY(vls)) => (Values.INTEGER(i2),Types.T_INTEGER(_)) &
	int_min(i1,i2) => res
	---------------------
	elab_builtin_min_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res),Types.T_INTEGER([]))

  rule	elab_builtin_min_2(v1) => (Values.REAL(i1),Types.T_REAL(_)) &
	elab_builtin_min_2(Values.ARRAY(vls)) => (Values.REAL(i2),Types.T_REAL(_)) &
	real_min(i1,i2) => res
	---------------------
	elab_builtin_min_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.REAL(res),Types.T_REAL([]))

  rule	elab_builtin_min_2(vl) => (v,t)
	------------------
	elab_builtin_min_2(Values.ARRAY([vl]))
	  => (v,t)

  axiom	elab_builtin_min_2(Values.INTEGER(i))
	  => (Values.INTEGER(i),Types.T_INTEGER([]))

  axiom	elab_builtin_min_2(Values.REAL(i))
	  => (Values.REAL(i),Types.T_REAL([]))
end

relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list) 
					  => (Exp.Exp, Types.Properties)) =

  axiom	elab_builtin_handler "size" => elab_builtin_size
  axiom	elab_builtin_handler "zeros" => elab_builtin_zeros
  axiom	elab_builtin_handler "ones" => elab_builtin_ones
  axiom	elab_builtin_handler "fill" => elab_builtin_fill
  axiom	elab_builtin_handler "max" => elab_builtin_max
  axiom	elab_builtin_handler "min" => elab_builtin_min
  axiom elab_builtin_handler "transpose" => elab_builtin_transpose
  axiom	elab_builtin_handler "array" => elab_builtin_array
  axiom	elab_builtin_handler "sum" => elab_builtin_sum
  axiom	elab_builtin_handler "pre" => elab_builtin_pre
  axiom	elab_builtin_handler "initial" => elab_builtin_initial
  axiom	elab_builtin_handler "terminal" => elab_builtin_terminal
end


(** relation: elab_call_builtin
 **
 **)

relation elab_call_builtin : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Types.Properties) =

  rule	elab_builtin_handler name => handler &
	handler (env, args) => (exp,prop)
	-------------------
	elab_call_builtin (env, Absyn.CREF_IDENT(name,[]), args) => (exp, prop)
end


(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg list, bool, Interactive.InteractiveSymbolTable option)
	=> (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =

	  (** LS: Check if a builtin function call, e.g. size()
	      and calculate if so **)

  rule	(* Elaborate interactive function calls *)
	elab_call_interactive(env,fn,args,nargs,impl,st) => (e,prop,st)
	-------------------------------------------------------
	elab_call(env,fn,args,nargs,impl,st) => (e,prop,st)

  rule	(* PA. Built in functions have only possitional arguments *)
	elab_call_builtin (env, fn, args) => (e,prop)
	---------------------------------------------
	elab_call (env,fn,args,nargs,impl,st) => (e,prop,st)

  rule	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args,nargs,st) => (e,prop) &
	generate_compiled_function(env,fn,e,prop,st) => st' &
	Debug.fprintln ("sei", "elab_call succeeded")
	------------------------------------
	elab_call (env,fn,args,nargs,impl,st) => (e,prop,st')

  rule	Debug.fprint("failtrace", "- elab_call failed\n") &
	Debug.fprint("failtrace", " function: ") &
	Debug.fcall("failtrace", Dump.print_component_ref,fn) &
	Debug.fprint("failtrace", " posargs: ") &
	Debug.fprint_list("failtrace", args, Dump.print_exp,", ") &	
	Debug.fprint("failtrace", "\n") 
	----------------------------
	elab_call (env,fn,args,nargs,impl,st) => fail

end

(** relation: elab_call_interactive
 *
 * This relation elaborates the functions defined in the interactive environment.
 * Since some of these functions are meta-functions, they can not be described in the type 
 * system, and is thus given the the type T_NOTYPE
 *)
relation elab_call_interactive : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg list, bool, Interactive.InteractiveSymbolTable option)
 	  => (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =

  rule	Absyn.cref_to_path(cr) => path & path_to_component_ref(path) => cr'
	-------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("lookupClass",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("lookupClass"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("typeOf",_),
			      [ Absyn.CREF(Absyn.CREF_IDENT(varid,[]))],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("typeOf"),
		       [Exp.CREF(Exp.CREF_IDENT(varid,[]),Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clear",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clear"), [], false, false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clearVariables",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clearVariables"), [], false, false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clearCache",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clearCache"), [], false, false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("list",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("list"),
		       [],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("list",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("list"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	let recordtype = 
	Types.T_COMPLEX(Absyn.IDENT("$TOP$"),
			ClassInf.RECORD("SimulationResult")
			,[Types.VAR("exeFile",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, Types.T_STRING([]), Types.UNBOUND)
			  ]
			)
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("translateClass",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("translateClass"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(recordtype,false),
	      SOME(st))

  rule	elab_exp(env,exp,impl,SOME(st)) => (exp',prop,st')
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("timing",_),
			      [exp],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("timing"),
		       [exp'],
		       false,
		       false),
	      Types.PROP(Types.T_REAL([]),false),
	      st')


  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("generateCode",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("generateCode"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompiler",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompiler"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompilerFlags",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompilerFlags"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setDebugFlags",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setDebugFlags"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("cd",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("cd"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("cd",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("cd"),
		       [],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("system",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("system"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_INTEGER([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("readFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("readFile"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

	(* Returns an array of "component references" *)
axiom	elab_call_interactive(env, Absyn.CREF_IDENT("listVariables",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("listVariables"),
		       [],
		       false,
		       false),
	      Types.PROP(Types.T_ARRAY(Types.DIM(NONE),Types.T_NOTYPE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("getErrorString",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getErrorString"),
		       [],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("runScript",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("runScript"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("loadClass",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("loadClass"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("loadFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("loadFile"),
		       [Exp.SCONST(str)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("saveClass",_),
			      [ Absyn.STRING(str),Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("saveClass"),
		       [Exp.SCONST(str),Exp.CREF(cr',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("help",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("help"),
		       [],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getUnit",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getUnit"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getQuantity",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getQuantity"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getDisplayUnit",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getDisplayUnit"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_STRING([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getMin",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getMin"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_REAL([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getMax",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getMax"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_REAL([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getStart",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getStart"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_REAL([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getFixed",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getFixed"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_BOOL([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getNominal",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getNominal"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_REAL([]),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getStateSelect",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getStateSelect"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       false),
	      Types.PROP(Types.T_ENUMERATION(["never", "avoid", "default", "prefer", "always"],[]),false),
	      SOME(st))

end

(* This relation elaborates a ComponentRef without adding type information. *)
(* Environment is passed along, such that constant subscripts can be elabed using existing
 relations *)	
relation elab_untyped_cref: (Env.Env, Absyn.ComponentRef) => Exp.ComponentRef =

  rule	elab_subscripts(env, subs) => (subs',_)
	----------------------------------
	elab_untyped_cref(env, Absyn.CREF_IDENT(id,subs)) => Exp.CREF_IDENT(id,subs')

  rule	elab_subscripts(env,subs) => (subs',_) &
	elab_untyped_cref(env, cr) => cr'
	-----------------------------
	elab_untyped_cref(env, Absyn.CREF_QUAL(id,subs,cr)) => Exp.CREF_QUAL(id,subs',cr')
end

relation path_to_component_ref: Absyn.Path => Exp.ComponentRef =

  axiom	path_to_component_ref(Absyn.IDENT(s)) => Exp.CREF_IDENT(s,[])

  rule	path_to_component_ref(path) => cref
	----------------
	path_to_component_ref(Absyn.QUALIFIED(id,path)) => Exp.CREF_QUAL(id,[],cref)
end

relation component_ref_to_path: Exp.ComponentRef => Absyn.Path =

  axiom	component_ref_to_path(Exp.CREF_IDENT(s,[])) => Absyn.IDENT(s)

  rule	component_ref_to_path(cref) => path
	----------------
	component_ref_to_path(Exp.CREF_QUAL(id,_,cref)) => Absyn.QUALIFIED(id,path)
end

(* relation: generate_compiled_function 
 ** TODO: This currently only works for top level functions. For functions inside packages 
 ** we need to reimplement without using lookup functions, since we can not build
 ** correct env for packages containing functions.   
   *)
relation generate_compiled_function: (Env.Env, Absyn.ComponentRef, Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =>
	(Interactive.InteractiveSymbolTable option) =

  axiom generate_compiled_function(_,_,_,_,NONE) => NONE
	
  rule	Absyn.cref_to_path(fn) => pfn &
	is_function_in_cflist (cflist,pfn) => true
	-----------------------------------------------
	generate_compiled_function(env,fn,e,Types.PROP(t,_),SOME(st as Interactive.SYMBOLTABLE(p,_,_,_,cflist))) => SOME(st)

  rule	Absyn.cref_to_path(fn) => path &
	is_function_in_cflist (cflist, path) => false &
	SCode.elaborate(p) => p' &
(*	Inst.instantiate_implicit(p') => d & *)
	Lookup.lookup_class(env, path, false) => (cls, env') &
	Inst.implicit_function_instantiation(env', Mod.NOMOD,
					     Prefix.NOPRE, [], cls, [], false)
	  => (env'',d) &
	Print.clear_buf() &
	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Codegen.generate_functions(d') &
	ModUtil.path_string2 (path,"_") => pathstr &	
	string_append(pathstr,".c") => filename &
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf "\nint main(int argc, char** argv)\n{\n\n  if (argc != 3)\n    {\n      fprintf(stderr,\"# Incorrrect number of arguments\\n\");\n      return 1;\n    }\n" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
	Print.write_buf(filename)& Print.clear_buf() &
	System.compile_c_file(filename) 
	-----------------------------------------------
	generate_compiled_function(env,fn,e,Types.PROP(t,_),SOME(st as Interactive.SYMBOLTABLE(p,a,b,c,cflist))) => SOME(Interactive.SYMBOLTABLE(p,a,b,c,(path,t)::cflist))

end


relation is_function_in_cflist : ((Absyn.Path * Types.Type) list, Absyn.Path) => bool =

  axiom	is_function_in_cflist ([],_) => false

  rule	ModUtil.path_equal (path1, path2) => true
	-----------------------------------------
	is_function_in_cflist ((path1, ty)::rest, path2) => true

  rule	ModUtil.path_equal (path1, path2) => false &
	is_function_in_cflist (rest, path2) => res
	------------------------------------------
	is_function_in_cflist ((path1, ty)::rest, path2) => res
end

(** relation: elab_call_args
 **
 ** Given the name of a function and two lists of expression and 
 ** NamedArg respectively to be used 
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, Absyn.Path, Absyn.Exp list, Absyn.NamedArg list, Interactive.InteractiveSymbolTable option)
	=> (Exp.Exp, Types.Properties) =

  rule	(* This rule finds record constructors, user defined or implicit *)

	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(fargs,outtype as Types.T_COMPLEX(_,ClassInf.RECORD(_),_),_),env') &
	Debug.fprintln ("sei", "function is record constructor\n") &
	
	make_empty_slots(fargs) => slots &
	elab_input_args(env, args,nargs,slots) => (args',newslots, c) &
	Debug.fprintln ("sei", "Did elab_input_args") &

	elab_consts(outtype) => const &

	Debug.fprintln ("sei", "Elaborated consts") &
	get_properties(outtype, const) => prop &

	Lookup.lookup_record_constructor_class(env',fn) => (cl,env'') &
	Debug.fprintln ("sei", "got record constructor class") &
	
	fill_default_slots(newslots,cl,env'') => newslots2 &
	Debug.fprint ("sei", "filled slots:") &
	Debug.fcall ("sei",print_slots,newslots2) &
	exp_list_from_slots(newslots2) => args'' &
	Debug.fprintln ("setr", "elab_call_args_succeeded")
	------------------------------------
	elab_call_args(env,fn,args,nargs,st) => (Exp.CALL(fn,args'',false,false), prop )

	(* This rule finds user-defined functions. *)

(* P.A: Removed. All functions can be overloaded. Thus, we need to fetch ALL type definitions
  and find the right one 
  rule	

	Debug.fprintln ("sei", "Looking up function in elab_call_args. env:\n") &
	Debug.fcall ("sei", Env.print_env,env) &
	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(fargs,outtype),env') &

	Debug.fprint("setr", "Did lookup in elab_call_args.\n") &

	Debug.fprintln ("sei", "Got types.") &
	make_empty_slots(fargs) => slots &
	elab_input_args(env, args,nargs,slots) => (args',newslots, c) &
	Debug.fprintln ("sei", "Did elab_input_args, constant=") &
	elab_consts(outtype) => const &
	is_tuple(outtype) => tuple &
	Debug.fprintln ("sei", "Elaborated consts") &
	get_properties(outtype, const) => prop &
	
	
	Debug.fprintln ("setr", "elab_call_args_succeeded")
	--------------------------------------------
	elab_call_args(env,fn,args,nargs,st) => (Exp.CALL(fn,args',tuple,false), prop ) *)
	(* 
	 Functions that returns just one argument should not return a
	 tuple. It just returns a simple expression. 
	 *)



	(* This rule finds the built-in functions *)

  rule	

	(* PR. A function can have several types. Taking an array with
	 different dimensions as parameter for example. Because of this we
	 cannot just lookup the function name and trust that it
	 returns the correct function. It returns just one
	 functiontype of several possibilites. The solution is to send
	 in the funktion type of the user function and check both the
	 funktion name and the function's type. 
	 *)
	Lookup.lookup_functions_in_env(env,fn) => typelist &
	Debug.fprintln("sei", "elab_call_args, found types: ") &
	Debug.fprint_list("sei",typelist,Types.print_type,", ") &
	elab_types (env, args, typelist) => (args', c, restype, functype) &
	deoverload_funcname(fn,functype) => fn' &
	is_tuple restype => tuple &
	elab_consts(restype) => const &
	get_properties(restype,const) => prop &
	(*P.R: When is T_FUNCTION ouputted from lookup_type? *)
(*	Print.print_buf "Debug: We did a lookup T_FUNCTION " &
*)
(*PR.	elab_input_args(env, args, params) => (args',c)  *)
	Debug.fprintln ("sei", "elab_call_args succeeded")
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs,st) => (Exp.CALL(fn',args',tuple,false), prop)

  rule	(* Rule above failed. Also consider koening lookup. *)
	get_koening_function_types(env,fn,args,nargs) => ktypelist &
	Debug.fprintln("sei", "elab_call_args, found koening types: ") &
	Debug.fprint_list("sei",ktypelist,Types.print_type,", ") &
	elab_types (env, args, ktypelist) => (args', c, restype, functype) &
	deoverload_funcname(fn,functype) => fn' &
	is_tuple restype => tuple &
	elab_consts(restype) => const &
	get_properties(restype,const) => prop &
	Debug.fprintln ("sei", "elab_call_args succeeded in koening lookup.")
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs,st) => (Exp.CALL(fn',args',tuple,false), prop)

  rule	not Lookup.lookup_type(env,fn) => (_,_) &
	
	Print.print_buf "# Couldn't find function " & Dump.print_path fn & Print.print_buf "\n" 
	-------------------------------------------------------------------
	elab_call_args(env,fn,_,_,_) => fail

  rule	(*elab_exp(env, e) => (e',Types.PROP(t,_)) &*)
	Debug.fprint("failtrace", "- elab_call_args failed\n")
	---------------------------------
	elab_call_args(_,_,_,_,_) => fail

end

(** relation: deoverload_funcname
 ** This relation is used to deoverload function calls. It investigates the type of the function
 ** to see if it has the optional functionname set. If so this is returned. 
 ** Otherwise return input.
**)
relation deoverload_funcname: (Absyn.Path, Types.Type) => Absyn.Path =

  axiom	deoverload_funcname(fn,Types.T_FUNCTION(_,_,SOME(fn'))) => fn'

  axiom	deoverload_funcname(fn,_) => fn

end


relation is_tuple : Types.Type => bool =

  axiom is_tuple Types.T_TUPLE(_) => true
  axiom	is_tuple _ => false

end
(*PR.*)
relation  elab_types:  (Env.Env, Absyn.Exp list,  Types.Type list) 
	  => (Exp.Exp list, bool, Types.Type(*result type*), Types.Type(*function type*)) =

	(* 
	 We found nothing. This is an error. return to the calling
	 function that writes an error message that makes sense (the
	 name of the funtion etc). 
	 *)
	(* 
	 If trest gets empty then we will return with a missmatch.
	 and write an error message in the calling function. 
	 *)

	(* We found a match.*)
  rule	Debug.fprintln ("sei", "We try the elab_input") &
	Debug.fprintln ("sei", "testing type:") &
	Debug.fcall ("sei", Types.print_type,t) &
	make_empty_slots(params) => slots &
	elab_input_args(env, args, [], slots ) => (args',newslots, c) &
        Debug.fprintln ("sei", "We found a match." )
	------------------
        elab_types(env, args, (t as Types.T_FUNCTION(params,restype,fpath))::trest)
	  => (args', c, restype, t)

	(* We did not found a match, try next. *)
  rule 	Debug.fprintln ("sei", "The elab_input_args failed, try next.") &
	elab_types(env, args, trest) => (args',c, restype,t) 
        ------------------
        elab_types(env, args, Types.T_FUNCTION(params,restype,fpath)::trest) 
	  => (args', c, restype,t)

  rule	Debug.fprint("failtrace","- elab_types failed.") 
	--------------
	elab_types(env,_,_) => fail
end


(* PR get_prop 
*)
(* LS: Changed type list to type, since T_TUPLE already fixed before *)
relation get_properties : (Types.Type, Types.Const)  => Types.Properties =

	(* At least two elements in the type list, this is a tuple. *)
	(* LS: Tuples are fixed before here *)
  axiom	get_properties (tt as Types.T_TUPLE(_), const) => Types.PROP_TUPLE(tt, const)

	(* One type, this is a tuple with one element. The resulting properties 
	 * is then identical to that of a single expression. *)
  axiom	get_properties(t, Types.TUPLE_CONST(Types.CONST(b)::[]))  => Types.PROP(t, b)

end


(** PR. assisting routines
 ** This just splits the properties list into a type list and a const list. 
 **)
(* LS: Changed to take a Type, which is the functions return type *)
relation elab_consts : Types.Type  => Types.Const =

  rule	check_consts tys => consts
	-------------------------------
	elab_consts Types.T_TUPLE(tys) => Types.TUPLE_CONST(consts)

  (* LS: If not a tuple then one normal type, T_INTEGER etc, but we make a list of types
     with one element and call the same check_consts, so that we always have Types.TUPLE_CONST as result
   *)
  rule	check_consts [ty] => consts
	-----------------------
	elab_consts ty => Types.TUPLE_CONST(consts)

end

(* LS: Changed to take a Type list, which is the functions return type. Only
   for functions returning a tuple *)
relation check_consts : Types.Type list => Types.Const list =	

  axiom	check_consts [] => []

  rule  check_const(a) => c &
	check_consts(rest) => rest'
	-------------------------------
	check_consts a::rest => c::rest'

end



(*PR. !! At the moment this make all outputs non cons.
* All ouputs sholud be checked in the function body for constness. 
*)
(* LS: but it says true? *)
(* LS: Adapted to check one type instead of funcarg, since it just checks return type *)
relation check_const : Types.Type => Types.Const  =	
	
  rule	print("\n Error. No support for tuples built by tuples. Yet.") 
	-------------------------------
	check_const (Types.T_TUPLE(_)) => fail

  axiom	check_const (_) => Types.CONST(true)
	
end

(* Splits the properties list into the separated types list and const list. *)
relation split_props : (Types.Properties list) => (Types.Type list, Types.Const list) =
  rule 	(*list_append(ts,t::[]) => t1 &
	list_append(cs,Types.CONST(c)::[]) => t2 &
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (Types.PROP(t,c)::props)=> (t::types,Types.CONST(c)::consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	(*list_append(cs, t_c::[]) => cs' & 
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (Types.PROP_TUPLE(t,t_c)::props)=> (t::types,t_c::consts)
  
  axiom	split_props([]) => ([], [])
end










(* obsolete LS: added space to inner comments, for emacs fontify to work
relation split_props: (Types.Properties list, Types.Type list, Types.Const list) => (Types.Type list, Types.Const list) =
  rule 	list_append(ts,t::[]) => t1 &
	list_append(cs,Types.CONST(c)::[]) => t2 &
	split_props(props, t1, t2) => (types, consts)
	-------------------------------------
	split_props (Types.PROP(t,c)::props, ts, cs)=> (types,consts)

  rule 	( *  list_append(ts,t::[]) => ts' &   * )
	list_append(cs, t_c::[]) => cs' & 
	split_props(props, [], cs') => (types, consts)
	-------------------------------------
	split_props (Types.PROP_TUPLE(t,t_c)::props, ts, cs)=> (types,consts)
  
  axiom	split_props([],ts,cs) => (ts, cs)
end
*)









(* LS: Changed to match FuncArg *)
relation get_types :(Types.FuncArg list) => Types.Type list =

  rule	(* print("\nDebug: Got a type for output of function. ") & *)
	get_types(rest) => types 
	-----------------
	get_types ((n,t)::rest) => t::types
	
  axiom	get_types ([]) => []
	
end


(** relation: functio_params
 **
 ** A function definition is just a clas definition where all publi
 ** components are declared as either inpu or outpu.  This
 ** relation_ find all those components and_ separates them into two
 ** separate lists.
 **)

(* LS: This can probably replaced by Types.get_input_vars and
   Types.get_output_vars *)

relation function_params : Types.Var list => (Types.FuncArg list,
					      Types.FuncArg list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	Debug.print("protected") &
	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	Debug.print("not protected. intput") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	Debug.print("not protected. output") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	Print.print_buf "# Components in functions must be INPUT or OUTPUT\n" &
	Print.print_buf "    component: " & Print.print_buf n & Print.print_buf "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,Types.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	Print.print_buf "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(* * relation_: elab_input_args
 **
 ** This relation_ elaborates on a number of expressions and_ matches
 ** them to a number of `Types.Var' objects, applying type_ conversions
 ** on the expressions when necessary to match the type_ of the
 ** `Types.Var'.
 * *)

(* PR. env, input args from the function call, in arguments in the
 function_ definition. *)
(* LS: inserted FuncArg *)
(* PA: Positional arguments and named arguments are filled in the argument slots as:
 1. Positional arguments fill the first slots according to their position.
 2. Named arguments fill slots with the same name as the named argument.
 3. Unfilled slots are checks so that they have default values, otherwise error.
*)
relation elab_input_args : (Env.Env, Absyn.Exp list, Absyn.NamedArg list, Slot list)
	=> (Exp.Exp list, Slot list, bool) =

  rule	Debug.fprint ("sei","elab_input_args, positional arguments\n") &
	funcarg_lst_from_slots(slots) => farg &
	elab_positional_input_args(env,exp,farg,slots) => (slots',c) &
	elab_input_args(env,[],narg,slots') => (_,newslots,c2) &
	bool_and(c,c2) => c3 &
	exp_list_from_slots(newslots) => explst
	----------------------------------------------------------------
	elab_input_args(env,exp as _::_,narg,slots) => (explst,newslots,c3)

  rule	Debug.fprint ("sei","elab_input_args, named arguments\n") &
	funcarg_lst_from_slots(slots) => farg &
	Debug.fprint ("sei","elab_input_args, got funcarg\n") &
	elab_named_input_args(env,narg,farg,slots) => (newslots,c) &
	exp_list_from_slots(newslots) => newexp &
	Debug.fprint ("sei","elab_input_args, got expressions: ") &
	Debug.fprint_list ("sei",newexp,Exp.print_exp,", ")
	------------------------------------------------------------
	elab_input_args(env,[],narg as _::_,slots) => (newexp,newslots,c)
	
  axiom	elab_input_args(env,[],[],slots) => ([],slots,true)
	
(*  rule	Print.print_buf "#Error, elab_input_args failed.\n"
	-----------------------------------------
	elab_input_args(_,_,_,_) => fail*)
end

relation make_empty_slots : (Types.FuncArg list) => Slot list =
	
  axiom	make_empty_slots([]) => []
	
  rule	make_empty_slots(fs) => ss
	--------------------------
	make_empty_slots(fa::fs) => SLOT(fa,false,NONE)::ss
end

relation funcarg_lst_from_slots : Slot list => Types.FuncArg list =
	
  axiom	 funcarg_lst_from_slots [] => [] 

  rule	funcarg_lst_from_slots(xs) => fs
	-------------------------------
	funcarg_lst_from_slots(SLOT(fa,_,_)::xs) => fa::fs
end 

relation exp_list_from_slots: (Slot list ) => Exp.Exp list =
	
  axiom	exp_list_from_slots [] => []
	
  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,SOME(e))::xs) => e::lst

  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,NONE)::xs) => lst
end

(** relation: fill_default_slots
 ** This function takes a slot list and a class definition of a function and fills default values into slots which 
 ** have not been filled.
   **)
	
relation fill_default_slots: (Slot list , SCode.Class, Env.Env) => Slot list =
	
  rule	fill_default_slots(xs,class,env) => res
	----------------------------
	fill_default_slots ( SLOT(fa,true,e)::xs,class,env) => SLOT(fa,true,e)::res

  rule	fill_default_slots(xs,class,env) => res &
	SCode.get_element_named(id,class) => SCode.COMPONENT(_,_,_,_,_,_,SCode.MOD(_,_,SOME(dexp))) &
	elab_exp (env,dexp,false,NONE) => (exp,Types.PROP(t,c1),_) &
	Types.match_type(exp,t,tp) => (exp',_) 
	---------------------------------------------------------------------------------
	fill_default_slots (SLOT((id,tp),false,e)::xs,class,env) => SLOT((id,tp),true,SOME(exp'))::res

  rule	fill_default_slots(xs,class,env) => res &
	Print.print_buf "#Error filling slot, id =" &
	Print.print_buf id &
	Print.print_buf "\n"
	----------
	fill_default_slots (SLOT((id,tp),false,e)::xs,class,env) => SLOT((id,tp),true,e)::xs

  axiom	fill_default_slots([],_,_) => []
end

relation print_slots: Slot list => () =
  rule	Print.print_buf "SLOT(" &
	Types.print_farg farg &
	Print.print_buf  ", " &
	Dump.print_select(filled,"filled","not filled") &
	Print.print_buf ", " &
	Dump.get_option_str(exp,Exp.print_exp_str) => str &
	Print.print_buf str &
	Print.print_buf ")\n" &
	print_slots(xs)
	---------------
	print_slots (SLOT(farg,filled,exp)::xs) => ()
  axiom	print_slots([] ) => ()
end 

(** relation: elab_positional_input_args
 ** This relation elaborates the positional input arguments of a function.
 ** A list of slots is filled from the beginning with types of each positional argument.
 **)
relation elab_positional_input_args : (Env.Env, Absyn.Exp list, Types.FuncArg list,  Slot list) 
	  => (Slot list, bool) =
	  
  axiom	elab_positional_input_args(_, [], _, slots) => (slots, true)
	
  rule	elab_exp(env, e,false,NONE) => (e',Types.PROP(t, c1),_) &
	Types.match_type(e', t, vt) => (e'',_) &
	elab_positional_input_args(env, es, vs,slots) => (slots',c2) &
	bool_and(c1, c2) => c &
	fill_slot(farg, e'',slots') => newslots
	-------------------------------------
	elab_positional_input_args(env, e::es, (farg as (_,vt))::vs, slots) 
	    => (newslots, c)
end

(** relation elab_named_input_args
 ** This relation takes an Env, a NamedArg list, a Types.FuncArg list and a Slot list.
 ** It builds up a new slot list and a list of elaborated expressions.
 ** If a slot is filled twice the relation fails. If a slot is not filled at all and the 
 ** value is not a parameter or a constant the relation also fails.
*)
relation elab_named_input_args : (Env.Env, Absyn.NamedArg list, Types.FuncArg list, Slot list) 
	=> (Slot list, bool) =

(*  rule	check_slots_filled(env,slots) 
	----------------------------
	elab_named_input_args(env,[],farg,slots) => ([],slots,true) *)

  rule	elab_exp(env, e,false,NONE) => (e',Types.PROP(t, c1),_) &
	Debug.fprint("sei", "elab_named_input_arg, elaborated exp\n  id =") &
	Debug.fprint("sei",id) &
	find_named_arg_type(id,farg) => vt &
	Debug.fprint ("sei", "elab_named_input_arg, found type\n") &
	Debug.fprint ("sei", "exp t = " ) &
	Debug.fcall ("sei", Types.print_type,t ) &
	Debug.fprint ("sei", "func t = " ) &
	Debug.fcall ("sei", Types.print_type,vt ) &
	Types.match_type(e', t, vt) => (e'',_) &
	Debug.fprint ("sei", "elab_named_input_arg, Types matched!\n") &
	fill_slot((id,vt), e'', slots) => slots' &
	Debug.fprint ("sei", "elab_named_input_arg, filled slot\n") &
	elab_named_input_args(env, nas, farg ,slots') => (newslots, c2) &
	bool_and(c1, c2) => c 
	---------------------
	elab_named_input_args (env, Absyn.NAMEDARG(id,e)::nas,farg,slots) 
	  => (newslots, c)

axiom elab_named_input_args (_,[],_,slots) => (slots,true)

  rule	Debug.fprint ("sei","elab_named_input_args failed, nargs = ") &
	Debug.fprint_list ("sei", narg, Dump.print_named_arg," ,")&
	Debug.fprint ("sei"," FuncArg=") &
	Debug.fcall  ("sei",Types.print_params,farg) &
	Debug.fprint ("sei", "\n")
	-----------------
	elab_named_input_args(env,narg,farg,_) => fail
end

(** relation find_named_arg_type
 ** This relation takes an Ident and a FuncArg list, and returns the FuncArg which has that identifier.
 ** Used for instance when looking up named arguments from the function type.
 **)
 relation find_named_arg_type : (Ident, Types.FuncArg list) => Types.Type =
	 
  rule	 id = id2
	 -----------------
	 find_named_arg_type (id, ((id2,farg))::ts) => farg
  rule	 not id = id2  &
	 find_named_arg_type (id,ts) => farg
	 ----------------------------------
	 find_named_arg_type(id,(farg as (id2,_))::ts) => farg
end

(** relation: fill_slot
 ** This relation takses a `FuncArg' and an Exp.Exp and a Slot list and fills the slot holding the FuncArg, by setting
 ** the boolean value of the slot and setting the expression. The relation fails if the slot is allready set.
 **)
relation fill_slot:(Types.FuncArg, Exp.Exp, Slot list) => Slot list =
	
  rule	fa1 = fa2
	---------
	fill_slot((fa1,_), exp,SLOT((fa2,b),false,_)::xs) => SLOT((fa2,b),true,SOME(exp))::xs

  rule	fa1 = fa2 &
	Print.print_buf "#Error, slot in functional argument allready filled.\b" 
	--------------------------------------------------------------
	fill_slot((fa1,_),exp, SLOT((fa2,b),true,_)::xs) => fail

  rule	not fa1 = fa2 &
	fill_slot(farg,exp,xs) => newslots
	------------------------------
	fill_slot((farg as (fa1,_)), exp,(s1 as SLOT((fa2,_),_,_))::xs) => s1::newslots

  rule  Print.print_buf "#Error, slot not found in function type.\n"
	---------------------------------------------------
	fill_slot(_,_,_) => fail
end

(* LS *)

relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	=> (Exp.Exp list, Types.Properties list, SCode.Accessibility list) =

  axiom	elab_cref_list (_, []) => ([], [], [])

  rule	elab_cref (env, cref) => (exp, prop, acc) &
	elab_cref_list (env, creflist) => (explist, proplist, acclist)
	----------------------------------------------------------
	elab_cref_list (env, cref::creflist) 
	  => (exp::explist, prop::proplist, acc::acclist)

end


(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Types.Properties, SCode.Accessibility) =

  rule	elab_cref_subs (env,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,acc,variability,_),
				       t,
				       binding) &
	Debug.fprint("ecref","elab_cref, looked up type:\n") &
	Debug.fcall("ecref",Types.print_type,t) &

	elab_cref2 (env, c', acc, variability, t, binding)
	  => (exp,const,acc') 
	(* FIXME subscript_cref_type (exp,t) => t' &  *)
	---------------------------------
	elab_cref(env, c) => (exp, Types.PROP(t, const), acc')

  rule	elab_cref_subs (env,c) => (c', const) &
	Print.print_buf "# Unknown component: " & Dump.print_component_ref c & Print.print_buf "\nenv:" &
	Env.print_env env & print "# Unknown component." 
	-----------------------------------------------------
	elab_cref(env, c) => fail

  rule	Print.print_buf "- elab_cref failed: " & Dump.print_component_ref c & Print.print_buf "\n" & print "- elab_cref_failed , cr= " & Dump.print_component_ref_str c => s1 & print s1 & print " envpath =" &
	Env.get_env_path env => SOME(envpath) & ModUtil.path_string(envpath) => s2 & print s2 & print "\n"
	------------------------------
	elab_cref (env,c) => fail

end

relation fill_cref_subscripts : (Exp.ComponentRef,Types.Type)
	  => Exp.ComponentRef =

  axiom	fill_cref_subscripts (e as Exp.CREF_IDENT(_,[]),t) => e

  rule	fill_subscripts (subs,t) => subs'
	------------------
	fill_cref_subscripts (Exp.CREF_IDENT(id,subs),t)
	  => Exp.CREF_IDENT(id,subs')

  rule	fill_cref_subscripts (cref,t) => cref'
	-----------------------------
	fill_cref_subscripts (Exp.CREF_QUAL(id,subs,cref),t)
			      => Exp.CREF_QUAL(id,subs,cref') 

end

relation fill_subscripts : (Exp.Subscript list, Types.Type) 
	  => Exp.Subscript list =

rule	fill_subscripts ([],t) => subs' &
	list_append([Exp.WHOLEDIM],subs') => subs''
	------------
	fill_subscripts ([],Types.T_ARRAY(_,t)) => subs''

  rule	fill_subscripts (subs,t) => subs' 
	------------
	fill_subscripts (fs::subs,Types.T_ARRAY(_,t)) => fs::subs'

  axiom	fill_subscripts (subs,_) => subs

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef,
		       SCode.Accessibility, SCode.Variability,
		       Types.Type, Types.Binding)
	  => (Exp.Exp,bool,SCode.Accessibility) =

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	-----------------
	elab_cref2 (_,cr, acc, SCode.VAR, tt,_) => (Exp.CREF(cr',t),false, acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	------------------
	elab_cref2 (_,cr, acc, SCode.DISCRETE,tt,_)
	  =>(Exp.CREF(cr',t),false,acc)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,SCode.CONST,t, Types.VALBOUND(v)) => (e,true,SCode.RO)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	value_exp v => e'
	----------------
  	elab_cref2 (env,cr,acc,SCode.PARAM,tt, Types.VALBOUND(v)) => ((*Exp.CREF(cr',t)*)e',true,acc) (* Change here when struct params work *)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	value_exp v => e'
	----------------
  	elab_cref2 (env,cr,acc,SCode.STRUCTPARAM,tt, Types.VALBOUND(v)) => (e',true,acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	----------------
	elab_cref2 (env,cr,acc,_,tt, Types.EQBOUND(exp,true))
	  => (Exp.CREF(cr',t),true,acc)

	  (* Enum constants does not have a value expression *)
  rule	Types.elab_type tt => t
	-----------------
	elab_cref2(env,cr,acc,_,tt as Types.T_ENUM,_) => (Exp.CREF(cr,t),true,acc)

  rule	print "elab_cref2 nonconstant\n"&
	(* If value not constant, but references another parameter, which has a value *)
	(* We need to perform value propagation. *)
	Lookup.lookup_var(env,cref) => (Types.ATTR(_,acc',variability',_),
				       t',
				       binding') &
	elab_cref2(env,cref,acc',variability',t',binding') => (e,const,acc)
	--------------------------------------------------
	elab_cref2 (env,cr,acc, variability,tp,Types.EQBOUND( Exp.CREF(cref,t),false)) 
	  => (e,const,acc)


  rule	print "# Constant or parameter with a non-constant initializer\n" &
	Print.print_buf "# Constant or parameter with a non-constant initializer\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr & Print.print_buf " = " &
	Exp.print_exp exp & Print.print_buf "\n"
	------------------------------
	elab_cref2 (_,cr,_, _,_,Types.EQBOUND(exp,false)) => fail

  rule	print "# Constant or parameter without a value\n" &
	Print.print_buf "# Constant or parameter without a value\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr 
	& Print.print_buf " env:\n" & Env.print_env env & Print.print_buf "\n"
	----------------------------------------------
	elab_cref2 (env,cr,_,_,_,Types.UNBOUND) => fail

  rule	print "- elab_cref2 failed (component: " &
	Print.print_buf "- elab_cref2 failed (component: " &
	Exp.print_component_ref cr & Print.print_buf ")\n"
	----------------------------------------
	elab_cref2 (_,cr,_,_,_,_) => fail

end	

(** relation: elab_cref_subs
 **
 ** This relation elaborates on all subscripts in a component reference.
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)


  rule	print "- elab_cref_subs failed\n" 
	---------------------
	elab_cref_subs(_,_) => fail
end

(** relation: elab_subscripts
 **
 ** This relation converts a list of `Absyn.Subscript' to a list of
 ** `Exp.Subscript', and checks if all subscripts are constant.
 ** HJ: not checking for constant, returning if constant or not
 **)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => true &
	ceval_subscripts(env, sub'::subs') => ss
	-----------------------------------
	elab_subscripts (env,sub::subs) => (ss, true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => false
	-----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs', false)

end

(** relation: elab_subscript
 **
 ** This relation converts an `Absyn.Subscript' to an
 ** `Exp.Subscript'.
 **)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.WHOLEDIM, true)

  rule	elab_exp (env,sub,false,NONE) => (sub', Types.PROP(ty, const),_) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub)) => (sub'', const)

end

(** relation: elab_subscript_type
 **
 ** This relation is used to find the correct constructor for
 ** `Exp.Subscript' to use for an indexing expression.  If an integer
 ** is given as index, `Exp.INDEX()' is used, and if an integer array
 ** is given, `Exp.SLICE()' is used.
 **)

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type (Types.T_INTEGER(_),_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type (Types.T_ARRAY(_,Types.T_INTEGER(_)),_,sub)
	  => Exp.SLICE(sub)

  rule	Print.print_buf "# Subscript is not an integer or integer array\n" &
	Print.print_buf "    expression: " & Dump.print_exp e &
 	Print.print_buf " :: " & Types.print_type t & Print.print_buf "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **
 ** This relation might actually not be needed.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c,_), t) => t'

  axiom	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (t,subs) => t'
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs), t) => t'

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **
 ** This does not handle slices or check that subscripts are not out
 ** of bounds.
 **)

relation subscript_type : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom	subscript_type (t,[]) => t

  rule	subscript_type (t, subs) => t'
	----------------------------------
	subscript_type (Types.T_ARRAY(Types.DIM(_),t),
			Exp.INDEX(_)::subs) => t'

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.SLICE(_)::subs)
	  => Types.T_ARRAY(dim,t')

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.WHOLEDIM::subs)
	  => Types.T_ARRAY(dim,t')

  rule	Print.print_buf "- subscript_type failed (" & Types.print_type t &
	Print.print_buf " , [...])\n"
	-------------------
	subscript_type (t,_) => fail

end

(** relation: elab_ifexp
 ** 
 ** This relation elaborates on the parts of an if expression.
 **)

relation elab_ifexp : (Exp.Exp, Types.Properties,
		       Exp.Exp, Types.Properties,
		       Exp.Exp, Types.Properties)
	  => (Exp.Exp, Types.Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,Types.PROP(Types.T_BOOL(_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3), Types.PROP(t2, c))

  rule	Types.match_type(e2,t2,t3) => (e2',t2') & (* then-part type converted to match else-part *)
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,Types.PROP(Types.T_BOOL(_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3)) => (Exp.IFEXP(e1,e2',e3), Types.PROP(t2', c))

  rule	Types.match_type(e3,t3,t2) => (e3',t3') & (* else-part type converted to match then-part *)
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,Types.PROP(Types.T_BOOL(_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3'), Types.PROP(t2, c))

  rule	not t1 = Types.T_BOOL([]) &
	Print.print_buf "# conditional in if expression has to be boolean\n" &
	Print.print_buf "    got type: " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    expression: " & Exp.print_exp e1 & Print.print_buf "\n"
	--------------------------------------------------------
	elab_ifexp(e1,Types.PROP(t1,c1),e2,Types.PROP(t2,c2),e3,Types.PROP(t3,c3)) => fail

  rule	Types.equivtypes(t2,t3) => false &
	Print.print_buf "# Type mismatch in if-expression\n" &
	Print.print_buf "    true branch : " & Exp.print_exp e2 &
 	Print.print_buf " :: " & Types.print_type t2 & Print.print_buf "\n" &
	Print.print_buf "    false branch: " & Exp.print_exp e3 &
 	Print.print_buf " :: " & Types.print_type t3 & Print.print_buf "\n"
	-----------------------------------------------
	elab_ifexp(e1,Types.PROP(Types.T_BOOL(_),c1),
		   e2,Types.PROP(t2,c2),e3,Types.PROP(t3,c3)) => fail

  rule	Print.print_buf "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_) => fail

end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, bool, bool, bool) => bool =

  axiom	const_ifexp(_,true,true,true) => true
  axiom	const_ifexp(_,_,_,_) => false

end

(** relation: ceval
 **
 ** This relations is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 ** The third argument indicates whether the evaluation is performed in the interactive environment, 
 ** in which case function calls are evaluated.
 **)

relation ceval : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	    => (Values.Value, Interactive.InteractiveSymbolTable option) =

  axiom	ceval (_,Exp.ICONST(x),_,st) => (Values.INTEGER(x),st)
  axiom	ceval (_,Exp.RCONST(x),_,st) => (Values.REAL(x),st)
  axiom ceval (_,Exp.SCONST(x),_,st) => (Values.STRING(x),st)
  axiom ceval (_,Exp.BCONST(x),_,st) => (Values.BOOL(x),st)

  axiom	ceval (_,Exp.CODE(c,_),_,st) => (Values.CODE(c),st)

  rule	ceval_list (env,es,impl,st) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(_,_,es),impl,st) => (Values.ARRAY(es'),st)

  rule	ceval_matrixelt(env,expll) => elts
	------------------------------
	ceval (env, Exp.MATRIX(_,_,expll),_,st) => (Values.ARRAY(elts),st)

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c,_),_,st) => (v,st) 

  rule	Print.print_buf "# Can't call functions at compile time\n" &
	Print.print_buf "    expression: " & Exp.print_exp e & Print.print_buf "\n"
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(_,_,_,_),false,NONE) => fail

  rule	Print.print_buf "implicit evaluation of function calls without symbol table\n" 
	-------------------------------------------
	ceval(env, e as Exp.CALL(_,_,_,_),true,NONE) => fail

  rule	ceval_interactive_functions(env,e,st) => (value,st)
	-------------------------------------
	ceval (env, e as Exp.CALL(_,_,_,_),true, SOME(st)) => (value,SOME(st))

  rule	(* Call externally implemented functions. *) 
	ceval_list(env,expl,true,st) => vallst &
	ModUtil.path_string2(func,"_") => funcstr &
	string_append(funcstr,"_in.txt") => infilename &
	string_append(funcstr,"_out.txt") => outfilename &
	Values.write_to_file_as_args(vallst,infilename)  &
	System.execute_function(funcstr) &
	System.read_values_from_file(outfilename) => newval
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(func,expl,_,_),true,st as SOME(_)) => (newval,st)

	(** Strings **)
	
  rule  ceval (env, lh, impl,st) => (Values.STRING(lhv),_) &
	ceval (env, rh, impl,st) => (Values.STRING(rhv),_) &
	string_append(lhv,rhv) => str
	-----------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.STRING), rh),impl,st)
	  => (Values.STRING(str),st)

	(**  Numerical *)

  rule	ceval (env, lh, impl,st) => (Values.REAL(lhv),st') &
	ceval (env, rh, impl,st') => (Values.REAL(rhv),st'') &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh),impl,st)
	  => (Values.REAL(sum),st'')

  rule	ceval (env,lh,impl,st) => (Values.ARRAY(vlst1),st') &
	ceval (env,rh,impl,st') => (Values.ARRAY(vlst2),st'') &
	Values.add_elementwise_arrayelt(vlst1, vlst2) => reslst
	-------------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD_ARR(_),rh),impl,st) 
	  => (Values.ARRAY(reslst),st'')

  rule	ceval (env,lh,impl,st) => (Values.ARRAY(vlst1),st') &
	ceval (env,rh,impl,st') => (Values.ARRAY(vlst2),st'') &
	Values.sub_elementwise_arrayelt(vlst1, vlst2) => reslst
	-------------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB_ARR(_),rh),impl,st) => (Values.ARRAY(reslst),st'')

  rule	ceval (env,lh,impl,st) => (sval,st') &
	ceval (env,rh,impl,st') => (Values.ARRAY(aval),st'') &
	Values.mult_scalar_arrayelt(sval,aval) => reslst
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_ARRAY(_), rh),impl,st) 
	  => (Values.ARRAY(reslst),st'')

  rule	ceval (env,rh,impl,st) => (sval,st') &
	ceval (env,lh,impl,st') => (Values.ARRAY(aval),st'') &
	Values.mult_scalar_arrayelt(sval,aval) => reslst
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_ARRAY_SCALAR(_), rh),impl,st) 
	  => (Values.ARRAY(reslst),st'')

  rule	ceval (env,rh,impl,st) => (Values.ARRAY(rhvals),st') &
	ceval (env,lh,impl,st') => (Values.ARRAY(lhvals),st'') &
	Values.mult_scalar_product(rhvals,lhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_PRODUCT(_), rh),impl,st) => (res,st'')
	
  rule	(* {{..}..{..}} * {...} *)
	ceval (env,lh,impl,st) => (Values.ARRAY(lhvals as (elt1::_)),st') &
 	ceval (env,rh,impl,st') => (Values.ARRAY(rhvals as (elt2::_)),st'') &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => false &
	Values.mult_scalar_product(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st) => (res,st'')

 rule	(* {...} * {{..}..{..}} *)
	ceval (env,rh,impl,st) => (Values.ARRAY(rhvals as (elt1::_)),st') &
 	ceval (env,lh,impl,st') => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => false &
	Values.mult_scalar_product(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st) => (res,st'')

 rule	(* {{..}..{..}} * {{..}..{..}} *)
	ceval (env,rh,impl,st) => (Values.ARRAY(rhvals as (elt1::_)),st') &
 	ceval (env,lh,impl,st') => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => true &
	Values.mult_matrix(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st) 
	  => (Values.ARRAY(res),st'')

  rule	ceval (env,lh,impl,st) => (Values.INTEGER(lhv),st') &
	ceval (env,rh,impl,st') => (Values.INTEGER(rhv),st'') &
	int_add(lhv, rhv) => sum
	------------------------
 	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh),impl,st) 
	  => (Values.INTEGER(sum),st'')
	(**)
  rule	ceval (env,lh,impl,st) => (Values.REAL(lhv),st') &
	ceval (env,rh,impl,st') => (Values.REAL(rhv),st'') &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh),impl,st) 
	  => (Values.REAL(sum),st'')

  rule	ceval (env,lh,impl,st) => (Values.INTEGER(lhv),st') &
	ceval (env, rh,impl,st') => (Values.INTEGER(rhv),st'') &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh),impl,st)
	  => (Values.INTEGER(sum),st'')
	(**)
  rule	ceval (env,lh,impl,st) => (Values.REAL(lhv),st') &
	ceval (env,rh,impl,st') => (Values.REAL(rhv),st'') &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh),impl,st) 
	  => (Values.REAL(sum),st'')

  rule	ceval (env,lh,impl,st) => (Values.INTEGER(lhv),st') &
	ceval (env,rh,impl,st') => (Values.INTEGER(rhv),st'') &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh),impl,st)
	  => (Values.INTEGER(sum),st'')
	(**)
  rule	ceval (env,exp,impl,st) => (Values.REAL(x),st') &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp),impl,st)
	  => (Values.REAL(x'),st')

  rule	ceval (env,exp,impl,st) => (Values.INTEGER(x),st') &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp),impl,st)
	  => (Values.INTEGER(x'),st')
	(**)
  rule	ceval (env,exp,impl,st) => (Values.REAL(x),st') &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp),impl,st)
	  => (Values.REAL(x'),st')

  rule	ceval (env,exp,impl,st) => (Values.INTEGER(x),st') &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp),impl,st)
	  => (Values.INTEGER(x'),st')

	(**  Logical *)

  rule	ceval (env,lh,impl,st) => (Values.BOOL(lhv),st') &
	ceval (env,rh,impl,st') => (Values.BOOL(rhv),st'') &
	bool_and(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.AND, rh),impl,st)
	  => (Values.BOOL(x),st'')

  rule	ceval (env,lh,impl,st) => (Values.BOOL(lhv),st') &
	ceval (env,rh,impl,st') => (Values.BOOL(rhv),st'') &
	bool_or(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.OR, rh),impl,st)
	  => (Values.BOOL(x),st'')

  rule	ceval (env,e,impl,st) => (Values.BOOL(b),st') &
	bool_not(b) => b'
	-----------------
	ceval (env, Exp.LUNARY(Exp.NOT, e),impl,st) => (Values.BOOL(b'),st')

	(**  Relations *)

  rule	ceval (env,lhs,impl,st) => (lhs',st') &
	ceval (env,rhs,impl,st') => (rhs',st'') &
	ceval_relation (lhs',relop,rhs') => v
	-------------------------------------
	ceval (env, Exp.RELATION(lhs,relop,rhs),impl,st) => (v, st'')

	(**)

  rule	ceval (env,start,impl,st) => (Values.INTEGER(start'),st') &
	ceval (env,stop,impl,st') => (Values.INTEGER(stop'),st'') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.INT,start, NONE, stop),impl,st) 
	  => (Values.ARRAY(arr),st')

  rule	ceval (env,start,impl,st) => (Values.INTEGER(start'),st') &
	ceval (env,step,impl,st') => (Values.INTEGER(step'),st'') &
	ceval (env,stop,impl,st'') => (Values.INTEGER(stop'),st''') &
	ceval_range(start', step', stop') => arr 
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.INT,start, SOME(step), stop),impl,st) 
	  => (Values.ARRAY(arr),st''')

  rule	ceval (env,start,impl,st) => (Values.REAL(start'),st') &
	ceval (env,stop,impl,st') => (Values.REAL(stop'),st'') &
	real_sub(stop',start') => diff &
	int_real 1 => step & (* bug in rml, 1.0 => 0.0 in cygwin  *)
	ceval_range_real(start', step, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.REAL,start, NONE, stop),impl,st) 
	  => (Values.ARRAY(arr),st'')

  rule	
	ceval (env,start,impl,st) => (Values.REAL(start'),st') &
	ceval (env,step,impl,st') => (Values.REAL(step'),st'') &
	ceval (env,stop,impl,st'') => (Values.REAL(stop'),st''') &
	ceval_range_real(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.REAL,start, SOME(step), stop),impl,st) 
	  => (Values.ARRAY(arr),st''')

  rule	ceval (env,e,impl,st) => (Values.INTEGER(i),st') &
	int_real i => r
	---------------
	ceval (env, Exp.CAST(Exp.REAL,e),impl,st) => (Values.REAL(r),st')

  rule	ceval (env,e,impl,st) => (Values.ARRAY(ivals),st') &
	Values.type_convert(Exp.INT,Exp.REAL,ivals) => rvals
	----------------------------------------------------
	ceval (env, Exp.CAST(Exp.REAL,e),impl,st) => (Values.ARRAY(rvals),st')

  rule	ceval (env,e,impl,st) => (Values.ARRAY(vallst),st') &
	Values.type_convert(Exp.INT, Exp.REAL, vallst) => vallst'
	--------------------------
	ceval (env, Exp.CAST(Exp.REAL,e as Exp.ARRAY(Exp.INT,_,expl)),impl,st) 
	       => (Values.ARRAY(vallst'),st')

  rule	ceval (env,e,impl,st) => (Values.ARRAY(vallst),st') &
	Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	---------------------------------------
	ceval (env, Exp.CAST(Exp.REAL,e as Exp.RANGE(Exp.INT,_,_,_)),impl,st) => 
		(Values.ARRAY(vallst'),st')

  rule	ceval (env,e,impl,st) => (Values.ARRAY(vallst),st') &
	Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	---------------------------------------
	ceval (env, Exp.CAST(Exp.REAL,e as Exp.MATRIX(Exp.INT,_,_)),impl,st) => 
		(Values.ARRAY(vallst'),st')

  rule	Print.print_buf "- ceval " & Exp.print_exp e & Print.print_buf " failed\n"
	-----------------------------------------------------
	ceval (_,e,_,_) => fail
	
end

(* relation ceval_interactive_functions
** This relation evaluates the functions defined in the interactive environment.
*)
relation ceval_interactive_functions: (Env.Env, Exp.Exp, Interactive.InteractiveSymbolTable)
	=> (Values.Value, Interactive.InteractiveSymbolTable) =


  rule	component_ref_to_path(cr) => path &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	Lookup.lookup_class(env,path,true) => (c, env) &
	Env.get_env_path(env) => SOME(p1) &
	ModUtil.path_string(p1) => s1 &
	Print.print_buf "Found class " &
	Print.print_buf s1 & Print.print_buf "\n\n" &
	Print.get_string() => str
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("lookupClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	Interactive.get_type_of_variable(varid, iv) => tp &
	Types.unparse_type tp => str 
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("typeOf"),[Exp.CREF(Exp.CREF_IDENT(varid,_),_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	let newst = Interactive.SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[],[])
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clear"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,ic,[],cf)
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearVariables"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf)) => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,[],iv,cf)
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearCache"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf)) => (Values.BOOL(true),newst)

  rule	Dump.unparse_str(p) => str
	-------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	component_ref_to_path(cr) => path &
	Interactive.get_pathed_class_in_program(path,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str
	-------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	component_ref_to_path(cr) => path &
	SCode.elaborate(p) => p' &
	Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	DAE.dump_str (dae) => str &
	Print.get_string() => s2 &
	Print.print_error_buf s2 &
	
(*	let filename = "flatclass.mof" &
	System.write_file(filename,str) &
	
	ModSim.compile_flat_class(filename) => exefile &*)
	
	let record = Values.RECORD([Values.STRING(str),Values.INTEGER(1)],["flatClass","exefile"])
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (record,Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))

  rule	component_ref_to_path(cr) => path & 
	Absyn.path_string path => pathstr &
	Print.print_buf "Failed to instantiate " &
	Print.print_buf pathstr & Print.print_buf " .\n" &
	Print.get_string() => str 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)
	
  rule	System.time => t1 &
	ceval(env,exp,true,SOME(st)) => (value,st') &
	System.time => t2 &
	real_sub(t2,t1) => time 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("timing"),[exp],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.REAL(time),st)

  rule	System.set_c_compiler(str)
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompiler"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),st)

  rule	System.set_c_flags(str)
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompilerFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),st)

  rule	string_append("+d=",str) => str' &
	RTOpts.args [str'] => args 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setDebugFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),st)

  rule	System.cd(str) => res &
	int_eq (res,0) => true &
	System.pwd => str' 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str'),st)

  rule	System.pwd() => str'
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str'),st)

  rule	System.system_call(str) => res 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("system"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.INTEGER(res),st)


  rule	System.read_file(str) => str'
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readFile"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str'),st)

  rule	Print.get_error_string() => str &
	Print.clear_error_buf()
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("getErrorString"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	System.read_file(str) => scriptstr &
	Parser.parsestringexp(scriptstr) => istmts &
	Interactive.evaluate(istmts,st) => (res,newst)
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),newst)


  rule	SCode.elaborate(p) => p' &
	component_ref_to_path(cr) => path &
	ModUtil.path_string2 (path,"_") => pathstr &
 (*	Inst.instantiate_implicit(p') => d & *)
	Lookup.lookup_class(env, path, false) => (cls, env') &
	Inst.implicit_function_instantiation(env', Mod.NOMOD,
					     Prefix.NOPRE, [], cls, [], false)
	  => (env'',d) &

	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Print.clear_buf &
	Codegen.generate_functions(d') &
	string_append(pathstr,".c") => filename &
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf "\nint main(int argc, char** argv)\n{\n\n  if (argc != 3)\n    {\n      fprintf(stderr,\"# Incorrrect number of arguments\\n\");\n      return 1;\n    }\n" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
	Print.write_buf(filename)&
	System.compile_c_file(filename) 
	--------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("generateCode"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true), st)
	(* add path to symboltable for compiled functions
	 Interactive.SYMBOLTABLE(p,sp,ic,iv,(path,t)::cf),
	 but where to get t? *)

  rule	System.modelicapath => mp &	
	component_ref_to_path(cr) => path &
	ClassLoader.load_class(path, mp) => pnew &
	Interactive.update_program(pnew,p) => p' &
	Print.get_string => str &
	let newst = Interactive.SYMBOLTABLE(p', sp, [], iv, cf)
	------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),newst)
	
  rule	component_ref_to_path(cr) => path &
	ModUtil.path_string(path) => pathstr &
	Util.string_append_list(["Class ",pathstr," not found in MODELICAPATH.\n"])=> str &
	Print.print_error_buf str
	------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(false),st)

  rule	Parser.parse(name) => p1 &
	Interactive.update_program(p1,p) => newp
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(true),Interactive.SYMBOLTABLE(newp,sp,[],iv,cf))

  rule	not Parser.parse(name) => _
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(false),st)

  rule	component_ref_to_path(cr) => classpath &
	Interactive.get_pathed_class_in_program(classpath,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str &
	System.write_file(filename,str) 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveClass"),[Exp.SCONST(filename),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(true),st)

  rule	(*Error writing to file *)
	component_ref_to_path(cr) => classpath &
	Interactive.get_pathed_class_in_program(classpath,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str &
	Print.print_error_buf "Error writing to file.\n" 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveClass"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(false),st)

  rule	(*Error writing to file *)
	component_ref_to_path(cr) => classpath &
	Print.print_error_buf "Error unknown class.\n" 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveClass"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(false),st)

  rule	System.read_env("MOSHHOME") => moshhome &
	string_append(moshhome,"/../modeq/helptext.txt") => filename &
	print filename & 
	System.read_file(filename) => str 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("help"),[],_,_),
				     st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.STRING(str),st)

  rule	get_builtin_attribute(classname,cref,"unit",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getUnit"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"quantity",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getQuantity"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"displayUnit",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getDisplayUnit"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"min",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMin"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"max",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMax"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"start",st) => (v, st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStart"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"fixed",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getFixed"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"nominal",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getNominal"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"stateSelect",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStateSelect"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

end

relation get_builtin_attribute: (Exp.ComponentRef, Exp.ComponentRef, string,
				 Interactive.InteractiveSymbolTable) 
	  => (Values.Value, Interactive.InteractiveSymbolTable) =

  rule	(* Check cached instantiated class *)
	component_ref_to_path(classname) => classname' &
	Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	Lookup.lookup_var(env,cref') => (attr,ty,Types.EQBOUND(exp,_)) &
	Exp.print_exp_str exp => str
	--------------------------------
	get_builtin_attribute(classname,cref,"stateSelect",
			      st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str),st)

  rule	component_ref_to_path(classname) => classname' &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	  Env.open_scope(env',encflag) => env'' &
	Env.name_scope(env'',n) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in(env3, Mod.NOMOD, Prefix.NOPRE, [], ci_state, 
			   c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys) &
	Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	Lookup.lookup_var(env4,cref') => (attr,ty,Types.EQBOUND(exp,_)) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' &
	Exp.print_exp_str exp => str
	--------------------------------
	get_builtin_attribute(classname,cref,"stateSelect",
			      Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str), Interactive.SYMBOLTABLE(p,sp,ic',vars,cf))

  rule	component_ref_to_path(classname) => classname' &
	Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	Lookup.lookup_var(env,cref') => (attr,ty,Types.VALBOUND(v)) 
	-----------------------------------------------
	get_builtin_attribute(classname,cref,attribute,
			      st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, st)

  rule	component_ref_to_path(classname) => classname' &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	  Env.open_scope(env',encflag) => env'' &
	Env.name_scope(env'',n) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in(env3, Mod.NOMOD, Prefix.NOPRE, [], ci_state, 
			   c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys) &
	Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	Lookup.lookup_var(env4,cref') => (attr,ty,Types.VALBOUND(v)) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' 
	-----------------------------------------------
	get_builtin_attribute(classname,cref,attribute,
			      st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, Interactive.SYMBOLTABLE(p,sp,ic',vars,cf)) 
end 

relation ceval_matrixelt:(Env.Env,(Exp.Exp*bool) list list) => Values.Value list =

  rule	ceval_matrixeltrow(env,expl) => v &
	ceval_matrixelt(env,expll) => vl
	---------------------------
	ceval_matrixelt(env,expl::expll) => v::vl
	
  axiom	ceval_matrixelt(_,[]) => []
end

relation ceval_matrixeltrow:(Env.Env, (Exp.Exp*bool) list ) => Values.Value =
	
  rule	ceval (env,e,false,NONE) => (res,_) &
	ceval_matrixeltrow(env,rest) => Values.ARRAY(resl)
	-------------------
	ceval_matrixeltrow(env, (e,_)::rest) => Values.ARRAY(res::resl)
	
  axiom	 ceval_matrixeltrow(env,[]) => Values.ARRAY([])

end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	-----------------------------------------
	ceval_relation (v1, Exp.GREATER(t), v2) => v

	(**  Integers *)

  rule	int_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.LESS(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.EQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.NEQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

	(**  Reals *)

  rule	real_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.LESS(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.EQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.NEQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	Print.print_buf "- ceval_relation failed\n"
	---------------------------------
	ceval_relation (_,_,_) => fail

end

(** relation: ceval_range
 **
 ** This relation evaluates a range expression.  It only handles integers.
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_eq(start,stop) => true (* e.g. 1:1 => {1} *)
	------------------
	ceval_range(start,_,stop) => [Values.INTEGER(start)]

  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	int_gt(j,k) => b1 &
	int_gt(d,0) => b2 &
	bool_and(b1,b2) => c1 &
	int_lt(j,k) => b3 &
	int_lt(d,0) => b4 &
	bool_and(b3,b4) => c2 &
	bool_or(c1,c1) => true
	-----------------------------
	ceval_range(j,d,k) => []

rule	ceval_range2(start,step,stop) => res
	-----------------------------------
	ceval_range (start, step, stop) => res

end

relation ceval_range2: (int,int,int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range2 (start,_,stop) => []	

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range2 (next, step, stop) => l
	-----------------------------------
	ceval_range2 (start, step, stop) => Values.INTEGER(start)::l
end
	


(** relation: ceval_range_real
 **
 ** This relation evaluates a range expression.  It only handles reals
 **)

relation ceval_range_real : (real, real, real) => Values.Value list =

  rule	real_eq(start,stop) => true (* e.g. 1:1 => {1} *)
	------------------
	ceval_range_real(start,_,stop) => [Values.REAL(start)]

  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	real_gt(j,k) => b1 &
	real_gt(d,0.0) => b2 &
	bool_and(b1,b2) => c1 &
	real_lt(j,k) => b3 &
	real_lt(d,0.0) => b4 &
	bool_and(b3,b4) => c2 &
	bool_or(c1,c1) => true
	-----------------------------
	ceval_range_real(j,d,k) => []

rule	ceval_range_real2(j,d,k)=> res
	-----------------------------------
	ceval_range_real (j,d,k) => res
end

relation ceval_range_real2 : (real, real, real) => Values.Value list =

  rule	real_gt(start,stop) => true
	--------------------------
	ceval_range_real2 (start,_,stop) => []

  rule	real_gt(start,stop) => false & (* redundant *)
	real_add (start, step) => next &
	ceval_range_real2 (next, step, stop) => l 	
	-----------------------------------
	ceval_range_real2 (start, step, stop) => Values.REAL(start)::l
end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

relation ceval_list : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option) 
	    => Values.Value list =
	  
  rule	ceval (env, exp,impl,st) => (v,_)
	----------------------------
	ceval_list (env, [exp],impl,st) => [v]

  rule	ceval (env,exp,impl,st) => (v,_) &
	ceval_list (env, exps,impl,st) => vs
	------------------------------
	ceval_list (env, exp::exps,impl,st) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

(* Uncomment this when struct params work *)
(*  rule	(* Parameters should not be evaluated. Exception: structural parameters *)
	Lookup.lookup_var (env, c) => (Types.ATTR(_,_,SCode.PARAM,_),_,binding) 
	-------------------------------------
	ceval_cref (env,c) => fail *)

  rule	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,c,binding) => v
	-------------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	Print.print_buf "# No constant binding for " &
	Exp.print_component_ref c & Print.print_buf "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Exp.ComponentRef,Types.Binding) => Values.Value =

  rule	ceval_subscript_value(env,subsc,v) => res
	-----------------------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(_,subsc),Types.VALBOUND(v))
	  => res

  rule	Print.print_buf "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND) => fail
	
  rule	ceval (env,exp,false,NONE) => (v,_)
	------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(_,[]),Types.EQBOUND(exp,true)) => v

  rule	Print.print_buf "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Exp.print_exp exp & Print.print_buf ")\n"
	--------------------------------
	ceval_cref_binding (env,_,Types.EQBOUND(exp,false)) => fail
	
end

relation ceval_subscript_value: (Env.Env,Exp.Subscript list ,Values.Value) 
	  => Values.Value =

  rule	ceval(env,exp,false,NONE) => (Values.INTEGER(n),_) &
	int_sub(n,1) => n' &
	list_nth(lst,n') => subval &
	ceval_subscript_value(env,subs,subval) => res 
	---------------------------------------------
	ceval_subscript_value(env,Exp.INDEX(exp)::subs,Values.ARRAY(lst)) 
	  => res
	  
  axiom	ceval_subscript_value(env,[],v) => v
			      
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)
  axiom	value_exp (Values.ARRAY([]))  => Exp.ARRAY(Exp.OTHER,false,[])

  rule	value_exp x => x' &
	value_type x => vt &
	Types.elab_type vt => t &
	Types.is_array vt => a &
  	value_exp Values.ARRAY(xs) => Exp.ARRAY(_,_,xs')
	--------------------------------------------
	value_exp (Values.ARRAY(x::xs)) => Exp.ARRAY(t,a,x'::xs')

  rule	Print.print_buf "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER([])
  axiom	value_type Values.REAL(x)    => Types.T_REAL([])
  axiom value_type Values.STRING(x)  => Types.T_STRING([])
  axiom value_type Values.BOOL(x)    => Types.T_BOOL([])

  rule	Print.print_buf "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	ceval_subscripts (env,ss) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	ceval_subscripts (env,ss) => ss' &
	canon_cref (env,c) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[]) => []

  rule	ceval_subscript (env,sub) => sub' &
	ceval_subscripts (env,subs) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs) => (sub'::subs')

end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.WHOLEDIM) => Exp.WHOLEDIM

  rule	ceval (env, e1,false,NONE) => (v1,_) &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1)) => Exp.INDEX(e1')
	
  rule	ceval (env, e1, false,NONE) => (v1,_) &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1)) => Exp.SLICE(e1')
	
end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.WHOLEDIM,Exp.WHOLEDIM)
 	
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
	
  rule	Print.print_buf "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> (Exp.Exp list,Types.Type list) =

  axiom	elab_arglist ([],[]) => ([],[])

  rule	Debug.fprint("earg","Match: ") & 
	Debug.fcall ("earg",Types.print_type, atype) & 
	Debug.fprint("earg"," == ") & 
	Debug.fcall ("earg",Types.print_type,pt) &
	Debug.fprint("earg","\n") &
	Types.match_type(arg, atype, pt) => (arg',atype') &
	Debug.fprint("earg","Types matched\n") &
	elab_arglist (pts, args) => (args',atypes')
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => (arg'::args',atype'::atypes')

(* This relation should fail sometimes. Thus it is not a good idea to print stuff here... *)
(*  rule	Debug.fprint("earg","- Static.elab_arglist failed lst1 len:") &
	list_length(lst1) => len1 &
	list_length(lst2) => len2 &
	int_string(len1) => str1 &
	int_string(len2) => str2 &
	Debug.fprintl("earg", [str1, " lst len2: ", str2, "\n"]) &
	Debug.fprint("failtrace","- Static.elab_arglist failed.") 
	--------------------------------------
	elab_arglist (lst1,lst2) => fail *)
end





(** relation: deoverlooad
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	Debug.fprint_list("dovl",params,Types.print_type,"\n") & 
	Debug.fprint("dovl","\n===\n") &
	elab_arglist (params, args) => (args',types') &
	compute_return_type(op, types', rtype) => rtype'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype')

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	Print.print_buf "# Can't resolve type of expression: " &
	Dump.print_exp exp & Print.print_buf "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

relation compute_return_type : (Exp.Operator, Types.Type list, Types.Type) => Types.Type =

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_buf "# +: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_buf "# -: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Print.print_buf "# *: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),[typ1,typ2],_) => fail

  rule	n_dims typ1 => 1 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n1 &
	dim_size(typ2,1) => n2 &
	dim_size(typ2,2) => m &
	n1 = n2 &
	element_type typ1 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(m)),etype)
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 1 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	m1 = m2 &
	element_type typ2 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(n)),etype)
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	dim_size(typ2,2) => p &
	m1 = m2 &
	element_type typ1 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(n)),
				  Types.T_ARRAY(Types.DIM(SOME(p)),etype))
	-----------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	Print.print_buf "# *: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	-----------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => fail

	
  axiom	compute_return_type (Exp.MUL_SCALAR_ARRAY(_),[typ1,typ2],rtype) => (*typ2*) rtype
  axiom	compute_return_type (Exp.MUL_ARRAY_SCALAR(_),[typ1,typ2],rtype) => (*typ1*) rtype


  axiom	compute_return_type (Exp.ADD(_),_,typ) => typ
  axiom	compute_return_type (Exp.SUB(_),_,typ) => typ
  axiom	compute_return_type (Exp.MUL(_),_,typ) => typ
  axiom	compute_return_type (Exp.DIV(_),_,typ) => typ
  axiom	compute_return_type (Exp.POW(_),_,typ) => typ
  axiom	compute_return_type (Exp.UMINUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.UPLUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.AND,_,typ) => typ
  axiom	compute_return_type (Exp.OR,_,typ) => typ
  axiom	compute_return_type (Exp.NOT,_,typ) => typ
  axiom	compute_return_type (Exp.LESS(_),_,typ) => typ
  axiom	compute_return_type (Exp.LESSEQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATER(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATEREQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.EQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.NEQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.USERDEFINED(_),_,typ) => typ
end 

relation n_dims : Types.Type => int =
	
  axiom	n_dims Types.T_INTEGER(_) => 0
  axiom	n_dims Types.T_REAL(_) => 0
  axiom	n_dims Types.T_STRING(_) => 0
  axiom	n_dims Types.T_BOOL(_) => 0

  rule	n_dims t => ns &
	int_add(ns,1) => n
	-----------------------------
	n_dims Types.T_ARRAY(_,t) => n

end

relation dim_size : (Types.Type,int) => int =

  axiom	dim_size(Types.T_ARRAY(Types.DIM(SOME(n)),_),1) => n

  rule	int_gt(d,1) => true &
	int_sub(d,1) => d' &
	dim_size(t,d') => n
	----------------------
	dim_size(Types.T_ARRAY(_,t),d) => n
end

relation element_type : Types.Type => Types.Type =
	
  axiom	element_type(t as Types.T_INTEGER(_)) => t
  axiom	element_type(t as Types.T_REAL(_)) => t
  axiom	element_type(t as Types.T_STRING(_)) => t
  axiom	element_type(t as Types.T_BOOL(_)) => t

  rule	element_type(t) => t'
	---------------------------
	element_type(Types.T_ARRAY(_,t)) => t'

end


(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode.
 **)

(** LS: POW added
 **)
relation operators : (Absyn.Operator, Env.Env, Types.Type, Types.Type)
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  rule	array_type_list(9, Types.T_INTEGER([])) => intarrtypes &
	array_type_list(9, Types.T_REAL([])) => realarrtypes &
	array_type_list(9, Types.T_STRING([])) => stringarrtypes &
	
	operator_return(Exp.ADD_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.ADD_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &

	operator_return(Exp.ADD_ARR(Exp.STRING), 
			stringarrtypes, 
			stringarrtypes, 
			stringarrtypes) => stringarrs &
	
	let scalars = [(Exp.ADD(Exp.INT),
			[Types.T_INTEGER([]), Types.T_INTEGER([])],
			Types.T_INTEGER([])),
		       (Exp.ADD(Exp.REAL),
			[Types.T_REAL([]), Types.T_REAL([])],
			Types.T_REAL([])),
		       (Exp.ADD(Exp.STRING),
			[Types.T_STRING([]), Types.T_STRING([])],
			Types.T_STRING([]))
		       ] &
	get_koening_operator_types("plus",env,t1,t2) => userops &
	Util.list_flatten([intarrs,realarrs,stringarrs]) => arrays &
	Util.list_flatten([scalars,arrays,userops]) => types 
	------------------------
	operators (Absyn.ADD,env,t1,t2) => types


  rule	array_type_list(9, Types.T_INTEGER([])) => intarrtypes &
	array_type_list(9, Types.T_REAL([])) => realarrtypes &
	
	operator_return(Exp.SUB_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.SUB_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.SUB(Exp.INT),
			[Types.T_INTEGER([]), Types.T_INTEGER([])],
			Types.T_INTEGER([])),
		       (Exp.SUB(Exp.REAL),
			[Types.T_REAL([]), Types.T_REAL([])],
			Types.T_REAL([]))		  
		       ] &
	get_koening_operator_types("minus",env,t1,t2) => userops &
	Util.list_flatten([scalars,intarrs,realarrs,userops]) => types
	---------------------------
	operators(Absyn.SUB,env,t1,t2) => types

  rule	array_type_list(9, Types.T_INTEGER([])) => intarrtypes &
	array_type_list(9, Types.T_REAL([])) => realarrtypes &
	n_types(9, Types.T_INTEGER([])) => inttypes &
	n_types(9, Types.T_REAL([])) => realtypes &
	
	let int_mul = Exp.MUL(Exp.INT) &
	let real_mul = Exp.MUL(Exp.REAL) &
	let int_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.INT) &
	let real_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.REAL) &
	let int_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.INT) &
	let real_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.REAL) &
	
	let int_scalar = Types.T_INTEGER([]) &
	let int_vector = Types.T_ARRAY(Types.DIM(NONE),int_scalar) &
	let int_matrix = Types.T_ARRAY(Types.DIM(NONE), int_vector) &
	let real_scalar = Types.T_REAL([]) &
	let real_vector = Types.T_ARRAY(Types.DIM(NONE),real_scalar) &
	let real_matrix = Types.T_ARRAY(Types.DIM(NONE), real_vector) &


	let scalars = [
		       (int_mul,[int_scalar, int_scalar], int_scalar),
		       (real_mul,[real_scalar, real_scalar], real_scalar)
		       ] &


	
	let scalarprod = [
			  (int_mul_sp,[int_vector, int_vector],int_scalar),
			  (real_mul_sp,[real_vector,real_vector],real_scalar)
			  ] &
			
	let matrixprod = [
			  (int_mul_mp, [int_vector, int_matrix], int_vector),
			  (int_mul_mp, [int_matrix, int_vector], int_vector),
			  (int_mul_mp, [int_matrix, int_matrix], int_matrix),
			  (real_mul_mp,[real_vector,real_matrix],real_vector),
			  (real_mul_mp,[real_matrix,real_vector],real_vector),
			  (real_mul_mp,[real_matrix, real_matrix],real_matrix)
			  ] &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.INT), 
			inttypes, 
			intarrtypes, 
			intarrtypes) => intscalararrs &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.REAL), 
			realtypes, 
			realarrtypes, 
			realarrtypes) => realscalararrs &
	
	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.INT), 
			intarrtypes, 
			inttypes, 
			intarrtypes) => intarrsscalar &

	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.REAL), 
			realarrtypes, 
			realtypes, 
			realarrtypes) => realarrsscalar &	

	get_koening_operator_types("times",env,t1,t2) => userops &
	
	Util.list_flatten([scalars, intscalararrs, realscalararrs, intarrsscalar,
			   realarrsscalar,scalarprod,matrixprod,userops]) => types
	--------------------------------------------------------------------------
	operators(Absyn.MUL,env,t1,t2) => types

  rule	array_type_list(9, Types.T_REAL([])) => realarrtypes &
	n_types(9, Types.T_REAL([])) => realtypes &
	let real_div = Exp.DIV(Exp.REAL) &
	let real_scalar = Types.T_REAL([]) &
	let scalars = [(real_div,[real_scalar, real_scalar], real_scalar)] &

	operator_return(Exp.DIV_ARRAY_SCALAR(Exp.REAL),
			realarrtypes,
			realtypes,
			realarrtypes) => realarrscalar &
	get_koening_operator_types("divide",env,t1,t2) => userops &
	Util.list_flatten([scalars,realarrscalar,userops]) => types
	-----------------------------------------------------------
	operators(Absyn.DIV,env,t1,t2) => types

  rule	let real_scalar = Types.T_REAL([]) &
	let int_scalar = Types.T_INTEGER([]) &
	let real_vector = Types.T_ARRAY(Types.DIM(NONE),real_scalar) &
	let real_matrix = Types.T_ARRAY(Types.DIM(NONE), real_vector) &
	let real_pow = Exp.POW(Exp.REAL) &

	let scalars = [(real_pow,[real_scalar, real_scalar], real_scalar)] &

	let arrscalar = [(Exp.POW_ARR(Exp.REAL),
			  [real_matrix,int_scalar],
			  real_matrix)] &
	get_koening_operator_types("power",env,t1,t2) => userops &
	Util.list_flatten([scalars,arrscalar,userops]) => types
	-------------------------------------------------------
	operators(Absyn.POW,env,t1,t2) => types

  rule	let scalars = [(Exp.UMINUS(Exp.INT),
	       [Types.T_INTEGER([])],
	       Types.T_INTEGER([])),
	      (Exp.UMINUS(Exp.REAL),
	       [Types.T_REAL([])],
	       Types.T_REAL([]))] &
	get_koening_operator_types("unaryMinus",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators (Absyn.UMINUS,env,t1,t2) => types

  rule	let scalars = [(Exp.UPLUS(Exp.INT),
	       [Types.T_INTEGER([])],
	       Types.T_INTEGER([])),
	      (Exp.UPLUS(Exp.REAL),
	       [Types.T_REAL([])],
	       Types.T_REAL([]))] &
	get_koening_operator_types("unaryPlus",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.UPLUS,env,t1,t2) => types

	(**  Logical operators *) (* Not considered for overloading yet. *)

  axiom	operators(Absyn.AND,env,t1,t2)
	  => [(Exp.AND,
	       [Types.T_BOOL([]), Types.T_BOOL([])],
	       Types.T_BOOL([]))]

  axiom	operators(Absyn.OR,env,t1,t2)
	  => [(Exp.OR,
	       [Types.T_BOOL([]), Types.T_BOOL([])],
	       Types.T_BOOL([]))]

  axiom	operators(Absyn.NOT,env,t1,t2)
	  => [(Exp.NOT,
	       [Types.T_BOOL([])],
	       Types.T_BOOL([]))]

	(**  Relational operators *)

  rule let scalars = [(Exp.LESS(Exp.INT),
	       [Types.T_INTEGER([]), Types.T_INTEGER([])],
	       Types.T_BOOL([])),
	      (Exp.LESS(Exp.REAL),
	       [Types.T_REAL([]), Types.T_REAL([])],
	       Types.T_BOOL([]))] &
	get_koening_operator_types("less",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.LESS,env,t1,t2) => types

  rule	let scalars = [(Exp.LESSEQ(Exp.INT),
	       [Types.T_INTEGER([]), Types.T_INTEGER([])],
	       Types.T_BOOL([])),
	      (Exp.LESSEQ(Exp.REAL),
	       [Types.T_REAL([]), Types.T_REAL([])],
	       Types.T_BOOL([]))] &
	get_koening_operator_types("lessEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.LESSEQ,env,t1,t2) => types

  rule	let scalars = [(Exp.GREATER(Exp.INT),
	       [Types.T_INTEGER([]), Types.T_INTEGER([])],
	       Types.T_BOOL([])),
	      (Exp.GREATER(Exp.REAL),
	       [Types.T_REAL([]), Types.T_REAL([])],
	       Types.T_BOOL([]))] &
	get_koening_operator_types("greater",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.GREATER,env,t1,t2) => types

  rule	let scalars = [(Exp.GREATEREQ(Exp.INT),
	       [Types.T_INTEGER([]), Types.T_INTEGER([])],
	       Types.T_BOOL([])),
	      (Exp.GREATEREQ(Exp.REAL),
	       [Types.T_REAL([]), Types.T_REAL([])],
	       Types.T_BOOL([]))] &
	get_koening_operator_types("greaterEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.GREATEREQ,env,t1,t2) => types

  rule	let scalars = [(Exp.EQUAL(Exp.INT),
	       [Types.T_INTEGER([]), Types.T_INTEGER([])],
	       Types.T_BOOL([])),
	      (Exp.EQUAL(Exp.REAL),
	       [Types.T_REAL([]), Types.T_REAL([])],
	       Types.T_BOOL([])),
	      (Exp.EQUAL(Exp.STRING),
	       [Types.T_STRING([]), Types.T_STRING([])],
	       Types.T_BOOL([])),
	      (Exp.EQUAL(Exp.BOOL),
	       [Types.T_BOOL([]), Types.T_BOOL([])],
	       Types.T_BOOL([]))] &
	get_koening_operator_types("equal",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.EQUAL,env,t1,t2) => types

  rule	let scalars = [(Exp.NEQUAL(Exp.INT),
	       [Types.T_INTEGER([]), Types.T_INTEGER([])],
	       Types.T_BOOL([])),
	      (Exp.NEQUAL(Exp.REAL),
	       [Types.T_REAL([]), Types.T_REAL([])],
	       Types.T_BOOL([])),
	      (Exp.NEQUAL(Exp.STRING),
	       [Types.T_STRING([]), Types.T_STRING([])],
	       Types.T_BOOL([])),
	      (Exp.NEQUAL(Exp.BOOL),
	       [Types.T_BOOL([]), Types.T_BOOL([])],
	       Types.T_BOOL([]))] &
	get_koening_operator_types("notEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.NEQUAL,env,t1,t2) => types


  rule	Print.print_buf "- operators(" & Dump.op_symbol op => s &
 	Print.print_buf s & Print.print_buf ") failed\n"
	----------------------------
	operators(op,env,t1,t2) => fail

end

(** relation: get_koening_function_types
 ** Used for userdefined function overloads.
 ** This relation will search the types of the arguments for matching function definitions 
 ** corresponding to the koening C++ lookup rule.
 ** Question: What happens if we have A.foo(x,y)? Should we search for function A.foo in
 ** scope where type of x and y are defined? Or is it an error?
 ** See also: get_koening_operator_types
 ** Note: The reason for having two relations here is that operators and functions differs a lot.
 ** Operators have fixed no of arguments, functions can both have positional and named 
 ** arguments, etc. Perhaps these two could be unified. This would require major refactoring.
 **)
relation get_koening_function_types: (Env.Env, Absyn.Path, Absyn.Exp list, Absyn.NamedArg list)
	=> Types.Type list =

  rule	elab_exp(env,e1,false,NONE) => (_,Types.PROP(t,_),_) &
	Types.get_classname(t) => p1 &
	Lookup.lookup_class(env,p1,false) => (c,f::_) &

	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],fn) => (_,f'::_) &

	Lookup.lookup_functions_in_env([f'],fn) => typelist &
	get_koening_function_types(env,fn,exps,na) => typelist2 &
	list_append(typelist,typelist2) => res
	--------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),e1::exps,na) => res 

  rule	get_koening_function_types(env,fn,exps,na) => typelist
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),e1::exps,na) => typelist
	
  rule	elab_exp(env,exp,false,NONE) => (_,Types.PROP(t,_),_) &
	Types.get_classname(t) => p1 &
	Lookup.lookup_class(env,p1,false) => (c,f::_) &
	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],fn) => (_,f'::_) &

	Lookup.lookup_functions_in_env([f'],fn) => typelist &
	get_koening_function_types(env,fn,[],na) => typelist2 &
	list_append(typelist,typelist2) => res
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),[],Absyn.NAMEDARG(id,exp)::na) 
	  => res

  rule	get_koening_function_types(env,fn,[],na) => res
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),[],_::na) => res

  axiom	get_koening_function_types(env,fn as Absyn.IDENT(_),[],[]) => []
	
  rule	Print.print_buf "# Error, koening lookup of non-simple function name, " &
	Absyn.path_string fn => fnstr & Print.print_buf fnstr & 
	Print.print_buf "\n"
	-------------------
	get_koening_function_types(env,fn as Absyn.QUALIFIED(_,_),_,_) => fail

  rule	Debug.fprint("failtrace", "- get_koening_function_types failed\n") 
	------------------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.QUALIFIED(_,_),_,_) => fail
	
end
(** relation: get_koening_operator_types
 ** Used for userdefined operator overloads.
 ** This relation will search the scopes of the classes of the two 
 ** corresponding types and look for user defined operator overloaded
 ** functions, such as 'plus', 'minus' and 'times'. This corresponds
 ** to the koening C++ lookup rule.
 **)
relation get_koening_operator_types: (string, Env.Env, Types.Type, Types.Type)
	=> (Exp.Operator * Types.Type list * Types.Type) list =

  rule	(* Both types user defined *)
	Types.get_classname(t1) => p1 &
	Lookup.lookup_class(env,p1,false) => (c,env1) &
	get_koening_operator_types_in_scope(op,env1) => res1 &
	Types.get_classname(t2) => p2 &
	Lookup.lookup_class(env,p2,false) => (c,env2) &
	get_koening_operator_types_in_scope(op,env2) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* User defined types only in t2*)
	not Types.get_classname(t1) => _ &
	Types.get_classname(t2) => p2 &
	Lookup.lookup_class(env,p2,false) => (c,env2) &
	get_koening_operator_types_in_scope(op,env2) => res
	---------------------------------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* User defined types only in t1*)
	not Types.get_classname(t2) => _ &
	Types.get_classname(t1) => p1 &
	Lookup.lookup_class(env,p1,false) => (c,env1) &
	get_koening_operator_types_in_scope(op,env1) => res
	---------------------------------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* No User defined types at all. *)
	not Types.get_classname(t1) => _ &
	not Types.get_classname(t2) => _ 
	--------------------------------
	get_koening_operator_types(op,env,t1,t2) => []
end

(** relation: get_koening_operator_types_in_scope
 ** This relation is a help relation to get_koening_operator_types
 ** and it will look for functions in the current scope of the passed
 ** environment, according to the koening rule. 
**)
relation get_koening_operator_types_in_scope: (string, Env.Env) 
	  => (Exp.Operator * Types.Type list * Types.Type) list =

  rule	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],Absyn.IDENT(funcname)) => (_,f'::_) &

	(* TODO: Fix so lookup_functions_in_env also does instantiation to get type *)
	Lookup.lookup_functions_in_env([f'],Absyn.IDENT(funcname)) => tplst &
	list_length(tplst) => tplen &
	Inst.package_prefix(f'::fs,Absyn.IDENT(funcname)) => fullfuncname &
	build_operator_types(tplst,fullfuncname) => res
	--------------------------------------------------
	get_koening_operator_types_in_scope(funcname,f::fs) => res
end

(** relation: build_operator_types
 ** This relation takes the types operator overloaded user functions and
 ** builds  the type list structure suitable for the deoverload relation. 
**)
relation build_operator_types: (Types.Type list,Absyn.Path) 
	  => (Exp.Operator * Types.Type list * Types.Type) list =

  axiom	build_operator_types([],_) => []

  rule	Util.list_map(args,Util.tuple2_2) => argtypes &
	build_operator_types(tps,funcname) => rest
	------------------------------------
	build_operator_types(Types.T_FUNCTION(args,tp,fpath)::tps,funcname) 
	  => ((Exp.USERDEFINED(funcname),argtypes,tp)::rest) 
end

relation n_dim_array : (int, Types.Type) => Types.Type =

  axiom	n_dim_array (0, t) => t

  rule	int_sub(n,1) => n' &
	n_dim_array (n',t) => t'
	------------------------
	n_dim_array (n, t) => Types.T_ARRAY(Types.DIM(NONE),t')

end
relation n_types : (int, Types.Type) => Types.Type list =

  axiom	n_types (0,_) => []

  rule	int_sub(n,1) => n' &
	n_types(n',t) => l
	-----------------------
	n_types (n, t) => t::l

end

relation operator_return : (Exp.Operator, 
			    Types.Type list, 
			    Types.Type list, 
			    Types.Type list) 
	  =>  (Exp.Operator * Types.Type list * Types.Type) list =

  axiom operator_return (_,[],[],[]) => []

  rule	operator_return (op, lr, rr, rer) => rest &
	let t = (op,[l,r],re)
	---------------------------------------
	operator_return (op, l::lr, r::rr, re::rer) => t::rest

end

relation array_type_list : (int, Types.Type) => Types.Type list =
  
  axiom array_type_list (0,_) => []

  rule	int_sub(n,1) => n' &
	n_dim_array(n,t) => f &
	array_type_list (n', t) => r
	-----------------------------
	array_type_list (n, t) => f::r


end
