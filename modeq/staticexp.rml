(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 static.rml
 ** module:      Static
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module does static analysis and constant evaluation of
 ** expressions.  The analyzed expressions are built using the
 ** constructors in the `Exp' module.  Also, a set of properties of
 ** the expressions is calculated during analysis.
 **)

module Static :

  with "absyn.rml"
  with "exp.rml"
  with "explode.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "lookup.rml"
  with "debug.rml"

  type Ident = string

  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(* Used by split_props  *)
  datatype Const = CONST of bool |
		   TUPLE_CONST  of Const list 

  datatype Properties = PROP of Types.Type * (* type *)
				 bool (* if the type is a tuple, each element 
				          have a const flag. *)

(* Types.Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Types.Type * Const (* The elements might be 
							    tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)



  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)

  datatype Slot = SLOT of Types.FuncArg *  (* An argument to a function *)
			bool *		   (* True if the slot has been filled, 
					      i.e. argument has been given a value*)
			Exp.Exp option		   (* Contain the elaborated expression for the actual argument *)							  

  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties)
  relation elab_graphics_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties) (* Special relation for graphics annotations, because of inhomogenous array of graphics primitives *)
  relation elab_exp_list : (Env.Env, Absyn.Exp list) => (Exp.Exp list, Properties list)
  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Properties, SCode.Accessibility)
  relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	  => (Exp.Exp list, Properties list, SCode.Accessibility list)
  relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool)

  (* Constant propagation *)
  relation ceval : (Env.Env, Exp.Exp, bool)	  => Values.Value
  relation ceval_list : (Env.Env, Exp.Exp list)	  => Values.Value list
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef

  (* Property matching (type conversions etc.) *)
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list

  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp
  relation get_prop_type : Properties => Types.Type
  relation is_prop_const : Properties => bool
  relation is_prop_array : Properties => bool

  relation elab_type : Types.Type => Exp.Type

end

with "dump.rml"
with "print.rml"
with "system.rml"

(** LS:
 ** - Expression elaboration
 **)

relation elab_exp_list : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp list, Properties list) =

  axiom	elab_exp_list (_,[]) => ([],[])

  rule	elab_exp (env, e) => (exp,p) & 
	elab_exp_list (env, rest) => (exps, props)
	-----------------------------------------
	elab_exp_list (env, e::rest) => (exp::exps, p::props) 
end

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties) =

  axiom	elab_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), PROP(Types.T_INTEGER,true))
  axiom	elab_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), PROP(Types.T_REAL,   true))
  axiom	elab_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), PROP(Types.T_STRING, true))
  axiom	elab_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), PROP(Types.T_BOOL,   true))

  rule	Debug.fprintln("setr", "elab_exp_cref") &
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr)) => (exp,prop) 

	(**  Binary and unary operations *)

  rule	Debug.fprintln("setr", "elab_exp_binary") &
	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_exp_unary") &
	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),PROP(rtype,c))
	
  rule	Debug.fprintln("setr", "elab_exp_lbinary") &
	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_exp_lunary") &
	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_exp_relation") &
	
	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),PROP(rtype,c))

	(**  Conditional expressions *)

  rule	Debug.fprintln("setr", "elab_exp_ifexp") &
	elab_exp (env,e1) => (e1', prop1) &
	elab_exp (env,e2) => (e2', prop2) &
	elab_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3)) => (e,prop)

	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)

  rule	Dump.print_component_ref_str fn => fnstr &
	Debug.fprintl("setr", ["elab_exp_call: ",fnstr,"\n"]) &
	elab_call(env,fn,args,nargs) => (e,prop) 
	--------------------------------------
	elab_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs))) 
		=> (e,prop)

	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	Debug.fprintln("setr", "elab_exp_tuple") &
	Debug.print "\n#####################elab_exp tuple.####################" &
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
	Debug.print "\nThe elaborated tuple." &
	split_props(props) => (types, consts) &
	Debug.print "\n split_props was just executed."
	-------------------------------------
	elab_exp (env,Absyn.TUPLE(e as e1::rest)) 
	  => (Exp.TUPLE(e'),PROP_TUPLE(Types.T_TUPLE(types), TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	Debug.fprintln("setr", "elab_exp_range1") &
	elab_exp (env, start) => (start', PROP(start_t, c_start)) &
	elab_exp (env, stop) => (stop', PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(rt,start',NONE,stop'), PROP(t, const))

  rule	Debug.fprintln("setr", "elab_exp_range2") &
	elab_exp (env, start) => (start', PROP(start_t, c_start)) &
	elab_exp (env, step) => (step', PROP(step_t, c_step)) &
	elab_exp (env, stop) => (stop', PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), PROP(t, const))

  rule	Debug.fprintln("setr", "elab_exp_array") &
	elab_array (env, es) => (es', PROP(t, const)) & list_length es' => l&
	elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(at,a,es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l)), t),
		   const))
	
  rule	Debug.fprintln("setr", "elab_exp_matrix") &
	elab_matrix_semi (env, es) => (es', PROP(t,c), dim1,dim2,nmax) & 
	elab_type t => at
	------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(at,nmax,es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 Types.T_ARRAY(Types.DIM(SOME(dim2)), t)),
		   c))

  rule	Print.print_buf "- elab_exp failed: " & Dump.print_exp e & Print.print_buf "\n"
	-----------------------------------------------------------
	elab_exp(_,e) => fail

end

relation elab_graphics_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties) =

  axiom	elab_graphics_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), PROP(Types.T_INTEGER,true))
  axiom	elab_graphics_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), PROP(Types.T_REAL,   true))
  axiom	elab_graphics_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), PROP(Types.T_STRING, true))
  axiom	elab_graphics_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), PROP(Types.T_BOOL,   true))

  rule	Debug.fprintln("setr", "elab_graphics_exp_cref") &
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_graphics_exp(env, Absyn.CREF(cr)) => (exp,prop) 

	(**  Binary and unary operations *)

  rule	Debug.fprintln("setr", "elab_graphics_exp_binary") &
	elab_graphics_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_graphics_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_graphics_exp_unary") &
	elab_graphics_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),PROP(rtype,c))
	
  rule	Debug.fprintln("setr", "elab_graphics_exp_lbinary") &
	elab_graphics_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_graphics_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_graphics_exp_lunary") &
	elab_graphics_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_graphics_exp_relation") &
	
	elab_graphics_exp (env,e1) => (e1', PROP(t1, c1)) &
	
	elab_graphics_exp (env,e2) => (e2', PROP(t2, c2)) &
	
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_graphics_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),PROP(rtype,c))

	(**  Conditional expressions *)

  rule	Debug.fprintln("setr", "elab_graphics_exp_ifexp") &
	elab_graphics_exp (env,e1) => (e1', prop1) &
	elab_graphics_exp (env,e2) => (e2', prop2) &
	elab_graphics_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	------------------------------------------------------
	elab_graphics_exp (env,Absyn.IFEXP(e1,e2,e3)) => (e,prop)

	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)

  rule	Dump.print_component_ref_str fn => fnstr &
	Debug.fprintl("setr", ["elab_graphics_exp_call: ",fnstr,"\n"]) &
	elab_call(env,fn,args,nargs) => (e,prop) 
	--------------------------------------
	elab_graphics_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs))) 
		=> (e,prop)

	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	Debug.fprintln("setr", "elab_graphics_exp_tuple") &
	Debug.print "\n#####################elab_graphics_exp tuple.####################" &
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
	Debug.print "\nThe elaborated tuple." &
	split_props(props) => (types, consts) &
	Debug.print "\n split_props was just executed."
	-------------------------------------
	elab_graphics_exp (env,Absyn.TUPLE(e as e1::rest)) 
	  => (Exp.TUPLE(e'),PROP_TUPLE(Types.T_TUPLE(types), TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	Debug.fprintln("setr", "elab_graphics_exp_range1") &
	elab_graphics_exp (env, start) => (start', PROP(start_t, c_start)) &
	elab_graphics_exp (env, stop) => (stop', PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt) => t
	--------------------------------------------------
	elab_graphics_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(rt,start',NONE,stop'), PROP(t, const))

  rule	Debug.fprintln("setr", "elab_graphics_exp_range2") &
	elab_graphics_exp (env, start) => (start', PROP(start_t, c_start)) &
	elab_graphics_exp (env, step) => (step', PROP(step_t, c_step)) &
	elab_graphics_exp (env, stop) => (stop', PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt) => t
	---------------------
	elab_graphics_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), PROP(t, const))

  rule	Debug.fprintln("setr", "elab_graphics_exp_array") &
	elab_graphics_array (env, es) => (es', PROP(t, const)) & list_length es' => l&
	elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_graphics_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(at,a,es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l)), t),
		   const))
	
  rule	Debug.fprintln("setr", "elab_graphics_exp_matrix") &
	elab_matrix_semi (env, es) => (es', PROP(t,c), dim1,dim2,nmax) & 
	elab_type t => at
	------------------------------------------------------------
	elab_graphics_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(at,nmax,es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 Types.T_ARRAY(Types.DIM(SOME(dim2)), t)),
		   c))

  rule	Print.print_buf "- elab_graphics_exp failed: " & Dump.print_exp e & Print.print_buf "\n"
	-----------------------------------------------------------
	elab_graphics_exp(_,e) => fail

end

relation deoverload_range : ((Exp.Exp*Types.Type), 
			     (Exp.Exp*Types.Type) option,
			     (Exp.Exp*Types.Type)) 
	  => (Exp.Exp, Exp.Exp option, Exp.Exp, Exp.Type) =
	  
  axiom	deoverload_range((e1,Types.T_INTEGER),
			 NONE,
			 (e3,Types.T_INTEGER)) => (e1,NONE,e3,Exp.INT)
  axiom	deoverload_range((e1,Types.T_INTEGER),
			 SOME((e2,Types.T_INTEGER)),
			 (e3,Types.T_INTEGER))  => (e1,SOME(e2),e3,Exp.INT)

  rule	elab_arglist([Types.T_REAL,Types.T_REAL],
		     [(e1,t1),(e3,t3)]) => ([e1',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),NONE,(e3,t3)) => (e1',NONE,e3',Exp.REAL)

  rule	elab_arglist([Types.T_REAL,Types.T_REAL,Types.T_REAL],
		     [(e1,t1),(e2,t2),(e3,t3)]) => ([e1',e2',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),SOME((e2,t2)),(e3,t3)) 
	  => (e1',SOME(e2'),e3',Exp.REAL)

end
(** relation: elab_range_type *)

relation elab_range_type : (Env.Env, Exp.Exp,
			    Exp.Exp option, Exp.Exp, bool,Exp.Type) => Types.Type =

  rule	ceval (env,start,false) => Values.INTEGER(startv) &
	ceval (env,stop,false) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n')), Types.T_INTEGER)

  rule	ceval (env,start,false) => Values.INTEGER(startv) &
	ceval (env,step,false) => Values.INTEGER(stepv) &
	ceval (env,stop,false) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n'')), Types.T_INTEGER)

  rule	ceval (env,start,false) => Values.REAL(startv) &
	ceval (env,stop,false) => Values.REAL(stopv) &
	real_sub (stopv,startv) => n &
	real_floor n => n'' &
	real_int n'' => n''' &
	int_add (n''',1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n')), Types.T_REAL)

  rule	ceval (env,start,false) => Values.REAL(startv) &
	ceval (env,step,false) => Values.REAL(stepv) &
	ceval (env,stop,false) => Values.REAL(stopv) &
	real_sub (stopv,startv) => n &
	real_div (n,stepv) => n' &
	real_floor n' => n''' &
	real_int n''' => n'''' &
 	int_add (n'''',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true,_)
	  => Types.T_ARRAY(Types.DIM(SOME(n'')), Types.T_REAL)

  axiom	elab_range_type (_,_,_,_,false,Exp.INT)
	  => Types.T_ARRAY(Types.DIM(NONE), Types.T_INTEGER)

  axiom	elab_range_type (_,_,_,_,false,Exp.REAL)
	  => Types.T_ARRAY(Types.DIM(NONE), Types.T_REAL)

end

relation elab_tuple : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties list) =

  rule	Debug.print "\nEntered elab_tuple." &
	elab_exp (env,e) => (e',p) &
	Debug.print "\nElaborated expression." &
	elab_tuple(env,exps) => (exps',props) &
	Debug.print "\nThe last element was just elaborated."
	-----------------------------
	elab_tuple(env,e::exps) => (e'::exps', p::props) 

(*PR.  rule	elab_exp (env,e) => (e',p) 
	-----------------------------
	elab_tuple(env,e::[]) => (e', p) 
*)
  rule 	Debug.print "elaborating last element."
	----------------
	elab_tuple(env,[]) => ([], []) 

(*  axiom elab_tuple(env,[]) => ([], []) 
*)
end


(** relation: elab_array *)

relation elab_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties) =

  rule	elab_exp (env,e) => (e',prop)
	-----------------------------
	elab_array (env,[e]) => ([e'],prop)

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es) => (e'::es',PROP(t1,c))

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in array expression\n" &
	Print.print_buf "  " & Dump.print_exp e & Print.print_buf " is of type " &
 	Types.print_type t1 & Print.print_buf "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	Print.print_buf "] are of type " & Types.print_type t2 & Print.print_buf "\n"
	---------------------------------------------------------
	elab_array (env,e::es) => fail

  rule	Print.print_buf "- elab_array failed\n"
	-----------------------------
	elab_array (_,_) => fail

end

relation elab_graphics_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties) =

  rule	elab_exp (env,e) => (e',prop)
	-----------------------------
	elab_graphics_array (env,[e]) => ([e'],prop)

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_graphics_array (env,es) => (es',PROP(t2,c2)) &
	bool_and (c1,c2) => c
	---------------------------------
	elab_graphics_array (env,e::es) => (e'::es',PROP(t1,c))

  rule	Print.print_buf "- elab_graphics_array failed\n"
	-----------------------------
	elab_graphics_array (_,_) => fail

end

relation match_with_promote : (Properties, Properties) => Properties =

  rule	match_with_promote(PROP(t1,c1),PROP(t2,c2)) => PROP(t,c) &
	let dim = dim1
	-----
	match_with_promote(PROP(Types.T_ARRAY(dim1,t1),c1),
			   PROP(Types.T_ARRAY(dim2,t2),c2)) 
	  => PROP(Types.T_ARRAY(dim,t),c)

  rule	Types.is_array t1 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2)) => PROP(t,c)
	---------------------------
	match_with_promote(PROP(t1,c1),
			   PROP(Types.T_ARRAY(Types.DIM(SOME(1)),t2),c2)) 
	  => PROP(Types.T_ARRAY(Types.DIM(SOME(1)),t),c)

  rule	Types.is_array t2 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2)) => PROP(t,c)
	-----
	match_with_promote(PROP(Types.T_ARRAY(Types.DIM(SOME(1)),t1),c1),
			   PROP(t2,c2)) 
	  => PROP(Types.T_ARRAY(Types.DIM(SOME(1)),t),c)


  rule	Types.is_array t1 => false &
	Types.is_array t2 => false &
	t1 = t2 &
	let t = t1 &
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP(t1,c1),PROP(t2,c2)) => PROP(t,c)

end

relation elab_matrix_comma : (Env.Env, Absyn.Exp list)
	=> ((Exp.Exp*bool) list, Properties, int, int) =


  rule	elab_exp (env,el) => (el', PROP(t,c)) &
	Types.ndims t => ndims &
	int_max(2,ndims) => maxn &
	int_gt(ndims,0) => array
	----------------------------------------
	elab_matrix_comma (env,[el]) => ([(el',array)],PROP(t,c),1,maxn)


  rule	elab_exp (env,el) => (el', PROP(t1,c1)) &
	elab_matrix_comma(env,els) => (els', PROP(t2,c2), _,maxn2) &

	match_with_promote(PROP(t1,c1),PROP(t2,c2)) => props &

	list_length el::els => dim &

	Types.ndims t1 => maxn1 &
	int_max (maxn1,maxn2) => maxn &
	int_gt(maxn1,0) => array
	-------------------------------------
	elab_matrix_comma (env,el::els) 
	  => ((el',array)::els',props,dim,maxn)

end

(** relation: elab_matrix_semi *)

relation elab_matrix_semi : (Env.Env, Absyn.Exp list list)
	=> ((Exp.Exp*bool) list list, Properties, int, int, int) =

  rule	elab_matrix_comma(env,el) => (el', props, dim, maxn)
	---------------------------------
	elab_matrix_semi(env,[el]) => ([el'], props, 1, dim, maxn)

  rule	list_length(el) => dim &
	elab_matrix_comma(env,el) => (el',props1,dim1,maxn1) &
	elab_matrix_semi(env,els) => (els',props2,_,dim2,maxn2) &

	dim1 = dim2 &
			
	match_with_promote(props1,props2) => props &

	int_max(maxn1,maxn2) => maxn
	--------------------
	elab_matrix_semi(env,el::els) => (el'::els',props,dim,dim1,maxn)






	(**  Error messages *)
(*
  rule	Print.print_buf "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix_semi(_,[]) => fail

  rule	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in matrix rows\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix is of " &
	Types.print_type t2 & Print.print_buf "\n"
	--------------------------------
	elab_matrix_semi(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	Print.print_buf "# Incompatible row length in matrix expression\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of size " &
	int_string dim1 => s & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix rows are of size " &
	int_string dim2 => s & Print.print_buf s & Print.print_buf "\n"
	--------------------------------------------
	elab_matrix_semi(env,el::els) => fail
*)
end


relation elab_builtin_size : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties) =

	(** LS: size(A) that returns an array of sizes for all dimensions is not *)
	(** implemented, just size(A,x) that returns size of x:th dimension *)

  rule	elab_exp (env,ind) => (indexp, PROP(indty, true)) &
	ceval (env, indexp,false) => Values.INTEGER(value) &
	int_string(value) => strval &
	elab_exp (env,arraycr) => (Exp.CREF(cr,crt), crprop) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	elab_builtin_size_2 (env, ty, value) => (exp, prop) 
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) => (exp, prop)

  rule	elab_exp (env,arraycr) => (crefe as Exp.CREF(cr,crt), crprop) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	Types.array_element_type ty => Types.T_INTEGER &
	elab_exp (env,ind) => (indexp, PROP(indty, ind_const)) &
	let exp = Exp.CALL(Absyn.IDENT("size_integer_array"),
			   [crefe,indexp],false,true) &
	let prop = PROP(Types.T_INTEGER,false)
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) 
	  => (exp, 
	      prop)

 rule	elab_exp (env,arraycr) => (crefe as Exp.CREF(cr,crt), crprop) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	Types.array_element_type ty => Types.T_REAL &
	elab_exp (env,ind) => (indexp, PROP(indty, ind_const)) &
	let exp = Exp.CALL(Absyn.IDENT("size_of_dimension_real_array"),
			   [crefe,indexp],false,true) &
	let prop = PROP(Types.T_INTEGER,false)
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) 
	  => (exp, prop)

  rule	Print.print_buf "#-- elab_builtin_size: Couldn't elaborate size()\n" &
	Print.print_buf "#-- Wrong args or non-constant dimension\n" &
	Print.print_buf "#env: " &
	Env.print_env env &
	Print.print_buf "\n" &
	Print.print_buf "expl = " &
	Debug.fprint_list ("peter6",expl,Dump.print_exp,", ") &
	Print.print_buf "\n" 
	----------------------------------------------------------
	elab_builtin_size (env,expl) => fail

end

relation elab_builtin_size_2 : (Env.Env, Types.Type, int) => (Exp.Exp, Properties) =

  rule	Print.print_buf "# Error non-constant dimension\n"
	---------------------------------------
	elab_builtin_size_2(env, Types.T_ARRAY(Types.DIM(NONE),ty), 1) => fail

 axiom	elab_builtin_size_2 (env, Types.T_ARRAY(Types.DIM(SOME(dim)),ty), 1) 
	  => (Exp.ICONST(dim), PROP(Types.T_INTEGER, true))

  rule	int_sub (ind, 1) => ind' &
	elab_builtin_size_2 (env, ty, ind') => (exp, prop)
	--------------------------------------------------
	elab_builtin_size_2 (env, Types.T_ARRAY(_, ty), ind) => (exp, prop)

  rule	Print.print_buf "# elab_builtin_size_2 failed\n type:" &
	Types.print_type tp &
	Print.print_buf " ind:" &
	int_string ind => indstr & Print.print_buf indstr &
	Print.print_buf "\n"
	--------------------------------------
	elab_builtin_size_2(_,tp,ind) => fail
end


relation elab_builtin_fill : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties)	=

  rule	elab_exp (env,s) => (s', PROP(sty, sconst)) &
	elab_exp_list (env,dims) => (dims', dimprops) &
	ceval_list (env, dims') => dimvals &
	elab_builtin_fill_2 (env, s', sty, dimvals) => (exp, prop) 
	--------------------------------------------------
	elab_builtin_fill (env, s::dims) => (exp, prop)

  rule	print"#-- elab_builtin_fill: Couldn't elaborate fill()\n"
	---------------------------------------------------------
	elab_builtin_fill (_,_) => fail

end


relation elab_builtin_fill_2 : (Env.Env, Exp.Exp, Types.Type, Values.Value list) 
	  => (Exp.Exp, Properties) =

  rule	build_exp_list (s, v) => arraylist &
	elab_type sty => at &
	Types.is_array sty => a
	----------------------------------
	elab_builtin_fill_2 (env, s, sty, [Values.INTEGER(v)])
	  => (Exp.ARRAY(at,a,arraylist), PROP(Types.T_ARRAY(Types.DIM(SOME(v)), sty), true))
			     
  rule	elab_builtin_fill_2 (env, s, sty, rest) 
	  => (exp, PROP(ty,con)) &
        build_exp_list (exp, v) => arraylist &
	elab_type ty => at &
	Types.is_array ty => a
	----------------------------------------------------------
	elab_builtin_fill_2 (env, s, sty, Values.INTEGER(v)::rest) 
	  => (Exp.ARRAY(at,a,arraylist), PROP(Types.T_ARRAY(Types.DIM(SOME(v)), ty), true))
	
  rule	Print.print_buf "#-- elab_builtin_fill_2: Failed to elaborate fill()\n"
	-------------------------------------------------------------
	elab_builtin_fill_2 (_,_,_,_) => fail

end

relation build_exp_list : (Exp.Exp, int) => Exp.Exp list =

  axiom	build_exp_list (e,1) => [e]

  rule	int_sub (c,1) => c' &
	build_exp_list (e, c') => rest
	------------------------------
	build_exp_list (e, c) => e::rest

end

relation elab_builtin_zeros : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(0)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_zeros (env, args) => (e,p)
end

relation elab_builtin_ones : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(1)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_ones (env, args) => (e,p)
end

relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list) 
					  => (Exp.Exp, Properties)) =

  axiom	elab_builtin_handler "size" => elab_builtin_size
  axiom	elab_builtin_handler "zeros" => elab_builtin_zeros
  axiom	elab_builtin_handler "ones" => elab_builtin_ones
  axiom	elab_builtin_handler "fill" => elab_builtin_fill

end


(** relation: elab_call_builtin
 **
 **)

relation elab_call_builtin : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

  rule	elab_builtin_handler name => handler &
	handler (env, args) => (exp,prop)
	-------------------
	elab_call_builtin (env, Absyn.CREF_IDENT(name,[]), args) => (exp, prop)


end


(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg list)
	=> (Exp.Exp, Properties) =

	  (** LS: Check if a builtin function call, e.g. size()
	      and calculate if so **)

  rule	(* PA. Built in functions have only possitional arguments *)
	elab_call_builtin (env, fn, args) => (e,prop)
	---------------------------------------------
	elab_call (env,fn,args,nargs) => (e,prop)

  rule	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args,nargs) => (e,prop) &
	Debug.fprintln ("sei", "elab_call succeeded")
	------------------------------------
	elab_call (env,fn,args,nargs) => (e,prop)

  rule	Print.print_buf "- elab_call failed\n"
	----------------------------
	elab_call (env,fn,args,nargs) => fail

end

(** relation: elab_call_args
 **
 ** Given the name of a function and two lists of expression and 
 ** NamedArg respectively to be used 
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, Absyn.Path, Absyn.Exp list, Absyn.NamedArg list)
	=> (Exp.Exp, Properties) =

  rule	(* This rule finds record constructors, user defined or implicit *)

	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(fargs,outtype as Types.T_COMPLEX(ClassInf.RECORD(_),_))) &
	Debug.fprintln ("sei", "function is record constructor\n") &
	
	make_empty_slots(fargs) => slots &
	elab_input_args(env, args,nargs,slots) => (args',newslots, c) &
	Debug.fprintln ("sei", "Did elab_input_args") &

	elab_consts(outtype) => const &

	Debug.fprintln ("sei", "Elaborated consts") &
	get_properties(outtype, const) => prop &

	Lookup.lookup_record_constructor_class(env,fn) => (cl,env') &
	Debug.fprintln ("sei", "got record constructor class") &
	
	fill_default_slots(newslots,cl,env') => newslots2 &
	Debug.fprint ("sei", "filled slots:") &
	Debug.fcall ("sei",print_slots,newslots2) &
	exp_list_from_slots(newslots2) => args'' &
	Debug.fprintln ("setr", "elab_call_args_succeeded")
	------------------------------------
	elab_call_args(env,fn,args,nargs) => (Exp.CALL(fn,args'',false,false), prop )

	(* This rule finds user-defined functions. *)

  rule	
	(* PR. We found a function definition of fn. *)
	Debug.fprintln ("sei", "Looking up function in elab_call_args.") &
	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(fargs,outtype)) &
	(* ClassInf.valid(st, Absyn.R_FUNCTION) & *)
	Debug.fprint("setr", "Did lookup in elab_call_args.\n") &
	(*PR. Find function parameters in the function definition.*)
	(*LS: Function type implemented, so just take second part of FunctionArg *)
(*	get_types(fargs) => in & *)

	Debug.fprintln ("sei", "Got types.") &
	(*PR. elaborate input parameters from the function call(args).
	* In are the in-parameters specified in the function declaration.
	* c indicate if all input parameters are constant, this means that
	* all output parameters are constant as well, since they only 
	* depends on the input parameters.
	* c is true if all input arguments are constant.
	*)
	make_empty_slots(fargs) => slots &
	elab_input_args(env, args,nargs,slots) => (args',newslots, c) &
	Debug.fprintln ("sei", "Did elab_input_args, constant=") &
	(*PR. !! Fix this. The function body is examined to determine the 
	* constness of each output argument.
	 At the moment this just gives a false list.
	*)
	elab_consts(outtype) => const &
 	(* Returns PROP_TUPLE if there is more than one element in the list. 
	   If there is only one element then PROP is returned.
	 *)
	is_tuple(outtype) => tuple &
	Debug.fprintln ("sei", "Elaborated consts") &
	get_properties(outtype, const) => prop &
	
	
	Debug.fprintln ("setr", "elab_call_args_succeeded")
	--------------------------------------------
	elab_call_args(env,fn,args,nargs) => (Exp.CALL(fn,args',tuple,false), prop )

	(* 
	 Functions that returns just one argument should not return a
	 tuple. It just returns a simple expression. 
	 *)



	(* This rule finds the built-in functions *)

  rule	

	(* PR. A function can have several types. Taking an array with
	 different dimensions as parameter for example. Because of this we
	 cannot just lookup the function name and trust that it
	 returns the correct function. It returns just one
	 functiontype of several possibilites. The solution is to send
	 in the funktion type of the user function and check both the
	 funktion name and the function's type. 
	 *)

(*	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(params,restype)) & *)
	Lookup.lookup_functions_in_env(env,fn) => typelist &
	Print.print_buf "We got the type list\n" & 
	elab_types (env, args, typelist) => (args', c, restype) &
(*	& Print.print_buf "We just elaborated the types\n"  *)
	is_tuple restype => tuple &
	(*P.R: When is T_FUNCTION ouputted from lookup_type? *)
(*	Print.print_buf "Debug: We did a lookup T_FUNCTION " &
*)
(*PR.	elab_input_args(env, args, params) => (args',c)  *)
	Debug.fprintln ("sei", "elab_call_args succeeded")
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs) => (Exp.CALL(fn,args',tuple,false), PROP(restype, c))

  rule	not Lookup.lookup_type(env,fn) => _ &
	
	Print.print_buf "# Couldn't find function " & Dump.print_path fn & Print.print_buf "\n"
	-------------------------------------------------------------------
	elab_call_args(env,fn,_,_) => fail

  rule	(*elab_exp(env, e) => (e',PROP(t,_)) &*)
	Print.print_buf "- elab_call_args failed\n"
	---------------------------------
	elab_call_args(_,_,_,_) => fail

end

relation is_tuple : Types.Type => bool =

  axiom is_tuple Types.T_TUPLE(_) => true
  axiom	is_tuple _ => false

end
(*PR.*)
relation  elab_types:  (Env.Env, Absyn.Exp list,  Types.Type list) 
	  => (Exp.Exp list, bool, Types.Type) =

	(* 
	 We found nothing. This is an error. return to the calling
	 function that writes an error message that makes sense (the
	 name of the funtion etc). 
	 *)
	(* 
	 If trest gets empty then we will return with a missmatch.
	 and write an error message in the calling function. 
	 *)

	(* We found a match.*)
  rule	Debug.fprintln ("sei", "We try the elab_input") &
	Debug.fprintln ("sei", "testing type:") &
	Debug.fcall ("sei", Types.print_type,t) &
	make_empty_slots(params) => slots &
	elab_input_args(env, args, [], slots ) => (args',newslots, c) &
        Debug.fprintln ("sei", "We found a match." )
	------------------
        elab_types(env, args, (t as Types.T_FUNCTION(params,restype))::trest)
	  => (args', c, restype)

	(* We did not found a match, try next. *)
  rule 	Debug.fprintln ("sei", "The elab_input_args failed, try next.") &
	elab_types(env, args, trest) => (args',c, restype) 
        ------------------
        elab_types(env, args, Types.T_FUNCTION(params,restype)::trest) 
	  => (args', c, restype)
       
end


(* PR get_prop 
*)
(* LS: Changed type list to type, since T_TUPLE already fixed before *)
relation get_properties : (Types.Type, Const)  => Properties =

	(* At least two elements in the type list, this is a tuple. *)
	(* LS: Tuples are fixed before here *)
  axiom	get_properties (tt as Types.T_TUPLE(_), const) => PROP_TUPLE(tt, const)

	(* One type, this is a tuple with one element. The resulting properties 
	 * is then identical to that of a single expression. *)
  axiom	get_properties(t, TUPLE_CONST(CONST(b)::[]))  => PROP(t, b)

end


(** PR. assisting routines
 ** This just splits the properties list into a type list and a const list. 
 **)
(* LS: Changed to take a Type, which is the functions return type *)
relation elab_consts : Types.Type  => Const =

  rule	check_consts tys => consts
	-------------------------------
	elab_consts Types.T_TUPLE(tys) => TUPLE_CONST(consts)

  (* LS: If not a tuple then one normal type, T_INTEGER etc, but we make a list of types
     with one element and call the same check_consts, so that we always have TUPLE_CONST as result
   *)
  rule	check_consts [ty] => consts
	-----------------------
	elab_consts ty => TUPLE_CONST(consts)

end

(* LS: Changed to take a Type list, which is the functions return type. Only
   for functions returning a tuple *)
relation check_consts : Types.Type list => Const list =	

  axiom	check_consts [] => []

  rule  check_const(a) => c &
	check_consts(rest) => rest'
	-------------------------------
	check_consts a::rest => c::rest'

end



(*PR. !! At the moment this make all outputs non cons.
* All ouputs sholud be checked in the function body for constness. 
*)
(* LS: but it says true? *)
(* LS: Adapted to check one type instead of funcarg, since it just checks return type *)
relation check_const : Types.Type => Const  =	
	
  rule	print("\n Error. No support for tuples built by tuples. Yet.") 
	-------------------------------
	check_const (Types.T_TUPLE(_)) => fail

  axiom	check_const (_) => CONST(true)
	
end

(* Splits the properties list into the separated types list and const list. *)
relation split_props : (Properties list) => (Types.Type list, Const list) =
  rule 	(*list_append(ts,t::[]) => t1 &
	list_append(cs,CONST(c)::[]) => t2 &
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (PROP(t,c)::props)=> (t::types,CONST(c)::consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	(*list_append(cs, t_c::[]) => cs' & 
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (PROP_TUPLE(t,t_c)::props)=> (t::types,t_c::consts)
  
  axiom	split_props([]) => ([], [])
end










(* obsolete LS: added space to inner comments, for emacs fontify to work
relation split_props: (Properties list, Types.Type list, Const list) => (Types.Type list, Const list) =
  rule 	list_append(ts,t::[]) => t1 &
	list_append(cs,CONST(c)::[]) => t2 &
	split_props(props, t1, t2) => (types, consts)
	-------------------------------------
	split_props (PROP(t,c)::props, ts, cs)=> (types,consts)

  rule 	( *  list_append(ts,t::[]) => ts' &   * )
	list_append(cs, t_c::[]) => cs' & 
	split_props(props, [], cs') => (types, consts)
	-------------------------------------
	split_props (PROP_TUPLE(t,t_c)::props, ts, cs)=> (types,consts)
  
  axiom	split_props([],ts,cs) => (ts, cs)
end
*)









(* LS: Changed to match FuncArg *)
relation get_types :(Types.FuncArg list) => Types.Type list =

  rule	(* print("\nDebug: Got a type for output of function. ") & *)
	get_types(rest) => types 
	-----------------
	get_types ((n,t)::rest) => t::types
	
  axiom	get_types ([]) => []
	
end


(** relation: functio_params
 **
 ** A function definition is just a clas definition where all publi
 ** components are declared as either inpu or outpu.  This
 ** relation_ find all those components and_ separates them into two
 ** separate lists.
 **)

(* LS: This can probably replaced by Types.get_input_vars and
   Types.get_output_vars *)

relation function_params : Types.Var list => (Types.FuncArg list,
					      Types.FuncArg list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	Debug.print("protected") &
	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	Debug.print("not protected. intput") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	Debug.print("not protected. output") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	Print.print_buf "# Components in functions must be INPUT or OUTPUT\n" &
	Print.print_buf "    component: " & Print.print_buf n & Print.print_buf "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,Types.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	Print.print_buf "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(* * relation_: elab_input_args
 **
 ** This relation_ elaborates on a number of expressions and_ matches
 ** them to a number of `Types.Var' objects, applying type_ conversions
 ** on the expressions when necessary to match the type_ of the
 ** `Types.Var'.
 * *)

(* PR. env, input args from the function call, in arguments in the
 function_ definition. *)
(* LS: inserted FuncArg *)
(* PA: Positional arguments and named arguments are filled in the argument slots as:
 1. Positional arguments fill the first slots according to their position.
 2. Named arguments fill slots with the same name as the named argument.
 3. Unfilled slots are checks so that they have default values, otherwise error.
*)
relation elab_input_args : (Env.Env, Absyn.Exp list, Absyn.NamedArg list, Slot list)
	=> (Exp.Exp list, Slot list, bool) =

  rule	Debug.fprint ("sei","elab_input_args, positional arguments\n") &
	funcarg_lst_from_slots(slots) => farg &
	elab_positional_input_args(env,exp,farg,slots) => (slots',c) &
	elab_input_args(env,[],narg,slots') => (_,newslots,c2) &
	bool_and(c,c2) => c3 &
	exp_list_from_slots(newslots) => explst
	----------------------------------------------------------------
	elab_input_args(env,exp as _::_,narg,slots) => (explst,newslots,c3)

  rule	Debug.fprint ("sei","elab_input_args, named arguments\n") &
	funcarg_lst_from_slots(slots) => farg &
	Debug.fprint ("sei","elab_input_args, got funcarg\n") &
	elab_named_input_args(env,narg,farg,slots) => (newslots,c) &
	exp_list_from_slots(newslots) => newexp &
	Debug.fprint ("sei","elab_input_args, got expressions: ") &
	Debug.fprint_list ("sei",newexp,Exp.print_exp,", ")
	------------------------------------------------------------
	elab_input_args(env,[],narg as _::_,slots) => (newexp,newslots,c)
	
  axiom	elab_input_args(env,[],[],slots) => ([],slots,true)
	
  rule	Print.print_buf "#Error, elab_input_args failed.\n"
	-----------------------------------------
	elab_input_args(_,_,_,_) => fail
end

relation make_empty_slots : (Types.FuncArg list) => Slot list =
	
  axiom	make_empty_slots([]) => []
	
  rule	make_empty_slots(fs) => ss
	--------------------------
	make_empty_slots(fa::fs) => SLOT(fa,false,NONE)::ss
end

relation funcarg_lst_from_slots : Slot list => Types.FuncArg list =
	
  axiom	 funcarg_lst_from_slots [] => [] 

  rule	funcarg_lst_from_slots(xs) => fs
	-------------------------------
	funcarg_lst_from_slots(SLOT(fa,_,_)::xs) => fa::fs
end 

relation exp_list_from_slots: (Slot list ) => Exp.Exp list =
	
  axiom	exp_list_from_slots [] => []
	
  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,SOME(e))::xs) => e::lst

  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,NONE)::xs) => lst
end

(** relation: fill_default_slots
 ** This function takes a slot list and a class definition of a function and fills default values into slots which 
 ** have not been filled.
   **)
	
relation fill_default_slots: (Slot list , SCode.Class, Env.Env) => Slot list =
	
  rule	fill_default_slots(xs,class,env) => res
	----------------------------
	fill_default_slots ( SLOT(fa,true,e)::xs,class,env) => SLOT(fa,true,e)::res

  rule	fill_default_slots(xs,class,env) => res &
	SCode.get_element_named(id,class) => SCode.COMPONENT(_,_,_,_,_,SCode.MOD(_,_,SOME(dexp))) &
	elab_exp (env,dexp) => (exp,PROP(t,c1)) &
	match_type(exp,t,tp) => (exp',_) 
	---------------------------------------------------------------------------------
	fill_default_slots (SLOT((id,tp),false,e)::xs,class,env) => SLOT((id,tp),true,SOME(exp'))::res

  rule	fill_default_slots(xs,class,env) => res &
	Print.print_buf "#Error filling slot, id =" &
	Print.print_buf id &
	Print.print_buf "\n"
	----------
	fill_default_slots (SLOT((id,tp),false,e)::xs,class,env) => SLOT((id,tp),true,e)::xs

  axiom	fill_default_slots([],_,_) => []
end

relation print_slots: Slot list => () =
  rule	Print.print_buf "SLOT(" &
	Types.print_farg farg &
	Print.print_buf  ", " &
	Dump.print_select(filled,"filled","not filled") &
	Print.print_buf ", " &
	Dump.get_option_str(exp,Exp.print_exp_str) => str &
	Print.print_buf str &
	Print.print_buf ")\n" &
	print_slots(xs)
	---------------
	print_slots (SLOT(farg,filled,exp)::xs) => ()
  axiom	print_slots([] ) => ()
end 

(** relation: elab_positional_input_args
 ** This relation elaborates the positional input arguments of a function.
 ** A list of slots is filled from the beginning with types of each positional argument.
 **)
relation elab_positional_input_args : (Env.Env, Absyn.Exp list, Types.FuncArg list,  Slot list) 
	  => (Slot list, bool) =
	  
  axiom	elab_positional_input_args(_, [], _, slots) => (slots, true)
	
  rule	elab_exp(env, e) => (e',PROP(t, c1)) &
	match_type(e', t, vt) => (e'',_) &
	elab_positional_input_args(env, es, vs,slots) => (slots',c2) &
	bool_and(c1, c2) => c &
	fill_slot(farg, e'',slots') => newslots
	-------------------------------------
	elab_positional_input_args(env, e::es, (farg as (_,vt))::vs, slots) 
	    => (newslots, c)
end

(** relation elab_named_input_args
 ** This relation takes an Env, a NamedArg list, a Types.FuncArg list and a Slot list.
 ** It builds up a new slot list and a list of elaborated expressions.
 ** If a slot is filled twice the relation fails. If a slot is not filled at all and the 
 ** value is not a parameter or a constant the relation also fails.
*)
relation elab_named_input_args : (Env.Env, Absyn.NamedArg list, Types.FuncArg list, Slot list) 
	=> (Slot list, bool) =

(*  rule	check_slots_filled(env,slots) 
	----------------------------
	elab_named_input_args(env,[],farg,slots) => ([],slots,true) *)

  rule	elab_exp(env, e) => (e',PROP(t, c1)) &
	Debug.fprint("sei", "elab_named_input_arg, elaborated exp\n  id =") &
	Debug.fprint("sei",id) &
	find_named_arg_type(id,farg) => vt &
	Debug.fprint ("sei", "elab_named_input_arg, found type\n") &
	Debug.fprint ("sei", "exp t = " ) &
	Debug.fcall ("sei", Types.print_type,t ) &
	Debug.fprint ("sei", "func t = " ) &
	Debug.fcall ("sei", Types.print_type,vt ) &
	match_type(e', t, vt) => (e'',_) &
	Debug.fprint ("sei", "elab_named_input_arg, Types matched!\n") &
	fill_slot((id,vt), e'', slots) => slots' &
	Debug.fprint ("sei", "elab_named_input_arg, filled slot\n") &
	elab_named_input_args(env, nas, farg ,slots') => (newslots, c2) &
	bool_and(c1, c2) => c 
	---------------------
	elab_named_input_args (env, Absyn.NAMEDARG(id,e)::nas,farg,slots) 
	  => (newslots, c)

axiom elab_named_input_args (_,[],_,slots) => (slots,true)

  rule	Debug.fprint ("sei","elab_named_input_args failed, nargs = ") &
	Debug.fprint_list ("sei", narg, Dump.print_named_arg," ,")&
	Debug.fprint ("sei"," FuncArg=") &
	Debug.fcall  ("sei",Types.print_params,farg) &
	Debug.fprint ("sei", "\n")
	-----------------
	elab_named_input_args(env,narg,farg,_) => fail
end

(** relation find_named_arg_type
 ** This relation takes an Ident and a FuncArg list, and returns the FuncArg which has that identifier.
 ** Used for instance when looking up named arguments from the function type.
 **)
 relation find_named_arg_type : (Ident, Types.FuncArg list) => Types.Type =
	 
  rule	 id = id2
	 -----------------
	 find_named_arg_type (id, ((id2,farg))::ts) => farg
  rule	 not id = id2  &
	 find_named_arg_type (id,ts) => farg
	 ----------------------------------
	 find_named_arg_type(id,(farg as (id2,_))::ts) => farg
end

(** relation: fill_slot
 ** This relation takses a `FuncArg' and an Exp.Exp and a Slot list and fills the slot holding the FuncArg, by setting
 ** the boolean value of the slot and setting the expression. The relation fails if the slot is allready set.
 **)
relation fill_slot:(Types.FuncArg, Exp.Exp, Slot list) => Slot list =
	
  rule	fa1 = fa2
	---------
	fill_slot((fa1,_), exp,SLOT((fa2,b),false,_)::xs) => SLOT((fa2,b),true,SOME(exp))::xs

  rule	fa1 = fa2 &
	Print.print_buf "#Error, slot in functional argument allready filled.\b" 
	--------------------------------------------------------------
	fill_slot((fa1,_),exp, SLOT((fa2,b),true,_)::xs) => fail

  rule	not fa1 = fa2 &
	fill_slot(farg,exp,xs) => newslots
	------------------------------
	fill_slot((farg as (fa1,_)), exp,(s1 as SLOT((fa2,_),_,_))::xs) => s1::newslots

  rule  Print.print_buf "#Error, slot not found in function type.\n"
	---------------------------------------------------
	fill_slot(_,_,_) => fail
end

(* LS *)

relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	=> (Exp.Exp list, Properties list, SCode.Accessibility list) =

  axiom	elab_cref_list (_, []) => ([], [], [])

  rule	elab_cref (env, cref) => (exp, prop, acc) &
	elab_cref_list (env, creflist) => (explist, proplist, acclist)
	----------------------------------------------------------
	elab_cref_list (env, cref::creflist) 
	  => (exp::explist, prop::proplist, acc::acclist)

end


(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Properties, SCode.Accessibility) =

  rule	elab_cref_subs (env,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,acc,variability,_),
				       t,
				       binding) &
	elab_cref2 (env, c', acc, variability, t, binding)
	  => (exp,const,acc')
	(* FIXME subscript_cref_type (exp,t) => t' &  *)
	---------------------------------
	elab_cref(env, c) => (exp, PROP(t, const), acc')

  rule	elab_cref_subs (env,c) => (c', const) &
	Print.print_buf "# Unknown component: " & Dump.print_component_ref c & Print.print_buf "\n" &
	Env.print_env env
	-----------------------------------------------------
	elab_cref(env, c) => fail

  rule	Print.print_buf "- elab_cref failed: " & Dump.print_component_ref c & Print.print_buf "\n"
	------------------------------
	elab_cref (_,c) => fail

end

relation elab_type : Types.Type => Exp.Type =

  axiom	elab_type Types.T_INTEGER => Exp.INT
  axiom	elab_type Types.T_REAL => Exp.REAL
  axiom	elab_type Types.T_BOOL => Exp.BOOL
  axiom	elab_type Types.T_STRING => Exp.STRING
  axiom elab_type Types.T_ENUM => Exp.ENUM

  rule	Types.array_element_type t => et &
	elab_type et => t'
	----------------
	elab_type (t as Types.T_ARRAY(_,_)) => t'

  axiom	elab_type _ => Exp.OTHER

end
relation fill_cref_subscripts : (Exp.ComponentRef,Types.Type)
	  => Exp.ComponentRef =

  axiom	fill_cref_subscripts (e as Exp.CREF_IDENT(_,[]),t) => e

  rule	fill_subscripts (subs,t) => subs'
	------------------
	fill_cref_subscripts (Exp.CREF_IDENT(id,subs),t)
	  => Exp.CREF_IDENT(id,subs')

  rule	fill_cref_subscripts (cref,t) => cref'
	-----------------------------
	fill_cref_subscripts (Exp.CREF_QUAL(id,subs,cref),t)
			      => Exp.CREF_QUAL(id,subs,cref') 

end

relation fill_subscripts : (Exp.Subscript list, Types.Type) 
	  => Exp.Subscript list =

rule	fill_subscripts ([],t) => subs' &
	list_append([Exp.WHOLEDIM],subs') => subs''
	------------
	fill_subscripts ([],Types.T_ARRAY(_,t)) => subs''

  rule	fill_subscripts (subs,t) => subs' 
	------------
	fill_subscripts (fs::subs,Types.T_ARRAY(_,t)) => fs::subs'

  axiom	fill_subscripts (subs,_) => subs

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef,
		       SCode.Accessibility, Absyn.Variability,
		       Types.Type, Types.Binding)
	  => (Exp.Exp,bool,SCode.Accessibility) =

  rule	elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	-----------------
	elab_cref2 (_,cr, acc, Absyn.VAR, tt,_) => (Exp.CREF(cr',t),false, acc)

  rule	elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	------------------
	elab_cref2 (_,cr, acc, Absyn.DISCRETE,tt,_)
	  =>(Exp.CREF(cr',t),false,acc)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,Absyn.CONST,t, Types.VALBOUND(v)) => (e,true,SCode.RO)

 rule	elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	----------------
 	elab_cref2 (env,cr,acc,Absyn.PARAM,tt, Types.VALBOUND(v)) => (Exp.CREF(cr',t),false,acc)

  rule	elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	----------------
	elab_cref2 (env,cr,acc,_,tt, Types.EQBOUND(exp,true))
	  => (Exp.CREF(cr',t),true,acc)

	  (* Enum constants does not have a value expression *)
  rule	elab_type tt => t
	-----------------
	elab_cref2(env,cr,acc,_,tt as Types.T_ENUM,_) => (Exp.CREF(cr,t),true,acc)

  rule	Print.print_buf "# Constant or parameter with a non-constant initializer\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr & Print.print_buf " = " &
	Exp.print_exp exp & Print.print_buf "\n"
	------------------------------
	elab_cref2 (_,cr,_, _,_,Types.EQBOUND(exp,false)) => fail

  rule	Print.print_buf "# Constant or parameter without a value\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr & Print.print_buf "\n"
	----------------------------------------------
	elab_cref2 (_,cr,_,_,_,Types.UNBOUND) => fail

  rule	Print.print_buf "- elab_cref2 failed (component: " &
	Exp.print_component_ref cr & Print.print_buf ")\n"
	----------------------------------------
	elab_cref2 (_,cr,_,_,_,_) => fail

end	

(** relation: elab_cref_subs
 **
 ** This relation elaborates on all subscripts in a component reference.
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(** relation: elab_subscripts
 **
 ** This relation converts a list of `Absyn.Subscript' to a list of
 ** `Exp.Subscript', and checks if all subscripts are constant.
 ** HJ: not checking for constant, returning if constant or not
 **)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => true &
	ceval_subscripts(env, sub'::subs') => ss
	-----------------------------------
	elab_subscripts (env,sub::subs) => (ss, true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => false
	-----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs', false)

end

(** relation: elab_subscript
 **
 ** This relation converts an `Absyn.Subscript' to an
 ** `Exp.Subscript'.
 **)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.WHOLEDIM, true)

  rule	elab_exp (env,sub) => (sub', PROP(ty, const)) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub)) => (sub'', const)

end

(** relation: elab_subscript_type
 **
 ** This relation is used to find the correct constructor for
 ** `Exp.Subscript' to use for an indexing expression.  If an integer
 ** is given as index, `Exp.INDEX()' is used, and if an integer array
 ** is given, `Exp.SLICE()' is used.
 **)

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type (Types.T_INTEGER,_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type (Types.T_ARRAY(_,Types.T_INTEGER),_,sub)
	  => Exp.SLICE(sub)

  rule	Print.print_buf "# Subscript is not an integer or integer array\n" &
	Print.print_buf "    expression: " & Dump.print_exp e &
 	Print.print_buf " :: " & Types.print_type t & Print.print_buf "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **
 ** This relation might actually not be needed.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c,_), t) => t'

  axiom	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (t,subs) => t'
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs), t) => t'

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **
 ** This does not handle slices or check that subscripts are not out
 ** of bounds.
 **)

relation subscript_type : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom	subscript_type (t,[]) => t

  rule	subscript_type (t, subs) => t'
	----------------------------------
	subscript_type (Types.T_ARRAY(Types.DIM(_),t),
			Exp.INDEX(_)::subs) => t'

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.SLICE(_)::subs)
	  => Types.T_ARRAY(dim,t')

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.WHOLEDIM::subs)
	  => Types.T_ARRAY(dim,t')

  rule	Print.print_buf "- subscript_type failed (" & Types.print_type t &
	Print.print_buf " , [...])\n"
	-------------------
	subscript_type (t,_) => fail

end

(** relation: elab_ifexp
 ** 
 ** This relation elaborates on the parts of an if expression.
 **)

relation elab_ifexp : (Exp.Exp, Properties,
		       Exp.Exp, Properties,
		       Exp.Exp, Properties)
	  => (Exp.Exp, Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),
		   e3,PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3), PROP(t2, c))

  rule	not t1 = Types.T_BOOL &
	Print.print_buf "# conditional in if expression has to be boolean\n" &
	Print.print_buf "    got type: " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    expression: " & Exp.print_exp e1 & Print.print_buf "\n"
	--------------------------------------------------------
	elab_ifexp(e1,PROP(t1,c1),e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	Types.equivtypes(t2,t3) => false &
	Print.print_buf "# Type mismatch in if-expression\n" &
	Print.print_buf "    true branch : " & Exp.print_exp e2 &
 	Print.print_buf " :: " & Types.print_type t2 & Print.print_buf "\n" &
	Print.print_buf "    false branch: " & Exp.print_exp e3 &
 	Print.print_buf " :: " & Types.print_type t3 & Print.print_buf "\n"
	-----------------------------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	Print.print_buf "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_) => fail

end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, bool, bool, bool) => bool =

  axiom	const_ifexp(_,true,true,true) => true
  axiom	const_ifexp(_,_,_,_) => false

end

(** relation: ceval
 **
 ** This relations is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 **)

relation ceval : (Env.Env, Exp.Exp, bool) => Values.Value =

  axiom	ceval (_,Exp.ICONST(x),_) => Values.INTEGER(x)
  axiom	ceval (_,Exp.RCONST(x),_) => Values.REAL(x)
  axiom ceval (_,Exp.SCONST(x),_) => Values.STRING(x)
  axiom ceval (_,Exp.BCONST(x),_) => Values.BOOL(x)

  rule	ceval_list (env,es) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(_,_,es),_) => Values.ARRAY(es')

  rule	ceval_matrixelt(env,expll) => elts
	------------------------------
	ceval (env, Exp.MATRIX(_,_,expll),_) => Values.ARRAY(elts)

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c,_),_) => v 

  rule	Print.print_buf "# Can't call functions at compile time\n" &
	Print.print_buf "    expression: " & Exp.print_exp e & Print.print_buf "\n"
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(_,_,_,_),false) => fail

  rule	(* Call externally implemented functions, if present *)
	ceval_list(env,expl) => vallst &
	Absyn.path_string(func) => funcstr &
	string_append(funcstr,"_in.txt") => infilename &
	string_append(funcstr,"_out.txt") => outfilename &
	Values.write_to_file_as_args(vallst,infilename)  &
	System.execute_function(funcstr) &
	System.read_values_from_file(outfilename) => newval
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(func,expl,_,_),true) => newval

	(**  Numerical *)

  rule	ceval (env, lh, i) => Values.REAL(lhv) &
	ceval (env, rh, i) => Values.REAL(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh),i)
	  => Values.REAL(sum)

  rule	ceval (env,lh,i) => Values.ARRAY(vlst1) &
	ceval (env,rh,i) => Values.ARRAY(vlst2) &
	Values.add_elementwise_arrayelt(vlst1, vlst2) => reslst
	-------------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD_ARR(_),rh),i) 
	  => Values.ARRAY(reslst)

  rule	ceval (env,lh,i) => Values.ARRAY(vlst1) &
	ceval (env,rh,i) => Values.ARRAY(vlst2) &
	Values.sub_elementwise_arrayelt(vlst1, vlst2) => reslst
	-------------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB_ARR(_),rh),i) => Values.ARRAY(reslst)

  rule	ceval (env,lh,i) => sval &
	ceval (env,rh,i) => Values.ARRAY(aval) &
	Values.mult_scalar_arrayelt(sval,aval) => reslst
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_ARRAY(_), rh),i) 
	  => Values.ARRAY(reslst)

  rule	ceval (env,rh,i) => sval &
	ceval (env,lh,i) => Values.ARRAY(aval) &
	Values.mult_scalar_arrayelt(sval,aval) => reslst
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_ARRAY_SCALAR(_), rh),i) 
	  => Values.ARRAY(reslst)

  rule	ceval (env,rh,i) => Values.ARRAY(rhvals) &
	ceval (env,lh,i) => Values.ARRAY(lhvals) &
	Values.mult_scalar_product(rhvals,lhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_PRODUCT(_), rh),i) => res
	
  rule	(* {{..}..{..}} * {...} *)
	ceval (env,lh,i) => Values.ARRAY(lhvals as (elt1::_)) &
 	ceval (env,rh,i) => Values.ARRAY(rhvals as (elt2::_)) &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => false &
	Values.mult_scalar_product(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),i) => res

 rule	(* {...} * {{..}..{..}} *)
	ceval (env,rh,i) => Values.ARRAY(rhvals as (elt1::_)) &
 	ceval (env,lh,i) => Values.ARRAY(lhvals as (elt2::_)) &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => false &
	Values.mult_scalar_product(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),i) => res

 rule	(* {{..}..{..}} * {{..}..{..}} *)
	ceval (env,rh,i) => Values.ARRAY(rhvals as (elt1::_)) &
 	ceval (env,lh,i) => Values.ARRAY(lhvals as (elt2::_)) &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => true &
	Values.mult_matrix(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),i) 
	  => Values.ARRAY(res)

  rule	ceval (env,lh,i) => Values.INTEGER(lhv) &
	ceval (env,rh,i) => Values.INTEGER(rhv) &
	int_add(lhv, rhv) => sum
	------------------------
 	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh),i) 
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env,lh,i) => Values.REAL(lhv) &
	ceval (env,rh,i) => Values.REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh),i) 
	  => Values.REAL(sum)

  rule	ceval (env,lh,i) => Values.INTEGER(lhv) &
	ceval (env, rh,i) => Values.INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh),i)
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env,lh,i) => Values.REAL(lhv) &
	ceval (env,rh,i) => Values.REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh),i) 
	  => Values.REAL(sum)

  rule	ceval (env,lh,i) => Values.INTEGER(lhv) &
	ceval (env,rh,i) => Values.INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh),i)
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env,exp,i) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp),i)
	  => Values.REAL(x')

  rule	ceval (env,exp,i) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp),i)
	  => Values.INTEGER(x')
	(**)
  rule	ceval (env,exp,i) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp),i)
	  => Values.REAL(x')

  rule	ceval (env,exp,i) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp),i)
	  => Values.INTEGER(x')

	(**  Logical *)

  rule	ceval (env,lh,i) => Values.BOOL(lhv) &
	ceval (env,rh,i) => Values.BOOL(rhv) &
	bool_and(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.AND, rh),i)
	  => Values.BOOL(x)

  rule	ceval (env,lh,i) => Values.BOOL(lhv) &
	ceval (env,rh,i) => Values.BOOL(rhv) &
	bool_or(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.OR, rh),i)
	  => Values.BOOL(x)

  rule	ceval (env,e,i) => Values.BOOL(b) &
	bool_not(b) => b'
	-----------------
	ceval (env, Exp.LUNARY(Exp.NOT, e),i) => Values.BOOL(b')

	(**  Relations *)

  rule	ceval (env,lhs,i) => lhs' &
	ceval (env,rhs,i) => rhs' &
	ceval_relation (lhs',relop,rhs') => v
	-------------------------------------
	ceval (env, Exp.RELATION(lhs,relop,rhs),i) => v

	(**)

  rule	ceval (env,start,i) => Values.INTEGER(start') &
	ceval (env,stop,i) => Values.INTEGER(stop') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.INT,start, NONE, stop),i) 
	  => Values.ARRAY(arr)

  rule	ceval (env,start,i) => Values.INTEGER(start') &
	ceval (env,step,i) => Values.INTEGER(step') &
	ceval (env,stop,i) => Values.INTEGER(stop') &
	ceval_range(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.INT,start, SOME(step), stop),i) 
	  => Values.ARRAY(arr)

  rule	ceval (env,start,i) => Values.REAL(start') &
	ceval (env,stop,i) => Values.REAL(stop') &
	ceval_range_real(start', 1.0, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.REAL,start, NONE, stop),i) 
	  => Values.ARRAY(arr)

  rule	ceval (env,start,i) => Values.REAL(start') &
	ceval (env,step,i) => Values.REAL(step') &
	ceval (env,stop,i) => Values.REAL(stop') &
	ceval_range_real(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.REAL,start, SOME(step), stop),i) 
	  => Values.ARRAY(arr)

  rule	ceval (env,e,i) => Values.INTEGER(i) &
	int_real i => r
	---------------
	ceval (env, Exp.CAST(Exp.REAL,e),i) => Values.REAL(r)

  rule	Print.print_buf "- ceval " & Exp.print_exp e & Print.print_buf " failed\n"
	-----------------------------------------------------
	ceval (_,e,_) => fail
	
end

relation ceval_matrixelt:(Env.Env,(Exp.Exp*bool) list list) => Values.Value list =

  rule	ceval_matrixeltrow(env,expl) => v &
	ceval_matrixelt(env,expll) => vl
	---------------------------
	ceval_matrixelt(env,expl::expll) => v::vl
	
  axiom	ceval_matrixelt(_,[]) => []
end

relation ceval_matrixeltrow:(Env.Env, (Exp.Exp*bool) list ) => Values.Value =
	
  rule	ceval (env,e,false) => res &
	ceval_matrixeltrow(env,rest) => Values.ARRAY(resl)
	-------------------
	ceval_matrixeltrow(env, (e,_)::rest) => Values.ARRAY(res::resl)
	
  axiom	 ceval_matrixeltrow(env,[]) => Values.ARRAY([])

end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	-----------------------------------------
	ceval_relation (v1, Exp.GREATER(t), v2) => v

	(**  Integers *)

  rule	int_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.LESS(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.EQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.NEQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

	(**  Reals *)

  rule	real_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.LESS(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.EQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.NEQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	Print.print_buf "- ceval_relation failed\n"
	---------------------------------
	ceval_relation (_,_,_) => fail

end

(** relation: ceval_range
 **
 ** This relation evaluates a range expression.  It only handles integers.
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range (start,_,stop) => []

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range (next, step, stop) => l
	-----------------------------------
	ceval_range (start, step, stop) => Values.INTEGER(start)::l

end

(** relation: ceval_range_real
 **
 ** This relation evaluates a range expression.  It only handles reals
 **)

relation ceval_range_real : (real, real, real) => Values.Value list =

  rule	real_gt(start,stop) => true
	--------------------------
	ceval_range_real (start,_,stop) => []

  rule	real_gt(start,stop) => false & (* redundant *)
	real_add (start, step) => next &
	ceval_range_real (next, step, stop) => l
	-----------------------------------
	ceval_range_real (start, step, stop) => Values.REAL(start)::l

end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

relation ceval_list : (Env.Env, Exp.Exp list) => Values.Value list =
	  
  rule	ceval (env, exp,false) => v
	----------------------------
	ceval_list (env, [exp]) => [v]

  rule	ceval (env,exp,false) => v &
	ceval_list (env, exps) => vs
	------------------------------
	ceval_list (env, exp::exps) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

  rule	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,c,binding) => v
	-------------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	Print.print_buf "# No constant binding for " &
	Exp.print_component_ref c & Print.print_buf "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Exp.ComponentRef,Types.Binding) => Values.Value =

  rule	ceval_subscript_value(env,subsc,v) => res
	-----------------------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(_,subsc),Types.VALBOUND(v))
	  => res

  rule	Print.print_buf "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND) => fail
	
  rule	ceval (env,exp,false) => v
	------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(_,[]),Types.EQBOUND(exp,true)) => v

  rule	Print.print_buf "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Exp.print_exp exp & Print.print_buf ")\n"
	--------------------------------
	ceval_cref_binding (env,_,Types.EQBOUND(exp,false)) => fail
	
end

relation ceval_subscript_value: (Env.Env,Exp.Subscript list ,Values.Value) 
	  => Values.Value =

  rule	ceval(env,exp,false) => Values.INTEGER(n) &
	int_sub(n,1) => n' &
	list_nth(lst,n') => subval &
	ceval_subscript_value(env,subs,subval) => res 
	---------------------------------------------
	ceval_subscript_value(env,Exp.INDEX(exp)::subs,Values.ARRAY(lst)) 
	  => res
	  
  axiom	ceval_subscript_value(env,[],v) => v
			      
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)
  axiom	value_exp (Values.ARRAY([]))  => Exp.ARRAY(Exp.OTHER,false,[])

  rule	value_exp x => x' &
	value_type x => vt &
	elab_type vt => t &
	Types.is_array vt => a &
  	value_exp Values.ARRAY(xs) => Exp.ARRAY(_,_,xs')
	--------------------------------------------
	value_exp (Values.ARRAY(x::xs)) => Exp.ARRAY(t,a,x'::xs')

  rule	Print.print_buf "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER
  axiom	value_type Values.REAL(x)    => Types.T_REAL
  axiom value_type Values.STRING(x)  => Types.T_STRING
  axiom value_type Values.BOOL(x)    => Types.T_BOOL

  rule	Print.print_buf "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	ceval_subscripts (env,ss) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	ceval_subscripts (env,ss) => ss' &
	canon_cref (env,c) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[]) => []

  rule	ceval_subscript (env,sub) => sub' &
	ceval_subscripts (env,subs) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs) => (sub'::subs')

end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.WHOLEDIM) => Exp.WHOLEDIM

  rule	ceval (env, e1,false) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1)) => Exp.INDEX(e1')
	
  rule	ceval (env, e1, false) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1)) => Exp.SLICE(e1')
	
end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.WHOLEDIM,Exp.WHOLEDIM)
 	
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
	
  rule	Print.print_buf "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> (Exp.Exp list,Types.Type list) =

  axiom	elab_arglist ([],[]) => ([],[])

  rule	Debug.fprint("earg","Match: ") & 
	Debug.fcall ("earg",Types.print_type, atype) & 
	Debug.fprint("earg"," == ") & 
	Debug.fcall ("earg",Types.print_type,pt) &
	Debug.fprint("earg","\n") &
	match_type(arg, atype, pt) => (arg',atype') &
	elab_arglist (pts, args) => (args',atypes')
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => (arg'::args',atype'::atypes')

  rule	Debug.fprint("earg","- Static.elab_arglist failed\n")
	--------------------------------------
	elab_arglist (_,_) => fail
end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	Debug.print "Debug: match prop." &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

  rule	Debug.print "\nDebug: match prop (PROP TUPLE). " &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP_TUPLE(gt,_), PROP_TUPLE(et,_)) => e'

end

(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Types.Type, Types.Type) => (Exp.Exp, Types.Type) =

  rule	Types.subtype(e_type, expected_type) => true
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e, e_type)

  rule	Types.subtype(e_type, expected_type) => false &
	Debug.fprint("sei", "trying type convert\n") &
	type_convert(e, e_type, expected_type) => (e',e_type') &
	Debug.fprint("sei", "Type convert succeded\n") 
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e',e_type')
end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Types.Type, Types.Type) => (Exp.Exp, Types.Type) =

  axiom	type_convert(e, Types.T_INTEGER, Types.T_REAL) => (Exp.CAST(Exp.REAL,e),Types.T_REAL)

  rule	int_eq (dim1, dim2) => true &
	type_convert_array (elist, ty1, ty2) => elist' &
	elab_type ty2 => at &
	Types.is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     Types.T_ARRAY(Types.DIM(SOME(dim1)), ty1), 
		     Types.T_ARRAY(Types.DIM(SOME(dim2)), ty2))
	  => (Exp.ARRAY(at,a,elist'),Types.T_ARRAY(Types.DIM(SOME(dim1)),ty2))

  rule	int_eq (dim1, dim2) => true &
	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     Types.T_ARRAY(Types.DIM(SOME(dim1)),Types.T_ARRAY(Types.DIM(SOME(dim11)),t1)), 
		     Types.T_ARRAY(Types.DIM(SOME(dim2)), Types.T_ARRAY(Types.DIM(SOME(dim22)),t2)))
	    => (Exp.MATRIX(at,nmax,ell'),Types.T_ARRAY(Types.DIM(SOME(dim1)),Types.T_ARRAY(Types.DIM(SOME(dim11)),t2)))
	    
  rule	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     Types.T_ARRAY(Types.DIM(SOME(dim1)),Types.T_ARRAY(Types.DIM(SOME(dim11)),t1)), 
		     Types.T_ARRAY(Types.DIM(NONE), Types.T_ARRAY(Types.DIM(SOME(dim22)),t2)))
	    => (Exp.MATRIX(at,nmax,ell'),Types.T_ARRAY(Types.DIM(SOME(dim1)),Types.T_ARRAY(Types.DIM(SOME(dim11)),t2)))

  rule	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     Types.T_ARRAY(Types.DIM(NONE), ty1), 
		     Types.T_ARRAY(Types.DIM(SOME(dim2)), ty2))
	  => (e', Types.T_ARRAY(Types.DIM(NONE), t'))

  rule	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     Types.T_ARRAY(Types.DIM(SOME(dim1)), ty1), 
		     Types.T_ARRAY(Types.DIM(NONE), ty2))
	  => (e', Types.T_ARRAY(Types.DIM(SOME(dim1)), t'))

  rule	type_convert_list (elist, tys1, tys2) => (elist',tys')
	------------------------------------------
	type_convert(Exp.TUPLE(elist), 
		     Types.T_TUPLE(tys1), 
		     Types.T_TUPLE(tys2))
	  => (Exp.TUPLE(elist'), Types.T_TUPLE(tys'))

  axiom	type_convert(exp, 
	    Types.T_ENUM,
	    Types.T_ENUMERATION(l))
	    => (exp, Types.T_ENUMERATION(l))
	    
  rule	Debug.fprint("tcvt","- type conversion failed: ") &
	Debug.fcall ("tcvt",Types.print_type,t1) & 
	Debug.fprint("tcvt",", ") & 
	Debug.fcall ("tcvt",Types.print_type,t2) &
	Debug.fprint("tcvt","\n")
	-------------------------------
	type_convert (_,t1,t2) => fail
end

relation type_convert_array : (Exp.Exp list, Types.Type, Types.Type) => Exp.Exp list =

  axiom type_convert_array ([], _, _) => []

  rule	type_convert_array (rest, ty1, ty2) => rest' &
	type_convert (first, ty1, ty2) => (first',_)
	-------------------------------------------
	type_convert_array (first::rest, ty1, ty2) => first'::rest'

  rule	Print.print_buf "- type conversion of array failed exp=" &
	Exp.print_exp e &
	Print.print_buf "t1 = " &
	Types.print_type t1 & 
	Print.print_buf " t2 = " &
	Types.print_type t2 &
	Print.print_buf "\n" 
	-------------------------------
	type_convert_array (e::_,t1,t2) => fail

end

relation type_convert_matrix : ((Exp.Exp*bool) list list, Types.Type, Types.Type) => (Exp.Exp*bool) list list =

  axiom type_convert_matrix ([], _, _) => []

  rule	type_convert_matrix (rest, ty1, ty2) => rest' &
	type_convert_matrix_row(first,ty1,ty2) => first'
	-------------------------------------------
	type_convert_matrix (first::rest, ty1, ty2) => first'::rest'

  rule	Print.print_buf "- type conversion of matrix failed" &
	Print.print_buf "t1 = " &
	Types.print_type t1 & 
	Print.print_buf " t2 = " &
	Types.print_type t2 &
	Print.print_buf "\n" 
	-------------------------------
	type_convert_matrix (e::_,t1,t2) => fail

end

relation type_convert_matrix_row: ((Exp.Exp*bool) list , Types.Type, Types.Type) 
	    => ( Exp.Exp * bool) list =
  axiom type_convert_matrix_row ([],_,_) => []

  rule	type_convert_matrix_row(rest,t1,t2) => rest &
	type_convert(exp,t1,t2) => (exp',newt) &
	Types.is_array t2 => a
	---------------------------------
	type_convert_matrix_row((exp,_)::rest,t1,t2 )=> ((exp',a)::rest)
end

relation type_convert_list : (Exp.Exp list, Types.Type list, Types.Type list) 
	  => (Exp.Exp list, Types.Type list) =

  axiom type_convert_list ([], _, _) => ([],[])

  rule	type_convert_list (rest, ty1rest, ty2rest) => (rest',tyrest') &
	type_convert (first, ty1, ty2) => (first',ty')
	-------------------------------------------
	type_convert_list (first::rest, ty1::ty1rest, ty2::ty2rest) => (first'::rest',ty'::tyrest')

end

(** relation: deoverlooad
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	Debug.fprint_list("dovl",params,Types.print_type,"\n") & 
	Debug.fprint("dovl","\n===\n") &
	elab_arglist (params, args) => (args',types') &
	compute_return_type(op, types', rtype) => rtype'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype')

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	Print.print_buf "# Can't resolve type of expression: " &
	Dump.print_exp exp & Print.print_buf "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

relation compute_return_type : (Exp.Operator, Types.Type list, Types.Type) => Types.Type =

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_buf "# +: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_buf "# -: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Print.print_buf "# *: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),[typ1,typ2],_) => fail

  rule	n_dims typ1 => 1 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n1 &
	dim_size(typ2,1) => n2 &
	dim_size(typ2,2) => m &
	n1 = n2 &
	element_type typ1 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(m)),etype)
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 1 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	m1 = m2 &
	element_type typ2 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(n)),etype)
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	dim_size(typ2,2) => p &
	m1 = m2 &
	element_type typ1 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(n)),
				  Types.T_ARRAY(Types.DIM(SOME(p)),etype))
	-----------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	Print.print_buf "# *: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	-----------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => fail

  axiom	compute_return_type (Exp.MUL_SCALAR_ARRAY(_),[typ1,typ2],rtype) => typ2
  axiom	compute_return_type (Exp.MUL_ARRAY_SCALAR(_),[typ1,typ2],rtype) => typ1



  axiom	compute_return_type (Exp.ADD(_),_,typ) => typ
  axiom	compute_return_type (Exp.SUB(_),_,typ) => typ
  axiom	compute_return_type (Exp.MUL(_),_,typ) => typ
  axiom	compute_return_type (Exp.DIV(_),_,typ) => typ
  axiom	compute_return_type (Exp.POW(_),_,typ) => typ
  axiom	compute_return_type (Exp.UMINUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.UPLUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.AND,_,typ) => typ
  axiom	compute_return_type (Exp.OR,_,typ) => typ
  axiom	compute_return_type (Exp.NOT,_,typ) => typ
  axiom	compute_return_type (Exp.LESS(_),_,typ) => typ
  axiom	compute_return_type (Exp.LESSEQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATER(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATEREQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.EQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.NEQUAL(_),_,typ) => typ

end 

relation n_dims : Types.Type => int =
	
  axiom	n_dims Types.T_INTEGER => 0
  axiom	n_dims Types.T_REAL => 0
  axiom	n_dims Types.T_STRING => 0
  axiom	n_dims Types.T_BOOL => 0

  rule	n_dims t => ns &
	int_add(ns,1) => n
	-----------------------------
	n_dims Types.T_ARRAY(_,t) => n

end

relation dim_size : (Types.Type,int) => int =

  axiom	dim_size(Types.T_ARRAY(Types.DIM(SOME(n)),_),1) => n

  rule	int_gt(d,1) => true &
	int_sub(d,1) => d' &
	dim_size(t,d') => n
	----------------------
	dim_size(Types.T_ARRAY(_,t),d) => n



end

relation element_type : Types.Type => Types.Type =
	
  axiom	element_type(t as Types.T_INTEGER) => t
  axiom	element_type(t as Types.T_REAL) => t
  axiom	element_type(t as Types.T_STRING) => t
  axiom	element_type(t as Types.T_BOOL) => t

  rule	element_type(t) => t'
	---------------------------
	element_type(Types.T_ARRAY(_,t)) => t'

end


(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode.
 **)

(** LS: POW added
 **)
relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  rule	array_type_list(9, Types.T_INTEGER) => intarrtypes &
	array_type_list(9, Types.T_REAL) => realarrtypes &
	
	operator_return(Exp.ADD_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.ADD_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.ADD(Exp.INT),
			[Types.T_INTEGER, Types.T_INTEGER],
			Types.T_INTEGER),
		       (Exp.ADD(Exp.REAL),
			[Types.T_REAL, Types.T_REAL],
			Types.T_REAL),
		       (Exp.ADD(Exp.STRING),
			[Types.T_STRING, Types.T_STRING],
			Types.T_STRING)
		       ] &
	
	list_append(intarrs,realarrs) => arrays &
	list_append(scalars,arrays) => types
	------------------------
	operators Absyn.ADD => types


  rule	array_type_list(9, Types.T_INTEGER) => intarrtypes &
	array_type_list(9, Types.T_REAL) => realarrtypes &
	
	operator_return(Exp.SUB_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.SUB_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.SUB(Exp.INT),
			[Types.T_INTEGER, Types.T_INTEGER],
			Types.T_INTEGER),
		       (Exp.SUB(Exp.REAL),
			[Types.T_REAL, Types.T_REAL],
			Types.T_REAL)		  
		       ] &
	
	list_append(intarrs,realarrs) => arrays &
	list_append(scalars,arrays) => types
	---------------------------
	operators Absyn.SUB => types

  rule	array_type_list(9, Types.T_INTEGER) => intarrtypes &
	array_type_list(9, Types.T_REAL) => realarrtypes &
	n_types(9, Types.T_INTEGER) => inttypes &
	n_types(9, Types.T_REAL) => realtypes &
	
	let int_mul = Exp.MUL(Exp.INT) &
	let real_mul = Exp.MUL(Exp.REAL) &
	let int_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.INT) &
	let real_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.REAL) &
	let int_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.INT) &
	let real_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.REAL) &
	
	let int_scalar = Types.T_INTEGER &
	let int_vector = Types.T_ARRAY(Types.DIM(NONE),int_scalar) &
	let int_matrix = Types.T_ARRAY(Types.DIM(NONE), int_vector) &
	let real_scalar = Types.T_REAL &
	let real_vector = Types.T_ARRAY(Types.DIM(NONE),real_scalar) &
	let real_matrix = Types.T_ARRAY(Types.DIM(NONE), real_vector) &


	let scalars = [
		       (int_mul,[int_scalar, int_scalar], int_scalar),
		       (real_mul,[real_scalar, real_scalar], real_scalar)
		       ] &


	
	let scalarprod = [
			  (int_mul_sp,[int_vector, int_vector],int_scalar),
			  (real_mul_sp,[real_vector,real_vector],real_scalar)
			  ] &
			
	let matrixprod = [
			  (int_mul_mp, [int_vector, int_matrix], int_vector),
			  (int_mul_mp, [int_matrix, int_vector], int_vector),
			  (int_mul_mp, [int_matrix, int_matrix], int_matrix),
			  (real_mul_mp,[real_vector,real_matrix],real_vector),
			  (real_mul_mp,[real_matrix,real_vector],real_vector),
			  (real_mul_mp,[real_matrix, real_matrix],real_matrix)
			  ] &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.INT), 
			inttypes, 
			intarrtypes, 
			intarrtypes) => intscalararrs &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.REAL), 
			realtypes, 
			realarrtypes, 
			realarrtypes) => realscalararrs &
	
	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.INT), 
			intarrtypes, 
			inttypes, 
			intarrtypes) => intarrsscalar &

	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.REAL), 
			realarrtypes, 
			realtypes, 
			realarrtypes) => realarrsscalar &	


	list_append(scalars, intscalararrs) => types1 &
	list_append(types1, realscalararrs) => types2 &
	list_append(types2, intarrsscalar) => types3 &
	list_append(types3, realarrsscalar) => types4 &
	list_append(types4, scalarprod) => types5 &
	list_append(types5, matrixprod) => types6 &
	

	let types = types6
	---------------------------
	operators Absyn.MUL => types

  rule	array_type_list(9, Types.T_REAL) => realarrtypes &
	n_types(9, Types.T_REAL) => realtypes &
	let real_div = Exp.DIV(Exp.REAL) &
	let real_scalar = Types.T_REAL &
	let scalars = [(real_div,[real_scalar, real_scalar], real_scalar)] &

	operator_return(Exp.DIV_ARRAY_SCALAR(Exp.REAL),
			realarrtypes,
			realtypes,
			realarrtypes) => realarrscalar &

	list_append(scalars,realarrscalar) => types
	--------------------------------------------
	operators Absyn.DIV => types

  rule	let real_scalar = Types.T_REAL &
	let int_scalar = Types.T_INTEGER &
	let real_vector = Types.T_ARRAY(Types.DIM(NONE),real_scalar) &
	let real_matrix = Types.T_ARRAY(Types.DIM(NONE), real_vector) &
	let real_pow = Exp.POW(Exp.REAL) &

	let scalars = [(real_pow,[real_scalar, real_scalar], real_scalar)] &

	let arrscalar = [(Exp.POW_ARR(Exp.REAL),
			  [real_matrix,int_scalar],
			  real_matrix)] &
	
	list_append(scalars,arrscalar) => types
	-------------------
	operators Absyn.POW => types

  axiom	operators Absyn.UMINUS
	  => [(Exp.UMINUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UMINUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.UPLUS
	  => [(Exp.UPLUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UPLUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

	(**  Logical operators *)

  axiom	operators Absyn.AND
	  => [(Exp.AND,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.OR
	  => [(Exp.OR,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NOT
	  => [(Exp.NOT,
	       [Types.T_BOOL],
	       Types.T_BOOL)]

	(**  Relational operators *)

  axiom	operators Absyn.LESS
	  => [(Exp.LESS(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESS(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.LESSEQ
	  => [(Exp.LESSEQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESSEQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATER
	  => [(Exp.GREATER(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATER(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATEREQ
	  => [(Exp.GREATEREQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATEREQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.EQUAL
	  => [(Exp.EQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NEQUAL
	  => [(Exp.NEQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]


  rule	Print.print_buf "- operators(" & Dump.op_symbol op => s &
 	Print.print_buf s & Print.print_buf ") failed\n"
	----------------------------
	operators op => fail

end

relation n_dim_array : (int, Types.Type) => Types.Type =

  axiom	n_dim_array (0, t) => t

  rule	int_sub(n,1) => n' &
	n_dim_array (n',t) => t'
	------------------------
	n_dim_array (n, t) => Types.T_ARRAY(Types.DIM(NONE),t')

end
relation n_types : (int, Types.Type) => Types.Type list =

  axiom	n_types (0,_) => []

  rule	int_sub(n,1) => n' &
	n_types(n',t) => l
	-----------------------
	n_types (n, t) => t::l

end

relation operator_return : (Exp.Operator, 
			    Types.Type list, 
			    Types.Type list, 
			    Types.Type list) 
	  =>  (Exp.Operator * Types.Type list * Types.Type) list =

  axiom operator_return (_,[],[],[]) => []

  rule	operator_return (op, lr, rr, rer) => rest &
	let t = (op,[l,r],re)
	---------------------------------------
	operator_return (op, l::lr, r::rr, re::rer) => t::rest

end

relation array_type_list : (int, Types.Type) => Types.Type list =
  
  axiom array_type_list (0,_) => []

  rule	int_sub(n,1) => n' &
	n_dim_array(n,t) => f &
	array_type_list (n', t) => r
	-----------------------------
	array_type_list (n, t) => f::r


end

(** LS: **)
relation get_prop_type: Properties => Types.Type = 

  axiom	get_prop_type PROP(ty,_) => ty
  axiom	get_prop_type PROP_TUPLE(ty,_) => ty

end

(** LS: If PROP_TUPLE, returns true if any of the flags is true **)
relation is_prop_const: Properties => bool =

  axiom	is_prop_const PROP(_,constant) => constant

  rule	is_prop_tuple_const constant => res
	-----------------------------------
	is_prop_const PROP_TUPLE(_,constant) => res

end

(** LS: **)
relation is_prop_tuple_const: Const => bool =

  axiom	is_prop_tuple_const CONST(f) => f

  rule	is_prop_tuple_const first => true
	---------------------------------
	is_prop_tuple_const TUPLE_CONST(first::rest) => true

  rule	is_prop_tuple_const first => false &
	is_prop_tuple_const TUPLE_CONST(rest) => res
	--------------------------------------------
	is_prop_tuple_const TUPLE_CONST(first::rest) => res

end

relation is_prop_array : Properties => bool =

  rule	get_prop_type p => t &
	is_type_array t => b
	----------------------
	is_prop_array p => b

end

relation is_type_array : Types.Type => bool =
	
	axiom is_type_array Types.T_ARRAY(_,_) => true
	axiom is_type_array _ => false

end
