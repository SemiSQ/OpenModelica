(**
 ** file:	 staticexp.rml
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 **
 **)

module StaticExp :

  with "absyn.rml"
  with "exp.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "lookup.rml"

  type Ident = string

  relation elab_exp : (Env.Env,
		       Absyn.Exp)           => (Exp.Exp, Types.Type, bool)
  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Types.Type, bool)
  relation elab_relop : (Absyn.RelOp, Types.Type) => Exp.RelOp
  relation ceval : (Env.Env, Exp.Exp)	  => Values.Value
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()

end

with "dump.rml"

(**
 ** - Expression elaboration
 **)

relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Types.Type, bool) =

  axiom	elab_exp(_, Absyn.INTEGER(x)) => (Exp.ICONST(x), Types.T_INTEGER,true)
  axiom	elab_exp(_, Absyn.REAL(x))    => (Exp.RCONST(x), Types.T_REAL,   true)
  axiom	elab_exp(_, Absyn.STRING(x))  => (Exp.SCONST(x), Types.T_STRING, true)
  axiom	elab_exp(_, Absyn.BOOL(x))    => (Exp.BCONST(x), Types.T_BOOL,   true)

  rule	elab_cref(env, cr) => (exp,t,c)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr)) => (exp,t,c)

  rule	elab_exp (env,e1) => (e1', t1, c1) &
	elab_exp (env,e2) => (e2', t2, c2) &
	print "  binary: " &
 	Exp.print_exp e1' & print " (" & Types.print_type t1 & print ") x " &
 	Exp.print_exp e2' & print " (" & Types.print_type t2 & print ") => " &
	elab_numtypes (e1',t1,e2',t2) => (e1'',e2'',t) &
 	Exp.print_exp e1'' & print " (" & Types.print_type t & print ") x " &
 	Exp.print_exp e2'' & print " (" & Types.print_type t & print ")\n" &
	elab_binary (e1'', t, c1, op, e2'', t, c2) => (e, t', c)
	-------------------------------------------------------
	elab_exp (env,Absyn.BINARY(e1,op,e2)) => (e,t',c)

  rule	elab_exp (env,e1) => (e1', t1, c1) &
	elab_exp (env,e2) => (e2', t2, c2) &
	elab_numtypes (e1',t1,e2',t2) => (e1'',e2'',t) &
	elab_relation (e1'', c1, t, op, e2'', c2) => (e, t', c)
	----------------------------------------------
	elab_exp (env,Absyn.RELATION(e1,op,e2))
	  => (e,t',c)

  rule	elab_call(env,fn,args) => (e,t,c)
	-------------------------------------
	elab_exp (env,Absyn.CALL(fn,args)) => (e,t,c)

  rule	elab_exp (env, start) => (start', Types.T_INTEGER, c_start) &
	elab_exp (env, stop) => (stop', Types.T_INTEGER, c_stop) &
	bool_and (c_start, c_stop) => const &
	ceval (env,start') => Values.INTEGER(startv) &
	ceval (env,stop') => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-----------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(start',NONE,stop'),
	      Types.T_ARRAY(Types.DIM(SOME(n'),Types.NODIM), Types.T_INTEGER),
	      const)

  rule	elab_exp (env, start) => (start', Types.T_INTEGER, c_start) &
	elab_exp (env, step) => (step', Types.T_INTEGER, c_step) &
	elab_exp (env, stop) => (stop', Types.T_INTEGER, c_stop) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	ceval (env,start') => Values.INTEGER(startv) &
	ceval (env,step') => Values.INTEGER(stepv) &
	ceval (env,stop') => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(start',SOME(step'),stop'),
	      Types.T_ARRAY(Types.DIM(SOME(n''),Types.NODIM), Types.T_INTEGER),
	      const)

  rule	elab_array (env, es) => (es', t, const) & list_length es' => l
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(es'),
	      Types.T_ARRAY(Types.DIM(SOME(l),Types.NODIM), t),
	      const)

  rule	print "- elab_exp failed: " & Dump.print_exp e & print "\n"
	---------------------------------------------------------
	elab_exp(_,e) => fail

end

(**)

relation elab_exp_list : (Env.Env, Absyn.Exp list) => (Exp.Exp list, bool) =

  axiom	elab_exp_list (_,[]) => ([],true)

  rule	elab_exp (env,e) => (e',_,c1) &
	elab_exp_list (env,es) => (es',c2) &
	bool_and (c1,c2) => c
	---------------------------------
	elab_exp_list (env,e::es) => (e'::es',c)

end

(**)

relation elab_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Types.Type, bool) =

	(* FIXME: Should we handle empty arrays? *)
  rule	elab_exp (env,e) => (e',t,c)
	-----------------------------
	elab_array (env,[e]) => ([e'],t,c)

  rule	elab_exp (env,e) => (e',t1,c1) &
	elab_array (env,es) => (es',t2,c2) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es) => (e'::es',t1,c)

  rule	elab_exp (env,e) => (e',t1,c1) &
	elab_array (env,es) => (es',t2,c2) &
	not t1 = t2 &
	print "# Incompatible types in array expression\n" &
	print "  " & Dump.print_exp e & print " is of type " &
 	Types.print_type t1 & print "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	print "] are of type " & Types.print_type t2 & print "\n"
	---------------------------------------------------------
	elab_array (env,e::es) => fail

  rule	print "- elab_array failed\n"
	-----------------------------
	elab_array (_,_) => fail

end

(** relation: elab_call
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Types.Type, bool) =

  rule	Absyn.cref_to_path fn => fn' &
	elab_call2 (env,fn',args) => (e,t,c)
	------------------------------------
	elab_call (env,fn,args) => (e,t,c)

  rule	print "# Invalid function name: " &
	Dump.print_component_ref fn & print "\n"
	----------------------------------------
	elab_call (env,fn,args) => fail

end

relation elab_call2 : (Env.Env, Absyn.Path, Absyn.Exp list)
	=> (Exp.Exp, Types.Type, bool) =

  rule	(* FIXME: lookup function *)
	elab_exp_list (env,args) => (args',c)
	-------------------------------------
	elab_call2 (env,fn,args) => (Exp.CALL(fn,args'),
				     Types.T_REAL (*FIXME*),
				     c)

end

(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Types.Type, bool) =

  rule	print "    elab_cref " & Dump.print_component_ref c & print "\n" &
	elab_cref_subs (env,c) => (c', const) &
	print "     subs\n" &
	Lookup.lookup_var (env,c') => (Absyn.ATTR(ad,_,vartype,_),
				       t,
				       binding) &
	print "     looked it up\n" &
	elab_cref2 (env, c', vartype, t, binding) => (exp,const) &
	print "    elab_cref " & Dump.print_component_ref c &
	print " => " & print " (" & Types.print_type t & print ")\n"
	-------------------------
	elab_cref(env, c) => (exp, t, const)

  rule	print "- elab_cref failed\n"
	------------------------------
	elab_cref (_,_) => fail

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef, Absyn.VarType,
		       Types.Type, Env.Binding) => (Exp.Exp,bool) =

	(* FIXME: Check type of expression anyway? *)
  axiom	elab_cref2 (_,cr, Absyn.VAR, _, _) => (Exp.CREF(cr),false)
  axiom	elab_cref2 (_,cr, Absyn.DISCRETE, _, _) => (Exp.CREF(cr),false)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,t, Env.VALBOUND(v)) => (e,true)

  rule	elab_exp (env,exp) => (exp', t', c) &
	c = true (* & *)
	(* t = t' *) (* FIXME: cast *)
	------------------------
	elab_cref2 (env,cr,_,t, Env.EQBOUND(exp)) => (Exp.CREF(cr),true)

  rule	print "# Constant or parameter with a non-constant initializer\n" &
	print "# component: " & Exp.print_component_ref cr & print " = " &
	Dump.print_exp exp & print "\n"
	------------------------------
	elab_cref2 (_,cr, _,_,Env.EQBOUND(exp)) => fail

  rule	print "# Constant or parameter without a value (I think)\n" &
	print "# component: " & Exp.print_component_ref cr & print "\n"
	----------------------------------------------
	elab_cref2 (_,cr, _,_,_) => fail

end	

(**)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(**)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => const
	----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs',const)

end

(**)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.NOSUB, true)

  rule	elab_exp (env,sub1) => (sub1', ty, const) &
	assert_subscript_type (ty, sub1)
	-----------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub1)) => (Exp.SUB1(sub1'), const)

end

relation assert_subscript_type : (Types.Type, Absyn.Exp) => () =

  axiom	assert_subscript_type (Types.T_INTEGER,_)

  axiom	assert_subscript_type (Types.T_ARRAY(_,Types.T_INTEGER),_)

  rule	print "# Subscript is not an integer or integer array\n" &
	print "#  expression: " & Dump.print_exp e & print "\n"
	------------------------------------------------------
	assert_subscript_type (_,e) => fail

end

(** relation: elab_numtypes
 **
 ** Elaborate on the types of numerical expression to unify their
 ** types. If one of them is a real expression and the other an
 ** integer expression, an explicit type promotion to `real' is added
 ** to the second expression.  If either is an array of integers of
 ** reals, it is treated as if it was simply a real or an integer.
 **)

relation elab_numtypes : (Exp.Exp, Types.Type, Exp.Exp, Types.Type)
	  => (Exp.Exp, Exp.Exp, Types.Type) =

  rule	elab_numtypes (e1, t1, e2, t2) => (e1,e2,t)
	(* FIXME: what about the dimensions? *)
	-------------------------------------------
	elab_numtypes (e1, Types.T_ARRAY(dim1,t1), e2, Types.T_ARRAY(dim2,t2))
	  => (e1, e2, t)

  axiom	elab_numtypes (e1, Types.T_INTEGER, e2, Types.T_INTEGER)
	  => (e1, e2, Types.T_INTEGER)

  axiom	elab_numtypes (e1, Types.T_REAL, e2, Types.T_REAL)
	  => (e1, e2, Types.T_REAL)

  axiom	elab_numtypes (e1, Types.T_INTEGER, e2, Types.T_REAL)
	  => (Exp.CAST_TO_REAL(e1), e2, Types.T_REAL)

  axiom	elab_numtypes (e1, Types.T_REAL, e2, Types.T_INTEGER)
	  => (e1, Exp.CAST_TO_REAL(e2), Types.T_REAL)

  axiom	elab_numtypes (e1, Types.T_STRING, e2, Types.T_STRING)
	  => (e1, e2, Types.T_STRING)

  axiom	elab_numtypes (e1, Types.T_BOOL, e2, Types.T_BOOL)
	  => (e1, e2, Types.T_STRING)

  rule	print "- elab_numtypes failed\n" &
	print "  type1 = " & Types.print_type t1 &
	print "  type2 = " & Types.print_type t2 &
	print "\n"
	----------------------------------
	elab_numtypes (_,t1,_,t2) => fail

end

(** relation: elab_binary *)

relation elab_binary : (Exp.Exp, Types.Type, bool,
			Absyn.BinOp,
			Exp.Exp, Types.Type, bool)
	  => (Exp.Exp, Types.Type, bool) =

	(**  ADD *)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_INTEGER,c1,Absyn.ADD,e2,Types.T_INTEGER,c2)
	  => (Exp.BINARY(e1,Exp.INT_ADD,e2), Types.T_INTEGER, c)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_REAL,c1,Absyn.ADD,e2,Types.T_REAL,c2)
	  => (Exp.BINARY(e1,Exp.REAL_ADD,e2), Types.T_REAL, c)

	(**  SUB *)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_INTEGER,c1,Absyn.SUB,e2,Types.T_INTEGER,c2)
	  => (Exp.BINARY(e1,Exp.INT_SUB,e2), Types.T_INTEGER, c)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_REAL,c1,Absyn.SUB,e2,Types.T_REAL,c2)
	  => (Exp.BINARY(e1,Exp.REAL_SUB,e2), Types.T_REAL, c)

	(**  MUL *)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_INTEGER,c1,Absyn.MUL,e2,Types.T_INTEGER,c2)
	  => (Exp.BINARY(e1,Exp.INT_MUL,e2), Types.T_INTEGER, c)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_REAL,c1,Absyn.MUL,e2,Types.T_REAL,c2)
	  => (Exp.BINARY(e1,Exp.REAL_MUL,e2), Types.T_REAL, c)

	(**  DIV
	 **
	 ** Division is always real division. Integers are always
	 ** promoted to reals before the division is made. *)
	
  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_INTEGER,c1,Absyn.DIV,e2,Types.T_INTEGER,c2)
	  => (Exp.BINARY(Exp.CAST_TO_REAL(e1),
			 Exp.REAL_DIV,
			 Exp.CAST_TO_REAL(e2)), Types.T_REAL, c)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,_,c1,Absyn.DIV,e2,_,c2)
	  => (Exp.BINARY(e1,Exp.REAL_DIV,e2), Types.T_REAL, c)

	(**  Failure *)
  rule	print "- elab_binary failed " (* &
	Absyn.dump_exp e1 & print " (" & Types.print_type t1 & print ") o " &
	Absyn.dump_exp e2 & print " (" & Types.print_type t2 *) & print ")\n"
	---------------------------------------------
	elab_binary(e1, t1, c1, op, e2, t2, c2) => fail
			
end

(** relation: elab_relation *)

relation elab_relation : (Exp.Exp, bool,
			  Types.Type, Absyn.RelOp,
			  Exp.Exp, bool)
	  => (Exp.Exp, Types.Type, bool) =

  rule	bool_and (c1,c2) => c &
	elab_relop (op,t) => op'
	---------------------
	elab_relation (e1,c1,t,op,e2,c2)
	  => (Exp.RELATION(e1,op',e2), Types.T_BOOL, c)

	(**  Failure *)
  rule	print "- elab_relation failed\n"
	--------------------------------
	elab_relation(_,_,_,_,_,_) => fail
			
end

(** relation: elab_relop *)

relation elab_relop : (Absyn.RelOp, Types.Type) => Exp.RelOp =

  axiom	elab_relop (Absyn.LESS,      Types.T_INTEGER) => Exp.INT_LESS
  axiom	elab_relop (Absyn.LESS,      Types.T_REAL)    => Exp.REAL_LESS
  axiom	elab_relop (Absyn.LESSEQ,    Types.T_INTEGER) => Exp.INT_LESSEQ
  axiom	elab_relop (Absyn.LESSEQ,    Types.T_REAL)    => Exp.REAL_LESSEQ
  axiom	elab_relop (Absyn.GREATER,   Types.T_INTEGER) => Exp.INT_GREATER
  axiom	elab_relop (Absyn.GREATER,   Types.T_REAL)    => Exp.REAL_GREATER
  axiom	elab_relop (Absyn.GREATEREQ, Types.T_INTEGER) => Exp.INT_GREATEREQ
  axiom	elab_relop (Absyn.GREATEREQ, Types.T_REAL)    => Exp.REAL_GREATEREQ
  axiom	elab_relop (Absyn.EQUAL,     Types.T_INTEGER) => Exp.INT_EQUAL
  axiom	elab_relop (Absyn.EQUAL,     Types.T_REAL)    => Exp.REAL_EQUAL
  axiom	elab_relop (Absyn.EQUAL,     Types.T_BOOL)    => Exp.BOOL_EQUAL
  axiom	elab_relop (Absyn.EQUAL,     Types.T_STRING)  => Exp.STRING_EQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_INTEGER) => Exp.INT_NEQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_REAL)    => Exp.REAL_NEQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_BOOL)    => Exp.BOOL_NEQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_STRING)  => Exp.STRING_NEQUAL

	(* What about arrays and = ? *)

  rule	print "- elab_relop failed\n"
	-----------------------------
	elab_relop (_,_) => fail

end

(**)

relation is_const : Exp.Exp => () =

  axiom	is_const Exp.ICONST(_)
  axiom	is_const Exp.RCONST(_)
  axiom	is_const Exp.SCONST(_)
  axiom	is_const Exp.BCONST(_)

end

(**)

relation ceval : (Env.Env, Exp.Exp) => Values.Value =

  axiom	ceval (_,Exp.ICONST(x)) => Values.INTEGER(x)
  axiom	ceval (_,Exp.RCONST(x)) => Values.REAL(x)
  axiom ceval (_,Exp.SCONST(x)) => Values.STRING(x)
  axiom ceval (_,Exp.BCONST(x)) => Values.BOOL(x)

  rule	ceval_list (env,es) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(es)) => Values.ARRAY(es')

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c)) => v

	(**  Numerical *)

  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.REAL_ADD, rh))
	  => Values.REAL(sum)

  rule	Exp.print_exp(rh) & print "\n" &
	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_add(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.INT_ADD, rh)) => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.REAL_SUB, rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.INT_SUB, rh)) => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.REAL_MUL, rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.INT_MUL, rh))
	  => Values.INTEGER(sum)

	(**)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, NONE, stop)) => Values.ARRAY(arr)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, step) => Values.INTEGER(step') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, SOME(step), stop)) => Values.ARRAY(arr)

  rule	ceval (env,e) => Values.INTEGER(i) &
	int_real i => r
	---------------
	ceval (env, Exp.CAST_TO_REAL(e)) => Values.REAL(r)

  rule	print "- ceval " & Exp.print_exp e & print " failed\n"
	-----------------------------------------------------
	ceval (_,e) => fail
	
end

(** relation: ceval_range
 **
 ** FIXME: Should handle reals too, I guess
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range (start,_,stop) => []

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range (next, step, stop) => l
	-----------------------------------
	ceval_range (start, step, stop) => Values.INTEGER(start)::l

end

(** relation: ceval_list
 **
 ** Do a constant evaluation on a number of expressions, and assert
 ** that they are all of the same type.
 **)

relation ceval_list : (Env.Env, Exp.Exp list) => Values.Value list =
	  
  rule	ceval (env, exp) => v
	----------------------------
	ceval_list (env, [exp]) => [v]

  rule	ceval (env,exp) => v &
	ceval_list (env, exps) => vs
	------------------------------
	ceval_list (env, exp::exps) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

  rule	print "    ceval_cref " & Exp.print_component_ref c & print " => " &
	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,binding) => v &
	Values.print_val v & print "\n"
	-----------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	print "# No constant binding for " &
	Exp.print_component_ref c & print "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Env.Binding) => Values.Value =

  axiom	ceval_cref_binding (env,Env.VALBOUND(v)) => v

  rule	print "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,Env.UNBOUND) => fail
	
  rule	elab_exp (env,exp) => (exp',t,true) &
	ceval (env,exp') => v
	------------------------
	ceval_cref_binding (env,Env.EQBOUND(exp)) => v

  rule	print "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Dump.print_exp exp & print ")\n"
	--------------------------------
	ceval_cref_binding (env,Env.EQBOUND(exp)) => fail
	
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)

  rule	print "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER
  axiom	value_type Values.REAL(x)    => Types.T_REAL
  axiom value_type Values.STRING(x)  => Types.T_STRING
  axiom value_type Values.BOOL(x)    => Types.T_BOOL

  rule	print "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	ceval_subscripts (env,ss) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	ceval_subscripts (env,ss) => ss' &
	canon_cref (env,c) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[]) => []

  rule	ceval_subscript (env,sub) => sub' &
	ceval_subscripts (env,subs) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs) => (sub'::subs')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.NOSUB) => Exp.NOSUB

  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SUB1(e1)) => Exp.SUB1(e1')
	
  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1' &
	ceval (env, e2) => v2 &
	value_exp v2 => e2'
	-----------------------------------------
	ceval_subscript (env, Exp.SUB2(e1,e2)) => Exp.SUB2(e1',e2')
	
  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1' &
	ceval (env, e2) => v2 &
	value_exp v2 => e2' &
	ceval (env, e3) => v3 &
	value_exp v3 => e3'
	-----------------------------------------
	ceval_subscript (env, Exp.SUB3(e1,e2,e3)) => Exp.SUB3(e1',e2',e3')
	
end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.NOSUB,Exp.NOSUB)
 	
 	(* FIXME: A little better, but probably not good *)
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.SUB1(s1),Exp.SUB1(s2))
	
  rule	print "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end
