(**
 ** file:	 static.rml
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 **
 **)

module Static :

  with "absyn.rml"
  with "exp.rml"
  with "explode.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "lookup.rml"

  type Ident = string

  (** - Expression properties *)
  datatype Properties = PROP of Types.Type (* type *)
			      * bool       (* constant *)
  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)

  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties)
  relation elab_cref : (Env.Env, Absyn.ComponentRef) => (Exp.Exp, Properties)

  (* Constant propagation *)
  relation ceval : (Env.Env, Exp.Exp)	  => Values.Value
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef

  (* Property matching (type conversions etc.) *)
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list

  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp

end

with "dump.rml"

(**
 ** - Expression elaboration
 **)

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties) =

  axiom	elab_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), PROP(Types.T_INTEGER,true))
  axiom	elab_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), PROP(Types.T_REAL,   true))
  axiom	elab_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), PROP(Types.T_STRING, true))
  axiom	elab_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), PROP(Types.T_BOOL,   true))

  rule	elab_cref(env, cr) => (exp,prop)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr)) => (exp,prop)

	(**  Binary and unary operations *)

  rule	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	print "  binary: " &
 	Exp.print_exp e1' & print " (" & Types.print_type t1 & print ") * " &
 	Exp.print_exp e2' & print " (" & Types.print_type t2 & print ") => " &
	Exp.print_exp Exp.BINARY(e1'',op',e2'') & print "\n"
	-------------------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),PROP(rtype,c))

  rule	elab_exp (env,e) => (e',PROP(t,c)) &
 	Exp.print_exp e' & print " (" & Types.print_type t & print ") => " &
	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	print "  unary: " &
	Exp.print_exp Exp.UNARY(op',e'') & print "\n"
	---------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),PROP(rtype,c))
	
  rule	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	print "  lbinary: " &
 	Exp.print_exp e1' & print " (" & Types.print_type t1 & print ") * " &
 	Exp.print_exp e2' & print " (" & Types.print_type t2 & print ") => " &
	Exp.print_exp Exp.LBINARY(e1'',op',e2'') & print "\n"
	-------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),PROP(rtype,c))

  rule	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	print "  lunary: " &
	Exp.print_exp Exp.LUNARY(op',e'') & print "\n"
	-----------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),PROP(rtype,c))

  rule	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),PROP(rtype,c))

	(**  Conditional expressions *)

  rule	elab_exp (env,e1) => (e1', prop1) &
	elab_exp (env,e2) => (e2', prop2) &
	elab_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3)) => (e,prop)

	(**  Function calls *)

  rule	elab_call(env,fn,args) => (e,prop)
	-------------------------------------
	elab_exp (env,Absyn.CALL(fn,args)) => (e,prop)

	(**  Array-related expressions *)

  rule	elab_exp (env, start) => (start', PROP(Types.T_INTEGER, c_start)) &
	elab_exp (env, stop) => (stop', PROP(Types.T_INTEGER, c_stop)) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start',NONE,stop',const) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(start',NONE,stop'), PROP(t, const))

  rule	elab_exp (env, start) => (start', PROP(Types.T_INTEGER, c_start)) &
	elab_exp (env, step) => (step', PROP(Types.T_INTEGER, c_step)) &
	elab_exp (env, stop) => (stop', PROP(Types.T_INTEGER, c_stop)) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start',SOME(step'),stop',const) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(start',SOME(step'),stop'), PROP(t, const))

(*
  rule	elab_array (env, es) => (es', PROP(t, const)) & list_length es' => l
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l),Types.NODIM), t),
		   const))
*)
	
  rule	elab_matrix (env, es) => (es', t, dim, const) & list_length es' => l
	--------------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l),
					   Types.DIM(SOME(dim),
						     Types.NODIM)), t),
		   const))

  rule	print "- elab_exp failed: " & Dump.print_exp e & print "\n"
	---------------------------------------------------------
	elab_exp(_,e) => fail

end

(** relation: elab_range_type *)

relation elab_range_type : (Env.Env, Exp.Exp,
			    Exp.Exp option, Exp.Exp, bool) => Types.Type =

  rule	ceval (env,start) => Values.INTEGER(startv) &
	ceval (env,stop) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true)
	  => Types.T_ARRAY(Types.DIM(SOME(n'),Types.NODIM), Types.T_INTEGER)

  rule	ceval (env,start) => Values.INTEGER(startv) &
	ceval (env,step) => Values.INTEGER(stepv) &
	ceval (env,stop) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true)
	  => Types.T_ARRAY(Types.DIM(SOME(n''),Types.NODIM), Types.T_INTEGER)

  axiom	elab_range_type (_,_,_,_,false)
	  => Types.T_ARRAY(Types.DIM(NONE, Types.NODIM), Types.T_INTEGER)

end

(** relation: elab_array *)

relation elab_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties) =

	(* FIXME: Should we handle empty arrays? *)
  rule	elab_exp (env,e) => (e',prop)
	-----------------------------
	elab_array (env,[e]) => ([e'],prop)

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es) => (e'::es',PROP(t1,c))

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	not t1 = t2 &
	print "# Incompatible types in array expression\n" &
	print "  " & Dump.print_exp e & print " is of type " &
 	Types.print_type t1 & print "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	print "] are of type " & Types.print_type t2 & print "\n"
	---------------------------------------------------------
	elab_array (env,e::es) => fail

  rule	print "- elab_array failed\n"
	-----------------------------
	elab_array (_,_) => fail

end

(** relation: elab_matrix *)

relation elab_matrix : (Env.Env, Absyn.Exp list list)
	=> (Exp.Exp list list, Types.Type, int, bool) =

  rule	list_length(el) => dim &
	elab_array(env,el) => (el', PROP(t, c))
	---------------------------------
	elab_matrix(env,[el]) => ([el'], t, dim, c)

  rule	list_length(el) => dim1 &
	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	t1 = t2 & dim1 = dim2 &
	bool_and(c1,c2) => c
	--------------------
	elab_matrix(env,el::els) => (el'::els',t1,dim1,c)

	(**  Error messages *)

  rule	print "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix(_,[]) => fail

  rule	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	print "# Incompatible types in matrix rows\n" &
	print "    [" & Dump.print_list(el,Dump.print_exp,",") &
	print "] is a row of " & Types.print_type t1 & print "\n" &
	print "    the rest of the matrix is of " &
	Types.print_type t2 & print "\n"
	--------------------------------
	elab_matrix(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	print "# Incompatible row length in matrix expression\n" &
	print "    [" & Dump.print_list(el,Dump.print_exp,",") &
	print "] is a row of size " &
	int_string dim1 => s & print s & print "\n" &
	print "    the rest of the matrix rows are of size " &
	int_string dim2 => s & print s & print "\n"
	--------------------------------------------
	elab_matrix(env,el::els) => fail

end

(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

  rule	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args) => (e,prop)
	------------------------------------
	elab_call (env,fn,args) => (e,prop)

  rule	print "- elab_call failed\n"
	----------------------------
	elab_call (env,fn,args) => fail

end

(** relation: elab_call_args
 **
 ** Given the name of a function and a list of expressions to be used
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, Absyn.Path, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

	(* This rule finds user-defined functions. *)

  rule	Lookup.lookup_type(env,fn) => (t as Types.T_COMPLEX(st,vl)) &
	(* ClassInf.valid(st, Absyn.R_FUNCTION) & *)
	function_params(vl) => (in,out as [(_,rt)]) &
	elab_input_args(env, args, in) => (args', c)
	--------------------------------------------
	elab_call_args(env,fn,args) => (Exp.CALL(fn,args'), PROP(rt, c))

	(* This rule finds the built-in functions *)

  rule	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(params,restype)) &
	print "   function " & Dump.print_path fn & print " is " &
	Types.print_type t & print "\n" &
	(* elab_call_args(env,args,params) => (args',c) *)
	elab_input_args(env, args, params) => (args',c)
	-------------------------------------
	elab_call_args (env,fn,args) => (Exp.CALL(fn,args'), PROP(restype, c))


  rule	not Lookup.lookup_type(env,fn) => _ &
	print "# Couldn't find function " & Dump.print_path fn & print "\n"
	-------------------------------------------------------------------
	elab_call_args(env,fn,_) => fail

  rule	print "- elab_call_args failed\n"
	---------------------------------
	elab_call_args(_,_,_) => fail

end

(** relation: function_params
 **
 ** A function definition is just a class definition where all public
 ** components are declared as either `input' or `output'.  This
 ** relation find all those components and separates them into two
 ** separate lists.
 **)

relation function_params : Types.Var list => ((Ident * Types.Type) list,
					      (Ident * Types.Type) list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,SCode.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,SCode.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	print "# Components in functions must be INPUT or OUTPUT\n" &
	print "    component: " & print n & print "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,SCode.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	print "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(** relation: elab_input_args
 **
 ** This relation elaborates on a number of expressions and matches
 ** them to a number of `Types.Var' object, applying type conversions
 ** on the expressions when necessary to match the type of the
 ** `Types.Var'.
 **)

relation elab_input_args : (Env.Env, Absyn.Exp list, (Ident * Types.Type) list)
	  => (Exp.Exp list, bool) =

  axiom	elab_input_args(_, [], []) => ([], true)

  rule	elab_exp(env, e) => (e',PROP(t, c1)) &
	match_type(e', t, vt) => e'' &
	elab_input_args(env, es, vs) => (args', c2) &
	bool_and(c1, c2) => c
	-------------------------------------
	elab_input_args(env, e::es, (_,vt)::vs) => (e''::args', c)

  rule	elab_exp(env, e) => (e',PROP(t,_)) &
	print "# Argument (" & Dump.print_exp e &
 	print ") doesn't match parameter type\n" &
	print "    parameter type: " & Types.print_type vt & print "\n" &
	print "    argument type: " & Types.print_type t & print "\n"
	-------------------------------------------------------------
	elab_input_args(env, e::es, (_,vt)::vs) => fail

end

(**)

(*
relation elab_call_args : (Env.Env, Absyn.Exp list, Types.FuncArg list)
	  => (Exp.Exp list, bool) =

  axiom	elab_call_args (env,[],[]) => ([],true)

  rule	elab_exp (env,arg) => (arg',PROP(t1,c1)) &
	match_type(arg',t1,pt) => arg'' &
	elab_call_args (env,args,params) => (args',c2) &
	bool_and (c1,c2) => c
	---------------------------------
	elab_call_args (env,arg::args,(pn,pt)::params) => (arg''::args',c)

  rule	elab_exp (env,arg) => (arg',PROP(t1,c1)) &
	not match_type(arg',t1,pt) => arg'' &
	print "# Incompatible type of function argument: " &
	Exp.print_exp arg' & print "\n"
	-------------------------------
	elab_call_args (env,arg::args,(pn,pt)::params) => fail

  rule	print "# Too many functiion arguments\n"
	----------------------------------------
	elab_call_args (_,_::_,[]) => fail

  rule	print "# Too few functiion arguments\n"
	----------------------------------------
	elab_call_args (_,[],_::_) => fail

  rule	print "- elab_call_args failed\n"
	---------------------------------
	elab_call_args(_,_,_) => fail

end
*)

(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef) => (Exp.Exp, Properties) =

  rule	print "    elab_cref " & Dump.print_component_ref c & print "\n" &
	elab_cref_subs (env,c) => (c', const) &
	print "     subs\n" &
	Lookup.lookup_var (env,c') => (SCode.ATTR(ad,_,variability,_),
				       t,
				       binding) &
	print "     looked it up\n" &
	elab_cref2 (env, c', variability, t, binding) => (exp,const) &
	subscript_cref_type (exp,t) => t' &
	print "    elab_cref " & Dump.print_component_ref c &
	print " => " & print " (" & Types.print_type t' & print ")\n"
	-------------------------
	elab_cref(env, c) => (exp, PROP(t', const))

  rule	print "- elab_cref failed\n"
	------------------------------
	elab_cref (_,_) => fail

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef, Absyn.Variability,
		       Types.Type, Types.Binding) => (Exp.Exp,bool) =

	(* FIXME: Check type of expression anyway? *)
  axiom	elab_cref2 (_,cr, Absyn.VAR, _, _) => (Exp.CREF(cr),false)
  axiom	elab_cref2 (_,cr, Absyn.DISCRETE, _, _) => (Exp.CREF(cr),false)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,t, Types.VALBOUND(v)) => (e,true)

  axiom	elab_cref2 (env,cr,_,t, Types.EQBOUND(exp,true)) => (Exp.CREF(cr),true)

  rule	print "# Constant or parameter with a non-constant initializer\n" &
	print "# component: " & Exp.print_component_ref cr & print " = " &
	Exp.print_exp exp & print "\n"
	------------------------------
	elab_cref2 (_,cr, _,_,Types.EQBOUND(exp,false)) => fail

  rule	print "# Constant or parameter without a value\n" &
	print "# component: " & Exp.print_component_ref cr & print "\n"
	----------------------------------------------
	elab_cref2 (_,cr, _,_,Types.UNBOUND) => fail

  rule	print "- elab_cref2 failed (component: " &
	Exp.print_component_ref cr & print ")\n"
	----------------------------------------
	elab_cref2 (_,cr, _,_,_) => fail

end	

(** relation: elab_cref_subs
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(**)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => const
	----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs',const)

end

(**)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.NOSUB, true)

  rule	elab_exp (env,sub) => (sub', PROP(ty, const)) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub)) => (sub'', const)

end

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type (Types.T_INTEGER,_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type (Types.T_ARRAY(_,Types.T_INTEGER),_,sub)
	  => Exp.SLICE(sub)

  rule	print "# Subscript is not an integer or integer array\n" &
	print "    expression: " & Dump.print_exp e &
 	print " :: " & Types.print_type t & print "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c), t) => t'

  rule	print "  subscript_cref_type " & Exp.print_exp e & print "\n"
	-------------------------------------------------------------
	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (dim,subs) => Types.NODIM
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs),
			      Types.T_ARRAY(dim,t)) => t

	(* double work *)
  rule	subscript_type (dim,subs) => dim'
	-----------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs),
			      Types.T_ARRAY(dim,t)) => Types.T_ARRAY(dim',t)

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **)

relation subscript_type : (Types.ArrayDim, Exp.Subscript list)
	  => Types.ArrayDim =

  axiom	subscript_type (dim,[]) => dim

  rule	subscript_type (dim, subs) => dim'
	----------------------------------
	subscript_type (Types.DIM(_,dim), Exp.INDEX(_)::subs) => dim'

	(** FIXME: What happens when you slice the first index of a multidimensional array? *)
  rule	subscript_type (dim, subs) => dim'
	----------------------------------
	subscript_type (Types.DIM(x,dim), Exp.SLICE(_)::subs)
	  => Types.DIM(x,dim')

  rule	print "- subscript_type failed\n"
	---------------
	subscript_type (_,_) => fail

end

(** relation: elab_ifexp *)

relation elab_ifexp : (Exp.Exp, Properties,
		       Exp.Exp, Properties,
		       Exp.Exp, Properties)
	  => (Exp.Exp, Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),
		   e3,PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3), PROP(t2, c))

  rule	not t1 = Types.T_BOOL &
	print "# conditional in if expression has to be boolean\n" &
	print "    got type: " & Types.print_type t1 & print "\n" &
	print "    expression: " & Exp.print_exp e1 & print "\n"
	--------------------------------------------------------
	elab_ifexp(e1,PROP(t1,c1),e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	Types.equivtypes(t2,t3) => false &
	print "# Type mismatch in if-expression\n" &
	print "    true branch : " & Exp.print_exp e2 &
 	print " :: " & Types.print_type t2 & print "\n" &
	print "    false branch: " & Exp.print_exp e3 &
 	print " :: " & Types.print_type t3 & print "\n"
	-----------------------------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	print "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_) => fail

end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** FIXME: I don't do this now. I do the simple thing.
 **
 ** FIXME: It this the right criterion? Maybe a simple AND of the constants is enough?
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, bool, bool, bool) => bool =

  axiom	const_ifexp(_,true,true,true) => true
  axiom	const_ifexp(_,_,_,_) => false

end

(**)

relation is_const : Exp.Exp => () =

  axiom	is_const Exp.ICONST(_)
  axiom	is_const Exp.RCONST(_)
  axiom	is_const Exp.SCONST(_)
  axiom	is_const Exp.BCONST(_)

end

(**)

relation ceval : (Env.Env, Exp.Exp) => Values.Value =

  axiom	ceval (_,Exp.ICONST(x)) => Values.INTEGER(x)
  axiom	ceval (_,Exp.RCONST(x)) => Values.REAL(x)
  axiom ceval (_,Exp.SCONST(x)) => Values.STRING(x)
  axiom ceval (_,Exp.BCONST(x)) => Values.BOOL(x)

  rule	ceval_list (env,es) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(es)) => Values.ARRAY(es')

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c)) => v

	(**  Numerical *)

  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh))
	  => Values.REAL(sum)

  rule	Exp.print_exp(rh) & print "\n" &
	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_add(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh)) => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh))
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh))
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env, exp) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp))
	  => Values.REAL(x')

  rule	ceval (env, exp) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp))
	  => Values.INTEGER(x')
	(**)
  rule	ceval (env, exp) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp))
	  => Values.REAL(x')

  rule	ceval (env, exp) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp))
	  => Values.INTEGER(x')

	(**  Logical *)

  rule	ceval (env, lh) => Values.BOOL(lhv) &
	ceval (env, rh) => Values.BOOL(rhv) &
	bool_and(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.AND, rh))
	  => Values.BOOL(x)

  rule	ceval (env, lh) => Values.BOOL(lhv) &
	ceval (env, rh) => Values.BOOL(rhv) &
	bool_or(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.OR, rh))
	  => Values.BOOL(x)

  rule	ceval (env,e) => Values.BOOL(b) &
	bool_not(b) => b'
	-----------------
	ceval (env, Exp.LUNARY(Exp.NOT, e)) => Values.BOOL(b')

	(**  Relations *)

  rule	ceval (env, lhs) => lhs' &
	ceval (env, rhs) => rhs' &
	ceval_relation (lhs',relop,rhs') => v
	-------------------------------------
	ceval (env, Exp.RELATION(lhs,relop,rhs)) => v

	(**)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, NONE, stop)) => Values.ARRAY(arr)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, step) => Values.INTEGER(step') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, SOME(step), stop)) => Values.ARRAY(arr)

  rule	ceval (env,e) => Values.INTEGER(i) &
	int_real i => r
	---------------
	ceval (env, Exp.CAST(Exp.REAL,e)) => Values.REAL(r)

  rule	print "- ceval " & Exp.print_exp e & print " failed\n"
	-----------------------------------------------------
	ceval (_,e) => fail
	
end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	-----------------------------------------
	ceval_relation (v1, Exp.GREATER(t), v2) => v

	(**  Integers *)

  rule	int_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.LESS(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.EQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.NEQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

	(**  Reals *)

  rule	real_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.LESS(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.EQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.NEQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	print "- ceval_relation failed\n"
	---------------------------------
	ceval_relation (_,_,_) => fail

end

(** relation: ceval_range
 **
 ** FIXME: Should handle reals too, I guess
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range (start,_,stop) => []

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range (next, step, stop) => l
	-----------------------------------
	ceval_range (start, step, stop) => Values.INTEGER(start)::l

end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

relation ceval_list : (Env.Env, Exp.Exp list) => Values.Value list =
	  
  rule	ceval (env, exp) => v
	----------------------------
	ceval_list (env, [exp]) => [v]

  rule	ceval (env,exp) => v &
	ceval_list (env, exps) => vs
	------------------------------
	ceval_list (env, exp::exps) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

  rule	print "    ceval_cref " & Exp.print_component_ref c & print " => " &
	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,binding) => v &
	Values.print_val v & print "\n"
	-----------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	print "# No constant binding for " &
	Exp.print_component_ref c & print "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Types.Binding) => Values.Value =

  axiom	ceval_cref_binding (env,Types.VALBOUND(v)) => v

  rule	print "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,Types.UNBOUND) => fail
	
  rule	ceval (env,exp) => v
	------------------------
	ceval_cref_binding (env,Types.EQBOUND(exp,true)) => v

  rule	print "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Exp.print_exp exp & print ")\n"
	--------------------------------
	ceval_cref_binding (env,Types.EQBOUND(exp,false)) => fail
	
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)

  rule	print "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER
  axiom	value_type Values.REAL(x)    => Types.T_REAL
  axiom value_type Values.STRING(x)  => Types.T_STRING
  axiom value_type Values.BOOL(x)    => Types.T_BOOL

  rule	print "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	ceval_subscripts (env,ss) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	ceval_subscripts (env,ss) => ss' &
	canon_cref (env,c) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[]) => []

  rule	ceval_subscript (env,sub) => sub' &
	ceval_subscripts (env,subs) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs) => (sub'::subs')

end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.NOSUB) => Exp.NOSUB

  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1)) => Exp.INDEX(e1')
	
  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1)) => Exp.SLICE(e1')
	
end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.NOSUB,Exp.NOSUB)
 	
 	(* FIXME: A little better, but probably not good *)
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
	
  rule	print "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 ** FIXME: Better motivation
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> Exp.Exp list =

  axiom	elab_arglist ([],[]) => []

  rule	match_type(arg, atype, pt) => arg' &
	elab_arglist (pts, args) => args'
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => arg'::args'

end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 ** FIXME: This could check the variability also, but it might need to
 different things in different places.
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	match_type(e, gt, et) => e'
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

end

(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Types.Type, Types.Type) => Exp.Exp =

  rule	Types.subtype(e_type, expected_type) => true
	--------------------------------------------
	match_type(e, e_type, expected_type) => e

  rule	Types.subtype(e_type, expected_type) => false &
	type_convert(e, e_type, expected_type) => e'
	--------------------------------------------
	match_type(e, e_type, expected_type) => e'

end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Types.Type, Types.Type) => Exp.Exp =

  axiom	type_convert(e, Types.T_INTEGER, Types.T_REAL) => Exp.CAST(Exp.REAL,e)

end

(** relation: deoverlooad
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	elab_arglist (params, args) => args'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype)

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	print "# Can't resolve type of expression: " &
	Dump.print_exp exp & print "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode.
 **)

relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  axiom	operators Absyn.ADD
	  => [(Exp.ADD(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.ADD(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL),
	      (Exp.ADD(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_STRING)]

  axiom	operators Absyn.SUB
	  => [(Exp.SUB(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.SUB(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.MUL
	  => [(Exp.MUL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.MUL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.DIV
	  => [(Exp.DIV(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.UMINUS
	  => [(Exp.UMINUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UMINUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.UPLUS
	  => [(Exp.UPLUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UPLUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

	(**  Logical operators *)

  axiom	operators Absyn.AND
	  => [(Exp.AND,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.OR
	  => [(Exp.OR,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NOT
	  => [(Exp.NOT,
	       [Types.T_BOOL],
	       Types.T_BOOL)]

	(**  Relational operators *)

  axiom	operators Absyn.LESS
	  => [(Exp.LESS(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESS(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.LESSEQ
	  => [(Exp.LESSEQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESSEQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATER
	  => [(Exp.GREATER(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATER(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATEREQ
	  => [(Exp.GREATEREQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATEREQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.EQUAL
	  => [(Exp.EQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NEQUAL
	  => [(Exp.NEQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]


  rule	print "- operators(" & Dump.op_symbol op => s &
 	print s & print ") failed\n"
	----------------------------
	operators op => fail

end
