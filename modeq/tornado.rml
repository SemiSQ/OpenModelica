(* 
 Copyright MathCore Engineering 2004-10-21
 This source is non-free and should not be included in OpenModelica
 *)

(**
 **
 ** file:	 tornado.rml
 ** module:		 Tornado
 ** description: Code generation of Nodelica models including equation
 ** code and symbolic information to the Tornado-1 format.
 ** Part of the Hemmis project at MathCore Engineering AB.
 **
 ** RCS: $Id$
 ** 
 **)
 module Tornado:
  
  with "dae.rml"
with "absyn.rml"

(* Generates code according to the Tornado-1 format *)
  relation generate_code: (Absyn.Program, DAE.DAElist, Absyn.Path) => ()
	      
	      
	      
  end
with "interactive.rml"
with "util.rml"
with "system.rml"
with "daelow.rml"
with "exp.rml"
with "debug.rml"
with "rtopts.rml"
with "inst.rml"
with "values.rml"
with "tornadoext.rml"
with "explode.rml"
with "lookup.rml"
with "env.rml"
with "simcodegen.rml"
with "dump.rml"
with "tornadocodegen.rml"

(** relation: generate_code
 ** This is the main relation that generates Tornado1 C++ code from the flat Modelica model
 ** It will generate two files <modelname>.cpp and <modelname>.hpp, the implementation file and 
 ** the header file. Those will currently be put in the current directory.
 ** The implementation uses the DAELow module to lower the flat modelica model such that it
 ** can be BLT sorted and indexed, etc.
 **)

 relation generate_code:	 (Absyn.Program, DAE.DAElist, Absyn.Path) => () =
	     
  rule  DAELow.lower(dae) => dae' &
         generate_blt(dae') => (dae'',blt,ass1,ass2,m,mt) &
         
         (*          print "translating dae.\n" & *)
         (* 	     DAELow.translate_dae (dae'') => indexed_dae & *)
         
         (* 	     DAELow.calculate_values(indexed_dae) => dae''' & *)
	     DAELow.calculate_values(dae'') => dae''' &
	     Absyn.path_string(class) => cname &
         add_dae_var_to_index_map(dae''') &
         add_dummy_der_to_top_model(dae''',cname) &
         save_hierarhical_info(class,dae''',p)  &
	     TornadoCodeGen.generate_header(cname) => header &
	     generate_impl_header(cname) => implheader &
	     generate_constructor(cname,p,dae''') => constr &
	     TornadoCodeGen.generate_var_defines(dae''') => defines &
	     generate_compute_methods(cname,dae''',p,blt,ass1,ass2,m,mt) => cmethods &
         TornadoCodeGen.generate_dll_code(cname) => dll_code &
         TORNADOEXT.get_hierachical_code(cname) => (hierachical_header_code,hierachical_code) &
         Debug.fcall("bltdump", DAELow.dump,dae''') &
         Debug.fcall0("bltdump", TORNADOEXT.dump_testing) &
         Util.string_append_list([implheader,hierachical_code,constr,defines,cmethods]) => impl &
         Util.string_append_list([header,hierachical_header_code,"#endif\n"]) => header' &
	     string_append(cname,".h") => headerfile &
	     string_append(cname,".cpp") => implfile &
	     string_append(cname,"DLL.cpp") => dllfile &
	     print "Generating: " & print headerfile & print "\n" &
	     System.write_file(headerfile,header') &
	     print "Generating: " & print implfile & print "\n" &
	     System.write_file(implfile,impl) &
	     print "Generating: " & print dllfile & print "\n" &
	     System.write_file(dllfile,dll_code) 
	     -------------------------------------------------------------------
	     generate_code(p,dae,class) => 
         
  rule	print "generate_code failed\n" 
	     ------------------------------
	     generate_code(_,_,_) => fail
 end

 relation save_hierarhical_info: (Absyn.Path,DAELow.DAELow,Absyn.Program)
         => () =

  rule  SCode.elaborate(program) => p' &
 	     Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
         Absyn.path_string(class_path) => str &
         (*         TORNADOEXT.set_top_model(str) & *)
         generate_code_from_class(class_path,dae,p',program,env)
         
         (*         list_length(elements) => tmp_int & int_string(tmp_int) => tmp_int_str &  *)
         (*         print "LIST LENGTH: " & print tmp_int_str  *)
         (*Util.string_delimit_list(class_,"\n") => str & *)
         
         (*& Util.string_append_list(comp_name_list) => str_res &
          print "COMPONENTS " & print str_res & print "\n" *)
         --------------------------------------
         save_hierarhical_info(class_path,dae,program)
         
 end
(*         Interactive.get_component_name_and_type_and_comment(elements)   *)

 relation generate_code_from_class:(Absyn.Path,DAELow.DAELow,
                                    SCode.Program,Absyn.Program,Env.Env) =>()   =
           
  rule  Interactive.get_pathed_class_in_program(class_path,a_program) => cdef & 
         Lookup.lookup_class(env,class_path,false) => (class,env') &
         
         Interactive.get_components_in_class(cdef) => elements &
         Absyn.path_string(class_path) => str &
         (*                   print "\n--------------------------------\n" & print str & print ":\n" &  *)
         generate_code_from_elements(class_path,elements,dae,program,a_program,env')
         --------------------------------------
         generate_code_from_class(class_path,dae,program,a_program,env) 
         
  rule  Absyn.path_string(class_path) => str &
         Interactive.is_primitive(Absyn.CREF_IDENT(str,[]),a_program) => true 
         (*          &        print "\n-----------PRIMITIVE--------------\n" & print str & print ":\n"  *)
         --------------------------------------
         generate_code_from_class(class_path,dae,program,a_program,env) 
         
  rule  Absyn.path_string(class_path) => str 
         (*          &       print "\n-----------NO MATCH--------------\n" & print str & print ":\n"  *)
         --------------------------------------
         generate_code_from_class(class_path,dae,program,a_program,env) 
         
         
         
 end

 relation generate_code_from_elements:(Absyn.Path,Absyn.Element list,  DAELow.DAELow,
                                       SCode.Program,Absyn.Program, Env.Env) 
          => () = 
           
  axiom generate_code_from_elements(_,[],_,_,_,_) 
         
         
  rule  Lookup.lookup_class(env,p,true) => (c,env') &
	     Env.get_env_path(env') => SOME(envpath) &
	     Absyn.path_last_ident(p) => tpname &
         Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	     Absyn.path_string(p') => typename &
         
         Interactive.get_componentitems_name(lst) => str_lst &
         Util.string_append_list(str_lst) => tml_str &
         
(*          print "TYPE: " & print typename & print " " & print tml_str & print "\n"  &  *)
         generate_code_from_elements(class_path,rest,dae,program,a_program,env') &
         generate_code_from_class(p,dae,program,a_program,env') & 
         get_componentitems_name(lst,dae) => name_list &
         add_variable_to_list(class_path,p,name_list,dae,program,a_program,env') 
         (* 	    get_componentitems_name(lst,dae) => names & *)
         (* 	    prefix_typename(typename,names) => lst *)
	     -------------------------------------------
	     generate_code_from_elements(class_path,
                                     Absyn.ELEMENT(_,_,_,_,
                                                   Absyn.COMPONENTS(_,p,lst),_,_,_)::rest,
                                     dae,
                                     program,a_program,
                                     env) 
         
         
  rule  Absyn.path_string(p) => typename &
         
         get_componentitems_name(lst,dae) => str_lst &
         Util.string_append_list(str_lst) => tml_str &
         
(*          print "bape: " & print typename & print " " & print tml_str & print "\n"  &  *)
         generate_code_from_elements(class_path,rest,dae,program,a_program,env)  &
         generate_code_from_class(p,dae,program,a_program,env) &
         get_componentitems_name(lst,dae) => name_list &
         add_variable_to_list(class_path,p,name_list,dae,program,a_program,env) 
         
         (* 	    get_componentitems_name(lst) => names & *)
         (* 	    prefix_typename(typename,names) => lst *)
         -------------------------------------------
         generate_code_from_elements(class_path,
                                     Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,p,lst),_,_,_)::rest,
                                     dae,
                                     program,a_program,
                                     env) 
         
  rule  (* print "lalalalalalalalalala"  *)
         ------------------------------------------
	     generate_code_from_elements(class_path,_,dae,program,a_program,env) 
         
  rule  print "generate_code_from_elements failed\n"
	     -------------------------------------------
	     generate_code_from_elements(_,_,_,_,_,_) => fail
         
         
 end


(** relation_get_componentitems_name
 ** This relation takes a `ComponentItems' list and returns a  list of all
 ** component names (if any).
 ** it also checks for components with array-subscrips and generates the 
 ** component-names: a[1],a[2] 
 **)
 relation get_componentitems_name: (Absyn.ComponentItem list,DAELow.DAELow) => string list =
	     
  rule  (* .. otherwise if no dimensions *)
	     get_componentitems_name(rest,dae) => lst 
	     ----------------------------
	     get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,[],_),
                                                     _)::rest,
                                 dae) 
          => c1::lst
   rule	(* When component has array dimensions *)
	     get_componentitems_name(rest,dae) => lst &
         generate_components_name_with_subscripts(c1,dae) => comps_name_w_subs &
         list_append(lst,comps_name_w_subs) => res 
	     ----------------------------
	     get_componentitems_name(Absyn.COMPONENTITEM((comp as Absyn.COMPONENT(c1,subs,_)),
                                                     _)::rest,
                                 dae)
          => res
	       
           
  rule	get_componentitems_name(rest,dae) => res
	     ------------------------------------
	     get_componentitems_name(_::rest,dae) => res
         
  axiom	get_componentitems_name([],dae) => []
 end

(**
 ** this searches the dae-vars for all the components of the form a[<number>] 
 ** to generate the correct names.
 **)
relation generate_components_name_with_subscripts: (string,DAELow.DAELow) => string list =

  rule  generate_components_name_with_subscripts2(cr,0,vars,knvars) => res

        --------------------------------------
        generate_components_name_with_subscripts(cr,
                                                 DAELow.DAELOW(vars, 
                                                               knvars,
                                                               _,_,_,_)) 
          => res

        (*         DAELow.get_var(cr,knvars) => (var1 as DAELow.VAR(_,_,_,_,_,_,_,_,_,_,class_path),_) & *)
        (*         DAELow.get_var(cr2,vars) => (var2 as DAELow.VAR(_,_,_,_,_,_,_,_,_,_,class_path),_) & *)

(*         generate_constructor_inputvars2(all_vars,0) => (lst,no_of_vars) & *)
(*         no_of_vars = 0 *)
        
(*         ------------------------------------------- *)
(*         generate_constructor_inputvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_), *)
(*                                                      DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) =>  *)
(*         ("","") *)

end

relation generate_components_name_with_subscripts2:(string,
                                                   int,
                                                   DAELow.Variables,
					                               DAELow.Variables) => string list =

  rule  int_add(index,1) => index_inc &
        int_string(index_inc) => index_str &
        Util.string_append_list([cr,"[",index_str,"]"]) => cr_w_index &
        DAELow.exists_var(Exp.CREF_IDENT(cr_w_index,[]),vars) => true &
        generate_components_name_with_subscripts2(cr,index_inc,vars,knvars) => res
        -------------------------------------------
        generate_components_name_with_subscripts2(cr,index,vars,knvars) => cr_w_index::res
 
  rule  int_add(index,1) => index_inc &
        int_string(index_inc) => index_str &
        Util.string_append_list([cr,"[",index_str,"]"]) => cr_w_index &
        DAELow.exists_var(Exp.CREF_IDENT(cr_w_index,[]),knvars) => true &
        generate_components_name_with_subscripts2(cr,index_inc,vars,knvars) => res
        -------------------------------------------
        generate_components_name_with_subscripts2(cr,index,vars,knvars) => cr_w_index::res

  rule  -------------------------------------------
        generate_components_name_with_subscripts2(cr,index,vars,knvars) => []


end

(**
 ** arg1 the name for the top class
 ** arg2 the name for the class of type
 ** arg3 the names of variables - this is a list because of the possibility of 
 **      writing Real x,y,z;
 **)
 relation add_variable_to_list:(Absyn.Path,Absyn.Path,string list,DAELow.DAELow,
                                SCode.Program,Absyn.Program,Env.Env) 
          => () =

  axiom add_variable_to_list(_,_,[],_,_,_,_) => ()
         
  rule  Interactive.get_pathed_class_in_program(variable_class_path,a_program) => 
         (cdef as Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(_,_,_,_,_))) &
         Absyn.path_string(variable_class_path) => str &
         Absyn.path_string(class_path) => str' &
         get_direction_for_variable(variable_name,str',dae) => (var_type,direction,unit,default_value,lower_bound,upper_bound,Desc) &
         TORNADOEXT.add_variable_to_class(str',variable_name,var_type,direction,unit,default_value,lower_bound,upper_bound,Desc) &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) 
         (*                  & print str' & print "\nA-----------derived-------------\n" *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,
                              variable_name::rest,
                              dae,program,a_program,env) => ()
         
  rule  (* Interactive.get_pathed_class_in_program(variable_class_path,a_program) => cdef & *)
         Absyn.path_string(variable_class_path) => str &
         Interactive.is_primitive(Absyn.CREF_IDENT(str,[]),a_program) => true & 
         Absyn.path_string(class_path) => str' &
         get_direction_for_variable(variable_name,str',dae) => (var_type,direction,unit,default_value,lower_bound,upper_bound,Desc) &
         TORNADOEXT.add_variable_to_class(str',variable_name,var_type,direction,unit,default_value,lower_bound,upper_bound,Desc) &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) 
         (*                    & print variable_name & print " " & print str'  & print "\nA-----------PRIMITIVE--------------\n" *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,
                              variable_name::rest,
                              dae,program,a_program,env) => ()

  rule  Interactive.get_pathed_class_in_program(variable_class_path,a_program) => cdef & 
         Lookup.lookup_class(env,variable_class_path,false) => (class,env') &
         Absyn.path_string(class_path) => str' &
         Absyn.path_string(variable_class_path) => var_str' &
         
         
         Absyn.path_string(variable_class_path) => str &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) &
         TORNADOEXT.add_variable_to_class(str',variable_name,"class",var_str',"","","","","") 
         (*                   & print str' & print "\nA--------------------------------\n" *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,

                              variable_name::rest,
                              dae,program,a_program,env) => ()
         
         
         
  rule  Absyn.path_string(variable_class_path) => str &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) 
         (*                   & print str &  print "\nA-----------NO MATCH--------------\n" *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,
                              variable_name::rest,
                              dae,program,a_program,env) => ()
         
         
         
 end



(**
 ** arg1 name of the variable
 ** arg2 name of the class where the variable is
 ** arg2 the DAELow.DAELow that contains all the varialbles
 ** 
 ** ret1 type
 ** ret2 direction
 **
 ** ret3 Unit;                // Unit of quantity
 ** ret4 DefaultValue;        // Default value (in Modelica lingo this is "start" I think)
 ** ret5 LowerBound;          // Lower bound
 ** ret6 UpperBound;          // Upper bound
 ** ret7 Desc;                // Description
 **)

 relation get_direction_for_variable:(string, string,DAELow.DAELow) 
          => (string,string,
              string,string,string,string,string) =  
         
         (*     rule  print "-get_direction_for_variable: " & print name *)
         (*          & print " in class " & print class_name  & print "\n" & *)
         (*          int_eq(1,0) => true *)
         (*          --------------------------------- *)
         (*         get_direction_for_variable(name,class_name,dae) => fail *)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc) &
         TornadoCodeGen.get_start_value(start) => default_value' 
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("variable","output",
                                                             unit,default_value',lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.VARIABLE,DAE.BIDIR,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc) &
         TornadoCodeGen.get_start_value(start) => default_value' 
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("variable","bidir",
                                                             unit,default_value',lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc) &
         TornadoCodeGen.get_start_value(start) => default_value'
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("variable","input",
                                                             unit,default_value',lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.PARAM,_,_,_,SOME(value),_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc)
         & Values.val_string value => val_str
         (*            & print "with value_: "  & print val_str & print "\n"  *)
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("parameter","",
                                                             unit,val_str,lower_bound,upper_bound,Desc)

  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.PARAM,_,_,_,_,_,start,_,_,_))&
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc)
         (*            & print "without value\n"  *)
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("parameter","",
                                                             unit,default_value,lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.CONST,_,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc)
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("parameter","",
                                                             unit,default_value,lower_bound,upper_bound,Desc)

  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc)
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("dummy_der","",
                                                             unit,default_value,lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc)
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("dummy_state","",
                                                             unit,default_value,lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc) &
         TornadoCodeGen.get_start_value(start) => default_value'
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("state","",
                                                             unit,default_value',lower_bound,upper_bound,Desc)
  rule  find_dae_var(name,class_name,dae)
          => (var as DAELow.VAR(cr,DAELow.DUMMY_STATE,_,_,_,_,_,start,_,_,_)) &
           TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc) &
         TornadoCodeGen.get_start_value(start) => default_value'
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("state","",
                                                             unit,default_value',lower_bound,upper_bound,Desc)
         
  rule  find_dae_var(name,class_name,dae)
          => var & DAELow.dump_vars([var]) &
           print "unknown type and direction on variable\n" &
         TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc)
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("<unknown>","<unknown>",
                                                             unit,default_value,lower_bound,upper_bound,Desc)
         
  rule  print "-get_direction_for_variable failed: " & print name  
         & print " in class " & print class_name  & print "\n" 
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => fail
         
           end

(** relation find_dae_var
 ** arg1 name of the variable
 ** arg2 name of the class where the variable is
 ** arg2 the DAELow.DAELow that contains all the varialbles
 **)
            
relation find_dae_var:(string, string,DAELow.DAELow) => DAELow.Var =  
        
  rule DAELow.vararray_list(vararr) => vars &
        DAELow.vararray_list(knvararr) => knvars &
        list_append(vars,knvars) => allvars &
        find_dae_var2(name,class_name,allvars) => var 
        --------------------------------------
        find_dae_var(name,
                     class_name,
                     DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                   DAELow.VARIABLES(_,knvararr,_,_),
                                   eqn,seqn,_,_))
          => var
          
  rule   print "find_dae_var failed\n " 
        --------------------------------------
        find_dae_var(_,_,_) => fail
        
end


relation find_dae_var2:(string,string,DAELow.Var list) => DAELow.Var =

        
  rule  print "no such variable\n "
        -------------------------------------
        find_dae_var2(name,class_name,[]) => fail


  rule  Exp.cref_str(cr) => cr_str &
        (* pick out the last of the names "a" in the name Temp3.a *)
        Util.string_split_at_char(cr_str,#".") => str_list &
        Util.list_last(str_list) => var_name &
	    list_reverse(class_paths) => from_class::_ &
        Absyn.path_string(from_class) => from_class_str &
        Util.string_equal(class_name,from_class_str) => true &
        Util.string_equal(var_name,name) => true 
        
        (*                  & print var_name & print " = " & print name & print " " & *)
        (*                 print from_class_str & print " = " & print class_name & print "\n" *)
        -------------------------------------
        find_dae_var2(name,
                      class_name,
                      (var as DAELow.VAR(cr,_,_,_,_,_,_,start,_,org_name,class_paths))::rest) 
          => var
          
  rule  find_dae_var2(name,class_name,rest) => var 
        -------------------------------------
        find_dae_var2(name,
                      class_name,
                      DAELow.VAR(cr,_,_,_,_,_,_,start,_,org_name,from_class)::rest) 
          => var
          
end



(** relation generate_impl_header
 ** generate the "header" of the implementation file, i.e. includes, ifdefs etc. 
 ** It is NOT the generation of the headerfile. (That is in the relation generate_header above)
 *)
 relation generate_impl_header: string => string =

  rule	Util.string_append_list(["#ifdef _MSC_VER\n",
				                 "#pragma warning(disable:4250)\n",
				                 "#pragma warning(disable:4786)\n",
				                 "#endif\n",
				                 "\n",
				                 "#include \"",cname,".h\"\n",
				                 "\n",
				                 "#include <math.h>\n",
				                 "#include <assert.h>\n",
				                 "\n",
				                 "using namespace Common;\n",
				                 "using namespace Tornado;\n",
				                 "\n"]) => implheader
	     ----------------------
	     generate_impl_header(cname) => implheader
	     
  rule	print "-generate_impl_header failed\n" 
	     -------------------
	     generate_impl_header(_) => fail
 end


(** relation generate_constructor:
 ** Generates the implementation for the constructor which sets up the variables (names)
 ** and their initial values.
 **)
 relation generate_constructor: (string, Absyn.Program, DAELow.DAELow) => string =
	     
	     
  rule	generate_constructor_component_initialization(cname,p) => (initializationvars) &
         TornadoCodeGen.generate_constructor_outputvars(dae) => (outputvars,noOutputVar_str) &
         TornadoCodeGen.generate_constructor_inputvars(dae) => (inputvars,noInputVar_str) &
         TornadoCodeGen.generate_constructor_algvars(dae) => (algvars) &
	     TornadoCodeGen.generate_constructor_statevars(dae) => (statevars) &
         TornadoCodeGen.generate_constructor_parameters(dae) => (parameters) &
         TornadoCodeGen.generate_links(dae,cname) => (links) &
         
         generate_no_of_strings("","parameter",cname,"  SetNoParams") => no_param_var_str &

         generate_no_of_values_strings("AlgStateVarValues") => no_alg_values_str &
         generate_no_of_values_strings("ParamValues") => no_param_values_str &
         generate_no_of_values_strings("DerStateVarValues") => no_of_der_state_values_str &
         
         Util.string_append_list(["C",cname,"::\n",
				                  "C",cname,"(const wchar_t* Name)\n",
				                  "{\n",
				                  "  SetName(Name);\n",
				                  "  SetDesc(L\"",cname," test.\");\n",
				                  "\n",
                                  "  CDummy m_Dummy;\n\n",
                                  no_param_var_str,
                                  "\n",
				                  parameters,
				                  "\n",
				                  "  SetNoIndepVars(1);\n",
				                  "  SetIndepVar(0, new CIndepVar(L\"time\",L\"s\"));\n",
				                  "\n",
				                  outputvars,
				                  "\n",
				                  inputvars,
				                  "\n",
				                  statevars,
				                  "\n",
                                  algvars,
                                  "\n",
				                  "  SetNoIndepVarValues(1);\n",
                                  noOutputVar_str,
                                  noInputVar_str,
                                  no_alg_values_str,
                                  no_param_values_str,
                                  no_of_der_state_values_str,
				                  "\n",
				                  initializationvars,
				                  "\n",
                                  "  this->GetIndepVar(0)->LinkValue(this, MSLE_INDEP_VAR, 0);\n", 
                                  "\n",
                                  links,
                                  "\n",
                                  "  Reset();\n",
		                          "}\n",
				                  "\n"]) => constr
	     -----------------------------------------
	     generate_constructor(cname,p,dae) => constr
         
         
  rule	print "-generate_constructor failed\n" 
	     -------------------------------------
	     generate_constructor(_,_,_) => fail
         
 end

(**
 ** generates the strings for "SetNo<...>VarValues(<int>)"
 **)
 relation generate_no_of_values_strings:(string) => string =
	     
  rule  TORNADOEXT.get_no_of_vars_with_type(name) => no_of_values &
         no_of_values = 0
         -------------------------------------
         generate_no_of_values_strings(name) => ""
	     
  rule  TORNADOEXT.get_no_of_vars_with_type(name) => no_of_values &
         int_string(no_of_values) => values &
         Util.string_append_list(["  SetNo",name,"(",values,");\n"]) => res
         -------------------------------------
         generate_no_of_values_strings(name) => res
	     
         
 end
(**
 ** generates the strings for "SetNo<...>Var(<int>)"
 **)
 relation generate_no_of_strings:(string,string,string,string) => string =
	     
  rule  TORNADOEXT.get_no_of_vars_with_dir_and_type_from_class(dir,var_type,name) => no_of_values &
         no_of_values = 0
         -------------------------------------
         generate_no_of_strings(dir,var_type,name,call) => ""
	     
  rule  TORNADOEXT.get_no_of_vars_with_dir_and_type_from_class(dir,var_type,name) => no_of_values &
         int_string(no_of_values) => values &
         Util.string_append_list([call,"(",values,");\n"]) => res
         -------------------------------------
         generate_no_of_strings(dir,var_type,name,call) => res
	     
         
 end

(**
 ** 
 **)
 relation add_dummy_der_to_top_model:(DAELow.DAELow,string) => () = 
         
         
  rule	DAELow.vararray_list(vararr) => varlst &
         DAELow.vararray_list(knvararr) => knvarlst &
 	     Util.list_select(knvarlst,DAELow.is_param) => knvarlst' & 
         list_append(knvarlst',varlst) => all_vars &
         add_dummy_der_to_top_model2(all_vars,top_class_name)
	     
	     -------------------------------------------
         add_dummy_der_to_top_model(DAELow.DAELOW(vars as DAELow.VARIABLES(_,vararr,_,_),
                                                  vars2 as DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_),
                                    top_class_name) 
          => ()        
	       
  axiom add_dummy_der_to_top_model(_,_) => fail
 end

(** 
 ** This relation update the index in the map in TORNADOEXT
 ** algebraic variable links.
 ** ARG1 the daelow.var list
 ** this is for #define-index
 ** DO NOT CHANGE THE STRING FOR THE DIFFERENT TYPES BECAUSE THERE ARE USED IN generate_no_of_values_strings
 **)
 relation add_dummy_der_to_top_model2:(DAELow.Var list,string) => () = 
	     
  axiom	add_dummy_der_to_top_model2([],_) => ()
         
         (*   rule print "IN add_dummy_der_to_top_model2\n"& *)
         (*          int_eq(1,0) => true *)
         (*          ------------------------------ *)
         (*          add_dummy_der_to_top_model2(_,_,_,_) => ([],[],0) *)

         
  rule  (* there should be no split because of there will be an error if top-class has a *)
         (* var with same name *)
         Exp.cref_str(cr) => cr_str &
         
         
         TornadoCodeGen.get_default_values() => (unit,default_value,lower_bound,upper_bound,Desc) &
         TORNADOEXT.add_variable_to_class(top_class_name,cr_str,"dummy_der","",unit,default_value,lower_bound,upper_bound,Desc) &


         add_dummy_der_to_top_model2(rest,top_class_name) 
         ---------------------------------------------
         add_dummy_der_to_top_model2(DAELow.VAR(cr,(kind as DAELow.DUMMY_DER),dir,_,_,_,_,start,_,_,class_paths)::rest,
                                     top_class_name)
         
  rule  add_dummy_der_to_top_model2(rest,top_class_name) =>
         -----------------------------------------------
         add_dummy_der_to_top_model2(_::rest,top_class_name)
	     
  rule  print "-add_dummy_der_to_top_model2 failed\n" 
         ----------------------
         add_dummy_der_to_top_model2(_,_) => fail
 end


(**
 ** fills the all_var_and_params map in tornadoext
 **)
 relation add_dae_var_to_index_map:(DAELow.DAELow) => () = 
         
         
  rule	DAELow.vararray_list(vararr) => varlst &
         DAELow.vararray_list(knvararr) => knvarlst &
 	     Util.list_select(knvarlst,DAELow.is_param) => knvarlst' & 
         list_append(knvarlst',varlst) => all_vars &
         add_dae_var_to_index_map2(all_vars)
	     
	     -------------------------------------------
         add_dae_var_to_index_map(DAELow.DAELOW(vars as DAELow.VARIABLES(_,vararr,_,_),
                                                vars2 as DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
          => ()        
	       
  axiom add_dae_var_to_index_map(_) => fail
 end
(** 
 ** This relation update the index in the map in TORNADOEXT
 ** algebraic variable links.
 ** ARG1 the daelow.var list
 ** this is for #define-index
 ** DO NOT CHANGE THE STRING FOR THE DIFFERENT TYPES BECAUSE THERE ARE USED IN generate_no_of_values_strings
 **)
 relation add_dae_var_to_index_map2:(DAELow.Var list) => () = 
	     
  axiom	add_dae_var_to_index_map2([]) => ()
         
         (*   rule print "IN add_dae_var_to_index_map2\n"& *)
         (*          int_eq(1,0) => true *)
         (*          ------------------------------ *)
         (*          add_dae_var_to_index_map2(_,_,_,_) => ([],[],0) *)

         (* check first if output variable is on the top model.*)
  rule  TornadoCodeGen.is_var_on_top_model(cr) => top_bool &
 	     list_reverse(class_paths) => class_path::_ & 
         Exp.cref_str(cr) => crs &
         Absyn.path_string(class_path) => class_path_str &
         TornadoCodeGen.generate_type_name(kind,dir,top_bool) => type_str &
         TORNADOEXT.add_variable_for_index(class_path_str,crs,type_str) &
         add_dae_var_to_index_map2(rest) 
         ---------------------------------------------
         add_dae_var_to_index_map2(DAELow.VAR(cr,kind,dir,_,_,_,_,start,_,_,class_paths)::rest)
         
  rule  add_dae_var_to_index_map2(rest) => 
         -----------------------------------------------
         add_dae_var_to_index_map2(_::rest)
	     
  rule  print "-add_dae_var_to_index_map2 failed\n" 
         ----------------------
         add_dae_var_to_index_map2(_) => fail
 end




(** relation: generate_constructor_component_initialization
 ** this relation generates the code for initialization of internal
 ** components for a model. The components are non-primitive types.
 ** The string list that is return is a list of the names of the components 
 ** in the main model. This is needed for extracting the index of the components.
 ** 
 **)
 relation generate_constructor_component_initialization: (string,Absyn.Program) => (string) =
	     
	     
  rule  Interactive.get_pathed_class_in_program(Absyn.IDENT(cname),program) => cdef &
         TORNADOEXT.generate_constructor_component_initialization(cname) => res 
         (*& Util.string_append_list(comp_name_list) => str_res &
          print "COMPONENTS " & print str_res & print "\n" *)
         --------------------------------------
         generate_constructor_component_initialization(cname,program) => (res)
         
         
  rule  print "generate_constructor_component_initialization failed\n"
         --------------------------------------
         generate_constructor_component_initialization(_,_) => fail
         
 end

(** relation: generate_compute_methods
 ** This relation generates the code for the computation of the equations
 ** They are separated into four parts.
 ** - computing the output variables (algebraic variables)
 ** - computing the state variables
 ** - computing the initial conditions
 ** - computing the terminal conditions
 **)
 relation generate_compute_methods: (string,
				                     DAELow.DAELow,
				                     Absyn.Program, 
				                     int list list, 
				                     int vector, 
				                     int vector,
				                     DAELow.IncidenceMatrix,
				                     DAELow.IncidenceMatrixT) => string =

  rule	(** ass1 is what var is solved in what eqn **)
         (** ass2 is what eqn is solves what var **)
         DAELow.generate_state_partition(blt,dae,ass1,ass2,m,mt) 
	      => (blt_states,blt_no_states) &
	       
           translate_dae(dae) => dae' &

         generate_compute_output(cname,dae',p,ass1,ass2,blt_no_states) => (coutput,simple1) &
         generate_compute_state(cname,dae',p,ass1,ass2,blt_states) => (cstate,simple2) &
         generate_compute_initial(cname,dae',p) => cinitial &
         Util.string_append_list([cinitial,simple1,simple2]) => cinitial' &
         (*generate_compute_terminal(cname,dae',p) => cterm &*)
         generate_compute_terminal(cname,dae',p,ass1,ass2,blt) => cterm &
         TornadoCodeGen.generate_compute_methods_str(cname,coutput,cinitial',cstate,cterm) => methods
         ---------------------------
         generate_compute_methods(cname,dae,p,blt,ass1,ass2,m,mt) => methods
         
  rule  print "-generate_compute_methods failed\n" 
         -----------------------------------------
         generate_compute_methods(_,_,_,_,_,_,_,_) => fail
 end 


(** relation generate_blt
 ** This relation computes the block lower triangular form of the equation 
 ** system using a list of the DAEs. 
 **
 **)
 relation generate_blt:(DAELow.DAELow) => (DAELow.DAELow,
					                       int list list,
					                       int vector, 
					                       int vector,
					                       DAELow.IncidenceMatrix,
					                       DAELow.IncidenceMatrixT) =
         
	     
  rule  (*DAELow.lower(d) => d' *)
         Debug.fcall("dumpdaelow", DAELow.dump, d') 
         & DAELow.incidence_matrix(d') => m 
         & DAELow.transpose_matrix(m) => mT 
         & DAELow.matching_algorithm(d',m,mT) => (v1,v2,d'',m,mT) 
         & Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
         (* & Debug.fcall("bltdump", DAELow.dump_incidence_matrix_t, mT) *)
(*          & Debug.fcall("bltdump", DAELow.dump,d'') *)
(*          & Debug.fcall("bltdump", DAELow.dump_matching, v1) *)
         & DAELow.strong_components(m,mT,v1,v2) => (comps) 
         (*& DAELow.dump_components(comps) *)
         -------------------------------------------------------------
         generate_blt(d') => (d'',comps,v1,v2,m,mT)
         
  rule  print "-generate_blt failed\n" 
         -------------------------------------------------
         generate_blt(_) => fail
         
 end

(** relation translate_dae 
 ** This relation translates the DAE so that all the der(x) is _D_X in the equations
 **
 **)    
 relation translate_dae: DAELow.DAELow => DAELow.DAELow =
         
  rule  DAELow.vararray_list(vararr) => var_list &
         extract_der_from_var_list(var_list) => (from_list,to_list) &
	     DAELow.equation_list(eqns) => eqn_list &
         replace_exp_in_eqns(eqn_list,from_list,to_list) => res_eqns &
	     DAELow.list_equation(res_eqns) => eqns' 
         -------------------------------------------------------------
         translate_dae(dae as DAELow.DAELOW(vars as DAELow.VARIABLES(_,vararr,_,_),a,eqns,b,c,d)) 
          => DAELow.DAELOW(vars,a,eqns',b,c,d)



  rule  print "-translate_dae failed\n"
         -------------------------------------------------------------
         translate_dae(dae) => fail



 end

(** relation extract_der_from_var_list 
 ** This relation generates to Exp.Exp list of the form:
 ** [Exp.CALL("der",Exp.Exp("x")...)] and [Exp.cref("x")]
 ** 
 **)
 relation extract_der_from_var_list: DAELow.Var list => (Exp.Exp list, Exp.Exp list) =
         
  rule  
         -------------------------------------------------------------
         extract_der_from_var_list([]) => ([],[])
	     
  rule  DAELow.is_non_state kind &
         (*print "extract_der_from_var_list Is not state\n" &*)
         extract_der_from_var_list(var_list) => (res1,res2)
         -------------------------------------------------------------
         extract_der_from_var_list((v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_))::var_list)  
          => (res1,res2)

  rule  (*print "extract_der_from_var_list Is state" &*)

         (*Exp.print_component_ref_str(cr) => cr_str &*)
         SimCodegen.cref_modelica_str(cr) => cr_str &

	     let old_varexp = Exp.CREF(cr,Exp.REAL) &

         let dercall = Exp.CALL(Absyn.IDENT("der"),
			                    [old_varexp], 
			                    false,
			                    false) &
	     
         Util.string_append_list(["_D_",cr_str]) => new_id &
	     let new_cr = Exp.CREF_IDENT(new_id,[]) &
	     let new_varexp = Exp.CREF(new_cr,Exp.REAL) &


         (* 	      print " from \"" & print cr_str & print "\" to \"" & print new_id  & print "\"\n" &  *)

         extract_der_from_var_list(var_list) => (res1,res2)
         -------------------------------------------------------------
         extract_der_from_var_list((v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_))::var_list)  
          => (dercall::res1, new_varexp::res2)


  rule  print "-extract_der_from_var_list failed\n"
         -------------------------------------------------------------
         extract_der_from_var_list(_) => fail
 end

(** relation replace_exp_in_eqns
 ** This takes a DAELow.Equation list and two Exp.Exp lists: ("from","to") and does
 ** a "replace" all on the equations;
 **
 **)

 relation replace_exp_in_eqns:(DAELow.Equation list, Exp.Exp list, Exp.Exp list) => DAELow.Equation list =
         
  rule  
         -------------------------------------------------------------
         replace_exp_in_eqns([],from_exp,to_exp) => []

  rule  (*print "replace_exp_in_eqns not list" &*)
         Exp.replace_exp_list(exp1,from_exp,to_exp) => (res_exp1,nr_of_times1) &
         Exp.replace_exp_list(exp2,from_exp,to_exp) => (res_exp2,nr_of_times2) & 
         replace_exp_in_eqns(eqns_rest,from_exp,to_exp) => res_eqns
         -------------------------------------------------------------
         replace_exp_in_eqns(DAELow.EQUATION(exp1,exp2)::eqns_rest,from_exp,to_exp) => (DAELow.EQUATION(res_exp1,res_exp2)::res_eqns)


  rule  print "-replace_exp_in_eqns failed\n"
         -------------------------------------------------------------
         replace_exp_in_eqns(_,_,_) => fail
 end



(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output variables.
 **)
 relation generate_compute_output:(string,
                                   DAELow.DAELow,
                                   Absyn.Program,
                                   int vector, 
                                   int vector, 
                                   int list list) => (string,string) =
         
  rule  (*Util.string_append_list(["/* output code here*/\n"]) => coutput &*)
         build_blocks(dae,ass1,ass2,blocks) => (eqn_str_list,seqn_str_list) &
         Util.string_append_list(eqn_str_list) => coutput1 &
         Util.string_append_list(seqn_str_list) => coutput2
         -----------------------------------------------------------
         generate_compute_output(cname,
                                 dae as DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_),
                                 p,ass1,ass2,blocks) => (coutput1,coutput2)
         
 end

 relation build_simple_equation:(DAELow.Var array, DAELow.Equation list) 
	      => string =
           
	       
           
  rule	
         --------------------------------
	     build_simple_equation(knvars,[]) => ""
	     
  rule  build_simple_equation(knvars,rest) => rest_res &
         SimCodegen.print_exp_cpp_str(exp1) => exp1_str & 
         SimCodegen.print_exp_cpp_str(exp2) => exp2_str &
         array_list(knvars) => knvarslist &
         DAELow.is_var_known(knvarslist,cr1) => true &
         DAELow.is_var_known(knvarslist,cr2) => true &
         Util.string_append_list(["  ",exp1_str, " = ", exp2_str, ";\n",rest_res]) => eqn_str 
         (*& print "\n build_simple_equation: " & print(eqn_str) *)
         --------------------------------
	     build_simple_equation(knvars,DAELow.EQUATION(exp1 as Exp.CREF(cr1,_),exp2 as Exp.CREF(cr2,_))::rest) => eqn_str

  rule  build_simple_equation(knvars,rest) => rest_res &
         SimCodegen.print_exp_cpp_str(exp1) => exp1_str & 
         SimCodegen.print_exp_cpp_str(exp2) => exp2_str &
         array_list(knvars) => knvarslist &
         DAELow.is_var_known(knvarslist,cr1) => true &
         Util.string_append_list(["  ",exp1_str, " = ", exp2_str, ";\n",rest_res]) => eqn_str 
         (*& print "\n build_simple_equation: " & print(eqn_str) *)
         --------------------------------
	     build_simple_equation(knvars,DAELow.EQUATION(exp1 as Exp.CREF(cr1,_),exp2 as Exp.CREF(cr2,_))::rest) => eqn_str

  rule  build_simple_equation(knvars,rest) => rest_res &
         SimCodegen.print_exp_cpp_str(exp1) => exp1_str & 
         SimCodegen.print_exp_cpp_str(exp2) => exp2_str &
         array_list(knvars) => knvarslist &
         DAELow.is_var_known(knvarslist,cr2) => true &
         Util.string_append_list(["  ",exp2_str, " = ", exp1_str, ";\n",rest_res]) => eqn_str 
         (*& print "\n build_simple_equation: " & print(eqn_str) *)
         --------------------------------
	     build_simple_equation(knvars,DAELow.EQUATION(exp1 as Exp.CREF(cr1,_),exp2 as Exp.CREF(cr2,_))::rest) => eqn_str
         
  rule  
         -------------------------------------------------------------
         build_simple_equation(_,_) => "// generating simple equation failed"

 end


(** relation: generate_compute_initial
 ** This relation generates the code for the calculation of the initial conditions.
 **)
 relation generate_compute_initial:(string,
				                    DAELow.DAELow,
				                    Absyn.Program) 
	      => string =

  rule	DAELow.vararray_list(vararr) => vars &
         DAELow.vararray_list(knvararr) => knvars &
         list_append(vars,knvars) => allvars &
         
         DAELow.equation_list(ieqnarr) => eqn_lst &
	     list_length(eqn_lst) => lst_len &
	     generate_compute_initial2(vars',eqn_lst) => str_lst1 &
         
         generate_compute_initial_from_start_values(allvars) => str_lst2 &
         
         list_append(str_lst1,str_lst2) => str_lst &

	     Util.string_delimit_list(str_lst,"\n") => cinit 
         -------------------------------------------------------------
         generate_compute_initial(cname,
                                  dae as DAELow.DAELOW(
                                                       (vars' as DAELow.VARIABLES(_,vararr,_,_)),
                                                       DAELow.VARIABLES(_,knvararr,_,_)
                                                       ,_,_,ieqnarr,_),p) => cinit
         
 end


(** relation: generate_compute_initial2
 ** Helper relation to generate_compute_initial
 **)
 relation generate_compute_initial2:(DAELow.Variables,
				                     DAELow.Equation list) => string list =
  axiom	generate_compute_initial2(_,[]) => ["\n"]
	     
  rule	generate_compute_initial2(vars,es) => str_lst &
	     DAELow.get_var(cr,vars) 
	      => (DAELow.VAR(cr',_,_,_,_,_,_,_,_,_,_),_) &
           SimCodegen.cref_modelica_str(cr') => crstr &
	     SimCodegen.print_exp_cpp_str(e2) => rhs_str &
	     Util.string_append_list(["  ",crstr, " = ",rhs_str, ";"]) => str 
	     ------------------------------
	     generate_compute_initial2(vars,DAELow.EQUATION(Exp.CREF(cr,_),e2)::es) 
	      => str::str_lst

  rule	print "Error, intial equation not on form x = <expr> for variable x.\n"
	     ---------------------------
	     generate_compute_initial2(_,_) => fail
 end


 relation generate_compute_initial_from_start_values:(DAELow.Var list) 
          => string list =
           
  axiom generate_compute_initial_from_start_values([]) => ["\n"]
         
  rule  Exp.is_const(start) => false &
         SimCodegen.cref_modelica_str(cr) => crs &
         SimCodegen.print_exp_cpp_str(start) => exp_str &
         Util.string_append_list(["  ",crs, " = ", exp_str,";\n"]) => eqn_str &
         generate_compute_initial_from_start_values(rest) => res
         -------------------------------------------
         generate_compute_initial_from_start_values(DAELow.VAR(cr,_,_,_,_,_,_,SOME(start),_,_,_)::rest) => eqn_str::res

  rule  Exp.is_const(start) => true &
         generate_compute_initial_from_start_values(rest) => res
         -------------------------------------------
         generate_compute_initial_from_start_values(DAELow.VAR(cr,_,_,_,_,_,_,SOME(start),_,_,_)::rest) => res

  rule  generate_compute_initial_from_start_values(rest) => res
         -------------------------------------------
         generate_compute_initial_from_start_values(DAELow.VAR(cr,_,_,_,_,_,_,NONE,_,_,_)::rest) => res
         

 end

(** relation: generate_compute_state
 ** This relation generates the code for the calculation of the state variables.
 **)
 relation generate_compute_state:(string,DAELow.DAELow,Absyn.Program,int vector, int vector, int list list) => (string,string) =
         
  rule  (*Util.string_append_list(["/* state code here*/\n"]) => cstate &*)
         (*print("----------- START building block STATE---------------\n") &*)
         build_blocks(dae,ass1,ass2,blocks) => (eqn_str_list,seqn_str_list) &
         Util.string_append_list(eqn_str_list) => cstate1 &
         Util.string_append_list(seqn_str_list) => cstate2 
         (*print("----------- END building block STATE---------------\n") *)
         
         -------------------------------------------------------------
         generate_compute_state(cname,dae,p,ass1,ass2,blocks) => (cstate1,cstate2)

 end


(** relation: generate_compute_terminal
 ** This relation generates the code for the calculation of the terminal behavior.
 ** This can be expressed in Modelica using when statements:
 ** when terminal() then
 **   x:=do_calc(x,y);
 ** e n d when
 *)
 relation generate_compute_terminal:(string,DAELow.DAELow,Absyn.Program,int vector, int vector, int list list) => string =
	     
  rule Util.string_append_list(["/* terminal code here*/\n"]) => cterm
	     -------------------------------------------------------------
	     generate_compute_terminal(cname,dae,p,_,_,_) => cterm
 end


(** relation build_blocks
 ** this is copied from taskgraph.rml and constructs the blocks in the incident matrix
 ** for the equations.
 ** It is NOT done for system of equations!
 **)
 relation build_blocks:(DAELow.DAELow, int vector, int vector, int list list) 
          => (string list,string list) =

  axiom	build_blocks(_,_,_,[]) => ([],[])

         (* rule	(* For system of equations *) *)
	     (* build_system(dae,ass1,ass2,block) &
	      build_blocks(dae,ass1,ass2,blocks)
	      -------------------------------------
	      build_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks)*)
	     
  rule	(* for single equations *)
	     build_equation(dae,ass1,ass2,eqn) => (eqn_str,seqn_str) &
	     build_blocks(dae,ass1,ass2,blocks) => (res1,res2)
	     -------------------------------------
	     build_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => (eqn_str::res1, seqn_str::res2)

  rule	print "-build_blocks failed\n" 
	     -----------------
	     build_blocks(_,_,_,_) => fail
 end


(** relation build_equation 
 ** This returns the string for a specific equation in the 
 ** incidence matrix.
 ** It is used both for state variables and regular variables
 ** RET1 = the usual equations
 ** RET2 = the initial equation if there are some that are on the form of cref = constant.
 **)
 relation build_equation:(DAELow.DAELow, int vector, int vector, int) => (string,string) =
	     
  rule  (* Solving for non-states *)
	     int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v &
	     int_sub(v,1) => v' &
	     DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_)) &  
	     DAELow.is_non_state kind &
	     (*print "Solving for non-states\n" &*)

	     let varexp = Exp.CREF(cr,Exp.REAL) &
	     Exp.solve(e1,e2,varexp) => expr &
	     
         (* start debug output *)
         Exp.print_exp_str e1 => e1s &
	     Exp.print_exp_str e2 => e2s &
         int_string(e) => eqn_nr &
         int_string(v) => var_nr &
	     (*    print "Equation nr: " & print eqn_nr & print " var nr: " & print var_nr &print " :\n" & print e1s & print " = " & print e2s &
	      print "\nsolved for:\n " & Exp.print_exp_str varexp => s &
	      print s & print "\ngiving:\n " &
          Exp.print_exp_str expr => s2 & print s2 & print "\n" &*)
         
         Exp.simplify(expr) => simplify_exp &
         Exp.is_const(simplify_exp) => true &
	     build_assignment(cr,simplify_exp,origname)  => assigment_string 
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_)
                                      ,_,eqns,_,_,_),ass1,ass2,e) 
          => ("",assigment_string)
 
  rule  (* Solving for non-states *)
	     int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v &
	     int_sub(v,1) => v' &
	     DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_)) &  
	     DAELow.is_non_state kind &
	     (*print "Solving for non-states\n" &*)

	     let varexp = Exp.CREF(cr,Exp.REAL) &
	     Exp.solve(e1,e2,varexp) => expr &
	     
         (* start debug output *)
         Exp.print_exp_str e1 => e1s &
	     Exp.print_exp_str e2 => e2s &
         int_string(e) => eqn_nr &
         int_string(v) => var_nr &
	     (*    print "Equation nr: " & print eqn_nr & print " var nr: " & print var_nr &print " :\n" & print e1s & print " = " & print e2s &
	      print "\nsolved for:\n " & Exp.print_exp_str varexp => s &
	      print s & print "\ngiving:\n " &
          Exp.print_exp_str expr => s2 & print s2 & print "\n" &*)
         
         Exp.simplify(expr) => simplify_exp &
	     build_assignment(cr,simplify_exp,origname)  => assigment_string
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) 
          => (assigment_string,"")
         

  rule  (* Solving the state s means solving for der(s) *)
	     int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v &
	     (* v == variable no solved in this equation *)
	     int_sub(v,1) => v' &
	     DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_) &

	     (*print "solving for state\n" &*)
         SimCodegen.cref_modelica_str(cr) => cr_str &


 	     Util.string_append_list(["_D_",cr_str]) => new_id &
	     let new_cr = Exp.CREF_IDENT(new_id,[]) &
	     let new_varexp = Exp.CREF(new_cr,Exp.REAL) &


	     Exp.solve(e1,e2,new_varexp) => expr &
         
         (*Exp.print_exp_str e1 => new_e1s &
	      Exp.print_exp_str e2 => new_e2s &
          int_string(e) => eqn_nr &
          int_string(v) => var_nr &
	      print "STATE Equation nr: " & print eqn_nr & print " var nr: " & print var_nr &print " :\n" & print new_e1s & print " = " & print new_e2s &
	      print " solved for " & Exp.print_exp_str new_varexp => s &
	      print s & print " giving " &
	      Exp.print_exp_str expr => s2 & print s2 & print "\n" & *)

         Exp.simplify(expr) => simplify_exp &
	     build_assignment(new_cr ,simplify_exp,origname)  => assigment_string
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) 
          => (assigment_string,"")

  rule	int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	     int_sub(v,1) => v' &
	     DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_) &  
	     let varexp = Exp.CREF(cr,Exp.REAL) &
	     not Exp.solve(e1,e2,varexp) => _ &
	     print "nonlinear equation not implemented yet\n" 
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => fail
         
  rule  print "-build_equation failed\n" 
	     --------------------------------
	     build_equation(_,_,_,_) => ("//build_equation failed\n","")
 end

(** relation build_assignment 
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)

 relation build_assignment: (Exp.ComponentRef, (* varname *)
			                 Exp.Exp, (*expression*) 
			                 string) (* orig. name*) 
	      => string =
	       
  rule  SimCodegen.cref_modelica_str(cr) => cr_str & 
         SimCodegen.print_exp_cpp_str(exp) => exp_str & 
         (*Exp.print_exp_str(exp) => exp_str & *)
         Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
         --------------------------------
	     build_assignment(cr,exp,origname) => eqn_str
         
  rule	print "-build_assignment failed\n" 
	     ------------------------
	     build_assignment(cr,exp,origname) => fail
         
	     
 end



