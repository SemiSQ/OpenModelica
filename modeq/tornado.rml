(* 
 Copyright MathCore Engineering 2004-10-21
 This source is non-free and should not be included in OpenModelica
*)

(**
**
  ** file:	 tornado.rml
 ** module:      Tornado
 ** description: Code generation of Nodelica models including equation
 ** code and symbolic information to the Tornado-1 format.
 ** Part of the Hemmis project at MathCore Engineering AB.
 **
 ** RCS: $Id$
 ** 
 **)
module Tornado:
  
  with "dae.rml"
  with "absyn.rml"

(* Generates code according to the Tornado-1 format *)
  relation generate_code: (Absyn.Program, DAE.DAElist, Absyn.Path) => ()
	  
	  
	  
  end
with "interactive.rml"
with "util.rml"
with "system.rml"
with "daelow.rml"
with "exp.rml"
with "debug.rml"


(** relation: generate_code
 ** This is the main relation that generates Tornado1 C++ code from the flat Modelica model
 ** It will generate two files <modelname>.cpp and <modelname>.hpp, the implementation file and 
 ** the header file. Those will currently be put in the current directory.
 ** The implementation uses the DAELow module to lower the flat modelica model such that it
 ** can be BLT sorted and indexed, etc.
 **)
relation generate_code:  (Absyn.Program, DAE.DAElist, Absyn.Path) => () =

  rule	DAELow.lower(dae) => dae' &
	Absyn.path_string(class) => cname &
	generate_header(cname) => header &
	generate_impl_header(cname) => implheader &
	generate_constructor(cname,p,dae') => constr &
	generate_var_defines(dae') => defines &
	generate_compute_methods(cname,dae',p) => cmethods &
	Util.string_append_list([implheader,constr,defines,cmethods]) => impl &
	string_append(cname,".hpp") => headerfile &
	string_append(cname,".cpp") => implfile &
	System.write_file(headerfile,header) &
	System.write_file(implfile,impl) 
	-------------------------------------------------------------------
	generate_code(p,dae,class) => 

  rule	print "generate_code failed\n" 
	------------------------------
	generate_code(_,_,_) => fail
end

(** relation: generate_header
 ** Generate the content of the header file. It only needs the name of the Modelica model.
 **)
relation generate_header: string => string =

  rule	System.toupper cname => CNAME &
	Util.string_append_list(["#ifndef __",CNAME,"_H__\n"]) => r1 &
	Util.string_append_list(["#define __",CNAME,"_H__\n"]) => r2 &
	Util.string_append_list(["\n#include \"Tornado/EE/MSLE/MSLE.h\"\n",
				 "\n\nclass C",cname," : public Tornado::CDAEModel\n"]) => r3 &
	Util.string_append_list(["{\n  public:\n\n    C",cname,"(const wchar_t* Name);\n",
				 "\n  public:\n\n",
				 "    void ComputeInitial();\n",
				 "    void ComputeTerminal();\n",
				 "    void ComputeState();\n",
				 "    void ComputeOutput();\n",
				 "};\n\n",
				 "#endif\n"]) => r4 &
	Util.string_append_list([r1,r2,r3,r4]) => header
	------------------------------------------------
	generate_header(cname) => header


  rule	print "-generate_header failed\n" 
	---------------------------------
	generate_header(_) => fail
end

(** relation generate_impl_header
 ** generate the "header" of the implementation file, i.e. includes, ifdefs etc. 
 ** It is NOT the generation of the headerfile. (That is in the relation generate_header above)
 *)
relation generate_impl_header: string => string =

  rule	Util.string_append_list(["#ifdef _MSC_VER\n",
				 "#pragma warning(disable:4250)\n",
				 "#pragma warning(diable:4786)\n",
				 "#endif\n",
				 "\n",
				 "#include \"",cname,".h\"\n",
				 "\n",
				 "#include <math.h>\n",
				 "\n",
				 "using namespace Common;\n",
				 "using namespace Tornado;\n",
				 "\n"]) => implheader
	----------------------
	generate_impl_header(cname) => implheader
	
  rule	print "-generate_impl_header failed\n" 
	-------------------
	generate_impl_header(_) => fail
end

(** relation generate_constructor:
 ** Generates the implementation for the constructor which sets up the variables (names)
 ** and their initial values.
**)
relation generate_constructor: (string, Absyn.Program, DAELow.DAELow) => string =
	
	
  rule	
	generate_constructor_outputvars(dae) => outputvars &
	generate_constructor_statevars(dae) => statevars &
	Util.string_append_list(["C",cname,"::\n",
				 "C",cname,"(const wchar_t* Name)\n",
				 "{\n",
				 "  SetName(Name);\n",
				 "  SetDesc(L\"",cname," test.\");\n",
				 "\n",
				 "  SetNoIndepVars(1);\n",
				 "  SetIndepVar(0, new CIndepVar(L\"t\",L\"s\"));\n",
				 "\n",
				 outputvars,
				 "\n",
				 "\n",
				 statevars,
				 "\n",
				 "  SetNoIndepVarValues(1);\n",
				 "\n",
				 "  Link();\n",
				 "  Reset();\n",
				 "}\n",
				 "\n"]) => constr
	-----------------------------------------
	generate_constructor(cname,p,dae) => constr


  rule	print "-generate_constructor failed\n" 
	-------------------------------------
	generate_constructor(_,_,_) => fail

end

(* relation generate_constructor_outputvars
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 *)
relation generate_constructor_outputvars:(DAELow.DAELow) => string= 

  rule	generate_constructor_outputvars2(vars,0) => lst1 &
	list_length(lst1) => len &
	int_sub(len,1) => len' &
	generate_constructor_outputvars2(knvars,len') => lst2 &
	list_append(lst1,lst2) => lst &
	Util.string_delimit_list(lst,"\n") => res &
	list_length(lst) => len &
	int_string len => lenstr &
	Util.string_append_list(["  SetNoOutputVars(",lenstr,");\n"]) => prefix &
	Util.string_append_list(["  SetNoOutputVarValues(",lenstr,");\n"]) => prefix &
	string_append(prefix,res) => res'
	-------------------------------------------
	generate_constructor_outputvars(DAELow.DAELOW(vars,knvars,eqn,seqn)) => res'
end

relation generate_constructor_outputvars2:(DAELow.Var list,int) => string list = 

  rule	(* special case for when called second time and first time gave 
	 list length zero *)
	generate_constructor_outputvars2(lst,0) => res
	----------------------------------------------
	generate_constructor_outputvars2(lst,-1) => res

  axiom	generate_constructor_outputvars2([],_) => []

  rule	int_add(i,1) => i' & int_string(i) => is &
	generate_constructor_outputvars2(rest,i') => res &
	Exp.cref_modelica_str(cr) => crs &
	Util.string_append_list(["  SetOutputVar(",is,", new COutputVar(L\"",crs,"\", L\"\",0);"]) 
	  => r1 
	--------------------
	generate_constructor_outputvars2(DAELow.VAR(cr,VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_)::rest,i) 
	  => r1::res
  rule	generate_constructor_outputvars2(rest,i) => res 
	-----------------------------------------------
	generate_constructor_outputvars2(_::rest,i) 
	  => res

  rule	print "-generate_constructor_outputvars2 failed\n" 
	----------------------
	generate_constructor_outputvars2(_,_) => fail
end


(* relation: generate_constructor_statevars
 **  This relation is similar to the generate_constructor_outputvars relation above.
 ** It also generates code placed in the contstructor, but for state variables.
 ** They are also indexed in the order they appear in the DAELow representation, starting
 ** with index 0.
 *)
relation generate_constructor_statevars:(DAELow.DAELow) => string = 

  rule	generate_constructor_statevars2(vars,0) => lst &
	Util.string_delimit_list(lst,"\n")=> res & 
	list_length(lst) => len &
	int_string len => lenstr &
	Util.string_append_list(["  SetNoDerStateVars(",lenstr,");\n"]) => prefix &
	Util.string_append_list(["  SetNoDerStateVarValues(",lenstr,");\n"]) => prefix &
	string_append(prefix,res) => res'
	----------------------
	generate_constructor_statevars(DAELow.DAELOW(vars,knvars,eqn,seqn)) => res'
end

relation generate_constructor_statevars2: (DAELow.Var list,int) => string list =

  axiom	generate_constructor_statevars2([],_) => []

  rule	(* When start value is present*)
	int_add(i,1) => i' & int_string(i) => is &
	generate_constructor_statevars2(rest,i') => res &
	Exp.cref_modelica_str(cr) => crs & 
	Exp.print_exp_str start => startstr &
	Util.string_append_list(["  SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",",
				 startstr,");"]) 
	  => r1 
	--------------------
	generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,SOME(start),_,_)::rest,i) 
	  => r1::res

  rule	(* If no start value is present*)
	int_add(i,1) => i' & int_string(i) => is &
	generate_constructor_statevars2(rest,i') => res &
	Exp.cref_modelica_str(cr) => crs & 
	
	Util.string_append_list(["  SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",0);"]) 
	  => r1 
	--------------------
	generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,NONE,_,_)::rest,i) 
	  => r1::res

  rule	generate_constructor_statevars2(rest,i) => res 
	-----------------------------------------------
	generate_constructor_statevars2(_::rest,i) 
	  => res

  rule	print "-generate_constructor_statevars2 failed\n" 
	----------------------
	generate_constructor_statevars2(_,_) => fail
end

relation generate_var_defines: (DAELow.DAELow) => string =

  rule	Util.string_append_list(["/*generate var defines here*/\n"]) => vdefs
	---------------------
	generate_var_defines(dae) => vdefs

  rule	print "-generate_var_defines failed\n"
	--------------------------------------
	generate_var_defines(_) => fail
end

(** relation: generate_compute_methods
 ** This relation generates the code for the computation of the equations
 ** They are separated into four parts.
 ** - computing the output variables (algebraic variables)
 ** - computing the state variables
 ** - computing the initial conditions
 ** - computing the terminal conditions
 **)
relation generate_compute_methods: (string,DAELow.DAELow,Absyn.Program) => string =

  rule	generate_blt(dae) => blt &
	generate_state_partition(blt,dae) => (blt_states,blt_no_states) &
	Debug.fcall("bltdump", DAELow.dump_components, blt_states) &
	Debug.fcall("bltdump", DAELow.dump_components, blt_no_states) &
	generate_compute_output(cname,dae,p) => coutput &
	generate_compute_initial(cname,dae,p) => cinitial &
	generate_compute_state(cname,dae,p) => cstate &
	generate_compute_terminal(cname,dae,p) => cterm &
	Util.string_append_list(["void C",cname,"::\n",
				 "ComputeOutput()\n",
				 "{\n",
				 coutput,
				 "}\n",
				 "\n",
				 "void C",cname,"::\n",
				 "ComputeInitial()\n",
				 "{\n",
				 cinitial,
				 "}\n",
				 "\n",
				 "void C",cname,"::\n",
				 "ComputeState()\n",
				 "{\n",
				 cstate,
				 "}\n",
				 "\n",
				 "void C",cname,"::\n",
				 "ComputeTerminal()\n",
				 "{\n",
				 cterm,
				 "}\n",
				 "\n"]) => methods
	---------------------------
	generate_compute_methods(cname,dae,p) => methods

  rule	print "-generate_compute_methods failed\n" 
	-----------------------------------------
	generate_compute_methods(_,_,_) => fail
end 


(** relation generate_blt
 ** This relation computes the block lower triangular form of the equation 
 ** system using a list of the DAEs. 
 **
 **)
relation generate_blt:(DAELow.DAELow) => (int list list) =

	
  rule	(*DAELow.lower(d) => d' *)
	Debug.fcall("dumpdaelow", DAELow.dump, d') 
	& DAELow.incidence_matrix(d') => m 
	& DAELow.transpose_matrix(m) => mT 
	& DAELow.matching_algorithm(d',m,mT) => (v1,v2,d'',m,mT) 
	& Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
(*	& Debug.fcall("bltdump", DAELow.dump_incidence_matrix_inv, mT) *)
	& Debug.fcall("bltdump", DAELow.dump,d'')
	& Debug.fcall("bltdump", DAELow.dump_matching, v1)
	& DAELow.strong_components(m,mT,v1,v2) => (comps) 
	& DAELow.dump_components(comps) 
	-------------------------------------------------------------
	generate_blt(d') => (comps)

  rule	print "-generate_blt failed\n" 
	-----------------------------------------
	generate_blt(_) => fail

end


(** relation:generate_state_partition
 ** this relation extracts the rightmost part 
 **
 ** returns two incidencematrices, the first one including blocks with 
 ** all state variables (and of course some other variables as well) 
 ** and the second one including no state variables. No reordering
 ** of blocks is performed.
 **) 
relation generate_state_partition:(int list list,DAELow.DAELow) => 
	(int list list, int list list) =

  rule	
	
	list_reverse(blt) => reversed_blt &
	has_state_var(0,reversed_blt,dae) => state_component_number &
	print "First state component found in component (reversed): " &
	int_string(state_component_number) => state_component_number_string &
	print state_component_number_string &
	print "\n" &
 	list_length(blt) => nr_of_components &
	int_sub(nr_of_components,state_component_number) => component_offset &	
	print "(non-reversed): " &
	int_string(component_offset) => component_offset_string &
	print component_offset_string &
	print "\n" &
	Util.list_split(blt,component_offset) => (blt_states,blt_no_states)
	-----------------------------------------
	generate_state_partition(blt,dae) => (blt_states,blt_no_states)  

  rule	print "-generate_state_partition failed\n" 
	-----------------------------------------
	generate_state_partition(_,_) => fail

end

(** Helper relation for generate state partition
 ** Determines which list of coefficients contains the first 
 ** statevariable
 ** 
 ** Returns the first component number (counted from the end of the list)
 ** which contais a state variable.
 **) 
relation has_state_var:(int, int list list, DAELow.DAELow) => int =
	  
  rule	(*if this component contains a statevar, return index *)
	check_component_for_statevars(0,element,dae) => true
	-----------------------------------------
	has_state_var(index,element::reversed_blt,dae) => index

	(* If we have no more components return 0 *)
  rule	
	-----------------------------------------
	has_state_var(_,[],_) => 0
	
  rule	(* If no statevars found in this component, continue with the next one*)
	int_add(1,index) => next_index &
	has_state_var(next_index,reversed_blt,dae) => ret_value
	-----------------------------------------
	has_state_var(index,element::reversed_blt,dae) => ret_value

  rule	print "-generate_state_partition2 failed\n" 
	-----------------------------------------
	has_state_var(_,_,_) => fail
end

(** relation:check_component_for_statevars
 ** Arg 1 is the index in the component to the current variable to check
 ** Arg 2 is the component itself
 ** Arg 3 is the DAEs
 ** Returns true if this component contains a statevar
 **)
relation check_component_for_statevars:(int, int list, DAELow.DAELow) => bool =

  rule	print "check_component_for_statevars failed: Empty component\n" 
	-------------------------------------------------------------
	check_component_for_statevars(_,[],_) => fail


  rule	(* Termination condition. variables checked.
	   This means that the component did not contain any state vars *)
	list_length(component) => nr_of_variables &
	int_eq(nr_of_variables,i) => true
	-------------------------------------------------------------
	check_component_for_statevars(i,component,_) => false

  rule	(* If this variable is a state variable, return true *)
	list_nth(component,i) => variable_index_to_check &
	(* Variable indexing starts from 1 but lists start from 0.
	 Thus decrease index by one*) 
	int_sub(variable_index_to_check,1) => adjusted_variable_index_to_check &
        list_nth(var_list,adjusted_variable_index_to_check) => 
	  (hej as DAELow.VAR(cref,DAELow.STATE,_,_,_,_,_,_,_,_))
	-------------------------------------------------------------
	check_component_for_statevars(i,component,dae as DAELow.DAELOW(var_list,_,_,_)) => true

  rule	(* If this variable is nt state variable, try the next one *)
	list_nth(component,i) => variable_index_to_check &
	(* Variable indexing starts from 1 but lists start from 0.
	 Thus decrease index by one*) 
	int_sub(variable_index_to_check,1) => adjusted_variable_index_to_check &
        list_nth(var_list,adjusted_variable_index_to_check) => 
	  DAELow.VAR(cref,_,_,_,_,_,_,_,_,_) &
	int_add(i,1) => next_i &
	check_component_for_statevars(next_i,component,dae) => result
	-------------------------------------------------------------
	check_component_for_statevars(i,component,dae as DAELow.DAELOW(var_list,_,_,_)) 
	  => result

  rule	print "check_component_for_statevars failed" 
	-------------------------------------------------------------
	check_component_for_statevars(_,_,_) => fail

end 



(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output variables.
 **)
relation generate_compute_output:(string,DAELow.DAELow,Absyn.Program) => string =

  rule	Util.string_append_list(["/* output code here*/\n"]) => coutput
	-------------------------------------------------------------
	generate_compute_output(cname,dae,p) => coutput

end

(** relation: generate_compute_initial
 ** This relation generates the code for the calculation of the initial conditions.
 **)
relation generate_compute_initial:(string,DAELow.DAELow,Absyn.Program) => string =

  rule	Util.string_append_list(["/* initial code here*/\n"]) => cinit
	-------------------------------------------------------------
	generate_compute_initial(cname,dae,p) => cinit

end

(** relation: generate_compute_state
 ** This relation generates the code for the calculation of the state variables.
 **)
relation generate_compute_state:(string,DAELow.DAELow,Absyn.Program) => string =

  rule	Util.string_append_list(["/* state code here*/\n"]) => cstate 
	
	-------------------------------------------------------------
	generate_compute_state(cname,dae,p) => cstate

end

(** relation: generate_compute_terminal
 ** This relation generates the code for the calculation of the terminal behavior.
 ** This can be expressed in Modelica using when statements:
 ** when terminal() then
 **   x:=do_calc(x,y);
 ** end when
 *)
relation generate_compute_terminal:(string,DAELow.DAELow,Absyn.Program) => string =

  rule	Util.string_append_list(["/* terminal code here*/\n"]) => cterm
	-------------------------------------------------------------
	generate_compute_terminal(cname,dae,p) => cterm
end
