(**
 ** file:	 types.rml
 ** description: Type system
 **
 ** RCS: $Id$
 **)

module Types :

  with "classinf.rml"
  with "absyn.rml"
  with "exp.rml"
  with "values.rml"

  (** - Identifiers *)
  type Ident = string
  (** FIXME: This is declared in many places. *)

  (** - Variables *)
  datatype Var = VAR of Ident			  (* name *)
		      * Absyn.VarAttr		  (* attributes *)
		      * bool	                  (* protected *)
		      * Type			  (* type *)
		      * Binding			  (* equation modification *)

  datatype Binding = UNBOUND
		   | EQBOUND of Exp.Exp * bool
		   | VALBOUND of Values.Value
  (** FIXME: I wonder why this goes here? *)

  (** - Types *)
  datatype Type = T_INTEGER
		| T_REAL
		| T_STRING
		| T_BOOL
		| T_ARRAY of ArrayDim * Type
		| T_COMPLEX of ClassInf.State
			     * Var list
		| T_FUNCTION of FuncArg list * Type (* Only single-result *)
		| T_NOTYPE

  datatype ArrayDim = NODIM
		    | DIM of int option * ArrayDim

  type FuncArg = Ident * Type

  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)

  (** - Exported relations *)
  relation basic_type : Type => bool
  relation equivtypes : (Type, Type) => bool
  relation subtype : (Type, Type) => bool
  (* relation same_type : (Type, Type) => bool *)
  relation lookup_component : (Type, Ident) => Var
  relation known_type : (ClassInf.State, Absyn.ArrayDim) => Type
  relation lift_array : (Type,int option) => Type
  relation unlift_array : Type => Type
  relation print_type : Type => ()

end

(** relation: basic_type
 **
 ** Test whether a type is one of the builtin types.
 **)

relation basic_type : Type => bool =

  axiom	basic_type T_INTEGER => true
  axiom	basic_type T_REAL => true
  axiom	basic_type T_STRING => true
  axiom	basic_type T_BOOL => true
  axiom	basic_type T_ARRAY(_,_) => false
  axiom	basic_type T_COMPLEX(_,_) => false

end

(** relation: equivtypes
 **
 ** This is the type equivalence relation.  It is defined in terms of
 ** the subtype relation.  Two types are considered equivalent if they
 ** are subtypes of each other.
 **)

relation equivtypes : (Type, Type) => bool =

  rule	subtype(t1, t2) => true &
	subtype(t2, t1) => true
	-----------------------
	equivtypes(t1, t2) => true

	(* default *)
  axiom	equivtypes(t1, t2) => false

end

(** relation: subtype
 **
 ** Is the first type a subtype of the second type?  This relation
 ** specifies the rules for subtyping in Modelica.
 **)

relation subtype : (Type, Type) => bool =
	
  axiom	subtype (T_INTEGER,T_INTEGER) => true
  axiom	subtype (T_REAL,T_REAL)       => true
  axiom	subtype (T_STRING,T_STRING)   => true
  axiom	subtype (T_BOOL,T_BOOL)       => true

  rule	sub_arraydim (d1,d2) => true &
 	subtype (t1,t2) => true
	---------------------------------------------------------
	subtype(T_ARRAY(d1,t1),T_ARRAY(d2,t2)) => true
	
	(* FIXME: Check state? *)
  rule	subtype_varlist(els1, els2) => true
	-----------------------------------
	subtype(T_COMPLEX(st1,els1), T_COMPLEX(st2,els2)) => true

	(* default *)
  axiom	subtype(_,_) => false

end

(** FIXME: Incorporate `sub_arraydim' in `subtype' *)

relation sub_arraydim : (ArrayDim, ArrayDim) => bool =

  axiom	sub_arraydim (NODIM,NODIM) => true

  rule	sub_arraydim (d1,d2) => true
	---------------------------------------
	sub_arraydim (DIM(_,d1),DIM(NONE,d2)) => true

  rule	i1 = i2 &
 	sub_arraydim (d1,d2) => true
	---------------------------------------
	sub_arraydim (DIM(SOME(i1),d1),DIM(SOME(i2),d2)) => true

	(* default *)
  axiom	sub_arraydim (_,_) => false

end

(** relation: subtype_varlist
 **
 ** This relation checks if the `Var' list in the first list is a
 ** subset of the list in the second argument.  More precisely, it
 ** checks if, for each `Var' in the second list there is a `Var' in
 ** the first list with a type that is a subtype of the `Var' in the
 ** second list.
 **)

relation subtype_varlist : (Var list, Var list) => bool =

  axiom	subtype_varlist(_, []) => true

  rule	varlist_lookup(l,n) => VAR(_,_,_,t1,_) &
	subtype(t1,t2) => true &
	subtype_varlist(l,vs) => true
	-----------------------------
	subtype_varlist(l, VAR(n,_,_,t2,_)::vs) => true

	(* default *)
  axiom	subtype_varlist(_,_) => false

end

(** relation: varlist_lookup
 **
 ** Given a list of `Var' and a name, this relation finds any `Var'
 ** with the given name.
 **)

relation varlist_lookup : (Var list, Ident) => Var =

  rule	n = name
	--------
	varlist_lookup((v as VAR(n,_,_,_,_))::_, name) => v

  rule	varlist_lookup(vs, name) => v
	-----------------------------
	varlist_lookup(v::vs, name) => v

end

(** relation: same_type
 **
 ** FIXME: An half-hearted type equivalence relation.
 **)

relation same_type : (Type, Type) => bool =
	
  axiom	same_type (T_INTEGER,T_INTEGER) => true
  axiom	same_type (T_REAL,T_REAL)       => true
  axiom	same_type (T_STRING,T_STRING)   => true
  axiom	same_type (T_BOOL,T_BOOL)       => true

  rule	same_arraydim (d1,d2) => true & same_type (t1,t2) => true
	---------------------------------------------------------
	same_type (T_ARRAY(d1,t1),T_ARRAY(d2,t2)) => true
	
	(* FIXME: Check state? *)
  rule	same_type_c(els1, els2) => true
	-------------------------------
	same_type(T_COMPLEX(st1,els1), T_COMPLEX(st2,els2)) => true

	(* default *)
  axiom	same_type (_,_) => false

end

(**)

relation same_arraydim : (ArrayDim, ArrayDim) => bool =

  axiom	same_arraydim (NODIM,NODIM) => true

  rule	i1 = i2 & same_arraydim (d1,d2) => true
	---------------------------------------
	same_arraydim (DIM(i1,d1),DIM(i2,d2)) => true

	(* default *)
  axiom	same_arraydim (_,_) => false

end

(**)

relation same_type_c : (Var list, Var list) => bool =

  axiom same_type_c([], []) => true

  rule  pick(xs2,n) => (xs2',attr,t2) &
	same_type(t1,t2) => true &
	same_type_c(xs1,xs2') => true
	---------------------
	same_type_c(VAR(n,_,_,t1,_)::xs1, xs2) => true

	(* default *)
  axiom	same_type_c(_,_) => false

end

(** relation: pick *)

relation pick : (Var list, Ident)
	  => (Var list, Absyn.VarAttr, Type) =

  rule  n1 = n2
	-------
	pick(VAR(n1,attr,_,ty,_)::xs,n2) => (xs,attr,ty)

  rule  pick(xs,n) => (xs',attr,ty)
	---------------------
	pick(_::xs,n) => (xs',attr,ty)

end

(** relation: lookup_component
 **
 ** This relation finds a subcomponent by name.
 **)

relation lookup_component : (Type, Ident) => Var =

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component(T_COMPLEX(st,cs), id) => v

  rule	print "# Can't lookup components in arrays\n"
	------------------------------
	lookup_component(T_ARRAY(dim,t), id) => fail

  rule	print "- Looking up " &
	print id &
	print " in noncomplex type\n"
	-----------------------------------------
	lookup_component(_, id) => fail

end

(**)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as VAR(n,_,_,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: known_type
 **
 ** When a class is instantiated, the restriction state machin will
 ** have reached its final state.  Such a state is here used to
 ** construct a `Types.Type' object.  If the state indicates that the
 ** instantiated class was one of the primitive types, the
 ** corresponding type constructor is used.  Otherwise, one of the
 ** constructors `T_ARRAY' and `T_COMPLEX' is used.
 **)

relation known_type : (ClassInf.State, Absyn.ArrayDim) => Type =

  rule	known_type (st, []) => t &
	mk_arraydim dims => dims'
	-------------------------
	known_type (st, dims as (_::_)) => T_ARRAY(dims',t)

  axiom	known_type (ClassInf.TYPE_INTEGER(_),[]) => T_INTEGER
  axiom	known_type (ClassInf.TYPE_REAL(_),[])    => T_REAL
  axiom	known_type (ClassInf.TYPE_STRING(_),[])  => T_STRING
  axiom	known_type (ClassInf.TYPE_BOOL(_),[])    => T_BOOL

	(* FIXME *)
  axiom	known_type (state,[])                    => T_COMPLEX(state,[])

  rule	print "- known_type failed\n"
	-----------------------------
	known_type (_,_) => fail

end

(** relation: mk_arraydim *)

relation mk_arraydim : Absyn.ArrayDim => ArrayDim =

  axiom	mk_arraydim [] => NODIM

  rule	mk_arraydim ds => ds'
	(** FIXME: calculate d *)
	---------------------
	mk_arraydim d::ds => DIM(NONE,ds')

end

(** relation: lift_array
 **
 ** This relation turns a type into an array of that type.  If the
 ** type already is an array, aonther dimension is simply added.
 **)

relation lift_array : (Type,int option) => Type =

  axiom	lift_array (T_ARRAY(dim,ty),i) => T_ARRAY(DIM(i,dim),ty)
  axiom	lift_array (ty,i) => T_ARRAY(DIM(i,NODIM),ty)

end

(** relation: unlift_array
 **
 ** This relation turns an array of a type into that type.
 **)

relation unlift_array : Type => Type =

  axiom	unlift_array T_ARRAY(DIM(_,NODIM),ty) => ty
  axiom	unlift_array T_ARRAY(DIM(_,dim),ty) => T_ARRAY(dim,ty)

end

(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `composite'.  The actual code is expluded from the report.
 **)

(*!ignorecode*)

relation print_type : Type => () =

  rule	print "Integer"
	---------------
	print_type T_INTEGER

  rule	print "Real"
	------------
	print_type T_REAL

  rule	print "String"
	--------------
	print_type T_STRING

  rule	print "Boolean"
	---------------
	print_type T_BOOL

  rule	print "composite"
	-----------------
	print_type T_COMPLEX(_,_)

  rule	print "array[" & print_arraydim dim & print "] of " &
	print_type t
	------------
	print_type T_ARRAY(dim,t)

  rule	print "function(" & print_params params & print " => " &
	print_type restype & print ")"
	------------------------------
	print_type T_FUNCTION(params,restype)

  rule	print "#NOTYPE#"
	----------------
	print_type T_NOTYPE

end

relation print_arraydim =

  axiom	print_arraydim NODIM

  rule	print ":"
	---------
	print_arraydim DIM(NONE,NODIM)

  rule	int_string i => s & print s
	---------------------------
	print_arraydim DIM(SOME(i),NODIM)

  rule	print ":," & print_arraydim(d)
	------------------------------
	print_arraydim DIM(NONE,d)

  rule	int_string i => s & print s & print "," & print_arraydim(d)
	-----------------------------------------------------------
	print_arraydim DIM(SOME(i),d)

end

relation print_params : FuncArg list => () =

  axiom	print_params []

  rule	print n & print " :: " & print_type t
	-------------------------------------
	print_params [(n,t)]

  rule	print n & print " :: " & print_type t &
	print " * " & print_params params
	---------------------------------
	print_params ((n,t)::params)

end

(*!includecode*)
