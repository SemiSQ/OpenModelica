
module Types :

  with "exp.rml"
  with "classinf.rml"

  type Restriction = ClassInf.Restriction

  datatype ArrayDim = NODIM
		    | ONEDIM of Exp.Subscript
		    | TWODIM of Exp.Subscript * Exp.Subscript

  type Ident = string
  type Var = (Ident * VarAttr * Type)
  datatype Type = TYPE of ClassInf.State * Var list
  datatype VarType = VAR | PARAM | CONST
  datatype Direction = INPUT | OUTPUT | BIDIR
  datatype VarAttr = ATTR of ArrayDim
			   * bool	(* flow *)
			   * VarType	(* parameter *)
			   * Direction

  relation same_type : (Type, Type) => ()
  relation lookup_component : (Type, Ident) => Var

end

relation pick : (Var list, Ident)
	  => (Var list, VarAttr, Type) =

  rule  n1 = n2
	-------
	pick((n1,attr,ty)::xs,n2) => (xs,attr,ty)

  rule  pick(xs,n) => (xs',attr,ty)
	---------------------
	pick(_::xs,n) => (xs',attr,ty)

end

relation same_type_c : (Var list, Var list) => () =

  axiom same_type_c([], [])

  rule  pick(xs2,n) => (xs2',attr,t2) &
	same_type(t1,t2) &
	same_type_c(xs1,xs2')
	---------------------
	same_type_c((n,_,t1)::xs1, xs2)

end

and same_type : (Type, Type) => () =

	(* FIXME: Check state? *)
  rule  same_type_c(els1, els2)
	-----------------------
	same_type(TYPE(st1,els1), TYPE(st2,els2))

end

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as (n,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

relation lookup_component : (Type, Ident) => Var =

  rule  print "# trying to lookup in builtin type " & print n & print "\n"
	------------------------------------------------------------------
	lookup_component(TYPE(ClassInf.PREDEFINED(n),_),_) => fail

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component(TYPE(st,cs), id) => v

end
