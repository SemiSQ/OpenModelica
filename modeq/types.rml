
module Types :

  with "exp.rml"

  datatype ArrayDim = NODIM
		    | ONEDIM of Exp.Subscript
		    | TWODIM of Exp.Subscript * Exp.Subscript

  type Ident = string
  type Var = (Ident * VarAttr * Type)
  datatype Type = COMPLEX of  Var list
		| BUILTIN of string
  datatype VarType = VAR | PARAM | CONST
  datatype Direction = INPUT | OUTPUT | BIDIR
  datatype VarAttr = ATTR of ArrayDim
			   * bool	(* flow *)
			   * VarType	(* parameter *)
			   * Direction

  relation same_type : (Type, Type) => ()
  relation lookup_component : (Type, Ident) => Var

end

relation pick : (Var list, Ident) => (Var list, VarAttr, Type) =

  rule  n1 = n2
	-------
	pick((n1,attr,t)::xs,n2) => (xs,attr,t)

  rule  pick(xs,n) => (xs',attr,t)
	---------------------
	pick(_::xs,n) => (xs',attr,t)

end

relation same_type_c : (Var list, Var list) => () =

  axiom same_type_c([], [])

  rule  pick(xs2,n) => (xs2',attr,t2) &
	same_type(t1,t2) &
	same_type_c(xs1,xs2')
	---------------------
	same_type_c((n,_,t1)::xs1, xs2)

end

and same_type : (Type, Type) => () =

  rule  t1 = t2
	-------
	same_type(BUILTIN(t1), BUILTIN(t2))

  rule  same_type_c(els1, els2)
	-----------------------
	same_type(COMPLEX(els1), COMPLEX(els2))

end

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as (n,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

relation lookup_component : (Type, Ident) => Var =

  rule  print "# trying to lookup in builtin type " & print n & print "\n" &
	fail
	----
	lookup_component(BUILTIN(n),_)
	  => (("", ATTR(NODIM,false,VAR,BIDIR), BUILTIN("error")))

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component(COMPLEX(cs), id) => v

end
