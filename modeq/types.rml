(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 types.rml
 ** module:      Types
 ** description: Type system
 **
 ** RCS: $Id$
 **
 ** This file defines the type system.  It contains an RML type
 ** called `Type' which defines types.  It also contains relations for
 ** determining subtyping etc.
 **
 ** There are a few known problems with this module.  It currently
 ** depends on `SCode.Attributes', which in turn depends on
 ** `Absyn.ArrayDim'.  However, the only things used from those
 ** modules are constants that could be moved to their own modules.
 **)

module Types :

  with "classinf.rml"
  with "absyn.rml"
  with "exp.rml"
  with "values.rml"
  with "explode.rml"

  (** - Identifiers *)
  type Ident = string

  (** - Variables *)
  datatype Var = VAR of Ident			  (* name *)
		      * Attributes		  (* attributes *)
		      * bool	                  (* protected *)
		      * Type			  (* type *)
		      * Binding			  (* equation modification *)

  datatype Attributes = ATTR of bool	(* flow *)
			      * SCode.Accessibility
	  		      * SCode.Variability	(* parameter *)
			      * Absyn.Direction

  datatype Binding = UNBOUND
		   | EQBOUND of Exp.Exp * bool (* LS: bool for constant? *)
		   | VALBOUND of Values.Value

  (** - Types *)
  datatype Type = T_INTEGER of Var list
		| T_REAL of Var list
		| T_STRING of Var list
		| T_BOOL of Var list
		| T_ENUM 
		| T_ENUMERATION of string list * Var list
		| T_ARRAY of ArrayDim * Type
		| T_COMPLEX of ClassInf.State
			     * Var list
		| T_FUNCTION of FuncArg list * Type (* Only single-result *)
		| T_TUPLE of Type list (*PR. Used by functions who return multiple values. *)
		| T_NOTYPE


  datatype ArrayDim = DIM of int option

  type FuncArg = Ident * Type


  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(* Used by split_props  *)
  datatype Const = CONST of bool |
		   TUPLE_CONST  of Const list 

  datatype Properties = PROP of Type * (* type *)
				 bool (* if the type is a tuple, each element 
				          have a const flag. *)

(* Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Type * Const (* The elements might be 
							    tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)

  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)


  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)

  (** - Exported relations *)
  relation basic_type : Type => bool
  relation equivtypes : (Type, Type) => bool
  relation subtype : (Type, Type) => bool
  relation lookup_component : (Type, Ident) => Var
  relation lift_array : (Type,int option) => Type
  relation unlift_array : Type => Type
  relation make_array: (Type, Absyn.ArrayDim) => Type
  relation array_element_type : Type => Type
  relation print_type : Type => ()
  relation unparse_type : Type => string
  relation print_var : Var => ()
  relation print_binding : Binding => ()
  relation print_params : FuncArg list => () 
  relation print_farg: FuncArg => () 
  relation make_function_type : (Var list) => Type
  relation make_enumeration_type : (Var list) => Type
  relation is_parameter: Var => ()
  relation contain_real: Type list => bool
	 
  relation get_vars: (Var list, Var => () )  => Var list
  relation get_type_name: Type => string
  relation is_array : Type => bool
  relation is_input_attr : Attributes => bool
  relation is_output_attr : Attributes => bool
  relation is_bidir_attr : Attributes => bool
  relation ndims : Type => int
  relation get_dimension_sizes: Type => int list
  
  relation is_prop_const : Properties => bool
  relation get_prop_type : Properties => Type
  relation is_prop_array : Properties => bool

  relation elab_type : Type => Exp.Type
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list 
  relation match_with_promote : (Properties, Properties) => Properties 

  relation flatten_array_type : Type => (Type, int list)

end
