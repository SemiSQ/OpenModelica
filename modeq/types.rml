(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 types.rml
 ** module:      Types
 ** description: Type system
 **
 ** RCS: $Id$
 **
 ** This file defines the type system.  It contains an RML type
 ** called `Type' which defines types.  It also contains relations for
 ** determining subtyping etc.
 **
 ** There are a few known problems with this module.  It currently
 ** depends on `SCode.Attributes', which in turn depends on
 ** `Absyn.ArrayDim'.  However, the only things used from those
 ** modules are constants that could be moved to their own modules.
 **)

module Types :

  with "classinf.rml"
  with "absyn.rml"
  with "exp.rml"
  with "values.rml"
  with "explode.rml"

  (** - Identifiers *)
  type Ident = string

  (** - Variables *)
  datatype Var = VAR of Ident			  (* name *)
		      * Attributes		  (* attributes *)
		      * bool	                  (* protected *)
		      * Type			  (* type *)
		      * Binding			  (* equation modification *)

  datatype Attributes = ATTR of bool	(* flow *)
			      * SCode.Accessibility
	  		      * Absyn.Variability	(* parameter *)
			      * Absyn.Direction

  datatype Binding = UNBOUND
		   | EQBOUND of Exp.Exp * bool (* LS: bool for constant? *)
		   | VALBOUND of Values.Value

  (** - Types *)
  datatype Type = T_INTEGER
		| T_REAL
		| T_STRING
		| T_BOOL
		| T_ENUM
		| T_ENUMERATION of string list
		| T_ARRAY of ArrayDim * Type
		| T_COMPLEX of ClassInf.State
			     * Var list
		| T_FUNCTION of FuncArg list * Type (* Only single-result *)
		| T_TUPLE of Type list (*PR. Used by functions who return multiple values. *)
		| T_NOTYPE


  datatype ArrayDim = DIM of int option

  type FuncArg = Ident * Type

  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)

  (** - Exported relations *)
  relation basic_type : Type => bool
  relation equivtypes : (Type, Type) => bool
  relation subtype : (Type, Type) => bool
  relation lookup_component : (Type, Ident) => Var
  relation lift_array : (Type,int option) => Type
  relation unlift_array : Type => Type
  relation array_element_type : Type => Type
  relation print_type : Type => ()
  relation print_var : Var => ()
  relation print_binding : Binding => ()
  relation make_function_type : (Var list) => Type
  relation make_enumeration_type : (Var list) => Type
  relation is_parameter: Var => ()
  relation get_vars: (Var list, Var => () )  => Var list
  relation get_type_name: Type => string
  relation is_array : Type => bool
  relation ndims : Type => int
end

with "dump.rml"
with "debug.rml"


relation is_array : Type => bool =

  axiom	is_array T_ARRAY(_,_) => true
  axiom	is_array _ => false

end

relation ndims : Type => int =

  rule	ndims t => n &
	int_add(n,1) => n'
	---
	ndims T_ARRAY(_,t) => n'

  axiom ndims _ => 0

end

(** relation: basic_type
 **
 ** Test whether a type is one of the builtin types.
 **)

relation basic_type : Type => bool =

  axiom	basic_type T_INTEGER => true
  axiom	basic_type T_REAL => true
  axiom	basic_type T_STRING => true
  axiom	basic_type T_BOOL => true
  axiom	basic_type T_ARRAY(_,_) => false
  axiom	basic_type T_COMPLEX(_,_) => false

end

(** relation: equivtypes
 **
 ** This is the type equivalence relation.  It is defined in terms of
 ** the subtype relation.  Two types are considered equivalent if they
 ** are subtypes of each other.
 **)

relation equivtypes : (Type, Type) => bool =

  rule	subtype(t1, t2) => true &
	subtype(t2, t1) => true
	-----------------------
	equivtypes(t1, t2) => true

	(* default *)
  axiom	equivtypes(t1, t2) => false

end

(** relation: subtype
 **
 ** Is the first type a subtype of the second type?  This relation
 ** specifies the rules for subtyping in Modelica.
 **)

relation subtype : (Type, Type) => bool =
	
  axiom	subtype (T_INTEGER,T_INTEGER) => true
  axiom	subtype (T_REAL,T_REAL)       => true
  axiom	subtype (T_STRING,T_STRING)   => true
  axiom	subtype (T_BOOL,T_BOOL)       => true
  axiom	subtype (T_ENUM,T_ENUM)	      => true

  rule	subtype (t1,t2) => true
	-----------------------
	subtype(T_ARRAY(_,t1),T_ARRAY(DIM(NONE),t2)) => true
	
  rule	subtype (t1,t2) => true
	-----------------------
	subtype(T_ARRAY(DIM(NONE),t1),T_ARRAY(_,t2)) => true
	
  rule	i1 = i2 &
 	subtype (t1,t2) => true
	---------------------------------------------------------
	subtype(T_ARRAY(DIM(SOME(i1)),t1),T_ARRAY(DIM(SOME(i2)),t2)) => true
	
  rule	subtype_varlist(els1, els2) => true
	-----------------------------------
	subtype(T_COMPLEX(st1,els1), T_COMPLEX(st2,els2)) => true

	(* PR. Check of tuples, similar to complex. Just that
	 identifier name do not have to be checked. Only types are
	 checked. *)
  rule	subtype_typelist(type_list1,type_list2) => true
	-----------------------------------
	subtype(T_TUPLE(type_list1), T_TUPLE(type_list2)) => true

  axiom subtype(t1,t2) => false

(* What? If not subtye should return false. Doesn't mean no matching rule

  rule	Debug.fprint ("tytr", "subtype: no matching subtype rule.\n") &
	Debug.fcall ("tytr", print_type, t1) &
	Debug.fprint ("tytr", " <> ") &
	Debug.fcall ("tytr", print_type, t2) &
	Debug.fprint ("tytr", "\n")
	-----------------------------------
	subtype(t1,t2) => false
*)

end


(** PR. relation: subtype_typelist
 **
 ** This relation checks if the both `Type' lists matches types, element
 ** by element.
 **)

relation subtype_typelist: (Type list,Type list) => bool =

  axiom	subtype_typelist ([], []) => true

  rule	subtype(t1,t2) => true &
	subtype_typelist(rest1,rest2) => true		
	-----------------------------
	subtype_typelist(t1::rest1,t2::rest2) => true

	(* default *)
  axiom	subtype_typelist(_,_) => false


end

(** relation: subtype_varlist
 **
 ** This relation checks if the `Var' list in the first list is a
 ** subset of the list in the second argument.  More precisely, it
 ** checks if, for each `Var' in the second list there is a `Var' in
 ** the first list with a type that is a subtype of the `Var' in the
 ** second list.
 **)

relation subtype_varlist : (Var list, Var list) => bool =

  axiom	subtype_varlist(_, []) => true

  rule	varlist_lookup(l,n) => VAR(_,_,_,t1,_) &
	subtype(t1,t2) => true &
	subtype_varlist(l,vs) => true
	-----------------------------
	subtype_varlist(l, VAR(n,_,_,t2,_)::vs) => true

	(* default *)
  axiom	subtype_varlist(_,_) => false

end

(** relation: varlist_lookup
 **
 ** Given a list of `Var' and a name, this relation finds any `Var'
 ** with the given name.
 **)

relation varlist_lookup : (Var list, Ident) => Var =

  rule	n = name
	--------
	varlist_lookup((v as VAR(n,_,_,_,_))::_, name) => v

  rule	varlist_lookup(vs, name) => v
	-----------------------------
	varlist_lookup(v::vs, name) => v

end

(** relation: lookup_component
 **
 ** This relation finds a subcomponent by name.
 **)

relation lookup_component : (Type, Ident) => Var =

  rule	basic_type(t) => true &
	lookup_in_builtin(t,n) => v
	-------------------------
	lookup_component(t,n) => v

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component(T_COMPLEX(st,cs), id) => v

  rule	print "# Can't lookup components in arrays\n"
	------------------------------
	lookup_component(T_ARRAY(dim,t), id) => fail

  rule	print "- Looking up " &
	print id &
	print " in noncomplex type\n"
	-----------------------------------------
	lookup_component(_, id) => fail

end

(** relation: lookup_in_builtin
 **
 ** Since builtin types are not represented as T_COMPLEX, special care
 ** is needed to be able to lookup the attributes (`start' etc) in
 ** them.
 **
 ** This is not a complete solution.  The current way of mapping the
 ** both the Modelica type `Real' and the simple type `RealType' to
 ** `Types.T_REAL' is a bit problematic, since it doesn't make a
 ** difference between `Real' and `RealType', which makes the
 ** translator accept things like `x.start.start.start'.
 **)

relation lookup_in_builtin : (Type,Ident) => Var =

  axiom	lookup_in_builtin(T_REAL,"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, Absyn.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(t,"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, Absyn.PARAM, Absyn.BIDIR),
		 false, t, UNBOUND)

  axiom	lookup_in_builtin(T_INTEGER,"unit")
	  => VAR("unit",
		 ATTR(false, SCode.RW, Absyn.PARAM, Absyn.BIDIR),
		 false, T_STRING, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"unit")
	  => VAR("unit",
		 ATTR(false, SCode.RW, Absyn.PARAM, Absyn.BIDIR),
		 false, T_STRING, UNBOUND)

	(* The rest of them should also be added *)

end

(** relation: lookup_component2
 **
 ** This relation finds a named `Var' in a list of `Var's, comparing
 ** the name against the second argument to this relation.
 **)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as VAR(n,_,_,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: lift_array
 **
 ** This relation turns a type into an array of that type.  If the
 ** type already is an array, aonther dimension is simply added.
 **)

relation lift_array : (Type,int option) => Type =

  rule	(*print("\nDebug: lifts the array.") 
*)	-------------------
	lift_array (ty,i) => T_ARRAY(DIM(i),ty)
(* PR  axiom	lift_array (ty,i) => T_ARRAY(DIM(i),ty) *)

end

(** relation: unlift_array
 **
 ** This relation turns an array of a type into that type.
 **)

relation unlift_array : Type => Type =

  axiom	unlift_array T_ARRAY(DIM(_),ty) => ty

end

(** relation: array_element_type
 **
 ** This relation turns an array into the element type
 ** of the array.
 **)

relation array_element_type : Type => Type =

  rule	array_element_type(ty) => ty'
	------------------------------
	array_element_type T_ARRAY(DIM(_),ty) => ty'

  axiom	array_element_type t => t

end

(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `composite'.  The actual code is expluded from the report.
 **)

(*!ignorecode*)

relation print_type : Type => () =

  rule	print "Integer"
	---------------
	print_type T_INTEGER

  rule	print "Real"
	------------
	print_type T_REAL

  rule	print "String"
	--------------
	print_type T_STRING

  rule	print "Boolean"
	---------------
	print_type T_BOOL

  rule	print "EnumType"
	---------------
	print_type T_ENUM

  rule	print "enumeration(" &
	Dump.print_list(l,print, ", ") &
	print ")"
	-----------
	print_type T_ENUMERATION(l)

  rule	print "composite(" &
	ClassInf.print_state(st) &
	print ", (" &
	Dump.print_list(vars, print_var, ", ") &
	print "))"
	-----------------
	print_type T_COMPLEX(st,vars)

  rule	print "array[" & print_arraydim dim & print "] of " &
	print_type t
	------------
	print_type T_ARRAY(dim,t)

  rule	print "function(" & print_params params & print " => " &
	print_type restype & print ")"
	------------------------------
	print_type T_FUNCTION(params,restype)

  rule	print "(" & 
	Dump.print_list(tys, print_type, ", ") &
	print ")"
	---------
	print_type T_TUPLE(tys)

  rule	print "#NOTYPE#"
	----------------
	print_type T_NOTYPE

  rule	print "print_type failed!\n"
	---------------------------
	print_type _

end

relation print_arraydim: ArrayDim => () =

  rule	get_arraydim_str ad => s &
	print s
	-------
	print_arraydim ad

end


relation get_arraydim_str: ArrayDim => string =

  axiom	get_arraydim_str DIM(NONE) => ":"

  rule	int_string i => s
	---------------------------
	get_arraydim_str DIM(SOME(i)) => s

  axiom	get_arraydim_str _ =>  "#STRANGE#"

end


relation print_params : FuncArg list => () =

  axiom	print_params []

  rule	print n & print " :: " & print_type t
	-------------------------------------
	print_params [(n,t)]

  rule	print n & print " :: " & print_type t &
	print " * " & print_params params
	---------------------------------
	print_params ((n,t)::params)

end

(*!includecode*)

(* LS *)
relation print_var : Var => () =

  rule	print_type typ &
	print n
	-------
	print_var VAR(n, attr, prot, typ, bind)

end

(* LS *)
relation print_binding : Binding => () =

  rule	print "UNBOUND"
	---------------
	print_binding UNBOUND

  rule	print "EQBOUND: " &
	Exp.print_exp exp &
	Dump.print_select (f, " true", " false")
	----------------------------------------
	print_binding EQBOUND (exp,f)

  rule	print "VALBOUND: " &
	Values.print_val v
	--------------------
	print_binding VALBOUND (v)

end

(* LS *)
relation make_function_type: (Var list) => Type =

  rule	get_input_vars vl => invl &
	get_output_vars vl => outvl &
	make_fargs_list invl => fargs &
	make_return_type outvl => rettype &

	Debug.fprint ("ft", " <fargs: ") & 
	Debug.fprint_list ("ft", fargs, print_farg, ", ") &
	Debug.fprint ("ft", " >") &

	Debug.fprint ("ft", " <rettype: ") & 
	Debug.fcall ("ft", print_type, rettype) &
	Debug.fprint ("ft", " >")
	---------------------------------
	make_function_type vl => T_FUNCTION(fargs, rettype)

end

relation make_enumeration_type: (Var list) => Type =

  rule	make_enumeration_type(xs) => T_ENUMERATION(strs)
	---------------------------------
	make_enumeration_type (VAR(name,_,_,_,_)::xs) =>T_ENUMERATION(name::strs) 
  axiom	make_enumeration_type([]) => T_ENUMERATION([])
end

relation print_farg: FuncArg => () =

  rule	print_type ty & print " " & print n
	-----------------------------------
	print_farg ((n,ty))

end

(* LS *)
relation get_input_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_input_var) => vl'
	---------------------------------
	get_input_vars vl => vl'
end

(* LS *)
relation get_output_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_output_var) => vl'
	---------------------------------
	get_output_vars vl => vl'
end


(* LS *)
relation get_vars: (Var list, Var => () )  => Var list =

  axiom	get_vars ([],_) => []

  rule	cond(v) &
	get_vars (vl, cond) => vl'
	-------------------
	get_vars (v::vl, cond) => v::vl'

  rule	not cond(v) &
	get_vars (vl, cond) => vl'
	--------------------------
	get_vars (v::vl, cond) => vl'

end	


(* LS *)
relation is_input_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_input_var VAR(n, ATTR(fl,ac,var,Absyn.INPUT), false, ty, bnd)

end

relation is_output_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_output_var VAR(n, ATTR(fl,ac,var,Absyn.OUTPUT), false, ty, bnd)

end

(* LS *)
relation make_fargs_list: Var list => FuncArg list =

  axiom	make_fargs_list [] => []

  rule	(*is_input_var v &*)
	make_fargs_list vl => fargl
	------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd) :: vl) => ((n,ty)::fargl)

  rule	print "#-- Not an input var:" & print n
	---------------------------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd)::vl) => fail

end

(* LS *)
relation make_return_type: Var list => Type =

  axiom	make_return_type [] => T_NOTYPE

  rule	make_return_type_single var => ty
	---------------------------------
	make_return_type [var] => ty

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type vl => T_TUPLE(tys)

end

(* LS *)
relation make_return_type_single: Var => Type =

  axiom	make_return_type_single VAR(n,attr,pr,ty,bnd) => ty

end

(* LS *)
relation make_return_type_tuple: (Var list) => Type list =

  axiom	make_return_type_tuple [] => []

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type_tuple VAR(n,attr,pr,ty,bnd)::vl => ty::tys

end

(* LS *)
relation is_parameter: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_parameter VAR(n, ATTR(fl, ac, Absyn.PARAM, dir), false, ty, bnd)

end

relation get_type_name: Type => string =

  axiom	get_type_name T_INTEGER	=> "Integer"
  axiom	get_type_name T_REAL	=> "Real"
  axiom	get_type_name T_STRING	=> "String"
  axiom	get_type_name T_BOOL	=> "Boolean"

  rule	ClassInf.get_state_name st => n
	-------------------------------
	get_type_name T_COMPLEX(st, _) => n

  axiom	get_type_name _ => "Not nameable type or no type"


end

