(** file: types.rml
 **)

module Types :

  with "exp.rml"
  with "classinf.rml"

  type Restriction = ClassInf.Restriction

  (** - Array dimensions *)
  datatype ArrayDim = NODIM
		    | ONEDIM of Exp.Subscript
		    | TWODIM of Exp.Subscript * Exp.Subscript
  (** Variables in Modelica can be scalar, one-dimensional arrays, or *)
  (** two-dimensional matrices.  This datatype is used to indicate the *)
  (** dimensionality of a variable or a type definition. *)

  (** - Identifiers *)
  type Ident = string
  (** FIXME: This is declared in many places. *)

  (** - Variables *)
  type Var = (Ident * VarAttr * Type)
  (** I wonder why this goes here? *)

  (** - Types *)
  datatype Type = TYPE of ClassInf.State * Var list
  (** The `Type' datatype stores information about the type of an *)
  (** instantiated variable. The only information that is kept is the *)
  (** class inference state, and the subcomponents. *)

  (** - Variable attributes *)
  datatype VarAttr = ATTR of ArrayDim
			   * bool	(* flow *)
			   * VarType	(* parameter *)
			   * Direction
  datatype VarType = VAR | PARAM | CONST
  datatype Direction = INPUT | OUTPUT | BIDIR

  (** - Exported relations *)
  relation same_type : (Type, Type) => ()
  relation lookup_component : (Type, Ident) => Var
  relation known_type : ClassInf.State => Exp.Type

end

(** relation: same_type
 **)

relation same_type : (Type, Type) => () =
	
	(* FIXME: Check state? *)
  rule	same_type_c(els1, els2)
	-----------------------
	same_type(TYPE(st1,els1), TYPE(st2,els2))

end

relation same_type_c : (Var list, Var list) => () =

  axiom same_type_c([], [])

  rule  pick(xs2,n) => (xs2',attr,t2) &
	same_type(t1,t2) &
	same_type_c(xs1,xs2')
	---------------------
	same_type_c((n,_,t1)::xs1, xs2)

end

(** relation: pick *)

relation pick : (Var list, Ident)
	  => (Var list, VarAttr, Type) =

  rule  n1 = n2
	-------
	pick((n1,attr,ty)::xs,n2) => (xs,attr,ty)

  rule  pick(xs,n) => (xs',attr,ty)
	---------------------
	pick(_::xs,n) => (xs',attr,ty)

end

(** relation: lookup_component *)

relation lookup_component : (Type, Ident) => Var =

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component(TYPE(st,cs), id) => v

end

(**)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as (n,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: known_type *)

relation known_type : ClassInf.State => Exp.Type =

  axiom	known_type ClassInf.TYPE_INTEGER(_) => Exp.T_INTEGER
  axiom	known_type ClassInf.TYPE_REAL(_) => Exp.T_REAL
  axiom	known_type ClassInf.TYPE_STRING(_) => Exp.T_STRING
  axiom	known_type ClassInf.TYPE_BOOL(_) => Exp.T_BOOL
  axiom	known_type _ => Exp.T_OTHER

end
