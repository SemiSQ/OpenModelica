(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:        values.rml
 ** module:      Values
 ** description: Evaluated expression values
 **
 ** RCS: $Id$
 ** 
 ** The module `Values' contains data structures for representing
 ** constant Modelica values.  These include integer, real, string and
 ** boolean values, and also arrays of any dimensionality and type.
 ** Multidimensional arrays are represented as arrays of arrays.
 **
 ** The code is excluded from the report, since they convey no
 ** semantic information.
 **)

module Values :
with "exp.rml"
with "absyn.rml"
  datatype Value = INTEGER of int
		 | REAL of real
		 | STRING of string
		 | BOOL of bool
		 | ENUM of string
		 | ARRAY of Value list
		 | TUPLE of Value list 
		 | RECORD of Absyn.Path * (* record name *)
			     Value list * (* orderd set of values *)
			     Exp.Ident list(* comp names for each value*)
		 | CODE of Absyn.Code
		(* A record consist of value * Ident pairs *)

  relation val_string : Value => string
  relation print_val : Value => ()
  relation add_elementwise_arrayelt: (Value list, Value list) => Value list
  relation sub_elementwise_arrayelt: (Value list, Value list) => Value list
  relation sum_arrayelt: (Value list) => Value	  
  relation mult_scalar_arrayelt: (Value, Value list) => Value list
  relation mult_scalar_product: (Value list, Value list) => Value
  relation mult_matrix: (Value list,Value list) => Value list
  relation div_arrayelt_scalar: (Value, Value list) => Value list
  relation intlist_to_value : int list => Value
  relation is_array : Value => bool
  relation write_to_file_as_args: (Value list,string) => ()
  relation type_convert: (Exp.Type, Exp.Type,Value list) => Value list
  relation unparse_values: (Value list) => string
  relation reverse_matrix: (Value ) => Value
  relation write_ptolemyplot_dataset: (string,Value,string list,string) => int
end


relation type_convert: (Exp.Type, Exp.Type, Value list) => Value list =
  axiom type_convert(_,_,[]) => []

  rule	type_convert(from,to,vrest) => vallst &
	int_real (i) => rval
	------------------------------------
	type_convert(from as Exp.INT, to as Exp.REAL, INTEGER(i)::vrest) 
	  =>  REAL(rval)::vallst

  rule	type_convert(from,to,vrest) => vallst &
	real_int (r) => ival
	------------------------------------
	type_convert(from as Exp.REAL, to as Exp.INT, REAL(r)::vrest) 
	  =>  INTEGER(ival)::vallst

  rule	type_convert(from,to,vals) => vallst &
        type_convert(from,to,vrest) => vallst2 
	------------------------------------
	type_convert(from, to, ARRAY(vals)::vrest) 
	  =>  ARRAY(vallst)::vallst2
end

relation is_array: Value => bool = 
  axiom	is_array(INTEGER(_)) => false
  axiom	is_array(REAL(_)) => false
  axiom	is_array(STRING(_)) => false
  axiom	is_array(BOOL(_)) => false
  axiom is_array(TUPLE(_)) => false
  axiom	is_array(ARRAY(_)) => true	
end

relation unparse_values: (Value list) => string =

  rule	unparse_description([v]) => s1 &
	unparse_value_numbers([v]) => s2 &
	unparse_values(vallst) => s3 &
	Util.string_append_list([s1,s2,"\n",s3]) => str
	-----------------------------
	unparse_values(v::vallst) => str

  axiom	unparse_values([]) => ""
end

relation unparse_value_numbers: (Value list) => string =
	
  rule	unparse_value_numbers(lst) => s1 &
	unparse_value_numbers(xs) => s2 &
	string_append(s1,s2) => res 
	---------------------------
	unparse_value_numbers (ARRAY(lst)::xs)=> res
	
  rule	unparse_value_numbers(xs) => s1 &
	int_string(i) => istr &
	string_append(istr," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(INTEGER(i)::xs) => res

  rule	unparse_value_numbers(xs) => s1 &
	real_string(i) => istr &
	string_append(istr," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(REAL(i)::xs) => res

  rule	unparse_value_numbers(xs) => s1 &
	string_append(sval," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(STRING(sval)::xs) => res

	axiom unparse_value_numbers([]) => ""

end


relation unparse_description:(Value list) => string =

  rule	unparse_description(xs) => s1 &
	string_append("# i!\n",s1) => str 
	--------------------------------
	unparse_description(INTEGER(_)::xs)=> str

  rule	unparse_description(xs) => s1 &
	string_append("# r!\n",s1) => str
	-------------------------------
	unparse_description(REAL(_)::xs)=> str

  rule	unparse_description(xs) => s1 &
	string_length sval => slen &
	int_string slen => slenstr &
	Util.string_append_list(["# s[ 1 ", slenstr, "\n"]) => str
	-------------------------------
	unparse_description(STRING(sval)::xs)=> str
	
  rule	unparse_description(xs) => s1 &
	unparse_array_description(vallst) => s2 &
	string_append(s2,s1) => s4 &
	string_append(s4," \n") => str
	-------------------------------
	unparse_description(ARRAY(vallst)::xs)=> str

  axiom unparse_description([]) => ""
end

relation unparse_array_description:(Value list) => string  =

  rule	unparse_prim_type (lst) => pt &
	string_append("# ",pt) => s1 &
	string_append(s1,"[") => s2 &
	unparse_num_dims(lst) => i1 &
	int_string(i1) => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," ") => s5 &
	unparse_dim_sizes(lst) => s6 &
	string_append(s5,s6) => str
	------------------
	unparse_array_description(lst) => str
end

relation unparse_prim_type: (Value list) => string =

  rule	unparse_prim_type(elts) => res
	------------------------------
	unparse_prim_type(ARRAY(elts)::_) => res
  axiom	unparse_prim_type(INTEGER(_)::_) => "i"
  axiom	unparse_prim_type(REAL(_)::_) => "r"
  axiom	unparse_prim_type(STRING(_)::_) => "s"
  axiom	unparse_prim_type(BOOL(_)::_) => "b"
  axiom	unparse_prim_type(_) => "error"
end

relation unparse_num_dims: (Value list) => int =
	
  rule	unparse_num_dims(vals) => i1 &
	int_add(i1,1) => res
	--------------------
	unparse_num_dims(ARRAY(vals)::_) => res

  axiom	unparse_num_dims(_) => 1
end

relation unparse_dim_sizes: (Value list) => string =

  rule	list_length(lst) => i1 &
	int_string(i1) => s1 &
	string_append(s1, " ") => s2 &
	unparse_dim_sizes(vals) => s3 &
	string_append(s2,s3) => res
	-------------------
	unparse_dim_sizes (lst as (ARRAY(vals)::_)) => res

  rule	list_length(lst) => len &
	int_string(len) => res 
	----------------------
	unparse_dim_sizes(lst) => res
end


relation write_to_file_as_args: (Value list,string) => () =
	
  rule	unparse_values(vallst) => str &
	System.write_file(filename,str) 
	-------------------------------
	write_to_file_as_args(vallst,filename)
end

relation add_elementwise_arrayelt: (Value list, Value list) => Value list =
	
  rule	add_elementwise_arrayelt(v1lst,v2lst) => reslst &
	add_elementwise_arrayelt(rest1,rest2) => res2 
	----------------------------------------------
	add_elementwise_arrayelt(ARRAY(v1lst)::rest1, ARRAY(v2lst)::rest2) 
	    => ARRAY(reslst)::res2
	    
  rule	int_add(v1,v2) => res &
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	add_elementwise_arrayelt(INTEGER(v1)::rest1,INTEGER(v2)::rest2) 
	    => INTEGER(res)::res2

  rule	real_add(v1,v2) => res &
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	add_elementwise_arrayelt(REAL(v1)::rest1,REAL(v2)::rest2) 
	    => REAL(res)::res2

  rule	string_append(v1,v2) => res & (* Addition of strings is string concatenation *)
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
 	add_elementwise_arrayelt(STRING(v1)::rest1,STRING(v2)::rest2) 
	    => STRING(res)::res2

  axiom	add_elementwise_arrayelt([],[]) => []

end

relation sub_elementwise_arrayelt: (Value list, Value list) => Value list =
	
  rule	sub_elementwise_arrayelt(v1lst,v2lst) => reslst &
	sub_elementwise_arrayelt(rest1,rest2) => res2 
	----------------------------------------------
	sub_elementwise_arrayelt(ARRAY(v1lst)::rest1, ARRAY(v2lst)::rest2) 
	    => ARRAY(reslst)::res2
	    
  rule	int_sub(v1,v2) => res &
	sub_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	sub_elementwise_arrayelt(INTEGER(v1)::rest1,INTEGER(v2)::rest2) 
	    => INTEGER(res)::res2

  rule	real_sub(v1,v2) => res &
	sub_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	sub_elementwise_arrayelt(REAL(v1)::rest1,REAL(v2)::rest2) 
	    => REAL(res)::res2

  axiom	sub_elementwise_arrayelt([],[]) => []
end

relation sum_arrayelt: (Value list) => Value =

  axiom	sum_arrayelt([INTEGER(v1)]) => INTEGER(v1)

  axiom	sum_arrayelt([REAL(v1)]) => REAL(v1)

  axiom	sum_arrayelt([ARRAY(v1)]) => ARRAY(v1)

  rule	sum_arrayelt(xs) => INTEGER(v1) &
	int_add(v1,v2) => v3
	--------------------
	sum_arrayelt(INTEGER(v2)::xs) => INTEGER(v3) 
	
  rule	sum_arrayelt(xs) => REAL(v1) &
	real_add(v1,v2) => v3
	--------------------
	sum_arrayelt(REAL(v2)::xs) => REAL(v3) 
	
  rule	sum_arrayelt(arr) => ARRAY(v1) &
	add_elementwise_arrayelt(v1,v2) => v3
	------------------------------------
	sum_arrayelt(arr as ARRAY(v2)::_) => ARRAY(v3)

end


relation mult_scalar_arrayelt: (Value, Value list) => Value list =

  rule	mult_scalar_arrayelt(sval,vals) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval,ARRAY(vals)::rest) => ARRAY(r1)::r2
 
  rule	int_mul(v1,v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as INTEGER(v1),INTEGER(v2)::rest) => INTEGER(r1)::r2

  rule	int_real(v2) => v2' &
	real_mul(v1,v2') => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as REAL(v1),INTEGER(v2)::rest) => REAL(r1)::r2

  rule	int_real(v1) => v1' &
	real_mul(v1',v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as INTEGER(v1),REAL(v2)::rest) => REAL(r1)::r2

  rule	real_mul(v1,v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as REAL(v1),REAL(v2)::rest) => REAL(r1)::r2

	axiom mult_scalar_arrayelt(_,[]) => []
end

relation mult_scalar_product: (Value list, Value list) => Value =
	
  rule	int_mul(v1,v2) => r1 &
	mult_scalar_product(v1lst,v2lst) => INTEGER(r2) & 
	int_add(r1,r2) => res	
	------------------------------------
	mult_scalar_product (INTEGER(v1)::(v1lst as (_::_)),INTEGER(v2)::(v2lst as (_::_)))
	    => INTEGER(res)

  rule	int_mul(v1,v2) => res 
	------------------------------------
	mult_scalar_product ([INTEGER(v1)],[INTEGER(v2)]) 
	    => INTEGER(res)

  rule	real_mul(v1,v2) => r1 &
	mult_scalar_product(v1lst,v2lst) => REAL(r2) &
	real_add(r1,r2) => res	
	------------------------------------
	mult_scalar_product (REAL(v1)::(v1lst as (_::_)),REAL(v2)::(v2lst as (_::_)))
	    => REAL(res)

  rule	real_mul(v1,v2) => res 
	------------------------------------
	mult_scalar_product ([REAL(v1)],[REAL(v2)]) 
	    => REAL(res)

  rule	mult_scalar_product (v2lst,vlst) => sres &
	mult_scalar_product (rest,vlst) => ARRAY(vres) 
	---------------------------------------------
	mult_scalar_product (ARRAY(v2lst)::rest, vlst as (INTEGER(_)::_)) 
	    => ARRAY(sres::vres)

  axiom	mult_scalar_product([],INTEGER(_)::_) => ARRAY([])

  rule	mult_scalar_product (v2lst,vlst) => sres &
	mult_scalar_product (rest,vlst) => ARRAY(vres) 
	---------------------------------------------
	mult_scalar_product (ARRAY(v2lst)::rest, vlst as (REAL(_)::_)) 
	    => ARRAY(sres::vres)

  axiom	mult_scalar_product([],REAL(_)::_) => ARRAY([])


  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => v &
	mult_scalar_product(vlst,mat') => ARRAY(vals)
	---------------------------------------------
	mult_scalar_product(vlst  as (INTEGER(_)::_), mat as (ARRAY(_::_::_)::_)) 
	    => ARRAY(v::vals)

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => INTEGER(v) 
	---------------------------------------------
	mult_scalar_product(vlst  as (INTEGER(_)::_), mat as (ARRAY([_])::_)) 
	    => ARRAY([INTEGER(v)])

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => v &
	mult_scalar_product(vlst,mat') => ARRAY(vals)
	---------------------------------------------
	mult_scalar_product(vlst  as (REAL(_)::_), mat as (ARRAY(_::_::_)::_)) 
	    => ARRAY(v::vals)

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => REAL(v) 
	---------------------------------------------
	mult_scalar_product(vlst  as (REAL(_)::_), mat as (ARRAY([_])::_)) 
	    => ARRAY([REAL(v)])

  rule	Print.print_buf "mult_scalar_product failed\n lst1 len:" &
	list_length(lst1) => len &
	int_string(len) => lenstr &
	Print.print_buf lenstr & Print.print_buf "lst2 len:" &
	list_length(lst2) => len2 &
	int_string(len2) => len2str & 
	Print.print_buf len2str & Print.print_buf "\n" 
	--------------------------
	mult_scalar_product(lst1,lst2) => fail
end

relation mult_matrix: (Value list,Value list) => Value list =
	
  rule	mult_scalar_product(v1lst,m2) => res1 &
	mult_matrix(rest1,m2) => res2
	-----------------------------
	mult_matrix(m1 as (ARRAY(v1lst)::rest1),m2 as (ARRAY(_)::_)) => res1::res2
	
  axiom	 mult_matrix([],_) => []
	
end


relation div_arrayelt_scalar: (Value, Value list) => Value list =

  rule	v1 = 0.0 &
	Print.print_error_buf "# Error, division by zero.\n" 
	------------------------------------
	div_arrayelt_scalar (sval as REAL(v1),_) => fail
	
  rule	v1 = 0 &
	Print.print_error_buf "# Error, division by zero.\n" 
	------------------------------------
	div_arrayelt_scalar (sval as INTEGER(v1),_) => fail
	
  rule	div_arrayelt_scalar(sval,vals) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval,ARRAY(vals)::rest) => ARRAY(r1)::r2
 
  rule	int_div(v2,v1) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as INTEGER(v1),INTEGER(v2)::rest) => INTEGER(r1)::r2


  rule	int_real(v2) => v2' &
	real_div(v2',v1) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as REAL(v1),INTEGER(v2)::rest) => REAL(r1)::r2
 
  rule	int_real(v1) => v1' &
	real_div(v2,v1') => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as INTEGER(v1),REAL(v2)::rest) => REAL(r1)::r2

  rule	real_div(v2,v1) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as REAL(v1),REAL(v2)::rest) => REAL(r1)::r2

	axiom div_arrayelt_scalar(_,[]) => []
end



(** This relation takes a Value list representing a matrix and strips the first column of the matrix, i.e. for each sub list it removes the first element. Returning both the stripped column and the resulting matrix.**)
relation matrix_strip_first_column: Value list => (Value,Value list) =

  rule	matrix_strip_first_column(rest) => (ARRAY(resl),resl2)
	---------------------------------------------------
	matrix_strip_first_column (ARRAY(v1::vrest)::rest) 
	    => (ARRAY(v1::resl),ARRAY(vrest)::resl2)

  axiom	matrix_strip_first_column( []) => (ARRAY([]),[])
end

relation intlist_to_value : int list => Value =

  axiom	intlist_to_value([]) => ARRAY([])

  rule	intlist_to_value(lst) => ARRAY(res)
	-----------------------------------
	intlist_to_value(i::lst) => ARRAY(INTEGER(i)::res)
end


with "print.rml"
with "system.rml"
with "util.rml"
with "dump.rml"

(*!ignorecode*) 

(** relation: val_string
 **
 ** This relation returns a textual representation of a value.
 **)

relation val_string : Value => string =

  rule	int_string n => s
	-----------------
	val_string INTEGER(n) => s

  rule	real_string x => s
	------------------
	val_string REAL(x) => s

  rule	Util.string_append_list(["\"",s,"\""]) => s'
	--------------------------
	val_string STRING(s) => s'

  axiom	val_string BOOL(false) => "false"
  axiom	val_string BOOL(true) => "true"

  rule	val_list_string vs => s &
	string_append("{",s) => s' &
	string_append(s',"}") => s''
	----------------------------
	val_string ARRAY(vs) => s''

  rule	val_list_string vs => s &
	string_append("(",s) => s' &
	string_append(s',")") => s''
	----------------------------
	val_string TUPLE(vs) => s''

  rule	val_record_string(r) => s &
	Util.string_append_list(["record\n",s,"\n end record"]) => res
	---------------------------
	val_string (r as RECORD(_,_,_)) => res

  rule	Dump.print_code_str(c) => res &
	Util.string_append_list(["Code(",res,")"]) => res'
	-----------------------
	val_string (CODE(c)) => res'

  rule	Print.print_buf "- val_string failed\n"
	-----------------------------
	val_string _ => fail

end

(** relation: val_record_string
 **
 ** This relation returns a textual representation of a record,
 separating each value with a comma.
 **)
relation val_record_string: Value => string =

  axiom	val_record_string(RECORD(cname,[],[])) => ""

  rule	val_string(x) => s1 &
	val_record_string(RECORD(cname,xs,ids))=> s2 &
	Util.string_append_list([id, " = ",s1,",\n",s2]) => res
	------------------------------------
	val_record_string(RECORD(cname,x::(xs as _::_),id::(ids as _::_))) => res

  rule	val_string(x) => s1 &
	val_record_string(RECORD(cname,xs,ids))=> s2 &
	Util.string_append_list(["    ", id, " = ",s1,"\n",s2]) => res
	------------------------------------
	val_record_string(RECORD(cname,x::xs,id::ids)) => res
end

(** relation: val_list_string
 **
 ** This relation returns a textual representation of a list of
 ** values, separating each value with a comman.
 **)

relation val_list_string : Value list => string =

  axiom	val_list_string [] => ""

  rule	val_string v => s
	-----------------
	val_list_string [v] => s

  rule	val_string v => s &
	val_list_string vs => s' &
	string_append (s,",") => s'' &
	string_append (s'',s') =>s'''
	------------------------------
	val_list_string v::vs => s'''

  rule	Print.print_buf "- val_list_string failed\n"
	----------------------------------
	val_list_string _ => fail

end

relation write_ptolemyplot_dataset: (string,Value,string list,string ) 
	  => int =

  rule	unparse_ptolemy_values(time,rest,varnames) => datasets &
	Util.string_append_list(["#Ptolemy Plot generated by OpenModelica\n",
				 "TitleText: ",message,"\n",
				 datasets])=> str &
	System.write_file(filename,str) => ()
	------------------------------------
	write_ptolemyplot_dataset(filename,ARRAY(time::rest),timevar::varnames,message) => 0
end

relation unparse_ptolemy_values: (Value, Value list,string list) => string =
  axiom	unparse_ptolemy_values(_,[],_) => ""

  rule	unparse_ptolemy_set(time,s1,v1) => str &
	unparse_ptolemy_values(time,xs,vs) => str2 &
	string_append(str,str2) => res
	------------------------------
	unparse_ptolemy_values(time,s1::xs,v1::vs) => res
end

relation unparse_ptolemy_set: (Value, Value, string) => string =
	
  rule	unparse_ptolemy_set_2(v1,v2) => str &
	Util.string_append_list(["DataSet: ",varname,"\n",str]) => res 
	------------------
	unparse_ptolemy_set(v1,v2,varname) => res
end

relation unparse_ptolemy_set_2: (Value,Value) => string =

  axiom	unparse_ptolemy_set_2 (ARRAY([]),ARRAY([])) => ""

  rule	val_string(v1) => s1 &
	val_string(v2) => s2 &
	unparse_ptolemy_set_2(ARRAY(v1s),ARRAY(v2s)) => res &
	Util.string_append_list([s1,",",s2,"\n",res]) => res'
	----------------------------------------------------
	unparse_ptolemy_set_2 (ARRAY(v1::v1s),ARRAY(v2::v2s)) => res'
end
(* Reverses each line and each row of a matrix.
 Implementation reverses all dimensions...*)
relation reverse_matrix: Value => Value =


  rule	Util.list_map(lst,reverse_matrix) => lst' &
	list_reverse(lst') => lst''
	-----------------------------------
	reverse_matrix(ARRAY(lst)) => ARRAY(lst'')

  axiom	reverse_matrix(value) => value

end

(** relation: print_val
 **
 ** This relation prints a value.
 **)

relation print_val : Value => () =

  rule	val_string v => s &
	Print.print_buf s
	-------
	print_val v

end

(*!includecode*)
