// name: PlanarMechanicsForTesting.Examples.* [instantiateModel]
// status: correct
// provided by Dirk Zimmer with changes from Francesco Casella
//


loadModel(Modelica, {"3.1"}); getErrorString();
loadFile("PlanarMechanicsForTesting.mo"); getErrorString();

instantiateModel(PlanarMechanicsForTesting.Examples.FreeBody); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.Pendulum); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.DoublePendulum); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.CounterSpin); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.CraneCrab); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.ControlledCraneCrab); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.InvertedCraneCrab); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.WheelBasedCranCrab); getErrorString();

instantiateModel(PlanarMechanicsForTesting.Examples.PistonEngine); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.PistonEngine_DynamicStateSelection); getErrorString();

instantiateModel(PlanarMechanicsForTesting.Examples.KinematicLoop); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.KinematicLoop_DynamicStateSelection); getErrorString();

instantiateModel(PlanarMechanicsForTesting.Examples.TestIdealWheel); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.TestDryFrictionWheel); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.TestSlipBasedWheel); getErrorString();

instantiateModel(PlanarMechanicsForTesting.Examples.SingleTrackWithEngine); getErrorString();
instantiateModel(PlanarMechanicsForTesting.Examples.SimpleCarWithDifferentialGear); getErrorString();

// Result:
// true
// ""
// true
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.FreeBody
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   body.frame_a.t = 0.0;
//   body.frame_a.fy = 0.0;
//   body.frame_a.fx = 0.0;
// end PlanarMechanicsForTesting.Examples.FreeBody;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.Pendulum
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
// end PlanarMechanicsForTesting.Examples.Pendulum;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.DoublePendulum
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.2 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.01 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real revolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute1.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute1.animate = true \"enable Animation\";
//   parameter Boolean revolute1.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1],revolute1.cylinder.lengthDirection[2],revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = \"1\") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = \"1\") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = \"1\") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.4 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
//   revolute1.phi = revolute1.phi_start;
//   revolute1.w = revolute1.w_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.g[1] * body1.m = body1.a[1] * body1.m;
//   body1.f[2] + body1.g[2] * body1.m = body1.a[2] * body1.m;
//   body1.frame_a.t = body1.I * body1.z;
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1],revolute1.cylinder.R.T[1,2],revolute1.cylinder.R.T[1,3]},{revolute1.cylinder.R.T[2,1],revolute1.cylinder.R.T[2,2],revolute1.cylinder.R.T[2,3]},{revolute1.cylinder.R.T[3,1],revolute1.cylinder.R.T[3,2],revolute1.cylinder.R.T[3,3]}},{revolute1.cylinder.r_shape[1],revolute1.cylinder.r_shape[2],revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0,revolute1.cylinder.color[2] / 255.0,revolute1.cylinder.color[3] / 255.0,revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   revolute1.w = der(revolute1.phi);
//   revolute1.z = der(revolute1.w);
//   revolute1.t = 0.0;
//   revolute1.frame_a.x = revolute1.frame_b.x;
//   revolute1.frame_a.y = revolute1.frame_b.y;
//   revolute1.frame_a.phi + revolute1.phi = revolute1.frame_b.phi;
//   revolute1.frame_a.fx + revolute1.frame_b.fx = 0.0;
//   revolute1.frame_a.fy + revolute1.frame_b.fy = 0.0;
//   revolute1.frame_a.t + revolute1.frame_b.t = 0.0;
//   revolute1.frame_a.t = revolute1.t;
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   body.frame_a.t + fixedTranslation.frame_b.t + revolute1.frame_a.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy + revolute1.frame_a.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx + revolute1.frame_a.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   body1.frame_a.t + fixedTranslation1.frame_b.t = 0.0;
//   body1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   body1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   revolute1.frame_b.t + fixedTranslation1.frame_a.t = 0.0;
//   revolute1.frame_b.fy + fixedTranslation1.frame_a.fy = 0.0;
//   revolute1.frame_b.fx + fixedTranslation1.frame_a.fx = 0.0;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.x = revolute1.frame_a.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.y = revolute1.frame_a.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   body.frame_a.phi = revolute1.frame_a.phi;
//   fixedTranslation1.frame_a.x = revolute1.frame_b.x;
//   fixedTranslation1.frame_a.y = revolute1.frame_b.y;
//   fixedTranslation1.frame_a.phi = revolute1.frame_b.phi;
//   body1.frame_a.x = fixedTranslation1.frame_b.x;
//   body1.frame_a.y = fixedTranslation1.frame_b.y;
//   body1.frame_a.phi = fixedTranslation1.frame_b.phi;
// end PlanarMechanicsForTesting.Examples.DoublePendulum;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsForTesting.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsForTesting.Utilities.S_Func;
// 
// function PlanarMechanicsForTesting.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsForTesting.Utilities.TripleS_Func;
// 
// class PlanarMechanicsForTesting.Examples.CounterSpin
//   Real slipBasedRolling.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real slipBasedRolling.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real slipBasedRolling.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real slipBasedRolling.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real slipBasedRolling.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real slipBasedRolling.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real slipBasedRolling.R(quantity = \"Length\", unit = \"m\") = 0.1 \"Radius of the wheel\";
//   parameter Real slipBasedRolling.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.01 \"adhesion velocity\";
//   parameter Real slipBasedRolling.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"sliding velocity\";
//   parameter Real slipBasedRolling.mu_A = 0.4 \"friction coefficient at adhesion\";
//   parameter Real slipBasedRolling.mu_S = 0.15 \"friction coefficient at sliding\";
//   parameter Boolean slipBasedRolling.initialize = true \"Initialize Position and Velocity\";
//   parameter Real slipBasedRolling.x_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real slipBasedRolling.vx_start(quantity = \"Velocity\", unit = \"m/s\") = 2.0;
//   parameter Real slipBasedRolling.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real slipBasedRolling.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = -15.0;
//   parameter Boolean slipBasedRolling.animate = true \"enable Animation\";
//   Real slipBasedRolling.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real slipBasedRolling.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real slipBasedRolling.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real slipBasedRolling.vx(quantity = \"Velocity\", unit = \"m/s\") \"Velocity in x-direction\";
//   Real slipBasedRolling.N(quantity = \"Force\", unit = \"N\") \"normal force\";
//   Real slipBasedRolling.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   parameter String slipBasedRolling.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedRolling.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.cylinder.r[1](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.cylinder.r[2](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real slipBasedRolling.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Width of visual object\";
//   input Real slipBasedRolling.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Height of visual object\";
//   input Real slipBasedRolling.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedRolling.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real slipBasedRolling.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real slipBasedRolling.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real slipBasedRolling.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedRolling.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedRolling.cylinder.lengthDirection[1],slipBasedRolling.cylinder.lengthDirection[2],slipBasedRolling.cylinder.lengthDirection[3]});
//   protected Real slipBasedRolling.cylinder.e_x[1](unit = \"1\") = if noEvent(slipBasedRolling.cylinder.abs_n_x < 0.0000000001) then 1.0 else slipBasedRolling.cylinder.lengthDirection[1] / slipBasedRolling.cylinder.abs_n_x;
//   protected Real slipBasedRolling.cylinder.e_x[2](unit = \"1\") = if noEvent(slipBasedRolling.cylinder.abs_n_x < 0.0000000001) then 0.0 else slipBasedRolling.cylinder.lengthDirection[2] / slipBasedRolling.cylinder.abs_n_x;
//   protected Real slipBasedRolling.cylinder.e_x[3](unit = \"1\") = if noEvent(slipBasedRolling.cylinder.abs_n_x < 0.0000000001) then 0.0 else slipBasedRolling.cylinder.lengthDirection[3] / slipBasedRolling.cylinder.abs_n_x;
//   protected Real slipBasedRolling.cylinder.n_z_aux[1](unit = \"1\") = slipBasedRolling.cylinder.e_x[2] * slipBasedRolling.cylinder.widthDirection[3] - slipBasedRolling.cylinder.e_x[3] * slipBasedRolling.cylinder.widthDirection[2];
//   protected Real slipBasedRolling.cylinder.n_z_aux[2](unit = \"1\") = slipBasedRolling.cylinder.e_x[3] * slipBasedRolling.cylinder.widthDirection[1] - slipBasedRolling.cylinder.e_x[1] * slipBasedRolling.cylinder.widthDirection[3];
//   protected Real slipBasedRolling.cylinder.n_z_aux[3](unit = \"1\") = slipBasedRolling.cylinder.e_x[1] * slipBasedRolling.cylinder.widthDirection[2] - slipBasedRolling.cylinder.e_x[2] * slipBasedRolling.cylinder.widthDirection[1];
//   protected Real slipBasedRolling.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]},if noEvent(slipBasedRolling.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedRolling.cylinder.n_z_aux[2] ^ 2.0 + slipBasedRolling.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.cylinder.widthDirection[1],slipBasedRolling.cylinder.widthDirection[2],slipBasedRolling.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedRolling.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]})[1];
//   protected Real slipBasedRolling.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]},if noEvent(slipBasedRolling.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedRolling.cylinder.n_z_aux[2] ^ 2.0 + slipBasedRolling.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.cylinder.widthDirection[1],slipBasedRolling.cylinder.widthDirection[2],slipBasedRolling.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedRolling.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]})[2];
//   protected Real slipBasedRolling.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]},if noEvent(slipBasedRolling.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedRolling.cylinder.n_z_aux[2] ^ 2.0 + slipBasedRolling.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.cylinder.widthDirection[1],slipBasedRolling.cylinder.widthDirection[2],slipBasedRolling.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedRolling.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.cylinder.e_x[1],slipBasedRolling.cylinder.e_x[2],slipBasedRolling.cylinder.e_x[3]})[3];
//   protected output Real slipBasedRolling.cylinder.Form;
//   output Real slipBasedRolling.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedRolling.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.cylinder.Material;
//   protected output Real slipBasedRolling.cylinder.Extra;
//   parameter String slipBasedRolling.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedRolling.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim1.r[1](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim1.r[2](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = -slipBasedRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim1.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Length of visual object\";
//   input Real slipBasedRolling.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedRolling.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedRolling.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedRolling.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedRolling.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedRolling.rim1.lengthDirection[1],slipBasedRolling.rim1.lengthDirection[2],slipBasedRolling.rim1.lengthDirection[3]});
//   protected Real slipBasedRolling.rim1.e_x[1](unit = \"1\") = if noEvent(slipBasedRolling.rim1.abs_n_x < 0.0000000001) then 1.0 else slipBasedRolling.rim1.lengthDirection[1] / slipBasedRolling.rim1.abs_n_x;
//   protected Real slipBasedRolling.rim1.e_x[2](unit = \"1\") = if noEvent(slipBasedRolling.rim1.abs_n_x < 0.0000000001) then 0.0 else slipBasedRolling.rim1.lengthDirection[2] / slipBasedRolling.rim1.abs_n_x;
//   protected Real slipBasedRolling.rim1.e_x[3](unit = \"1\") = if noEvent(slipBasedRolling.rim1.abs_n_x < 0.0000000001) then 0.0 else slipBasedRolling.rim1.lengthDirection[3] / slipBasedRolling.rim1.abs_n_x;
//   protected Real slipBasedRolling.rim1.n_z_aux[1](unit = \"1\") = slipBasedRolling.rim1.e_x[2] * slipBasedRolling.rim1.widthDirection[3] - slipBasedRolling.rim1.e_x[3] * slipBasedRolling.rim1.widthDirection[2];
//   protected Real slipBasedRolling.rim1.n_z_aux[2](unit = \"1\") = slipBasedRolling.rim1.e_x[3] * slipBasedRolling.rim1.widthDirection[1] - slipBasedRolling.rim1.e_x[1] * slipBasedRolling.rim1.widthDirection[3];
//   protected Real slipBasedRolling.rim1.n_z_aux[3](unit = \"1\") = slipBasedRolling.rim1.e_x[1] * slipBasedRolling.rim1.widthDirection[2] - slipBasedRolling.rim1.e_x[2] * slipBasedRolling.rim1.widthDirection[1];
//   protected Real slipBasedRolling.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]},if noEvent(slipBasedRolling.rim1.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim1.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.rim1.widthDirection[1],slipBasedRolling.rim1.widthDirection[2],slipBasedRolling.rim1.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]})[1];
//   protected Real slipBasedRolling.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]},if noEvent(slipBasedRolling.rim1.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim1.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.rim1.widthDirection[1],slipBasedRolling.rim1.widthDirection[2],slipBasedRolling.rim1.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]})[2];
//   protected Real slipBasedRolling.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]},if noEvent(slipBasedRolling.rim1.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim1.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.rim1.widthDirection[1],slipBasedRolling.rim1.widthDirection[2],slipBasedRolling.rim1.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.rim1.e_x[1],slipBasedRolling.rim1.e_x[2],slipBasedRolling.rim1.e_x[3]})[3];
//   protected output Real slipBasedRolling.rim1.Form;
//   output Real slipBasedRolling.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedRolling.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim1.Material;
//   protected output Real slipBasedRolling.rim1.Extra;
//   parameter String slipBasedRolling.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedRolling.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedRolling.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedRolling.rim2.r[1](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim2.r[2](quantity = \"Length\", unit = \"m\") = slipBasedRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedRolling.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = -slipBasedRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedRolling.rim2.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedRolling.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedRolling.R \"Length of visual object\";
//   input Real slipBasedRolling.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedRolling.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedRolling.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedRolling.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedRolling.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedRolling.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedRolling.rim2.lengthDirection[1],slipBasedRolling.rim2.lengthDirection[2],slipBasedRolling.rim2.lengthDirection[3]});
//   protected Real slipBasedRolling.rim2.e_x[1](unit = \"1\") = if noEvent(slipBasedRolling.rim2.abs_n_x < 0.0000000001) then 1.0 else slipBasedRolling.rim2.lengthDirection[1] / slipBasedRolling.rim2.abs_n_x;
//   protected Real slipBasedRolling.rim2.e_x[2](unit = \"1\") = if noEvent(slipBasedRolling.rim2.abs_n_x < 0.0000000001) then 0.0 else slipBasedRolling.rim2.lengthDirection[2] / slipBasedRolling.rim2.abs_n_x;
//   protected Real slipBasedRolling.rim2.e_x[3](unit = \"1\") = if noEvent(slipBasedRolling.rim2.abs_n_x < 0.0000000001) then 0.0 else slipBasedRolling.rim2.lengthDirection[3] / slipBasedRolling.rim2.abs_n_x;
//   protected Real slipBasedRolling.rim2.n_z_aux[1](unit = \"1\") = slipBasedRolling.rim2.e_x[2] * slipBasedRolling.rim2.widthDirection[3] - slipBasedRolling.rim2.e_x[3] * slipBasedRolling.rim2.widthDirection[2];
//   protected Real slipBasedRolling.rim2.n_z_aux[2](unit = \"1\") = slipBasedRolling.rim2.e_x[3] * slipBasedRolling.rim2.widthDirection[1] - slipBasedRolling.rim2.e_x[1] * slipBasedRolling.rim2.widthDirection[3];
//   protected Real slipBasedRolling.rim2.n_z_aux[3](unit = \"1\") = slipBasedRolling.rim2.e_x[1] * slipBasedRolling.rim2.widthDirection[2] - slipBasedRolling.rim2.e_x[2] * slipBasedRolling.rim2.widthDirection[1];
//   protected Real slipBasedRolling.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]},if noEvent(slipBasedRolling.rim2.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim2.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.rim2.widthDirection[1],slipBasedRolling.rim2.widthDirection[2],slipBasedRolling.rim2.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]})[1];
//   protected Real slipBasedRolling.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]},if noEvent(slipBasedRolling.rim2.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim2.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.rim2.widthDirection[1],slipBasedRolling.rim2.widthDirection[2],slipBasedRolling.rim2.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]})[2];
//   protected Real slipBasedRolling.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]},if noEvent(slipBasedRolling.rim2.n_z_aux[1] ^ 2.0 + (slipBasedRolling.rim2.n_z_aux[2] ^ 2.0 + slipBasedRolling.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedRolling.rim2.widthDirection[1],slipBasedRolling.rim2.widthDirection[2],slipBasedRolling.rim2.widthDirection[3]} else if noEvent(abs(slipBasedRolling.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedRolling.rim2.e_x[1],slipBasedRolling.rim2.e_x[2],slipBasedRolling.rim2.e_x[3]})[3];
//   protected output Real slipBasedRolling.rim2.Form;
//   output Real slipBasedRolling.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedRolling.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedRolling.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedRolling.rim2.Material;
//   protected output Real slipBasedRolling.rim2.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.01 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.0005 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = false \"enable Animation\";
// initial equation
//   slipBasedRolling.phi = slipBasedRolling.phi_start;
//   slipBasedRolling.w = slipBasedRolling.w_start;
//   slipBasedRolling.frame_a.x = slipBasedRolling.x_start;
//   slipBasedRolling.vx = slipBasedRolling.vx_start;
// equation
//   slipBasedRolling.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedRolling.cylinder.shapeType);
//   slipBasedRolling.cylinder.rxvisobj[1] = slipBasedRolling.cylinder.R.T[1,1] * slipBasedRolling.cylinder.e_x[1] + slipBasedRolling.cylinder.R.T[2,1] * slipBasedRolling.cylinder.e_x[2] + slipBasedRolling.cylinder.R.T[3,1] * slipBasedRolling.cylinder.e_x[3];
//   slipBasedRolling.cylinder.rxvisobj[2] = slipBasedRolling.cylinder.R.T[1,2] * slipBasedRolling.cylinder.e_x[1] + slipBasedRolling.cylinder.R.T[2,2] * slipBasedRolling.cylinder.e_x[2] + slipBasedRolling.cylinder.R.T[3,2] * slipBasedRolling.cylinder.e_x[3];
//   slipBasedRolling.cylinder.rxvisobj[3] = slipBasedRolling.cylinder.R.T[1,3] * slipBasedRolling.cylinder.e_x[1] + slipBasedRolling.cylinder.R.T[2,3] * slipBasedRolling.cylinder.e_x[2] + slipBasedRolling.cylinder.R.T[3,3] * slipBasedRolling.cylinder.e_x[3];
//   slipBasedRolling.cylinder.ryvisobj[1] = slipBasedRolling.cylinder.R.T[1,1] * slipBasedRolling.cylinder.e_y[1] + slipBasedRolling.cylinder.R.T[2,1] * slipBasedRolling.cylinder.e_y[2] + slipBasedRolling.cylinder.R.T[3,1] * slipBasedRolling.cylinder.e_y[3];
//   slipBasedRolling.cylinder.ryvisobj[2] = slipBasedRolling.cylinder.R.T[1,2] * slipBasedRolling.cylinder.e_y[1] + slipBasedRolling.cylinder.R.T[2,2] * slipBasedRolling.cylinder.e_y[2] + slipBasedRolling.cylinder.R.T[3,2] * slipBasedRolling.cylinder.e_y[3];
//   slipBasedRolling.cylinder.ryvisobj[3] = slipBasedRolling.cylinder.R.T[1,3] * slipBasedRolling.cylinder.e_y[1] + slipBasedRolling.cylinder.R.T[2,3] * slipBasedRolling.cylinder.e_y[2] + slipBasedRolling.cylinder.R.T[3,3] * slipBasedRolling.cylinder.e_y[3];
//   slipBasedRolling.cylinder.rvisobj = slipBasedRolling.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedRolling.cylinder.R.T[1,1],slipBasedRolling.cylinder.R.T[1,2],slipBasedRolling.cylinder.R.T[1,3]},{slipBasedRolling.cylinder.R.T[2,1],slipBasedRolling.cylinder.R.T[2,2],slipBasedRolling.cylinder.R.T[2,3]},{slipBasedRolling.cylinder.R.T[3,1],slipBasedRolling.cylinder.R.T[3,2],slipBasedRolling.cylinder.R.T[3,3]}},{slipBasedRolling.cylinder.r_shape[1],slipBasedRolling.cylinder.r_shape[2],slipBasedRolling.cylinder.r_shape[3]});
//   slipBasedRolling.cylinder.size[1] = slipBasedRolling.cylinder.length;
//   slipBasedRolling.cylinder.size[2] = slipBasedRolling.cylinder.width;
//   slipBasedRolling.cylinder.size[3] = slipBasedRolling.cylinder.height;
//   slipBasedRolling.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedRolling.cylinder.color[1] / 255.0,slipBasedRolling.cylinder.color[2] / 255.0,slipBasedRolling.cylinder.color[3] / 255.0,slipBasedRolling.cylinder.specularCoefficient);
//   slipBasedRolling.cylinder.Extra = slipBasedRolling.cylinder.extra;
//   slipBasedRolling.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},-slipBasedRolling.phi,0.0);
//   slipBasedRolling.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedRolling.rim1.shapeType);
//   slipBasedRolling.rim1.rxvisobj[1] = slipBasedRolling.rim1.R.T[1,1] * slipBasedRolling.rim1.e_x[1] + slipBasedRolling.rim1.R.T[2,1] * slipBasedRolling.rim1.e_x[2] + slipBasedRolling.rim1.R.T[3,1] * slipBasedRolling.rim1.e_x[3];
//   slipBasedRolling.rim1.rxvisobj[2] = slipBasedRolling.rim1.R.T[1,2] * slipBasedRolling.rim1.e_x[1] + slipBasedRolling.rim1.R.T[2,2] * slipBasedRolling.rim1.e_x[2] + slipBasedRolling.rim1.R.T[3,2] * slipBasedRolling.rim1.e_x[3];
//   slipBasedRolling.rim1.rxvisobj[3] = slipBasedRolling.rim1.R.T[1,3] * slipBasedRolling.rim1.e_x[1] + slipBasedRolling.rim1.R.T[2,3] * slipBasedRolling.rim1.e_x[2] + slipBasedRolling.rim1.R.T[3,3] * slipBasedRolling.rim1.e_x[3];
//   slipBasedRolling.rim1.ryvisobj[1] = slipBasedRolling.rim1.R.T[1,1] * slipBasedRolling.rim1.e_y[1] + slipBasedRolling.rim1.R.T[2,1] * slipBasedRolling.rim1.e_y[2] + slipBasedRolling.rim1.R.T[3,1] * slipBasedRolling.rim1.e_y[3];
//   slipBasedRolling.rim1.ryvisobj[2] = slipBasedRolling.rim1.R.T[1,2] * slipBasedRolling.rim1.e_y[1] + slipBasedRolling.rim1.R.T[2,2] * slipBasedRolling.rim1.e_y[2] + slipBasedRolling.rim1.R.T[3,2] * slipBasedRolling.rim1.e_y[3];
//   slipBasedRolling.rim1.ryvisobj[3] = slipBasedRolling.rim1.R.T[1,3] * slipBasedRolling.rim1.e_y[1] + slipBasedRolling.rim1.R.T[2,3] * slipBasedRolling.rim1.e_y[2] + slipBasedRolling.rim1.R.T[3,3] * slipBasedRolling.rim1.e_y[3];
//   slipBasedRolling.rim1.rvisobj = slipBasedRolling.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedRolling.rim1.R.T[1,1],slipBasedRolling.rim1.R.T[1,2],slipBasedRolling.rim1.R.T[1,3]},{slipBasedRolling.rim1.R.T[2,1],slipBasedRolling.rim1.R.T[2,2],slipBasedRolling.rim1.R.T[2,3]},{slipBasedRolling.rim1.R.T[3,1],slipBasedRolling.rim1.R.T[3,2],slipBasedRolling.rim1.R.T[3,3]}},{slipBasedRolling.rim1.r_shape[1],slipBasedRolling.rim1.r_shape[2],slipBasedRolling.rim1.r_shape[3]});
//   slipBasedRolling.rim1.size[1] = slipBasedRolling.rim1.length;
//   slipBasedRolling.rim1.size[2] = slipBasedRolling.rim1.width;
//   slipBasedRolling.rim1.size[3] = slipBasedRolling.rim1.height;
//   slipBasedRolling.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedRolling.rim1.color[1] / 255.0,slipBasedRolling.rim1.color[2] / 255.0,slipBasedRolling.rim1.color[3] / 255.0,slipBasedRolling.rim1.specularCoefficient);
//   slipBasedRolling.rim1.Extra = slipBasedRolling.rim1.extra;
//   slipBasedRolling.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},1.5707963267948966 - slipBasedRolling.phi,0.0);
//   slipBasedRolling.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedRolling.rim2.shapeType);
//   slipBasedRolling.rim2.rxvisobj[1] = slipBasedRolling.rim2.R.T[1,1] * slipBasedRolling.rim2.e_x[1] + slipBasedRolling.rim2.R.T[2,1] * slipBasedRolling.rim2.e_x[2] + slipBasedRolling.rim2.R.T[3,1] * slipBasedRolling.rim2.e_x[3];
//   slipBasedRolling.rim2.rxvisobj[2] = slipBasedRolling.rim2.R.T[1,2] * slipBasedRolling.rim2.e_x[1] + slipBasedRolling.rim2.R.T[2,2] * slipBasedRolling.rim2.e_x[2] + slipBasedRolling.rim2.R.T[3,2] * slipBasedRolling.rim2.e_x[3];
//   slipBasedRolling.rim2.rxvisobj[3] = slipBasedRolling.rim2.R.T[1,3] * slipBasedRolling.rim2.e_x[1] + slipBasedRolling.rim2.R.T[2,3] * slipBasedRolling.rim2.e_x[2] + slipBasedRolling.rim2.R.T[3,3] * slipBasedRolling.rim2.e_x[3];
//   slipBasedRolling.rim2.ryvisobj[1] = slipBasedRolling.rim2.R.T[1,1] * slipBasedRolling.rim2.e_y[1] + slipBasedRolling.rim2.R.T[2,1] * slipBasedRolling.rim2.e_y[2] + slipBasedRolling.rim2.R.T[3,1] * slipBasedRolling.rim2.e_y[3];
//   slipBasedRolling.rim2.ryvisobj[2] = slipBasedRolling.rim2.R.T[1,2] * slipBasedRolling.rim2.e_y[1] + slipBasedRolling.rim2.R.T[2,2] * slipBasedRolling.rim2.e_y[2] + slipBasedRolling.rim2.R.T[3,2] * slipBasedRolling.rim2.e_y[3];
//   slipBasedRolling.rim2.ryvisobj[3] = slipBasedRolling.rim2.R.T[1,3] * slipBasedRolling.rim2.e_y[1] + slipBasedRolling.rim2.R.T[2,3] * slipBasedRolling.rim2.e_y[2] + slipBasedRolling.rim2.R.T[3,3] * slipBasedRolling.rim2.e_y[3];
//   slipBasedRolling.rim2.rvisobj = slipBasedRolling.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedRolling.rim2.R.T[1,1],slipBasedRolling.rim2.R.T[1,2],slipBasedRolling.rim2.R.T[1,3]},{slipBasedRolling.rim2.R.T[2,1],slipBasedRolling.rim2.R.T[2,2],slipBasedRolling.rim2.R.T[2,3]},{slipBasedRolling.rim2.R.T[3,1],slipBasedRolling.rim2.R.T[3,2],slipBasedRolling.rim2.R.T[3,3]}},{slipBasedRolling.rim2.r_shape[1],slipBasedRolling.rim2.r_shape[2],slipBasedRolling.rim2.r_shape[3]});
//   slipBasedRolling.rim2.size[1] = slipBasedRolling.rim2.length;
//   slipBasedRolling.rim2.size[2] = slipBasedRolling.rim2.width;
//   slipBasedRolling.rim2.size[3] = slipBasedRolling.rim2.height;
//   slipBasedRolling.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedRolling.rim2.color[1] / 255.0,slipBasedRolling.rim2.color[2] / 255.0,slipBasedRolling.rim2.color[3] / 255.0,slipBasedRolling.rim2.specularCoefficient);
//   slipBasedRolling.rim2.Extra = slipBasedRolling.rim2.extra;
//   slipBasedRolling.phi = slipBasedRolling.frame_a.phi;
//   slipBasedRolling.w = der(slipBasedRolling.phi);
//   slipBasedRolling.z = der(slipBasedRolling.w);
//   slipBasedRolling.vx = der(slipBasedRolling.frame_a.x);
//   slipBasedRolling.frame_a.y = slipBasedRolling.R;
//   slipBasedRolling.v_slip = slipBasedRolling.vx - slipBasedRolling.w * slipBasedRolling.R;
//   slipBasedRolling.N = -slipBasedRolling.frame_a.fy;
//   slipBasedRolling.frame_a.fx = slipBasedRolling.N * PlanarMechanicsForTesting.Utilities.TripleS_Func(slipBasedRolling.vAdhesion,slipBasedRolling.vSlide,slipBasedRolling.mu_A,slipBasedRolling.mu_S,slipBasedRolling.v_slip);
//   slipBasedRolling.frame_a.fx * slipBasedRolling.R = -slipBasedRolling.frame_a.t;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   slipBasedRolling.frame_a.t + body.frame_a.t = 0.0;
//   slipBasedRolling.frame_a.fy + body.frame_a.fy = 0.0;
//   slipBasedRolling.frame_a.fx + body.frame_a.fx = 0.0;
//   body.frame_a.x = slipBasedRolling.frame_a.x;
//   body.frame_a.y = slipBasedRolling.frame_a.y;
//   body.frame_a.phi = slipBasedRolling.frame_a.phi;
// end PlanarMechanicsForTesting.Examples.CounterSpin;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.CraneCrab
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.5 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -2.7925268031909;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = -1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real prismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   parameter Boolean prismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real damper.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real damper.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real damper.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real damper.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real damper.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real damper.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real damper.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real damper.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real damper.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real damper.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real damper.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real damper.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real damper.d(quantity = \"TranslationalDampingConstant\", unit = \"N.s/m\") = 5.0;
//   Real damper.r0[1](quantity = \"Length\", unit = \"m\");
//   Real damper.r0[2](quantity = \"Length\", unit = \"m\");
//   Real damper.d0[1];
//   Real damper.d0[2];
//   Real damper.vx(quantity = \"Velocity\", unit = \"m/s\");
//   Real damper.vy(quantity = \"Velocity\", unit = \"m/s\");
//   Real damper.v(quantity = \"Velocity\", unit = \"m/s\");
//   Real damper.f(quantity = \"Force\", unit = \"N\");
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
//   prismatic.s = prismatic.s_start;
//   prismatic.v = prismatic.v_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.e0[1] = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2];
//   prismatic.e0[2] = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2];
//   prismatic.r0[1] = prismatic.e0[1] * prismatic.s;
//   prismatic.r0[2] = prismatic.e0[2] * prismatic.s;
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * prismatic.e0[1] + prismatic.frame_a.fy * prismatic.e0[2] = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.g[1] * body1.m = body1.a[1] * body1.m;
//   body1.f[2] + body1.g[2] * body1.m = body1.a[2] * body1.m;
//   body1.frame_a.t = body1.I * body1.z;
//   damper.frame_a.x + damper.r0[1] = damper.frame_b.x;
//   damper.frame_b.y + damper.r0[2] = damper.frame_b.y;
//   damper.d0 = Modelica.Math.Vectors.normalize({damper.r0[1],damper.r0[2]},0.0000000000001);
//   der(damper.frame_a.x) + damper.vx = der(damper.frame_b.x);
//   der(damper.frame_a.y) + damper.vy = der(damper.frame_b.y);
//   damper.v = damper.vx * damper.d0[1] + damper.vy * damper.d0[2];
//   damper.f = (-damper.d) * damper.v;
//   damper.frame_a.fx = damper.d0[1] * damper.f;
//   damper.frame_a.fy = damper.d0[2] * damper.f;
//   damper.frame_a.t = 0.0;
//   damper.frame_a.fx + damper.frame_b.fx = 0.0;
//   damper.frame_a.fy + damper.frame_b.fy = 0.0;
//   damper.frame_a.t + damper.frame_b.t = 0.0;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   revolute.frame_a.t + prismatic.frame_b.t + body1.frame_a.t + damper.frame_b.t = 0.0;
//   revolute.frame_a.fy + prismatic.frame_b.fy + body1.frame_a.fy + damper.frame_b.fy = 0.0;
//   revolute.frame_a.fx + prismatic.frame_b.fx + body1.frame_a.fx + damper.frame_b.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   fixed.frame_a.t + prismatic.frame_a.t + damper.frame_a.t = 0.0;
//   fixed.frame_a.fy + prismatic.frame_a.fy + damper.frame_a.fy = 0.0;
//   fixed.frame_a.fx + prismatic.frame_a.fx + damper.frame_a.fx = 0.0;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   damper.frame_a.x = fixed.frame_a.x;
//   damper.frame_a.x = prismatic.frame_a.x;
//   damper.frame_a.y = fixed.frame_a.y;
//   damper.frame_a.y = prismatic.frame_a.y;
//   damper.frame_a.phi = fixed.frame_a.phi;
//   damper.frame_a.phi = prismatic.frame_a.phi;
//   body1.frame_a.x = damper.frame_b.x;
//   body1.frame_a.x = prismatic.frame_b.x;
//   body1.frame_a.x = revolute.frame_a.x;
//   body1.frame_a.y = damper.frame_b.y;
//   body1.frame_a.y = prismatic.frame_b.y;
//   body1.frame_a.y = revolute.frame_a.y;
//   body1.frame_a.phi = damper.frame_b.phi;
//   body1.frame_a.phi = prismatic.frame_b.phi;
//   body1.frame_a.phi = revolute.frame_a.phi;
// end PlanarMechanicsForTesting.Examples.CraneCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.ControlledCraneCrab
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 70.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 2.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 250.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.0 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real actuatedPrismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   parameter Boolean actuatedPrismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   Real angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real angleSensor.phi \"Absolute angle of flange\";
//   Real actuatedRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.69813170079773;
//   parameter Real actuatedRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real actuatedRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real actuatedRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute.animate = true \"enable Animation\";
//   parameter Boolean actuatedRevolute.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute.cylinder.lengthDirection[1],actuatedRevolute.cylinder.lengthDirection[2],actuatedRevolute.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else actuatedRevolute.cylinder.lengthDirection[1] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute.cylinder.lengthDirection[2] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute.cylinder.lengthDirection[3] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[3] - actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[2];
//   protected Real actuatedRevolute.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[1] - actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[3];
//   protected Real actuatedRevolute.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[2] - actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[1];
//   protected Real actuatedRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute.cylinder.Form;
//   output Real actuatedRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.Material;
//   protected output Real actuatedRevolute.cylinder.Extra;
//   parameter Boolean force.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real force.s(quantity = \"Length\", unit = \"m\") = force.flange.s - force.s_support \"distance between flange and support (= flange.s - support.s)\";
//   Real force.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real force.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   protected Real force.s_support(quantity = \"Length\", unit = \"m\") \"Absolute position of support flange\";
//   input Real force.f \"driving force as input signal\";
//   input Real PID.u \"Connector of Real input signal\";
//   output Real PID.y \"Connector of Real output signal\";
//   parameter Real PID.k = 15696.000000000002 \"Gain\";
//   parameter Real PID.Ti(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 0.5) = 1000000000000.0 \"Time Constant of Integrator\";
//   parameter Real PID.Td(quantity = \"Time\", unit = \"s\", min = 0.0, start = 0.1) = 0.2 \"Time Constant of Derivative block\";
//   parameter Real PID.Nd(min = 1e-60) = 10.0 \"The higher Nd, the more ideal the derivative block\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput, DoNotUse_InitialIntegratorState) PID.initType = Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real PID.xi_start = 0.0 \"Initial or guess value value for integrator output (= integrator state)\";
//   parameter Real PID.xd_start = 0.0 \"Initial or guess value for state of derivative block\";
//   parameter Real PID.y_start = 0.0 \"Initial value of output\";
//   parameter Real PID.P.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real PID.P.u \"Input signal connector\";
//   output Real PID.P.y \"Output signal connector\";
//   input Real PID.I.u \"Connector of Real input signal\";
//   parameter Real PID.I.k = 1.0 / PID.Ti \"Integrator gain\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) PID.I.initType = if PID.initType == Modelica.Blocks.Types.InitPID.SteadyState then Modelica.Blocks.Types.Init.SteadyState else if PID.initType == Modelica.Blocks.Types.InitPID.InitialState or PID.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState then Modelica.Blocks.Types.Init.InitialState else Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\";
//   parameter Real PID.I.y_start = PID.xi_start \"Initial or guess value of output (= state)\";
//   output Real PID.I.y(start = PID.I.y_start) \"Connector of Real output signal\";
//   input Real PID.D.u \"Connector of Real input signal\";
//   output Real PID.D.y \"Connector of Real output signal\";
//   parameter Real PID.D.k = PID.Td \"Gains\";
//   parameter Real PID.D.T(quantity = \"Time\", unit = \"s\", min = 1e-60) = max({{PID.Td / PID.Nd,0.0000000000001}}) \"Time constants (T>0 required; T=0 is ideal derivative block)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) PID.D.initType = if PID.initType == Modelica.Blocks.Types.InitPID.SteadyState or PID.initType == Modelica.Blocks.Types.InitPID.InitialOutput then Modelica.Blocks.Types.Init.SteadyState else if PID.initType == Modelica.Blocks.Types.InitPID.InitialState then Modelica.Blocks.Types.Init.InitialState else Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real PID.D.x_start = PID.xd_start \"Initial or guess value of state\";
//   parameter Real PID.D.y_start = 0.0 \"Initial value of output (= state)\";
//   protected parameter Boolean PID.D.zeroGain = abs(PID.D.k) < 0.000000000000001;
//   output Real PID.D.x(start = PID.D.x_start) \"State of block\";
//   parameter Real PID.Add.k1 = 1.0 \"Gain of upper input\";
//   parameter Real PID.Add.k2 = 1.0 \"Gain of middle input\";
//   parameter Real PID.Add.k3 = 1.0 \"Gain of lower input\";
//   input Real PID.Add.u1 \"Connector 1 of Real input signals\";
//   input Real PID.Add.u2 \"Connector 2 of Real input signals\";
//   input Real PID.Add.u3 \"Connector 3 of Real input signals\";
//   output Real PID.Add.y \"Connector of Real output signals\";
//   parameter Real PID.Gain.k(start = 1.0) = PID.k \"Gain value multiplied with input signal\";
//   input Real PID.Gain.u \"Input signal connector\";
//   output Real PID.Gain.y \"Output signal connector\";
// initial equation
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
//   actuatedRevolute.phi = actuatedRevolute.phi_start;
//   actuatedRevolute.w = actuatedRevolute.w_start;
//   PID.I.y = PID.I.y_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.g[1] * body1.m = body1.a[1] * body1.m;
//   body1.f[2] + body1.g[2] * body1.m = body1.a[2] * body1.m;
//   body1.frame_a.t = body1.I * body1.z;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.e0[1] = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.e0[2] = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.r0[1] = actuatedPrismatic.e0[1] * actuatedPrismatic.s;
//   actuatedPrismatic.r0[2] = actuatedPrismatic.e0[2] * actuatedPrismatic.s;
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * actuatedPrismatic.e0[1] + actuatedPrismatic.frame_a.fy * actuatedPrismatic.e0[2] = actuatedPrismatic.f;
//   angleSensor.phi = angleSensor.flange.phi;
//   0.0 = angleSensor.flange.tau;
//   actuatedRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute.cylinder.shapeType);
//   actuatedRevolute.cylinder.rxvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.ryvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.rvisobj = actuatedRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute.cylinder.R.T[1,1],actuatedRevolute.cylinder.R.T[1,2],actuatedRevolute.cylinder.R.T[1,3]},{actuatedRevolute.cylinder.R.T[2,1],actuatedRevolute.cylinder.R.T[2,2],actuatedRevolute.cylinder.R.T[2,3]},{actuatedRevolute.cylinder.R.T[3,1],actuatedRevolute.cylinder.R.T[3,2],actuatedRevolute.cylinder.R.T[3,3]}},{actuatedRevolute.cylinder.r_shape[1],actuatedRevolute.cylinder.r_shape[2],actuatedRevolute.cylinder.r_shape[3]});
//   actuatedRevolute.cylinder.size[1] = actuatedRevolute.cylinder.length;
//   actuatedRevolute.cylinder.size[2] = actuatedRevolute.cylinder.width;
//   actuatedRevolute.cylinder.size[3] = actuatedRevolute.cylinder.height;
//   actuatedRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute.cylinder.color[1] / 255.0,actuatedRevolute.cylinder.color[2] / 255.0,actuatedRevolute.cylinder.color[3] / 255.0,actuatedRevolute.cylinder.specularCoefficient);
//   actuatedRevolute.cylinder.Extra = actuatedRevolute.cylinder.extra;
//   actuatedRevolute.phi = actuatedRevolute.flange_a.phi;
//   actuatedRevolute.w = der(actuatedRevolute.phi);
//   actuatedRevolute.z = der(actuatedRevolute.w);
//   actuatedRevolute.t = actuatedRevolute.flange_a.tau;
//   actuatedRevolute.frame_a.x = actuatedRevolute.frame_b.x;
//   actuatedRevolute.frame_a.y = actuatedRevolute.frame_b.y;
//   actuatedRevolute.frame_a.phi + actuatedRevolute.phi = actuatedRevolute.frame_b.phi;
//   actuatedRevolute.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   actuatedRevolute.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   actuatedRevolute.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   actuatedRevolute.frame_a.t = actuatedRevolute.t;
//   force.flange.f = -force.f;
//   force.s_support = 0.0;
//   PID.P.y = PID.P.k * PID.P.u;
//   der(PID.I.y) = PID.I.k * PID.I.u;
//   der(PID.D.x) = if PID.D.zeroGain then 0.0 else (PID.D.u - PID.D.x) / PID.D.T;
//   PID.D.y = if PID.D.zeroGain then 0.0 else ((PID.D.u - PID.D.x) * PID.D.k) / PID.D.T;
//   PID.Add.y = PID.Add.k1 * PID.Add.u1 + (PID.Add.k2 * PID.Add.u2 + PID.Add.k3 * PID.Add.u3);
//   PID.Gain.y = PID.Gain.k * PID.Gain.u;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   fixedTranslation.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   body1.frame_a.t + actuatedPrismatic.frame_b.t + actuatedRevolute.frame_a.t = 0.0;
//   body1.frame_a.fy + actuatedPrismatic.frame_b.fy + actuatedRevolute.frame_a.fy = 0.0;
//   body1.frame_a.fx + actuatedPrismatic.frame_b.fx + actuatedRevolute.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + force.flange.f = 0.0;
//   angleSensor.flange.tau + actuatedRevolute.flange_a.tau = 0.0;
//   PID.D.u = PID.I.u;
//   PID.D.u = PID.P.u;
//   PID.D.u = PID.u;
//   PID.Add.u1 = PID.P.y;
//   PID.Add.u2 = PID.I.y;
//   PID.Add.u3 = PID.D.y;
//   PID.Add.y = PID.Gain.u;
//   PID.Gain.y = PID.y;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_b.x = actuatedRevolute.frame_a.x;
//   actuatedPrismatic.frame_b.x = body1.frame_a.x;
//   actuatedPrismatic.frame_b.y = actuatedRevolute.frame_a.y;
//   actuatedPrismatic.frame_b.y = body1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = actuatedRevolute.frame_a.phi;
//   actuatedPrismatic.frame_b.phi = body1.frame_a.phi;
//   actuatedRevolute.frame_b.x = fixedTranslation.frame_a.x;
//   actuatedRevolute.frame_b.y = fixedTranslation.frame_a.y;
//   actuatedRevolute.frame_b.phi = fixedTranslation.frame_a.phi;
//   actuatedRevolute.flange_a.phi = angleSensor.flange.phi;
//   actuatedPrismatic.flange_a.s = force.flange.s;
//   PID.y = force.f;
//   PID.u = angleSensor.phi;
// end PlanarMechanicsForTesting.Examples.ControlledCraneCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.InvertedCraneCrab
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 0.5 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real actuatedPrismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   parameter Boolean actuatedPrismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   Real actuatedRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.34906585039887;
//   parameter Real actuatedRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real actuatedRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real actuatedRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute.animate = true \"enable Animation\";
//   parameter Boolean actuatedRevolute.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute.cylinder.lengthDirection[1],actuatedRevolute.cylinder.lengthDirection[2],actuatedRevolute.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else actuatedRevolute.cylinder.lengthDirection[1] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute.cylinder.lengthDirection[2] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute.cylinder.lengthDirection[3] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[3] - actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[2];
//   protected Real actuatedRevolute.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[1] - actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[3];
//   protected Real actuatedRevolute.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[2] - actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[1];
//   protected Real actuatedRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute.cylinder.Form;
//   output Real actuatedRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.Material;
//   protected output Real actuatedRevolute.cylinder.Extra;
//   parameter Boolean force.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real force.s(quantity = \"Length\", unit = \"m\") = force.flange.s - force.s_support \"distance between flange and support (= flange.s - support.s)\";
//   Real force.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real force.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   protected Real force.s_support(quantity = \"Length\", unit = \"m\") \"Absolute position of support flange\";
//   input Real force.f \"driving force as input signal\";
//   Real angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real angleSensor.phi \"Absolute angle of flange\";
//   input Real inverseBlockConstraints.u1 \"Input signal 1 (u1 = u2)\";
//   input Real inverseBlockConstraints.u2 \"Input signal 2 (u1 = u2)\";
//   output Real inverseBlockConstraints.y1 \"Output signal 1 (y1 = y2)\";
//   output Real inverseBlockConstraints.y2 \"Output signal 2 (y2 = y2)\";
//   output Real ramp.y \"Connector of Real output signal\";
//   parameter Real ramp.height = -0.5 \"Height of ramps\";
//   parameter Real ramp.duration(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 2.0) = 0.5 \"Durations of ramp\";
//   parameter Real ramp.offset = 0.5 \"Offset of output signal\";
//   parameter Real ramp.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Output = offset for time < startTime\";
//   input Real firstOrder.u \"Connector of Real input signal\";
//   parameter Real firstOrder.k = 1.0 \"Gain\";
//   parameter Real firstOrder.T(quantity = \"Time\", unit = \"s\", start = 1.0) = 0.1 \"Time Constant\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) firstOrder.initType = Modelica.Blocks.Types.Init.SteadyState \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\";
//   parameter Real firstOrder.y_start = 0.0 \"Initial or guess value of output (= state)\";
//   output Real firstOrder.y(start = firstOrder.y_start) \"Connector of Real output signal\";
// initial equation
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
//   der(firstOrder.y) = 0.0;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.g[1] * body1.m = body1.a[1] * body1.m;
//   body1.f[2] + body1.g[2] * body1.m = body1.a[2] * body1.m;
//   body1.frame_a.t = body1.I * body1.z;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.e0[1] = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.e0[2] = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.r0[1] = actuatedPrismatic.e0[1] * actuatedPrismatic.s;
//   actuatedPrismatic.r0[2] = actuatedPrismatic.e0[2] * actuatedPrismatic.s;
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * actuatedPrismatic.e0[1] + actuatedPrismatic.frame_a.fy * actuatedPrismatic.e0[2] = actuatedPrismatic.f;
//   actuatedRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute.cylinder.shapeType);
//   actuatedRevolute.cylinder.rxvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.ryvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.rvisobj = actuatedRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute.cylinder.R.T[1,1],actuatedRevolute.cylinder.R.T[1,2],actuatedRevolute.cylinder.R.T[1,3]},{actuatedRevolute.cylinder.R.T[2,1],actuatedRevolute.cylinder.R.T[2,2],actuatedRevolute.cylinder.R.T[2,3]},{actuatedRevolute.cylinder.R.T[3,1],actuatedRevolute.cylinder.R.T[3,2],actuatedRevolute.cylinder.R.T[3,3]}},{actuatedRevolute.cylinder.r_shape[1],actuatedRevolute.cylinder.r_shape[2],actuatedRevolute.cylinder.r_shape[3]});
//   actuatedRevolute.cylinder.size[1] = actuatedRevolute.cylinder.length;
//   actuatedRevolute.cylinder.size[2] = actuatedRevolute.cylinder.width;
//   actuatedRevolute.cylinder.size[3] = actuatedRevolute.cylinder.height;
//   actuatedRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute.cylinder.color[1] / 255.0,actuatedRevolute.cylinder.color[2] / 255.0,actuatedRevolute.cylinder.color[3] / 255.0,actuatedRevolute.cylinder.specularCoefficient);
//   actuatedRevolute.cylinder.Extra = actuatedRevolute.cylinder.extra;
//   actuatedRevolute.phi = actuatedRevolute.flange_a.phi;
//   actuatedRevolute.w = der(actuatedRevolute.phi);
//   actuatedRevolute.z = der(actuatedRevolute.w);
//   actuatedRevolute.t = actuatedRevolute.flange_a.tau;
//   actuatedRevolute.frame_a.x = actuatedRevolute.frame_b.x;
//   actuatedRevolute.frame_a.y = actuatedRevolute.frame_b.y;
//   actuatedRevolute.frame_a.phi + actuatedRevolute.phi = actuatedRevolute.frame_b.phi;
//   actuatedRevolute.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   actuatedRevolute.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   actuatedRevolute.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   actuatedRevolute.frame_a.t = actuatedRevolute.t;
//   force.flange.f = -force.f;
//   force.s_support = 0.0;
//   angleSensor.phi = angleSensor.flange.phi;
//   0.0 = angleSensor.flange.tau;
//   inverseBlockConstraints.u1 = inverseBlockConstraints.u2;
//   inverseBlockConstraints.y1 = inverseBlockConstraints.y2;
//   ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then ((time - ramp.startTime) * ramp.height) / ramp.duration else ramp.height);
//   der(firstOrder.y) = (firstOrder.k * firstOrder.u - firstOrder.y) / firstOrder.T;
//   body.frame_a.t + fixedTranslation.frame_b.t = 0.0;
//   body.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   body.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   fixedTranslation.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   body1.frame_a.t + actuatedPrismatic.frame_b.t + actuatedRevolute.frame_a.t = 0.0;
//   body1.frame_a.fy + actuatedPrismatic.frame_b.fy + actuatedRevolute.frame_a.fy = 0.0;
//   body1.frame_a.fx + actuatedPrismatic.frame_b.fx + actuatedRevolute.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + force.flange.f = 0.0;
//   actuatedRevolute.flange_a.tau + angleSensor.flange.tau = 0.0;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_b.x = actuatedRevolute.frame_a.x;
//   actuatedPrismatic.frame_b.x = body1.frame_a.x;
//   actuatedPrismatic.frame_b.y = actuatedRevolute.frame_a.y;
//   actuatedPrismatic.frame_b.y = body1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = actuatedRevolute.frame_a.phi;
//   actuatedPrismatic.frame_b.phi = body1.frame_a.phi;
//   actuatedRevolute.frame_b.x = fixedTranslation.frame_a.x;
//   actuatedRevolute.frame_b.y = fixedTranslation.frame_a.y;
//   actuatedRevolute.frame_b.phi = fixedTranslation.frame_a.phi;
//   actuatedPrismatic.flange_a.s = force.flange.s;
//   actuatedRevolute.flange_a.phi = angleSensor.flange.phi;
//   angleSensor.phi = inverseBlockConstraints.u1;
//   force.f = inverseBlockConstraints.y1;
//   body.frame_a.x = fixedTranslation.frame_b.x;
//   body.frame_a.y = fixedTranslation.frame_b.y;
//   body.frame_a.phi = fixedTranslation.frame_b.phi;
//   firstOrder.u = ramp.y;
//   firstOrder.y = inverseBlockConstraints.u2;
// end PlanarMechanicsForTesting.Examples.InvertedCraneCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.WheelBasedCranCrab
//   Real idealRolling.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealRolling.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealRolling.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealRolling.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealRolling.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealRolling.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real idealRolling.R(quantity = \"Length\", unit = \"m\") = 0.3 \"Radius of the wheel\";
//   parameter Boolean idealRolling.initialize = true \"Initialize Position and Velocity\";
//   parameter Real idealRolling.x_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real idealRolling.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real idealRolling.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean idealRolling.animate = true \"enable Animation\";
//   Real idealRolling.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angular position\";
//   Real idealRolling.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity\";
//   Real idealRolling.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real idealRolling.vx(quantity = \"Velocity\", unit = \"m/s\") \"Velocity in x-direction\";
//   parameter String idealRolling.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealRolling.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealRolling.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Width of visual object\";
//   input Real idealRolling.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Height of visual object\";
//   input Real idealRolling.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealRolling.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real idealRolling.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real idealRolling.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real idealRolling.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealRolling.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealRolling.cylinder.lengthDirection[1],idealRolling.cylinder.lengthDirection[2],idealRolling.cylinder.lengthDirection[3]});
//   protected Real idealRolling.cylinder.e_x[1](unit = \"1\") = if noEvent(idealRolling.cylinder.abs_n_x < 0.0000000001) then 1.0 else idealRolling.cylinder.lengthDirection[1] / idealRolling.cylinder.abs_n_x;
//   protected Real idealRolling.cylinder.e_x[2](unit = \"1\") = if noEvent(idealRolling.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealRolling.cylinder.lengthDirection[2] / idealRolling.cylinder.abs_n_x;
//   protected Real idealRolling.cylinder.e_x[3](unit = \"1\") = if noEvent(idealRolling.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealRolling.cylinder.lengthDirection[3] / idealRolling.cylinder.abs_n_x;
//   protected Real idealRolling.cylinder.n_z_aux[1](unit = \"1\") = idealRolling.cylinder.e_x[2] * idealRolling.cylinder.widthDirection[3] - idealRolling.cylinder.e_x[3] * idealRolling.cylinder.widthDirection[2];
//   protected Real idealRolling.cylinder.n_z_aux[2](unit = \"1\") = idealRolling.cylinder.e_x[3] * idealRolling.cylinder.widthDirection[1] - idealRolling.cylinder.e_x[1] * idealRolling.cylinder.widthDirection[3];
//   protected Real idealRolling.cylinder.n_z_aux[3](unit = \"1\") = idealRolling.cylinder.e_x[1] * idealRolling.cylinder.widthDirection[2] - idealRolling.cylinder.e_x[2] * idealRolling.cylinder.widthDirection[1];
//   protected Real idealRolling.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]},if noEvent(idealRolling.cylinder.n_z_aux[1] ^ 2.0 + (idealRolling.cylinder.n_z_aux[2] ^ 2.0 + idealRolling.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.cylinder.widthDirection[1],idealRolling.cylinder.widthDirection[2],idealRolling.cylinder.widthDirection[3]} else if noEvent(abs(idealRolling.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]})[1];
//   protected Real idealRolling.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]},if noEvent(idealRolling.cylinder.n_z_aux[1] ^ 2.0 + (idealRolling.cylinder.n_z_aux[2] ^ 2.0 + idealRolling.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.cylinder.widthDirection[1],idealRolling.cylinder.widthDirection[2],idealRolling.cylinder.widthDirection[3]} else if noEvent(abs(idealRolling.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]})[2];
//   protected Real idealRolling.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]},if noEvent(idealRolling.cylinder.n_z_aux[1] ^ 2.0 + (idealRolling.cylinder.n_z_aux[2] ^ 2.0 + idealRolling.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.cylinder.widthDirection[1],idealRolling.cylinder.widthDirection[2],idealRolling.cylinder.widthDirection[3]} else if noEvent(abs(idealRolling.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.cylinder.e_x[1],idealRolling.cylinder.e_x[2],idealRolling.cylinder.e_x[3]})[3];
//   protected output Real idealRolling.cylinder.Form;
//   output Real idealRolling.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealRolling.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.cylinder.Material;
//   protected output Real idealRolling.cylinder.Extra;
//   parameter String idealRolling.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealRolling.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = -idealRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim1.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim1.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim1.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Length of visual object\";
//   input Real idealRolling.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealRolling.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealRolling.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealRolling.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealRolling.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealRolling.rim1.lengthDirection[1],idealRolling.rim1.lengthDirection[2],idealRolling.rim1.lengthDirection[3]});
//   protected Real idealRolling.rim1.e_x[1](unit = \"1\") = if noEvent(idealRolling.rim1.abs_n_x < 0.0000000001) then 1.0 else idealRolling.rim1.lengthDirection[1] / idealRolling.rim1.abs_n_x;
//   protected Real idealRolling.rim1.e_x[2](unit = \"1\") = if noEvent(idealRolling.rim1.abs_n_x < 0.0000000001) then 0.0 else idealRolling.rim1.lengthDirection[2] / idealRolling.rim1.abs_n_x;
//   protected Real idealRolling.rim1.e_x[3](unit = \"1\") = if noEvent(idealRolling.rim1.abs_n_x < 0.0000000001) then 0.0 else idealRolling.rim1.lengthDirection[3] / idealRolling.rim1.abs_n_x;
//   protected Real idealRolling.rim1.n_z_aux[1](unit = \"1\") = idealRolling.rim1.e_x[2] * idealRolling.rim1.widthDirection[3] - idealRolling.rim1.e_x[3] * idealRolling.rim1.widthDirection[2];
//   protected Real idealRolling.rim1.n_z_aux[2](unit = \"1\") = idealRolling.rim1.e_x[3] * idealRolling.rim1.widthDirection[1] - idealRolling.rim1.e_x[1] * idealRolling.rim1.widthDirection[3];
//   protected Real idealRolling.rim1.n_z_aux[3](unit = \"1\") = idealRolling.rim1.e_x[1] * idealRolling.rim1.widthDirection[2] - idealRolling.rim1.e_x[2] * idealRolling.rim1.widthDirection[1];
//   protected Real idealRolling.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]},if noEvent(idealRolling.rim1.n_z_aux[1] ^ 2.0 + (idealRolling.rim1.n_z_aux[2] ^ 2.0 + idealRolling.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.rim1.widthDirection[1],idealRolling.rim1.widthDirection[2],idealRolling.rim1.widthDirection[3]} else if noEvent(abs(idealRolling.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]})[1];
//   protected Real idealRolling.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]},if noEvent(idealRolling.rim1.n_z_aux[1] ^ 2.0 + (idealRolling.rim1.n_z_aux[2] ^ 2.0 + idealRolling.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.rim1.widthDirection[1],idealRolling.rim1.widthDirection[2],idealRolling.rim1.widthDirection[3]} else if noEvent(abs(idealRolling.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]})[2];
//   protected Real idealRolling.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]},if noEvent(idealRolling.rim1.n_z_aux[1] ^ 2.0 + (idealRolling.rim1.n_z_aux[2] ^ 2.0 + idealRolling.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.rim1.widthDirection[1],idealRolling.rim1.widthDirection[2],idealRolling.rim1.widthDirection[3]} else if noEvent(abs(idealRolling.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.rim1.e_x[1],idealRolling.rim1.e_x[2],idealRolling.rim1.e_x[3]})[3];
//   protected output Real idealRolling.rim1.Form;
//   output Real idealRolling.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealRolling.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim1.Material;
//   protected output Real idealRolling.rim1.Extra;
//   parameter String idealRolling.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealRolling.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealRolling.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealRolling.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealRolling.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealRolling.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = -idealRolling.R \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealRolling.rim2.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim2.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealRolling.rim2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim2.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealRolling.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealRolling.R \"Length of visual object\";
//   input Real idealRolling.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealRolling.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealRolling.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealRolling.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealRolling.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealRolling.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealRolling.rim2.lengthDirection[1],idealRolling.rim2.lengthDirection[2],idealRolling.rim2.lengthDirection[3]});
//   protected Real idealRolling.rim2.e_x[1](unit = \"1\") = if noEvent(idealRolling.rim2.abs_n_x < 0.0000000001) then 1.0 else idealRolling.rim2.lengthDirection[1] / idealRolling.rim2.abs_n_x;
//   protected Real idealRolling.rim2.e_x[2](unit = \"1\") = if noEvent(idealRolling.rim2.abs_n_x < 0.0000000001) then 0.0 else idealRolling.rim2.lengthDirection[2] / idealRolling.rim2.abs_n_x;
//   protected Real idealRolling.rim2.e_x[3](unit = \"1\") = if noEvent(idealRolling.rim2.abs_n_x < 0.0000000001) then 0.0 else idealRolling.rim2.lengthDirection[3] / idealRolling.rim2.abs_n_x;
//   protected Real idealRolling.rim2.n_z_aux[1](unit = \"1\") = idealRolling.rim2.e_x[2] * idealRolling.rim2.widthDirection[3] - idealRolling.rim2.e_x[3] * idealRolling.rim2.widthDirection[2];
//   protected Real idealRolling.rim2.n_z_aux[2](unit = \"1\") = idealRolling.rim2.e_x[3] * idealRolling.rim2.widthDirection[1] - idealRolling.rim2.e_x[1] * idealRolling.rim2.widthDirection[3];
//   protected Real idealRolling.rim2.n_z_aux[3](unit = \"1\") = idealRolling.rim2.e_x[1] * idealRolling.rim2.widthDirection[2] - idealRolling.rim2.e_x[2] * idealRolling.rim2.widthDirection[1];
//   protected Real idealRolling.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]},if noEvent(idealRolling.rim2.n_z_aux[1] ^ 2.0 + (idealRolling.rim2.n_z_aux[2] ^ 2.0 + idealRolling.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.rim2.widthDirection[1],idealRolling.rim2.widthDirection[2],idealRolling.rim2.widthDirection[3]} else if noEvent(abs(idealRolling.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]})[1];
//   protected Real idealRolling.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]},if noEvent(idealRolling.rim2.n_z_aux[1] ^ 2.0 + (idealRolling.rim2.n_z_aux[2] ^ 2.0 + idealRolling.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.rim2.widthDirection[1],idealRolling.rim2.widthDirection[2],idealRolling.rim2.widthDirection[3]} else if noEvent(abs(idealRolling.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]})[2];
//   protected Real idealRolling.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]},if noEvent(idealRolling.rim2.n_z_aux[1] ^ 2.0 + (idealRolling.rim2.n_z_aux[2] ^ 2.0 + idealRolling.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealRolling.rim2.widthDirection[1],idealRolling.rim2.widthDirection[2],idealRolling.rim2.widthDirection[3]} else if noEvent(abs(idealRolling.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealRolling.rim2.e_x[1],idealRolling.rim2.e_x[2],idealRolling.rim2.e_x[3]})[3];
//   protected output Real idealRolling.rim2.Form;
//   output Real idealRolling.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealRolling.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealRolling.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealRolling.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealRolling.rim2.Material;
//   protected output Real idealRolling.rim2.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -1.3962634015955;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixedTranslation.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation.r[1] ^ 2.0 + fixedTranslation.r[2] ^ 2.0);
//   parameter String fixedTranslation.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation.r0[1] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation.r0[2] / fixedTranslation.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation.l \"Length of visual object\";
//   input Real fixedTranslation.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation.cylinder.lengthDirection[1],fixedTranslation.cylinder.lengthDirection[2],fixedTranslation.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation.cylinder.lengthDirection[1] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[2] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation.cylinder.lengthDirection[3] / fixedTranslation.cylinder.abs_n_x;
//   protected Real fixedTranslation.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[3] - fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[2];
//   protected Real fixedTranslation.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation.cylinder.e_x[3] * fixedTranslation.cylinder.widthDirection[1] - fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[3];
//   protected Real fixedTranslation.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation.cylinder.e_x[1] * fixedTranslation.cylinder.widthDirection[2] - fixedTranslation.cylinder.e_x[2] * fixedTranslation.cylinder.widthDirection[1];
//   protected Real fixedTranslation.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]},if noEvent(fixedTranslation.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation.cylinder.widthDirection[1],fixedTranslation.cylinder.widthDirection[2],fixedTranslation.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation.cylinder.e_x[1],fixedTranslation.cylinder.e_x[2],fixedTranslation.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation.cylinder.Form;
//   output Real fixedTranslation.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation.cylinder.Material;
//   protected output Real fixedTranslation.cylinder.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 2.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.2 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
// initial equation
//   idealRolling.phi = idealRolling.phi_start;
//   idealRolling.w = idealRolling.w_start;
//   idealRolling.frame_a.x = idealRolling.x_start;
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
// equation
//   idealRolling.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealRolling.cylinder.shapeType);
//   idealRolling.cylinder.rxvisobj[1] = idealRolling.cylinder.R.T[1,1] * idealRolling.cylinder.e_x[1] + idealRolling.cylinder.R.T[2,1] * idealRolling.cylinder.e_x[2] + idealRolling.cylinder.R.T[3,1] * idealRolling.cylinder.e_x[3];
//   idealRolling.cylinder.rxvisobj[2] = idealRolling.cylinder.R.T[1,2] * idealRolling.cylinder.e_x[1] + idealRolling.cylinder.R.T[2,2] * idealRolling.cylinder.e_x[2] + idealRolling.cylinder.R.T[3,2] * idealRolling.cylinder.e_x[3];
//   idealRolling.cylinder.rxvisobj[3] = idealRolling.cylinder.R.T[1,3] * idealRolling.cylinder.e_x[1] + idealRolling.cylinder.R.T[2,3] * idealRolling.cylinder.e_x[2] + idealRolling.cylinder.R.T[3,3] * idealRolling.cylinder.e_x[3];
//   idealRolling.cylinder.ryvisobj[1] = idealRolling.cylinder.R.T[1,1] * idealRolling.cylinder.e_y[1] + idealRolling.cylinder.R.T[2,1] * idealRolling.cylinder.e_y[2] + idealRolling.cylinder.R.T[3,1] * idealRolling.cylinder.e_y[3];
//   idealRolling.cylinder.ryvisobj[2] = idealRolling.cylinder.R.T[1,2] * idealRolling.cylinder.e_y[1] + idealRolling.cylinder.R.T[2,2] * idealRolling.cylinder.e_y[2] + idealRolling.cylinder.R.T[3,2] * idealRolling.cylinder.e_y[3];
//   idealRolling.cylinder.ryvisobj[3] = idealRolling.cylinder.R.T[1,3] * idealRolling.cylinder.e_y[1] + idealRolling.cylinder.R.T[2,3] * idealRolling.cylinder.e_y[2] + idealRolling.cylinder.R.T[3,3] * idealRolling.cylinder.e_y[3];
//   idealRolling.cylinder.rvisobj = idealRolling.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealRolling.cylinder.R.T[1,1],idealRolling.cylinder.R.T[1,2],idealRolling.cylinder.R.T[1,3]},{idealRolling.cylinder.R.T[2,1],idealRolling.cylinder.R.T[2,2],idealRolling.cylinder.R.T[2,3]},{idealRolling.cylinder.R.T[3,1],idealRolling.cylinder.R.T[3,2],idealRolling.cylinder.R.T[3,3]}},{idealRolling.cylinder.r_shape[1],idealRolling.cylinder.r_shape[2],idealRolling.cylinder.r_shape[3]});
//   idealRolling.cylinder.size[1] = idealRolling.cylinder.length;
//   idealRolling.cylinder.size[2] = idealRolling.cylinder.width;
//   idealRolling.cylinder.size[3] = idealRolling.cylinder.height;
//   idealRolling.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealRolling.cylinder.color[1] / 255.0,idealRolling.cylinder.color[2] / 255.0,idealRolling.cylinder.color[3] / 255.0,idealRolling.cylinder.specularCoefficient);
//   idealRolling.cylinder.Extra = idealRolling.cylinder.extra;
//   idealRolling.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},-idealRolling.phi,0.0);
//   idealRolling.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealRolling.rim1.shapeType);
//   idealRolling.rim1.rxvisobj[1] = idealRolling.rim1.R.T[1,1] * idealRolling.rim1.e_x[1] + idealRolling.rim1.R.T[2,1] * idealRolling.rim1.e_x[2] + idealRolling.rim1.R.T[3,1] * idealRolling.rim1.e_x[3];
//   idealRolling.rim1.rxvisobj[2] = idealRolling.rim1.R.T[1,2] * idealRolling.rim1.e_x[1] + idealRolling.rim1.R.T[2,2] * idealRolling.rim1.e_x[2] + idealRolling.rim1.R.T[3,2] * idealRolling.rim1.e_x[3];
//   idealRolling.rim1.rxvisobj[3] = idealRolling.rim1.R.T[1,3] * idealRolling.rim1.e_x[1] + idealRolling.rim1.R.T[2,3] * idealRolling.rim1.e_x[2] + idealRolling.rim1.R.T[3,3] * idealRolling.rim1.e_x[3];
//   idealRolling.rim1.ryvisobj[1] = idealRolling.rim1.R.T[1,1] * idealRolling.rim1.e_y[1] + idealRolling.rim1.R.T[2,1] * idealRolling.rim1.e_y[2] + idealRolling.rim1.R.T[3,1] * idealRolling.rim1.e_y[3];
//   idealRolling.rim1.ryvisobj[2] = idealRolling.rim1.R.T[1,2] * idealRolling.rim1.e_y[1] + idealRolling.rim1.R.T[2,2] * idealRolling.rim1.e_y[2] + idealRolling.rim1.R.T[3,2] * idealRolling.rim1.e_y[3];
//   idealRolling.rim1.ryvisobj[3] = idealRolling.rim1.R.T[1,3] * idealRolling.rim1.e_y[1] + idealRolling.rim1.R.T[2,3] * idealRolling.rim1.e_y[2] + idealRolling.rim1.R.T[3,3] * idealRolling.rim1.e_y[3];
//   idealRolling.rim1.rvisobj = idealRolling.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealRolling.rim1.R.T[1,1],idealRolling.rim1.R.T[1,2],idealRolling.rim1.R.T[1,3]},{idealRolling.rim1.R.T[2,1],idealRolling.rim1.R.T[2,2],idealRolling.rim1.R.T[2,3]},{idealRolling.rim1.R.T[3,1],idealRolling.rim1.R.T[3,2],idealRolling.rim1.R.T[3,3]}},{idealRolling.rim1.r_shape[1],idealRolling.rim1.r_shape[2],idealRolling.rim1.r_shape[3]});
//   idealRolling.rim1.size[1] = idealRolling.rim1.length;
//   idealRolling.rim1.size[2] = idealRolling.rim1.width;
//   idealRolling.rim1.size[3] = idealRolling.rim1.height;
//   idealRolling.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealRolling.rim1.color[1] / 255.0,idealRolling.rim1.color[2] / 255.0,idealRolling.rim1.color[3] / 255.0,idealRolling.rim1.specularCoefficient);
//   idealRolling.rim1.Extra = idealRolling.rim1.extra;
//   idealRolling.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({0.0,0.0,1.0},1.5707963267948966 - idealRolling.phi,0.0);
//   idealRolling.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealRolling.rim2.shapeType);
//   idealRolling.rim2.rxvisobj[1] = idealRolling.rim2.R.T[1,1] * idealRolling.rim2.e_x[1] + idealRolling.rim2.R.T[2,1] * idealRolling.rim2.e_x[2] + idealRolling.rim2.R.T[3,1] * idealRolling.rim2.e_x[3];
//   idealRolling.rim2.rxvisobj[2] = idealRolling.rim2.R.T[1,2] * idealRolling.rim2.e_x[1] + idealRolling.rim2.R.T[2,2] * idealRolling.rim2.e_x[2] + idealRolling.rim2.R.T[3,2] * idealRolling.rim2.e_x[3];
//   idealRolling.rim2.rxvisobj[3] = idealRolling.rim2.R.T[1,3] * idealRolling.rim2.e_x[1] + idealRolling.rim2.R.T[2,3] * idealRolling.rim2.e_x[2] + idealRolling.rim2.R.T[3,3] * idealRolling.rim2.e_x[3];
//   idealRolling.rim2.ryvisobj[1] = idealRolling.rim2.R.T[1,1] * idealRolling.rim2.e_y[1] + idealRolling.rim2.R.T[2,1] * idealRolling.rim2.e_y[2] + idealRolling.rim2.R.T[3,1] * idealRolling.rim2.e_y[3];
//   idealRolling.rim2.ryvisobj[2] = idealRolling.rim2.R.T[1,2] * idealRolling.rim2.e_y[1] + idealRolling.rim2.R.T[2,2] * idealRolling.rim2.e_y[2] + idealRolling.rim2.R.T[3,2] * idealRolling.rim2.e_y[3];
//   idealRolling.rim2.ryvisobj[3] = idealRolling.rim2.R.T[1,3] * idealRolling.rim2.e_y[1] + idealRolling.rim2.R.T[2,3] * idealRolling.rim2.e_y[2] + idealRolling.rim2.R.T[3,3] * idealRolling.rim2.e_y[3];
//   idealRolling.rim2.rvisobj = idealRolling.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealRolling.rim2.R.T[1,1],idealRolling.rim2.R.T[1,2],idealRolling.rim2.R.T[1,3]},{idealRolling.rim2.R.T[2,1],idealRolling.rim2.R.T[2,2],idealRolling.rim2.R.T[2,3]},{idealRolling.rim2.R.T[3,1],idealRolling.rim2.R.T[3,2],idealRolling.rim2.R.T[3,3]}},{idealRolling.rim2.r_shape[1],idealRolling.rim2.r_shape[2],idealRolling.rim2.r_shape[3]});
//   idealRolling.rim2.size[1] = idealRolling.rim2.length;
//   idealRolling.rim2.size[2] = idealRolling.rim2.width;
//   idealRolling.rim2.size[3] = idealRolling.rim2.height;
//   idealRolling.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealRolling.rim2.color[1] / 255.0,idealRolling.rim2.color[2] / 255.0,idealRolling.rim2.color[3] / 255.0,idealRolling.rim2.specularCoefficient);
//   idealRolling.rim2.Extra = idealRolling.rim2.extra;
//   idealRolling.phi = idealRolling.frame_a.phi;
//   idealRolling.w = der(idealRolling.phi);
//   idealRolling.z = der(idealRolling.w);
//   idealRolling.vx = der(idealRolling.frame_a.x);
//   idealRolling.frame_a.y = idealRolling.R;
//   idealRolling.vx = idealRolling.w * idealRolling.R;
//   idealRolling.frame_a.fx * idealRolling.R = -idealRolling.frame_a.t;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixedTranslation.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.cylinder.shapeType);
//   fixedTranslation.cylinder.rxvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.rxvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_x[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_x[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_x[3];
//   fixedTranslation.cylinder.ryvisobj[1] = fixedTranslation.cylinder.R.T[1,1] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,1] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,1] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[2] = fixedTranslation.cylinder.R.T[1,2] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,2] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,2] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.ryvisobj[3] = fixedTranslation.cylinder.R.T[1,3] * fixedTranslation.cylinder.e_y[1] + fixedTranslation.cylinder.R.T[2,3] * fixedTranslation.cylinder.e_y[2] + fixedTranslation.cylinder.R.T[3,3] * fixedTranslation.cylinder.e_y[3];
//   fixedTranslation.cylinder.rvisobj = fixedTranslation.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.cylinder.R.T[1,1],fixedTranslation.cylinder.R.T[1,2],fixedTranslation.cylinder.R.T[1,3]},{fixedTranslation.cylinder.R.T[2,1],fixedTranslation.cylinder.R.T[2,2],fixedTranslation.cylinder.R.T[2,3]},{fixedTranslation.cylinder.R.T[3,1],fixedTranslation.cylinder.R.T[3,2],fixedTranslation.cylinder.R.T[3,3]}},{fixedTranslation.cylinder.r_shape[1],fixedTranslation.cylinder.r_shape[2],fixedTranslation.cylinder.r_shape[3]});
//   fixedTranslation.cylinder.size[1] = fixedTranslation.cylinder.length;
//   fixedTranslation.cylinder.size[2] = fixedTranslation.cylinder.width;
//   fixedTranslation.cylinder.size[3] = fixedTranslation.cylinder.height;
//   fixedTranslation.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.cylinder.color[1] / 255.0,fixedTranslation.cylinder.color[2] / 255.0,fixedTranslation.cylinder.color[3] / 255.0,fixedTranslation.cylinder.specularCoefficient);
//   fixedTranslation.cylinder.Extra = fixedTranslation.cylinder.extra;
//   fixedTranslation.R[1,1] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[1,2] = sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,1] = -sin(fixedTranslation.frame_a.phi);
//   fixedTranslation.R[2,2] = cos(fixedTranslation.frame_a.phi);
//   fixedTranslation.r0[1] = fixedTranslation.R[1,1] * fixedTranslation.r[1] + fixedTranslation.R[1,2] * fixedTranslation.r[2];
//   fixedTranslation.r0[2] = fixedTranslation.R[2,1] * fixedTranslation.r[1] + fixedTranslation.R[2,2] * fixedTranslation.r[2];
//   fixedTranslation.frame_a.x + fixedTranslation.r0[1] = fixedTranslation.frame_b.x;
//   fixedTranslation.frame_a.y + fixedTranslation.r0[2] = fixedTranslation.frame_b.y;
//   fixedTranslation.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.fx + fixedTranslation.frame_b.fx = 0.0;
//   fixedTranslation.frame_a.fy + fixedTranslation.frame_b.fy = 0.0;
//   fixedTranslation.frame_a.t + (fixedTranslation.frame_b.t + ((-fixedTranslation.r0[1]) * fixedTranslation.frame_b.fy + fixedTranslation.r0[2] * fixedTranslation.frame_b.fx)) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.g[1] * body1.m = body1.a[1] * body1.m;
//   body1.f[2] + body1.g[2] * body1.m = body1.a[2] * body1.m;
//   body1.frame_a.t = body1.I * body1.z;
//   idealRolling.frame_a.t + body.frame_a.t + revolute.frame_a.t = 0.0;
//   idealRolling.frame_a.fy + body.frame_a.fy + revolute.frame_a.fy = 0.0;
//   idealRolling.frame_a.fx + body.frame_a.fx + revolute.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation.frame_a.fx = 0.0;
//   fixedTranslation.frame_b.t + body1.frame_a.t = 0.0;
//   fixedTranslation.frame_b.fy + body1.frame_a.fy = 0.0;
//   fixedTranslation.frame_b.fx + body1.frame_a.fx = 0.0;
//   body.frame_a.x = idealRolling.frame_a.x;
//   body.frame_a.x = revolute.frame_a.x;
//   body.frame_a.y = idealRolling.frame_a.y;
//   body.frame_a.y = revolute.frame_a.y;
//   body.frame_a.phi = idealRolling.frame_a.phi;
//   body.frame_a.phi = revolute.frame_a.phi;
//   body1.frame_a.x = fixedTranslation.frame_b.x;
//   body1.frame_a.y = fixedTranslation.frame_b.y;
//   body1.frame_a.phi = fixedTranslation.frame_b.phi;
//   fixedTranslation.frame_a.x = revolute.frame_b.x;
//   fixedTranslation.frame_a.y = revolute.frame_b.y;
//   fixedTranslation.frame_a.phi = revolute.frame_b.phi;
// end PlanarMechanicsForTesting.Examples.WheelBasedCranCrab;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.PistonEngine
//   Real bodyDrive.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyDrive.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyDrive.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyDrive.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyDrive.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyDrive.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyDrive.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real bodyDrive.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyDrive.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyDrive.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real bodyDrive.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyDrive.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyDrive.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyDrive.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyDrive.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyDrive.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyDrive.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyDrive.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyDrive.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyDrive.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyDrive.animate = true \"enable Animation\";
//   parameter String bodyDrive.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyDrive.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyDrive.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyDrive.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyDrive.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyDrive.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyDrive.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyDrive.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyDrive.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyDrive.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyDrive.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyDrive.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyDrive.sphere.lengthDirection[1],bodyDrive.sphere.lengthDirection[2],bodyDrive.sphere.lengthDirection[3]});
//   protected Real bodyDrive.sphere.e_x[1](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 0.0000000001) then 1.0 else bodyDrive.sphere.lengthDirection[1] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.e_x[2](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyDrive.sphere.lengthDirection[2] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.e_x[3](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyDrive.sphere.lengthDirection[3] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.n_z_aux[1](unit = \"1\") = bodyDrive.sphere.e_x[2] * bodyDrive.sphere.widthDirection[3] - bodyDrive.sphere.e_x[3] * bodyDrive.sphere.widthDirection[2];
//   protected Real bodyDrive.sphere.n_z_aux[2](unit = \"1\") = bodyDrive.sphere.e_x[3] * bodyDrive.sphere.widthDirection[1] - bodyDrive.sphere.e_x[1] * bodyDrive.sphere.widthDirection[3];
//   protected Real bodyDrive.sphere.n_z_aux[3](unit = \"1\") = bodyDrive.sphere.e_x[1] * bodyDrive.sphere.widthDirection[2] - bodyDrive.sphere.e_x[2] * bodyDrive.sphere.widthDirection[1];
//   protected Real bodyDrive.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[1];
//   protected Real bodyDrive.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[2];
//   protected Real bodyDrive.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[3];
//   protected output Real bodyDrive.sphere.Form;
//   output Real bodyDrive.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyDrive.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.Material;
//   protected output Real bodyDrive.sphere.Extra;
//   Real revoluteDrive.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDrive.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDrive.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDrive.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDrive.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDrive.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revoluteDrive.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDrive.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDrive.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDrive.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDrive.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDrive.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revoluteDrive.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revoluteDrive.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revoluteDrive.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   parameter Boolean revoluteDrive.animate = true \"enable Animation\";
//   parameter Boolean revoluteDrive.enforceStates = true \"enforce the state of the revolute to become the state of the total system\";
//   Real revoluteDrive.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.always) \"Angular position\";
//   Real revoluteDrive.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.always) \"Angular velocity\";
//   Real revoluteDrive.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revoluteDrive.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revoluteDrive.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revoluteDrive.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revoluteDrive.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revoluteDrive.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revoluteDrive.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revoluteDrive.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revoluteDrive.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revoluteDrive.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revoluteDrive.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revoluteDrive.cylinder.lengthDirection[1],revoluteDrive.cylinder.lengthDirection[2],revoluteDrive.cylinder.lengthDirection[3]});
//   protected Real revoluteDrive.cylinder.e_x[1](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 0.0000000001) then 1.0 else revoluteDrive.cylinder.lengthDirection[1] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.e_x[2](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDrive.cylinder.lengthDirection[2] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.e_x[3](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDrive.cylinder.lengthDirection[3] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.n_z_aux[1](unit = \"1\") = revoluteDrive.cylinder.e_x[2] * revoluteDrive.cylinder.widthDirection[3] - revoluteDrive.cylinder.e_x[3] * revoluteDrive.cylinder.widthDirection[2];
//   protected Real revoluteDrive.cylinder.n_z_aux[2](unit = \"1\") = revoluteDrive.cylinder.e_x[3] * revoluteDrive.cylinder.widthDirection[1] - revoluteDrive.cylinder.e_x[1] * revoluteDrive.cylinder.widthDirection[3];
//   protected Real revoluteDrive.cylinder.n_z_aux[3](unit = \"1\") = revoluteDrive.cylinder.e_x[1] * revoluteDrive.cylinder.widthDirection[2] - revoluteDrive.cylinder.e_x[2] * revoluteDrive.cylinder.widthDirection[1];
//   protected Real revoluteDrive.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[1];
//   protected Real revoluteDrive.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[2];
//   protected Real revoluteDrive.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[3];
//   protected output Real revoluteDrive.cylinder.Form;
//   output Real revoluteDrive.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revoluteDrive.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.Material;
//   protected output Real revoluteDrive.cylinder.Extra;
//   Real fixedTranslationDisc.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslationDisc.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslationDisc.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslationDisc.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslationDisc.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslationDisc.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslationDisc.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslationDisc.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslationDisc.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslationDisc.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslationDisc.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslationDisc.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslationDisc.r[1](quantity = \"Length\", unit = \"m\") = 0.3 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslationDisc.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslationDisc.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslationDisc.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslationDisc.R[1,1] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[1,2] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[2,1] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslationDisc.animate = true \"enable Animation\";
//   final parameter Real fixedTranslationDisc.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslationDisc.r[1] ^ 2.0 + fixedTranslationDisc.r[2] ^ 2.0);
//   parameter String fixedTranslationDisc.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslationDisc.r0[1] / fixedTranslationDisc.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslationDisc.r0[2] / fixedTranslationDisc.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.l \"Length of visual object\";
//   input Real fixedTranslationDisc.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslationDisc.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslationDisc.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslationDisc.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslationDisc.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslationDisc.cylinder.lengthDirection[1],fixedTranslationDisc.cylinder.lengthDirection[2],fixedTranslationDisc.cylinder.lengthDirection[3]});
//   protected Real fixedTranslationDisc.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslationDisc.cylinder.lengthDirection[1] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslationDisc.cylinder.lengthDirection[2] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslationDisc.cylinder.lengthDirection[3] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[2] * fixedTranslationDisc.cylinder.widthDirection[3] - fixedTranslationDisc.cylinder.e_x[3] * fixedTranslationDisc.cylinder.widthDirection[2];
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[3] * fixedTranslationDisc.cylinder.widthDirection[1] - fixedTranslationDisc.cylinder.e_x[1] * fixedTranslationDisc.cylinder.widthDirection[3];
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[1] * fixedTranslationDisc.cylinder.widthDirection[2] - fixedTranslationDisc.cylinder.e_x[2] * fixedTranslationDisc.cylinder.widthDirection[1];
//   protected Real fixedTranslationDisc.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[1];
//   protected Real fixedTranslationDisc.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[2];
//   protected Real fixedTranslationDisc.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslationDisc.cylinder.Form;
//   output Real fixedTranslationDisc.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslationDisc.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.Material;
//   protected output Real fixedTranslationDisc.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real prismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   parameter Boolean prismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   Real fixed1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real revoluteDisc.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDisc.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDisc.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDisc.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDisc.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDisc.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revoluteDisc.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDisc.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDisc.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDisc.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDisc.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDisc.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revoluteDisc.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revoluteDisc.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revoluteDisc.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revoluteDisc.animate = true \"enable Animation\";
//   parameter Boolean revoluteDisc.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revoluteDisc.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revoluteDisc.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revoluteDisc.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revoluteDisc.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revoluteDisc.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revoluteDisc.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revoluteDisc.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revoluteDisc.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revoluteDisc.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revoluteDisc.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revoluteDisc.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revoluteDisc.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revoluteDisc.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revoluteDisc.cylinder.lengthDirection[1],revoluteDisc.cylinder.lengthDirection[2],revoluteDisc.cylinder.lengthDirection[3]});
//   protected Real revoluteDisc.cylinder.e_x[1](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 0.0000000001) then 1.0 else revoluteDisc.cylinder.lengthDirection[1] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.e_x[2](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDisc.cylinder.lengthDirection[2] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.e_x[3](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDisc.cylinder.lengthDirection[3] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.n_z_aux[1](unit = \"1\") = revoluteDisc.cylinder.e_x[2] * revoluteDisc.cylinder.widthDirection[3] - revoluteDisc.cylinder.e_x[3] * revoluteDisc.cylinder.widthDirection[2];
//   protected Real revoluteDisc.cylinder.n_z_aux[2](unit = \"1\") = revoluteDisc.cylinder.e_x[3] * revoluteDisc.cylinder.widthDirection[1] - revoluteDisc.cylinder.e_x[1] * revoluteDisc.cylinder.widthDirection[3];
//   protected Real revoluteDisc.cylinder.n_z_aux[3](unit = \"1\") = revoluteDisc.cylinder.e_x[1] * revoluteDisc.cylinder.widthDirection[2] - revoluteDisc.cylinder.e_x[2] * revoluteDisc.cylinder.widthDirection[1];
//   protected Real revoluteDisc.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[1];
//   protected Real revoluteDisc.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[2];
//   protected Real revoluteDisc.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[3];
//   protected output Real revoluteDisc.cylinder.Form;
//   output Real revoluteDisc.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revoluteDisc.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.Material;
//   protected output Real revoluteDisc.cylinder.Extra;
//   Real pistonRod.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real pistonRod.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real pistonRod.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real pistonRod.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real pistonRod.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real pistonRod.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real pistonRod.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real pistonRod.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real pistonRod.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real pistonRod.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real pistonRod.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real pistonRod.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real pistonRod.r[1](quantity = \"Length\", unit = \"m\") = 0.8 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real pistonRod.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real pistonRod.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real pistonRod.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real pistonRod.R[1,1] \"Rotation matrix\";
//   Real pistonRod.R[1,2] \"Rotation matrix\";
//   Real pistonRod.R[2,1] \"Rotation matrix\";
//   Real pistonRod.R[2,2] \"Rotation matrix\";
//   parameter Boolean pistonRod.animate = true \"enable Animation\";
//   final parameter Real pistonRod.l(quantity = \"Length\", unit = \"m\") = sqrt(pistonRod.r[1] ^ 2.0 + pistonRod.r[2] ^ 2.0);
//   parameter String pistonRod.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real pistonRod.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.r[1](quantity = \"Length\", unit = \"m\") = pistonRod.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r[2](quantity = \"Length\", unit = \"m\") = pistonRod.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[1](unit = \"1\") = pistonRod.r0[1] / pistonRod.l \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[2](unit = \"1\") = pistonRod.r0[2] / pistonRod.l \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.length(quantity = \"Length\", unit = \"m\") = pistonRod.l \"Length of visual object\";
//   input Real pistonRod.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real pistonRod.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real pistonRod.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real pistonRod.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real pistonRod.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({pistonRod.cylinder.lengthDirection[1],pistonRod.cylinder.lengthDirection[2],pistonRod.cylinder.lengthDirection[3]});
//   protected Real pistonRod.cylinder.e_x[1](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 0.0000000001) then 1.0 else pistonRod.cylinder.lengthDirection[1] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.e_x[2](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 0.0000000001) then 0.0 else pistonRod.cylinder.lengthDirection[2] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.e_x[3](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 0.0000000001) then 0.0 else pistonRod.cylinder.lengthDirection[3] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.n_z_aux[1](unit = \"1\") = pistonRod.cylinder.e_x[2] * pistonRod.cylinder.widthDirection[3] - pistonRod.cylinder.e_x[3] * pistonRod.cylinder.widthDirection[2];
//   protected Real pistonRod.cylinder.n_z_aux[2](unit = \"1\") = pistonRod.cylinder.e_x[3] * pistonRod.cylinder.widthDirection[1] - pistonRod.cylinder.e_x[1] * pistonRod.cylinder.widthDirection[3];
//   protected Real pistonRod.cylinder.n_z_aux[3](unit = \"1\") = pistonRod.cylinder.e_x[1] * pistonRod.cylinder.widthDirection[2] - pistonRod.cylinder.e_x[2] * pistonRod.cylinder.widthDirection[1];
//   protected Real pistonRod.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[1];
//   protected Real pistonRod.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[2];
//   protected Real pistonRod.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[3];
//   protected output Real pistonRod.cylinder.Form;
//   output Real pistonRod.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real pistonRod.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.Material;
//   protected output Real pistonRod.cylinder.Extra;
//   Real bodyPiston.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyPiston.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyPiston.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyPiston.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyPiston.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyPiston.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyPiston.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.0 \"mass of the body\";
//   parameter Real bodyPiston.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyPiston.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyPiston.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real bodyPiston.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyPiston.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyPiston.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyPiston.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyPiston.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyPiston.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyPiston.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyPiston.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyPiston.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyPiston.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyPiston.animate = true \"enable Animation\";
//   parameter String bodyPiston.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyPiston.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyPiston.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyPiston.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyPiston.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyPiston.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyPiston.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyPiston.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyPiston.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyPiston.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyPiston.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyPiston.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyPiston.sphere.lengthDirection[1],bodyPiston.sphere.lengthDirection[2],bodyPiston.sphere.lengthDirection[3]});
//   protected Real bodyPiston.sphere.e_x[1](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 0.0000000001) then 1.0 else bodyPiston.sphere.lengthDirection[1] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.e_x[2](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyPiston.sphere.lengthDirection[2] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.e_x[3](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyPiston.sphere.lengthDirection[3] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.n_z_aux[1](unit = \"1\") = bodyPiston.sphere.e_x[2] * bodyPiston.sphere.widthDirection[3] - bodyPiston.sphere.e_x[3] * bodyPiston.sphere.widthDirection[2];
//   protected Real bodyPiston.sphere.n_z_aux[2](unit = \"1\") = bodyPiston.sphere.e_x[3] * bodyPiston.sphere.widthDirection[1] - bodyPiston.sphere.e_x[1] * bodyPiston.sphere.widthDirection[3];
//   protected Real bodyPiston.sphere.n_z_aux[3](unit = \"1\") = bodyPiston.sphere.e_x[1] * bodyPiston.sphere.widthDirection[2] - bodyPiston.sphere.e_x[2] * bodyPiston.sphere.widthDirection[1];
//   protected Real bodyPiston.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[1];
//   protected Real bodyPiston.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[2];
//   protected Real bodyPiston.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[3];
//   protected output Real bodyPiston.sphere.Form;
//   output Real bodyPiston.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyPiston.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.Material;
//   protected output Real bodyPiston.sphere.Extra;
//   Real revolutePiston.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolutePiston.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolutePiston.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolutePiston.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolutePiston.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolutePiston.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolutePiston.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolutePiston.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolutePiston.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolutePiston.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolutePiston.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolutePiston.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolutePiston.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolutePiston.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolutePiston.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolutePiston.animate = true \"enable Animation\";
//   parameter Boolean revolutePiston.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolutePiston.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolutePiston.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolutePiston.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolutePiston.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolutePiston.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolutePiston.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolutePiston.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolutePiston.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolutePiston.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolutePiston.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolutePiston.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolutePiston.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolutePiston.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolutePiston.cylinder.lengthDirection[1],revolutePiston.cylinder.lengthDirection[2],revolutePiston.cylinder.lengthDirection[3]});
//   protected Real revolutePiston.cylinder.e_x[1](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolutePiston.cylinder.lengthDirection[1] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.e_x[2](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolutePiston.cylinder.lengthDirection[2] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.e_x[3](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolutePiston.cylinder.lengthDirection[3] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.n_z_aux[1](unit = \"1\") = revolutePiston.cylinder.e_x[2] * revolutePiston.cylinder.widthDirection[3] - revolutePiston.cylinder.e_x[3] * revolutePiston.cylinder.widthDirection[2];
//   protected Real revolutePiston.cylinder.n_z_aux[2](unit = \"1\") = revolutePiston.cylinder.e_x[3] * revolutePiston.cylinder.widthDirection[1] - revolutePiston.cylinder.e_x[1] * revolutePiston.cylinder.widthDirection[3];
//   protected Real revolutePiston.cylinder.n_z_aux[3](unit = \"1\") = revolutePiston.cylinder.e_x[1] * revolutePiston.cylinder.widthDirection[2] - revolutePiston.cylinder.e_x[2] * revolutePiston.cylinder.widthDirection[1];
//   protected Real revolutePiston.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[1];
//   protected Real revolutePiston.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[2];
//   protected Real revolutePiston.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[3];
//   protected output Real revolutePiston.cylinder.Form;
//   output Real revolutePiston.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolutePiston.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.Material;
//   protected output Real revolutePiston.cylinder.Extra;
// initial equation
//   revoluteDrive.phi = revoluteDrive.phi_start;
//   revoluteDrive.w = revoluteDrive.w_start;
// equation
//   bodyDrive.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyDrive.sphere.shapeType);
//   bodyDrive.sphere.rxvisobj[1] = bodyDrive.sphere.R.T[1,1] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,1] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,1] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.rxvisobj[2] = bodyDrive.sphere.R.T[1,2] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,2] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,2] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.rxvisobj[3] = bodyDrive.sphere.R.T[1,3] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,3] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,3] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.ryvisobj[1] = bodyDrive.sphere.R.T[1,1] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,1] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,1] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.ryvisobj[2] = bodyDrive.sphere.R.T[1,2] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,2] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,2] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.ryvisobj[3] = bodyDrive.sphere.R.T[1,3] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,3] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,3] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.rvisobj = bodyDrive.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyDrive.sphere.R.T[1,1],bodyDrive.sphere.R.T[1,2],bodyDrive.sphere.R.T[1,3]},{bodyDrive.sphere.R.T[2,1],bodyDrive.sphere.R.T[2,2],bodyDrive.sphere.R.T[2,3]},{bodyDrive.sphere.R.T[3,1],bodyDrive.sphere.R.T[3,2],bodyDrive.sphere.R.T[3,3]}},{bodyDrive.sphere.r_shape[1],bodyDrive.sphere.r_shape[2],bodyDrive.sphere.r_shape[3]});
//   bodyDrive.sphere.size[1] = bodyDrive.sphere.length;
//   bodyDrive.sphere.size[2] = bodyDrive.sphere.width;
//   bodyDrive.sphere.size[3] = bodyDrive.sphere.height;
//   bodyDrive.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyDrive.sphere.color[1] / 255.0,bodyDrive.sphere.color[2] / 255.0,bodyDrive.sphere.color[3] / 255.0,bodyDrive.sphere.specularCoefficient);
//   bodyDrive.sphere.Extra = bodyDrive.sphere.extra;
//   bodyDrive.r[1] = bodyDrive.frame_a.x;
//   bodyDrive.r[2] = bodyDrive.frame_a.y;
//   bodyDrive.v[1] = der(bodyDrive.r[1]);
//   bodyDrive.v[2] = der(bodyDrive.r[2]);
//   bodyDrive.w = der(bodyDrive.frame_a.phi);
//   bodyDrive.a[1] = der(bodyDrive.v[1]);
//   bodyDrive.a[2] = der(bodyDrive.v[2]);
//   bodyDrive.z = der(bodyDrive.w);
//   bodyDrive.f[1] = bodyDrive.frame_a.fx;
//   bodyDrive.f[2] = bodyDrive.frame_a.fy;
//   bodyDrive.f[1] + bodyDrive.g[1] * bodyDrive.m = bodyDrive.a[1] * bodyDrive.m;
//   bodyDrive.f[2] + bodyDrive.g[2] * bodyDrive.m = bodyDrive.a[2] * bodyDrive.m;
//   bodyDrive.frame_a.t = bodyDrive.I * bodyDrive.z;
//   revoluteDrive.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revoluteDrive.cylinder.shapeType);
//   revoluteDrive.cylinder.rxvisobj[1] = revoluteDrive.cylinder.R.T[1,1] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,1] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,1] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.rxvisobj[2] = revoluteDrive.cylinder.R.T[1,2] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,2] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,2] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.rxvisobj[3] = revoluteDrive.cylinder.R.T[1,3] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,3] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,3] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.ryvisobj[1] = revoluteDrive.cylinder.R.T[1,1] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,1] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,1] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.ryvisobj[2] = revoluteDrive.cylinder.R.T[1,2] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,2] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,2] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.ryvisobj[3] = revoluteDrive.cylinder.R.T[1,3] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,3] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,3] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.rvisobj = revoluteDrive.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revoluteDrive.cylinder.R.T[1,1],revoluteDrive.cylinder.R.T[1,2],revoluteDrive.cylinder.R.T[1,3]},{revoluteDrive.cylinder.R.T[2,1],revoluteDrive.cylinder.R.T[2,2],revoluteDrive.cylinder.R.T[2,3]},{revoluteDrive.cylinder.R.T[3,1],revoluteDrive.cylinder.R.T[3,2],revoluteDrive.cylinder.R.T[3,3]}},{revoluteDrive.cylinder.r_shape[1],revoluteDrive.cylinder.r_shape[2],revoluteDrive.cylinder.r_shape[3]});
//   revoluteDrive.cylinder.size[1] = revoluteDrive.cylinder.length;
//   revoluteDrive.cylinder.size[2] = revoluteDrive.cylinder.width;
//   revoluteDrive.cylinder.size[3] = revoluteDrive.cylinder.height;
//   revoluteDrive.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revoluteDrive.cylinder.color[1] / 255.0,revoluteDrive.cylinder.color[2] / 255.0,revoluteDrive.cylinder.color[3] / 255.0,revoluteDrive.cylinder.specularCoefficient);
//   revoluteDrive.cylinder.Extra = revoluteDrive.cylinder.extra;
//   revoluteDrive.w = der(revoluteDrive.phi);
//   revoluteDrive.z = der(revoluteDrive.w);
//   revoluteDrive.t = 0.0;
//   revoluteDrive.frame_a.x = revoluteDrive.frame_b.x;
//   revoluteDrive.frame_a.y = revoluteDrive.frame_b.y;
//   revoluteDrive.frame_a.phi + revoluteDrive.phi = revoluteDrive.frame_b.phi;
//   revoluteDrive.frame_a.fx + revoluteDrive.frame_b.fx = 0.0;
//   revoluteDrive.frame_a.fy + revoluteDrive.frame_b.fy = 0.0;
//   revoluteDrive.frame_a.t + revoluteDrive.frame_b.t = 0.0;
//   revoluteDrive.frame_a.t = revoluteDrive.t;
//   fixedTranslationDisc.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslationDisc.cylinder.shapeType);
//   fixedTranslationDisc.cylinder.rxvisobj[1] = fixedTranslationDisc.cylinder.R.T[1,1] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,1] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,1] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.rxvisobj[2] = fixedTranslationDisc.cylinder.R.T[1,2] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,2] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,2] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.rxvisobj[3] = fixedTranslationDisc.cylinder.R.T[1,3] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,3] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,3] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.ryvisobj[1] = fixedTranslationDisc.cylinder.R.T[1,1] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,1] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,1] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.ryvisobj[2] = fixedTranslationDisc.cylinder.R.T[1,2] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,2] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,2] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.ryvisobj[3] = fixedTranslationDisc.cylinder.R.T[1,3] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,3] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,3] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.rvisobj = fixedTranslationDisc.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslationDisc.cylinder.R.T[1,1],fixedTranslationDisc.cylinder.R.T[1,2],fixedTranslationDisc.cylinder.R.T[1,3]},{fixedTranslationDisc.cylinder.R.T[2,1],fixedTranslationDisc.cylinder.R.T[2,2],fixedTranslationDisc.cylinder.R.T[2,3]},{fixedTranslationDisc.cylinder.R.T[3,1],fixedTranslationDisc.cylinder.R.T[3,2],fixedTranslationDisc.cylinder.R.T[3,3]}},{fixedTranslationDisc.cylinder.r_shape[1],fixedTranslationDisc.cylinder.r_shape[2],fixedTranslationDisc.cylinder.r_shape[3]});
//   fixedTranslationDisc.cylinder.size[1] = fixedTranslationDisc.cylinder.length;
//   fixedTranslationDisc.cylinder.size[2] = fixedTranslationDisc.cylinder.width;
//   fixedTranslationDisc.cylinder.size[3] = fixedTranslationDisc.cylinder.height;
//   fixedTranslationDisc.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslationDisc.cylinder.color[1] / 255.0,fixedTranslationDisc.cylinder.color[2] / 255.0,fixedTranslationDisc.cylinder.color[3] / 255.0,fixedTranslationDisc.cylinder.specularCoefficient);
//   fixedTranslationDisc.cylinder.Extra = fixedTranslationDisc.cylinder.extra;
//   fixedTranslationDisc.R[1,1] = cos(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[1,2] = sin(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[2,1] = -sin(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[2,2] = cos(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.r0[1] = fixedTranslationDisc.R[1,1] * fixedTranslationDisc.r[1] + fixedTranslationDisc.R[1,2] * fixedTranslationDisc.r[2];
//   fixedTranslationDisc.r0[2] = fixedTranslationDisc.R[2,1] * fixedTranslationDisc.r[1] + fixedTranslationDisc.R[2,2] * fixedTranslationDisc.r[2];
//   fixedTranslationDisc.frame_a.x + fixedTranslationDisc.r0[1] = fixedTranslationDisc.frame_b.x;
//   fixedTranslationDisc.frame_a.y + fixedTranslationDisc.r0[2] = fixedTranslationDisc.frame_b.y;
//   fixedTranslationDisc.frame_a.phi = fixedTranslationDisc.frame_b.phi;
//   fixedTranslationDisc.frame_a.fx + fixedTranslationDisc.frame_b.fx = 0.0;
//   fixedTranslationDisc.frame_a.fy + fixedTranslationDisc.frame_b.fy = 0.0;
//   fixedTranslationDisc.frame_a.t + (fixedTranslationDisc.frame_b.t + ((-fixedTranslationDisc.r0[1]) * fixedTranslationDisc.frame_b.fy + fixedTranslationDisc.r0[2] * fixedTranslationDisc.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.e0[1] = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2];
//   prismatic.e0[2] = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2];
//   prismatic.r0[1] = prismatic.e0[1] * prismatic.s;
//   prismatic.r0[2] = prismatic.e0[2] * prismatic.s;
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * prismatic.e0[1] + prismatic.frame_a.fy * prismatic.e0[2] = 0.0;
//   fixed1.frame_a.x = fixed1.r[1];
//   fixed1.frame_a.y = fixed1.r[2];
//   fixed1.frame_a.phi = fixed1.phi;
//   revoluteDisc.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revoluteDisc.cylinder.shapeType);
//   revoluteDisc.cylinder.rxvisobj[1] = revoluteDisc.cylinder.R.T[1,1] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,1] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,1] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.rxvisobj[2] = revoluteDisc.cylinder.R.T[1,2] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,2] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,2] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.rxvisobj[3] = revoluteDisc.cylinder.R.T[1,3] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,3] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,3] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.ryvisobj[1] = revoluteDisc.cylinder.R.T[1,1] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,1] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,1] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.ryvisobj[2] = revoluteDisc.cylinder.R.T[1,2] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,2] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,2] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.ryvisobj[3] = revoluteDisc.cylinder.R.T[1,3] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,3] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,3] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.rvisobj = revoluteDisc.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revoluteDisc.cylinder.R.T[1,1],revoluteDisc.cylinder.R.T[1,2],revoluteDisc.cylinder.R.T[1,3]},{revoluteDisc.cylinder.R.T[2,1],revoluteDisc.cylinder.R.T[2,2],revoluteDisc.cylinder.R.T[2,3]},{revoluteDisc.cylinder.R.T[3,1],revoluteDisc.cylinder.R.T[3,2],revoluteDisc.cylinder.R.T[3,3]}},{revoluteDisc.cylinder.r_shape[1],revoluteDisc.cylinder.r_shape[2],revoluteDisc.cylinder.r_shape[3]});
//   revoluteDisc.cylinder.size[1] = revoluteDisc.cylinder.length;
//   revoluteDisc.cylinder.size[2] = revoluteDisc.cylinder.width;
//   revoluteDisc.cylinder.size[3] = revoluteDisc.cylinder.height;
//   revoluteDisc.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revoluteDisc.cylinder.color[1] / 255.0,revoluteDisc.cylinder.color[2] / 255.0,revoluteDisc.cylinder.color[3] / 255.0,revoluteDisc.cylinder.specularCoefficient);
//   revoluteDisc.cylinder.Extra = revoluteDisc.cylinder.extra;
//   revoluteDisc.w = der(revoluteDisc.phi);
//   revoluteDisc.z = der(revoluteDisc.w);
//   revoluteDisc.t = 0.0;
//   revoluteDisc.frame_a.x = revoluteDisc.frame_b.x;
//   revoluteDisc.frame_a.y = revoluteDisc.frame_b.y;
//   revoluteDisc.frame_a.phi + revoluteDisc.phi = revoluteDisc.frame_b.phi;
//   revoluteDisc.frame_a.fx + revoluteDisc.frame_b.fx = 0.0;
//   revoluteDisc.frame_a.fy + revoluteDisc.frame_b.fy = 0.0;
//   revoluteDisc.frame_a.t + revoluteDisc.frame_b.t = 0.0;
//   revoluteDisc.frame_a.t = revoluteDisc.t;
//   pistonRod.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pistonRod.cylinder.shapeType);
//   pistonRod.cylinder.rxvisobj[1] = pistonRod.cylinder.R.T[1,1] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,1] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,1] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.rxvisobj[2] = pistonRod.cylinder.R.T[1,2] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,2] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,2] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.rxvisobj[3] = pistonRod.cylinder.R.T[1,3] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,3] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,3] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.ryvisobj[1] = pistonRod.cylinder.R.T[1,1] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,1] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,1] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.ryvisobj[2] = pistonRod.cylinder.R.T[1,2] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,2] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,2] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.ryvisobj[3] = pistonRod.cylinder.R.T[1,3] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,3] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,3] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.rvisobj = pistonRod.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pistonRod.cylinder.R.T[1,1],pistonRod.cylinder.R.T[1,2],pistonRod.cylinder.R.T[1,3]},{pistonRod.cylinder.R.T[2,1],pistonRod.cylinder.R.T[2,2],pistonRod.cylinder.R.T[2,3]},{pistonRod.cylinder.R.T[3,1],pistonRod.cylinder.R.T[3,2],pistonRod.cylinder.R.T[3,3]}},{pistonRod.cylinder.r_shape[1],pistonRod.cylinder.r_shape[2],pistonRod.cylinder.r_shape[3]});
//   pistonRod.cylinder.size[1] = pistonRod.cylinder.length;
//   pistonRod.cylinder.size[2] = pistonRod.cylinder.width;
//   pistonRod.cylinder.size[3] = pistonRod.cylinder.height;
//   pistonRod.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pistonRod.cylinder.color[1] / 255.0,pistonRod.cylinder.color[2] / 255.0,pistonRod.cylinder.color[3] / 255.0,pistonRod.cylinder.specularCoefficient);
//   pistonRod.cylinder.Extra = pistonRod.cylinder.extra;
//   pistonRod.R[1,1] = cos(pistonRod.frame_a.phi);
//   pistonRod.R[1,2] = sin(pistonRod.frame_a.phi);
//   pistonRod.R[2,1] = -sin(pistonRod.frame_a.phi);
//   pistonRod.R[2,2] = cos(pistonRod.frame_a.phi);
//   pistonRod.r0[1] = pistonRod.R[1,1] * pistonRod.r[1] + pistonRod.R[1,2] * pistonRod.r[2];
//   pistonRod.r0[2] = pistonRod.R[2,1] * pistonRod.r[1] + pistonRod.R[2,2] * pistonRod.r[2];
//   pistonRod.frame_a.x + pistonRod.r0[1] = pistonRod.frame_b.x;
//   pistonRod.frame_a.y + pistonRod.r0[2] = pistonRod.frame_b.y;
//   pistonRod.frame_a.phi = pistonRod.frame_b.phi;
//   pistonRod.frame_a.fx + pistonRod.frame_b.fx = 0.0;
//   pistonRod.frame_a.fy + pistonRod.frame_b.fy = 0.0;
//   pistonRod.frame_a.t + (pistonRod.frame_b.t + ((-pistonRod.r0[1]) * pistonRod.frame_b.fy + pistonRod.r0[2] * pistonRod.frame_b.fx)) = 0.0;
//   bodyPiston.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyPiston.sphere.shapeType);
//   bodyPiston.sphere.rxvisobj[1] = bodyPiston.sphere.R.T[1,1] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,1] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,1] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.rxvisobj[2] = bodyPiston.sphere.R.T[1,2] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,2] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,2] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.rxvisobj[3] = bodyPiston.sphere.R.T[1,3] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,3] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,3] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.ryvisobj[1] = bodyPiston.sphere.R.T[1,1] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,1] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,1] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.ryvisobj[2] = bodyPiston.sphere.R.T[1,2] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,2] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,2] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.ryvisobj[3] = bodyPiston.sphere.R.T[1,3] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,3] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,3] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.rvisobj = bodyPiston.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyPiston.sphere.R.T[1,1],bodyPiston.sphere.R.T[1,2],bodyPiston.sphere.R.T[1,3]},{bodyPiston.sphere.R.T[2,1],bodyPiston.sphere.R.T[2,2],bodyPiston.sphere.R.T[2,3]},{bodyPiston.sphere.R.T[3,1],bodyPiston.sphere.R.T[3,2],bodyPiston.sphere.R.T[3,3]}},{bodyPiston.sphere.r_shape[1],bodyPiston.sphere.r_shape[2],bodyPiston.sphere.r_shape[3]});
//   bodyPiston.sphere.size[1] = bodyPiston.sphere.length;
//   bodyPiston.sphere.size[2] = bodyPiston.sphere.width;
//   bodyPiston.sphere.size[3] = bodyPiston.sphere.height;
//   bodyPiston.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyPiston.sphere.color[1] / 255.0,bodyPiston.sphere.color[2] / 255.0,bodyPiston.sphere.color[3] / 255.0,bodyPiston.sphere.specularCoefficient);
//   bodyPiston.sphere.Extra = bodyPiston.sphere.extra;
//   bodyPiston.r[1] = bodyPiston.frame_a.x;
//   bodyPiston.r[2] = bodyPiston.frame_a.y;
//   bodyPiston.v[1] = der(bodyPiston.r[1]);
//   bodyPiston.v[2] = der(bodyPiston.r[2]);
//   bodyPiston.w = der(bodyPiston.frame_a.phi);
//   bodyPiston.a[1] = der(bodyPiston.v[1]);
//   bodyPiston.a[2] = der(bodyPiston.v[2]);
//   bodyPiston.z = der(bodyPiston.w);
//   bodyPiston.f[1] = bodyPiston.frame_a.fx;
//   bodyPiston.f[2] = bodyPiston.frame_a.fy;
//   bodyPiston.f[1] + bodyPiston.g[1] * bodyPiston.m = bodyPiston.a[1] * bodyPiston.m;
//   bodyPiston.f[2] + bodyPiston.g[2] * bodyPiston.m = bodyPiston.a[2] * bodyPiston.m;
//   bodyPiston.frame_a.t = bodyPiston.I * bodyPiston.z;
//   revolutePiston.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolutePiston.cylinder.shapeType);
//   revolutePiston.cylinder.rxvisobj[1] = revolutePiston.cylinder.R.T[1,1] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,1] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,1] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.rxvisobj[2] = revolutePiston.cylinder.R.T[1,2] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,2] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,2] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.rxvisobj[3] = revolutePiston.cylinder.R.T[1,3] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,3] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,3] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.ryvisobj[1] = revolutePiston.cylinder.R.T[1,1] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,1] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,1] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.ryvisobj[2] = revolutePiston.cylinder.R.T[1,2] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,2] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,2] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.ryvisobj[3] = revolutePiston.cylinder.R.T[1,3] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,3] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,3] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.rvisobj = revolutePiston.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolutePiston.cylinder.R.T[1,1],revolutePiston.cylinder.R.T[1,2],revolutePiston.cylinder.R.T[1,3]},{revolutePiston.cylinder.R.T[2,1],revolutePiston.cylinder.R.T[2,2],revolutePiston.cylinder.R.T[2,3]},{revolutePiston.cylinder.R.T[3,1],revolutePiston.cylinder.R.T[3,2],revolutePiston.cylinder.R.T[3,3]}},{revolutePiston.cylinder.r_shape[1],revolutePiston.cylinder.r_shape[2],revolutePiston.cylinder.r_shape[3]});
//   revolutePiston.cylinder.size[1] = revolutePiston.cylinder.length;
//   revolutePiston.cylinder.size[2] = revolutePiston.cylinder.width;
//   revolutePiston.cylinder.size[3] = revolutePiston.cylinder.height;
//   revolutePiston.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolutePiston.cylinder.color[1] / 255.0,revolutePiston.cylinder.color[2] / 255.0,revolutePiston.cylinder.color[3] / 255.0,revolutePiston.cylinder.specularCoefficient);
//   revolutePiston.cylinder.Extra = revolutePiston.cylinder.extra;
//   revolutePiston.w = der(revolutePiston.phi);
//   revolutePiston.z = der(revolutePiston.w);
//   revolutePiston.t = 0.0;
//   revolutePiston.frame_a.x = revolutePiston.frame_b.x;
//   revolutePiston.frame_a.y = revolutePiston.frame_b.y;
//   revolutePiston.frame_a.phi + revolutePiston.phi = revolutePiston.frame_b.phi;
//   revolutePiston.frame_a.fx + revolutePiston.frame_b.fx = 0.0;
//   revolutePiston.frame_a.fy + revolutePiston.frame_b.fy = 0.0;
//   revolutePiston.frame_a.t + revolutePiston.frame_b.t = 0.0;
//   revolutePiston.frame_a.t = revolutePiston.t;
//   bodyDrive.frame_a.t + revoluteDrive.frame_b.t + fixedTranslationDisc.frame_a.t = 0.0;
//   bodyDrive.frame_a.fy + revoluteDrive.frame_b.fy + fixedTranslationDisc.frame_a.fy = 0.0;
//   bodyDrive.frame_a.fx + revoluteDrive.frame_b.fx + fixedTranslationDisc.frame_a.fx = 0.0;
//   revoluteDrive.frame_a.t + fixed.frame_a.t = 0.0;
//   revoluteDrive.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revoluteDrive.frame_a.fx + fixed.frame_a.fx = 0.0;
//   fixedTranslationDisc.frame_b.t + revoluteDisc.frame_a.t = 0.0;
//   fixedTranslationDisc.frame_b.fy + revoluteDisc.frame_a.fy = 0.0;
//   fixedTranslationDisc.frame_b.fx + revoluteDisc.frame_a.fx = 0.0;
//   prismatic.frame_a.t + bodyPiston.frame_a.t + revolutePiston.frame_a.t = 0.0;
//   prismatic.frame_a.fy + bodyPiston.frame_a.fy + revolutePiston.frame_a.fy = 0.0;
//   prismatic.frame_a.fx + bodyPiston.frame_a.fx + revolutePiston.frame_a.fx = 0.0;
//   prismatic.frame_b.t + fixed1.frame_a.t = 0.0;
//   prismatic.frame_b.fy + fixed1.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + fixed1.frame_a.fx = 0.0;
//   revoluteDisc.frame_b.t + pistonRod.frame_a.t = 0.0;
//   revoluteDisc.frame_b.fy + pistonRod.frame_a.fy = 0.0;
//   revoluteDisc.frame_b.fx + pistonRod.frame_a.fx = 0.0;
//   pistonRod.frame_b.t + revolutePiston.frame_b.t = 0.0;
//   pistonRod.frame_b.fy + revolutePiston.frame_b.fy = 0.0;
//   pistonRod.frame_b.fx + revolutePiston.frame_b.fx = 0.0;
//   fixed.frame_a.x = revoluteDrive.frame_a.x;
//   fixed.frame_a.y = revoluteDrive.frame_a.y;
//   fixed.frame_a.phi = revoluteDrive.frame_a.phi;
//   bodyDrive.frame_a.x = fixedTranslationDisc.frame_a.x;
//   bodyDrive.frame_a.x = revoluteDrive.frame_b.x;
//   bodyDrive.frame_a.y = fixedTranslationDisc.frame_a.y;
//   bodyDrive.frame_a.y = revoluteDrive.frame_b.y;
//   bodyDrive.frame_a.phi = fixedTranslationDisc.frame_a.phi;
//   bodyDrive.frame_a.phi = revoluteDrive.frame_b.phi;
//   fixed1.frame_a.x = prismatic.frame_b.x;
//   fixed1.frame_a.y = prismatic.frame_b.y;
//   fixed1.frame_a.phi = prismatic.frame_b.phi;
//   fixedTranslationDisc.frame_b.x = revoluteDisc.frame_a.x;
//   fixedTranslationDisc.frame_b.y = revoluteDisc.frame_a.y;
//   fixedTranslationDisc.frame_b.phi = revoluteDisc.frame_a.phi;
//   pistonRod.frame_a.x = revoluteDisc.frame_b.x;
//   pistonRod.frame_a.y = revoluteDisc.frame_b.y;
//   pistonRod.frame_a.phi = revoluteDisc.frame_b.phi;
//   pistonRod.frame_b.x = revolutePiston.frame_b.x;
//   pistonRod.frame_b.y = revolutePiston.frame_b.y;
//   pistonRod.frame_b.phi = revolutePiston.frame_b.phi;
//   bodyPiston.frame_a.x = prismatic.frame_a.x;
//   bodyPiston.frame_a.x = revolutePiston.frame_a.x;
//   bodyPiston.frame_a.y = prismatic.frame_a.y;
//   bodyPiston.frame_a.y = revolutePiston.frame_a.y;
//   bodyPiston.frame_a.phi = prismatic.frame_a.phi;
//   bodyPiston.frame_a.phi = revolutePiston.frame_a.phi;
// end PlanarMechanicsForTesting.Examples.PistonEngine;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.PistonEngine_DynamicStateSelection
//   Real bodyDrive.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyDrive.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyDrive.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyDrive.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyDrive.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyDrive.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyDrive.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real bodyDrive.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyDrive.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyDrive.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real bodyDrive.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyDrive.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyDrive.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyDrive.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyDrive.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyDrive.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyDrive.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyDrive.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyDrive.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyDrive.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyDrive.animate = true \"enable Animation\";
//   parameter String bodyDrive.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyDrive.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyDrive.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyDrive.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyDrive.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyDrive.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyDrive.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyDrive.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyDrive.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyDrive.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyDrive.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyDrive.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyDrive.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyDrive.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyDrive.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyDrive.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyDrive.sphere.lengthDirection[1],bodyDrive.sphere.lengthDirection[2],bodyDrive.sphere.lengthDirection[3]});
//   protected Real bodyDrive.sphere.e_x[1](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 0.0000000001) then 1.0 else bodyDrive.sphere.lengthDirection[1] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.e_x[2](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyDrive.sphere.lengthDirection[2] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.e_x[3](unit = \"1\") = if noEvent(bodyDrive.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyDrive.sphere.lengthDirection[3] / bodyDrive.sphere.abs_n_x;
//   protected Real bodyDrive.sphere.n_z_aux[1](unit = \"1\") = bodyDrive.sphere.e_x[2] * bodyDrive.sphere.widthDirection[3] - bodyDrive.sphere.e_x[3] * bodyDrive.sphere.widthDirection[2];
//   protected Real bodyDrive.sphere.n_z_aux[2](unit = \"1\") = bodyDrive.sphere.e_x[3] * bodyDrive.sphere.widthDirection[1] - bodyDrive.sphere.e_x[1] * bodyDrive.sphere.widthDirection[3];
//   protected Real bodyDrive.sphere.n_z_aux[3](unit = \"1\") = bodyDrive.sphere.e_x[1] * bodyDrive.sphere.widthDirection[2] - bodyDrive.sphere.e_x[2] * bodyDrive.sphere.widthDirection[1];
//   protected Real bodyDrive.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[1];
//   protected Real bodyDrive.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[2];
//   protected Real bodyDrive.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]},if noEvent(bodyDrive.sphere.n_z_aux[1] ^ 2.0 + (bodyDrive.sphere.n_z_aux[2] ^ 2.0 + bodyDrive.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyDrive.sphere.widthDirection[1],bodyDrive.sphere.widthDirection[2],bodyDrive.sphere.widthDirection[3]} else if noEvent(abs(bodyDrive.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyDrive.sphere.e_x[1],bodyDrive.sphere.e_x[2],bodyDrive.sphere.e_x[3]})[3];
//   protected output Real bodyDrive.sphere.Form;
//   output Real bodyDrive.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyDrive.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyDrive.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyDrive.sphere.Material;
//   protected output Real bodyDrive.sphere.Extra;
//   Real revoluteDrive.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDrive.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDrive.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDrive.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDrive.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDrive.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revoluteDrive.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDrive.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDrive.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDrive.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDrive.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDrive.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revoluteDrive.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revoluteDrive.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revoluteDrive.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   parameter Boolean revoluteDrive.animate = true \"enable Animation\";
//   parameter Boolean revoluteDrive.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revoluteDrive.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revoluteDrive.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revoluteDrive.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revoluteDrive.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revoluteDrive.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revoluteDrive.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDrive.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDrive.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revoluteDrive.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revoluteDrive.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDrive.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDrive.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revoluteDrive.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revoluteDrive.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revoluteDrive.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revoluteDrive.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revoluteDrive.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revoluteDrive.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revoluteDrive.cylinder.lengthDirection[1],revoluteDrive.cylinder.lengthDirection[2],revoluteDrive.cylinder.lengthDirection[3]});
//   protected Real revoluteDrive.cylinder.e_x[1](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 0.0000000001) then 1.0 else revoluteDrive.cylinder.lengthDirection[1] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.e_x[2](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDrive.cylinder.lengthDirection[2] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.e_x[3](unit = \"1\") = if noEvent(revoluteDrive.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDrive.cylinder.lengthDirection[3] / revoluteDrive.cylinder.abs_n_x;
//   protected Real revoluteDrive.cylinder.n_z_aux[1](unit = \"1\") = revoluteDrive.cylinder.e_x[2] * revoluteDrive.cylinder.widthDirection[3] - revoluteDrive.cylinder.e_x[3] * revoluteDrive.cylinder.widthDirection[2];
//   protected Real revoluteDrive.cylinder.n_z_aux[2](unit = \"1\") = revoluteDrive.cylinder.e_x[3] * revoluteDrive.cylinder.widthDirection[1] - revoluteDrive.cylinder.e_x[1] * revoluteDrive.cylinder.widthDirection[3];
//   protected Real revoluteDrive.cylinder.n_z_aux[3](unit = \"1\") = revoluteDrive.cylinder.e_x[1] * revoluteDrive.cylinder.widthDirection[2] - revoluteDrive.cylinder.e_x[2] * revoluteDrive.cylinder.widthDirection[1];
//   protected Real revoluteDrive.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[1];
//   protected Real revoluteDrive.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[2];
//   protected Real revoluteDrive.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]},if noEvent(revoluteDrive.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDrive.cylinder.n_z_aux[2] ^ 2.0 + revoluteDrive.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDrive.cylinder.widthDirection[1],revoluteDrive.cylinder.widthDirection[2],revoluteDrive.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDrive.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDrive.cylinder.e_x[1],revoluteDrive.cylinder.e_x[2],revoluteDrive.cylinder.e_x[3]})[3];
//   protected output Real revoluteDrive.cylinder.Form;
//   output Real revoluteDrive.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDrive.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revoluteDrive.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDrive.cylinder.Material;
//   protected output Real revoluteDrive.cylinder.Extra;
//   Real fixedTranslationDisc.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslationDisc.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslationDisc.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslationDisc.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslationDisc.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslationDisc.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslationDisc.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslationDisc.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslationDisc.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslationDisc.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslationDisc.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslationDisc.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslationDisc.r[1](quantity = \"Length\", unit = \"m\") = 0.3 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslationDisc.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslationDisc.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslationDisc.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslationDisc.R[1,1] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[1,2] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[2,1] \"Rotation matrix\";
//   Real fixedTranslationDisc.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslationDisc.animate = true \"enable Animation\";
//   final parameter Real fixedTranslationDisc.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslationDisc.r[1] ^ 2.0 + fixedTranslationDisc.r[2] ^ 2.0);
//   parameter String fixedTranslationDisc.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslationDisc.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslationDisc.r0[1] / fixedTranslationDisc.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslationDisc.r0[2] / fixedTranslationDisc.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslationDisc.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslationDisc.l \"Length of visual object\";
//   input Real fixedTranslationDisc.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslationDisc.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslationDisc.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslationDisc.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslationDisc.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslationDisc.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslationDisc.cylinder.lengthDirection[1],fixedTranslationDisc.cylinder.lengthDirection[2],fixedTranslationDisc.cylinder.lengthDirection[3]});
//   protected Real fixedTranslationDisc.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslationDisc.cylinder.lengthDirection[1] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslationDisc.cylinder.lengthDirection[2] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslationDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslationDisc.cylinder.lengthDirection[3] / fixedTranslationDisc.cylinder.abs_n_x;
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[2] * fixedTranslationDisc.cylinder.widthDirection[3] - fixedTranslationDisc.cylinder.e_x[3] * fixedTranslationDisc.cylinder.widthDirection[2];
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[3] * fixedTranslationDisc.cylinder.widthDirection[1] - fixedTranslationDisc.cylinder.e_x[1] * fixedTranslationDisc.cylinder.widthDirection[3];
//   protected Real fixedTranslationDisc.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslationDisc.cylinder.e_x[1] * fixedTranslationDisc.cylinder.widthDirection[2] - fixedTranslationDisc.cylinder.e_x[2] * fixedTranslationDisc.cylinder.widthDirection[1];
//   protected Real fixedTranslationDisc.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[1];
//   protected Real fixedTranslationDisc.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[2];
//   protected Real fixedTranslationDisc.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]},if noEvent(fixedTranslationDisc.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslationDisc.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslationDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslationDisc.cylinder.widthDirection[1],fixedTranslationDisc.cylinder.widthDirection[2],fixedTranslationDisc.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslationDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslationDisc.cylinder.e_x[1],fixedTranslationDisc.cylinder.e_x[2],fixedTranslationDisc.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslationDisc.cylinder.Form;
//   output Real fixedTranslationDisc.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslationDisc.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslationDisc.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslationDisc.cylinder.Material;
//   protected output Real fixedTranslationDisc.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real prismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   parameter Boolean prismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   Real fixed1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real revoluteDisc.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDisc.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDisc.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDisc.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDisc.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDisc.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revoluteDisc.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revoluteDisc.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revoluteDisc.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revoluteDisc.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revoluteDisc.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revoluteDisc.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revoluteDisc.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revoluteDisc.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revoluteDisc.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revoluteDisc.animate = true \"enable Animation\";
//   parameter Boolean revoluteDisc.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revoluteDisc.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revoluteDisc.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revoluteDisc.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revoluteDisc.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revoluteDisc.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revoluteDisc.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revoluteDisc.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revoluteDisc.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revoluteDisc.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revoluteDisc.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revoluteDisc.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revoluteDisc.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revoluteDisc.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revoluteDisc.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revoluteDisc.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revoluteDisc.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revoluteDisc.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revoluteDisc.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revoluteDisc.cylinder.lengthDirection[1],revoluteDisc.cylinder.lengthDirection[2],revoluteDisc.cylinder.lengthDirection[3]});
//   protected Real revoluteDisc.cylinder.e_x[1](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 0.0000000001) then 1.0 else revoluteDisc.cylinder.lengthDirection[1] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.e_x[2](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDisc.cylinder.lengthDirection[2] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.e_x[3](unit = \"1\") = if noEvent(revoluteDisc.cylinder.abs_n_x < 0.0000000001) then 0.0 else revoluteDisc.cylinder.lengthDirection[3] / revoluteDisc.cylinder.abs_n_x;
//   protected Real revoluteDisc.cylinder.n_z_aux[1](unit = \"1\") = revoluteDisc.cylinder.e_x[2] * revoluteDisc.cylinder.widthDirection[3] - revoluteDisc.cylinder.e_x[3] * revoluteDisc.cylinder.widthDirection[2];
//   protected Real revoluteDisc.cylinder.n_z_aux[2](unit = \"1\") = revoluteDisc.cylinder.e_x[3] * revoluteDisc.cylinder.widthDirection[1] - revoluteDisc.cylinder.e_x[1] * revoluteDisc.cylinder.widthDirection[3];
//   protected Real revoluteDisc.cylinder.n_z_aux[3](unit = \"1\") = revoluteDisc.cylinder.e_x[1] * revoluteDisc.cylinder.widthDirection[2] - revoluteDisc.cylinder.e_x[2] * revoluteDisc.cylinder.widthDirection[1];
//   protected Real revoluteDisc.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[1];
//   protected Real revoluteDisc.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[2];
//   protected Real revoluteDisc.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]},if noEvent(revoluteDisc.cylinder.n_z_aux[1] ^ 2.0 + (revoluteDisc.cylinder.n_z_aux[2] ^ 2.0 + revoluteDisc.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revoluteDisc.cylinder.widthDirection[1],revoluteDisc.cylinder.widthDirection[2],revoluteDisc.cylinder.widthDirection[3]} else if noEvent(abs(revoluteDisc.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revoluteDisc.cylinder.e_x[1],revoluteDisc.cylinder.e_x[2],revoluteDisc.cylinder.e_x[3]})[3];
//   protected output Real revoluteDisc.cylinder.Form;
//   output Real revoluteDisc.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revoluteDisc.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revoluteDisc.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revoluteDisc.cylinder.Material;
//   protected output Real revoluteDisc.cylinder.Extra;
//   Real pistonRod.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real pistonRod.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real pistonRod.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real pistonRod.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real pistonRod.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real pistonRod.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real pistonRod.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real pistonRod.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real pistonRod.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real pistonRod.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real pistonRod.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real pistonRod.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real pistonRod.r[1](quantity = \"Length\", unit = \"m\") = 0.8 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real pistonRod.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real pistonRod.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real pistonRod.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real pistonRod.R[1,1] \"Rotation matrix\";
//   Real pistonRod.R[1,2] \"Rotation matrix\";
//   Real pistonRod.R[2,1] \"Rotation matrix\";
//   Real pistonRod.R[2,2] \"Rotation matrix\";
//   parameter Boolean pistonRod.animate = true \"enable Animation\";
//   final parameter Real pistonRod.l(quantity = \"Length\", unit = \"m\") = sqrt(pistonRod.r[1] ^ 2.0 + pistonRod.r[2] ^ 2.0);
//   parameter String pistonRod.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real pistonRod.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real pistonRod.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real pistonRod.cylinder.r[1](quantity = \"Length\", unit = \"m\") = pistonRod.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r[2](quantity = \"Length\", unit = \"m\") = pistonRod.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real pistonRod.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[1](unit = \"1\") = pistonRod.r0[1] / pistonRod.l \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[2](unit = \"1\") = pistonRod.r0[2] / pistonRod.l \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real pistonRod.cylinder.length(quantity = \"Length\", unit = \"m\") = pistonRod.l \"Length of visual object\";
//   input Real pistonRod.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real pistonRod.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real pistonRod.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real pistonRod.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real pistonRod.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real pistonRod.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({pistonRod.cylinder.lengthDirection[1],pistonRod.cylinder.lengthDirection[2],pistonRod.cylinder.lengthDirection[3]});
//   protected Real pistonRod.cylinder.e_x[1](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 0.0000000001) then 1.0 else pistonRod.cylinder.lengthDirection[1] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.e_x[2](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 0.0000000001) then 0.0 else pistonRod.cylinder.lengthDirection[2] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.e_x[3](unit = \"1\") = if noEvent(pistonRod.cylinder.abs_n_x < 0.0000000001) then 0.0 else pistonRod.cylinder.lengthDirection[3] / pistonRod.cylinder.abs_n_x;
//   protected Real pistonRod.cylinder.n_z_aux[1](unit = \"1\") = pistonRod.cylinder.e_x[2] * pistonRod.cylinder.widthDirection[3] - pistonRod.cylinder.e_x[3] * pistonRod.cylinder.widthDirection[2];
//   protected Real pistonRod.cylinder.n_z_aux[2](unit = \"1\") = pistonRod.cylinder.e_x[3] * pistonRod.cylinder.widthDirection[1] - pistonRod.cylinder.e_x[1] * pistonRod.cylinder.widthDirection[3];
//   protected Real pistonRod.cylinder.n_z_aux[3](unit = \"1\") = pistonRod.cylinder.e_x[1] * pistonRod.cylinder.widthDirection[2] - pistonRod.cylinder.e_x[2] * pistonRod.cylinder.widthDirection[1];
//   protected Real pistonRod.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[1];
//   protected Real pistonRod.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[2];
//   protected Real pistonRod.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]},if noEvent(pistonRod.cylinder.n_z_aux[1] ^ 2.0 + (pistonRod.cylinder.n_z_aux[2] ^ 2.0 + pistonRod.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {pistonRod.cylinder.widthDirection[1],pistonRod.cylinder.widthDirection[2],pistonRod.cylinder.widthDirection[3]} else if noEvent(abs(pistonRod.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{pistonRod.cylinder.e_x[1],pistonRod.cylinder.e_x[2],pistonRod.cylinder.e_x[3]})[3];
//   protected output Real pistonRod.cylinder.Form;
//   output Real pistonRod.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real pistonRod.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real pistonRod.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real pistonRod.cylinder.Material;
//   protected output Real pistonRod.cylinder.Extra;
//   Real bodyPiston.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyPiston.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyPiston.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyPiston.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyPiston.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyPiston.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyPiston.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 3.0 \"mass of the body\";
//   parameter Real bodyPiston.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyPiston.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyPiston.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real bodyPiston.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyPiston.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyPiston.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyPiston.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyPiston.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyPiston.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyPiston.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyPiston.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyPiston.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyPiston.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyPiston.animate = true \"enable Animation\";
//   parameter String bodyPiston.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyPiston.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyPiston.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyPiston.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyPiston.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyPiston.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyPiston.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyPiston.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyPiston.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyPiston.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyPiston.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyPiston.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyPiston.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyPiston.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyPiston.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyPiston.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyPiston.sphere.lengthDirection[1],bodyPiston.sphere.lengthDirection[2],bodyPiston.sphere.lengthDirection[3]});
//   protected Real bodyPiston.sphere.e_x[1](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 0.0000000001) then 1.0 else bodyPiston.sphere.lengthDirection[1] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.e_x[2](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyPiston.sphere.lengthDirection[2] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.e_x[3](unit = \"1\") = if noEvent(bodyPiston.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyPiston.sphere.lengthDirection[3] / bodyPiston.sphere.abs_n_x;
//   protected Real bodyPiston.sphere.n_z_aux[1](unit = \"1\") = bodyPiston.sphere.e_x[2] * bodyPiston.sphere.widthDirection[3] - bodyPiston.sphere.e_x[3] * bodyPiston.sphere.widthDirection[2];
//   protected Real bodyPiston.sphere.n_z_aux[2](unit = \"1\") = bodyPiston.sphere.e_x[3] * bodyPiston.sphere.widthDirection[1] - bodyPiston.sphere.e_x[1] * bodyPiston.sphere.widthDirection[3];
//   protected Real bodyPiston.sphere.n_z_aux[3](unit = \"1\") = bodyPiston.sphere.e_x[1] * bodyPiston.sphere.widthDirection[2] - bodyPiston.sphere.e_x[2] * bodyPiston.sphere.widthDirection[1];
//   protected Real bodyPiston.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[1];
//   protected Real bodyPiston.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[2];
//   protected Real bodyPiston.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]},if noEvent(bodyPiston.sphere.n_z_aux[1] ^ 2.0 + (bodyPiston.sphere.n_z_aux[2] ^ 2.0 + bodyPiston.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyPiston.sphere.widthDirection[1],bodyPiston.sphere.widthDirection[2],bodyPiston.sphere.widthDirection[3]} else if noEvent(abs(bodyPiston.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyPiston.sphere.e_x[1],bodyPiston.sphere.e_x[2],bodyPiston.sphere.e_x[3]})[3];
//   protected output Real bodyPiston.sphere.Form;
//   output Real bodyPiston.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyPiston.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyPiston.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyPiston.sphere.Material;
//   protected output Real bodyPiston.sphere.Extra;
//   Real revolutePiston.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolutePiston.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolutePiston.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolutePiston.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolutePiston.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolutePiston.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolutePiston.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolutePiston.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolutePiston.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolutePiston.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolutePiston.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolutePiston.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolutePiston.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolutePiston.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolutePiston.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolutePiston.animate = true \"enable Animation\";
//   parameter Boolean revolutePiston.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolutePiston.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolutePiston.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolutePiston.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolutePiston.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolutePiston.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolutePiston.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolutePiston.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolutePiston.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolutePiston.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolutePiston.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolutePiston.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolutePiston.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolutePiston.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolutePiston.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolutePiston.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolutePiston.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolutePiston.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolutePiston.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolutePiston.cylinder.lengthDirection[1],revolutePiston.cylinder.lengthDirection[2],revolutePiston.cylinder.lengthDirection[3]});
//   protected Real revolutePiston.cylinder.e_x[1](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolutePiston.cylinder.lengthDirection[1] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.e_x[2](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolutePiston.cylinder.lengthDirection[2] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.e_x[3](unit = \"1\") = if noEvent(revolutePiston.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolutePiston.cylinder.lengthDirection[3] / revolutePiston.cylinder.abs_n_x;
//   protected Real revolutePiston.cylinder.n_z_aux[1](unit = \"1\") = revolutePiston.cylinder.e_x[2] * revolutePiston.cylinder.widthDirection[3] - revolutePiston.cylinder.e_x[3] * revolutePiston.cylinder.widthDirection[2];
//   protected Real revolutePiston.cylinder.n_z_aux[2](unit = \"1\") = revolutePiston.cylinder.e_x[3] * revolutePiston.cylinder.widthDirection[1] - revolutePiston.cylinder.e_x[1] * revolutePiston.cylinder.widthDirection[3];
//   protected Real revolutePiston.cylinder.n_z_aux[3](unit = \"1\") = revolutePiston.cylinder.e_x[1] * revolutePiston.cylinder.widthDirection[2] - revolutePiston.cylinder.e_x[2] * revolutePiston.cylinder.widthDirection[1];
//   protected Real revolutePiston.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[1];
//   protected Real revolutePiston.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[2];
//   protected Real revolutePiston.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]},if noEvent(revolutePiston.cylinder.n_z_aux[1] ^ 2.0 + (revolutePiston.cylinder.n_z_aux[2] ^ 2.0 + revolutePiston.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolutePiston.cylinder.widthDirection[1],revolutePiston.cylinder.widthDirection[2],revolutePiston.cylinder.widthDirection[3]} else if noEvent(abs(revolutePiston.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolutePiston.cylinder.e_x[1],revolutePiston.cylinder.e_x[2],revolutePiston.cylinder.e_x[3]})[3];
//   protected output Real revolutePiston.cylinder.Form;
//   output Real revolutePiston.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolutePiston.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolutePiston.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolutePiston.cylinder.Material;
//   protected output Real revolutePiston.cylinder.Extra;
// initial equation
//   revoluteDrive.phi = revoluteDrive.phi_start;
//   revoluteDrive.w = revoluteDrive.w_start;
// equation
//   bodyDrive.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyDrive.sphere.shapeType);
//   bodyDrive.sphere.rxvisobj[1] = bodyDrive.sphere.R.T[1,1] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,1] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,1] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.rxvisobj[2] = bodyDrive.sphere.R.T[1,2] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,2] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,2] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.rxvisobj[3] = bodyDrive.sphere.R.T[1,3] * bodyDrive.sphere.e_x[1] + bodyDrive.sphere.R.T[2,3] * bodyDrive.sphere.e_x[2] + bodyDrive.sphere.R.T[3,3] * bodyDrive.sphere.e_x[3];
//   bodyDrive.sphere.ryvisobj[1] = bodyDrive.sphere.R.T[1,1] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,1] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,1] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.ryvisobj[2] = bodyDrive.sphere.R.T[1,2] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,2] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,2] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.ryvisobj[3] = bodyDrive.sphere.R.T[1,3] * bodyDrive.sphere.e_y[1] + bodyDrive.sphere.R.T[2,3] * bodyDrive.sphere.e_y[2] + bodyDrive.sphere.R.T[3,3] * bodyDrive.sphere.e_y[3];
//   bodyDrive.sphere.rvisobj = bodyDrive.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyDrive.sphere.R.T[1,1],bodyDrive.sphere.R.T[1,2],bodyDrive.sphere.R.T[1,3]},{bodyDrive.sphere.R.T[2,1],bodyDrive.sphere.R.T[2,2],bodyDrive.sphere.R.T[2,3]},{bodyDrive.sphere.R.T[3,1],bodyDrive.sphere.R.T[3,2],bodyDrive.sphere.R.T[3,3]}},{bodyDrive.sphere.r_shape[1],bodyDrive.sphere.r_shape[2],bodyDrive.sphere.r_shape[3]});
//   bodyDrive.sphere.size[1] = bodyDrive.sphere.length;
//   bodyDrive.sphere.size[2] = bodyDrive.sphere.width;
//   bodyDrive.sphere.size[3] = bodyDrive.sphere.height;
//   bodyDrive.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyDrive.sphere.color[1] / 255.0,bodyDrive.sphere.color[2] / 255.0,bodyDrive.sphere.color[3] / 255.0,bodyDrive.sphere.specularCoefficient);
//   bodyDrive.sphere.Extra = bodyDrive.sphere.extra;
//   bodyDrive.r[1] = bodyDrive.frame_a.x;
//   bodyDrive.r[2] = bodyDrive.frame_a.y;
//   bodyDrive.v[1] = der(bodyDrive.r[1]);
//   bodyDrive.v[2] = der(bodyDrive.r[2]);
//   bodyDrive.w = der(bodyDrive.frame_a.phi);
//   bodyDrive.a[1] = der(bodyDrive.v[1]);
//   bodyDrive.a[2] = der(bodyDrive.v[2]);
//   bodyDrive.z = der(bodyDrive.w);
//   bodyDrive.f[1] = bodyDrive.frame_a.fx;
//   bodyDrive.f[2] = bodyDrive.frame_a.fy;
//   bodyDrive.f[1] + bodyDrive.g[1] * bodyDrive.m = bodyDrive.a[1] * bodyDrive.m;
//   bodyDrive.f[2] + bodyDrive.g[2] * bodyDrive.m = bodyDrive.a[2] * bodyDrive.m;
//   bodyDrive.frame_a.t = bodyDrive.I * bodyDrive.z;
//   revoluteDrive.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revoluteDrive.cylinder.shapeType);
//   revoluteDrive.cylinder.rxvisobj[1] = revoluteDrive.cylinder.R.T[1,1] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,1] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,1] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.rxvisobj[2] = revoluteDrive.cylinder.R.T[1,2] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,2] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,2] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.rxvisobj[3] = revoluteDrive.cylinder.R.T[1,3] * revoluteDrive.cylinder.e_x[1] + revoluteDrive.cylinder.R.T[2,3] * revoluteDrive.cylinder.e_x[2] + revoluteDrive.cylinder.R.T[3,3] * revoluteDrive.cylinder.e_x[3];
//   revoluteDrive.cylinder.ryvisobj[1] = revoluteDrive.cylinder.R.T[1,1] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,1] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,1] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.ryvisobj[2] = revoluteDrive.cylinder.R.T[1,2] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,2] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,2] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.ryvisobj[3] = revoluteDrive.cylinder.R.T[1,3] * revoluteDrive.cylinder.e_y[1] + revoluteDrive.cylinder.R.T[2,3] * revoluteDrive.cylinder.e_y[2] + revoluteDrive.cylinder.R.T[3,3] * revoluteDrive.cylinder.e_y[3];
//   revoluteDrive.cylinder.rvisobj = revoluteDrive.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revoluteDrive.cylinder.R.T[1,1],revoluteDrive.cylinder.R.T[1,2],revoluteDrive.cylinder.R.T[1,3]},{revoluteDrive.cylinder.R.T[2,1],revoluteDrive.cylinder.R.T[2,2],revoluteDrive.cylinder.R.T[2,3]},{revoluteDrive.cylinder.R.T[3,1],revoluteDrive.cylinder.R.T[3,2],revoluteDrive.cylinder.R.T[3,3]}},{revoluteDrive.cylinder.r_shape[1],revoluteDrive.cylinder.r_shape[2],revoluteDrive.cylinder.r_shape[3]});
//   revoluteDrive.cylinder.size[1] = revoluteDrive.cylinder.length;
//   revoluteDrive.cylinder.size[2] = revoluteDrive.cylinder.width;
//   revoluteDrive.cylinder.size[3] = revoluteDrive.cylinder.height;
//   revoluteDrive.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revoluteDrive.cylinder.color[1] / 255.0,revoluteDrive.cylinder.color[2] / 255.0,revoluteDrive.cylinder.color[3] / 255.0,revoluteDrive.cylinder.specularCoefficient);
//   revoluteDrive.cylinder.Extra = revoluteDrive.cylinder.extra;
//   revoluteDrive.w = der(revoluteDrive.phi);
//   revoluteDrive.z = der(revoluteDrive.w);
//   revoluteDrive.t = 0.0;
//   revoluteDrive.frame_a.x = revoluteDrive.frame_b.x;
//   revoluteDrive.frame_a.y = revoluteDrive.frame_b.y;
//   revoluteDrive.frame_a.phi + revoluteDrive.phi = revoluteDrive.frame_b.phi;
//   revoluteDrive.frame_a.fx + revoluteDrive.frame_b.fx = 0.0;
//   revoluteDrive.frame_a.fy + revoluteDrive.frame_b.fy = 0.0;
//   revoluteDrive.frame_a.t + revoluteDrive.frame_b.t = 0.0;
//   revoluteDrive.frame_a.t = revoluteDrive.t;
//   fixedTranslationDisc.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslationDisc.cylinder.shapeType);
//   fixedTranslationDisc.cylinder.rxvisobj[1] = fixedTranslationDisc.cylinder.R.T[1,1] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,1] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,1] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.rxvisobj[2] = fixedTranslationDisc.cylinder.R.T[1,2] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,2] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,2] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.rxvisobj[3] = fixedTranslationDisc.cylinder.R.T[1,3] * fixedTranslationDisc.cylinder.e_x[1] + fixedTranslationDisc.cylinder.R.T[2,3] * fixedTranslationDisc.cylinder.e_x[2] + fixedTranslationDisc.cylinder.R.T[3,3] * fixedTranslationDisc.cylinder.e_x[3];
//   fixedTranslationDisc.cylinder.ryvisobj[1] = fixedTranslationDisc.cylinder.R.T[1,1] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,1] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,1] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.ryvisobj[2] = fixedTranslationDisc.cylinder.R.T[1,2] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,2] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,2] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.ryvisobj[3] = fixedTranslationDisc.cylinder.R.T[1,3] * fixedTranslationDisc.cylinder.e_y[1] + fixedTranslationDisc.cylinder.R.T[2,3] * fixedTranslationDisc.cylinder.e_y[2] + fixedTranslationDisc.cylinder.R.T[3,3] * fixedTranslationDisc.cylinder.e_y[3];
//   fixedTranslationDisc.cylinder.rvisobj = fixedTranslationDisc.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslationDisc.cylinder.R.T[1,1],fixedTranslationDisc.cylinder.R.T[1,2],fixedTranslationDisc.cylinder.R.T[1,3]},{fixedTranslationDisc.cylinder.R.T[2,1],fixedTranslationDisc.cylinder.R.T[2,2],fixedTranslationDisc.cylinder.R.T[2,3]},{fixedTranslationDisc.cylinder.R.T[3,1],fixedTranslationDisc.cylinder.R.T[3,2],fixedTranslationDisc.cylinder.R.T[3,3]}},{fixedTranslationDisc.cylinder.r_shape[1],fixedTranslationDisc.cylinder.r_shape[2],fixedTranslationDisc.cylinder.r_shape[3]});
//   fixedTranslationDisc.cylinder.size[1] = fixedTranslationDisc.cylinder.length;
//   fixedTranslationDisc.cylinder.size[2] = fixedTranslationDisc.cylinder.width;
//   fixedTranslationDisc.cylinder.size[3] = fixedTranslationDisc.cylinder.height;
//   fixedTranslationDisc.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslationDisc.cylinder.color[1] / 255.0,fixedTranslationDisc.cylinder.color[2] / 255.0,fixedTranslationDisc.cylinder.color[3] / 255.0,fixedTranslationDisc.cylinder.specularCoefficient);
//   fixedTranslationDisc.cylinder.Extra = fixedTranslationDisc.cylinder.extra;
//   fixedTranslationDisc.R[1,1] = cos(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[1,2] = sin(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[2,1] = -sin(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.R[2,2] = cos(fixedTranslationDisc.frame_a.phi);
//   fixedTranslationDisc.r0[1] = fixedTranslationDisc.R[1,1] * fixedTranslationDisc.r[1] + fixedTranslationDisc.R[1,2] * fixedTranslationDisc.r[2];
//   fixedTranslationDisc.r0[2] = fixedTranslationDisc.R[2,1] * fixedTranslationDisc.r[1] + fixedTranslationDisc.R[2,2] * fixedTranslationDisc.r[2];
//   fixedTranslationDisc.frame_a.x + fixedTranslationDisc.r0[1] = fixedTranslationDisc.frame_b.x;
//   fixedTranslationDisc.frame_a.y + fixedTranslationDisc.r0[2] = fixedTranslationDisc.frame_b.y;
//   fixedTranslationDisc.frame_a.phi = fixedTranslationDisc.frame_b.phi;
//   fixedTranslationDisc.frame_a.fx + fixedTranslationDisc.frame_b.fx = 0.0;
//   fixedTranslationDisc.frame_a.fy + fixedTranslationDisc.frame_b.fy = 0.0;
//   fixedTranslationDisc.frame_a.t + (fixedTranslationDisc.frame_b.t + ((-fixedTranslationDisc.r0[1]) * fixedTranslationDisc.frame_b.fy + fixedTranslationDisc.r0[2] * fixedTranslationDisc.frame_b.fx)) = 0.0;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.e0[1] = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2];
//   prismatic.e0[2] = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2];
//   prismatic.r0[1] = prismatic.e0[1] * prismatic.s;
//   prismatic.r0[2] = prismatic.e0[2] * prismatic.s;
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * prismatic.e0[1] + prismatic.frame_a.fy * prismatic.e0[2] = 0.0;
//   fixed1.frame_a.x = fixed1.r[1];
//   fixed1.frame_a.y = fixed1.r[2];
//   fixed1.frame_a.phi = fixed1.phi;
//   revoluteDisc.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revoluteDisc.cylinder.shapeType);
//   revoluteDisc.cylinder.rxvisobj[1] = revoluteDisc.cylinder.R.T[1,1] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,1] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,1] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.rxvisobj[2] = revoluteDisc.cylinder.R.T[1,2] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,2] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,2] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.rxvisobj[3] = revoluteDisc.cylinder.R.T[1,3] * revoluteDisc.cylinder.e_x[1] + revoluteDisc.cylinder.R.T[2,3] * revoluteDisc.cylinder.e_x[2] + revoluteDisc.cylinder.R.T[3,3] * revoluteDisc.cylinder.e_x[3];
//   revoluteDisc.cylinder.ryvisobj[1] = revoluteDisc.cylinder.R.T[1,1] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,1] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,1] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.ryvisobj[2] = revoluteDisc.cylinder.R.T[1,2] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,2] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,2] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.ryvisobj[3] = revoluteDisc.cylinder.R.T[1,3] * revoluteDisc.cylinder.e_y[1] + revoluteDisc.cylinder.R.T[2,3] * revoluteDisc.cylinder.e_y[2] + revoluteDisc.cylinder.R.T[3,3] * revoluteDisc.cylinder.e_y[3];
//   revoluteDisc.cylinder.rvisobj = revoluteDisc.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revoluteDisc.cylinder.R.T[1,1],revoluteDisc.cylinder.R.T[1,2],revoluteDisc.cylinder.R.T[1,3]},{revoluteDisc.cylinder.R.T[2,1],revoluteDisc.cylinder.R.T[2,2],revoluteDisc.cylinder.R.T[2,3]},{revoluteDisc.cylinder.R.T[3,1],revoluteDisc.cylinder.R.T[3,2],revoluteDisc.cylinder.R.T[3,3]}},{revoluteDisc.cylinder.r_shape[1],revoluteDisc.cylinder.r_shape[2],revoluteDisc.cylinder.r_shape[3]});
//   revoluteDisc.cylinder.size[1] = revoluteDisc.cylinder.length;
//   revoluteDisc.cylinder.size[2] = revoluteDisc.cylinder.width;
//   revoluteDisc.cylinder.size[3] = revoluteDisc.cylinder.height;
//   revoluteDisc.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revoluteDisc.cylinder.color[1] / 255.0,revoluteDisc.cylinder.color[2] / 255.0,revoluteDisc.cylinder.color[3] / 255.0,revoluteDisc.cylinder.specularCoefficient);
//   revoluteDisc.cylinder.Extra = revoluteDisc.cylinder.extra;
//   revoluteDisc.w = der(revoluteDisc.phi);
//   revoluteDisc.z = der(revoluteDisc.w);
//   revoluteDisc.t = 0.0;
//   revoluteDisc.frame_a.x = revoluteDisc.frame_b.x;
//   revoluteDisc.frame_a.y = revoluteDisc.frame_b.y;
//   revoluteDisc.frame_a.phi + revoluteDisc.phi = revoluteDisc.frame_b.phi;
//   revoluteDisc.frame_a.fx + revoluteDisc.frame_b.fx = 0.0;
//   revoluteDisc.frame_a.fy + revoluteDisc.frame_b.fy = 0.0;
//   revoluteDisc.frame_a.t + revoluteDisc.frame_b.t = 0.0;
//   revoluteDisc.frame_a.t = revoluteDisc.t;
//   pistonRod.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pistonRod.cylinder.shapeType);
//   pistonRod.cylinder.rxvisobj[1] = pistonRod.cylinder.R.T[1,1] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,1] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,1] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.rxvisobj[2] = pistonRod.cylinder.R.T[1,2] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,2] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,2] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.rxvisobj[3] = pistonRod.cylinder.R.T[1,3] * pistonRod.cylinder.e_x[1] + pistonRod.cylinder.R.T[2,3] * pistonRod.cylinder.e_x[2] + pistonRod.cylinder.R.T[3,3] * pistonRod.cylinder.e_x[3];
//   pistonRod.cylinder.ryvisobj[1] = pistonRod.cylinder.R.T[1,1] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,1] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,1] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.ryvisobj[2] = pistonRod.cylinder.R.T[1,2] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,2] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,2] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.ryvisobj[3] = pistonRod.cylinder.R.T[1,3] * pistonRod.cylinder.e_y[1] + pistonRod.cylinder.R.T[2,3] * pistonRod.cylinder.e_y[2] + pistonRod.cylinder.R.T[3,3] * pistonRod.cylinder.e_y[3];
//   pistonRod.cylinder.rvisobj = pistonRod.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pistonRod.cylinder.R.T[1,1],pistonRod.cylinder.R.T[1,2],pistonRod.cylinder.R.T[1,3]},{pistonRod.cylinder.R.T[2,1],pistonRod.cylinder.R.T[2,2],pistonRod.cylinder.R.T[2,3]},{pistonRod.cylinder.R.T[3,1],pistonRod.cylinder.R.T[3,2],pistonRod.cylinder.R.T[3,3]}},{pistonRod.cylinder.r_shape[1],pistonRod.cylinder.r_shape[2],pistonRod.cylinder.r_shape[3]});
//   pistonRod.cylinder.size[1] = pistonRod.cylinder.length;
//   pistonRod.cylinder.size[2] = pistonRod.cylinder.width;
//   pistonRod.cylinder.size[3] = pistonRod.cylinder.height;
//   pistonRod.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pistonRod.cylinder.color[1] / 255.0,pistonRod.cylinder.color[2] / 255.0,pistonRod.cylinder.color[3] / 255.0,pistonRod.cylinder.specularCoefficient);
//   pistonRod.cylinder.Extra = pistonRod.cylinder.extra;
//   pistonRod.R[1,1] = cos(pistonRod.frame_a.phi);
//   pistonRod.R[1,2] = sin(pistonRod.frame_a.phi);
//   pistonRod.R[2,1] = -sin(pistonRod.frame_a.phi);
//   pistonRod.R[2,2] = cos(pistonRod.frame_a.phi);
//   pistonRod.r0[1] = pistonRod.R[1,1] * pistonRod.r[1] + pistonRod.R[1,2] * pistonRod.r[2];
//   pistonRod.r0[2] = pistonRod.R[2,1] * pistonRod.r[1] + pistonRod.R[2,2] * pistonRod.r[2];
//   pistonRod.frame_a.x + pistonRod.r0[1] = pistonRod.frame_b.x;
//   pistonRod.frame_a.y + pistonRod.r0[2] = pistonRod.frame_b.y;
//   pistonRod.frame_a.phi = pistonRod.frame_b.phi;
//   pistonRod.frame_a.fx + pistonRod.frame_b.fx = 0.0;
//   pistonRod.frame_a.fy + pistonRod.frame_b.fy = 0.0;
//   pistonRod.frame_a.t + (pistonRod.frame_b.t + ((-pistonRod.r0[1]) * pistonRod.frame_b.fy + pistonRod.r0[2] * pistonRod.frame_b.fx)) = 0.0;
//   bodyPiston.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyPiston.sphere.shapeType);
//   bodyPiston.sphere.rxvisobj[1] = bodyPiston.sphere.R.T[1,1] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,1] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,1] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.rxvisobj[2] = bodyPiston.sphere.R.T[1,2] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,2] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,2] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.rxvisobj[3] = bodyPiston.sphere.R.T[1,3] * bodyPiston.sphere.e_x[1] + bodyPiston.sphere.R.T[2,3] * bodyPiston.sphere.e_x[2] + bodyPiston.sphere.R.T[3,3] * bodyPiston.sphere.e_x[3];
//   bodyPiston.sphere.ryvisobj[1] = bodyPiston.sphere.R.T[1,1] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,1] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,1] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.ryvisobj[2] = bodyPiston.sphere.R.T[1,2] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,2] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,2] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.ryvisobj[3] = bodyPiston.sphere.R.T[1,3] * bodyPiston.sphere.e_y[1] + bodyPiston.sphere.R.T[2,3] * bodyPiston.sphere.e_y[2] + bodyPiston.sphere.R.T[3,3] * bodyPiston.sphere.e_y[3];
//   bodyPiston.sphere.rvisobj = bodyPiston.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyPiston.sphere.R.T[1,1],bodyPiston.sphere.R.T[1,2],bodyPiston.sphere.R.T[1,3]},{bodyPiston.sphere.R.T[2,1],bodyPiston.sphere.R.T[2,2],bodyPiston.sphere.R.T[2,3]},{bodyPiston.sphere.R.T[3,1],bodyPiston.sphere.R.T[3,2],bodyPiston.sphere.R.T[3,3]}},{bodyPiston.sphere.r_shape[1],bodyPiston.sphere.r_shape[2],bodyPiston.sphere.r_shape[3]});
//   bodyPiston.sphere.size[1] = bodyPiston.sphere.length;
//   bodyPiston.sphere.size[2] = bodyPiston.sphere.width;
//   bodyPiston.sphere.size[3] = bodyPiston.sphere.height;
//   bodyPiston.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyPiston.sphere.color[1] / 255.0,bodyPiston.sphere.color[2] / 255.0,bodyPiston.sphere.color[3] / 255.0,bodyPiston.sphere.specularCoefficient);
//   bodyPiston.sphere.Extra = bodyPiston.sphere.extra;
//   bodyPiston.r[1] = bodyPiston.frame_a.x;
//   bodyPiston.r[2] = bodyPiston.frame_a.y;
//   bodyPiston.v[1] = der(bodyPiston.r[1]);
//   bodyPiston.v[2] = der(bodyPiston.r[2]);
//   bodyPiston.w = der(bodyPiston.frame_a.phi);
//   bodyPiston.a[1] = der(bodyPiston.v[1]);
//   bodyPiston.a[2] = der(bodyPiston.v[2]);
//   bodyPiston.z = der(bodyPiston.w);
//   bodyPiston.f[1] = bodyPiston.frame_a.fx;
//   bodyPiston.f[2] = bodyPiston.frame_a.fy;
//   bodyPiston.f[1] + bodyPiston.g[1] * bodyPiston.m = bodyPiston.a[1] * bodyPiston.m;
//   bodyPiston.f[2] + bodyPiston.g[2] * bodyPiston.m = bodyPiston.a[2] * bodyPiston.m;
//   bodyPiston.frame_a.t = bodyPiston.I * bodyPiston.z;
//   revolutePiston.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolutePiston.cylinder.shapeType);
//   revolutePiston.cylinder.rxvisobj[1] = revolutePiston.cylinder.R.T[1,1] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,1] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,1] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.rxvisobj[2] = revolutePiston.cylinder.R.T[1,2] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,2] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,2] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.rxvisobj[3] = revolutePiston.cylinder.R.T[1,3] * revolutePiston.cylinder.e_x[1] + revolutePiston.cylinder.R.T[2,3] * revolutePiston.cylinder.e_x[2] + revolutePiston.cylinder.R.T[3,3] * revolutePiston.cylinder.e_x[3];
//   revolutePiston.cylinder.ryvisobj[1] = revolutePiston.cylinder.R.T[1,1] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,1] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,1] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.ryvisobj[2] = revolutePiston.cylinder.R.T[1,2] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,2] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,2] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.ryvisobj[3] = revolutePiston.cylinder.R.T[1,3] * revolutePiston.cylinder.e_y[1] + revolutePiston.cylinder.R.T[2,3] * revolutePiston.cylinder.e_y[2] + revolutePiston.cylinder.R.T[3,3] * revolutePiston.cylinder.e_y[3];
//   revolutePiston.cylinder.rvisobj = revolutePiston.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolutePiston.cylinder.R.T[1,1],revolutePiston.cylinder.R.T[1,2],revolutePiston.cylinder.R.T[1,3]},{revolutePiston.cylinder.R.T[2,1],revolutePiston.cylinder.R.T[2,2],revolutePiston.cylinder.R.T[2,3]},{revolutePiston.cylinder.R.T[3,1],revolutePiston.cylinder.R.T[3,2],revolutePiston.cylinder.R.T[3,3]}},{revolutePiston.cylinder.r_shape[1],revolutePiston.cylinder.r_shape[2],revolutePiston.cylinder.r_shape[3]});
//   revolutePiston.cylinder.size[1] = revolutePiston.cylinder.length;
//   revolutePiston.cylinder.size[2] = revolutePiston.cylinder.width;
//   revolutePiston.cylinder.size[3] = revolutePiston.cylinder.height;
//   revolutePiston.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolutePiston.cylinder.color[1] / 255.0,revolutePiston.cylinder.color[2] / 255.0,revolutePiston.cylinder.color[3] / 255.0,revolutePiston.cylinder.specularCoefficient);
//   revolutePiston.cylinder.Extra = revolutePiston.cylinder.extra;
//   revolutePiston.w = der(revolutePiston.phi);
//   revolutePiston.z = der(revolutePiston.w);
//   revolutePiston.t = 0.0;
//   revolutePiston.frame_a.x = revolutePiston.frame_b.x;
//   revolutePiston.frame_a.y = revolutePiston.frame_b.y;
//   revolutePiston.frame_a.phi + revolutePiston.phi = revolutePiston.frame_b.phi;
//   revolutePiston.frame_a.fx + revolutePiston.frame_b.fx = 0.0;
//   revolutePiston.frame_a.fy + revolutePiston.frame_b.fy = 0.0;
//   revolutePiston.frame_a.t + revolutePiston.frame_b.t = 0.0;
//   revolutePiston.frame_a.t = revolutePiston.t;
//   bodyDrive.frame_a.t + revoluteDrive.frame_b.t + fixedTranslationDisc.frame_a.t = 0.0;
//   bodyDrive.frame_a.fy + revoluteDrive.frame_b.fy + fixedTranslationDisc.frame_a.fy = 0.0;
//   bodyDrive.frame_a.fx + revoluteDrive.frame_b.fx + fixedTranslationDisc.frame_a.fx = 0.0;
//   revoluteDrive.frame_a.t + fixed.frame_a.t = 0.0;
//   revoluteDrive.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revoluteDrive.frame_a.fx + fixed.frame_a.fx = 0.0;
//   fixedTranslationDisc.frame_b.t + revoluteDisc.frame_a.t = 0.0;
//   fixedTranslationDisc.frame_b.fy + revoluteDisc.frame_a.fy = 0.0;
//   fixedTranslationDisc.frame_b.fx + revoluteDisc.frame_a.fx = 0.0;
//   prismatic.frame_a.t + bodyPiston.frame_a.t + revolutePiston.frame_a.t = 0.0;
//   prismatic.frame_a.fy + bodyPiston.frame_a.fy + revolutePiston.frame_a.fy = 0.0;
//   prismatic.frame_a.fx + bodyPiston.frame_a.fx + revolutePiston.frame_a.fx = 0.0;
//   prismatic.frame_b.t + fixed1.frame_a.t = 0.0;
//   prismatic.frame_b.fy + fixed1.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + fixed1.frame_a.fx = 0.0;
//   revoluteDisc.frame_b.t + pistonRod.frame_a.t = 0.0;
//   revoluteDisc.frame_b.fy + pistonRod.frame_a.fy = 0.0;
//   revoluteDisc.frame_b.fx + pistonRod.frame_a.fx = 0.0;
//   pistonRod.frame_b.t + revolutePiston.frame_b.t = 0.0;
//   pistonRod.frame_b.fy + revolutePiston.frame_b.fy = 0.0;
//   pistonRod.frame_b.fx + revolutePiston.frame_b.fx = 0.0;
//   fixed.frame_a.x = revoluteDrive.frame_a.x;
//   fixed.frame_a.y = revoluteDrive.frame_a.y;
//   fixed.frame_a.phi = revoluteDrive.frame_a.phi;
//   bodyDrive.frame_a.x = fixedTranslationDisc.frame_a.x;
//   bodyDrive.frame_a.x = revoluteDrive.frame_b.x;
//   bodyDrive.frame_a.y = fixedTranslationDisc.frame_a.y;
//   bodyDrive.frame_a.y = revoluteDrive.frame_b.y;
//   bodyDrive.frame_a.phi = fixedTranslationDisc.frame_a.phi;
//   bodyDrive.frame_a.phi = revoluteDrive.frame_b.phi;
//   fixed1.frame_a.x = prismatic.frame_b.x;
//   fixed1.frame_a.y = prismatic.frame_b.y;
//   fixed1.frame_a.phi = prismatic.frame_b.phi;
//   fixedTranslationDisc.frame_b.x = revoluteDisc.frame_a.x;
//   fixedTranslationDisc.frame_b.y = revoluteDisc.frame_a.y;
//   fixedTranslationDisc.frame_b.phi = revoluteDisc.frame_a.phi;
//   pistonRod.frame_a.x = revoluteDisc.frame_b.x;
//   pistonRod.frame_a.y = revoluteDisc.frame_b.y;
//   pistonRod.frame_a.phi = revoluteDisc.frame_b.phi;
//   pistonRod.frame_b.x = revolutePiston.frame_b.x;
//   pistonRod.frame_b.y = revolutePiston.frame_b.y;
//   pistonRod.frame_b.phi = revolutePiston.frame_b.phi;
//   bodyPiston.frame_a.x = prismatic.frame_a.x;
//   bodyPiston.frame_a.x = revolutePiston.frame_a.x;
//   bodyPiston.frame_a.y = prismatic.frame_a.y;
//   bodyPiston.frame_a.y = revolutePiston.frame_a.y;
//   bodyPiston.frame_a.phi = prismatic.frame_a.phi;
//   bodyPiston.frame_a.phi = revolutePiston.frame_a.phi;
// end PlanarMechanicsForTesting.Examples.PistonEngine_DynamicStateSelection;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.KinematicLoop
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.always) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.always) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real revolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute1.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute1.animate = true \"enable Animation\";
//   parameter Boolean revolute1.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1],revolute1.cylinder.lengthDirection[2],revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = \"1\") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = \"1\") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = \"1\") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   Real revolute2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute2.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute2.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute2.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute2.animate = true \"enable Animation\";
//   parameter Boolean revolute2.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute2.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute2.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute2.cylinder.lengthDirection[1],revolute2.cylinder.lengthDirection[2],revolute2.cylinder.lengthDirection[3]});
//   protected Real revolute2.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute2.cylinder.lengthDirection[1] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute2.cylinder.lengthDirection[2] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute2.cylinder.lengthDirection[3] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.n_z_aux[1](unit = \"1\") = revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[3] - revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[2];
//   protected Real revolute2.cylinder.n_z_aux[2](unit = \"1\") = revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[1] - revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[3];
//   protected Real revolute2.cylinder.n_z_aux[3](unit = \"1\") = revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[2] - revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[1];
//   protected Real revolute2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[1];
//   protected Real revolute2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[2];
//   protected Real revolute2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[3];
//   protected output Real revolute2.cylinder.Form;
//   output Real revolute2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.Material;
//   protected output Real revolute2.cylinder.Extra;
//   Real revolute3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute3.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute3.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -0.69813170079773;
//   parameter Real revolute3.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute3.animate = true \"enable Animation\";
//   parameter Boolean revolute3.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute3.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute3.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute3.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute3.cylinder.lengthDirection[1],revolute3.cylinder.lengthDirection[2],revolute3.cylinder.lengthDirection[3]});
//   protected Real revolute3.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute3.cylinder.lengthDirection[1] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute3.cylinder.lengthDirection[2] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute3.cylinder.lengthDirection[3] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.n_z_aux[1](unit = \"1\") = revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[3] - revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[2];
//   protected Real revolute3.cylinder.n_z_aux[2](unit = \"1\") = revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[1] - revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[3];
//   protected Real revolute3.cylinder.n_z_aux[3](unit = \"1\") = revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[2] - revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[1];
//   protected Real revolute3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[1];
//   protected Real revolute3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[2];
//   protected Real revolute3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[3];
//   protected output Real revolute3.cylinder.Form;
//   output Real revolute3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.Material;
//   protected output Real revolute3.cylinder.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation2.r[1] ^ 2.0 + fixedTranslation2.r[2] ^ 2.0);
//   parameter String fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation2.r0[1] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation2.r0[2] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation2.l \"Length of visual object\";
//   input Real fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation2.cylinder.lengthDirection[1],fixedTranslation2.cylinder.lengthDirection[2],fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation2.cylinder.lengthDirection[1] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation2.cylinder.lengthDirection[2] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation2.cylinder.lengthDirection[3] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[3] - fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[2];
//   protected Real fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[1] - fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[3];
//   protected Real fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[2] - fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[1];
//   protected Real fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation2.cylinder.Form;
//   output Real fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.Material;
//   protected output Real fixedTranslation2.cylinder.Extra;
//   Real fixedTranslation3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation3.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation3.r[2](quantity = \"Length\", unit = \"m\") = -0.6 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation3.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation3.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation3.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation3.r[1] ^ 2.0 + fixedTranslation3.r[2] ^ 2.0);
//   parameter String fixedTranslation3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation3.r0[1] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation3.r0[2] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation3.l \"Length of visual object\";
//   input Real fixedTranslation3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation3.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation3.cylinder.lengthDirection[1],fixedTranslation3.cylinder.lengthDirection[2],fixedTranslation3.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation3.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation3.cylinder.lengthDirection[1] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation3.cylinder.lengthDirection[2] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation3.cylinder.lengthDirection[3] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[3] - fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[2];
//   protected Real fixedTranslation3.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[1] - fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[3];
//   protected Real fixedTranslation3.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[2] - fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[1];
//   protected Real fixedTranslation3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation3.cylinder.Form;
//   output Real fixedTranslation3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.Material;
//   protected output Real fixedTranslation3.cylinder.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real actuatedPrismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.4;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   parameter Boolean actuatedPrismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   parameter enumeration(never, avoid, default, prefer, always) springDamper.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real springDamper.s_nominal(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0001 \"Nominal value of s_rel (used for scaling)\";
//   Real springDamper.f(quantity = \"Force\", unit = \"N\") \"Forces between flanges (= flange_b.f)\";
//   Real springDamper.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real springDamper.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real springDamper.flange_b.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real springDamper.flange_b.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   parameter Real springDamper.c(quantity = \"TranslationalSpringConstant\", unit = \"N/m\", min = 0.0, start = 1.0) = 20.0 \"spring constant\";
//   parameter Real springDamper.d(quantity = \"TranslationalDampingConstant\", unit = \"N.s/m\", min = 0.0, start = 1.0) = 5.0 \"damping constant\";
//   parameter Real springDamper.s_rel0(quantity = \"Length\", unit = \"m\") = 0.6 \"unstretched spring length\";
//   Real springDamper.v_rel(quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative velocity (= der(s_rel))\";
//   Real springDamper.s_rel(quantity = \"Length\", unit = \"m\", min = 0.0, start = 0.0, nominal = springDamper.s_nominal, StateSelect = StateSelect.prefer) \"Relative distance (= flange_b.s - flange_a.s)\";
//   parameter Real fixed1.s0(quantity = \"Length\", unit = \"m\") = 0.0 \"fixed offset position of housing\";
//   Real fixed1.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real fixed1.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
// initial equation
//   revolute3.phi = revolute3.phi_start;
//   revolute3.w = revolute3.w_start;
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
// equation
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1],revolute1.cylinder.R.T[1,2],revolute1.cylinder.R.T[1,3]},{revolute1.cylinder.R.T[2,1],revolute1.cylinder.R.T[2,2],revolute1.cylinder.R.T[2,3]},{revolute1.cylinder.R.T[3,1],revolute1.cylinder.R.T[3,2],revolute1.cylinder.R.T[3,3]}},{revolute1.cylinder.r_shape[1],revolute1.cylinder.r_shape[2],revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0,revolute1.cylinder.color[2] / 255.0,revolute1.cylinder.color[3] / 255.0,revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   revolute1.w = der(revolute1.phi);
//   revolute1.z = der(revolute1.w);
//   revolute1.t = 0.0;
//   revolute1.frame_a.x = revolute1.frame_b.x;
//   revolute1.frame_a.y = revolute1.frame_b.y;
//   revolute1.frame_a.phi + revolute1.phi = revolute1.frame_b.phi;
//   revolute1.frame_a.fx + revolute1.frame_b.fx = 0.0;
//   revolute1.frame_a.fy + revolute1.frame_b.fy = 0.0;
//   revolute1.frame_a.t + revolute1.frame_b.t = 0.0;
//   revolute1.frame_a.t = revolute1.t;
//   revolute2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute2.cylinder.shapeType);
//   revolute2.cylinder.rxvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.ryvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.rvisobj = revolute2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute2.cylinder.R.T[1,1],revolute2.cylinder.R.T[1,2],revolute2.cylinder.R.T[1,3]},{revolute2.cylinder.R.T[2,1],revolute2.cylinder.R.T[2,2],revolute2.cylinder.R.T[2,3]},{revolute2.cylinder.R.T[3,1],revolute2.cylinder.R.T[3,2],revolute2.cylinder.R.T[3,3]}},{revolute2.cylinder.r_shape[1],revolute2.cylinder.r_shape[2],revolute2.cylinder.r_shape[3]});
//   revolute2.cylinder.size[1] = revolute2.cylinder.length;
//   revolute2.cylinder.size[2] = revolute2.cylinder.width;
//   revolute2.cylinder.size[3] = revolute2.cylinder.height;
//   revolute2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute2.cylinder.color[1] / 255.0,revolute2.cylinder.color[2] / 255.0,revolute2.cylinder.color[3] / 255.0,revolute2.cylinder.specularCoefficient);
//   revolute2.cylinder.Extra = revolute2.cylinder.extra;
//   revolute2.w = der(revolute2.phi);
//   revolute2.z = der(revolute2.w);
//   revolute2.t = 0.0;
//   revolute2.frame_a.x = revolute2.frame_b.x;
//   revolute2.frame_a.y = revolute2.frame_b.y;
//   revolute2.frame_a.phi + revolute2.phi = revolute2.frame_b.phi;
//   revolute2.frame_a.fx + revolute2.frame_b.fx = 0.0;
//   revolute2.frame_a.fy + revolute2.frame_b.fy = 0.0;
//   revolute2.frame_a.t + revolute2.frame_b.t = 0.0;
//   revolute2.frame_a.t = revolute2.t;
//   revolute3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute3.cylinder.shapeType);
//   revolute3.cylinder.rxvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.ryvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.rvisobj = revolute3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute3.cylinder.R.T[1,1],revolute3.cylinder.R.T[1,2],revolute3.cylinder.R.T[1,3]},{revolute3.cylinder.R.T[2,1],revolute3.cylinder.R.T[2,2],revolute3.cylinder.R.T[2,3]},{revolute3.cylinder.R.T[3,1],revolute3.cylinder.R.T[3,2],revolute3.cylinder.R.T[3,3]}},{revolute3.cylinder.r_shape[1],revolute3.cylinder.r_shape[2],revolute3.cylinder.r_shape[3]});
//   revolute3.cylinder.size[1] = revolute3.cylinder.length;
//   revolute3.cylinder.size[2] = revolute3.cylinder.width;
//   revolute3.cylinder.size[3] = revolute3.cylinder.height;
//   revolute3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute3.cylinder.color[1] / 255.0,revolute3.cylinder.color[2] / 255.0,revolute3.cylinder.color[3] / 255.0,revolute3.cylinder.specularCoefficient);
//   revolute3.cylinder.Extra = revolute3.cylinder.extra;
//   revolute3.w = der(revolute3.phi);
//   revolute3.z = der(revolute3.w);
//   revolute3.t = 0.0;
//   revolute3.frame_a.x = revolute3.frame_b.x;
//   revolute3.frame_a.y = revolute3.frame_b.y;
//   revolute3.frame_a.phi + revolute3.phi = revolute3.frame_b.phi;
//   revolute3.frame_a.fx + revolute3.frame_b.fx = 0.0;
//   revolute3.frame_a.fy + revolute3.frame_b.fy = 0.0;
//   revolute3.frame_a.t + revolute3.frame_b.t = 0.0;
//   revolute3.frame_a.t = revolute3.t;
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.cylinder.shapeType);
//   fixedTranslation2.cylinder.rxvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.ryvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.rvisobj = fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.cylinder.R.T[1,1],fixedTranslation2.cylinder.R.T[1,2],fixedTranslation2.cylinder.R.T[1,3]},{fixedTranslation2.cylinder.R.T[2,1],fixedTranslation2.cylinder.R.T[2,2],fixedTranslation2.cylinder.R.T[2,3]},{fixedTranslation2.cylinder.R.T[3,1],fixedTranslation2.cylinder.R.T[3,2],fixedTranslation2.cylinder.R.T[3,3]}},{fixedTranslation2.cylinder.r_shape[1],fixedTranslation2.cylinder.r_shape[2],fixedTranslation2.cylinder.r_shape[3]});
//   fixedTranslation2.cylinder.size[1] = fixedTranslation2.cylinder.length;
//   fixedTranslation2.cylinder.size[2] = fixedTranslation2.cylinder.width;
//   fixedTranslation2.cylinder.size[3] = fixedTranslation2.cylinder.height;
//   fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.cylinder.color[1] / 255.0,fixedTranslation2.cylinder.color[2] / 255.0,fixedTranslation2.cylinder.color[3] / 255.0,fixedTranslation2.cylinder.specularCoefficient);
//   fixedTranslation2.cylinder.Extra = fixedTranslation2.cylinder.extra;
//   fixedTranslation2.R[1,1] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[1,2] = sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,1] = -sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,2] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.r0[1] = fixedTranslation2.R[1,1] * fixedTranslation2.r[1] + fixedTranslation2.R[1,2] * fixedTranslation2.r[2];
//   fixedTranslation2.r0[2] = fixedTranslation2.R[2,1] * fixedTranslation2.r[1] + fixedTranslation2.R[2,2] * fixedTranslation2.r[2];
//   fixedTranslation2.frame_a.x + fixedTranslation2.r0[1] = fixedTranslation2.frame_b.x;
//   fixedTranslation2.frame_a.y + fixedTranslation2.r0[2] = fixedTranslation2.frame_b.y;
//   fixedTranslation2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   fixedTranslation2.frame_a.fx + fixedTranslation2.frame_b.fx = 0.0;
//   fixedTranslation2.frame_a.fy + fixedTranslation2.frame_b.fy = 0.0;
//   fixedTranslation2.frame_a.t + (fixedTranslation2.frame_b.t + ((-fixedTranslation2.r0[1]) * fixedTranslation2.frame_b.fy + fixedTranslation2.r0[2] * fixedTranslation2.frame_b.fx)) = 0.0;
//   fixedTranslation3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.cylinder.shapeType);
//   fixedTranslation3.cylinder.rxvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.ryvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.rvisobj = fixedTranslation3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.cylinder.R.T[1,1],fixedTranslation3.cylinder.R.T[1,2],fixedTranslation3.cylinder.R.T[1,3]},{fixedTranslation3.cylinder.R.T[2,1],fixedTranslation3.cylinder.R.T[2,2],fixedTranslation3.cylinder.R.T[2,3]},{fixedTranslation3.cylinder.R.T[3,1],fixedTranslation3.cylinder.R.T[3,2],fixedTranslation3.cylinder.R.T[3,3]}},{fixedTranslation3.cylinder.r_shape[1],fixedTranslation3.cylinder.r_shape[2],fixedTranslation3.cylinder.r_shape[3]});
//   fixedTranslation3.cylinder.size[1] = fixedTranslation3.cylinder.length;
//   fixedTranslation3.cylinder.size[2] = fixedTranslation3.cylinder.width;
//   fixedTranslation3.cylinder.size[3] = fixedTranslation3.cylinder.height;
//   fixedTranslation3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.cylinder.color[1] / 255.0,fixedTranslation3.cylinder.color[2] / 255.0,fixedTranslation3.cylinder.color[3] / 255.0,fixedTranslation3.cylinder.specularCoefficient);
//   fixedTranslation3.cylinder.Extra = fixedTranslation3.cylinder.extra;
//   fixedTranslation3.R[1,1] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[1,2] = sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,1] = -sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,2] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.r0[1] = fixedTranslation3.R[1,1] * fixedTranslation3.r[1] + fixedTranslation3.R[1,2] * fixedTranslation3.r[2];
//   fixedTranslation3.r0[2] = fixedTranslation3.R[2,1] * fixedTranslation3.r[1] + fixedTranslation3.R[2,2] * fixedTranslation3.r[2];
//   fixedTranslation3.frame_a.x + fixedTranslation3.r0[1] = fixedTranslation3.frame_b.x;
//   fixedTranslation3.frame_a.y + fixedTranslation3.r0[2] = fixedTranslation3.frame_b.y;
//   fixedTranslation3.frame_a.phi = fixedTranslation3.frame_b.phi;
//   fixedTranslation3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation3.frame_a.t + (fixedTranslation3.frame_b.t + ((-fixedTranslation3.r0[1]) * fixedTranslation3.frame_b.fy + fixedTranslation3.r0[2] * fixedTranslation3.frame_b.fx)) = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.e0[1] = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.e0[2] = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.r0[1] = actuatedPrismatic.e0[1] * actuatedPrismatic.s;
//   actuatedPrismatic.r0[2] = actuatedPrismatic.e0[2] * actuatedPrismatic.s;
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * actuatedPrismatic.e0[1] + actuatedPrismatic.frame_a.fy * actuatedPrismatic.e0[2] = actuatedPrismatic.f;
//   springDamper.f = springDamper.c * (springDamper.s_rel - springDamper.s_rel0) + springDamper.d * springDamper.v_rel;
//   springDamper.s_rel = springDamper.flange_b.s - springDamper.flange_a.s;
//   springDamper.v_rel = der(springDamper.s_rel);
//   springDamper.flange_b.f = springDamper.f;
//   springDamper.flange_a.f = -springDamper.f;
//   fixed1.flange.s = fixed1.s0;
//   revolute.frame_a.t + fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation1.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation1.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation1.frame_a.fx = 0.0;
//   revolute1.frame_a.t + actuatedPrismatic.frame_b.t = 0.0;
//   revolute1.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   revolute1.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   revolute1.frame_b.t + fixedTranslation2.frame_a.t = 0.0;
//   revolute1.frame_b.fy + fixedTranslation2.frame_a.fy = 0.0;
//   revolute1.frame_b.fx + fixedTranslation2.frame_a.fx = 0.0;
//   revolute2.frame_a.t + revolute3.frame_a.t + fixedTranslation1.frame_b.t = 0.0;
//   revolute2.frame_a.fy + revolute3.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   revolute2.frame_a.fx + revolute3.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   revolute2.frame_b.t + fixedTranslation2.frame_b.t = 0.0;
//   revolute2.frame_b.fy + fixedTranslation2.frame_b.fy = 0.0;
//   revolute2.frame_b.fx + fixedTranslation2.frame_b.fx = 0.0;
//   revolute3.frame_b.t + fixedTranslation3.frame_a.t = 0.0;
//   revolute3.frame_b.fy + fixedTranslation3.frame_a.fy = 0.0;
//   revolute3.frame_b.fx + fixedTranslation3.frame_a.fx = 0.0;
//   fixedTranslation3.frame_b.t + body.frame_a.t = 0.0;
//   fixedTranslation3.frame_b.fy + body.frame_a.fy = 0.0;
//   fixedTranslation3.frame_b.fx + body.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + springDamper.flange_b.f = 0.0;
//   springDamper.flange_a.f + fixed1.flange.f = 0.0;
//   fixedTranslation1.frame_a.x = revolute.frame_b.x;
//   fixedTranslation1.frame_a.y = revolute.frame_b.y;
//   fixedTranslation1.frame_a.phi = revolute.frame_b.phi;
//   fixedTranslation2.frame_a.x = revolute1.frame_b.x;
//   fixedTranslation2.frame_a.y = revolute1.frame_b.y;
//   fixedTranslation2.frame_a.phi = revolute1.frame_b.phi;
//   fixedTranslation1.frame_b.x = revolute2.frame_a.x;
//   fixedTranslation1.frame_b.x = revolute3.frame_a.x;
//   fixedTranslation1.frame_b.y = revolute2.frame_a.y;
//   fixedTranslation1.frame_b.y = revolute3.frame_a.y;
//   fixedTranslation1.frame_b.phi = revolute2.frame_a.phi;
//   fixedTranslation1.frame_b.phi = revolute3.frame_a.phi;
//   fixedTranslation2.frame_b.x = revolute2.frame_b.x;
//   fixedTranslation2.frame_b.y = revolute2.frame_b.y;
//   fixedTranslation2.frame_b.phi = revolute2.frame_b.phi;
//   fixedTranslation3.frame_a.x = revolute3.frame_b.x;
//   fixedTranslation3.frame_a.y = revolute3.frame_b.y;
//   fixedTranslation3.frame_a.phi = revolute3.frame_b.phi;
//   actuatedPrismatic.frame_b.x = revolute1.frame_a.x;
//   actuatedPrismatic.frame_b.y = revolute1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = revolute1.frame_a.phi;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.x = revolute.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.y = revolute.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_a.phi = revolute.frame_a.phi;
//   actuatedPrismatic.flange_a.s = springDamper.flange_b.s;
//   fixed1.flange.s = springDamper.flange_a.s;
//   body.frame_a.x = fixedTranslation3.frame_b.x;
//   body.frame_a.y = fixedTranslation3.frame_b.y;
//   body.frame_a.phi = fixedTranslation3.frame_b.phi;
// end PlanarMechanicsForTesting.Examples.KinematicLoop;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.KinematicLoop_DynamicStateSelection
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real revolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute1.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute1.animate = true \"enable Animation\";
//   parameter Boolean revolute1.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1],revolute1.cylinder.lengthDirection[2],revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = \"1\") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = \"1\") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = \"1\") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   Real revolute2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute2.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute2.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute2.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute2.animate = true \"enable Animation\";
//   parameter Boolean revolute2.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute2.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute2.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute2.cylinder.lengthDirection[1],revolute2.cylinder.lengthDirection[2],revolute2.cylinder.lengthDirection[3]});
//   protected Real revolute2.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute2.cylinder.lengthDirection[1] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute2.cylinder.lengthDirection[2] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute2.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute2.cylinder.lengthDirection[3] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.n_z_aux[1](unit = \"1\") = revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[3] - revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[2];
//   protected Real revolute2.cylinder.n_z_aux[2](unit = \"1\") = revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[1] - revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[3];
//   protected Real revolute2.cylinder.n_z_aux[3](unit = \"1\") = revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[2] - revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[1];
//   protected Real revolute2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[1];
//   protected Real revolute2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[2];
//   protected Real revolute2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[3];
//   protected output Real revolute2.cylinder.Form;
//   output Real revolute2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute2.cylinder.Material;
//   protected output Real revolute2.cylinder.Extra;
//   Real revolute3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute3.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute3.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -0.69813170079773;
//   parameter Real revolute3.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute3.animate = true \"enable Animation\";
//   parameter Boolean revolute3.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute3.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute3.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute3.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute3.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute3.cylinder.lengthDirection[1],revolute3.cylinder.lengthDirection[2],revolute3.cylinder.lengthDirection[3]});
//   protected Real revolute3.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute3.cylinder.lengthDirection[1] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute3.cylinder.lengthDirection[2] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute3.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute3.cylinder.lengthDirection[3] / revolute3.cylinder.abs_n_x;
//   protected Real revolute3.cylinder.n_z_aux[1](unit = \"1\") = revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[3] - revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[2];
//   protected Real revolute3.cylinder.n_z_aux[2](unit = \"1\") = revolute3.cylinder.e_x[3] * revolute3.cylinder.widthDirection[1] - revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[3];
//   protected Real revolute3.cylinder.n_z_aux[3](unit = \"1\") = revolute3.cylinder.e_x[1] * revolute3.cylinder.widthDirection[2] - revolute3.cylinder.e_x[2] * revolute3.cylinder.widthDirection[1];
//   protected Real revolute3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[1];
//   protected Real revolute3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[2];
//   protected Real revolute3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]},if noEvent(revolute3.cylinder.n_z_aux[1] ^ 2.0 + (revolute3.cylinder.n_z_aux[2] ^ 2.0 + revolute3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute3.cylinder.widthDirection[1],revolute3.cylinder.widthDirection[2],revolute3.cylinder.widthDirection[3]} else if noEvent(abs(revolute3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute3.cylinder.e_x[1],revolute3.cylinder.e_x[2],revolute3.cylinder.e_x[3]})[3];
//   protected output Real revolute3.cylinder.Form;
//   output Real revolute3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute3.cylinder.Material;
//   protected output Real revolute3.cylinder.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = -0.5 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation2.r[1] ^ 2.0 + fixedTranslation2.r[2] ^ 2.0);
//   parameter String fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation2.r0[1] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation2.r0[2] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation2.l \"Length of visual object\";
//   input Real fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation2.cylinder.lengthDirection[1],fixedTranslation2.cylinder.lengthDirection[2],fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation2.cylinder.lengthDirection[1] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation2.cylinder.lengthDirection[2] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation2.cylinder.lengthDirection[3] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[3] - fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[2];
//   protected Real fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[1] - fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[3];
//   protected Real fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[2] - fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[1];
//   protected Real fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation2.cylinder.Form;
//   output Real fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.Material;
//   protected output Real fixedTranslation2.cylinder.Extra;
//   Real fixedTranslation3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation3.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation3.r[2](quantity = \"Length\", unit = \"m\") = -0.6 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation3.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation3.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation3.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation3.r[1] ^ 2.0 + fixedTranslation3.r[2] ^ 2.0);
//   parameter String fixedTranslation3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation3.r0[1] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation3.r0[2] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation3.l \"Length of visual object\";
//   input Real fixedTranslation3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation3.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation3.cylinder.lengthDirection[1],fixedTranslation3.cylinder.lengthDirection[2],fixedTranslation3.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation3.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation3.cylinder.lengthDirection[1] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation3.cylinder.lengthDirection[2] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation3.cylinder.lengthDirection[3] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[3] - fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[2];
//   protected Real fixedTranslation3.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[1] - fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[3];
//   protected Real fixedTranslation3.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[2] - fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[1];
//   protected Real fixedTranslation3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation3.cylinder.Form;
//   output Real fixedTranslation3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.Material;
//   protected output Real fixedTranslation3.cylinder.Extra;
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 1.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = -9.81 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   Real actuatedPrismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedPrismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedPrismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedPrismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedPrismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedPrismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedPrismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real actuatedPrismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real actuatedPrismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   Real actuatedPrismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real actuatedPrismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real actuatedPrismatic.R[1,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[1,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,1] \"Rotation Matrix\";
//   Real actuatedPrismatic.R[2,2] \"Rotation Matrix\";
//   Real actuatedPrismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real actuatedPrismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real actuatedPrismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean actuatedPrismatic.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedPrismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.4;
//   parameter Real actuatedPrismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean actuatedPrismatic.animate = true \"enable Animation\";
//   parameter Boolean actuatedPrismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedPrismatic.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real actuatedPrismatic.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   final parameter Real actuatedPrismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(actuatedPrismatic.r[1] ^ 2.0 + actuatedPrismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String actuatedPrismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedPrismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedPrismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedPrismatic.box.r[1](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[2](quantity = \"Length\", unit = \"m\") = actuatedPrismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedPrismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[1](unit = \"1\") = actuatedPrismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[2](unit = \"1\") = actuatedPrismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedPrismatic.box.length(quantity = \"Length\", unit = \"m\") = actuatedPrismatic.s \"Length of visual object\";
//   input Real actuatedPrismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedPrismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedPrismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedPrismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real actuatedPrismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedPrismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedPrismatic.box.lengthDirection[1],actuatedPrismatic.box.lengthDirection[2],actuatedPrismatic.box.lengthDirection[3]});
//   protected Real actuatedPrismatic.box.e_x[1](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 1.0 else actuatedPrismatic.box.lengthDirection[1] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[2](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[2] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.e_x[3](unit = \"1\") = if noEvent(actuatedPrismatic.box.abs_n_x < 0.0000000001) then 0.0 else actuatedPrismatic.box.lengthDirection[3] / actuatedPrismatic.box.abs_n_x;
//   protected Real actuatedPrismatic.box.n_z_aux[1](unit = \"1\") = actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[3] - actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[2];
//   protected Real actuatedPrismatic.box.n_z_aux[2](unit = \"1\") = actuatedPrismatic.box.e_x[3] * actuatedPrismatic.box.widthDirection[1] - actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[3];
//   protected Real actuatedPrismatic.box.n_z_aux[3](unit = \"1\") = actuatedPrismatic.box.e_x[1] * actuatedPrismatic.box.widthDirection[2] - actuatedPrismatic.box.e_x[2] * actuatedPrismatic.box.widthDirection[1];
//   protected Real actuatedPrismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[1];
//   protected Real actuatedPrismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[2];
//   protected Real actuatedPrismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]},if noEvent(actuatedPrismatic.box.n_z_aux[1] ^ 2.0 + (actuatedPrismatic.box.n_z_aux[2] ^ 2.0 + actuatedPrismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedPrismatic.box.widthDirection[1],actuatedPrismatic.box.widthDirection[2],actuatedPrismatic.box.widthDirection[3]} else if noEvent(abs(actuatedPrismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedPrismatic.box.e_x[1],actuatedPrismatic.box.e_x[2],actuatedPrismatic.box.e_x[3]})[3];
//   protected output Real actuatedPrismatic.box.Form;
//   output Real actuatedPrismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedPrismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedPrismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedPrismatic.box.Material;
//   protected output Real actuatedPrismatic.box.Extra;
//   final parameter Real actuatedPrismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[1] / actuatedPrismatic.l \"normalized r\";
//   final parameter Real actuatedPrismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = actuatedPrismatic.r[2] / actuatedPrismatic.l \"normalized r\";
//   parameter enumeration(never, avoid, default, prefer, always) springDamper.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real springDamper.s_nominal(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0001 \"Nominal value of s_rel (used for scaling)\";
//   Real springDamper.f(quantity = \"Force\", unit = \"N\") \"Forces between flanges (= flange_b.f)\";
//   Real springDamper.flange_a.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real springDamper.flange_a.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   Real springDamper.flange_b.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real springDamper.flange_b.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
//   parameter Real springDamper.c(quantity = \"TranslationalSpringConstant\", unit = \"N/m\", min = 0.0, start = 1.0) = 20.0 \"spring constant\";
//   parameter Real springDamper.d(quantity = \"TranslationalDampingConstant\", unit = \"N.s/m\", min = 0.0, start = 1.0) = 5.0 \"damping constant\";
//   parameter Real springDamper.s_rel0(quantity = \"Length\", unit = \"m\") = 0.6 \"unstretched spring length\";
//   Real springDamper.v_rel(quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative velocity (= der(s_rel))\";
//   Real springDamper.s_rel(quantity = \"Length\", unit = \"m\", min = 0.0, start = 0.0, nominal = springDamper.s_nominal, StateSelect = StateSelect.prefer) \"Relative distance (= flange_b.s - flange_a.s)\";
//   parameter Real fixed1.s0(quantity = \"Length\", unit = \"m\") = 0.0 \"fixed offset position of housing\";
//   Real fixed1.flange.s(quantity = \"Length\", unit = \"m\") \"absolute position of flange\";
//   Real fixed1.flange.f(quantity = \"Force\", unit = \"N\") \"cut force directed into flange\";
// initial equation
//   revolute3.phi = revolute3.phi_start;
//   revolute3.w = revolute3.w_start;
//   actuatedPrismatic.s = actuatedPrismatic.s_start;
//   actuatedPrismatic.v = actuatedPrismatic.v_start;
// equation
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3];
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3];
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1],revolute1.cylinder.R.T[1,2],revolute1.cylinder.R.T[1,3]},{revolute1.cylinder.R.T[2,1],revolute1.cylinder.R.T[2,2],revolute1.cylinder.R.T[2,3]},{revolute1.cylinder.R.T[3,1],revolute1.cylinder.R.T[3,2],revolute1.cylinder.R.T[3,3]}},{revolute1.cylinder.r_shape[1],revolute1.cylinder.r_shape[2],revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0,revolute1.cylinder.color[2] / 255.0,revolute1.cylinder.color[3] / 255.0,revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   revolute1.w = der(revolute1.phi);
//   revolute1.z = der(revolute1.w);
//   revolute1.t = 0.0;
//   revolute1.frame_a.x = revolute1.frame_b.x;
//   revolute1.frame_a.y = revolute1.frame_b.y;
//   revolute1.frame_a.phi + revolute1.phi = revolute1.frame_b.phi;
//   revolute1.frame_a.fx + revolute1.frame_b.fx = 0.0;
//   revolute1.frame_a.fy + revolute1.frame_b.fy = 0.0;
//   revolute1.frame_a.t + revolute1.frame_b.t = 0.0;
//   revolute1.frame_a.t = revolute1.t;
//   revolute2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute2.cylinder.shapeType);
//   revolute2.cylinder.rxvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.rxvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_x[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_x[3];
//   revolute2.cylinder.ryvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.ryvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_y[1] + revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_y[3];
//   revolute2.cylinder.rvisobj = revolute2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute2.cylinder.R.T[1,1],revolute2.cylinder.R.T[1,2],revolute2.cylinder.R.T[1,3]},{revolute2.cylinder.R.T[2,1],revolute2.cylinder.R.T[2,2],revolute2.cylinder.R.T[2,3]},{revolute2.cylinder.R.T[3,1],revolute2.cylinder.R.T[3,2],revolute2.cylinder.R.T[3,3]}},{revolute2.cylinder.r_shape[1],revolute2.cylinder.r_shape[2],revolute2.cylinder.r_shape[3]});
//   revolute2.cylinder.size[1] = revolute2.cylinder.length;
//   revolute2.cylinder.size[2] = revolute2.cylinder.width;
//   revolute2.cylinder.size[3] = revolute2.cylinder.height;
//   revolute2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute2.cylinder.color[1] / 255.0,revolute2.cylinder.color[2] / 255.0,revolute2.cylinder.color[3] / 255.0,revolute2.cylinder.specularCoefficient);
//   revolute2.cylinder.Extra = revolute2.cylinder.extra;
//   revolute2.w = der(revolute2.phi);
//   revolute2.z = der(revolute2.w);
//   revolute2.t = 0.0;
//   revolute2.frame_a.x = revolute2.frame_b.x;
//   revolute2.frame_a.y = revolute2.frame_b.y;
//   revolute2.frame_a.phi + revolute2.phi = revolute2.frame_b.phi;
//   revolute2.frame_a.fx + revolute2.frame_b.fx = 0.0;
//   revolute2.frame_a.fy + revolute2.frame_b.fy = 0.0;
//   revolute2.frame_a.t + revolute2.frame_b.t = 0.0;
//   revolute2.frame_a.t = revolute2.t;
//   revolute3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute3.cylinder.shapeType);
//   revolute3.cylinder.rxvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.rxvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_x[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_x[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_x[3];
//   revolute3.cylinder.ryvisobj[1] = revolute3.cylinder.R.T[1,1] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,1] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,1] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[2] = revolute3.cylinder.R.T[1,2] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,2] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,2] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.ryvisobj[3] = revolute3.cylinder.R.T[1,3] * revolute3.cylinder.e_y[1] + revolute3.cylinder.R.T[2,3] * revolute3.cylinder.e_y[2] + revolute3.cylinder.R.T[3,3] * revolute3.cylinder.e_y[3];
//   revolute3.cylinder.rvisobj = revolute3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute3.cylinder.R.T[1,1],revolute3.cylinder.R.T[1,2],revolute3.cylinder.R.T[1,3]},{revolute3.cylinder.R.T[2,1],revolute3.cylinder.R.T[2,2],revolute3.cylinder.R.T[2,3]},{revolute3.cylinder.R.T[3,1],revolute3.cylinder.R.T[3,2],revolute3.cylinder.R.T[3,3]}},{revolute3.cylinder.r_shape[1],revolute3.cylinder.r_shape[2],revolute3.cylinder.r_shape[3]});
//   revolute3.cylinder.size[1] = revolute3.cylinder.length;
//   revolute3.cylinder.size[2] = revolute3.cylinder.width;
//   revolute3.cylinder.size[3] = revolute3.cylinder.height;
//   revolute3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute3.cylinder.color[1] / 255.0,revolute3.cylinder.color[2] / 255.0,revolute3.cylinder.color[3] / 255.0,revolute3.cylinder.specularCoefficient);
//   revolute3.cylinder.Extra = revolute3.cylinder.extra;
//   revolute3.w = der(revolute3.phi);
//   revolute3.z = der(revolute3.w);
//   revolute3.t = 0.0;
//   revolute3.frame_a.x = revolute3.frame_b.x;
//   revolute3.frame_a.y = revolute3.frame_b.y;
//   revolute3.frame_a.phi + revolute3.phi = revolute3.frame_b.phi;
//   revolute3.frame_a.fx + revolute3.frame_b.fx = 0.0;
//   revolute3.frame_a.fy + revolute3.frame_b.fy = 0.0;
//   revolute3.frame_a.t + revolute3.frame_b.t = 0.0;
//   revolute3.frame_a.t = revolute3.t;
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.cylinder.shapeType);
//   fixedTranslation2.cylinder.rxvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.ryvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.rvisobj = fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.cylinder.R.T[1,1],fixedTranslation2.cylinder.R.T[1,2],fixedTranslation2.cylinder.R.T[1,3]},{fixedTranslation2.cylinder.R.T[2,1],fixedTranslation2.cylinder.R.T[2,2],fixedTranslation2.cylinder.R.T[2,3]},{fixedTranslation2.cylinder.R.T[3,1],fixedTranslation2.cylinder.R.T[3,2],fixedTranslation2.cylinder.R.T[3,3]}},{fixedTranslation2.cylinder.r_shape[1],fixedTranslation2.cylinder.r_shape[2],fixedTranslation2.cylinder.r_shape[3]});
//   fixedTranslation2.cylinder.size[1] = fixedTranslation2.cylinder.length;
//   fixedTranslation2.cylinder.size[2] = fixedTranslation2.cylinder.width;
//   fixedTranslation2.cylinder.size[3] = fixedTranslation2.cylinder.height;
//   fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.cylinder.color[1] / 255.0,fixedTranslation2.cylinder.color[2] / 255.0,fixedTranslation2.cylinder.color[3] / 255.0,fixedTranslation2.cylinder.specularCoefficient);
//   fixedTranslation2.cylinder.Extra = fixedTranslation2.cylinder.extra;
//   fixedTranslation2.R[1,1] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[1,2] = sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,1] = -sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,2] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.r0[1] = fixedTranslation2.R[1,1] * fixedTranslation2.r[1] + fixedTranslation2.R[1,2] * fixedTranslation2.r[2];
//   fixedTranslation2.r0[2] = fixedTranslation2.R[2,1] * fixedTranslation2.r[1] + fixedTranslation2.R[2,2] * fixedTranslation2.r[2];
//   fixedTranslation2.frame_a.x + fixedTranslation2.r0[1] = fixedTranslation2.frame_b.x;
//   fixedTranslation2.frame_a.y + fixedTranslation2.r0[2] = fixedTranslation2.frame_b.y;
//   fixedTranslation2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   fixedTranslation2.frame_a.fx + fixedTranslation2.frame_b.fx = 0.0;
//   fixedTranslation2.frame_a.fy + fixedTranslation2.frame_b.fy = 0.0;
//   fixedTranslation2.frame_a.t + (fixedTranslation2.frame_b.t + ((-fixedTranslation2.r0[1]) * fixedTranslation2.frame_b.fy + fixedTranslation2.r0[2] * fixedTranslation2.frame_b.fx)) = 0.0;
//   fixedTranslation3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.cylinder.shapeType);
//   fixedTranslation3.cylinder.rxvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.ryvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.rvisobj = fixedTranslation3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.cylinder.R.T[1,1],fixedTranslation3.cylinder.R.T[1,2],fixedTranslation3.cylinder.R.T[1,3]},{fixedTranslation3.cylinder.R.T[2,1],fixedTranslation3.cylinder.R.T[2,2],fixedTranslation3.cylinder.R.T[2,3]},{fixedTranslation3.cylinder.R.T[3,1],fixedTranslation3.cylinder.R.T[3,2],fixedTranslation3.cylinder.R.T[3,3]}},{fixedTranslation3.cylinder.r_shape[1],fixedTranslation3.cylinder.r_shape[2],fixedTranslation3.cylinder.r_shape[3]});
//   fixedTranslation3.cylinder.size[1] = fixedTranslation3.cylinder.length;
//   fixedTranslation3.cylinder.size[2] = fixedTranslation3.cylinder.width;
//   fixedTranslation3.cylinder.size[3] = fixedTranslation3.cylinder.height;
//   fixedTranslation3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.cylinder.color[1] / 255.0,fixedTranslation3.cylinder.color[2] / 255.0,fixedTranslation3.cylinder.color[3] / 255.0,fixedTranslation3.cylinder.specularCoefficient);
//   fixedTranslation3.cylinder.Extra = fixedTranslation3.cylinder.extra;
//   fixedTranslation3.R[1,1] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[1,2] = sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,1] = -sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,2] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.r0[1] = fixedTranslation3.R[1,1] * fixedTranslation3.r[1] + fixedTranslation3.R[1,2] * fixedTranslation3.r[2];
//   fixedTranslation3.r0[2] = fixedTranslation3.R[2,1] * fixedTranslation3.r[1] + fixedTranslation3.R[2,2] * fixedTranslation3.r[2];
//   fixedTranslation3.frame_a.x + fixedTranslation3.r0[1] = fixedTranslation3.frame_b.x;
//   fixedTranslation3.frame_a.y + fixedTranslation3.r0[2] = fixedTranslation3.frame_b.y;
//   fixedTranslation3.frame_a.phi = fixedTranslation3.frame_b.phi;
//   fixedTranslation3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation3.frame_a.t + (fixedTranslation3.frame_b.t + ((-fixedTranslation3.r0[1]) * fixedTranslation3.frame_b.fy + fixedTranslation3.r0[2] * fixedTranslation3.frame_b.fx)) = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   actuatedPrismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedPrismatic.box.shapeType);
//   actuatedPrismatic.box.rxvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.rxvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_x[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_x[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_x[3];
//   actuatedPrismatic.box.ryvisobj[1] = actuatedPrismatic.box.R.T[1,1] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,1] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,1] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[2] = actuatedPrismatic.box.R.T[1,2] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,2] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,2] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.ryvisobj[3] = actuatedPrismatic.box.R.T[1,3] * actuatedPrismatic.box.e_y[1] + actuatedPrismatic.box.R.T[2,3] * actuatedPrismatic.box.e_y[2] + actuatedPrismatic.box.R.T[3,3] * actuatedPrismatic.box.e_y[3];
//   actuatedPrismatic.box.rvisobj = actuatedPrismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedPrismatic.box.R.T[1,1],actuatedPrismatic.box.R.T[1,2],actuatedPrismatic.box.R.T[1,3]},{actuatedPrismatic.box.R.T[2,1],actuatedPrismatic.box.R.T[2,2],actuatedPrismatic.box.R.T[2,3]},{actuatedPrismatic.box.R.T[3,1],actuatedPrismatic.box.R.T[3,2],actuatedPrismatic.box.R.T[3,3]}},{actuatedPrismatic.box.r_shape[1],actuatedPrismatic.box.r_shape[2],actuatedPrismatic.box.r_shape[3]});
//   actuatedPrismatic.box.size[1] = actuatedPrismatic.box.length;
//   actuatedPrismatic.box.size[2] = actuatedPrismatic.box.width;
//   actuatedPrismatic.box.size[3] = actuatedPrismatic.box.height;
//   actuatedPrismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedPrismatic.box.color[1] / 255.0,actuatedPrismatic.box.color[2] / 255.0,actuatedPrismatic.box.color[3] / 255.0,actuatedPrismatic.box.specularCoefficient);
//   actuatedPrismatic.box.Extra = actuatedPrismatic.box.extra;
//   actuatedPrismatic.R[1,1] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[1,2] = sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,1] = -sin(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.R[2,2] = cos(actuatedPrismatic.frame_a.phi);
//   actuatedPrismatic.e0[1] = actuatedPrismatic.R[1,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[1,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.e0[2] = actuatedPrismatic.R[2,1] * actuatedPrismatic.e[1] + actuatedPrismatic.R[2,2] * actuatedPrismatic.e[2];
//   actuatedPrismatic.r0[1] = actuatedPrismatic.e0[1] * actuatedPrismatic.s;
//   actuatedPrismatic.r0[2] = actuatedPrismatic.e0[2] * actuatedPrismatic.s;
//   actuatedPrismatic.s = actuatedPrismatic.flange_a.s;
//   actuatedPrismatic.v = der(actuatedPrismatic.s);
//   actuatedPrismatic.a = der(actuatedPrismatic.v);
//   actuatedPrismatic.f = actuatedPrismatic.flange_a.f;
//   actuatedPrismatic.frame_a.x + actuatedPrismatic.r0[1] = actuatedPrismatic.frame_b.x;
//   actuatedPrismatic.frame_a.y + actuatedPrismatic.r0[2] = actuatedPrismatic.frame_b.y;
//   actuatedPrismatic.frame_a.phi = actuatedPrismatic.frame_b.phi;
//   actuatedPrismatic.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   actuatedPrismatic.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   actuatedPrismatic.frame_a.t + (actuatedPrismatic.frame_b.t + ((-actuatedPrismatic.r0[1]) * actuatedPrismatic.frame_b.fy + actuatedPrismatic.r0[2] * actuatedPrismatic.frame_b.fx)) = 0.0;
//   actuatedPrismatic.frame_a.fx * actuatedPrismatic.e0[1] + actuatedPrismatic.frame_a.fy * actuatedPrismatic.e0[2] = actuatedPrismatic.f;
//   springDamper.f = springDamper.c * (springDamper.s_rel - springDamper.s_rel0) + springDamper.d * springDamper.v_rel;
//   springDamper.s_rel = springDamper.flange_b.s - springDamper.flange_a.s;
//   springDamper.v_rel = der(springDamper.s_rel);
//   springDamper.flange_b.f = springDamper.f;
//   springDamper.flange_a.f = -springDamper.f;
//   fixed1.flange.s = fixed1.s0;
//   revolute.frame_a.t + fixed.frame_a.t + actuatedPrismatic.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy + actuatedPrismatic.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx + actuatedPrismatic.frame_a.fx = 0.0;
//   revolute.frame_b.t + fixedTranslation1.frame_a.t = 0.0;
//   revolute.frame_b.fy + fixedTranslation1.frame_a.fy = 0.0;
//   revolute.frame_b.fx + fixedTranslation1.frame_a.fx = 0.0;
//   revolute1.frame_a.t + actuatedPrismatic.frame_b.t = 0.0;
//   revolute1.frame_a.fy + actuatedPrismatic.frame_b.fy = 0.0;
//   revolute1.frame_a.fx + actuatedPrismatic.frame_b.fx = 0.0;
//   revolute1.frame_b.t + fixedTranslation2.frame_a.t = 0.0;
//   revolute1.frame_b.fy + fixedTranslation2.frame_a.fy = 0.0;
//   revolute1.frame_b.fx + fixedTranslation2.frame_a.fx = 0.0;
//   revolute2.frame_a.t + revolute3.frame_a.t + fixedTranslation1.frame_b.t = 0.0;
//   revolute2.frame_a.fy + revolute3.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   revolute2.frame_a.fx + revolute3.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   revolute2.frame_b.t + fixedTranslation2.frame_b.t = 0.0;
//   revolute2.frame_b.fy + fixedTranslation2.frame_b.fy = 0.0;
//   revolute2.frame_b.fx + fixedTranslation2.frame_b.fx = 0.0;
//   revolute3.frame_b.t + fixedTranslation3.frame_a.t = 0.0;
//   revolute3.frame_b.fy + fixedTranslation3.frame_a.fy = 0.0;
//   revolute3.frame_b.fx + fixedTranslation3.frame_a.fx = 0.0;
//   fixedTranslation3.frame_b.t + body.frame_a.t = 0.0;
//   fixedTranslation3.frame_b.fy + body.frame_a.fy = 0.0;
//   fixedTranslation3.frame_b.fx + body.frame_a.fx = 0.0;
//   actuatedPrismatic.flange_a.f + springDamper.flange_b.f = 0.0;
//   springDamper.flange_a.f + fixed1.flange.f = 0.0;
//   fixedTranslation1.frame_a.x = revolute.frame_b.x;
//   fixedTranslation1.frame_a.y = revolute.frame_b.y;
//   fixedTranslation1.frame_a.phi = revolute.frame_b.phi;
//   fixedTranslation2.frame_a.x = revolute1.frame_b.x;
//   fixedTranslation2.frame_a.y = revolute1.frame_b.y;
//   fixedTranslation2.frame_a.phi = revolute1.frame_b.phi;
//   fixedTranslation1.frame_b.x = revolute2.frame_a.x;
//   fixedTranslation1.frame_b.x = revolute3.frame_a.x;
//   fixedTranslation1.frame_b.y = revolute2.frame_a.y;
//   fixedTranslation1.frame_b.y = revolute3.frame_a.y;
//   fixedTranslation1.frame_b.phi = revolute2.frame_a.phi;
//   fixedTranslation1.frame_b.phi = revolute3.frame_a.phi;
//   fixedTranslation2.frame_b.x = revolute2.frame_b.x;
//   fixedTranslation2.frame_b.y = revolute2.frame_b.y;
//   fixedTranslation2.frame_b.phi = revolute2.frame_b.phi;
//   fixedTranslation3.frame_a.x = revolute3.frame_b.x;
//   fixedTranslation3.frame_a.y = revolute3.frame_b.y;
//   fixedTranslation3.frame_a.phi = revolute3.frame_b.phi;
//   actuatedPrismatic.frame_b.x = revolute1.frame_a.x;
//   actuatedPrismatic.frame_b.y = revolute1.frame_a.y;
//   actuatedPrismatic.frame_b.phi = revolute1.frame_a.phi;
//   actuatedPrismatic.frame_a.x = fixed.frame_a.x;
//   actuatedPrismatic.frame_a.x = revolute.frame_a.x;
//   actuatedPrismatic.frame_a.y = fixed.frame_a.y;
//   actuatedPrismatic.frame_a.y = revolute.frame_a.y;
//   actuatedPrismatic.frame_a.phi = fixed.frame_a.phi;
//   actuatedPrismatic.frame_a.phi = revolute.frame_a.phi;
//   actuatedPrismatic.flange_a.s = springDamper.flange_b.s;
//   fixed1.flange.s = springDamper.flange_a.s;
//   body.frame_a.x = fixedTranslation3.frame_b.x;
//   body.frame_a.y = fixedTranslation3.frame_b.y;
//   body.frame_a.phi = fixedTranslation3.frame_b.phi;
// end PlanarMechanicsForTesting.Examples.KinematicLoop_DynamicStateSelection;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.TestIdealWheel
//   Real idealWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real idealWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real idealWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real idealWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelJoint.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean idealWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelJoint.r[1] ^ 2.0 + idealWheelJoint.r[2] ^ 2.0);
//   final parameter Real idealWheelJoint.e[1] = idealWheelJoint.r[1] / idealWheelJoint.l \"normalized direction\";
//   final parameter Real idealWheelJoint.e[2] = idealWheelJoint.r[2] / idealWheelJoint.l \"normalized direction\";
//   parameter String idealWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-idealWheelJoint.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = idealWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Width of visual object\";
//   input Real idealWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Height of visual object\";
//   input Real idealWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.cylinder.lengthDirection[1],idealWheelJoint.cylinder.lengthDirection[2],idealWheelJoint.cylinder.lengthDirection[3]});
//   protected Real idealWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 0.0000000001) then 1.0 else idealWheelJoint.cylinder.lengthDirection[1] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealWheelJoint.cylinder.lengthDirection[2] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealWheelJoint.cylinder.lengthDirection[3] / idealWheelJoint.cylinder.abs_n_x;
//   protected Real idealWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[3] - idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[2];
//   protected Real idealWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = idealWheelJoint.cylinder.e_x[3] * idealWheelJoint.cylinder.widthDirection[1] - idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[3];
//   protected Real idealWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = idealWheelJoint.cylinder.e_x[1] * idealWheelJoint.cylinder.widthDirection[2] - idealWheelJoint.cylinder.e_x[2] * idealWheelJoint.cylinder.widthDirection[1];
//   protected Real idealWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[1];
//   protected Real idealWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[2];
//   protected Real idealWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]},if noEvent(idealWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + idealWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.cylinder.widthDirection[1],idealWheelJoint.cylinder.widthDirection[2],idealWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.cylinder.e_x[1],idealWheelJoint.cylinder.e_x[2],idealWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real idealWheelJoint.cylinder.Form;
//   output Real idealWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.cylinder.Material;
//   protected output Real idealWheelJoint.cylinder.Extra;
//   parameter String idealWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim1.lengthDirection[1],idealWheelJoint.rim1.lengthDirection[2],idealWheelJoint.rim1.lengthDirection[3]});
//   protected Real idealWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 0.0000000001) then 1.0 else idealWheelJoint.rim1.lengthDirection[1] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 0.0000000001) then 0.0 else idealWheelJoint.rim1.lengthDirection[2] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim1.abs_n_x < 0.0000000001) then 0.0 else idealWheelJoint.rim1.lengthDirection[3] / idealWheelJoint.rim1.abs_n_x;
//   protected Real idealWheelJoint.rim1.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[3] - idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[2];
//   protected Real idealWheelJoint.rim1.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim1.e_x[3] * idealWheelJoint.rim1.widthDirection[1] - idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[3];
//   protected Real idealWheelJoint.rim1.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim1.e_x[1] * idealWheelJoint.rim1.widthDirection[2] - idealWheelJoint.rim1.e_x[2] * idealWheelJoint.rim1.widthDirection[1];
//   protected Real idealWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[1];
//   protected Real idealWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[2];
//   protected Real idealWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]},if noEvent(idealWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim1.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.rim1.widthDirection[1],idealWheelJoint.rim1.widthDirection[2],idealWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.rim1.e_x[1],idealWheelJoint.rim1.e_x[2],idealWheelJoint.rim1.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim1.Form;
//   output Real idealWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim1.Material;
//   protected output Real idealWheelJoint.rim1.Extra;
//   parameter String idealWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelJoint.radius \"Length of visual object\";
//   input Real idealWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelJoint.rim2.lengthDirection[1],idealWheelJoint.rim2.lengthDirection[2],idealWheelJoint.rim2.lengthDirection[3]});
//   protected Real idealWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 0.0000000001) then 1.0 else idealWheelJoint.rim2.lengthDirection[1] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 0.0000000001) then 0.0 else idealWheelJoint.rim2.lengthDirection[2] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelJoint.rim2.abs_n_x < 0.0000000001) then 0.0 else idealWheelJoint.rim2.lengthDirection[3] / idealWheelJoint.rim2.abs_n_x;
//   protected Real idealWheelJoint.rim2.n_z_aux[1](unit = \"1\") = idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[3] - idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[2];
//   protected Real idealWheelJoint.rim2.n_z_aux[2](unit = \"1\") = idealWheelJoint.rim2.e_x[3] * idealWheelJoint.rim2.widthDirection[1] - idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[3];
//   protected Real idealWheelJoint.rim2.n_z_aux[3](unit = \"1\") = idealWheelJoint.rim2.e_x[1] * idealWheelJoint.rim2.widthDirection[2] - idealWheelJoint.rim2.e_x[2] * idealWheelJoint.rim2.widthDirection[1];
//   protected Real idealWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[1];
//   protected Real idealWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[2];
//   protected Real idealWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]},if noEvent(idealWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (idealWheelJoint.rim2.n_z_aux[2] ^ 2.0 + idealWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelJoint.rim2.widthDirection[1],idealWheelJoint.rim2.widthDirection[2],idealWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(idealWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelJoint.rim2.e_x[1],idealWheelJoint.rim2.e_x[2],idealWheelJoint.rim2.e_x[3]})[3];
//   protected output Real idealWheelJoint.rim2.Form;
//   output Real idealWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelJoint.rim2.Material;
//   protected output Real idealWheelJoint.rim2.Extra;
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, start = 1.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real prismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   parameter Boolean prismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = true \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.always) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.always) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
// equation
//   idealWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.cylinder.shapeType);
//   idealWheelJoint.cylinder.rxvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.rxvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_x[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_x[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_x[3];
//   idealWheelJoint.cylinder.ryvisobj[1] = idealWheelJoint.cylinder.R.T[1,1] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,1] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,1] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[2] = idealWheelJoint.cylinder.R.T[1,2] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,2] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,2] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.ryvisobj[3] = idealWheelJoint.cylinder.R.T[1,3] * idealWheelJoint.cylinder.e_y[1] + idealWheelJoint.cylinder.R.T[2,3] * idealWheelJoint.cylinder.e_y[2] + idealWheelJoint.cylinder.R.T[3,3] * idealWheelJoint.cylinder.e_y[3];
//   idealWheelJoint.cylinder.rvisobj = idealWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.cylinder.R.T[1,1],idealWheelJoint.cylinder.R.T[1,2],idealWheelJoint.cylinder.R.T[1,3]},{idealWheelJoint.cylinder.R.T[2,1],idealWheelJoint.cylinder.R.T[2,2],idealWheelJoint.cylinder.R.T[2,3]},{idealWheelJoint.cylinder.R.T[3,1],idealWheelJoint.cylinder.R.T[3,2],idealWheelJoint.cylinder.R.T[3,3]}},{idealWheelJoint.cylinder.r_shape[1],idealWheelJoint.cylinder.r_shape[2],idealWheelJoint.cylinder.r_shape[3]});
//   idealWheelJoint.cylinder.size[1] = idealWheelJoint.cylinder.length;
//   idealWheelJoint.cylinder.size[2] = idealWheelJoint.cylinder.width;
//   idealWheelJoint.cylinder.size[3] = idealWheelJoint.cylinder.height;
//   idealWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.cylinder.color[1] / 255.0,idealWheelJoint.cylinder.color[2] / 255.0,idealWheelJoint.cylinder.color[3] / 255.0,idealWheelJoint.cylinder.specularCoefficient);
//   idealWheelJoint.cylinder.Extra = idealWheelJoint.cylinder.extra;
//   idealWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim1.shapeType);
//   idealWheelJoint.rim1.rxvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.rxvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_x[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_x[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_x[3];
//   idealWheelJoint.rim1.ryvisobj[1] = idealWheelJoint.rim1.R.T[1,1] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,1] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,1] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[2] = idealWheelJoint.rim1.R.T[1,2] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,2] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,2] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.ryvisobj[3] = idealWheelJoint.rim1.R.T[1,3] * idealWheelJoint.rim1.e_y[1] + idealWheelJoint.rim1.R.T[2,3] * idealWheelJoint.rim1.e_y[2] + idealWheelJoint.rim1.R.T[3,3] * idealWheelJoint.rim1.e_y[3];
//   idealWheelJoint.rim1.rvisobj = idealWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim1.R.T[1,1],idealWheelJoint.rim1.R.T[1,2],idealWheelJoint.rim1.R.T[1,3]},{idealWheelJoint.rim1.R.T[2,1],idealWheelJoint.rim1.R.T[2,2],idealWheelJoint.rim1.R.T[2,3]},{idealWheelJoint.rim1.R.T[3,1],idealWheelJoint.rim1.R.T[3,2],idealWheelJoint.rim1.R.T[3,3]}},{idealWheelJoint.rim1.r_shape[1],idealWheelJoint.rim1.r_shape[2],idealWheelJoint.rim1.r_shape[3]});
//   idealWheelJoint.rim1.size[1] = idealWheelJoint.rim1.length;
//   idealWheelJoint.rim1.size[2] = idealWheelJoint.rim1.width;
//   idealWheelJoint.rim1.size[3] = idealWheelJoint.rim1.height;
//   idealWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim1.color[1] / 255.0,idealWheelJoint.rim1.color[2] / 255.0,idealWheelJoint.rim1.color[3] / 255.0,idealWheelJoint.rim1.specularCoefficient);
//   idealWheelJoint.rim1.Extra = idealWheelJoint.rim1.extra;
//   idealWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelJoint.e0[2],idealWheelJoint.e0[1],0.0},1.5707963267948966 + idealWheelJoint.flange_a.phi,0.0);
//   idealWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelJoint.rim2.shapeType);
//   idealWheelJoint.rim2.rxvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.rxvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_x[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_x[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_x[3];
//   idealWheelJoint.rim2.ryvisobj[1] = idealWheelJoint.rim2.R.T[1,1] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,1] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,1] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[2] = idealWheelJoint.rim2.R.T[1,2] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,2] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,2] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.ryvisobj[3] = idealWheelJoint.rim2.R.T[1,3] * idealWheelJoint.rim2.e_y[1] + idealWheelJoint.rim2.R.T[2,3] * idealWheelJoint.rim2.e_y[2] + idealWheelJoint.rim2.R.T[3,3] * idealWheelJoint.rim2.e_y[3];
//   idealWheelJoint.rim2.rvisobj = idealWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelJoint.rim2.R.T[1,1],idealWheelJoint.rim2.R.T[1,2],idealWheelJoint.rim2.R.T[1,3]},{idealWheelJoint.rim2.R.T[2,1],idealWheelJoint.rim2.R.T[2,2],idealWheelJoint.rim2.R.T[2,3]},{idealWheelJoint.rim2.R.T[3,1],idealWheelJoint.rim2.R.T[3,2],idealWheelJoint.rim2.R.T[3,3]}},{idealWheelJoint.rim2.r_shape[1],idealWheelJoint.rim2.r_shape[2],idealWheelJoint.rim2.r_shape[3]});
//   idealWheelJoint.rim2.size[1] = idealWheelJoint.rim2.length;
//   idealWheelJoint.rim2.size[2] = idealWheelJoint.rim2.width;
//   idealWheelJoint.rim2.size[3] = idealWheelJoint.rim2.height;
//   idealWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelJoint.rim2.color[1] / 255.0,idealWheelJoint.rim2.color[2] / 255.0,idealWheelJoint.rim2.color[3] / 255.0,idealWheelJoint.rim2.specularCoefficient);
//   idealWheelJoint.rim2.Extra = idealWheelJoint.rim2.extra;
//   idealWheelJoint.R[1,1] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[1,2] = sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,1] = -sin(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.R[2,2] = cos(idealWheelJoint.frame_a.phi);
//   idealWheelJoint.e0[1] = idealWheelJoint.R[1,1] * idealWheelJoint.e[1] + idealWheelJoint.R[1,2] * idealWheelJoint.e[2];
//   idealWheelJoint.e0[2] = idealWheelJoint.R[2,1] * idealWheelJoint.e[1] + idealWheelJoint.R[2,2] * idealWheelJoint.e[2];
//   idealWheelJoint.v[1] = der(idealWheelJoint.frame_a.x);
//   idealWheelJoint.v[2] = der(idealWheelJoint.frame_a.y);
//   idealWheelJoint.v[1] = idealWheelJoint.e0[1] * idealWheelJoint.v_long;
//   idealWheelJoint.v[2] = idealWheelJoint.e0[2] * idealWheelJoint.v_long;
//   idealWheelJoint.w_roll = der(idealWheelJoint.flange_a.phi);
//   idealWheelJoint.v_long = idealWheelJoint.radius * idealWheelJoint.w_roll;
//   idealWheelJoint.a = der(idealWheelJoint.v_long);
//   (-idealWheelJoint.f_long) * idealWheelJoint.radius = idealWheelJoint.flange_a.tau;
//   idealWheelJoint.frame_a.t = 0.0;
//   idealWheelJoint.frame_a.fx * idealWheelJoint.e0[1] + idealWheelJoint.frame_a.fy * idealWheelJoint.e0[2] = idealWheelJoint.f_long;
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.e0[1] = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2];
//   prismatic.e0[2] = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2];
//   prismatic.r0[1] = prismatic.e0[1] * prismatic.s;
//   prismatic.r0[2] = prismatic.e0[2] * prismatic.s;
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * prismatic.e0[1] + prismatic.frame_a.fy * prismatic.e0[2] = 0.0;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   idealWheelJoint.frame_a.t + prismatic.frame_b.t + body.frame_a.t = 0.0;
//   idealWheelJoint.frame_a.fy + prismatic.frame_b.fy + body.frame_a.fy = 0.0;
//   idealWheelJoint.frame_a.fx + prismatic.frame_b.fx + body.frame_a.fx = 0.0;
//   idealWheelJoint.flange_a.tau + inertia.flange_b.tau = 0.0;
//   prismatic.frame_a.t + revolute.frame_b.t = 0.0;
//   prismatic.frame_a.fy + revolute.frame_b.fy = 0.0;
//   prismatic.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   engineTorque.flange.tau + inertia.flange_a.tau = 0.0;
//   body.frame_a.x = idealWheelJoint.frame_a.x;
//   body.frame_a.x = prismatic.frame_b.x;
//   body.frame_a.y = idealWheelJoint.frame_a.y;
//   body.frame_a.y = prismatic.frame_b.y;
//   body.frame_a.phi = idealWheelJoint.frame_a.phi;
//   body.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.x = revolute.frame_b.x;
//   prismatic.frame_a.y = revolute.frame_b.y;
//   prismatic.frame_a.phi = revolute.frame_b.phi;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = inertia.flange_a.phi;
//   idealWheelJoint.flange_a.phi = inertia.flange_b.phi;
// end PlanarMechanicsForTesting.Examples.TestIdealWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsForTesting.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsForTesting.Utilities.S_Func;
// 
// function PlanarMechanicsForTesting.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsForTesting.Utilities.TripleS_Func;
// 
// class PlanarMechanicsForTesting.Examples.TestDryFrictionWheel
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, start = 1.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real prismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   parameter Boolean prismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real dryFrictionWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real dryFrictionWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real dryFrictionWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real dryFrictionWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real dryFrictionWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real dryFrictionWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real dryFrictionWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real dryFrictionWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real dryFrictionWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real dryFrictionWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real dryFrictionWheelJoint.N(quantity = \"Force\", unit = \"N\") = 100.0 \"normal force\";
//   parameter Real dryFrictionWheelJoint.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real dryFrictionWheelJoint.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real dryFrictionWheelJoint.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real dryFrictionWheelJoint.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real dryFrictionWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real dryFrictionWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real dryFrictionWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real dryFrictionWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real dryFrictionWheelJoint.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real dryFrictionWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real dryFrictionWheelJoint.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real dryFrictionWheelJoint.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real dryFrictionWheelJoint.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real dryFrictionWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean dryFrictionWheelJoint.animate = true \"enable Animation\";
//   parameter Boolean dryFrictionWheelJoint.SimVis = false \"perform animation with SimVis\";
//   final parameter Real dryFrictionWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(dryFrictionWheelJoint.r[1] ^ 2.0 + dryFrictionWheelJoint.r[2] ^ 2.0);
//   final parameter Real dryFrictionWheelJoint.e[1] = dryFrictionWheelJoint.r[1] / dryFrictionWheelJoint.l \"normalized direction\";
//   final parameter Real dryFrictionWheelJoint.e[2] = dryFrictionWheelJoint.r[2] / dryFrictionWheelJoint.l \"normalized direction\";
//   parameter String dryFrictionWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-dryFrictionWheelJoint.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -dryFrictionWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = dryFrictionWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real dryFrictionWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Width of visual object\";
//   input Real dryFrictionWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Height of visual object\";
//   input Real dryFrictionWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint.cylinder.lengthDirection[1],dryFrictionWheelJoint.cylinder.lengthDirection[2],dryFrictionWheelJoint.cylinder.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint.cylinder.abs_n_x < 0.0000000001) then 1.0 else dryFrictionWheelJoint.cylinder.lengthDirection[1] / dryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint.cylinder.abs_n_x < 0.0000000001) then 0.0 else dryFrictionWheelJoint.cylinder.lengthDirection[2] / dryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint.cylinder.abs_n_x < 0.0000000001) then 0.0 else dryFrictionWheelJoint.cylinder.lengthDirection[3] / dryFrictionWheelJoint.cylinder.abs_n_x;
//   protected Real dryFrictionWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint.cylinder.e_x[2] * dryFrictionWheelJoint.cylinder.widthDirection[3] - dryFrictionWheelJoint.cylinder.e_x[3] * dryFrictionWheelJoint.cylinder.widthDirection[2];
//   protected Real dryFrictionWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint.cylinder.e_x[3] * dryFrictionWheelJoint.cylinder.widthDirection[1] - dryFrictionWheelJoint.cylinder.e_x[1] * dryFrictionWheelJoint.cylinder.widthDirection[3];
//   protected Real dryFrictionWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint.cylinder.e_x[1] * dryFrictionWheelJoint.cylinder.widthDirection[2] - dryFrictionWheelJoint.cylinder.e_x[2] * dryFrictionWheelJoint.cylinder.widthDirection[1];
//   protected Real dryFrictionWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.cylinder.widthDirection[1],dryFrictionWheelJoint.cylinder.widthDirection[2],dryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.cylinder.widthDirection[1],dryFrictionWheelJoint.cylinder.widthDirection[2],dryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]},if noEvent(dryFrictionWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.cylinder.widthDirection[1],dryFrictionWheelJoint.cylinder.widthDirection[2],dryFrictionWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.cylinder.e_x[1],dryFrictionWheelJoint.cylinder.e_x[2],dryFrictionWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint.cylinder.Form;
//   output Real dryFrictionWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.cylinder.Material;
//   protected output Real dryFrictionWheelJoint.cylinder.Extra;
//   parameter String dryFrictionWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint.rim1.lengthDirection[1],dryFrictionWheelJoint.rim1.lengthDirection[2],dryFrictionWheelJoint.rim1.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim1.abs_n_x < 0.0000000001) then 1.0 else dryFrictionWheelJoint.rim1.lengthDirection[1] / dryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim1.abs_n_x < 0.0000000001) then 0.0 else dryFrictionWheelJoint.rim1.lengthDirection[2] / dryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim1.abs_n_x < 0.0000000001) then 0.0 else dryFrictionWheelJoint.rim1.lengthDirection[3] / dryFrictionWheelJoint.rim1.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim1.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint.rim1.e_x[2] * dryFrictionWheelJoint.rim1.widthDirection[3] - dryFrictionWheelJoint.rim1.e_x[3] * dryFrictionWheelJoint.rim1.widthDirection[2];
//   protected Real dryFrictionWheelJoint.rim1.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint.rim1.e_x[3] * dryFrictionWheelJoint.rim1.widthDirection[1] - dryFrictionWheelJoint.rim1.e_x[1] * dryFrictionWheelJoint.rim1.widthDirection[3];
//   protected Real dryFrictionWheelJoint.rim1.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint.rim1.e_x[1] * dryFrictionWheelJoint.rim1.widthDirection[2] - dryFrictionWheelJoint.rim1.e_x[2] * dryFrictionWheelJoint.rim1.widthDirection[1];
//   protected Real dryFrictionWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.rim1.widthDirection[1],dryFrictionWheelJoint.rim1.widthDirection[2],dryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.rim1.widthDirection[1],dryFrictionWheelJoint.rim1.widthDirection[2],dryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]},if noEvent(dryFrictionWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim1.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.rim1.widthDirection[1],dryFrictionWheelJoint.rim1.widthDirection[2],dryFrictionWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.rim1.e_x[1],dryFrictionWheelJoint.rim1.e_x[2],dryFrictionWheelJoint.rim1.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint.rim1.Form;
//   output Real dryFrictionWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim1.Material;
//   protected output Real dryFrictionWheelJoint.rim1.Extra;
//   parameter String dryFrictionWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real dryFrictionWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real dryFrictionWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = dryFrictionWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real dryFrictionWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -dryFrictionWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real dryFrictionWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * dryFrictionWheelJoint.radius \"Length of visual object\";
//   input Real dryFrictionWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real dryFrictionWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real dryFrictionWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real dryFrictionWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real dryFrictionWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real dryFrictionWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({dryFrictionWheelJoint.rim2.lengthDirection[1],dryFrictionWheelJoint.rim2.lengthDirection[2],dryFrictionWheelJoint.rim2.lengthDirection[3]});
//   protected Real dryFrictionWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim2.abs_n_x < 0.0000000001) then 1.0 else dryFrictionWheelJoint.rim2.lengthDirection[1] / dryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim2.abs_n_x < 0.0000000001) then 0.0 else dryFrictionWheelJoint.rim2.lengthDirection[2] / dryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(dryFrictionWheelJoint.rim2.abs_n_x < 0.0000000001) then 0.0 else dryFrictionWheelJoint.rim2.lengthDirection[3] / dryFrictionWheelJoint.rim2.abs_n_x;
//   protected Real dryFrictionWheelJoint.rim2.n_z_aux[1](unit = \"1\") = dryFrictionWheelJoint.rim2.e_x[2] * dryFrictionWheelJoint.rim2.widthDirection[3] - dryFrictionWheelJoint.rim2.e_x[3] * dryFrictionWheelJoint.rim2.widthDirection[2];
//   protected Real dryFrictionWheelJoint.rim2.n_z_aux[2](unit = \"1\") = dryFrictionWheelJoint.rim2.e_x[3] * dryFrictionWheelJoint.rim2.widthDirection[1] - dryFrictionWheelJoint.rim2.e_x[1] * dryFrictionWheelJoint.rim2.widthDirection[3];
//   protected Real dryFrictionWheelJoint.rim2.n_z_aux[3](unit = \"1\") = dryFrictionWheelJoint.rim2.e_x[1] * dryFrictionWheelJoint.rim2.widthDirection[2] - dryFrictionWheelJoint.rim2.e_x[2] * dryFrictionWheelJoint.rim2.widthDirection[1];
//   protected Real dryFrictionWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.rim2.widthDirection[1],dryFrictionWheelJoint.rim2.widthDirection[2],dryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]})[1];
//   protected Real dryFrictionWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.rim2.widthDirection[1],dryFrictionWheelJoint.rim2.widthDirection[2],dryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]})[2];
//   protected Real dryFrictionWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]},if noEvent(dryFrictionWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (dryFrictionWheelJoint.rim2.n_z_aux[2] ^ 2.0 + dryFrictionWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {dryFrictionWheelJoint.rim2.widthDirection[1],dryFrictionWheelJoint.rim2.widthDirection[2],dryFrictionWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(dryFrictionWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{dryFrictionWheelJoint.rim2.e_x[1],dryFrictionWheelJoint.rim2.e_x[2],dryFrictionWheelJoint.rim2.e_x[3]})[3];
//   protected output Real dryFrictionWheelJoint.rim2.Form;
//   output Real dryFrictionWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real dryFrictionWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real dryFrictionWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real dryFrictionWheelJoint.rim2.Material;
//   protected output Real dryFrictionWheelJoint.rim2.Extra;
// equation
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.e0[1] = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2];
//   prismatic.e0[2] = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2];
//   prismatic.r0[1] = prismatic.e0[1] * prismatic.s;
//   prismatic.r0[2] = prismatic.e0[2] * prismatic.s;
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * prismatic.e0[1] + prismatic.frame_a.fy * prismatic.e0[2] = 0.0;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   dryFrictionWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint.cylinder.shapeType);
//   dryFrictionWheelJoint.cylinder.rxvisobj[1] = dryFrictionWheelJoint.cylinder.R.T[1,1] * dryFrictionWheelJoint.cylinder.e_x[1] + dryFrictionWheelJoint.cylinder.R.T[2,1] * dryFrictionWheelJoint.cylinder.e_x[2] + dryFrictionWheelJoint.cylinder.R.T[3,1] * dryFrictionWheelJoint.cylinder.e_x[3];
//   dryFrictionWheelJoint.cylinder.rxvisobj[2] = dryFrictionWheelJoint.cylinder.R.T[1,2] * dryFrictionWheelJoint.cylinder.e_x[1] + dryFrictionWheelJoint.cylinder.R.T[2,2] * dryFrictionWheelJoint.cylinder.e_x[2] + dryFrictionWheelJoint.cylinder.R.T[3,2] * dryFrictionWheelJoint.cylinder.e_x[3];
//   dryFrictionWheelJoint.cylinder.rxvisobj[3] = dryFrictionWheelJoint.cylinder.R.T[1,3] * dryFrictionWheelJoint.cylinder.e_x[1] + dryFrictionWheelJoint.cylinder.R.T[2,3] * dryFrictionWheelJoint.cylinder.e_x[2] + dryFrictionWheelJoint.cylinder.R.T[3,3] * dryFrictionWheelJoint.cylinder.e_x[3];
//   dryFrictionWheelJoint.cylinder.ryvisobj[1] = dryFrictionWheelJoint.cylinder.R.T[1,1] * dryFrictionWheelJoint.cylinder.e_y[1] + dryFrictionWheelJoint.cylinder.R.T[2,1] * dryFrictionWheelJoint.cylinder.e_y[2] + dryFrictionWheelJoint.cylinder.R.T[3,1] * dryFrictionWheelJoint.cylinder.e_y[3];
//   dryFrictionWheelJoint.cylinder.ryvisobj[2] = dryFrictionWheelJoint.cylinder.R.T[1,2] * dryFrictionWheelJoint.cylinder.e_y[1] + dryFrictionWheelJoint.cylinder.R.T[2,2] * dryFrictionWheelJoint.cylinder.e_y[2] + dryFrictionWheelJoint.cylinder.R.T[3,2] * dryFrictionWheelJoint.cylinder.e_y[3];
//   dryFrictionWheelJoint.cylinder.ryvisobj[3] = dryFrictionWheelJoint.cylinder.R.T[1,3] * dryFrictionWheelJoint.cylinder.e_y[1] + dryFrictionWheelJoint.cylinder.R.T[2,3] * dryFrictionWheelJoint.cylinder.e_y[2] + dryFrictionWheelJoint.cylinder.R.T[3,3] * dryFrictionWheelJoint.cylinder.e_y[3];
//   dryFrictionWheelJoint.cylinder.rvisobj = dryFrictionWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint.cylinder.R.T[1,1],dryFrictionWheelJoint.cylinder.R.T[1,2],dryFrictionWheelJoint.cylinder.R.T[1,3]},{dryFrictionWheelJoint.cylinder.R.T[2,1],dryFrictionWheelJoint.cylinder.R.T[2,2],dryFrictionWheelJoint.cylinder.R.T[2,3]},{dryFrictionWheelJoint.cylinder.R.T[3,1],dryFrictionWheelJoint.cylinder.R.T[3,2],dryFrictionWheelJoint.cylinder.R.T[3,3]}},{dryFrictionWheelJoint.cylinder.r_shape[1],dryFrictionWheelJoint.cylinder.r_shape[2],dryFrictionWheelJoint.cylinder.r_shape[3]});
//   dryFrictionWheelJoint.cylinder.size[1] = dryFrictionWheelJoint.cylinder.length;
//   dryFrictionWheelJoint.cylinder.size[2] = dryFrictionWheelJoint.cylinder.width;
//   dryFrictionWheelJoint.cylinder.size[3] = dryFrictionWheelJoint.cylinder.height;
//   dryFrictionWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint.cylinder.color[1] / 255.0,dryFrictionWheelJoint.cylinder.color[2] / 255.0,dryFrictionWheelJoint.cylinder.color[3] / 255.0,dryFrictionWheelJoint.cylinder.specularCoefficient);
//   dryFrictionWheelJoint.cylinder.Extra = dryFrictionWheelJoint.cylinder.extra;
//   dryFrictionWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint.e0[2],dryFrictionWheelJoint.e0[1],0.0},dryFrictionWheelJoint.flange_a.phi,0.0);
//   dryFrictionWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint.rim1.shapeType);
//   dryFrictionWheelJoint.rim1.rxvisobj[1] = dryFrictionWheelJoint.rim1.R.T[1,1] * dryFrictionWheelJoint.rim1.e_x[1] + dryFrictionWheelJoint.rim1.R.T[2,1] * dryFrictionWheelJoint.rim1.e_x[2] + dryFrictionWheelJoint.rim1.R.T[3,1] * dryFrictionWheelJoint.rim1.e_x[3];
//   dryFrictionWheelJoint.rim1.rxvisobj[2] = dryFrictionWheelJoint.rim1.R.T[1,2] * dryFrictionWheelJoint.rim1.e_x[1] + dryFrictionWheelJoint.rim1.R.T[2,2] * dryFrictionWheelJoint.rim1.e_x[2] + dryFrictionWheelJoint.rim1.R.T[3,2] * dryFrictionWheelJoint.rim1.e_x[3];
//   dryFrictionWheelJoint.rim1.rxvisobj[3] = dryFrictionWheelJoint.rim1.R.T[1,3] * dryFrictionWheelJoint.rim1.e_x[1] + dryFrictionWheelJoint.rim1.R.T[2,3] * dryFrictionWheelJoint.rim1.e_x[2] + dryFrictionWheelJoint.rim1.R.T[3,3] * dryFrictionWheelJoint.rim1.e_x[3];
//   dryFrictionWheelJoint.rim1.ryvisobj[1] = dryFrictionWheelJoint.rim1.R.T[1,1] * dryFrictionWheelJoint.rim1.e_y[1] + dryFrictionWheelJoint.rim1.R.T[2,1] * dryFrictionWheelJoint.rim1.e_y[2] + dryFrictionWheelJoint.rim1.R.T[3,1] * dryFrictionWheelJoint.rim1.e_y[3];
//   dryFrictionWheelJoint.rim1.ryvisobj[2] = dryFrictionWheelJoint.rim1.R.T[1,2] * dryFrictionWheelJoint.rim1.e_y[1] + dryFrictionWheelJoint.rim1.R.T[2,2] * dryFrictionWheelJoint.rim1.e_y[2] + dryFrictionWheelJoint.rim1.R.T[3,2] * dryFrictionWheelJoint.rim1.e_y[3];
//   dryFrictionWheelJoint.rim1.ryvisobj[3] = dryFrictionWheelJoint.rim1.R.T[1,3] * dryFrictionWheelJoint.rim1.e_y[1] + dryFrictionWheelJoint.rim1.R.T[2,3] * dryFrictionWheelJoint.rim1.e_y[2] + dryFrictionWheelJoint.rim1.R.T[3,3] * dryFrictionWheelJoint.rim1.e_y[3];
//   dryFrictionWheelJoint.rim1.rvisobj = dryFrictionWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint.rim1.R.T[1,1],dryFrictionWheelJoint.rim1.R.T[1,2],dryFrictionWheelJoint.rim1.R.T[1,3]},{dryFrictionWheelJoint.rim1.R.T[2,1],dryFrictionWheelJoint.rim1.R.T[2,2],dryFrictionWheelJoint.rim1.R.T[2,3]},{dryFrictionWheelJoint.rim1.R.T[3,1],dryFrictionWheelJoint.rim1.R.T[3,2],dryFrictionWheelJoint.rim1.R.T[3,3]}},{dryFrictionWheelJoint.rim1.r_shape[1],dryFrictionWheelJoint.rim1.r_shape[2],dryFrictionWheelJoint.rim1.r_shape[3]});
//   dryFrictionWheelJoint.rim1.size[1] = dryFrictionWheelJoint.rim1.length;
//   dryFrictionWheelJoint.rim1.size[2] = dryFrictionWheelJoint.rim1.width;
//   dryFrictionWheelJoint.rim1.size[3] = dryFrictionWheelJoint.rim1.height;
//   dryFrictionWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint.rim1.color[1] / 255.0,dryFrictionWheelJoint.rim1.color[2] / 255.0,dryFrictionWheelJoint.rim1.color[3] / 255.0,dryFrictionWheelJoint.rim1.specularCoefficient);
//   dryFrictionWheelJoint.rim1.Extra = dryFrictionWheelJoint.rim1.extra;
//   dryFrictionWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-dryFrictionWheelJoint.e0[2],dryFrictionWheelJoint.e0[1],0.0},1.5707963267948966 + dryFrictionWheelJoint.flange_a.phi,0.0);
//   dryFrictionWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(dryFrictionWheelJoint.rim2.shapeType);
//   dryFrictionWheelJoint.rim2.rxvisobj[1] = dryFrictionWheelJoint.rim2.R.T[1,1] * dryFrictionWheelJoint.rim2.e_x[1] + dryFrictionWheelJoint.rim2.R.T[2,1] * dryFrictionWheelJoint.rim2.e_x[2] + dryFrictionWheelJoint.rim2.R.T[3,1] * dryFrictionWheelJoint.rim2.e_x[3];
//   dryFrictionWheelJoint.rim2.rxvisobj[2] = dryFrictionWheelJoint.rim2.R.T[1,2] * dryFrictionWheelJoint.rim2.e_x[1] + dryFrictionWheelJoint.rim2.R.T[2,2] * dryFrictionWheelJoint.rim2.e_x[2] + dryFrictionWheelJoint.rim2.R.T[3,2] * dryFrictionWheelJoint.rim2.e_x[3];
//   dryFrictionWheelJoint.rim2.rxvisobj[3] = dryFrictionWheelJoint.rim2.R.T[1,3] * dryFrictionWheelJoint.rim2.e_x[1] + dryFrictionWheelJoint.rim2.R.T[2,3] * dryFrictionWheelJoint.rim2.e_x[2] + dryFrictionWheelJoint.rim2.R.T[3,3] * dryFrictionWheelJoint.rim2.e_x[3];
//   dryFrictionWheelJoint.rim2.ryvisobj[1] = dryFrictionWheelJoint.rim2.R.T[1,1] * dryFrictionWheelJoint.rim2.e_y[1] + dryFrictionWheelJoint.rim2.R.T[2,1] * dryFrictionWheelJoint.rim2.e_y[2] + dryFrictionWheelJoint.rim2.R.T[3,1] * dryFrictionWheelJoint.rim2.e_y[3];
//   dryFrictionWheelJoint.rim2.ryvisobj[2] = dryFrictionWheelJoint.rim2.R.T[1,2] * dryFrictionWheelJoint.rim2.e_y[1] + dryFrictionWheelJoint.rim2.R.T[2,2] * dryFrictionWheelJoint.rim2.e_y[2] + dryFrictionWheelJoint.rim2.R.T[3,2] * dryFrictionWheelJoint.rim2.e_y[3];
//   dryFrictionWheelJoint.rim2.ryvisobj[3] = dryFrictionWheelJoint.rim2.R.T[1,3] * dryFrictionWheelJoint.rim2.e_y[1] + dryFrictionWheelJoint.rim2.R.T[2,3] * dryFrictionWheelJoint.rim2.e_y[2] + dryFrictionWheelJoint.rim2.R.T[3,3] * dryFrictionWheelJoint.rim2.e_y[3];
//   dryFrictionWheelJoint.rim2.rvisobj = dryFrictionWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{dryFrictionWheelJoint.rim2.R.T[1,1],dryFrictionWheelJoint.rim2.R.T[1,2],dryFrictionWheelJoint.rim2.R.T[1,3]},{dryFrictionWheelJoint.rim2.R.T[2,1],dryFrictionWheelJoint.rim2.R.T[2,2],dryFrictionWheelJoint.rim2.R.T[2,3]},{dryFrictionWheelJoint.rim2.R.T[3,1],dryFrictionWheelJoint.rim2.R.T[3,2],dryFrictionWheelJoint.rim2.R.T[3,3]}},{dryFrictionWheelJoint.rim2.r_shape[1],dryFrictionWheelJoint.rim2.r_shape[2],dryFrictionWheelJoint.rim2.r_shape[3]});
//   dryFrictionWheelJoint.rim2.size[1] = dryFrictionWheelJoint.rim2.length;
//   dryFrictionWheelJoint.rim2.size[2] = dryFrictionWheelJoint.rim2.width;
//   dryFrictionWheelJoint.rim2.size[3] = dryFrictionWheelJoint.rim2.height;
//   dryFrictionWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(dryFrictionWheelJoint.rim2.color[1] / 255.0,dryFrictionWheelJoint.rim2.color[2] / 255.0,dryFrictionWheelJoint.rim2.color[3] / 255.0,dryFrictionWheelJoint.rim2.specularCoefficient);
//   dryFrictionWheelJoint.rim2.Extra = dryFrictionWheelJoint.rim2.extra;
//   dryFrictionWheelJoint.R[1,1] = cos(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.R[1,2] = sin(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.R[2,1] = -sin(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.R[2,2] = cos(dryFrictionWheelJoint.frame_a.phi);
//   dryFrictionWheelJoint.e0[1] = dryFrictionWheelJoint.R[1,1] * dryFrictionWheelJoint.e[1] + dryFrictionWheelJoint.R[1,2] * dryFrictionWheelJoint.e[2];
//   dryFrictionWheelJoint.e0[2] = dryFrictionWheelJoint.R[2,1] * dryFrictionWheelJoint.e[1] + dryFrictionWheelJoint.R[2,2] * dryFrictionWheelJoint.e[2];
//   dryFrictionWheelJoint.v[1] = der(dryFrictionWheelJoint.frame_a.x);
//   dryFrictionWheelJoint.v[2] = der(dryFrictionWheelJoint.frame_a.y);
//   dryFrictionWheelJoint.w_roll = der(dryFrictionWheelJoint.flange_a.phi);
//   dryFrictionWheelJoint.v_long = dryFrictionWheelJoint.v[1] * dryFrictionWheelJoint.e0[1] + dryFrictionWheelJoint.v[2] * dryFrictionWheelJoint.e0[2];
//   dryFrictionWheelJoint.v_lat = (-dryFrictionWheelJoint.v[1]) * dryFrictionWheelJoint.e0[2] + dryFrictionWheelJoint.v[2] * dryFrictionWheelJoint.e0[1];
//   dryFrictionWheelJoint.v_slip_lat = dryFrictionWheelJoint.v_lat;
//   dryFrictionWheelJoint.v_slip_long = dryFrictionWheelJoint.v_long - dryFrictionWheelJoint.radius * dryFrictionWheelJoint.w_roll;
//   dryFrictionWheelJoint.v_slip = 0.0001 + sqrt(dryFrictionWheelJoint.v_slip_long ^ 2.0 + dryFrictionWheelJoint.v_slip_lat ^ 2.0);
//   (-dryFrictionWheelJoint.f_long) * dryFrictionWheelJoint.radius = dryFrictionWheelJoint.flange_a.tau;
//   dryFrictionWheelJoint.frame_a.t = 0.0;
//   dryFrictionWheelJoint.f = dryFrictionWheelJoint.N * PlanarMechanicsForTesting.Utilities.TripleS_Func(dryFrictionWheelJoint.vAdhesion,dryFrictionWheelJoint.vSlide,dryFrictionWheelJoint.mu_A,dryFrictionWheelJoint.mu_S,dryFrictionWheelJoint.v_slip);
//   dryFrictionWheelJoint.f_long = (dryFrictionWheelJoint.f * dryFrictionWheelJoint.v_slip_long) / dryFrictionWheelJoint.v_slip;
//   dryFrictionWheelJoint.f_lat = (dryFrictionWheelJoint.f * dryFrictionWheelJoint.v_slip_lat) / dryFrictionWheelJoint.v_slip;
//   dryFrictionWheelJoint.f_long = dryFrictionWheelJoint.frame_a.fx * dryFrictionWheelJoint.e0[1] + dryFrictionWheelJoint.frame_a.fy * dryFrictionWheelJoint.e0[2];
//   dryFrictionWheelJoint.f_lat = dryFrictionWheelJoint.frame_a.fy * dryFrictionWheelJoint.e0[1] + (-dryFrictionWheelJoint.frame_a.fx) * dryFrictionWheelJoint.e0[2];
//   prismatic.frame_a.t + revolute.frame_b.t = 0.0;
//   prismatic.frame_a.fy + revolute.frame_b.fy = 0.0;
//   prismatic.frame_a.fx + revolute.frame_b.fx = 0.0;
//   prismatic.frame_b.t + body.frame_a.t + dryFrictionWheelJoint.frame_a.t = 0.0;
//   prismatic.frame_b.fy + body.frame_a.fy + dryFrictionWheelJoint.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + body.frame_a.fx + dryFrictionWheelJoint.frame_a.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   engineTorque.flange.tau + inertia.flange_a.tau = 0.0;
//   inertia.flange_b.tau + dryFrictionWheelJoint.flange_a.tau = 0.0;
//   prismatic.frame_a.x = revolute.frame_b.x;
//   prismatic.frame_a.y = revolute.frame_b.y;
//   prismatic.frame_a.phi = revolute.frame_b.phi;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = inertia.flange_a.phi;
//   body.frame_a.x = dryFrictionWheelJoint.frame_a.x;
//   body.frame_a.x = prismatic.frame_b.x;
//   body.frame_a.y = dryFrictionWheelJoint.frame_a.y;
//   body.frame_a.y = prismatic.frame_b.y;
//   body.frame_a.phi = dryFrictionWheelJoint.frame_a.phi;
//   body.frame_a.phi = prismatic.frame_b.phi;
//   dryFrictionWheelJoint.flange_a.phi = inertia.flange_b.phi;
// end PlanarMechanicsForTesting.Examples.TestDryFrictionWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsForTesting.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsForTesting.Utilities.S_Func;
// 
// function PlanarMechanicsForTesting.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsForTesting.Utilities.TripleS_Func;
// 
// class PlanarMechanicsForTesting.Examples.TestSlipBasedWheel
//   Real prismatic.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real prismatic.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real prismatic.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real prismatic.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real prismatic.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real prismatic.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real prismatic.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real prismatic.r[1](quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"direction of the rod wrt. body system at phi=0\";
//   parameter Real prismatic.r[2](quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"direction of the rod wrt. body system at phi=0\";
//   Real prismatic.s(quantity = \"Length\", unit = \"m\", min = 0.0, start = 1.0, StateSelect = StateSelect.prefer) \"Elongation of the joint\";
//   Real prismatic.e0[1] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.e0[2] \"direction of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"translation vector of the prismatic rod resolved wrt.inertial frame\";
//   Real prismatic.R[1,1] \"Rotation Matrix\";
//   Real prismatic.R[1,2] \"Rotation Matrix\";
//   Real prismatic.R[2,1] \"Rotation Matrix\";
//   Real prismatic.R[2,2] \"Rotation Matrix\";
//   Real prismatic.v(quantity = \"Velocity\", unit = \"m/s\", StateSelect = StateSelect.prefer) \"velocity of elongation\";
//   Real prismatic.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of elongation\";
//   Real prismatic.f(quantity = \"Force\", unit = \"N\") \"force in direction of elongation\";
//   parameter Boolean prismatic.initialize = false \"Initialize Position and Velocity\";
//   parameter Real prismatic.s_start(quantity = \"Length\", unit = \"m\") = 0.0;
//   parameter Real prismatic.v_start(quantity = \"Velocity\", unit = \"m/s\") = 0.0;
//   parameter Boolean prismatic.animate = true \"enable Animation\";
//   parameter Boolean prismatic.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   final parameter Real prismatic.l(quantity = \"Length\", unit = \"m\") = sqrt(prismatic.r[1] ^ 2.0 + prismatic.r[2] ^ 2.0) \"lengt of r\";
//   parameter String prismatic.box.shapeType = \"box\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real prismatic.box.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real prismatic.box.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real prismatic.box.r[1](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[2](quantity = \"Length\", unit = \"m\") = prismatic.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real prismatic.box.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[1](unit = \"1\") = prismatic.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[2](unit = \"1\") = prismatic.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real prismatic.box.length(quantity = \"Length\", unit = \"m\") = prismatic.s \"Length of visual object\";
//   input Real prismatic.box.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real prismatic.box.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real prismatic.box.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real prismatic.box.color[1] = 255.0 \"Color of shape\";
//   input Real prismatic.box.color[2] = 63.0 \"Color of shape\";
//   input Real prismatic.box.color[3] = 63.0 \"Color of shape\";
//   input Real prismatic.box.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real prismatic.box.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({prismatic.box.lengthDirection[1],prismatic.box.lengthDirection[2],prismatic.box.lengthDirection[3]});
//   protected Real prismatic.box.e_x[1](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 1.0 else prismatic.box.lengthDirection[1] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[2](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[2] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.e_x[3](unit = \"1\") = if noEvent(prismatic.box.abs_n_x < 0.0000000001) then 0.0 else prismatic.box.lengthDirection[3] / prismatic.box.abs_n_x;
//   protected Real prismatic.box.n_z_aux[1](unit = \"1\") = prismatic.box.e_x[2] * prismatic.box.widthDirection[3] - prismatic.box.e_x[3] * prismatic.box.widthDirection[2];
//   protected Real prismatic.box.n_z_aux[2](unit = \"1\") = prismatic.box.e_x[3] * prismatic.box.widthDirection[1] - prismatic.box.e_x[1] * prismatic.box.widthDirection[3];
//   protected Real prismatic.box.n_z_aux[3](unit = \"1\") = prismatic.box.e_x[1] * prismatic.box.widthDirection[2] - prismatic.box.e_x[2] * prismatic.box.widthDirection[1];
//   protected Real prismatic.box.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[1];
//   protected Real prismatic.box.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[2];
//   protected Real prismatic.box.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]},if noEvent(prismatic.box.n_z_aux[1] ^ 2.0 + (prismatic.box.n_z_aux[2] ^ 2.0 + prismatic.box.n_z_aux[3] ^ 2.0) > 0.000001) then {prismatic.box.widthDirection[1],prismatic.box.widthDirection[2],prismatic.box.widthDirection[3]} else if noEvent(abs(prismatic.box.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{prismatic.box.e_x[1],prismatic.box.e_x[2],prismatic.box.e_x[3]})[3];
//   protected output Real prismatic.box.Form;
//   output Real prismatic.box.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real prismatic.box.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real prismatic.box.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real prismatic.box.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real prismatic.box.Material;
//   protected output Real prismatic.box.Extra;
//   final parameter Real prismatic.e[1](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[1] / prismatic.l \"normalized r\";
//   final parameter Real prismatic.e[2](quantity = \"Length\", unit = \"m\", min = 0.0) = prismatic.r[2] / prismatic.l \"normalized r\";
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = false \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = false \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   Real fixed.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixed.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixed.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixed.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixed.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixed.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixed.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"fixed x,y-position\";
//   parameter Real fixed.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"fixed angle\";
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real slipBasedWheelJoint.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real slipBasedWheelJoint.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real slipBasedWheelJoint.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real slipBasedWheelJoint.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real slipBasedWheelJoint.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real slipBasedWheelJoint.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real slipBasedWheelJoint.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real slipBasedWheelJoint.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real slipBasedWheelJoint.dynamicLoad(unit = \"N\");
//   parameter Real slipBasedWheelJoint.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real slipBasedWheelJoint.r[1](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real slipBasedWheelJoint.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real slipBasedWheelJoint.N(quantity = \"Force\", unit = \"N\") = 100.0 \"base normal load\";
//   parameter Real slipBasedWheelJoint.vAdhesion_min(quantity = \"Velocity\", unit = \"m/s\") = 0.05 \"minimum adhesion velocity\";
//   parameter Real slipBasedWheelJoint.vSlide_min(quantity = \"Velocity\", unit = \"m/s\") = 0.15 \"minimum sliding velocity\";
//   parameter Real slipBasedWheelJoint.sAdhesion = 0.04 \"adhesion slippage\";
//   parameter Real slipBasedWheelJoint.sSlide = 0.12 \"sliding slippage\";
//   parameter Real slipBasedWheelJoint.mu_A = 0.8 \"friction coefficient at adhesion\";
//   parameter Real slipBasedWheelJoint.mu_S = 0.4 \"friction coefficient at sliding\";
//   Real slipBasedWheelJoint.e0[1] \"normalized direction w.r.t inertial system\";
//   Real slipBasedWheelJoint.e0[2] \"normalized direction w.r.t inertial system\";
//   Real slipBasedWheelJoint.R[1,1] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.R[1,2] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.R[2,1] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.R[2,2] \"Rotation Matrix\";
//   Real slipBasedWheelJoint.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real slipBasedWheelJoint.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real slipBasedWheelJoint.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real slipBasedWheelJoint.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real slipBasedWheelJoint.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real slipBasedWheelJoint.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real slipBasedWheelJoint.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real slipBasedWheelJoint.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real slipBasedWheelJoint.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real slipBasedWheelJoint.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real slipBasedWheelJoint.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real slipBasedWheelJoint.fN(quantity = \"Force\", unit = \"N\") \"base normal load\";
//   Real slipBasedWheelJoint.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") \"adhesion velocity\";
//   Real slipBasedWheelJoint.vSlide(quantity = \"Velocity\", unit = \"m/s\") \"sliding velocity\";
//   parameter Boolean slipBasedWheelJoint.animate = true \"enable Animation\";
//   final parameter Real slipBasedWheelJoint.l(quantity = \"Length\", unit = \"m\") = sqrt(slipBasedWheelJoint.r[1] ^ 2.0 + slipBasedWheelJoint.r[2] ^ 2.0);
//   final parameter Real slipBasedWheelJoint.e[1] = slipBasedWheelJoint.r[1] / slipBasedWheelJoint.l \"normalized direction\";
//   final parameter Real slipBasedWheelJoint.e[2] = slipBasedWheelJoint.r[2] / slipBasedWheelJoint.l \"normalized direction\";
//   parameter String slipBasedWheelJoint.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedWheelJoint.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.cylinder.r[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.cylinder.r[2](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-slipBasedWheelJoint.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.lengthDirection[1](unit = \"1\") = -slipBasedWheelJoint.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.lengthDirection[2](unit = \"1\") = slipBasedWheelJoint.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real slipBasedWheelJoint.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Width of visual object\";
//   input Real slipBasedWheelJoint.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Height of visual object\";
//   input Real slipBasedWheelJoint.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedWheelJoint.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedWheelJoint.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedWheelJoint.cylinder.lengthDirection[1],slipBasedWheelJoint.cylinder.lengthDirection[2],slipBasedWheelJoint.cylinder.lengthDirection[3]});
//   protected Real slipBasedWheelJoint.cylinder.e_x[1](unit = \"1\") = if noEvent(slipBasedWheelJoint.cylinder.abs_n_x < 0.0000000001) then 1.0 else slipBasedWheelJoint.cylinder.lengthDirection[1] / slipBasedWheelJoint.cylinder.abs_n_x;
//   protected Real slipBasedWheelJoint.cylinder.e_x[2](unit = \"1\") = if noEvent(slipBasedWheelJoint.cylinder.abs_n_x < 0.0000000001) then 0.0 else slipBasedWheelJoint.cylinder.lengthDirection[2] / slipBasedWheelJoint.cylinder.abs_n_x;
//   protected Real slipBasedWheelJoint.cylinder.e_x[3](unit = \"1\") = if noEvent(slipBasedWheelJoint.cylinder.abs_n_x < 0.0000000001) then 0.0 else slipBasedWheelJoint.cylinder.lengthDirection[3] / slipBasedWheelJoint.cylinder.abs_n_x;
//   protected Real slipBasedWheelJoint.cylinder.n_z_aux[1](unit = \"1\") = slipBasedWheelJoint.cylinder.e_x[2] * slipBasedWheelJoint.cylinder.widthDirection[3] - slipBasedWheelJoint.cylinder.e_x[3] * slipBasedWheelJoint.cylinder.widthDirection[2];
//   protected Real slipBasedWheelJoint.cylinder.n_z_aux[2](unit = \"1\") = slipBasedWheelJoint.cylinder.e_x[3] * slipBasedWheelJoint.cylinder.widthDirection[1] - slipBasedWheelJoint.cylinder.e_x[1] * slipBasedWheelJoint.cylinder.widthDirection[3];
//   protected Real slipBasedWheelJoint.cylinder.n_z_aux[3](unit = \"1\") = slipBasedWheelJoint.cylinder.e_x[1] * slipBasedWheelJoint.cylinder.widthDirection[2] - slipBasedWheelJoint.cylinder.e_x[2] * slipBasedWheelJoint.cylinder.widthDirection[1];
//   protected Real slipBasedWheelJoint.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]},if noEvent(slipBasedWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.cylinder.widthDirection[1],slipBasedWheelJoint.cylinder.widthDirection[2],slipBasedWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]})[1];
//   protected Real slipBasedWheelJoint.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]},if noEvent(slipBasedWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.cylinder.widthDirection[1],slipBasedWheelJoint.cylinder.widthDirection[2],slipBasedWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]})[2];
//   protected Real slipBasedWheelJoint.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]},if noEvent(slipBasedWheelJoint.cylinder.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.cylinder.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.cylinder.widthDirection[1],slipBasedWheelJoint.cylinder.widthDirection[2],slipBasedWheelJoint.cylinder.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.cylinder.e_x[1],slipBasedWheelJoint.cylinder.e_x[2],slipBasedWheelJoint.cylinder.e_x[3]})[3];
//   protected output Real slipBasedWheelJoint.cylinder.Form;
//   output Real slipBasedWheelJoint.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedWheelJoint.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.cylinder.Material;
//   protected output Real slipBasedWheelJoint.cylinder.Extra;
//   parameter String slipBasedWheelJoint.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedWheelJoint.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim1.r[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim1.r[2](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -slipBasedWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Length of visual object\";
//   input Real slipBasedWheelJoint.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedWheelJoint.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedWheelJoint.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedWheelJoint.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedWheelJoint.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedWheelJoint.rim1.lengthDirection[1],slipBasedWheelJoint.rim1.lengthDirection[2],slipBasedWheelJoint.rim1.lengthDirection[3]});
//   protected Real slipBasedWheelJoint.rim1.e_x[1](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim1.abs_n_x < 0.0000000001) then 1.0 else slipBasedWheelJoint.rim1.lengthDirection[1] / slipBasedWheelJoint.rim1.abs_n_x;
//   protected Real slipBasedWheelJoint.rim1.e_x[2](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim1.abs_n_x < 0.0000000001) then 0.0 else slipBasedWheelJoint.rim1.lengthDirection[2] / slipBasedWheelJoint.rim1.abs_n_x;
//   protected Real slipBasedWheelJoint.rim1.e_x[3](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim1.abs_n_x < 0.0000000001) then 0.0 else slipBasedWheelJoint.rim1.lengthDirection[3] / slipBasedWheelJoint.rim1.abs_n_x;
//   protected Real slipBasedWheelJoint.rim1.n_z_aux[1](unit = \"1\") = slipBasedWheelJoint.rim1.e_x[2] * slipBasedWheelJoint.rim1.widthDirection[3] - slipBasedWheelJoint.rim1.e_x[3] * slipBasedWheelJoint.rim1.widthDirection[2];
//   protected Real slipBasedWheelJoint.rim1.n_z_aux[2](unit = \"1\") = slipBasedWheelJoint.rim1.e_x[3] * slipBasedWheelJoint.rim1.widthDirection[1] - slipBasedWheelJoint.rim1.e_x[1] * slipBasedWheelJoint.rim1.widthDirection[3];
//   protected Real slipBasedWheelJoint.rim1.n_z_aux[3](unit = \"1\") = slipBasedWheelJoint.rim1.e_x[1] * slipBasedWheelJoint.rim1.widthDirection[2] - slipBasedWheelJoint.rim1.e_x[2] * slipBasedWheelJoint.rim1.widthDirection[1];
//   protected Real slipBasedWheelJoint.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]},if noEvent(slipBasedWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim1.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.rim1.widthDirection[1],slipBasedWheelJoint.rim1.widthDirection[2],slipBasedWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]})[1];
//   protected Real slipBasedWheelJoint.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]},if noEvent(slipBasedWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim1.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.rim1.widthDirection[1],slipBasedWheelJoint.rim1.widthDirection[2],slipBasedWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]})[2];
//   protected Real slipBasedWheelJoint.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]},if noEvent(slipBasedWheelJoint.rim1.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim1.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.rim1.widthDirection[1],slipBasedWheelJoint.rim1.widthDirection[2],slipBasedWheelJoint.rim1.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.rim1.e_x[1],slipBasedWheelJoint.rim1.e_x[2],slipBasedWheelJoint.rim1.e_x[3]})[3];
//   protected output Real slipBasedWheelJoint.rim1.Form;
//   output Real slipBasedWheelJoint.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedWheelJoint.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim1.Material;
//   protected output Real slipBasedWheelJoint.rim1.Extra;
//   parameter String slipBasedWheelJoint.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real slipBasedWheelJoint.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real slipBasedWheelJoint.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real slipBasedWheelJoint.rim2.r[1](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim2.r[2](quantity = \"Length\", unit = \"m\") = slipBasedWheelJoint.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real slipBasedWheelJoint.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -slipBasedWheelJoint.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real slipBasedWheelJoint.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * slipBasedWheelJoint.radius \"Length of visual object\";
//   input Real slipBasedWheelJoint.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real slipBasedWheelJoint.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real slipBasedWheelJoint.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real slipBasedWheelJoint.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real slipBasedWheelJoint.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real slipBasedWheelJoint.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({slipBasedWheelJoint.rim2.lengthDirection[1],slipBasedWheelJoint.rim2.lengthDirection[2],slipBasedWheelJoint.rim2.lengthDirection[3]});
//   protected Real slipBasedWheelJoint.rim2.e_x[1](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim2.abs_n_x < 0.0000000001) then 1.0 else slipBasedWheelJoint.rim2.lengthDirection[1] / slipBasedWheelJoint.rim2.abs_n_x;
//   protected Real slipBasedWheelJoint.rim2.e_x[2](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim2.abs_n_x < 0.0000000001) then 0.0 else slipBasedWheelJoint.rim2.lengthDirection[2] / slipBasedWheelJoint.rim2.abs_n_x;
//   protected Real slipBasedWheelJoint.rim2.e_x[3](unit = \"1\") = if noEvent(slipBasedWheelJoint.rim2.abs_n_x < 0.0000000001) then 0.0 else slipBasedWheelJoint.rim2.lengthDirection[3] / slipBasedWheelJoint.rim2.abs_n_x;
//   protected Real slipBasedWheelJoint.rim2.n_z_aux[1](unit = \"1\") = slipBasedWheelJoint.rim2.e_x[2] * slipBasedWheelJoint.rim2.widthDirection[3] - slipBasedWheelJoint.rim2.e_x[3] * slipBasedWheelJoint.rim2.widthDirection[2];
//   protected Real slipBasedWheelJoint.rim2.n_z_aux[2](unit = \"1\") = slipBasedWheelJoint.rim2.e_x[3] * slipBasedWheelJoint.rim2.widthDirection[1] - slipBasedWheelJoint.rim2.e_x[1] * slipBasedWheelJoint.rim2.widthDirection[3];
//   protected Real slipBasedWheelJoint.rim2.n_z_aux[3](unit = \"1\") = slipBasedWheelJoint.rim2.e_x[1] * slipBasedWheelJoint.rim2.widthDirection[2] - slipBasedWheelJoint.rim2.e_x[2] * slipBasedWheelJoint.rim2.widthDirection[1];
//   protected Real slipBasedWheelJoint.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]},if noEvent(slipBasedWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim2.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.rim2.widthDirection[1],slipBasedWheelJoint.rim2.widthDirection[2],slipBasedWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]})[1];
//   protected Real slipBasedWheelJoint.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]},if noEvent(slipBasedWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim2.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.rim2.widthDirection[1],slipBasedWheelJoint.rim2.widthDirection[2],slipBasedWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]})[2];
//   protected Real slipBasedWheelJoint.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]},if noEvent(slipBasedWheelJoint.rim2.n_z_aux[1] ^ 2.0 + (slipBasedWheelJoint.rim2.n_z_aux[2] ^ 2.0 + slipBasedWheelJoint.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {slipBasedWheelJoint.rim2.widthDirection[1],slipBasedWheelJoint.rim2.widthDirection[2],slipBasedWheelJoint.rim2.widthDirection[3]} else if noEvent(abs(slipBasedWheelJoint.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{slipBasedWheelJoint.rim2.e_x[1],slipBasedWheelJoint.rim2.e_x[2],slipBasedWheelJoint.rim2.e_x[3]})[3];
//   protected output Real slipBasedWheelJoint.rim2.Form;
//   output Real slipBasedWheelJoint.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real slipBasedWheelJoint.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real slipBasedWheelJoint.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real slipBasedWheelJoint.rim2.Material;
//   protected output Real slipBasedWheelJoint.rim2.Extra;
//   output Real const.y \"Connector of Real output signal\";
//   parameter Real const.k(start = 1.0) = 0.0 \"Constant output value\";
// equation
//   prismatic.box.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(prismatic.box.shapeType);
//   prismatic.box.rxvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_x[1] + prismatic.box.R.T[2,1] * prismatic.box.e_x[2] + prismatic.box.R.T[3,1] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_x[1] + prismatic.box.R.T[2,2] * prismatic.box.e_x[2] + prismatic.box.R.T[3,2] * prismatic.box.e_x[3];
//   prismatic.box.rxvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_x[1] + prismatic.box.R.T[2,3] * prismatic.box.e_x[2] + prismatic.box.R.T[3,3] * prismatic.box.e_x[3];
//   prismatic.box.ryvisobj[1] = prismatic.box.R.T[1,1] * prismatic.box.e_y[1] + prismatic.box.R.T[2,1] * prismatic.box.e_y[2] + prismatic.box.R.T[3,1] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[2] = prismatic.box.R.T[1,2] * prismatic.box.e_y[1] + prismatic.box.R.T[2,2] * prismatic.box.e_y[2] + prismatic.box.R.T[3,2] * prismatic.box.e_y[3];
//   prismatic.box.ryvisobj[3] = prismatic.box.R.T[1,3] * prismatic.box.e_y[1] + prismatic.box.R.T[2,3] * prismatic.box.e_y[2] + prismatic.box.R.T[3,3] * prismatic.box.e_y[3];
//   prismatic.box.rvisobj = prismatic.box.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{prismatic.box.R.T[1,1],prismatic.box.R.T[1,2],prismatic.box.R.T[1,3]},{prismatic.box.R.T[2,1],prismatic.box.R.T[2,2],prismatic.box.R.T[2,3]},{prismatic.box.R.T[3,1],prismatic.box.R.T[3,2],prismatic.box.R.T[3,3]}},{prismatic.box.r_shape[1],prismatic.box.r_shape[2],prismatic.box.r_shape[3]});
//   prismatic.box.size[1] = prismatic.box.length;
//   prismatic.box.size[2] = prismatic.box.width;
//   prismatic.box.size[3] = prismatic.box.height;
//   prismatic.box.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(prismatic.box.color[1] / 255.0,prismatic.box.color[2] / 255.0,prismatic.box.color[3] / 255.0,prismatic.box.specularCoefficient);
//   prismatic.box.Extra = prismatic.box.extra;
//   prismatic.R[1,1] = cos(prismatic.frame_a.phi);
//   prismatic.R[1,2] = sin(prismatic.frame_a.phi);
//   prismatic.R[2,1] = -sin(prismatic.frame_a.phi);
//   prismatic.R[2,2] = cos(prismatic.frame_a.phi);
//   prismatic.e0[1] = prismatic.R[1,1] * prismatic.e[1] + prismatic.R[1,2] * prismatic.e[2];
//   prismatic.e0[2] = prismatic.R[2,1] * prismatic.e[1] + prismatic.R[2,2] * prismatic.e[2];
//   prismatic.r0[1] = prismatic.e0[1] * prismatic.s;
//   prismatic.r0[2] = prismatic.e0[2] * prismatic.s;
//   prismatic.v = der(prismatic.s);
//   prismatic.a = der(prismatic.v);
//   prismatic.f = 0.0;
//   prismatic.frame_a.x + prismatic.r0[1] = prismatic.frame_b.x;
//   prismatic.frame_a.y + prismatic.r0[2] = prismatic.frame_b.y;
//   prismatic.frame_a.phi = prismatic.frame_b.phi;
//   prismatic.frame_a.fx + prismatic.frame_b.fx = 0.0;
//   prismatic.frame_a.fy + prismatic.frame_b.fy = 0.0;
//   prismatic.frame_a.t + (prismatic.frame_b.t + ((-prismatic.r0[1]) * prismatic.frame_b.fy + prismatic.r0[2] * prismatic.frame_b.fx)) = 0.0;
//   prismatic.frame_a.fx * prismatic.e0[1] + prismatic.frame_a.fy * prismatic.e0[2] = 0.0;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   fixed.frame_a.x = fixed.r[1];
//   fixed.frame_a.y = fixed.r[2];
//   fixed.frame_a.phi = fixed.phi;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   slipBasedWheelJoint.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedWheelJoint.cylinder.shapeType);
//   slipBasedWheelJoint.cylinder.rxvisobj[1] = slipBasedWheelJoint.cylinder.R.T[1,1] * slipBasedWheelJoint.cylinder.e_x[1] + slipBasedWheelJoint.cylinder.R.T[2,1] * slipBasedWheelJoint.cylinder.e_x[2] + slipBasedWheelJoint.cylinder.R.T[3,1] * slipBasedWheelJoint.cylinder.e_x[3];
//   slipBasedWheelJoint.cylinder.rxvisobj[2] = slipBasedWheelJoint.cylinder.R.T[1,2] * slipBasedWheelJoint.cylinder.e_x[1] + slipBasedWheelJoint.cylinder.R.T[2,2] * slipBasedWheelJoint.cylinder.e_x[2] + slipBasedWheelJoint.cylinder.R.T[3,2] * slipBasedWheelJoint.cylinder.e_x[3];
//   slipBasedWheelJoint.cylinder.rxvisobj[3] = slipBasedWheelJoint.cylinder.R.T[1,3] * slipBasedWheelJoint.cylinder.e_x[1] + slipBasedWheelJoint.cylinder.R.T[2,3] * slipBasedWheelJoint.cylinder.e_x[2] + slipBasedWheelJoint.cylinder.R.T[3,3] * slipBasedWheelJoint.cylinder.e_x[3];
//   slipBasedWheelJoint.cylinder.ryvisobj[1] = slipBasedWheelJoint.cylinder.R.T[1,1] * slipBasedWheelJoint.cylinder.e_y[1] + slipBasedWheelJoint.cylinder.R.T[2,1] * slipBasedWheelJoint.cylinder.e_y[2] + slipBasedWheelJoint.cylinder.R.T[3,1] * slipBasedWheelJoint.cylinder.e_y[3];
//   slipBasedWheelJoint.cylinder.ryvisobj[2] = slipBasedWheelJoint.cylinder.R.T[1,2] * slipBasedWheelJoint.cylinder.e_y[1] + slipBasedWheelJoint.cylinder.R.T[2,2] * slipBasedWheelJoint.cylinder.e_y[2] + slipBasedWheelJoint.cylinder.R.T[3,2] * slipBasedWheelJoint.cylinder.e_y[3];
//   slipBasedWheelJoint.cylinder.ryvisobj[3] = slipBasedWheelJoint.cylinder.R.T[1,3] * slipBasedWheelJoint.cylinder.e_y[1] + slipBasedWheelJoint.cylinder.R.T[2,3] * slipBasedWheelJoint.cylinder.e_y[2] + slipBasedWheelJoint.cylinder.R.T[3,3] * slipBasedWheelJoint.cylinder.e_y[3];
//   slipBasedWheelJoint.cylinder.rvisobj = slipBasedWheelJoint.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedWheelJoint.cylinder.R.T[1,1],slipBasedWheelJoint.cylinder.R.T[1,2],slipBasedWheelJoint.cylinder.R.T[1,3]},{slipBasedWheelJoint.cylinder.R.T[2,1],slipBasedWheelJoint.cylinder.R.T[2,2],slipBasedWheelJoint.cylinder.R.T[2,3]},{slipBasedWheelJoint.cylinder.R.T[3,1],slipBasedWheelJoint.cylinder.R.T[3,2],slipBasedWheelJoint.cylinder.R.T[3,3]}},{slipBasedWheelJoint.cylinder.r_shape[1],slipBasedWheelJoint.cylinder.r_shape[2],slipBasedWheelJoint.cylinder.r_shape[3]});
//   slipBasedWheelJoint.cylinder.size[1] = slipBasedWheelJoint.cylinder.length;
//   slipBasedWheelJoint.cylinder.size[2] = slipBasedWheelJoint.cylinder.width;
//   slipBasedWheelJoint.cylinder.size[3] = slipBasedWheelJoint.cylinder.height;
//   slipBasedWheelJoint.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedWheelJoint.cylinder.color[1] / 255.0,slipBasedWheelJoint.cylinder.color[2] / 255.0,slipBasedWheelJoint.cylinder.color[3] / 255.0,slipBasedWheelJoint.cylinder.specularCoefficient);
//   slipBasedWheelJoint.cylinder.Extra = slipBasedWheelJoint.cylinder.extra;
//   slipBasedWheelJoint.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-slipBasedWheelJoint.e0[2],slipBasedWheelJoint.e0[1],0.0},slipBasedWheelJoint.flange_a.phi,0.0);
//   slipBasedWheelJoint.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedWheelJoint.rim1.shapeType);
//   slipBasedWheelJoint.rim1.rxvisobj[1] = slipBasedWheelJoint.rim1.R.T[1,1] * slipBasedWheelJoint.rim1.e_x[1] + slipBasedWheelJoint.rim1.R.T[2,1] * slipBasedWheelJoint.rim1.e_x[2] + slipBasedWheelJoint.rim1.R.T[3,1] * slipBasedWheelJoint.rim1.e_x[3];
//   slipBasedWheelJoint.rim1.rxvisobj[2] = slipBasedWheelJoint.rim1.R.T[1,2] * slipBasedWheelJoint.rim1.e_x[1] + slipBasedWheelJoint.rim1.R.T[2,2] * slipBasedWheelJoint.rim1.e_x[2] + slipBasedWheelJoint.rim1.R.T[3,2] * slipBasedWheelJoint.rim1.e_x[3];
//   slipBasedWheelJoint.rim1.rxvisobj[3] = slipBasedWheelJoint.rim1.R.T[1,3] * slipBasedWheelJoint.rim1.e_x[1] + slipBasedWheelJoint.rim1.R.T[2,3] * slipBasedWheelJoint.rim1.e_x[2] + slipBasedWheelJoint.rim1.R.T[3,3] * slipBasedWheelJoint.rim1.e_x[3];
//   slipBasedWheelJoint.rim1.ryvisobj[1] = slipBasedWheelJoint.rim1.R.T[1,1] * slipBasedWheelJoint.rim1.e_y[1] + slipBasedWheelJoint.rim1.R.T[2,1] * slipBasedWheelJoint.rim1.e_y[2] + slipBasedWheelJoint.rim1.R.T[3,1] * slipBasedWheelJoint.rim1.e_y[3];
//   slipBasedWheelJoint.rim1.ryvisobj[2] = slipBasedWheelJoint.rim1.R.T[1,2] * slipBasedWheelJoint.rim1.e_y[1] + slipBasedWheelJoint.rim1.R.T[2,2] * slipBasedWheelJoint.rim1.e_y[2] + slipBasedWheelJoint.rim1.R.T[3,2] * slipBasedWheelJoint.rim1.e_y[3];
//   slipBasedWheelJoint.rim1.ryvisobj[3] = slipBasedWheelJoint.rim1.R.T[1,3] * slipBasedWheelJoint.rim1.e_y[1] + slipBasedWheelJoint.rim1.R.T[2,3] * slipBasedWheelJoint.rim1.e_y[2] + slipBasedWheelJoint.rim1.R.T[3,3] * slipBasedWheelJoint.rim1.e_y[3];
//   slipBasedWheelJoint.rim1.rvisobj = slipBasedWheelJoint.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedWheelJoint.rim1.R.T[1,1],slipBasedWheelJoint.rim1.R.T[1,2],slipBasedWheelJoint.rim1.R.T[1,3]},{slipBasedWheelJoint.rim1.R.T[2,1],slipBasedWheelJoint.rim1.R.T[2,2],slipBasedWheelJoint.rim1.R.T[2,3]},{slipBasedWheelJoint.rim1.R.T[3,1],slipBasedWheelJoint.rim1.R.T[3,2],slipBasedWheelJoint.rim1.R.T[3,3]}},{slipBasedWheelJoint.rim1.r_shape[1],slipBasedWheelJoint.rim1.r_shape[2],slipBasedWheelJoint.rim1.r_shape[3]});
//   slipBasedWheelJoint.rim1.size[1] = slipBasedWheelJoint.rim1.length;
//   slipBasedWheelJoint.rim1.size[2] = slipBasedWheelJoint.rim1.width;
//   slipBasedWheelJoint.rim1.size[3] = slipBasedWheelJoint.rim1.height;
//   slipBasedWheelJoint.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedWheelJoint.rim1.color[1] / 255.0,slipBasedWheelJoint.rim1.color[2] / 255.0,slipBasedWheelJoint.rim1.color[3] / 255.0,slipBasedWheelJoint.rim1.specularCoefficient);
//   slipBasedWheelJoint.rim1.Extra = slipBasedWheelJoint.rim1.extra;
//   slipBasedWheelJoint.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-slipBasedWheelJoint.e0[2],slipBasedWheelJoint.e0[1],0.0},1.5707963267948966 + slipBasedWheelJoint.flange_a.phi,0.0);
//   slipBasedWheelJoint.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(slipBasedWheelJoint.rim2.shapeType);
//   slipBasedWheelJoint.rim2.rxvisobj[1] = slipBasedWheelJoint.rim2.R.T[1,1] * slipBasedWheelJoint.rim2.e_x[1] + slipBasedWheelJoint.rim2.R.T[2,1] * slipBasedWheelJoint.rim2.e_x[2] + slipBasedWheelJoint.rim2.R.T[3,1] * slipBasedWheelJoint.rim2.e_x[3];
//   slipBasedWheelJoint.rim2.rxvisobj[2] = slipBasedWheelJoint.rim2.R.T[1,2] * slipBasedWheelJoint.rim2.e_x[1] + slipBasedWheelJoint.rim2.R.T[2,2] * slipBasedWheelJoint.rim2.e_x[2] + slipBasedWheelJoint.rim2.R.T[3,2] * slipBasedWheelJoint.rim2.e_x[3];
//   slipBasedWheelJoint.rim2.rxvisobj[3] = slipBasedWheelJoint.rim2.R.T[1,3] * slipBasedWheelJoint.rim2.e_x[1] + slipBasedWheelJoint.rim2.R.T[2,3] * slipBasedWheelJoint.rim2.e_x[2] + slipBasedWheelJoint.rim2.R.T[3,3] * slipBasedWheelJoint.rim2.e_x[3];
//   slipBasedWheelJoint.rim2.ryvisobj[1] = slipBasedWheelJoint.rim2.R.T[1,1] * slipBasedWheelJoint.rim2.e_y[1] + slipBasedWheelJoint.rim2.R.T[2,1] * slipBasedWheelJoint.rim2.e_y[2] + slipBasedWheelJoint.rim2.R.T[3,1] * slipBasedWheelJoint.rim2.e_y[3];
//   slipBasedWheelJoint.rim2.ryvisobj[2] = slipBasedWheelJoint.rim2.R.T[1,2] * slipBasedWheelJoint.rim2.e_y[1] + slipBasedWheelJoint.rim2.R.T[2,2] * slipBasedWheelJoint.rim2.e_y[2] + slipBasedWheelJoint.rim2.R.T[3,2] * slipBasedWheelJoint.rim2.e_y[3];
//   slipBasedWheelJoint.rim2.ryvisobj[3] = slipBasedWheelJoint.rim2.R.T[1,3] * slipBasedWheelJoint.rim2.e_y[1] + slipBasedWheelJoint.rim2.R.T[2,3] * slipBasedWheelJoint.rim2.e_y[2] + slipBasedWheelJoint.rim2.R.T[3,3] * slipBasedWheelJoint.rim2.e_y[3];
//   slipBasedWheelJoint.rim2.rvisobj = slipBasedWheelJoint.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{slipBasedWheelJoint.rim2.R.T[1,1],slipBasedWheelJoint.rim2.R.T[1,2],slipBasedWheelJoint.rim2.R.T[1,3]},{slipBasedWheelJoint.rim2.R.T[2,1],slipBasedWheelJoint.rim2.R.T[2,2],slipBasedWheelJoint.rim2.R.T[2,3]},{slipBasedWheelJoint.rim2.R.T[3,1],slipBasedWheelJoint.rim2.R.T[3,2],slipBasedWheelJoint.rim2.R.T[3,3]}},{slipBasedWheelJoint.rim2.r_shape[1],slipBasedWheelJoint.rim2.r_shape[2],slipBasedWheelJoint.rim2.r_shape[3]});
//   slipBasedWheelJoint.rim2.size[1] = slipBasedWheelJoint.rim2.length;
//   slipBasedWheelJoint.rim2.size[2] = slipBasedWheelJoint.rim2.width;
//   slipBasedWheelJoint.rim2.size[3] = slipBasedWheelJoint.rim2.height;
//   slipBasedWheelJoint.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(slipBasedWheelJoint.rim2.color[1] / 255.0,slipBasedWheelJoint.rim2.color[2] / 255.0,slipBasedWheelJoint.rim2.color[3] / 255.0,slipBasedWheelJoint.rim2.specularCoefficient);
//   slipBasedWheelJoint.rim2.Extra = slipBasedWheelJoint.rim2.extra;
//   slipBasedWheelJoint.R[1,1] = cos(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.R[1,2] = sin(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.R[2,1] = -sin(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.R[2,2] = cos(slipBasedWheelJoint.frame_a.phi);
//   slipBasedWheelJoint.e0[1] = slipBasedWheelJoint.R[1,1] * slipBasedWheelJoint.e[1] + slipBasedWheelJoint.R[1,2] * slipBasedWheelJoint.e[2];
//   slipBasedWheelJoint.e0[2] = slipBasedWheelJoint.R[2,1] * slipBasedWheelJoint.e[1] + slipBasedWheelJoint.R[2,2] * slipBasedWheelJoint.e[2];
//   slipBasedWheelJoint.v[1] = der(slipBasedWheelJoint.frame_a.x);
//   slipBasedWheelJoint.v[2] = der(slipBasedWheelJoint.frame_a.y);
//   slipBasedWheelJoint.w_roll = der(slipBasedWheelJoint.flange_a.phi);
//   slipBasedWheelJoint.v_long = slipBasedWheelJoint.v[1] * slipBasedWheelJoint.e0[1] + slipBasedWheelJoint.v[2] * slipBasedWheelJoint.e0[2];
//   slipBasedWheelJoint.v_lat = (-slipBasedWheelJoint.v[1]) * slipBasedWheelJoint.e0[2] + slipBasedWheelJoint.v[2] * slipBasedWheelJoint.e0[1];
//   slipBasedWheelJoint.v_slip_lat = slipBasedWheelJoint.v_lat;
//   slipBasedWheelJoint.v_slip_long = slipBasedWheelJoint.v_long - slipBasedWheelJoint.radius * slipBasedWheelJoint.w_roll;
//   slipBasedWheelJoint.v_slip = 0.0001 + sqrt(slipBasedWheelJoint.v_slip_long ^ 2.0 + slipBasedWheelJoint.v_slip_lat ^ 2.0);
//   (-slipBasedWheelJoint.f_long) * slipBasedWheelJoint.radius = slipBasedWheelJoint.flange_a.tau;
//   slipBasedWheelJoint.frame_a.t = 0.0;
//   slipBasedWheelJoint.vAdhesion = max(slipBasedWheelJoint.sAdhesion * abs(slipBasedWheelJoint.radius * slipBasedWheelJoint.w_roll),slipBasedWheelJoint.vAdhesion_min);
//   slipBasedWheelJoint.vSlide = max(slipBasedWheelJoint.sSlide * abs(slipBasedWheelJoint.radius * slipBasedWheelJoint.w_roll),slipBasedWheelJoint.vSlide_min);
//   slipBasedWheelJoint.fN = max(0.0,slipBasedWheelJoint.N + slipBasedWheelJoint.dynamicLoad);
//   slipBasedWheelJoint.f = slipBasedWheelJoint.fN * PlanarMechanicsForTesting.Utilities.TripleS_Func(slipBasedWheelJoint.vAdhesion,slipBasedWheelJoint.vSlide,slipBasedWheelJoint.mu_A,slipBasedWheelJoint.mu_S,slipBasedWheelJoint.v_slip);
//   slipBasedWheelJoint.f_long = (slipBasedWheelJoint.f * slipBasedWheelJoint.v_slip_long) / slipBasedWheelJoint.v_slip;
//   slipBasedWheelJoint.f_lat = (slipBasedWheelJoint.f * slipBasedWheelJoint.v_slip_lat) / slipBasedWheelJoint.v_slip;
//   slipBasedWheelJoint.f_long = slipBasedWheelJoint.frame_a.fx * slipBasedWheelJoint.e0[1] + slipBasedWheelJoint.frame_a.fy * slipBasedWheelJoint.e0[2];
//   slipBasedWheelJoint.f_lat = slipBasedWheelJoint.frame_a.fy * slipBasedWheelJoint.e0[1] + (-slipBasedWheelJoint.frame_a.fx) * slipBasedWheelJoint.e0[2];
//   const.y = const.k;
//   prismatic.frame_a.t + revolute.frame_b.t = 0.0;
//   prismatic.frame_a.fy + revolute.frame_b.fy = 0.0;
//   prismatic.frame_a.fx + revolute.frame_b.fx = 0.0;
//   prismatic.frame_b.t + body.frame_a.t + slipBasedWheelJoint.frame_a.t = 0.0;
//   prismatic.frame_b.fy + body.frame_a.fy + slipBasedWheelJoint.frame_a.fy = 0.0;
//   prismatic.frame_b.fx + body.frame_a.fx + slipBasedWheelJoint.frame_a.fx = 0.0;
//   revolute.frame_a.t + fixed.frame_a.t = 0.0;
//   revolute.frame_a.fy + fixed.frame_a.fy = 0.0;
//   revolute.frame_a.fx + fixed.frame_a.fx = 0.0;
//   engineTorque.flange.tau + inertia.flange_a.tau = 0.0;
//   inertia.flange_b.tau + slipBasedWheelJoint.flange_a.tau = 0.0;
//   prismatic.frame_a.x = revolute.frame_b.x;
//   prismatic.frame_a.y = revolute.frame_b.y;
//   prismatic.frame_a.phi = revolute.frame_b.phi;
//   fixed.frame_a.x = revolute.frame_a.x;
//   fixed.frame_a.y = revolute.frame_a.y;
//   fixed.frame_a.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = inertia.flange_a.phi;
//   body.frame_a.x = prismatic.frame_b.x;
//   body.frame_a.x = slipBasedWheelJoint.frame_a.x;
//   body.frame_a.y = prismatic.frame_b.y;
//   body.frame_a.y = slipBasedWheelJoint.frame_a.y;
//   body.frame_a.phi = prismatic.frame_b.phi;
//   body.frame_a.phi = slipBasedWheelJoint.frame_a.phi;
//   inertia.flange_b.phi = slipBasedWheelJoint.flange_a.phi;
//   const.y = slipBasedWheelJoint.dynamicLoad;
// end PlanarMechanicsForTesting.Examples.TestSlipBasedWheel;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class PlanarMechanicsForTesting.Examples.SingleTrackWithEngine
//   Real bodyFront.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyFront.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyFront.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyFront.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyFront.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyFront.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyFront.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 2.0 \"mass of the body\";
//   parameter Real bodyFront.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyFront.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyFront.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real bodyFront.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyFront.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyFront.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyFront.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyFront.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyFront.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyFront.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyFront.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyFront.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyFront.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyFront.animate = true \"enable Animation\";
//   parameter String bodyFront.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyFront.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyFront.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyFront.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyFront.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyFront.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyFront.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyFront.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyFront.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyFront.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyFront.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyFront.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyFront.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyFront.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyFront.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyFront.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyFront.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyFront.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyFront.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyFront.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyFront.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyFront.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyFront.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyFront.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyFront.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyFront.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyFront.sphere.lengthDirection[1],bodyFront.sphere.lengthDirection[2],bodyFront.sphere.lengthDirection[3]});
//   protected Real bodyFront.sphere.e_x[1](unit = \"1\") = if noEvent(bodyFront.sphere.abs_n_x < 0.0000000001) then 1.0 else bodyFront.sphere.lengthDirection[1] / bodyFront.sphere.abs_n_x;
//   protected Real bodyFront.sphere.e_x[2](unit = \"1\") = if noEvent(bodyFront.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyFront.sphere.lengthDirection[2] / bodyFront.sphere.abs_n_x;
//   protected Real bodyFront.sphere.e_x[3](unit = \"1\") = if noEvent(bodyFront.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyFront.sphere.lengthDirection[3] / bodyFront.sphere.abs_n_x;
//   protected Real bodyFront.sphere.n_z_aux[1](unit = \"1\") = bodyFront.sphere.e_x[2] * bodyFront.sphere.widthDirection[3] - bodyFront.sphere.e_x[3] * bodyFront.sphere.widthDirection[2];
//   protected Real bodyFront.sphere.n_z_aux[2](unit = \"1\") = bodyFront.sphere.e_x[3] * bodyFront.sphere.widthDirection[1] - bodyFront.sphere.e_x[1] * bodyFront.sphere.widthDirection[3];
//   protected Real bodyFront.sphere.n_z_aux[3](unit = \"1\") = bodyFront.sphere.e_x[1] * bodyFront.sphere.widthDirection[2] - bodyFront.sphere.e_x[2] * bodyFront.sphere.widthDirection[1];
//   protected Real bodyFront.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]},if noEvent(bodyFront.sphere.n_z_aux[1] ^ 2.0 + (bodyFront.sphere.n_z_aux[2] ^ 2.0 + bodyFront.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyFront.sphere.widthDirection[1],bodyFront.sphere.widthDirection[2],bodyFront.sphere.widthDirection[3]} else if noEvent(abs(bodyFront.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]})[1];
//   protected Real bodyFront.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]},if noEvent(bodyFront.sphere.n_z_aux[1] ^ 2.0 + (bodyFront.sphere.n_z_aux[2] ^ 2.0 + bodyFront.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyFront.sphere.widthDirection[1],bodyFront.sphere.widthDirection[2],bodyFront.sphere.widthDirection[3]} else if noEvent(abs(bodyFront.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]})[2];
//   protected Real bodyFront.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]},if noEvent(bodyFront.sphere.n_z_aux[1] ^ 2.0 + (bodyFront.sphere.n_z_aux[2] ^ 2.0 + bodyFront.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyFront.sphere.widthDirection[1],bodyFront.sphere.widthDirection[2],bodyFront.sphere.widthDirection[3]} else if noEvent(abs(bodyFront.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyFront.sphere.e_x[1],bodyFront.sphere.e_x[2],bodyFront.sphere.e_x[3]})[3];
//   protected output Real bodyFront.sphere.Form;
//   output Real bodyFront.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyFront.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyFront.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyFront.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyFront.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyFront.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyFront.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyFront.sphere.Material;
//   protected output Real bodyFront.sphere.Extra;
//   Real idealWheelFront.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelFront.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelFront.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelFront.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelFront.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelFront.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelFront.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelFront.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelFront.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real idealWheelFront.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelFront.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelFront.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelFront.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelFront.R[1,1] \"Rotation Matrix\";
//   Real idealWheelFront.R[1,2] \"Rotation Matrix\";
//   Real idealWheelFront.R[2,1] \"Rotation Matrix\";
//   Real idealWheelFront.R[2,2] \"Rotation Matrix\";
//   Real idealWheelFront.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelFront.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelFront.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelFront.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelFront.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelFront.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelFront.animate = true \"enable Animation\";
//   parameter Boolean idealWheelFront.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelFront.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelFront.r[1] ^ 2.0 + idealWheelFront.r[2] ^ 2.0);
//   final parameter Real idealWheelFront.e[1] = idealWheelFront.r[1] / idealWheelFront.l \"normalized direction\";
//   final parameter Real idealWheelFront.e[2] = idealWheelFront.r[2] / idealWheelFront.l \"normalized direction\";
//   parameter String idealWheelFront.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelFront.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-idealWheelFront.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelFront.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.lengthDirection[2](unit = \"1\") = idealWheelFront.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelFront.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Width of visual object\";
//   input Real idealWheelFront.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Height of visual object\";
//   input Real idealWheelFront.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelFront.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelFront.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelFront.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelFront.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelFront.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelFront.cylinder.lengthDirection[1],idealWheelFront.cylinder.lengthDirection[2],idealWheelFront.cylinder.lengthDirection[3]});
//   protected Real idealWheelFront.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelFront.cylinder.abs_n_x < 0.0000000001) then 1.0 else idealWheelFront.cylinder.lengthDirection[1] / idealWheelFront.cylinder.abs_n_x;
//   protected Real idealWheelFront.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelFront.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealWheelFront.cylinder.lengthDirection[2] / idealWheelFront.cylinder.abs_n_x;
//   protected Real idealWheelFront.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelFront.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealWheelFront.cylinder.lengthDirection[3] / idealWheelFront.cylinder.abs_n_x;
//   protected Real idealWheelFront.cylinder.n_z_aux[1](unit = \"1\") = idealWheelFront.cylinder.e_x[2] * idealWheelFront.cylinder.widthDirection[3] - idealWheelFront.cylinder.e_x[3] * idealWheelFront.cylinder.widthDirection[2];
//   protected Real idealWheelFront.cylinder.n_z_aux[2](unit = \"1\") = idealWheelFront.cylinder.e_x[3] * idealWheelFront.cylinder.widthDirection[1] - idealWheelFront.cylinder.e_x[1] * idealWheelFront.cylinder.widthDirection[3];
//   protected Real idealWheelFront.cylinder.n_z_aux[3](unit = \"1\") = idealWheelFront.cylinder.e_x[1] * idealWheelFront.cylinder.widthDirection[2] - idealWheelFront.cylinder.e_x[2] * idealWheelFront.cylinder.widthDirection[1];
//   protected Real idealWheelFront.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]},if noEvent(idealWheelFront.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelFront.cylinder.n_z_aux[2] ^ 2.0 + idealWheelFront.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.cylinder.widthDirection[1],idealWheelFront.cylinder.widthDirection[2],idealWheelFront.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelFront.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]})[1];
//   protected Real idealWheelFront.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]},if noEvent(idealWheelFront.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelFront.cylinder.n_z_aux[2] ^ 2.0 + idealWheelFront.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.cylinder.widthDirection[1],idealWheelFront.cylinder.widthDirection[2],idealWheelFront.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelFront.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]})[2];
//   protected Real idealWheelFront.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]},if noEvent(idealWheelFront.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelFront.cylinder.n_z_aux[2] ^ 2.0 + idealWheelFront.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.cylinder.widthDirection[1],idealWheelFront.cylinder.widthDirection[2],idealWheelFront.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelFront.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.cylinder.e_x[1],idealWheelFront.cylinder.e_x[2],idealWheelFront.cylinder.e_x[3]})[3];
//   protected output Real idealWheelFront.cylinder.Form;
//   output Real idealWheelFront.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelFront.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.cylinder.Material;
//   protected output Real idealWheelFront.cylinder.Extra;
//   parameter String idealWheelFront.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelFront.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelFront.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Length of visual object\";
//   input Real idealWheelFront.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelFront.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelFront.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelFront.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelFront.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelFront.rim1.lengthDirection[1],idealWheelFront.rim1.lengthDirection[2],idealWheelFront.rim1.lengthDirection[3]});
//   protected Real idealWheelFront.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelFront.rim1.abs_n_x < 0.0000000001) then 1.0 else idealWheelFront.rim1.lengthDirection[1] / idealWheelFront.rim1.abs_n_x;
//   protected Real idealWheelFront.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelFront.rim1.abs_n_x < 0.0000000001) then 0.0 else idealWheelFront.rim1.lengthDirection[2] / idealWheelFront.rim1.abs_n_x;
//   protected Real idealWheelFront.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelFront.rim1.abs_n_x < 0.0000000001) then 0.0 else idealWheelFront.rim1.lengthDirection[3] / idealWheelFront.rim1.abs_n_x;
//   protected Real idealWheelFront.rim1.n_z_aux[1](unit = \"1\") = idealWheelFront.rim1.e_x[2] * idealWheelFront.rim1.widthDirection[3] - idealWheelFront.rim1.e_x[3] * idealWheelFront.rim1.widthDirection[2];
//   protected Real idealWheelFront.rim1.n_z_aux[2](unit = \"1\") = idealWheelFront.rim1.e_x[3] * idealWheelFront.rim1.widthDirection[1] - idealWheelFront.rim1.e_x[1] * idealWheelFront.rim1.widthDirection[3];
//   protected Real idealWheelFront.rim1.n_z_aux[3](unit = \"1\") = idealWheelFront.rim1.e_x[1] * idealWheelFront.rim1.widthDirection[2] - idealWheelFront.rim1.e_x[2] * idealWheelFront.rim1.widthDirection[1];
//   protected Real idealWheelFront.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]},if noEvent(idealWheelFront.rim1.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim1.n_z_aux[2] ^ 2.0 + idealWheelFront.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.rim1.widthDirection[1],idealWheelFront.rim1.widthDirection[2],idealWheelFront.rim1.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]})[1];
//   protected Real idealWheelFront.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]},if noEvent(idealWheelFront.rim1.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim1.n_z_aux[2] ^ 2.0 + idealWheelFront.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.rim1.widthDirection[1],idealWheelFront.rim1.widthDirection[2],idealWheelFront.rim1.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]})[2];
//   protected Real idealWheelFront.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]},if noEvent(idealWheelFront.rim1.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim1.n_z_aux[2] ^ 2.0 + idealWheelFront.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.rim1.widthDirection[1],idealWheelFront.rim1.widthDirection[2],idealWheelFront.rim1.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.rim1.e_x[1],idealWheelFront.rim1.e_x[2],idealWheelFront.rim1.e_x[3]})[3];
//   protected output Real idealWheelFront.rim1.Form;
//   output Real idealWheelFront.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelFront.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim1.Material;
//   protected output Real idealWheelFront.rim1.Extra;
//   parameter String idealWheelFront.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelFront.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelFront.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelFront.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelFront.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelFront.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelFront.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelFront.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelFront.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelFront.radius \"Length of visual object\";
//   input Real idealWheelFront.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelFront.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelFront.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelFront.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelFront.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelFront.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelFront.rim2.lengthDirection[1],idealWheelFront.rim2.lengthDirection[2],idealWheelFront.rim2.lengthDirection[3]});
//   protected Real idealWheelFront.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelFront.rim2.abs_n_x < 0.0000000001) then 1.0 else idealWheelFront.rim2.lengthDirection[1] / idealWheelFront.rim2.abs_n_x;
//   protected Real idealWheelFront.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelFront.rim2.abs_n_x < 0.0000000001) then 0.0 else idealWheelFront.rim2.lengthDirection[2] / idealWheelFront.rim2.abs_n_x;
//   protected Real idealWheelFront.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelFront.rim2.abs_n_x < 0.0000000001) then 0.0 else idealWheelFront.rim2.lengthDirection[3] / idealWheelFront.rim2.abs_n_x;
//   protected Real idealWheelFront.rim2.n_z_aux[1](unit = \"1\") = idealWheelFront.rim2.e_x[2] * idealWheelFront.rim2.widthDirection[3] - idealWheelFront.rim2.e_x[3] * idealWheelFront.rim2.widthDirection[2];
//   protected Real idealWheelFront.rim2.n_z_aux[2](unit = \"1\") = idealWheelFront.rim2.e_x[3] * idealWheelFront.rim2.widthDirection[1] - idealWheelFront.rim2.e_x[1] * idealWheelFront.rim2.widthDirection[3];
//   protected Real idealWheelFront.rim2.n_z_aux[3](unit = \"1\") = idealWheelFront.rim2.e_x[1] * idealWheelFront.rim2.widthDirection[2] - idealWheelFront.rim2.e_x[2] * idealWheelFront.rim2.widthDirection[1];
//   protected Real idealWheelFront.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]},if noEvent(idealWheelFront.rim2.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim2.n_z_aux[2] ^ 2.0 + idealWheelFront.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.rim2.widthDirection[1],idealWheelFront.rim2.widthDirection[2],idealWheelFront.rim2.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]})[1];
//   protected Real idealWheelFront.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]},if noEvent(idealWheelFront.rim2.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim2.n_z_aux[2] ^ 2.0 + idealWheelFront.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.rim2.widthDirection[1],idealWheelFront.rim2.widthDirection[2],idealWheelFront.rim2.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]})[2];
//   protected Real idealWheelFront.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]},if noEvent(idealWheelFront.rim2.n_z_aux[1] ^ 2.0 + (idealWheelFront.rim2.n_z_aux[2] ^ 2.0 + idealWheelFront.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelFront.rim2.widthDirection[1],idealWheelFront.rim2.widthDirection[2],idealWheelFront.rim2.widthDirection[3]} else if noEvent(abs(idealWheelFront.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelFront.rim2.e_x[1],idealWheelFront.rim2.e_x[2],idealWheelFront.rim2.e_x[3]})[3];
//   protected output Real idealWheelFront.rim2.Form;
//   output Real idealWheelFront.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelFront.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelFront.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelFront.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelFront.rim2.Material;
//   protected output Real idealWheelFront.rim2.Extra;
//   Real chassis.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real chassis.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real chassis.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real chassis.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real chassis.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real chassis.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real chassis.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real chassis.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real chassis.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real chassis.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real chassis.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real chassis.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real chassis.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real chassis.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real chassis.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real chassis.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real chassis.R[1,1] \"Rotation matrix\";
//   Real chassis.R[1,2] \"Rotation matrix\";
//   Real chassis.R[2,1] \"Rotation matrix\";
//   Real chassis.R[2,2] \"Rotation matrix\";
//   parameter Boolean chassis.animate = true \"enable Animation\";
//   final parameter Real chassis.l(quantity = \"Length\", unit = \"m\") = sqrt(chassis.r[1] ^ 2.0 + chassis.r[2] ^ 2.0);
//   parameter String chassis.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real chassis.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real chassis.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real chassis.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real chassis.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real chassis.cylinder.r[1](quantity = \"Length\", unit = \"m\") = chassis.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real chassis.cylinder.r[2](quantity = \"Length\", unit = \"m\") = chassis.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real chassis.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real chassis.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real chassis.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real chassis.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real chassis.cylinder.lengthDirection[1](unit = \"1\") = chassis.r0[1] / chassis.l \"Vector in length direction, resolved in object frame\";
//   input Real chassis.cylinder.lengthDirection[2](unit = \"1\") = chassis.r0[2] / chassis.l \"Vector in length direction, resolved in object frame\";
//   input Real chassis.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real chassis.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real chassis.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real chassis.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real chassis.cylinder.length(quantity = \"Length\", unit = \"m\") = chassis.l \"Length of visual object\";
//   input Real chassis.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real chassis.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real chassis.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real chassis.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real chassis.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real chassis.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real chassis.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real chassis.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({chassis.cylinder.lengthDirection[1],chassis.cylinder.lengthDirection[2],chassis.cylinder.lengthDirection[3]});
//   protected Real chassis.cylinder.e_x[1](unit = \"1\") = if noEvent(chassis.cylinder.abs_n_x < 0.0000000001) then 1.0 else chassis.cylinder.lengthDirection[1] / chassis.cylinder.abs_n_x;
//   protected Real chassis.cylinder.e_x[2](unit = \"1\") = if noEvent(chassis.cylinder.abs_n_x < 0.0000000001) then 0.0 else chassis.cylinder.lengthDirection[2] / chassis.cylinder.abs_n_x;
//   protected Real chassis.cylinder.e_x[3](unit = \"1\") = if noEvent(chassis.cylinder.abs_n_x < 0.0000000001) then 0.0 else chassis.cylinder.lengthDirection[3] / chassis.cylinder.abs_n_x;
//   protected Real chassis.cylinder.n_z_aux[1](unit = \"1\") = chassis.cylinder.e_x[2] * chassis.cylinder.widthDirection[3] - chassis.cylinder.e_x[3] * chassis.cylinder.widthDirection[2];
//   protected Real chassis.cylinder.n_z_aux[2](unit = \"1\") = chassis.cylinder.e_x[3] * chassis.cylinder.widthDirection[1] - chassis.cylinder.e_x[1] * chassis.cylinder.widthDirection[3];
//   protected Real chassis.cylinder.n_z_aux[3](unit = \"1\") = chassis.cylinder.e_x[1] * chassis.cylinder.widthDirection[2] - chassis.cylinder.e_x[2] * chassis.cylinder.widthDirection[1];
//   protected Real chassis.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]},if noEvent(chassis.cylinder.n_z_aux[1] ^ 2.0 + (chassis.cylinder.n_z_aux[2] ^ 2.0 + chassis.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {chassis.cylinder.widthDirection[1],chassis.cylinder.widthDirection[2],chassis.cylinder.widthDirection[3]} else if noEvent(abs(chassis.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]})[1];
//   protected Real chassis.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]},if noEvent(chassis.cylinder.n_z_aux[1] ^ 2.0 + (chassis.cylinder.n_z_aux[2] ^ 2.0 + chassis.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {chassis.cylinder.widthDirection[1],chassis.cylinder.widthDirection[2],chassis.cylinder.widthDirection[3]} else if noEvent(abs(chassis.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]})[2];
//   protected Real chassis.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]},if noEvent(chassis.cylinder.n_z_aux[1] ^ 2.0 + (chassis.cylinder.n_z_aux[2] ^ 2.0 + chassis.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {chassis.cylinder.widthDirection[1],chassis.cylinder.widthDirection[2],chassis.cylinder.widthDirection[3]} else if noEvent(abs(chassis.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{chassis.cylinder.e_x[1],chassis.cylinder.e_x[2],chassis.cylinder.e_x[3]})[3];
//   protected output Real chassis.cylinder.Form;
//   output Real chassis.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real chassis.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real chassis.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real chassis.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real chassis.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real chassis.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real chassis.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real chassis.cylinder.Material;
//   protected output Real chassis.cylinder.Extra;
//   Real bodyRear.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real bodyRear.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real bodyRear.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real bodyRear.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real bodyRear.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real bodyRear.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real bodyRear.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 10.0 \"mass of the body\";
//   parameter Real bodyRear.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real bodyRear.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real bodyRear.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real bodyRear.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyRear.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real bodyRear.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyRear.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real bodyRear.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyRear.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real bodyRear.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyRear.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real bodyRear.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real bodyRear.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean bodyRear.animate = true \"enable Animation\";
//   parameter String bodyRear.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real bodyRear.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real bodyRear.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyRear.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyRear.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real bodyRear.sphere.r[1](quantity = \"Length\", unit = \"m\") = bodyRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyRear.sphere.r[2](quantity = \"Length\", unit = \"m\") = bodyRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyRear.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real bodyRear.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyRear.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyRear.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real bodyRear.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyRear.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyRear.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real bodyRear.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyRear.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyRear.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real bodyRear.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real bodyRear.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real bodyRear.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real bodyRear.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real bodyRear.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real bodyRear.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real bodyRear.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real bodyRear.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real bodyRear.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({bodyRear.sphere.lengthDirection[1],bodyRear.sphere.lengthDirection[2],bodyRear.sphere.lengthDirection[3]});
//   protected Real bodyRear.sphere.e_x[1](unit = \"1\") = if noEvent(bodyRear.sphere.abs_n_x < 0.0000000001) then 1.0 else bodyRear.sphere.lengthDirection[1] / bodyRear.sphere.abs_n_x;
//   protected Real bodyRear.sphere.e_x[2](unit = \"1\") = if noEvent(bodyRear.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyRear.sphere.lengthDirection[2] / bodyRear.sphere.abs_n_x;
//   protected Real bodyRear.sphere.e_x[3](unit = \"1\") = if noEvent(bodyRear.sphere.abs_n_x < 0.0000000001) then 0.0 else bodyRear.sphere.lengthDirection[3] / bodyRear.sphere.abs_n_x;
//   protected Real bodyRear.sphere.n_z_aux[1](unit = \"1\") = bodyRear.sphere.e_x[2] * bodyRear.sphere.widthDirection[3] - bodyRear.sphere.e_x[3] * bodyRear.sphere.widthDirection[2];
//   protected Real bodyRear.sphere.n_z_aux[2](unit = \"1\") = bodyRear.sphere.e_x[3] * bodyRear.sphere.widthDirection[1] - bodyRear.sphere.e_x[1] * bodyRear.sphere.widthDirection[3];
//   protected Real bodyRear.sphere.n_z_aux[3](unit = \"1\") = bodyRear.sphere.e_x[1] * bodyRear.sphere.widthDirection[2] - bodyRear.sphere.e_x[2] * bodyRear.sphere.widthDirection[1];
//   protected Real bodyRear.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]},if noEvent(bodyRear.sphere.n_z_aux[1] ^ 2.0 + (bodyRear.sphere.n_z_aux[2] ^ 2.0 + bodyRear.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyRear.sphere.widthDirection[1],bodyRear.sphere.widthDirection[2],bodyRear.sphere.widthDirection[3]} else if noEvent(abs(bodyRear.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]})[1];
//   protected Real bodyRear.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]},if noEvent(bodyRear.sphere.n_z_aux[1] ^ 2.0 + (bodyRear.sphere.n_z_aux[2] ^ 2.0 + bodyRear.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyRear.sphere.widthDirection[1],bodyRear.sphere.widthDirection[2],bodyRear.sphere.widthDirection[3]} else if noEvent(abs(bodyRear.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]})[2];
//   protected Real bodyRear.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]},if noEvent(bodyRear.sphere.n_z_aux[1] ^ 2.0 + (bodyRear.sphere.n_z_aux[2] ^ 2.0 + bodyRear.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {bodyRear.sphere.widthDirection[1],bodyRear.sphere.widthDirection[2],bodyRear.sphere.widthDirection[3]} else if noEvent(abs(bodyRear.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{bodyRear.sphere.e_x[1],bodyRear.sphere.e_x[2],bodyRear.sphere.e_x[3]})[3];
//   protected output Real bodyRear.sphere.Form;
//   output Real bodyRear.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real bodyRear.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyRear.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real bodyRear.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real bodyRear.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyRear.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyRear.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real bodyRear.sphere.Material;
//   protected output Real bodyRear.sphere.Extra;
//   Real idealWheelRear.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real idealWheelRear.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real idealWheelRear.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real idealWheelRear.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real idealWheelRear.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real idealWheelRear.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real idealWheelRear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real idealWheelRear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real idealWheelRear.radius(quantity = \"Length\", unit = \"m\") = 0.3 \"radius of the wheel\";
//   parameter Real idealWheelRear.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real idealWheelRear.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   Real idealWheelRear.e0[1] \"normalized direction w.r.t inertial system\";
//   Real idealWheelRear.e0[2] \"normalized direction w.r.t inertial system\";
//   Real idealWheelRear.R[1,1] \"Rotation Matrix\";
//   Real idealWheelRear.R[1,2] \"Rotation Matrix\";
//   Real idealWheelRear.R[2,1] \"Rotation Matrix\";
//   Real idealWheelRear.R[2,2] \"Rotation Matrix\";
//   Real idealWheelRear.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real idealWheelRear.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelRear.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real idealWheelRear.v_long(quantity = \"Velocity\", unit = \"m/s\") \"driving velocity in (longitudinal) driving direction\";
//   Real idealWheelRear.a(quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration of driving velocity\";
//   Real idealWheelRear.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean idealWheelRear.animate = true \"enable Animation\";
//   parameter Boolean idealWheelRear.SimVis = false \"perform animation with SimVis\";
//   final parameter Real idealWheelRear.l(quantity = \"Length\", unit = \"m\") = sqrt(idealWheelRear.r[1] ^ 2.0 + idealWheelRear.r[2] ^ 2.0);
//   final parameter Real idealWheelRear.e[1] = idealWheelRear.r[1] / idealWheelRear.l \"normalized direction\";
//   final parameter Real idealWheelRear.e[2] = idealWheelRear.r[2] / idealWheelRear.l \"normalized direction\";
//   parameter String idealWheelRear.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelRear.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.cylinder.r[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.cylinder.r[2](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-idealWheelRear.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.cylinder.lengthDirection[1](unit = \"1\") = -idealWheelRear.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.lengthDirection[2](unit = \"1\") = idealWheelRear.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real idealWheelRear.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Width of visual object\";
//   input Real idealWheelRear.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Height of visual object\";
//   input Real idealWheelRear.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelRear.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real idealWheelRear.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real idealWheelRear.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real idealWheelRear.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelRear.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelRear.cylinder.lengthDirection[1],idealWheelRear.cylinder.lengthDirection[2],idealWheelRear.cylinder.lengthDirection[3]});
//   protected Real idealWheelRear.cylinder.e_x[1](unit = \"1\") = if noEvent(idealWheelRear.cylinder.abs_n_x < 0.0000000001) then 1.0 else idealWheelRear.cylinder.lengthDirection[1] / idealWheelRear.cylinder.abs_n_x;
//   protected Real idealWheelRear.cylinder.e_x[2](unit = \"1\") = if noEvent(idealWheelRear.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealWheelRear.cylinder.lengthDirection[2] / idealWheelRear.cylinder.abs_n_x;
//   protected Real idealWheelRear.cylinder.e_x[3](unit = \"1\") = if noEvent(idealWheelRear.cylinder.abs_n_x < 0.0000000001) then 0.0 else idealWheelRear.cylinder.lengthDirection[3] / idealWheelRear.cylinder.abs_n_x;
//   protected Real idealWheelRear.cylinder.n_z_aux[1](unit = \"1\") = idealWheelRear.cylinder.e_x[2] * idealWheelRear.cylinder.widthDirection[3] - idealWheelRear.cylinder.e_x[3] * idealWheelRear.cylinder.widthDirection[2];
//   protected Real idealWheelRear.cylinder.n_z_aux[2](unit = \"1\") = idealWheelRear.cylinder.e_x[3] * idealWheelRear.cylinder.widthDirection[1] - idealWheelRear.cylinder.e_x[1] * idealWheelRear.cylinder.widthDirection[3];
//   protected Real idealWheelRear.cylinder.n_z_aux[3](unit = \"1\") = idealWheelRear.cylinder.e_x[1] * idealWheelRear.cylinder.widthDirection[2] - idealWheelRear.cylinder.e_x[2] * idealWheelRear.cylinder.widthDirection[1];
//   protected Real idealWheelRear.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]},if noEvent(idealWheelRear.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelRear.cylinder.n_z_aux[2] ^ 2.0 + idealWheelRear.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.cylinder.widthDirection[1],idealWheelRear.cylinder.widthDirection[2],idealWheelRear.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelRear.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]})[1];
//   protected Real idealWheelRear.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]},if noEvent(idealWheelRear.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelRear.cylinder.n_z_aux[2] ^ 2.0 + idealWheelRear.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.cylinder.widthDirection[1],idealWheelRear.cylinder.widthDirection[2],idealWheelRear.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelRear.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]})[2];
//   protected Real idealWheelRear.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]},if noEvent(idealWheelRear.cylinder.n_z_aux[1] ^ 2.0 + (idealWheelRear.cylinder.n_z_aux[2] ^ 2.0 + idealWheelRear.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.cylinder.widthDirection[1],idealWheelRear.cylinder.widthDirection[2],idealWheelRear.cylinder.widthDirection[3]} else if noEvent(abs(idealWheelRear.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.cylinder.e_x[1],idealWheelRear.cylinder.e_x[2],idealWheelRear.cylinder.e_x[3]})[3];
//   protected output Real idealWheelRear.cylinder.Form;
//   output Real idealWheelRear.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelRear.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.cylinder.Material;
//   protected output Real idealWheelRear.cylinder.Extra;
//   parameter String idealWheelRear.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelRear.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim1.r[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim1.r[2](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelRear.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Length of visual object\";
//   input Real idealWheelRear.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelRear.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelRear.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelRear.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelRear.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelRear.rim1.lengthDirection[1],idealWheelRear.rim1.lengthDirection[2],idealWheelRear.rim1.lengthDirection[3]});
//   protected Real idealWheelRear.rim1.e_x[1](unit = \"1\") = if noEvent(idealWheelRear.rim1.abs_n_x < 0.0000000001) then 1.0 else idealWheelRear.rim1.lengthDirection[1] / idealWheelRear.rim1.abs_n_x;
//   protected Real idealWheelRear.rim1.e_x[2](unit = \"1\") = if noEvent(idealWheelRear.rim1.abs_n_x < 0.0000000001) then 0.0 else idealWheelRear.rim1.lengthDirection[2] / idealWheelRear.rim1.abs_n_x;
//   protected Real idealWheelRear.rim1.e_x[3](unit = \"1\") = if noEvent(idealWheelRear.rim1.abs_n_x < 0.0000000001) then 0.0 else idealWheelRear.rim1.lengthDirection[3] / idealWheelRear.rim1.abs_n_x;
//   protected Real idealWheelRear.rim1.n_z_aux[1](unit = \"1\") = idealWheelRear.rim1.e_x[2] * idealWheelRear.rim1.widthDirection[3] - idealWheelRear.rim1.e_x[3] * idealWheelRear.rim1.widthDirection[2];
//   protected Real idealWheelRear.rim1.n_z_aux[2](unit = \"1\") = idealWheelRear.rim1.e_x[3] * idealWheelRear.rim1.widthDirection[1] - idealWheelRear.rim1.e_x[1] * idealWheelRear.rim1.widthDirection[3];
//   protected Real idealWheelRear.rim1.n_z_aux[3](unit = \"1\") = idealWheelRear.rim1.e_x[1] * idealWheelRear.rim1.widthDirection[2] - idealWheelRear.rim1.e_x[2] * idealWheelRear.rim1.widthDirection[1];
//   protected Real idealWheelRear.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]},if noEvent(idealWheelRear.rim1.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim1.n_z_aux[2] ^ 2.0 + idealWheelRear.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.rim1.widthDirection[1],idealWheelRear.rim1.widthDirection[2],idealWheelRear.rim1.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]})[1];
//   protected Real idealWheelRear.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]},if noEvent(idealWheelRear.rim1.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim1.n_z_aux[2] ^ 2.0 + idealWheelRear.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.rim1.widthDirection[1],idealWheelRear.rim1.widthDirection[2],idealWheelRear.rim1.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]})[2];
//   protected Real idealWheelRear.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]},if noEvent(idealWheelRear.rim1.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim1.n_z_aux[2] ^ 2.0 + idealWheelRear.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.rim1.widthDirection[1],idealWheelRear.rim1.widthDirection[2],idealWheelRear.rim1.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.rim1.e_x[1],idealWheelRear.rim1.e_x[2],idealWheelRear.rim1.e_x[3]})[3];
//   protected output Real idealWheelRear.rim1.Form;
//   output Real idealWheelRear.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelRear.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim1.Material;
//   protected output Real idealWheelRear.rim1.Extra;
//   parameter String idealWheelRear.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real idealWheelRear.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real idealWheelRear.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real idealWheelRear.rim2.r[1](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim2.r[2](quantity = \"Length\", unit = \"m\") = idealWheelRear.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real idealWheelRear.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -idealWheelRear.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real idealWheelRear.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real idealWheelRear.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * idealWheelRear.radius \"Length of visual object\";
//   input Real idealWheelRear.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real idealWheelRear.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real idealWheelRear.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real idealWheelRear.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real idealWheelRear.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real idealWheelRear.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({idealWheelRear.rim2.lengthDirection[1],idealWheelRear.rim2.lengthDirection[2],idealWheelRear.rim2.lengthDirection[3]});
//   protected Real idealWheelRear.rim2.e_x[1](unit = \"1\") = if noEvent(idealWheelRear.rim2.abs_n_x < 0.0000000001) then 1.0 else idealWheelRear.rim2.lengthDirection[1] / idealWheelRear.rim2.abs_n_x;
//   protected Real idealWheelRear.rim2.e_x[2](unit = \"1\") = if noEvent(idealWheelRear.rim2.abs_n_x < 0.0000000001) then 0.0 else idealWheelRear.rim2.lengthDirection[2] / idealWheelRear.rim2.abs_n_x;
//   protected Real idealWheelRear.rim2.e_x[3](unit = \"1\") = if noEvent(idealWheelRear.rim2.abs_n_x < 0.0000000001) then 0.0 else idealWheelRear.rim2.lengthDirection[3] / idealWheelRear.rim2.abs_n_x;
//   protected Real idealWheelRear.rim2.n_z_aux[1](unit = \"1\") = idealWheelRear.rim2.e_x[2] * idealWheelRear.rim2.widthDirection[3] - idealWheelRear.rim2.e_x[3] * idealWheelRear.rim2.widthDirection[2];
//   protected Real idealWheelRear.rim2.n_z_aux[2](unit = \"1\") = idealWheelRear.rim2.e_x[3] * idealWheelRear.rim2.widthDirection[1] - idealWheelRear.rim2.e_x[1] * idealWheelRear.rim2.widthDirection[3];
//   protected Real idealWheelRear.rim2.n_z_aux[3](unit = \"1\") = idealWheelRear.rim2.e_x[1] * idealWheelRear.rim2.widthDirection[2] - idealWheelRear.rim2.e_x[2] * idealWheelRear.rim2.widthDirection[1];
//   protected Real idealWheelRear.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]},if noEvent(idealWheelRear.rim2.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim2.n_z_aux[2] ^ 2.0 + idealWheelRear.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.rim2.widthDirection[1],idealWheelRear.rim2.widthDirection[2],idealWheelRear.rim2.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]})[1];
//   protected Real idealWheelRear.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]},if noEvent(idealWheelRear.rim2.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim2.n_z_aux[2] ^ 2.0 + idealWheelRear.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.rim2.widthDirection[1],idealWheelRear.rim2.widthDirection[2],idealWheelRear.rim2.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]})[2];
//   protected Real idealWheelRear.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]},if noEvent(idealWheelRear.rim2.n_z_aux[1] ^ 2.0 + (idealWheelRear.rim2.n_z_aux[2] ^ 2.0 + idealWheelRear.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {idealWheelRear.rim2.widthDirection[1],idealWheelRear.rim2.widthDirection[2],idealWheelRear.rim2.widthDirection[3]} else if noEvent(abs(idealWheelRear.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{idealWheelRear.rim2.e_x[1],idealWheelRear.rim2.e_x[2],idealWheelRear.rim2.e_x[3]})[3];
//   protected output Real idealWheelRear.rim2.Form;
//   output Real idealWheelRear.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real idealWheelRear.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real idealWheelRear.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real idealWheelRear.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real idealWheelRear.rim2.Material;
//   protected output Real idealWheelRear.rim2.Extra;
//   Real revolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real revolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real revolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real revolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real revolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real revolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real revolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean revolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real revolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -0.69813170079773;
//   parameter Real revolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   parameter Boolean revolute.animate = true \"enable Animation\";
//   parameter Boolean revolute.enforceStates = true \"enforce the state of the revolute to become the state of the total system\";
//   Real revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.always) \"Angular position\";
//   Real revolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.always) \"Angular velocity\";
//   Real revolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real revolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter String revolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real revolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real revolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real revolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = revolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = revolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real revolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real revolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real revolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real revolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real revolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real revolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real revolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real revolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real revolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({revolute.cylinder.lengthDirection[1],revolute.cylinder.lengthDirection[2],revolute.cylinder.lengthDirection[3]});
//   protected Real revolute.cylinder.e_x[1](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else revolute.cylinder.lengthDirection[1] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[2](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[2] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.e_x[3](unit = \"1\") = if noEvent(revolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else revolute.cylinder.lengthDirection[3] / revolute.cylinder.abs_n_x;
//   protected Real revolute.cylinder.n_z_aux[1](unit = \"1\") = revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[3] - revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[2];
//   protected Real revolute.cylinder.n_z_aux[2](unit = \"1\") = revolute.cylinder.e_x[3] * revolute.cylinder.widthDirection[1] - revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[3];
//   protected Real revolute.cylinder.n_z_aux[3](unit = \"1\") = revolute.cylinder.e_x[1] * revolute.cylinder.widthDirection[2] - revolute.cylinder.e_x[2] * revolute.cylinder.widthDirection[1];
//   protected Real revolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[1];
//   protected Real revolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[2];
//   protected Real revolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]},if noEvent(revolute.cylinder.n_z_aux[1] ^ 2.0 + (revolute.cylinder.n_z_aux[2] ^ 2.0 + revolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {revolute.cylinder.widthDirection[1],revolute.cylinder.widthDirection[2],revolute.cylinder.widthDirection[3]} else if noEvent(abs(revolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{revolute.cylinder.e_x[1],revolute.cylinder.e_x[2],revolute.cylinder.e_x[3]})[3];
//   protected output Real revolute.cylinder.Form;
//   output Real revolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real revolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real revolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real revolute.cylinder.Material;
//   protected output Real revolute.cylinder.Extra;
//   parameter Boolean engineTorque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real engineTorque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real engineTorque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real engineTorque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real engineTorque.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real engineTorque.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 2.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real engineTorque.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real trail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real trail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real trail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real trail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real trail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real trail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real trail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real trail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real trail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real trail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real trail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real trail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real trail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real trail.r[2](quantity = \"Length\", unit = \"m\") = -0.1 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real trail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real trail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real trail.R[1,1] \"Rotation matrix\";
//   Real trail.R[1,2] \"Rotation matrix\";
//   Real trail.R[2,1] \"Rotation matrix\";
//   Real trail.R[2,2] \"Rotation matrix\";
//   parameter Boolean trail.animate = true \"enable Animation\";
//   final parameter Real trail.l(quantity = \"Length\", unit = \"m\") = sqrt(trail.r[1] ^ 2.0 + trail.r[2] ^ 2.0);
//   parameter String trail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real trail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real trail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real trail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real trail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real trail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = trail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real trail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = trail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real trail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real trail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real trail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real trail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real trail.cylinder.lengthDirection[1](unit = \"1\") = trail.r0[1] / trail.l \"Vector in length direction, resolved in object frame\";
//   input Real trail.cylinder.lengthDirection[2](unit = \"1\") = trail.r0[2] / trail.l \"Vector in length direction, resolved in object frame\";
//   input Real trail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real trail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real trail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real trail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real trail.cylinder.length(quantity = \"Length\", unit = \"m\") = trail.l \"Length of visual object\";
//   input Real trail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real trail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real trail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real trail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real trail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real trail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real trail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real trail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({trail.cylinder.lengthDirection[1],trail.cylinder.lengthDirection[2],trail.cylinder.lengthDirection[3]});
//   protected Real trail.cylinder.e_x[1](unit = \"1\") = if noEvent(trail.cylinder.abs_n_x < 0.0000000001) then 1.0 else trail.cylinder.lengthDirection[1] / trail.cylinder.abs_n_x;
//   protected Real trail.cylinder.e_x[2](unit = \"1\") = if noEvent(trail.cylinder.abs_n_x < 0.0000000001) then 0.0 else trail.cylinder.lengthDirection[2] / trail.cylinder.abs_n_x;
//   protected Real trail.cylinder.e_x[3](unit = \"1\") = if noEvent(trail.cylinder.abs_n_x < 0.0000000001) then 0.0 else trail.cylinder.lengthDirection[3] / trail.cylinder.abs_n_x;
//   protected Real trail.cylinder.n_z_aux[1](unit = \"1\") = trail.cylinder.e_x[2] * trail.cylinder.widthDirection[3] - trail.cylinder.e_x[3] * trail.cylinder.widthDirection[2];
//   protected Real trail.cylinder.n_z_aux[2](unit = \"1\") = trail.cylinder.e_x[3] * trail.cylinder.widthDirection[1] - trail.cylinder.e_x[1] * trail.cylinder.widthDirection[3];
//   protected Real trail.cylinder.n_z_aux[3](unit = \"1\") = trail.cylinder.e_x[1] * trail.cylinder.widthDirection[2] - trail.cylinder.e_x[2] * trail.cylinder.widthDirection[1];
//   protected Real trail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]},if noEvent(trail.cylinder.n_z_aux[1] ^ 2.0 + (trail.cylinder.n_z_aux[2] ^ 2.0 + trail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {trail.cylinder.widthDirection[1],trail.cylinder.widthDirection[2],trail.cylinder.widthDirection[3]} else if noEvent(abs(trail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]})[1];
//   protected Real trail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]},if noEvent(trail.cylinder.n_z_aux[1] ^ 2.0 + (trail.cylinder.n_z_aux[2] ^ 2.0 + trail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {trail.cylinder.widthDirection[1],trail.cylinder.widthDirection[2],trail.cylinder.widthDirection[3]} else if noEvent(abs(trail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]})[2];
//   protected Real trail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]},if noEvent(trail.cylinder.n_z_aux[1] ^ 2.0 + (trail.cylinder.n_z_aux[2] ^ 2.0 + trail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {trail.cylinder.widthDirection[1],trail.cylinder.widthDirection[2],trail.cylinder.widthDirection[3]} else if noEvent(abs(trail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{trail.cylinder.e_x[1],trail.cylinder.e_x[2],trail.cylinder.e_x[3]})[3];
//   protected output Real trail.cylinder.Form;
//   output Real trail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real trail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real trail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real trail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real trail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real trail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real trail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real trail.cylinder.Material;
//   protected output Real trail.cylinder.Extra;
// initial equation
//   revolute.phi = revolute.phi_start;
//   revolute.w = revolute.w_start;
// equation
//   bodyFront.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyFront.sphere.shapeType);
//   bodyFront.sphere.rxvisobj[1] = bodyFront.sphere.R.T[1,1] * bodyFront.sphere.e_x[1] + bodyFront.sphere.R.T[2,1] * bodyFront.sphere.e_x[2] + bodyFront.sphere.R.T[3,1] * bodyFront.sphere.e_x[3];
//   bodyFront.sphere.rxvisobj[2] = bodyFront.sphere.R.T[1,2] * bodyFront.sphere.e_x[1] + bodyFront.sphere.R.T[2,2] * bodyFront.sphere.e_x[2] + bodyFront.sphere.R.T[3,2] * bodyFront.sphere.e_x[3];
//   bodyFront.sphere.rxvisobj[3] = bodyFront.sphere.R.T[1,3] * bodyFront.sphere.e_x[1] + bodyFront.sphere.R.T[2,3] * bodyFront.sphere.e_x[2] + bodyFront.sphere.R.T[3,3] * bodyFront.sphere.e_x[3];
//   bodyFront.sphere.ryvisobj[1] = bodyFront.sphere.R.T[1,1] * bodyFront.sphere.e_y[1] + bodyFront.sphere.R.T[2,1] * bodyFront.sphere.e_y[2] + bodyFront.sphere.R.T[3,1] * bodyFront.sphere.e_y[3];
//   bodyFront.sphere.ryvisobj[2] = bodyFront.sphere.R.T[1,2] * bodyFront.sphere.e_y[1] + bodyFront.sphere.R.T[2,2] * bodyFront.sphere.e_y[2] + bodyFront.sphere.R.T[3,2] * bodyFront.sphere.e_y[3];
//   bodyFront.sphere.ryvisobj[3] = bodyFront.sphere.R.T[1,3] * bodyFront.sphere.e_y[1] + bodyFront.sphere.R.T[2,3] * bodyFront.sphere.e_y[2] + bodyFront.sphere.R.T[3,3] * bodyFront.sphere.e_y[3];
//   bodyFront.sphere.rvisobj = bodyFront.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyFront.sphere.R.T[1,1],bodyFront.sphere.R.T[1,2],bodyFront.sphere.R.T[1,3]},{bodyFront.sphere.R.T[2,1],bodyFront.sphere.R.T[2,2],bodyFront.sphere.R.T[2,3]},{bodyFront.sphere.R.T[3,1],bodyFront.sphere.R.T[3,2],bodyFront.sphere.R.T[3,3]}},{bodyFront.sphere.r_shape[1],bodyFront.sphere.r_shape[2],bodyFront.sphere.r_shape[3]});
//   bodyFront.sphere.size[1] = bodyFront.sphere.length;
//   bodyFront.sphere.size[2] = bodyFront.sphere.width;
//   bodyFront.sphere.size[3] = bodyFront.sphere.height;
//   bodyFront.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyFront.sphere.color[1] / 255.0,bodyFront.sphere.color[2] / 255.0,bodyFront.sphere.color[3] / 255.0,bodyFront.sphere.specularCoefficient);
//   bodyFront.sphere.Extra = bodyFront.sphere.extra;
//   bodyFront.r[1] = bodyFront.frame_a.x;
//   bodyFront.r[2] = bodyFront.frame_a.y;
//   bodyFront.v[1] = der(bodyFront.r[1]);
//   bodyFront.v[2] = der(bodyFront.r[2]);
//   bodyFront.w = der(bodyFront.frame_a.phi);
//   bodyFront.a[1] = der(bodyFront.v[1]);
//   bodyFront.a[2] = der(bodyFront.v[2]);
//   bodyFront.z = der(bodyFront.w);
//   bodyFront.f[1] = bodyFront.frame_a.fx;
//   bodyFront.f[2] = bodyFront.frame_a.fy;
//   bodyFront.f[1] + bodyFront.g[1] * bodyFront.m = bodyFront.a[1] * bodyFront.m;
//   bodyFront.f[2] + bodyFront.g[2] * bodyFront.m = bodyFront.a[2] * bodyFront.m;
//   bodyFront.frame_a.t = bodyFront.I * bodyFront.z;
//   idealWheelFront.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelFront.cylinder.shapeType);
//   idealWheelFront.cylinder.rxvisobj[1] = idealWheelFront.cylinder.R.T[1,1] * idealWheelFront.cylinder.e_x[1] + idealWheelFront.cylinder.R.T[2,1] * idealWheelFront.cylinder.e_x[2] + idealWheelFront.cylinder.R.T[3,1] * idealWheelFront.cylinder.e_x[3];
//   idealWheelFront.cylinder.rxvisobj[2] = idealWheelFront.cylinder.R.T[1,2] * idealWheelFront.cylinder.e_x[1] + idealWheelFront.cylinder.R.T[2,2] * idealWheelFront.cylinder.e_x[2] + idealWheelFront.cylinder.R.T[3,2] * idealWheelFront.cylinder.e_x[3];
//   idealWheelFront.cylinder.rxvisobj[3] = idealWheelFront.cylinder.R.T[1,3] * idealWheelFront.cylinder.e_x[1] + idealWheelFront.cylinder.R.T[2,3] * idealWheelFront.cylinder.e_x[2] + idealWheelFront.cylinder.R.T[3,3] * idealWheelFront.cylinder.e_x[3];
//   idealWheelFront.cylinder.ryvisobj[1] = idealWheelFront.cylinder.R.T[1,1] * idealWheelFront.cylinder.e_y[1] + idealWheelFront.cylinder.R.T[2,1] * idealWheelFront.cylinder.e_y[2] + idealWheelFront.cylinder.R.T[3,1] * idealWheelFront.cylinder.e_y[3];
//   idealWheelFront.cylinder.ryvisobj[2] = idealWheelFront.cylinder.R.T[1,2] * idealWheelFront.cylinder.e_y[1] + idealWheelFront.cylinder.R.T[2,2] * idealWheelFront.cylinder.e_y[2] + idealWheelFront.cylinder.R.T[3,2] * idealWheelFront.cylinder.e_y[3];
//   idealWheelFront.cylinder.ryvisobj[3] = idealWheelFront.cylinder.R.T[1,3] * idealWheelFront.cylinder.e_y[1] + idealWheelFront.cylinder.R.T[2,3] * idealWheelFront.cylinder.e_y[2] + idealWheelFront.cylinder.R.T[3,3] * idealWheelFront.cylinder.e_y[3];
//   idealWheelFront.cylinder.rvisobj = idealWheelFront.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelFront.cylinder.R.T[1,1],idealWheelFront.cylinder.R.T[1,2],idealWheelFront.cylinder.R.T[1,3]},{idealWheelFront.cylinder.R.T[2,1],idealWheelFront.cylinder.R.T[2,2],idealWheelFront.cylinder.R.T[2,3]},{idealWheelFront.cylinder.R.T[3,1],idealWheelFront.cylinder.R.T[3,2],idealWheelFront.cylinder.R.T[3,3]}},{idealWheelFront.cylinder.r_shape[1],idealWheelFront.cylinder.r_shape[2],idealWheelFront.cylinder.r_shape[3]});
//   idealWheelFront.cylinder.size[1] = idealWheelFront.cylinder.length;
//   idealWheelFront.cylinder.size[2] = idealWheelFront.cylinder.width;
//   idealWheelFront.cylinder.size[3] = idealWheelFront.cylinder.height;
//   idealWheelFront.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelFront.cylinder.color[1] / 255.0,idealWheelFront.cylinder.color[2] / 255.0,idealWheelFront.cylinder.color[3] / 255.0,idealWheelFront.cylinder.specularCoefficient);
//   idealWheelFront.cylinder.Extra = idealWheelFront.cylinder.extra;
//   idealWheelFront.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelFront.e0[2],idealWheelFront.e0[1],0.0},idealWheelFront.flange_a.phi,0.0);
//   idealWheelFront.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelFront.rim1.shapeType);
//   idealWheelFront.rim1.rxvisobj[1] = idealWheelFront.rim1.R.T[1,1] * idealWheelFront.rim1.e_x[1] + idealWheelFront.rim1.R.T[2,1] * idealWheelFront.rim1.e_x[2] + idealWheelFront.rim1.R.T[3,1] * idealWheelFront.rim1.e_x[3];
//   idealWheelFront.rim1.rxvisobj[2] = idealWheelFront.rim1.R.T[1,2] * idealWheelFront.rim1.e_x[1] + idealWheelFront.rim1.R.T[2,2] * idealWheelFront.rim1.e_x[2] + idealWheelFront.rim1.R.T[3,2] * idealWheelFront.rim1.e_x[3];
//   idealWheelFront.rim1.rxvisobj[3] = idealWheelFront.rim1.R.T[1,3] * idealWheelFront.rim1.e_x[1] + idealWheelFront.rim1.R.T[2,3] * idealWheelFront.rim1.e_x[2] + idealWheelFront.rim1.R.T[3,3] * idealWheelFront.rim1.e_x[3];
//   idealWheelFront.rim1.ryvisobj[1] = idealWheelFront.rim1.R.T[1,1] * idealWheelFront.rim1.e_y[1] + idealWheelFront.rim1.R.T[2,1] * idealWheelFront.rim1.e_y[2] + idealWheelFront.rim1.R.T[3,1] * idealWheelFront.rim1.e_y[3];
//   idealWheelFront.rim1.ryvisobj[2] = idealWheelFront.rim1.R.T[1,2] * idealWheelFront.rim1.e_y[1] + idealWheelFront.rim1.R.T[2,2] * idealWheelFront.rim1.e_y[2] + idealWheelFront.rim1.R.T[3,2] * idealWheelFront.rim1.e_y[3];
//   idealWheelFront.rim1.ryvisobj[3] = idealWheelFront.rim1.R.T[1,3] * idealWheelFront.rim1.e_y[1] + idealWheelFront.rim1.R.T[2,3] * idealWheelFront.rim1.e_y[2] + idealWheelFront.rim1.R.T[3,3] * idealWheelFront.rim1.e_y[3];
//   idealWheelFront.rim1.rvisobj = idealWheelFront.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelFront.rim1.R.T[1,1],idealWheelFront.rim1.R.T[1,2],idealWheelFront.rim1.R.T[1,3]},{idealWheelFront.rim1.R.T[2,1],idealWheelFront.rim1.R.T[2,2],idealWheelFront.rim1.R.T[2,3]},{idealWheelFront.rim1.R.T[3,1],idealWheelFront.rim1.R.T[3,2],idealWheelFront.rim1.R.T[3,3]}},{idealWheelFront.rim1.r_shape[1],idealWheelFront.rim1.r_shape[2],idealWheelFront.rim1.r_shape[3]});
//   idealWheelFront.rim1.size[1] = idealWheelFront.rim1.length;
//   idealWheelFront.rim1.size[2] = idealWheelFront.rim1.width;
//   idealWheelFront.rim1.size[3] = idealWheelFront.rim1.height;
//   idealWheelFront.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelFront.rim1.color[1] / 255.0,idealWheelFront.rim1.color[2] / 255.0,idealWheelFront.rim1.color[3] / 255.0,idealWheelFront.rim1.specularCoefficient);
//   idealWheelFront.rim1.Extra = idealWheelFront.rim1.extra;
//   idealWheelFront.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelFront.e0[2],idealWheelFront.e0[1],0.0},1.5707963267948966 + idealWheelFront.flange_a.phi,0.0);
//   idealWheelFront.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelFront.rim2.shapeType);
//   idealWheelFront.rim2.rxvisobj[1] = idealWheelFront.rim2.R.T[1,1] * idealWheelFront.rim2.e_x[1] + idealWheelFront.rim2.R.T[2,1] * idealWheelFront.rim2.e_x[2] + idealWheelFront.rim2.R.T[3,1] * idealWheelFront.rim2.e_x[3];
//   idealWheelFront.rim2.rxvisobj[2] = idealWheelFront.rim2.R.T[1,2] * idealWheelFront.rim2.e_x[1] + idealWheelFront.rim2.R.T[2,2] * idealWheelFront.rim2.e_x[2] + idealWheelFront.rim2.R.T[3,2] * idealWheelFront.rim2.e_x[3];
//   idealWheelFront.rim2.rxvisobj[3] = idealWheelFront.rim2.R.T[1,3] * idealWheelFront.rim2.e_x[1] + idealWheelFront.rim2.R.T[2,3] * idealWheelFront.rim2.e_x[2] + idealWheelFront.rim2.R.T[3,3] * idealWheelFront.rim2.e_x[3];
//   idealWheelFront.rim2.ryvisobj[1] = idealWheelFront.rim2.R.T[1,1] * idealWheelFront.rim2.e_y[1] + idealWheelFront.rim2.R.T[2,1] * idealWheelFront.rim2.e_y[2] + idealWheelFront.rim2.R.T[3,1] * idealWheelFront.rim2.e_y[3];
//   idealWheelFront.rim2.ryvisobj[2] = idealWheelFront.rim2.R.T[1,2] * idealWheelFront.rim2.e_y[1] + idealWheelFront.rim2.R.T[2,2] * idealWheelFront.rim2.e_y[2] + idealWheelFront.rim2.R.T[3,2] * idealWheelFront.rim2.e_y[3];
//   idealWheelFront.rim2.ryvisobj[3] = idealWheelFront.rim2.R.T[1,3] * idealWheelFront.rim2.e_y[1] + idealWheelFront.rim2.R.T[2,3] * idealWheelFront.rim2.e_y[2] + idealWheelFront.rim2.R.T[3,3] * idealWheelFront.rim2.e_y[3];
//   idealWheelFront.rim2.rvisobj = idealWheelFront.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelFront.rim2.R.T[1,1],idealWheelFront.rim2.R.T[1,2],idealWheelFront.rim2.R.T[1,3]},{idealWheelFront.rim2.R.T[2,1],idealWheelFront.rim2.R.T[2,2],idealWheelFront.rim2.R.T[2,3]},{idealWheelFront.rim2.R.T[3,1],idealWheelFront.rim2.R.T[3,2],idealWheelFront.rim2.R.T[3,3]}},{idealWheelFront.rim2.r_shape[1],idealWheelFront.rim2.r_shape[2],idealWheelFront.rim2.r_shape[3]});
//   idealWheelFront.rim2.size[1] = idealWheelFront.rim2.length;
//   idealWheelFront.rim2.size[2] = idealWheelFront.rim2.width;
//   idealWheelFront.rim2.size[3] = idealWheelFront.rim2.height;
//   idealWheelFront.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelFront.rim2.color[1] / 255.0,idealWheelFront.rim2.color[2] / 255.0,idealWheelFront.rim2.color[3] / 255.0,idealWheelFront.rim2.specularCoefficient);
//   idealWheelFront.rim2.Extra = idealWheelFront.rim2.extra;
//   idealWheelFront.R[1,1] = cos(idealWheelFront.frame_a.phi);
//   idealWheelFront.R[1,2] = sin(idealWheelFront.frame_a.phi);
//   idealWheelFront.R[2,1] = -sin(idealWheelFront.frame_a.phi);
//   idealWheelFront.R[2,2] = cos(idealWheelFront.frame_a.phi);
//   idealWheelFront.e0[1] = idealWheelFront.R[1,1] * idealWheelFront.e[1] + idealWheelFront.R[1,2] * idealWheelFront.e[2];
//   idealWheelFront.e0[2] = idealWheelFront.R[2,1] * idealWheelFront.e[1] + idealWheelFront.R[2,2] * idealWheelFront.e[2];
//   idealWheelFront.v[1] = der(idealWheelFront.frame_a.x);
//   idealWheelFront.v[2] = der(idealWheelFront.frame_a.y);
//   idealWheelFront.v[1] = idealWheelFront.e0[1] * idealWheelFront.v_long;
//   idealWheelFront.v[2] = idealWheelFront.e0[2] * idealWheelFront.v_long;
//   idealWheelFront.w_roll = der(idealWheelFront.flange_a.phi);
//   idealWheelFront.v_long = idealWheelFront.radius * idealWheelFront.w_roll;
//   idealWheelFront.a = der(idealWheelFront.v_long);
//   (-idealWheelFront.f_long) * idealWheelFront.radius = idealWheelFront.flange_a.tau;
//   idealWheelFront.frame_a.t = 0.0;
//   idealWheelFront.frame_a.fx * idealWheelFront.e0[1] + idealWheelFront.frame_a.fy * idealWheelFront.e0[2] = idealWheelFront.f_long;
//   chassis.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(chassis.cylinder.shapeType);
//   chassis.cylinder.rxvisobj[1] = chassis.cylinder.R.T[1,1] * chassis.cylinder.e_x[1] + chassis.cylinder.R.T[2,1] * chassis.cylinder.e_x[2] + chassis.cylinder.R.T[3,1] * chassis.cylinder.e_x[3];
//   chassis.cylinder.rxvisobj[2] = chassis.cylinder.R.T[1,2] * chassis.cylinder.e_x[1] + chassis.cylinder.R.T[2,2] * chassis.cylinder.e_x[2] + chassis.cylinder.R.T[3,2] * chassis.cylinder.e_x[3];
//   chassis.cylinder.rxvisobj[3] = chassis.cylinder.R.T[1,3] * chassis.cylinder.e_x[1] + chassis.cylinder.R.T[2,3] * chassis.cylinder.e_x[2] + chassis.cylinder.R.T[3,3] * chassis.cylinder.e_x[3];
//   chassis.cylinder.ryvisobj[1] = chassis.cylinder.R.T[1,1] * chassis.cylinder.e_y[1] + chassis.cylinder.R.T[2,1] * chassis.cylinder.e_y[2] + chassis.cylinder.R.T[3,1] * chassis.cylinder.e_y[3];
//   chassis.cylinder.ryvisobj[2] = chassis.cylinder.R.T[1,2] * chassis.cylinder.e_y[1] + chassis.cylinder.R.T[2,2] * chassis.cylinder.e_y[2] + chassis.cylinder.R.T[3,2] * chassis.cylinder.e_y[3];
//   chassis.cylinder.ryvisobj[3] = chassis.cylinder.R.T[1,3] * chassis.cylinder.e_y[1] + chassis.cylinder.R.T[2,3] * chassis.cylinder.e_y[2] + chassis.cylinder.R.T[3,3] * chassis.cylinder.e_y[3];
//   chassis.cylinder.rvisobj = chassis.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{chassis.cylinder.R.T[1,1],chassis.cylinder.R.T[1,2],chassis.cylinder.R.T[1,3]},{chassis.cylinder.R.T[2,1],chassis.cylinder.R.T[2,2],chassis.cylinder.R.T[2,3]},{chassis.cylinder.R.T[3,1],chassis.cylinder.R.T[3,2],chassis.cylinder.R.T[3,3]}},{chassis.cylinder.r_shape[1],chassis.cylinder.r_shape[2],chassis.cylinder.r_shape[3]});
//   chassis.cylinder.size[1] = chassis.cylinder.length;
//   chassis.cylinder.size[2] = chassis.cylinder.width;
//   chassis.cylinder.size[3] = chassis.cylinder.height;
//   chassis.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(chassis.cylinder.color[1] / 255.0,chassis.cylinder.color[2] / 255.0,chassis.cylinder.color[3] / 255.0,chassis.cylinder.specularCoefficient);
//   chassis.cylinder.Extra = chassis.cylinder.extra;
//   chassis.R[1,1] = cos(chassis.frame_a.phi);
//   chassis.R[1,2] = sin(chassis.frame_a.phi);
//   chassis.R[2,1] = -sin(chassis.frame_a.phi);
//   chassis.R[2,2] = cos(chassis.frame_a.phi);
//   chassis.r0[1] = chassis.R[1,1] * chassis.r[1] + chassis.R[1,2] * chassis.r[2];
//   chassis.r0[2] = chassis.R[2,1] * chassis.r[1] + chassis.R[2,2] * chassis.r[2];
//   chassis.frame_a.x + chassis.r0[1] = chassis.frame_b.x;
//   chassis.frame_a.y + chassis.r0[2] = chassis.frame_b.y;
//   chassis.frame_a.phi = chassis.frame_b.phi;
//   chassis.frame_a.fx + chassis.frame_b.fx = 0.0;
//   chassis.frame_a.fy + chassis.frame_b.fy = 0.0;
//   chassis.frame_a.t + (chassis.frame_b.t + ((-chassis.r0[1]) * chassis.frame_b.fy + chassis.r0[2] * chassis.frame_b.fx)) = 0.0;
//   bodyRear.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyRear.sphere.shapeType);
//   bodyRear.sphere.rxvisobj[1] = bodyRear.sphere.R.T[1,1] * bodyRear.sphere.e_x[1] + bodyRear.sphere.R.T[2,1] * bodyRear.sphere.e_x[2] + bodyRear.sphere.R.T[3,1] * bodyRear.sphere.e_x[3];
//   bodyRear.sphere.rxvisobj[2] = bodyRear.sphere.R.T[1,2] * bodyRear.sphere.e_x[1] + bodyRear.sphere.R.T[2,2] * bodyRear.sphere.e_x[2] + bodyRear.sphere.R.T[3,2] * bodyRear.sphere.e_x[3];
//   bodyRear.sphere.rxvisobj[3] = bodyRear.sphere.R.T[1,3] * bodyRear.sphere.e_x[1] + bodyRear.sphere.R.T[2,3] * bodyRear.sphere.e_x[2] + bodyRear.sphere.R.T[3,3] * bodyRear.sphere.e_x[3];
//   bodyRear.sphere.ryvisobj[1] = bodyRear.sphere.R.T[1,1] * bodyRear.sphere.e_y[1] + bodyRear.sphere.R.T[2,1] * bodyRear.sphere.e_y[2] + bodyRear.sphere.R.T[3,1] * bodyRear.sphere.e_y[3];
//   bodyRear.sphere.ryvisobj[2] = bodyRear.sphere.R.T[1,2] * bodyRear.sphere.e_y[1] + bodyRear.sphere.R.T[2,2] * bodyRear.sphere.e_y[2] + bodyRear.sphere.R.T[3,2] * bodyRear.sphere.e_y[3];
//   bodyRear.sphere.ryvisobj[3] = bodyRear.sphere.R.T[1,3] * bodyRear.sphere.e_y[1] + bodyRear.sphere.R.T[2,3] * bodyRear.sphere.e_y[2] + bodyRear.sphere.R.T[3,3] * bodyRear.sphere.e_y[3];
//   bodyRear.sphere.rvisobj = bodyRear.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyRear.sphere.R.T[1,1],bodyRear.sphere.R.T[1,2],bodyRear.sphere.R.T[1,3]},{bodyRear.sphere.R.T[2,1],bodyRear.sphere.R.T[2,2],bodyRear.sphere.R.T[2,3]},{bodyRear.sphere.R.T[3,1],bodyRear.sphere.R.T[3,2],bodyRear.sphere.R.T[3,3]}},{bodyRear.sphere.r_shape[1],bodyRear.sphere.r_shape[2],bodyRear.sphere.r_shape[3]});
//   bodyRear.sphere.size[1] = bodyRear.sphere.length;
//   bodyRear.sphere.size[2] = bodyRear.sphere.width;
//   bodyRear.sphere.size[3] = bodyRear.sphere.height;
//   bodyRear.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyRear.sphere.color[1] / 255.0,bodyRear.sphere.color[2] / 255.0,bodyRear.sphere.color[3] / 255.0,bodyRear.sphere.specularCoefficient);
//   bodyRear.sphere.Extra = bodyRear.sphere.extra;
//   bodyRear.r[1] = bodyRear.frame_a.x;
//   bodyRear.r[2] = bodyRear.frame_a.y;
//   bodyRear.v[1] = der(bodyRear.r[1]);
//   bodyRear.v[2] = der(bodyRear.r[2]);
//   bodyRear.w = der(bodyRear.frame_a.phi);
//   bodyRear.a[1] = der(bodyRear.v[1]);
//   bodyRear.a[2] = der(bodyRear.v[2]);
//   bodyRear.z = der(bodyRear.w);
//   bodyRear.f[1] = bodyRear.frame_a.fx;
//   bodyRear.f[2] = bodyRear.frame_a.fy;
//   bodyRear.f[1] + bodyRear.g[1] * bodyRear.m = bodyRear.a[1] * bodyRear.m;
//   bodyRear.f[2] + bodyRear.g[2] * bodyRear.m = bodyRear.a[2] * bodyRear.m;
//   bodyRear.frame_a.t = bodyRear.I * bodyRear.z;
//   idealWheelRear.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelRear.cylinder.shapeType);
//   idealWheelRear.cylinder.rxvisobj[1] = idealWheelRear.cylinder.R.T[1,1] * idealWheelRear.cylinder.e_x[1] + idealWheelRear.cylinder.R.T[2,1] * idealWheelRear.cylinder.e_x[2] + idealWheelRear.cylinder.R.T[3,1] * idealWheelRear.cylinder.e_x[3];
//   idealWheelRear.cylinder.rxvisobj[2] = idealWheelRear.cylinder.R.T[1,2] * idealWheelRear.cylinder.e_x[1] + idealWheelRear.cylinder.R.T[2,2] * idealWheelRear.cylinder.e_x[2] + idealWheelRear.cylinder.R.T[3,2] * idealWheelRear.cylinder.e_x[3];
//   idealWheelRear.cylinder.rxvisobj[3] = idealWheelRear.cylinder.R.T[1,3] * idealWheelRear.cylinder.e_x[1] + idealWheelRear.cylinder.R.T[2,3] * idealWheelRear.cylinder.e_x[2] + idealWheelRear.cylinder.R.T[3,3] * idealWheelRear.cylinder.e_x[3];
//   idealWheelRear.cylinder.ryvisobj[1] = idealWheelRear.cylinder.R.T[1,1] * idealWheelRear.cylinder.e_y[1] + idealWheelRear.cylinder.R.T[2,1] * idealWheelRear.cylinder.e_y[2] + idealWheelRear.cylinder.R.T[3,1] * idealWheelRear.cylinder.e_y[3];
//   idealWheelRear.cylinder.ryvisobj[2] = idealWheelRear.cylinder.R.T[1,2] * idealWheelRear.cylinder.e_y[1] + idealWheelRear.cylinder.R.T[2,2] * idealWheelRear.cylinder.e_y[2] + idealWheelRear.cylinder.R.T[3,2] * idealWheelRear.cylinder.e_y[3];
//   idealWheelRear.cylinder.ryvisobj[3] = idealWheelRear.cylinder.R.T[1,3] * idealWheelRear.cylinder.e_y[1] + idealWheelRear.cylinder.R.T[2,3] * idealWheelRear.cylinder.e_y[2] + idealWheelRear.cylinder.R.T[3,3] * idealWheelRear.cylinder.e_y[3];
//   idealWheelRear.cylinder.rvisobj = idealWheelRear.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelRear.cylinder.R.T[1,1],idealWheelRear.cylinder.R.T[1,2],idealWheelRear.cylinder.R.T[1,3]},{idealWheelRear.cylinder.R.T[2,1],idealWheelRear.cylinder.R.T[2,2],idealWheelRear.cylinder.R.T[2,3]},{idealWheelRear.cylinder.R.T[3,1],idealWheelRear.cylinder.R.T[3,2],idealWheelRear.cylinder.R.T[3,3]}},{idealWheelRear.cylinder.r_shape[1],idealWheelRear.cylinder.r_shape[2],idealWheelRear.cylinder.r_shape[3]});
//   idealWheelRear.cylinder.size[1] = idealWheelRear.cylinder.length;
//   idealWheelRear.cylinder.size[2] = idealWheelRear.cylinder.width;
//   idealWheelRear.cylinder.size[3] = idealWheelRear.cylinder.height;
//   idealWheelRear.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelRear.cylinder.color[1] / 255.0,idealWheelRear.cylinder.color[2] / 255.0,idealWheelRear.cylinder.color[3] / 255.0,idealWheelRear.cylinder.specularCoefficient);
//   idealWheelRear.cylinder.Extra = idealWheelRear.cylinder.extra;
//   idealWheelRear.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelRear.e0[2],idealWheelRear.e0[1],0.0},idealWheelRear.flange_a.phi,0.0);
//   idealWheelRear.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelRear.rim1.shapeType);
//   idealWheelRear.rim1.rxvisobj[1] = idealWheelRear.rim1.R.T[1,1] * idealWheelRear.rim1.e_x[1] + idealWheelRear.rim1.R.T[2,1] * idealWheelRear.rim1.e_x[2] + idealWheelRear.rim1.R.T[3,1] * idealWheelRear.rim1.e_x[3];
//   idealWheelRear.rim1.rxvisobj[2] = idealWheelRear.rim1.R.T[1,2] * idealWheelRear.rim1.e_x[1] + idealWheelRear.rim1.R.T[2,2] * idealWheelRear.rim1.e_x[2] + idealWheelRear.rim1.R.T[3,2] * idealWheelRear.rim1.e_x[3];
//   idealWheelRear.rim1.rxvisobj[3] = idealWheelRear.rim1.R.T[1,3] * idealWheelRear.rim1.e_x[1] + idealWheelRear.rim1.R.T[2,3] * idealWheelRear.rim1.e_x[2] + idealWheelRear.rim1.R.T[3,3] * idealWheelRear.rim1.e_x[3];
//   idealWheelRear.rim1.ryvisobj[1] = idealWheelRear.rim1.R.T[1,1] * idealWheelRear.rim1.e_y[1] + idealWheelRear.rim1.R.T[2,1] * idealWheelRear.rim1.e_y[2] + idealWheelRear.rim1.R.T[3,1] * idealWheelRear.rim1.e_y[3];
//   idealWheelRear.rim1.ryvisobj[2] = idealWheelRear.rim1.R.T[1,2] * idealWheelRear.rim1.e_y[1] + idealWheelRear.rim1.R.T[2,2] * idealWheelRear.rim1.e_y[2] + idealWheelRear.rim1.R.T[3,2] * idealWheelRear.rim1.e_y[3];
//   idealWheelRear.rim1.ryvisobj[3] = idealWheelRear.rim1.R.T[1,3] * idealWheelRear.rim1.e_y[1] + idealWheelRear.rim1.R.T[2,3] * idealWheelRear.rim1.e_y[2] + idealWheelRear.rim1.R.T[3,3] * idealWheelRear.rim1.e_y[3];
//   idealWheelRear.rim1.rvisobj = idealWheelRear.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelRear.rim1.R.T[1,1],idealWheelRear.rim1.R.T[1,2],idealWheelRear.rim1.R.T[1,3]},{idealWheelRear.rim1.R.T[2,1],idealWheelRear.rim1.R.T[2,2],idealWheelRear.rim1.R.T[2,3]},{idealWheelRear.rim1.R.T[3,1],idealWheelRear.rim1.R.T[3,2],idealWheelRear.rim1.R.T[3,3]}},{idealWheelRear.rim1.r_shape[1],idealWheelRear.rim1.r_shape[2],idealWheelRear.rim1.r_shape[3]});
//   idealWheelRear.rim1.size[1] = idealWheelRear.rim1.length;
//   idealWheelRear.rim1.size[2] = idealWheelRear.rim1.width;
//   idealWheelRear.rim1.size[3] = idealWheelRear.rim1.height;
//   idealWheelRear.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelRear.rim1.color[1] / 255.0,idealWheelRear.rim1.color[2] / 255.0,idealWheelRear.rim1.color[3] / 255.0,idealWheelRear.rim1.specularCoefficient);
//   idealWheelRear.rim1.Extra = idealWheelRear.rim1.extra;
//   idealWheelRear.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-idealWheelRear.e0[2],idealWheelRear.e0[1],0.0},1.5707963267948966 + idealWheelRear.flange_a.phi,0.0);
//   idealWheelRear.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(idealWheelRear.rim2.shapeType);
//   idealWheelRear.rim2.rxvisobj[1] = idealWheelRear.rim2.R.T[1,1] * idealWheelRear.rim2.e_x[1] + idealWheelRear.rim2.R.T[2,1] * idealWheelRear.rim2.e_x[2] + idealWheelRear.rim2.R.T[3,1] * idealWheelRear.rim2.e_x[3];
//   idealWheelRear.rim2.rxvisobj[2] = idealWheelRear.rim2.R.T[1,2] * idealWheelRear.rim2.e_x[1] + idealWheelRear.rim2.R.T[2,2] * idealWheelRear.rim2.e_x[2] + idealWheelRear.rim2.R.T[3,2] * idealWheelRear.rim2.e_x[3];
//   idealWheelRear.rim2.rxvisobj[3] = idealWheelRear.rim2.R.T[1,3] * idealWheelRear.rim2.e_x[1] + idealWheelRear.rim2.R.T[2,3] * idealWheelRear.rim2.e_x[2] + idealWheelRear.rim2.R.T[3,3] * idealWheelRear.rim2.e_x[3];
//   idealWheelRear.rim2.ryvisobj[1] = idealWheelRear.rim2.R.T[1,1] * idealWheelRear.rim2.e_y[1] + idealWheelRear.rim2.R.T[2,1] * idealWheelRear.rim2.e_y[2] + idealWheelRear.rim2.R.T[3,1] * idealWheelRear.rim2.e_y[3];
//   idealWheelRear.rim2.ryvisobj[2] = idealWheelRear.rim2.R.T[1,2] * idealWheelRear.rim2.e_y[1] + idealWheelRear.rim2.R.T[2,2] * idealWheelRear.rim2.e_y[2] + idealWheelRear.rim2.R.T[3,2] * idealWheelRear.rim2.e_y[3];
//   idealWheelRear.rim2.ryvisobj[3] = idealWheelRear.rim2.R.T[1,3] * idealWheelRear.rim2.e_y[1] + idealWheelRear.rim2.R.T[2,3] * idealWheelRear.rim2.e_y[2] + idealWheelRear.rim2.R.T[3,3] * idealWheelRear.rim2.e_y[3];
//   idealWheelRear.rim2.rvisobj = idealWheelRear.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{idealWheelRear.rim2.R.T[1,1],idealWheelRear.rim2.R.T[1,2],idealWheelRear.rim2.R.T[1,3]},{idealWheelRear.rim2.R.T[2,1],idealWheelRear.rim2.R.T[2,2],idealWheelRear.rim2.R.T[2,3]},{idealWheelRear.rim2.R.T[3,1],idealWheelRear.rim2.R.T[3,2],idealWheelRear.rim2.R.T[3,3]}},{idealWheelRear.rim2.r_shape[1],idealWheelRear.rim2.r_shape[2],idealWheelRear.rim2.r_shape[3]});
//   idealWheelRear.rim2.size[1] = idealWheelRear.rim2.length;
//   idealWheelRear.rim2.size[2] = idealWheelRear.rim2.width;
//   idealWheelRear.rim2.size[3] = idealWheelRear.rim2.height;
//   idealWheelRear.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(idealWheelRear.rim2.color[1] / 255.0,idealWheelRear.rim2.color[2] / 255.0,idealWheelRear.rim2.color[3] / 255.0,idealWheelRear.rim2.specularCoefficient);
//   idealWheelRear.rim2.Extra = idealWheelRear.rim2.extra;
//   idealWheelRear.R[1,1] = cos(idealWheelRear.frame_a.phi);
//   idealWheelRear.R[1,2] = sin(idealWheelRear.frame_a.phi);
//   idealWheelRear.R[2,1] = -sin(idealWheelRear.frame_a.phi);
//   idealWheelRear.R[2,2] = cos(idealWheelRear.frame_a.phi);
//   idealWheelRear.e0[1] = idealWheelRear.R[1,1] * idealWheelRear.e[1] + idealWheelRear.R[1,2] * idealWheelRear.e[2];
//   idealWheelRear.e0[2] = idealWheelRear.R[2,1] * idealWheelRear.e[1] + idealWheelRear.R[2,2] * idealWheelRear.e[2];
//   idealWheelRear.v[1] = der(idealWheelRear.frame_a.x);
//   idealWheelRear.v[2] = der(idealWheelRear.frame_a.y);
//   idealWheelRear.v[1] = idealWheelRear.e0[1] * idealWheelRear.v_long;
//   idealWheelRear.v[2] = idealWheelRear.e0[2] * idealWheelRear.v_long;
//   idealWheelRear.w_roll = der(idealWheelRear.flange_a.phi);
//   idealWheelRear.v_long = idealWheelRear.radius * idealWheelRear.w_roll;
//   idealWheelRear.a = der(idealWheelRear.v_long);
//   (-idealWheelRear.f_long) * idealWheelRear.radius = idealWheelRear.flange_a.tau;
//   idealWheelRear.frame_a.t = 0.0;
//   idealWheelRear.frame_a.fx * idealWheelRear.e0[1] + idealWheelRear.frame_a.fy * idealWheelRear.e0[2] = idealWheelRear.f_long;
//   revolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute.cylinder.shapeType);
//   revolute.cylinder.rxvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_x[3];
//   revolute.cylinder.rxvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_x[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_x[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_x[3];
//   revolute.cylinder.ryvisobj[1] = revolute.cylinder.R.T[1,1] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,1] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,1] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[2] = revolute.cylinder.R.T[1,2] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,2] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,2] * revolute.cylinder.e_y[3];
//   revolute.cylinder.ryvisobj[3] = revolute.cylinder.R.T[1,3] * revolute.cylinder.e_y[1] + revolute.cylinder.R.T[2,3] * revolute.cylinder.e_y[2] + revolute.cylinder.R.T[3,3] * revolute.cylinder.e_y[3];
//   revolute.cylinder.rvisobj = revolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute.cylinder.R.T[1,1],revolute.cylinder.R.T[1,2],revolute.cylinder.R.T[1,3]},{revolute.cylinder.R.T[2,1],revolute.cylinder.R.T[2,2],revolute.cylinder.R.T[2,3]},{revolute.cylinder.R.T[3,1],revolute.cylinder.R.T[3,2],revolute.cylinder.R.T[3,3]}},{revolute.cylinder.r_shape[1],revolute.cylinder.r_shape[2],revolute.cylinder.r_shape[3]});
//   revolute.cylinder.size[1] = revolute.cylinder.length;
//   revolute.cylinder.size[2] = revolute.cylinder.width;
//   revolute.cylinder.size[3] = revolute.cylinder.height;
//   revolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute.cylinder.color[1] / 255.0,revolute.cylinder.color[2] / 255.0,revolute.cylinder.color[3] / 255.0,revolute.cylinder.specularCoefficient);
//   revolute.cylinder.Extra = revolute.cylinder.extra;
//   revolute.w = der(revolute.phi);
//   revolute.z = der(revolute.w);
//   revolute.t = 0.0;
//   revolute.frame_a.x = revolute.frame_b.x;
//   revolute.frame_a.y = revolute.frame_b.y;
//   revolute.frame_a.phi + revolute.phi = revolute.frame_b.phi;
//   revolute.frame_a.fx + revolute.frame_b.fx = 0.0;
//   revolute.frame_a.fy + revolute.frame_b.fy = 0.0;
//   revolute.frame_a.t + revolute.frame_b.t = 0.0;
//   revolute.frame_a.t = revolute.t;
//   engineTorque.tau = -engineTorque.flange.tau;
//   engineTorque.tau = engineTorque.tau_constant;
//   engineTorque.phi = engineTorque.flange.phi - engineTorque.phi_support;
//   engineTorque.phi_support = 0.0;
//   trail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(trail.cylinder.shapeType);
//   trail.cylinder.rxvisobj[1] = trail.cylinder.R.T[1,1] * trail.cylinder.e_x[1] + trail.cylinder.R.T[2,1] * trail.cylinder.e_x[2] + trail.cylinder.R.T[3,1] * trail.cylinder.e_x[3];
//   trail.cylinder.rxvisobj[2] = trail.cylinder.R.T[1,2] * trail.cylinder.e_x[1] + trail.cylinder.R.T[2,2] * trail.cylinder.e_x[2] + trail.cylinder.R.T[3,2] * trail.cylinder.e_x[3];
//   trail.cylinder.rxvisobj[3] = trail.cylinder.R.T[1,3] * trail.cylinder.e_x[1] + trail.cylinder.R.T[2,3] * trail.cylinder.e_x[2] + trail.cylinder.R.T[3,3] * trail.cylinder.e_x[3];
//   trail.cylinder.ryvisobj[1] = trail.cylinder.R.T[1,1] * trail.cylinder.e_y[1] + trail.cylinder.R.T[2,1] * trail.cylinder.e_y[2] + trail.cylinder.R.T[3,1] * trail.cylinder.e_y[3];
//   trail.cylinder.ryvisobj[2] = trail.cylinder.R.T[1,2] * trail.cylinder.e_y[1] + trail.cylinder.R.T[2,2] * trail.cylinder.e_y[2] + trail.cylinder.R.T[3,2] * trail.cylinder.e_y[3];
//   trail.cylinder.ryvisobj[3] = trail.cylinder.R.T[1,3] * trail.cylinder.e_y[1] + trail.cylinder.R.T[2,3] * trail.cylinder.e_y[2] + trail.cylinder.R.T[3,3] * trail.cylinder.e_y[3];
//   trail.cylinder.rvisobj = trail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{trail.cylinder.R.T[1,1],trail.cylinder.R.T[1,2],trail.cylinder.R.T[1,3]},{trail.cylinder.R.T[2,1],trail.cylinder.R.T[2,2],trail.cylinder.R.T[2,3]},{trail.cylinder.R.T[3,1],trail.cylinder.R.T[3,2],trail.cylinder.R.T[3,3]}},{trail.cylinder.r_shape[1],trail.cylinder.r_shape[2],trail.cylinder.r_shape[3]});
//   trail.cylinder.size[1] = trail.cylinder.length;
//   trail.cylinder.size[2] = trail.cylinder.width;
//   trail.cylinder.size[3] = trail.cylinder.height;
//   trail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(trail.cylinder.color[1] / 255.0,trail.cylinder.color[2] / 255.0,trail.cylinder.color[3] / 255.0,trail.cylinder.specularCoefficient);
//   trail.cylinder.Extra = trail.cylinder.extra;
//   trail.R[1,1] = cos(trail.frame_a.phi);
//   trail.R[1,2] = sin(trail.frame_a.phi);
//   trail.R[2,1] = -sin(trail.frame_a.phi);
//   trail.R[2,2] = cos(trail.frame_a.phi);
//   trail.r0[1] = trail.R[1,1] * trail.r[1] + trail.R[1,2] * trail.r[2];
//   trail.r0[2] = trail.R[2,1] * trail.r[1] + trail.R[2,2] * trail.r[2];
//   trail.frame_a.x + trail.r0[1] = trail.frame_b.x;
//   trail.frame_a.y + trail.r0[2] = trail.frame_b.y;
//   trail.frame_a.phi = trail.frame_b.phi;
//   trail.frame_a.fx + trail.frame_b.fx = 0.0;
//   trail.frame_a.fy + trail.frame_b.fy = 0.0;
//   trail.frame_a.t + (trail.frame_b.t + ((-trail.r0[1]) * trail.frame_b.fy + trail.r0[2] * trail.frame_b.fx)) = 0.0;
//   bodyFront.frame_a.t + idealWheelFront.frame_a.t + trail.frame_b.t = 0.0;
//   bodyFront.frame_a.fy + idealWheelFront.frame_a.fy + trail.frame_b.fy = 0.0;
//   bodyFront.frame_a.fx + idealWheelFront.frame_a.fx + trail.frame_b.fx = 0.0;
//   idealWheelFront.flange_a.tau = 0.0;
//   chassis.frame_a.t + bodyRear.frame_a.t + idealWheelRear.frame_a.t = 0.0;
//   chassis.frame_a.fy + bodyRear.frame_a.fy + idealWheelRear.frame_a.fy = 0.0;
//   chassis.frame_a.fx + bodyRear.frame_a.fx + idealWheelRear.frame_a.fx = 0.0;
//   chassis.frame_b.t + revolute.frame_a.t = 0.0;
//   chassis.frame_b.fy + revolute.frame_a.fy = 0.0;
//   chassis.frame_b.fx + revolute.frame_a.fx = 0.0;
//   idealWheelRear.flange_a.tau + engineTorque.flange.tau = 0.0;
//   revolute.frame_b.t + trail.frame_a.t = 0.0;
//   revolute.frame_b.fy + trail.frame_a.fy = 0.0;
//   revolute.frame_b.fx + trail.frame_a.fx = 0.0;
//   bodyFront.frame_a.x = idealWheelFront.frame_a.x;
//   bodyFront.frame_a.x = trail.frame_b.x;
//   bodyFront.frame_a.y = idealWheelFront.frame_a.y;
//   bodyFront.frame_a.y = trail.frame_b.y;
//   bodyFront.frame_a.phi = idealWheelFront.frame_a.phi;
//   bodyFront.frame_a.phi = trail.frame_b.phi;
//   bodyRear.frame_a.x = chassis.frame_a.x;
//   bodyRear.frame_a.x = idealWheelRear.frame_a.x;
//   bodyRear.frame_a.y = chassis.frame_a.y;
//   bodyRear.frame_a.y = idealWheelRear.frame_a.y;
//   bodyRear.frame_a.phi = chassis.frame_a.phi;
//   bodyRear.frame_a.phi = idealWheelRear.frame_a.phi;
//   chassis.frame_b.x = revolute.frame_a.x;
//   chassis.frame_b.y = revolute.frame_a.y;
//   chassis.frame_b.phi = revolute.frame_a.phi;
//   engineTorque.flange.phi = idealWheelRear.flange_a.phi;
//   revolute.frame_b.x = trail.frame_a.x;
//   revolute.frame_b.y = trail.frame_a.y;
//   revolute.frame_b.phi = trail.frame_a.phi;
// end PlanarMechanicsForTesting.Examples.SingleTrackWithEngine;
// "
// ""
// "function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 0.0000000000001 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = cos(u);
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\" y = sin(u);
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + (1.0 - e[1] * e[1]) * cos(angle),(e[1] * e[2] + -e[1] * e[2] * cos(angle)) - -e[3] * sin(angle),(e[1] * e[3] + -e[1] * e[3] * cos(angle)) - e[2] * sin(angle);(e[2] * e[1] + -e[2] * e[1] * cos(angle)) - e[3] * sin(angle),e[2] * e[2] + (1.0 - e[2] * e[2]) * cos(angle),(e[2] * e[3] + -e[2] * e[3] * cos(angle)) - -e[1] * sin(angle);(e[3] * e[1] + -e[3] * e[1] * cos(angle)) - -e[2] * sin(angle),(e[3] * e[2] + -e[3] * e[2] * cos(angle)) - e[1] * sin(angle),e[3] * e[3] + (1.0 - e[3] * e[3]) * cos(angle)],{e[1] * der_angle,e[2] * der_angle,e[3] * der_angle});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*T_REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*T_REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*T_REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*T_REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function PlanarMechanicsForTesting.Utilities.S_Func \"Models an S-Function\"
//   input Real x_min;
//   input Real x_max;
//   input Real y_min;
//   input Real y_max;
//   input Real x;
//   output Real y;
//   protected Real x2;
// algorithm
//   x2 := x + -x_max / 2.0 + -x_min / 2.0;
//   x2 := (2.0 * x2) / (x_max - x_min);
//   if x2 > 1.0 then
//     y := 1.0;
//   elseif x2 < -1.0 then
//     y := -1.0;
//   else
//     y := -0.5 * x2 ^ 3.0 + 1.5 * x2;
//   end if;
//   y := y * (y_max / 2.0 - y_min / 2.0);
//   y := y + y_max / 2.0 + y_min / 2.0;
// end PlanarMechanicsForTesting.Utilities.S_Func;
// 
// function PlanarMechanicsForTesting.Utilities.TripleS_Func \"Models a point-symmetric Triple S-Function\"
//   input Real x_max;
//   input Real x_sat;
//   input Real y_max;
//   input Real y_sat;
//   input Real x;
//   output Real y;
// algorithm
//   if x > x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(x_max,x_sat,y_max,y_sat,x);
//   elseif x < -x_max then
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,-x_sat,-y_max,-y_sat,x);
//   else
//     y := PlanarMechanicsForTesting.Utilities.S_Func(-x_max,x_max,-y_max,y_max,x);
//   end if;
// end PlanarMechanicsForTesting.Utilities.TripleS_Func;
// 
// class PlanarMechanicsForTesting.Examples.SimpleCarWithDifferentialGear
//   Real body.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 100.0 \"mass of the body\";
//   parameter Real body.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body.animate = true \"enable Animation\";
//   parameter String body.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body.sphere.r[1](quantity = \"Length\", unit = \"m\") = body.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[2](quantity = \"Length\", unit = \"m\") = body.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body.sphere.lengthDirection[1],body.sphere.lengthDirection[2],body.sphere.lengthDirection[3]});
//   protected Real body.sphere.e_x[1](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 1.0 else body.sphere.lengthDirection[1] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[2](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[2] / body.sphere.abs_n_x;
//   protected Real body.sphere.e_x[3](unit = \"1\") = if noEvent(body.sphere.abs_n_x < 0.0000000001) then 0.0 else body.sphere.lengthDirection[3] / body.sphere.abs_n_x;
//   protected Real body.sphere.n_z_aux[1](unit = \"1\") = body.sphere.e_x[2] * body.sphere.widthDirection[3] - body.sphere.e_x[3] * body.sphere.widthDirection[2];
//   protected Real body.sphere.n_z_aux[2](unit = \"1\") = body.sphere.e_x[3] * body.sphere.widthDirection[1] - body.sphere.e_x[1] * body.sphere.widthDirection[3];
//   protected Real body.sphere.n_z_aux[3](unit = \"1\") = body.sphere.e_x[1] * body.sphere.widthDirection[2] - body.sphere.e_x[2] * body.sphere.widthDirection[1];
//   protected Real body.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[1];
//   protected Real body.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[2];
//   protected Real body.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]},if noEvent(body.sphere.n_z_aux[1] ^ 2.0 + (body.sphere.n_z_aux[2] ^ 2.0 + body.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body.sphere.widthDirection[1],body.sphere.widthDirection[2],body.sphere.widthDirection[3]} else if noEvent(abs(body.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body.sphere.e_x[1],body.sphere.e_x[2],body.sphere.e_x[3]})[3];
//   protected output Real body.sphere.Form;
//   output Real body.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body.sphere.Material;
//   protected output Real body.sphere.Extra;
//   Real WheelJoint1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint1.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint1.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint1.N(quantity = \"Force\", unit = \"N\") = 1000.0 \"normal force\";
//   parameter Real WheelJoint1.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint1.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint1.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint1.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint1.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint1.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint1.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint1.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint1.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint1.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint1.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint1.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint1.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint1.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint1.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint1.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint1.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint1.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint1.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint1.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint1.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint1.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint1.r[1] ^ 2.0 + WheelJoint1.r[2] ^ 2.0);
//   final parameter Real WheelJoint1.e[1] = WheelJoint1.r[1] / WheelJoint1.l \"normalized direction\";
//   final parameter Real WheelJoint1.e[2] = WheelJoint1.r[2] / WheelJoint1.l \"normalized direction\";
//   parameter String WheelJoint1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-WheelJoint1.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint1.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint1.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint1.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Width of visual object\";
//   input Real WheelJoint1.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Height of visual object\";
//   input Real WheelJoint1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint1.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint1.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint1.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint1.cylinder.lengthDirection[1],WheelJoint1.cylinder.lengthDirection[2],WheelJoint1.cylinder.lengthDirection[3]});
//   protected Real WheelJoint1.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint1.cylinder.abs_n_x < 0.0000000001) then 1.0 else WheelJoint1.cylinder.lengthDirection[1] / WheelJoint1.cylinder.abs_n_x;
//   protected Real WheelJoint1.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint1.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint1.cylinder.lengthDirection[2] / WheelJoint1.cylinder.abs_n_x;
//   protected Real WheelJoint1.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint1.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint1.cylinder.lengthDirection[3] / WheelJoint1.cylinder.abs_n_x;
//   protected Real WheelJoint1.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint1.cylinder.e_x[2] * WheelJoint1.cylinder.widthDirection[3] - WheelJoint1.cylinder.e_x[3] * WheelJoint1.cylinder.widthDirection[2];
//   protected Real WheelJoint1.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint1.cylinder.e_x[3] * WheelJoint1.cylinder.widthDirection[1] - WheelJoint1.cylinder.e_x[1] * WheelJoint1.cylinder.widthDirection[3];
//   protected Real WheelJoint1.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint1.cylinder.e_x[1] * WheelJoint1.cylinder.widthDirection[2] - WheelJoint1.cylinder.e_x[2] * WheelJoint1.cylinder.widthDirection[1];
//   protected Real WheelJoint1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]},if noEvent(WheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.cylinder.widthDirection[1],WheelJoint1.cylinder.widthDirection[2],WheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]})[1];
//   protected Real WheelJoint1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]},if noEvent(WheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.cylinder.widthDirection[1],WheelJoint1.cylinder.widthDirection[2],WheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]})[2];
//   protected Real WheelJoint1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]},if noEvent(WheelJoint1.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint1.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.cylinder.widthDirection[1],WheelJoint1.cylinder.widthDirection[2],WheelJoint1.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.cylinder.e_x[1],WheelJoint1.cylinder.e_x[2],WheelJoint1.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint1.cylinder.Form;
//   output Real WheelJoint1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.cylinder.Material;
//   protected output Real WheelJoint1.cylinder.Extra;
//   parameter String WheelJoint1.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint1.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Length of visual object\";
//   input Real WheelJoint1.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint1.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint1.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint1.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint1.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint1.rim1.lengthDirection[1],WheelJoint1.rim1.lengthDirection[2],WheelJoint1.rim1.lengthDirection[3]});
//   protected Real WheelJoint1.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint1.rim1.abs_n_x < 0.0000000001) then 1.0 else WheelJoint1.rim1.lengthDirection[1] / WheelJoint1.rim1.abs_n_x;
//   protected Real WheelJoint1.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint1.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint1.rim1.lengthDirection[2] / WheelJoint1.rim1.abs_n_x;
//   protected Real WheelJoint1.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint1.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint1.rim1.lengthDirection[3] / WheelJoint1.rim1.abs_n_x;
//   protected Real WheelJoint1.rim1.n_z_aux[1](unit = \"1\") = WheelJoint1.rim1.e_x[2] * WheelJoint1.rim1.widthDirection[3] - WheelJoint1.rim1.e_x[3] * WheelJoint1.rim1.widthDirection[2];
//   protected Real WheelJoint1.rim1.n_z_aux[2](unit = \"1\") = WheelJoint1.rim1.e_x[3] * WheelJoint1.rim1.widthDirection[1] - WheelJoint1.rim1.e_x[1] * WheelJoint1.rim1.widthDirection[3];
//   protected Real WheelJoint1.rim1.n_z_aux[3](unit = \"1\") = WheelJoint1.rim1.e_x[1] * WheelJoint1.rim1.widthDirection[2] - WheelJoint1.rim1.e_x[2] * WheelJoint1.rim1.widthDirection[1];
//   protected Real WheelJoint1.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]},if noEvent(WheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim1.n_z_aux[2] ^ 2.0 + WheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.rim1.widthDirection[1],WheelJoint1.rim1.widthDirection[2],WheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]})[1];
//   protected Real WheelJoint1.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]},if noEvent(WheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim1.n_z_aux[2] ^ 2.0 + WheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.rim1.widthDirection[1],WheelJoint1.rim1.widthDirection[2],WheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]})[2];
//   protected Real WheelJoint1.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]},if noEvent(WheelJoint1.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim1.n_z_aux[2] ^ 2.0 + WheelJoint1.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.rim1.widthDirection[1],WheelJoint1.rim1.widthDirection[2],WheelJoint1.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.rim1.e_x[1],WheelJoint1.rim1.e_x[2],WheelJoint1.rim1.e_x[3]})[3];
//   protected output Real WheelJoint1.rim1.Form;
//   output Real WheelJoint1.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint1.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim1.Material;
//   protected output Real WheelJoint1.rim1.Extra;
//   parameter String WheelJoint1.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint1.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint1.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint1.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint1.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint1.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint1.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint1.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint1.radius \"Length of visual object\";
//   input Real WheelJoint1.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint1.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint1.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint1.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint1.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint1.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint1.rim2.lengthDirection[1],WheelJoint1.rim2.lengthDirection[2],WheelJoint1.rim2.lengthDirection[3]});
//   protected Real WheelJoint1.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint1.rim2.abs_n_x < 0.0000000001) then 1.0 else WheelJoint1.rim2.lengthDirection[1] / WheelJoint1.rim2.abs_n_x;
//   protected Real WheelJoint1.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint1.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint1.rim2.lengthDirection[2] / WheelJoint1.rim2.abs_n_x;
//   protected Real WheelJoint1.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint1.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint1.rim2.lengthDirection[3] / WheelJoint1.rim2.abs_n_x;
//   protected Real WheelJoint1.rim2.n_z_aux[1](unit = \"1\") = WheelJoint1.rim2.e_x[2] * WheelJoint1.rim2.widthDirection[3] - WheelJoint1.rim2.e_x[3] * WheelJoint1.rim2.widthDirection[2];
//   protected Real WheelJoint1.rim2.n_z_aux[2](unit = \"1\") = WheelJoint1.rim2.e_x[3] * WheelJoint1.rim2.widthDirection[1] - WheelJoint1.rim2.e_x[1] * WheelJoint1.rim2.widthDirection[3];
//   protected Real WheelJoint1.rim2.n_z_aux[3](unit = \"1\") = WheelJoint1.rim2.e_x[1] * WheelJoint1.rim2.widthDirection[2] - WheelJoint1.rim2.e_x[2] * WheelJoint1.rim2.widthDirection[1];
//   protected Real WheelJoint1.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]},if noEvent(WheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim2.n_z_aux[2] ^ 2.0 + WheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.rim2.widthDirection[1],WheelJoint1.rim2.widthDirection[2],WheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]})[1];
//   protected Real WheelJoint1.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]},if noEvent(WheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim2.n_z_aux[2] ^ 2.0 + WheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.rim2.widthDirection[1],WheelJoint1.rim2.widthDirection[2],WheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]})[2];
//   protected Real WheelJoint1.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]},if noEvent(WheelJoint1.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint1.rim2.n_z_aux[2] ^ 2.0 + WheelJoint1.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint1.rim2.widthDirection[1],WheelJoint1.rim2.widthDirection[2],WheelJoint1.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint1.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint1.rim2.e_x[1],WheelJoint1.rim2.e_x[2],WheelJoint1.rim2.e_x[3]})[3];
//   protected output Real WheelJoint1.rim2.Form;
//   output Real WheelJoint1.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint1.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint1.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint1.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint1.rim2.Material;
//   protected output Real WheelJoint1.rim2.Extra;
//   Real fixedTranslation1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation1.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation1.r[2](quantity = \"Length\", unit = \"m\") = 2.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation1.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation1.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation1.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation1.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation1.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation1.r[1] ^ 2.0 + fixedTranslation1.r[2] ^ 2.0);
//   parameter String fixedTranslation1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation1.r0[1] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation1.r0[2] / fixedTranslation1.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation1.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation1.l \"Length of visual object\";
//   input Real fixedTranslation1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation1.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation1.cylinder.lengthDirection[1],fixedTranslation1.cylinder.lengthDirection[2],fixedTranslation1.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation1.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation1.cylinder.lengthDirection[1] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[2] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation1.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation1.cylinder.lengthDirection[3] / fixedTranslation1.cylinder.abs_n_x;
//   protected Real fixedTranslation1.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[3] - fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[2];
//   protected Real fixedTranslation1.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation1.cylinder.e_x[3] * fixedTranslation1.cylinder.widthDirection[1] - fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[3];
//   protected Real fixedTranslation1.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation1.cylinder.e_x[1] * fixedTranslation1.cylinder.widthDirection[2] - fixedTranslation1.cylinder.e_x[2] * fixedTranslation1.cylinder.widthDirection[1];
//   protected Real fixedTranslation1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]},if noEvent(fixedTranslation1.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation1.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation1.cylinder.widthDirection[1],fixedTranslation1.cylinder.widthDirection[2],fixedTranslation1.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation1.cylinder.e_x[1],fixedTranslation1.cylinder.e_x[2],fixedTranslation1.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation1.cylinder.Form;
//   output Real fixedTranslation1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation1.cylinder.Material;
//   protected output Real fixedTranslation1.cylinder.Extra;
//   Real body1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 300.0 \"mass of the body\";
//   parameter Real body1.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.1 \"Inertia of the Body\";
//   parameter Real body1.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body1.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body1.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body1.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body1.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body1.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body1.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body1.animate = true \"enable Animation\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body1.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 0.0000000001) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real WheelJoint2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint2.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint2.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint2.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint2.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real WheelJoint2.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint2.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint2.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint2.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint2.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint2.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint2.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint2.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint2.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint2.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint2.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint2.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint2.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint2.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint2.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint2.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint2.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint2.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint2.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint2.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint2.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint2.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint2.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint2.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint2.r[1] ^ 2.0 + WheelJoint2.r[2] ^ 2.0);
//   final parameter Real WheelJoint2.e[1] = WheelJoint2.r[1] / WheelJoint2.l \"normalized direction\";
//   final parameter Real WheelJoint2.e[2] = WheelJoint2.r[2] / WheelJoint2.l \"normalized direction\";
//   parameter String WheelJoint2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-WheelJoint2.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint2.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint2.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint2.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Width of visual object\";
//   input Real WheelJoint2.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Height of visual object\";
//   input Real WheelJoint2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint2.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint2.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint2.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint2.cylinder.lengthDirection[1],WheelJoint2.cylinder.lengthDirection[2],WheelJoint2.cylinder.lengthDirection[3]});
//   protected Real WheelJoint2.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint2.cylinder.abs_n_x < 0.0000000001) then 1.0 else WheelJoint2.cylinder.lengthDirection[1] / WheelJoint2.cylinder.abs_n_x;
//   protected Real WheelJoint2.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint2.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint2.cylinder.lengthDirection[2] / WheelJoint2.cylinder.abs_n_x;
//   protected Real WheelJoint2.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint2.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint2.cylinder.lengthDirection[3] / WheelJoint2.cylinder.abs_n_x;
//   protected Real WheelJoint2.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint2.cylinder.e_x[2] * WheelJoint2.cylinder.widthDirection[3] - WheelJoint2.cylinder.e_x[3] * WheelJoint2.cylinder.widthDirection[2];
//   protected Real WheelJoint2.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint2.cylinder.e_x[3] * WheelJoint2.cylinder.widthDirection[1] - WheelJoint2.cylinder.e_x[1] * WheelJoint2.cylinder.widthDirection[3];
//   protected Real WheelJoint2.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint2.cylinder.e_x[1] * WheelJoint2.cylinder.widthDirection[2] - WheelJoint2.cylinder.e_x[2] * WheelJoint2.cylinder.widthDirection[1];
//   protected Real WheelJoint2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]},if noEvent(WheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.cylinder.widthDirection[1],WheelJoint2.cylinder.widthDirection[2],WheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]})[1];
//   protected Real WheelJoint2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]},if noEvent(WheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.cylinder.widthDirection[1],WheelJoint2.cylinder.widthDirection[2],WheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]})[2];
//   protected Real WheelJoint2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]},if noEvent(WheelJoint2.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint2.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.cylinder.widthDirection[1],WheelJoint2.cylinder.widthDirection[2],WheelJoint2.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.cylinder.e_x[1],WheelJoint2.cylinder.e_x[2],WheelJoint2.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint2.cylinder.Form;
//   output Real WheelJoint2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.cylinder.Material;
//   protected output Real WheelJoint2.cylinder.Extra;
//   parameter String WheelJoint2.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint2.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint2.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Length of visual object\";
//   input Real WheelJoint2.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint2.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint2.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint2.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint2.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint2.rim1.lengthDirection[1],WheelJoint2.rim1.lengthDirection[2],WheelJoint2.rim1.lengthDirection[3]});
//   protected Real WheelJoint2.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint2.rim1.abs_n_x < 0.0000000001) then 1.0 else WheelJoint2.rim1.lengthDirection[1] / WheelJoint2.rim1.abs_n_x;
//   protected Real WheelJoint2.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint2.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint2.rim1.lengthDirection[2] / WheelJoint2.rim1.abs_n_x;
//   protected Real WheelJoint2.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint2.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint2.rim1.lengthDirection[3] / WheelJoint2.rim1.abs_n_x;
//   protected Real WheelJoint2.rim1.n_z_aux[1](unit = \"1\") = WheelJoint2.rim1.e_x[2] * WheelJoint2.rim1.widthDirection[3] - WheelJoint2.rim1.e_x[3] * WheelJoint2.rim1.widthDirection[2];
//   protected Real WheelJoint2.rim1.n_z_aux[2](unit = \"1\") = WheelJoint2.rim1.e_x[3] * WheelJoint2.rim1.widthDirection[1] - WheelJoint2.rim1.e_x[1] * WheelJoint2.rim1.widthDirection[3];
//   protected Real WheelJoint2.rim1.n_z_aux[3](unit = \"1\") = WheelJoint2.rim1.e_x[1] * WheelJoint2.rim1.widthDirection[2] - WheelJoint2.rim1.e_x[2] * WheelJoint2.rim1.widthDirection[1];
//   protected Real WheelJoint2.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]},if noEvent(WheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim1.n_z_aux[2] ^ 2.0 + WheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.rim1.widthDirection[1],WheelJoint2.rim1.widthDirection[2],WheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]})[1];
//   protected Real WheelJoint2.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]},if noEvent(WheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim1.n_z_aux[2] ^ 2.0 + WheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.rim1.widthDirection[1],WheelJoint2.rim1.widthDirection[2],WheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]})[2];
//   protected Real WheelJoint2.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]},if noEvent(WheelJoint2.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim1.n_z_aux[2] ^ 2.0 + WheelJoint2.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.rim1.widthDirection[1],WheelJoint2.rim1.widthDirection[2],WheelJoint2.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.rim1.e_x[1],WheelJoint2.rim1.e_x[2],WheelJoint2.rim1.e_x[3]})[3];
//   protected output Real WheelJoint2.rim1.Form;
//   output Real WheelJoint2.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint2.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim1.Material;
//   protected output Real WheelJoint2.rim1.Extra;
//   parameter String WheelJoint2.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint2.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint2.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint2.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint2.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint2.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint2.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint2.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint2.radius \"Length of visual object\";
//   input Real WheelJoint2.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint2.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint2.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint2.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint2.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint2.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint2.rim2.lengthDirection[1],WheelJoint2.rim2.lengthDirection[2],WheelJoint2.rim2.lengthDirection[3]});
//   protected Real WheelJoint2.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint2.rim2.abs_n_x < 0.0000000001) then 1.0 else WheelJoint2.rim2.lengthDirection[1] / WheelJoint2.rim2.abs_n_x;
//   protected Real WheelJoint2.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint2.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint2.rim2.lengthDirection[2] / WheelJoint2.rim2.abs_n_x;
//   protected Real WheelJoint2.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint2.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint2.rim2.lengthDirection[3] / WheelJoint2.rim2.abs_n_x;
//   protected Real WheelJoint2.rim2.n_z_aux[1](unit = \"1\") = WheelJoint2.rim2.e_x[2] * WheelJoint2.rim2.widthDirection[3] - WheelJoint2.rim2.e_x[3] * WheelJoint2.rim2.widthDirection[2];
//   protected Real WheelJoint2.rim2.n_z_aux[2](unit = \"1\") = WheelJoint2.rim2.e_x[3] * WheelJoint2.rim2.widthDirection[1] - WheelJoint2.rim2.e_x[1] * WheelJoint2.rim2.widthDirection[3];
//   protected Real WheelJoint2.rim2.n_z_aux[3](unit = \"1\") = WheelJoint2.rim2.e_x[1] * WheelJoint2.rim2.widthDirection[2] - WheelJoint2.rim2.e_x[2] * WheelJoint2.rim2.widthDirection[1];
//   protected Real WheelJoint2.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]},if noEvent(WheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim2.n_z_aux[2] ^ 2.0 + WheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.rim2.widthDirection[1],WheelJoint2.rim2.widthDirection[2],WheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]})[1];
//   protected Real WheelJoint2.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]},if noEvent(WheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim2.n_z_aux[2] ^ 2.0 + WheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.rim2.widthDirection[1],WheelJoint2.rim2.widthDirection[2],WheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]})[2];
//   protected Real WheelJoint2.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]},if noEvent(WheelJoint2.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint2.rim2.n_z_aux[2] ^ 2.0 + WheelJoint2.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint2.rim2.widthDirection[1],WheelJoint2.rim2.widthDirection[2],WheelJoint2.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint2.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint2.rim2.e_x[1],WheelJoint2.rim2.e_x[2],WheelJoint2.rim2.e_x[3]})[3];
//   protected output Real WheelJoint2.rim2.Form;
//   output Real WheelJoint2.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint2.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint2.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint2.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint2.rim2.Material;
//   protected output Real WheelJoint2.rim2.Extra;
//   parameter Boolean constantTorque1.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real constantTorque1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real constantTorque1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real constantTorque1.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real constantTorque1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real constantTorque1.tau_constant(quantity = \"Torque\", unit = \"N.m\") = 25.0 \"Constant torque (if negative, torque is acting as load)\";
//   Real constantTorque1.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real inertia.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real inertia1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia1.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia1.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia1.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia1.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real fixedTranslation2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation2.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation2.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation2.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation2.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation2.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation2.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation2.r[1](quantity = \"Length\", unit = \"m\") = 0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation2.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation2.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation2.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation2.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation2.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation2.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation2.r[1] ^ 2.0 + fixedTranslation2.r[2] ^ 2.0);
//   parameter String fixedTranslation2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation2.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation2.r0[1] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation2.r0[2] / fixedTranslation2.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation2.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation2.l \"Length of visual object\";
//   input Real fixedTranslation2.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation2.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation2.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation2.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation2.cylinder.lengthDirection[1],fixedTranslation2.cylinder.lengthDirection[2],fixedTranslation2.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation2.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation2.cylinder.lengthDirection[1] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation2.cylinder.lengthDirection[2] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation2.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation2.cylinder.lengthDirection[3] / fixedTranslation2.cylinder.abs_n_x;
//   protected Real fixedTranslation2.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[3] - fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[2];
//   protected Real fixedTranslation2.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation2.cylinder.e_x[3] * fixedTranslation2.cylinder.widthDirection[1] - fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[3];
//   protected Real fixedTranslation2.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation2.cylinder.e_x[1] * fixedTranslation2.cylinder.widthDirection[2] - fixedTranslation2.cylinder.e_x[2] * fixedTranslation2.cylinder.widthDirection[1];
//   protected Real fixedTranslation2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]},if noEvent(fixedTranslation2.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation2.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation2.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation2.cylinder.widthDirection[1],fixedTranslation2.cylinder.widthDirection[2],fixedTranslation2.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation2.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation2.cylinder.e_x[1],fixedTranslation2.cylinder.e_x[2],fixedTranslation2.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation2.cylinder.Form;
//   output Real fixedTranslation2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation2.cylinder.Material;
//   protected output Real fixedTranslation2.cylinder.Extra;
//   Real fixedTranslation3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation3.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation3.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation3.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation3.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation3.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation3.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation3.r[1](quantity = \"Length\", unit = \"m\") = -0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation3.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation3.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation3.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation3.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation3.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation3.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation3.r[1] ^ 2.0 + fixedTranslation3.r[2] ^ 2.0);
//   parameter String fixedTranslation3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation3.r0[1] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation3.r0[2] / fixedTranslation3.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation3.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation3.l \"Length of visual object\";
//   input Real fixedTranslation3.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation3.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation3.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation3.cylinder.lengthDirection[1],fixedTranslation3.cylinder.lengthDirection[2],fixedTranslation3.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation3.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation3.cylinder.lengthDirection[1] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation3.cylinder.lengthDirection[2] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation3.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation3.cylinder.lengthDirection[3] / fixedTranslation3.cylinder.abs_n_x;
//   protected Real fixedTranslation3.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[3] - fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[2];
//   protected Real fixedTranslation3.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation3.cylinder.e_x[3] * fixedTranslation3.cylinder.widthDirection[1] - fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[3];
//   protected Real fixedTranslation3.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation3.cylinder.e_x[1] * fixedTranslation3.cylinder.widthDirection[2] - fixedTranslation3.cylinder.e_x[2] * fixedTranslation3.cylinder.widthDirection[1];
//   protected Real fixedTranslation3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]},if noEvent(fixedTranslation3.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation3.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation3.cylinder.widthDirection[1],fixedTranslation3.cylinder.widthDirection[2],fixedTranslation3.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation3.cylinder.e_x[1],fixedTranslation3.cylinder.e_x[2],fixedTranslation3.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation3.cylinder.Form;
//   output Real fixedTranslation3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation3.cylinder.Material;
//   protected output Real fixedTranslation3.cylinder.Extra;
//   Real WheelJoint3.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint3.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint3.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint3.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint3.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint3.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint3.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint3.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint3.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint3.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint3.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint3.N(quantity = \"Force\", unit = \"N\") = 1500.0 \"normal force\";
//   parameter Real WheelJoint3.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint3.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint3.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint3.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint3.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint3.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint3.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint3.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint3.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint3.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint3.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint3.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint3.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint3.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint3.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint3.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint3.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint3.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint3.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint3.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint3.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint3.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint3.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint3.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint3.r[1] ^ 2.0 + WheelJoint3.r[2] ^ 2.0);
//   final parameter Real WheelJoint3.e[1] = WheelJoint3.r[1] / WheelJoint3.l \"normalized direction\";
//   final parameter Real WheelJoint3.e[2] = WheelJoint3.r[2] / WheelJoint3.l \"normalized direction\";
//   parameter String WheelJoint3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint3.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-WheelJoint3.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint3.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint3.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint3.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Width of visual object\";
//   input Real WheelJoint3.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Height of visual object\";
//   input Real WheelJoint3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint3.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint3.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint3.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint3.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint3.cylinder.lengthDirection[1],WheelJoint3.cylinder.lengthDirection[2],WheelJoint3.cylinder.lengthDirection[3]});
//   protected Real WheelJoint3.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint3.cylinder.abs_n_x < 0.0000000001) then 1.0 else WheelJoint3.cylinder.lengthDirection[1] / WheelJoint3.cylinder.abs_n_x;
//   protected Real WheelJoint3.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint3.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint3.cylinder.lengthDirection[2] / WheelJoint3.cylinder.abs_n_x;
//   protected Real WheelJoint3.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint3.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint3.cylinder.lengthDirection[3] / WheelJoint3.cylinder.abs_n_x;
//   protected Real WheelJoint3.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint3.cylinder.e_x[2] * WheelJoint3.cylinder.widthDirection[3] - WheelJoint3.cylinder.e_x[3] * WheelJoint3.cylinder.widthDirection[2];
//   protected Real WheelJoint3.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint3.cylinder.e_x[3] * WheelJoint3.cylinder.widthDirection[1] - WheelJoint3.cylinder.e_x[1] * WheelJoint3.cylinder.widthDirection[3];
//   protected Real WheelJoint3.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint3.cylinder.e_x[1] * WheelJoint3.cylinder.widthDirection[2] - WheelJoint3.cylinder.e_x[2] * WheelJoint3.cylinder.widthDirection[1];
//   protected Real WheelJoint3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]},if noEvent(WheelJoint3.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint3.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.cylinder.widthDirection[1],WheelJoint3.cylinder.widthDirection[2],WheelJoint3.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]})[1];
//   protected Real WheelJoint3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]},if noEvent(WheelJoint3.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint3.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.cylinder.widthDirection[1],WheelJoint3.cylinder.widthDirection[2],WheelJoint3.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]})[2];
//   protected Real WheelJoint3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]},if noEvent(WheelJoint3.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint3.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint3.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.cylinder.widthDirection[1],WheelJoint3.cylinder.widthDirection[2],WheelJoint3.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint3.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.cylinder.e_x[1],WheelJoint3.cylinder.e_x[2],WheelJoint3.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint3.cylinder.Form;
//   output Real WheelJoint3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.cylinder.Material;
//   protected output Real WheelJoint3.cylinder.Extra;
//   parameter String WheelJoint3.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint3.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint3.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Length of visual object\";
//   input Real WheelJoint3.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint3.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint3.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint3.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint3.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint3.rim1.lengthDirection[1],WheelJoint3.rim1.lengthDirection[2],WheelJoint3.rim1.lengthDirection[3]});
//   protected Real WheelJoint3.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint3.rim1.abs_n_x < 0.0000000001) then 1.0 else WheelJoint3.rim1.lengthDirection[1] / WheelJoint3.rim1.abs_n_x;
//   protected Real WheelJoint3.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint3.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint3.rim1.lengthDirection[2] / WheelJoint3.rim1.abs_n_x;
//   protected Real WheelJoint3.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint3.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint3.rim1.lengthDirection[3] / WheelJoint3.rim1.abs_n_x;
//   protected Real WheelJoint3.rim1.n_z_aux[1](unit = \"1\") = WheelJoint3.rim1.e_x[2] * WheelJoint3.rim1.widthDirection[3] - WheelJoint3.rim1.e_x[3] * WheelJoint3.rim1.widthDirection[2];
//   protected Real WheelJoint3.rim1.n_z_aux[2](unit = \"1\") = WheelJoint3.rim1.e_x[3] * WheelJoint3.rim1.widthDirection[1] - WheelJoint3.rim1.e_x[1] * WheelJoint3.rim1.widthDirection[3];
//   protected Real WheelJoint3.rim1.n_z_aux[3](unit = \"1\") = WheelJoint3.rim1.e_x[1] * WheelJoint3.rim1.widthDirection[2] - WheelJoint3.rim1.e_x[2] * WheelJoint3.rim1.widthDirection[1];
//   protected Real WheelJoint3.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]},if noEvent(WheelJoint3.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim1.n_z_aux[2] ^ 2.0 + WheelJoint3.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.rim1.widthDirection[1],WheelJoint3.rim1.widthDirection[2],WheelJoint3.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]})[1];
//   protected Real WheelJoint3.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]},if noEvent(WheelJoint3.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim1.n_z_aux[2] ^ 2.0 + WheelJoint3.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.rim1.widthDirection[1],WheelJoint3.rim1.widthDirection[2],WheelJoint3.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]})[2];
//   protected Real WheelJoint3.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]},if noEvent(WheelJoint3.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim1.n_z_aux[2] ^ 2.0 + WheelJoint3.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.rim1.widthDirection[1],WheelJoint3.rim1.widthDirection[2],WheelJoint3.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.rim1.e_x[1],WheelJoint3.rim1.e_x[2],WheelJoint3.rim1.e_x[3]})[3];
//   protected output Real WheelJoint3.rim1.Form;
//   output Real WheelJoint3.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint3.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim1.Material;
//   protected output Real WheelJoint3.rim1.Extra;
//   parameter String WheelJoint3.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint3.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint3.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint3.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint3.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint3.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint3.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint3.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint3.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint3.radius \"Length of visual object\";
//   input Real WheelJoint3.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint3.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint3.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint3.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint3.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint3.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint3.rim2.lengthDirection[1],WheelJoint3.rim2.lengthDirection[2],WheelJoint3.rim2.lengthDirection[3]});
//   protected Real WheelJoint3.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint3.rim2.abs_n_x < 0.0000000001) then 1.0 else WheelJoint3.rim2.lengthDirection[1] / WheelJoint3.rim2.abs_n_x;
//   protected Real WheelJoint3.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint3.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint3.rim2.lengthDirection[2] / WheelJoint3.rim2.abs_n_x;
//   protected Real WheelJoint3.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint3.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint3.rim2.lengthDirection[3] / WheelJoint3.rim2.abs_n_x;
//   protected Real WheelJoint3.rim2.n_z_aux[1](unit = \"1\") = WheelJoint3.rim2.e_x[2] * WheelJoint3.rim2.widthDirection[3] - WheelJoint3.rim2.e_x[3] * WheelJoint3.rim2.widthDirection[2];
//   protected Real WheelJoint3.rim2.n_z_aux[2](unit = \"1\") = WheelJoint3.rim2.e_x[3] * WheelJoint3.rim2.widthDirection[1] - WheelJoint3.rim2.e_x[1] * WheelJoint3.rim2.widthDirection[3];
//   protected Real WheelJoint3.rim2.n_z_aux[3](unit = \"1\") = WheelJoint3.rim2.e_x[1] * WheelJoint3.rim2.widthDirection[2] - WheelJoint3.rim2.e_x[2] * WheelJoint3.rim2.widthDirection[1];
//   protected Real WheelJoint3.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]},if noEvent(WheelJoint3.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim2.n_z_aux[2] ^ 2.0 + WheelJoint3.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.rim2.widthDirection[1],WheelJoint3.rim2.widthDirection[2],WheelJoint3.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]})[1];
//   protected Real WheelJoint3.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]},if noEvent(WheelJoint3.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim2.n_z_aux[2] ^ 2.0 + WheelJoint3.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.rim2.widthDirection[1],WheelJoint3.rim2.widthDirection[2],WheelJoint3.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]})[2];
//   protected Real WheelJoint3.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]},if noEvent(WheelJoint3.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint3.rim2.n_z_aux[2] ^ 2.0 + WheelJoint3.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint3.rim2.widthDirection[1],WheelJoint3.rim2.widthDirection[2],WheelJoint3.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint3.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint3.rim2.e_x[1],WheelJoint3.rim2.e_x[2],WheelJoint3.rim2.e_x[3]})[3];
//   protected output Real WheelJoint3.rim2.Form;
//   output Real WheelJoint3.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint3.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint3.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint3.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint3.rim2.Material;
//   protected output Real WheelJoint3.rim2.Extra;
//   Real inertia2.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia2.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia2.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia2.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia2.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia2.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia2.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = false, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real fixedTranslation4.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation4.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation4.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation4.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation4.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation4.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation4.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation4.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation4.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation4.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation4.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation4.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation4.r[1](quantity = \"Length\", unit = \"m\") = 0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation4.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation4.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation4.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation4.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation4.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation4.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation4.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation4.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation4.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation4.r[1] ^ 2.0 + fixedTranslation4.r[2] ^ 2.0);
//   parameter String fixedTranslation4.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation4.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation4.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation4.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation4.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation4.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation4.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation4.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation4.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation4.r0[1] / fixedTranslation4.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation4.r0[2] / fixedTranslation4.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation4.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation4.l \"Length of visual object\";
//   input Real fixedTranslation4.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation4.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation4.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation4.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation4.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation4.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation4.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation4.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation4.cylinder.lengthDirection[1],fixedTranslation4.cylinder.lengthDirection[2],fixedTranslation4.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation4.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation4.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation4.cylinder.lengthDirection[1] / fixedTranslation4.cylinder.abs_n_x;
//   protected Real fixedTranslation4.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation4.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation4.cylinder.lengthDirection[2] / fixedTranslation4.cylinder.abs_n_x;
//   protected Real fixedTranslation4.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation4.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation4.cylinder.lengthDirection[3] / fixedTranslation4.cylinder.abs_n_x;
//   protected Real fixedTranslation4.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation4.cylinder.e_x[2] * fixedTranslation4.cylinder.widthDirection[3] - fixedTranslation4.cylinder.e_x[3] * fixedTranslation4.cylinder.widthDirection[2];
//   protected Real fixedTranslation4.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation4.cylinder.e_x[3] * fixedTranslation4.cylinder.widthDirection[1] - fixedTranslation4.cylinder.e_x[1] * fixedTranslation4.cylinder.widthDirection[3];
//   protected Real fixedTranslation4.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation4.cylinder.e_x[1] * fixedTranslation4.cylinder.widthDirection[2] - fixedTranslation4.cylinder.e_x[2] * fixedTranslation4.cylinder.widthDirection[1];
//   protected Real fixedTranslation4.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]},if noEvent(fixedTranslation4.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation4.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation4.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation4.cylinder.widthDirection[1],fixedTranslation4.cylinder.widthDirection[2],fixedTranslation4.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation4.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation4.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]},if noEvent(fixedTranslation4.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation4.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation4.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation4.cylinder.widthDirection[1],fixedTranslation4.cylinder.widthDirection[2],fixedTranslation4.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation4.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation4.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]},if noEvent(fixedTranslation4.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation4.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation4.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation4.cylinder.widthDirection[1],fixedTranslation4.cylinder.widthDirection[2],fixedTranslation4.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation4.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation4.cylinder.e_x[1],fixedTranslation4.cylinder.e_x[2],fixedTranslation4.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation4.cylinder.Form;
//   output Real fixedTranslation4.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation4.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation4.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation4.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation4.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation4.cylinder.Material;
//   protected output Real fixedTranslation4.cylinder.Extra;
//   Real fixedTranslation5.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation5.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation5.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation5.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation5.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation5.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real fixedTranslation5.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real fixedTranslation5.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real fixedTranslation5.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real fixedTranslation5.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real fixedTranslation5.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real fixedTranslation5.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real fixedTranslation5.r[1](quantity = \"Length\", unit = \"m\") = -0.75 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real fixedTranslation5.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real fixedTranslation5.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation5.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real fixedTranslation5.R[1,1] \"Rotation matrix\";
//   Real fixedTranslation5.R[1,2] \"Rotation matrix\";
//   Real fixedTranslation5.R[2,1] \"Rotation matrix\";
//   Real fixedTranslation5.R[2,2] \"Rotation matrix\";
//   parameter Boolean fixedTranslation5.animate = true \"enable Animation\";
//   final parameter Real fixedTranslation5.l(quantity = \"Length\", unit = \"m\") = sqrt(fixedTranslation5.r[1] ^ 2.0 + fixedTranslation5.r[2] ^ 2.0);
//   parameter String fixedTranslation5.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real fixedTranslation5.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real fixedTranslation5.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation5.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation5.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real fixedTranslation5.cylinder.r[1](quantity = \"Length\", unit = \"m\") = fixedTranslation5.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation5.cylinder.r[2](quantity = \"Length\", unit = \"m\") = fixedTranslation5.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation5.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real fixedTranslation5.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.lengthDirection[1](unit = \"1\") = fixedTranslation5.r0[1] / fixedTranslation5.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.lengthDirection[2](unit = \"1\") = fixedTranslation5.r0[2] / fixedTranslation5.l \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real fixedTranslation5.cylinder.length(quantity = \"Length\", unit = \"m\") = fixedTranslation5.l \"Length of visual object\";
//   input Real fixedTranslation5.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real fixedTranslation5.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real fixedTranslation5.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real fixedTranslation5.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real fixedTranslation5.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real fixedTranslation5.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real fixedTranslation5.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real fixedTranslation5.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({fixedTranslation5.cylinder.lengthDirection[1],fixedTranslation5.cylinder.lengthDirection[2],fixedTranslation5.cylinder.lengthDirection[3]});
//   protected Real fixedTranslation5.cylinder.e_x[1](unit = \"1\") = if noEvent(fixedTranslation5.cylinder.abs_n_x < 0.0000000001) then 1.0 else fixedTranslation5.cylinder.lengthDirection[1] / fixedTranslation5.cylinder.abs_n_x;
//   protected Real fixedTranslation5.cylinder.e_x[2](unit = \"1\") = if noEvent(fixedTranslation5.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation5.cylinder.lengthDirection[2] / fixedTranslation5.cylinder.abs_n_x;
//   protected Real fixedTranslation5.cylinder.e_x[3](unit = \"1\") = if noEvent(fixedTranslation5.cylinder.abs_n_x < 0.0000000001) then 0.0 else fixedTranslation5.cylinder.lengthDirection[3] / fixedTranslation5.cylinder.abs_n_x;
//   protected Real fixedTranslation5.cylinder.n_z_aux[1](unit = \"1\") = fixedTranslation5.cylinder.e_x[2] * fixedTranslation5.cylinder.widthDirection[3] - fixedTranslation5.cylinder.e_x[3] * fixedTranslation5.cylinder.widthDirection[2];
//   protected Real fixedTranslation5.cylinder.n_z_aux[2](unit = \"1\") = fixedTranslation5.cylinder.e_x[3] * fixedTranslation5.cylinder.widthDirection[1] - fixedTranslation5.cylinder.e_x[1] * fixedTranslation5.cylinder.widthDirection[3];
//   protected Real fixedTranslation5.cylinder.n_z_aux[3](unit = \"1\") = fixedTranslation5.cylinder.e_x[1] * fixedTranslation5.cylinder.widthDirection[2] - fixedTranslation5.cylinder.e_x[2] * fixedTranslation5.cylinder.widthDirection[1];
//   protected Real fixedTranslation5.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]},if noEvent(fixedTranslation5.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation5.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation5.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation5.cylinder.widthDirection[1],fixedTranslation5.cylinder.widthDirection[2],fixedTranslation5.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation5.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]})[1];
//   protected Real fixedTranslation5.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]},if noEvent(fixedTranslation5.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation5.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation5.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation5.cylinder.widthDirection[1],fixedTranslation5.cylinder.widthDirection[2],fixedTranslation5.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation5.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]})[2];
//   protected Real fixedTranslation5.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]},if noEvent(fixedTranslation5.cylinder.n_z_aux[1] ^ 2.0 + (fixedTranslation5.cylinder.n_z_aux[2] ^ 2.0 + fixedTranslation5.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {fixedTranslation5.cylinder.widthDirection[1],fixedTranslation5.cylinder.widthDirection[2],fixedTranslation5.cylinder.widthDirection[3]} else if noEvent(abs(fixedTranslation5.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{fixedTranslation5.cylinder.e_x[1],fixedTranslation5.cylinder.e_x[2],fixedTranslation5.cylinder.e_x[3]})[3];
//   protected output Real fixedTranslation5.cylinder.Form;
//   output Real fixedTranslation5.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real fixedTranslation5.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real fixedTranslation5.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation5.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation5.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real fixedTranslation5.cylinder.Material;
//   protected output Real fixedTranslation5.cylinder.Extra;
//   Real WheelJoint4.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real WheelJoint4.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real WheelJoint4.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real WheelJoint4.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real WheelJoint4.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real WheelJoint4.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real WheelJoint4.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real WheelJoint4.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real WheelJoint4.radius(quantity = \"Length\", unit = \"m\") = 0.25 \"radius of the wheel\";
//   parameter Real WheelJoint4.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint4.r[2](quantity = \"Length\", unit = \"m\") = 1.0 \"driving direction of the wheel at angle phi = 0\";
//   parameter Real WheelJoint4.N(quantity = \"Force\", unit = \"N\") = 1000.0 \"normal force\";
//   parameter Real WheelJoint4.vAdhesion(quantity = \"Velocity\", unit = \"m/s\") = 0.1 \"adhesion velocity\";
//   parameter Real WheelJoint4.vSlide(quantity = \"Velocity\", unit = \"m/s\") = 0.3 \"sliding velocity\";
//   parameter Real WheelJoint4.mu_A = 1.0 \"friction coefficient at adhesion\";
//   parameter Real WheelJoint4.mu_S = 0.7 \"friction coefficient at sliding\";
//   Real WheelJoint4.e0[1] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint4.e0[2] \"normalized direction w.r.t inertial system\";
//   Real WheelJoint4.R[1,1] \"Rotation Matrix\";
//   Real WheelJoint4.R[1,2] \"Rotation Matrix\";
//   Real WheelJoint4.R[2,1] \"Rotation Matrix\";
//   Real WheelJoint4.R[2,2] \"Rotation Matrix\";
//   Real WheelJoint4.w_roll(quantity = \"AngularVelocity\", unit = \"rad/s\") \"roll velocity of wheel\";
//   Real WheelJoint4.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint4.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real WheelJoint4.v_lat(quantity = \"Velocity\", unit = \"m/s\") \"driving in lateral direction\";
//   Real WheelJoint4.v_long(quantity = \"Velocity\", unit = \"m/s\") \"velocity in longitudinal direction\";
//   Real WheelJoint4.v_slip_long(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in longitudinal direction\";
//   Real WheelJoint4.v_slip_lat(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity in lateral direction\";
//   Real WheelJoint4.v_slip(quantity = \"Velocity\", unit = \"m/s\") \"slip velocity\";
//   Real WheelJoint4.f(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint4.f_lat(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   Real WheelJoint4.f_long(quantity = \"Force\", unit = \"N\") \"longitudinal force\";
//   parameter Boolean WheelJoint4.animate = true \"enable Animation\";
//   parameter Boolean WheelJoint4.SimVis = false \"perform animation with SimVis\";
//   final parameter Real WheelJoint4.l(quantity = \"Length\", unit = \"m\") = sqrt(WheelJoint4.r[1] ^ 2.0 + WheelJoint4.r[2] ^ 2.0);
//   final parameter Real WheelJoint4.e[1] = WheelJoint4.r[1] / WheelJoint4.l \"normalized direction\";
//   final parameter Real WheelJoint4.e[2] = WheelJoint4.r[2] / WheelJoint4.l \"normalized direction\";
//   parameter String WheelJoint4.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint4.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.cylinder.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.cylinder.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.e0[2] * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-WheelJoint4.e0[1]) * 0.03 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.cylinder.lengthDirection[1](unit = \"1\") = -WheelJoint4.e0[2] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.lengthDirection[2](unit = \"1\") = WheelJoint4.e0[1] \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.06 \"Length of visual object\";
//   input Real WheelJoint4.cylinder.width(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Width of visual object\";
//   input Real WheelJoint4.cylinder.height(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Height of visual object\";
//   input Real WheelJoint4.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint4.cylinder.color[1] = 63.0 \"Color of shape\";
//   input Real WheelJoint4.cylinder.color[2] = 63.0 \"Color of shape\";
//   input Real WheelJoint4.cylinder.color[3] = 63.0 \"Color of shape\";
//   input Real WheelJoint4.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint4.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint4.cylinder.lengthDirection[1],WheelJoint4.cylinder.lengthDirection[2],WheelJoint4.cylinder.lengthDirection[3]});
//   protected Real WheelJoint4.cylinder.e_x[1](unit = \"1\") = if noEvent(WheelJoint4.cylinder.abs_n_x < 0.0000000001) then 1.0 else WheelJoint4.cylinder.lengthDirection[1] / WheelJoint4.cylinder.abs_n_x;
//   protected Real WheelJoint4.cylinder.e_x[2](unit = \"1\") = if noEvent(WheelJoint4.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint4.cylinder.lengthDirection[2] / WheelJoint4.cylinder.abs_n_x;
//   protected Real WheelJoint4.cylinder.e_x[3](unit = \"1\") = if noEvent(WheelJoint4.cylinder.abs_n_x < 0.0000000001) then 0.0 else WheelJoint4.cylinder.lengthDirection[3] / WheelJoint4.cylinder.abs_n_x;
//   protected Real WheelJoint4.cylinder.n_z_aux[1](unit = \"1\") = WheelJoint4.cylinder.e_x[2] * WheelJoint4.cylinder.widthDirection[3] - WheelJoint4.cylinder.e_x[3] * WheelJoint4.cylinder.widthDirection[2];
//   protected Real WheelJoint4.cylinder.n_z_aux[2](unit = \"1\") = WheelJoint4.cylinder.e_x[3] * WheelJoint4.cylinder.widthDirection[1] - WheelJoint4.cylinder.e_x[1] * WheelJoint4.cylinder.widthDirection[3];
//   protected Real WheelJoint4.cylinder.n_z_aux[3](unit = \"1\") = WheelJoint4.cylinder.e_x[1] * WheelJoint4.cylinder.widthDirection[2] - WheelJoint4.cylinder.e_x[2] * WheelJoint4.cylinder.widthDirection[1];
//   protected Real WheelJoint4.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]},if noEvent(WheelJoint4.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint4.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint4.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.cylinder.widthDirection[1],WheelJoint4.cylinder.widthDirection[2],WheelJoint4.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint4.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]})[1];
//   protected Real WheelJoint4.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]},if noEvent(WheelJoint4.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint4.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint4.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.cylinder.widthDirection[1],WheelJoint4.cylinder.widthDirection[2],WheelJoint4.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint4.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]})[2];
//   protected Real WheelJoint4.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]},if noEvent(WheelJoint4.cylinder.n_z_aux[1] ^ 2.0 + (WheelJoint4.cylinder.n_z_aux[2] ^ 2.0 + WheelJoint4.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.cylinder.widthDirection[1],WheelJoint4.cylinder.widthDirection[2],WheelJoint4.cylinder.widthDirection[3]} else if noEvent(abs(WheelJoint4.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.cylinder.e_x[1],WheelJoint4.cylinder.e_x[2],WheelJoint4.cylinder.e_x[3]})[3];
//   protected output Real WheelJoint4.cylinder.Form;
//   output Real WheelJoint4.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint4.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.cylinder.Material;
//   protected output Real WheelJoint4.cylinder.Extra;
//   parameter String WheelJoint4.rim1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint4.rim1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim1.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim1.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim1.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim1.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint4.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim1.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim1.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Length of visual object\";
//   input Real WheelJoint4.rim1.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint4.rim1.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint4.rim1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint4.rim1.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim1.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim1.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim1.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint4.rim1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint4.rim1.lengthDirection[1],WheelJoint4.rim1.lengthDirection[2],WheelJoint4.rim1.lengthDirection[3]});
//   protected Real WheelJoint4.rim1.e_x[1](unit = \"1\") = if noEvent(WheelJoint4.rim1.abs_n_x < 0.0000000001) then 1.0 else WheelJoint4.rim1.lengthDirection[1] / WheelJoint4.rim1.abs_n_x;
//   protected Real WheelJoint4.rim1.e_x[2](unit = \"1\") = if noEvent(WheelJoint4.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint4.rim1.lengthDirection[2] / WheelJoint4.rim1.abs_n_x;
//   protected Real WheelJoint4.rim1.e_x[3](unit = \"1\") = if noEvent(WheelJoint4.rim1.abs_n_x < 0.0000000001) then 0.0 else WheelJoint4.rim1.lengthDirection[3] / WheelJoint4.rim1.abs_n_x;
//   protected Real WheelJoint4.rim1.n_z_aux[1](unit = \"1\") = WheelJoint4.rim1.e_x[2] * WheelJoint4.rim1.widthDirection[3] - WheelJoint4.rim1.e_x[3] * WheelJoint4.rim1.widthDirection[2];
//   protected Real WheelJoint4.rim1.n_z_aux[2](unit = \"1\") = WheelJoint4.rim1.e_x[3] * WheelJoint4.rim1.widthDirection[1] - WheelJoint4.rim1.e_x[1] * WheelJoint4.rim1.widthDirection[3];
//   protected Real WheelJoint4.rim1.n_z_aux[3](unit = \"1\") = WheelJoint4.rim1.e_x[1] * WheelJoint4.rim1.widthDirection[2] - WheelJoint4.rim1.e_x[2] * WheelJoint4.rim1.widthDirection[1];
//   protected Real WheelJoint4.rim1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]},if noEvent(WheelJoint4.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim1.n_z_aux[2] ^ 2.0 + WheelJoint4.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.rim1.widthDirection[1],WheelJoint4.rim1.widthDirection[2],WheelJoint4.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]})[1];
//   protected Real WheelJoint4.rim1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]},if noEvent(WheelJoint4.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim1.n_z_aux[2] ^ 2.0 + WheelJoint4.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.rim1.widthDirection[1],WheelJoint4.rim1.widthDirection[2],WheelJoint4.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]})[2];
//   protected Real WheelJoint4.rim1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]},if noEvent(WheelJoint4.rim1.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim1.n_z_aux[2] ^ 2.0 + WheelJoint4.rim1.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.rim1.widthDirection[1],WheelJoint4.rim1.widthDirection[2],WheelJoint4.rim1.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim1.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.rim1.e_x[1],WheelJoint4.rim1.e_x[2],WheelJoint4.rim1.e_x[3]})[3];
//   protected output Real WheelJoint4.rim1.Form;
//   output Real WheelJoint4.rim1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint4.rim1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim1.Material;
//   protected output Real WheelJoint4.rim1.Extra;
//   parameter String WheelJoint4.rim2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real WheelJoint4.rim2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real WheelJoint4.rim2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real WheelJoint4.rim2.r[1](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim2.r[2](quantity = \"Length\", unit = \"m\") = WheelJoint4.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim2.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real WheelJoint4.rim2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim2.r_shape[3](quantity = \"Length\", unit = \"m\") = -WheelJoint4.radius \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real WheelJoint4.rim2.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real WheelJoint4.rim2.length(quantity = \"Length\", unit = \"m\") = 2.0 * WheelJoint4.radius \"Length of visual object\";
//   input Real WheelJoint4.rim2.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real WheelJoint4.rim2.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real WheelJoint4.rim2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real WheelJoint4.rim2.color[1] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim2.color[2] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim2.color[3] = 195.0 \"Color of shape\";
//   input Real WheelJoint4.rim2.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real WheelJoint4.rim2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({WheelJoint4.rim2.lengthDirection[1],WheelJoint4.rim2.lengthDirection[2],WheelJoint4.rim2.lengthDirection[3]});
//   protected Real WheelJoint4.rim2.e_x[1](unit = \"1\") = if noEvent(WheelJoint4.rim2.abs_n_x < 0.0000000001) then 1.0 else WheelJoint4.rim2.lengthDirection[1] / WheelJoint4.rim2.abs_n_x;
//   protected Real WheelJoint4.rim2.e_x[2](unit = \"1\") = if noEvent(WheelJoint4.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint4.rim2.lengthDirection[2] / WheelJoint4.rim2.abs_n_x;
//   protected Real WheelJoint4.rim2.e_x[3](unit = \"1\") = if noEvent(WheelJoint4.rim2.abs_n_x < 0.0000000001) then 0.0 else WheelJoint4.rim2.lengthDirection[3] / WheelJoint4.rim2.abs_n_x;
//   protected Real WheelJoint4.rim2.n_z_aux[1](unit = \"1\") = WheelJoint4.rim2.e_x[2] * WheelJoint4.rim2.widthDirection[3] - WheelJoint4.rim2.e_x[3] * WheelJoint4.rim2.widthDirection[2];
//   protected Real WheelJoint4.rim2.n_z_aux[2](unit = \"1\") = WheelJoint4.rim2.e_x[3] * WheelJoint4.rim2.widthDirection[1] - WheelJoint4.rim2.e_x[1] * WheelJoint4.rim2.widthDirection[3];
//   protected Real WheelJoint4.rim2.n_z_aux[3](unit = \"1\") = WheelJoint4.rim2.e_x[1] * WheelJoint4.rim2.widthDirection[2] - WheelJoint4.rim2.e_x[2] * WheelJoint4.rim2.widthDirection[1];
//   protected Real WheelJoint4.rim2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]},if noEvent(WheelJoint4.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim2.n_z_aux[2] ^ 2.0 + WheelJoint4.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.rim2.widthDirection[1],WheelJoint4.rim2.widthDirection[2],WheelJoint4.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]})[1];
//   protected Real WheelJoint4.rim2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]},if noEvent(WheelJoint4.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim2.n_z_aux[2] ^ 2.0 + WheelJoint4.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.rim2.widthDirection[1],WheelJoint4.rim2.widthDirection[2],WheelJoint4.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]})[2];
//   protected Real WheelJoint4.rim2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]},if noEvent(WheelJoint4.rim2.n_z_aux[1] ^ 2.0 + (WheelJoint4.rim2.n_z_aux[2] ^ 2.0 + WheelJoint4.rim2.n_z_aux[3] ^ 2.0) > 0.000001) then {WheelJoint4.rim2.widthDirection[1],WheelJoint4.rim2.widthDirection[2],WheelJoint4.rim2.widthDirection[3]} else if noEvent(abs(WheelJoint4.rim2.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{WheelJoint4.rim2.e_x[1],WheelJoint4.rim2.e_x[2],WheelJoint4.rim2.e_x[3]})[3];
//   protected output Real WheelJoint4.rim2.Form;
//   output Real WheelJoint4.rim2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real WheelJoint4.rim2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real WheelJoint4.rim2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real WheelJoint4.rim2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real WheelJoint4.rim2.Material;
//   protected output Real WheelJoint4.rim2.Extra;
//   Real inertia3.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia3.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real inertia3.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real inertia3.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real inertia3.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.0 \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) inertia3.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real inertia3.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   Real inertia3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real inertia3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real body2.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real body2.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real body2.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real body2.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real body2.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real body2.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real body2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 100.0 \"mass of the body\";
//   parameter Real body2.I(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 1.0 \"Inertia of the Body\";
//   parameter Real body2.g[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   parameter Real body2.g[2](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0 \"local gravity acting on the mass\";
//   Real body2.f[1](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body2.f[2](quantity = \"Force\", unit = \"N\") \"force\";
//   Real body2.r[1](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body2.r[2](quantity = \"Length\", unit = \"m\") \"transl. position\";
//   Real body2.v[1](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body2.v[2](quantity = \"Velocity\", unit = \"m/s\") \"velocity\";
//   Real body2.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body2.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"acceleration\";
//   Real body2.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"angular velocity\";
//   Real body2.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"angular acceleration\";
//   parameter Boolean body2.animate = true \"enable Animation\";
//   parameter String body2.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body2.sphere.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.r[1](quantity = \"Length\", unit = \"m\") = body2.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[2](quantity = \"Length\", unit = \"m\") = body2.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.075 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.length(quantity = \"Length\", unit = \"m\") = 0.15 \"Length of visual object\";
//   input Real body2.sphere.width(quantity = \"Length\", unit = \"m\") = 0.15 \"Width of visual object\";
//   input Real body2.sphere.height(quantity = \"Length\", unit = \"m\") = 0.15 \"Height of visual object\";
//   input Real body2.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body2.sphere.color[1] = 63.0 \"Color of shape\";
//   input Real body2.sphere.color[2] = 63.0 \"Color of shape\";
//   input Real body2.sphere.color[3] = 255.0 \"Color of shape\";
//   input Real body2.sphere.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body2.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body2.sphere.lengthDirection[1],body2.sphere.lengthDirection[2],body2.sphere.lengthDirection[3]});
//   protected Real body2.sphere.e_x[1](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 0.0000000001) then 1.0 else body2.sphere.lengthDirection[1] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[2](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 0.0000000001) then 0.0 else body2.sphere.lengthDirection[2] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[3](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 0.0000000001) then 0.0 else body2.sphere.lengthDirection[3] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.n_z_aux[1](unit = \"1\") = body2.sphere.e_x[2] * body2.sphere.widthDirection[3] - body2.sphere.e_x[3] * body2.sphere.widthDirection[2];
//   protected Real body2.sphere.n_z_aux[2](unit = \"1\") = body2.sphere.e_x[3] * body2.sphere.widthDirection[1] - body2.sphere.e_x[1] * body2.sphere.widthDirection[3];
//   protected Real body2.sphere.n_z_aux[3](unit = \"1\") = body2.sphere.e_x[1] * body2.sphere.widthDirection[2] - body2.sphere.e_x[2] * body2.sphere.widthDirection[1];
//   protected Real body2.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[1];
//   protected Real body2.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[2];
//   protected Real body2.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 0.000001) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[3];
//   protected output Real body2.sphere.Form;
//   output Real body2.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body2.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.Material;
//   protected output Real body2.sphere.Extra;
//   Real actuatedRevolute.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute.initialize = true \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.43633231299858;
//   parameter Real actuatedRevolute.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real actuatedRevolute.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real actuatedRevolute.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute.animate = true \"enable Animation\";
//   parameter Boolean actuatedRevolute.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedRevolute.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute.cylinder.lengthDirection[1],actuatedRevolute.cylinder.lengthDirection[2],actuatedRevolute.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 1.0 else actuatedRevolute.cylinder.lengthDirection[1] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute.cylinder.lengthDirection[2] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute.cylinder.lengthDirection[3] / actuatedRevolute.cylinder.abs_n_x;
//   protected Real actuatedRevolute.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[3] - actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[2];
//   protected Real actuatedRevolute.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute.cylinder.e_x[3] * actuatedRevolute.cylinder.widthDirection[1] - actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[3];
//   protected Real actuatedRevolute.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute.cylinder.e_x[1] * actuatedRevolute.cylinder.widthDirection[2] - actuatedRevolute.cylinder.e_x[2] * actuatedRevolute.cylinder.widthDirection[1];
//   protected Real actuatedRevolute.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]},if noEvent(actuatedRevolute.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute.cylinder.widthDirection[1],actuatedRevolute.cylinder.widthDirection[2],actuatedRevolute.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute.cylinder.e_x[1],actuatedRevolute.cylinder.e_x[2],actuatedRevolute.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute.cylinder.Form;
//   output Real actuatedRevolute.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute.cylinder.Material;
//   protected output Real actuatedRevolute.cylinder.Extra;
//   Real actuatedRevolute1.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute1.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute1.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute1.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute1.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute1.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real actuatedRevolute1.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real actuatedRevolute1.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real actuatedRevolute1.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real actuatedRevolute1.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real actuatedRevolute1.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real actuatedRevolute1.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Boolean actuatedRevolute1.initialize = false \"Initialize Position and Velocity\";
//   parameter Real actuatedRevolute1.phi_start(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0;
//   parameter Real actuatedRevolute1.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0;
//   Real actuatedRevolute1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Angular position\";
//   Real actuatedRevolute1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) \"Angular velocity\";
//   Real actuatedRevolute1.z(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Angular acceleration\";
//   Real actuatedRevolute1.t(quantity = \"Torque\", unit = \"N.m\") \"Torque\";
//   parameter Boolean actuatedRevolute1.animate = true \"enable Animation\";
//   parameter Boolean actuatedRevolute1.enforceStates = false \"enforce the state of the prismatic joint to become the state of the total system\";
//   Real actuatedRevolute1.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real actuatedRevolute1.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String actuatedRevolute1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real actuatedRevolute1.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real actuatedRevolute1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real actuatedRevolute1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = actuatedRevolute1.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = actuatedRevolute1.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real actuatedRevolute1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = -0.05 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real actuatedRevolute1.cylinder.length(quantity = \"Length\", unit = \"m\") = 0.2 \"Length of visual object\";
//   input Real actuatedRevolute1.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real actuatedRevolute1.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real actuatedRevolute1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real actuatedRevolute1.cylinder.color[1] = 255.0 \"Color of shape\";
//   input Real actuatedRevolute1.cylinder.color[2] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute1.cylinder.color[3] = 0.0 \"Color of shape\";
//   input Real actuatedRevolute1.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real actuatedRevolute1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({actuatedRevolute1.cylinder.lengthDirection[1],actuatedRevolute1.cylinder.lengthDirection[2],actuatedRevolute1.cylinder.lengthDirection[3]});
//   protected Real actuatedRevolute1.cylinder.e_x[1](unit = \"1\") = if noEvent(actuatedRevolute1.cylinder.abs_n_x < 0.0000000001) then 1.0 else actuatedRevolute1.cylinder.lengthDirection[1] / actuatedRevolute1.cylinder.abs_n_x;
//   protected Real actuatedRevolute1.cylinder.e_x[2](unit = \"1\") = if noEvent(actuatedRevolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute1.cylinder.lengthDirection[2] / actuatedRevolute1.cylinder.abs_n_x;
//   protected Real actuatedRevolute1.cylinder.e_x[3](unit = \"1\") = if noEvent(actuatedRevolute1.cylinder.abs_n_x < 0.0000000001) then 0.0 else actuatedRevolute1.cylinder.lengthDirection[3] / actuatedRevolute1.cylinder.abs_n_x;
//   protected Real actuatedRevolute1.cylinder.n_z_aux[1](unit = \"1\") = actuatedRevolute1.cylinder.e_x[2] * actuatedRevolute1.cylinder.widthDirection[3] - actuatedRevolute1.cylinder.e_x[3] * actuatedRevolute1.cylinder.widthDirection[2];
//   protected Real actuatedRevolute1.cylinder.n_z_aux[2](unit = \"1\") = actuatedRevolute1.cylinder.e_x[3] * actuatedRevolute1.cylinder.widthDirection[1] - actuatedRevolute1.cylinder.e_x[1] * actuatedRevolute1.cylinder.widthDirection[3];
//   protected Real actuatedRevolute1.cylinder.n_z_aux[3](unit = \"1\") = actuatedRevolute1.cylinder.e_x[1] * actuatedRevolute1.cylinder.widthDirection[2] - actuatedRevolute1.cylinder.e_x[2] * actuatedRevolute1.cylinder.widthDirection[1];
//   protected Real actuatedRevolute1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]},if noEvent(actuatedRevolute1.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute1.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute1.cylinder.widthDirection[1],actuatedRevolute1.cylinder.widthDirection[2],actuatedRevolute1.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]})[1];
//   protected Real actuatedRevolute1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]},if noEvent(actuatedRevolute1.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute1.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute1.cylinder.widthDirection[1],actuatedRevolute1.cylinder.widthDirection[2],actuatedRevolute1.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]})[2];
//   protected Real actuatedRevolute1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]},if noEvent(actuatedRevolute1.cylinder.n_z_aux[1] ^ 2.0 + (actuatedRevolute1.cylinder.n_z_aux[2] ^ 2.0 + actuatedRevolute1.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {actuatedRevolute1.cylinder.widthDirection[1],actuatedRevolute1.cylinder.widthDirection[2],actuatedRevolute1.cylinder.widthDirection[3]} else if noEvent(abs(actuatedRevolute1.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{actuatedRevolute1.cylinder.e_x[1],actuatedRevolute1.cylinder.e_x[2],actuatedRevolute1.cylinder.e_x[3]})[3];
//   protected output Real actuatedRevolute1.cylinder.Form;
//   output Real actuatedRevolute1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real actuatedRevolute1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real actuatedRevolute1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real actuatedRevolute1.cylinder.Material;
//   protected output Real actuatedRevolute1.cylinder.Extra;
//   parameter Boolean torque.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torque.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torque.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torque.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   input Real torque.tau \"Accelerating torque acting at flange (= -flange.tau)\";
//   output Real pulse.y \"Connector of Real output signal\";
//   parameter Real pulse.amplitude = 2.0 \"Amplitude of pulse\";
//   parameter Real pulse.width(min = 1e-60, max = 100.0) = 30.0 \"Width of pulse in % of period\";
//   parameter Real pulse.period(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = 2.0 \"Time for one period\";
//   parameter Real pulse.offset = 0.0 \"Offset of output signals\";
//   parameter Real pulse.startTime(quantity = \"Time\", unit = \"s\") = 1.0 \"Output = offset for time < startTime\";
//   protected Real pulse.T_width(quantity = \"Time\", unit = \"s\") = (pulse.period * pulse.width) / 100.0;
//   protected Real pulse.T0(quantity = \"Time\", unit = \"s\", start = pulse.startTime) \"Start time of current period\";
//   parameter Real differentialGear.idealPlanetary.ratio(start = 2.0) = -2.0 \"number of ring_teeth/sun_teeth (e.g. ratio=100/50)\";
//   Real differentialGear.idealPlanetary.sun.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.idealPlanetary.sun.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.idealPlanetary.carrier.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.idealPlanetary.carrier.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.idealPlanetary.ring.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.idealPlanetary.ring.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.flange_left.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.flange_left.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real differentialGear.flange_right.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real differentialGear.flange_right.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real leftTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real leftTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real leftTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real leftTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real leftTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real leftTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real leftTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real leftTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real leftTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real leftTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real leftTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real leftTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real leftTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real leftTrail.r[2](quantity = \"Length\", unit = \"m\") = -0.05 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real leftTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real leftTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real leftTrail.R[1,1] \"Rotation matrix\";
//   Real leftTrail.R[1,2] \"Rotation matrix\";
//   Real leftTrail.R[2,1] \"Rotation matrix\";
//   Real leftTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean leftTrail.animate = true \"enable Animation\";
//   final parameter Real leftTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(leftTrail.r[1] ^ 2.0 + leftTrail.r[2] ^ 2.0);
//   parameter String leftTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real leftTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real leftTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real leftTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real leftTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real leftTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = leftTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real leftTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = leftTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real leftTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real leftTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real leftTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real leftTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real leftTrail.cylinder.lengthDirection[1](unit = \"1\") = leftTrail.r0[1] / leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real leftTrail.cylinder.lengthDirection[2](unit = \"1\") = leftTrail.r0[2] / leftTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real leftTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real leftTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real leftTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real leftTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real leftTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = leftTrail.l \"Length of visual object\";
//   input Real leftTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real leftTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real leftTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real leftTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real leftTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real leftTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real leftTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real leftTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({leftTrail.cylinder.lengthDirection[1],leftTrail.cylinder.lengthDirection[2],leftTrail.cylinder.lengthDirection[3]});
//   protected Real leftTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(leftTrail.cylinder.abs_n_x < 0.0000000001) then 1.0 else leftTrail.cylinder.lengthDirection[1] / leftTrail.cylinder.abs_n_x;
//   protected Real leftTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(leftTrail.cylinder.abs_n_x < 0.0000000001) then 0.0 else leftTrail.cylinder.lengthDirection[2] / leftTrail.cylinder.abs_n_x;
//   protected Real leftTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(leftTrail.cylinder.abs_n_x < 0.0000000001) then 0.0 else leftTrail.cylinder.lengthDirection[3] / leftTrail.cylinder.abs_n_x;
//   protected Real leftTrail.cylinder.n_z_aux[1](unit = \"1\") = leftTrail.cylinder.e_x[2] * leftTrail.cylinder.widthDirection[3] - leftTrail.cylinder.e_x[3] * leftTrail.cylinder.widthDirection[2];
//   protected Real leftTrail.cylinder.n_z_aux[2](unit = \"1\") = leftTrail.cylinder.e_x[3] * leftTrail.cylinder.widthDirection[1] - leftTrail.cylinder.e_x[1] * leftTrail.cylinder.widthDirection[3];
//   protected Real leftTrail.cylinder.n_z_aux[3](unit = \"1\") = leftTrail.cylinder.e_x[1] * leftTrail.cylinder.widthDirection[2] - leftTrail.cylinder.e_x[2] * leftTrail.cylinder.widthDirection[1];
//   protected Real leftTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]},if noEvent(leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (leftTrail.cylinder.n_z_aux[2] ^ 2.0 + leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {leftTrail.cylinder.widthDirection[1],leftTrail.cylinder.widthDirection[2],leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(leftTrail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]})[1];
//   protected Real leftTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]},if noEvent(leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (leftTrail.cylinder.n_z_aux[2] ^ 2.0 + leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {leftTrail.cylinder.widthDirection[1],leftTrail.cylinder.widthDirection[2],leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(leftTrail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]})[2];
//   protected Real leftTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]},if noEvent(leftTrail.cylinder.n_z_aux[1] ^ 2.0 + (leftTrail.cylinder.n_z_aux[2] ^ 2.0 + leftTrail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {leftTrail.cylinder.widthDirection[1],leftTrail.cylinder.widthDirection[2],leftTrail.cylinder.widthDirection[3]} else if noEvent(abs(leftTrail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{leftTrail.cylinder.e_x[1],leftTrail.cylinder.e_x[2],leftTrail.cylinder.e_x[3]})[3];
//   protected output Real leftTrail.cylinder.Form;
//   output Real leftTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real leftTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real leftTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real leftTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real leftTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real leftTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real leftTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real leftTrail.cylinder.Material;
//   protected output Real leftTrail.cylinder.Extra;
//   Real rightTrail.frame_a.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rightTrail.frame_a.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rightTrail.frame_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rightTrail.frame_a.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rightTrail.frame_a.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rightTrail.frame_a.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   Real rightTrail.frame_b.x(quantity = \"Length\", unit = \"m\") \"x-position\";
//   Real rightTrail.frame_b.y(quantity = \"Length\", unit = \"m\") \"y-position\";
//   Real rightTrail.frame_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angle (clockwise)\";
//   Real rightTrail.frame_b.fx(quantity = \"Force\", unit = \"N\") \"force in x-direction\";
//   Real rightTrail.frame_b.fy(quantity = \"Force\", unit = \"N\") \"force in y-direction\";
//   Real rightTrail.frame_b.t(quantity = \"Torque\", unit = \"N.m\") \"torque (clockwise)\";
//   parameter Real rightTrail.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   parameter Real rightTrail.r[2](quantity = \"Length\", unit = \"m\") = -0.05 \"length of the rod resolved w.r.t to body frame at phi = 0\";
//   Real rightTrail.r0[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rightTrail.r0[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"length of the rod resolved w.r.t to inertal frame\";
//   Real rightTrail.R[1,1] \"Rotation matrix\";
//   Real rightTrail.R[1,2] \"Rotation matrix\";
//   Real rightTrail.R[2,1] \"Rotation matrix\";
//   Real rightTrail.R[2,2] \"Rotation matrix\";
//   parameter Boolean rightTrail.animate = true \"enable Animation\";
//   final parameter Real rightTrail.l(quantity = \"Length\", unit = \"m\") = sqrt(rightTrail.r[1] ^ 2.0 + rightTrail.r[2] ^ 2.0);
//   parameter String rightTrail.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rightTrail.cylinder.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real rightTrail.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rightTrail.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rightTrail.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rightTrail.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rightTrail.frame_a.x \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rightTrail.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rightTrail.frame_a.y \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rightTrail.cylinder.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rightTrail.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rightTrail.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rightTrail.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rightTrail.cylinder.lengthDirection[1](unit = \"1\") = rightTrail.r0[1] / rightTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real rightTrail.cylinder.lengthDirection[2](unit = \"1\") = rightTrail.r0[2] / rightTrail.l \"Vector in length direction, resolved in object frame\";
//   input Real rightTrail.cylinder.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real rightTrail.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rightTrail.cylinder.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rightTrail.cylinder.widthDirection[3](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rightTrail.cylinder.length(quantity = \"Length\", unit = \"m\") = rightTrail.l \"Length of visual object\";
//   input Real rightTrail.cylinder.width(quantity = \"Length\", unit = \"m\") = 0.1 \"Width of visual object\";
//   input Real rightTrail.cylinder.height(quantity = \"Length\", unit = \"m\") = 0.1 \"Height of visual object\";
//   input Real rightTrail.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rightTrail.cylinder.color[1] = 128.0 \"Color of shape\";
//   input Real rightTrail.cylinder.color[2] = 128.0 \"Color of shape\";
//   input Real rightTrail.cylinder.color[3] = 128.0 \"Color of shape\";
//   input Real rightTrail.cylinder.specularCoefficient = 0.5 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rightTrail.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rightTrail.cylinder.lengthDirection[1],rightTrail.cylinder.lengthDirection[2],rightTrail.cylinder.lengthDirection[3]});
//   protected Real rightTrail.cylinder.e_x[1](unit = \"1\") = if noEvent(rightTrail.cylinder.abs_n_x < 0.0000000001) then 1.0 else rightTrail.cylinder.lengthDirection[1] / rightTrail.cylinder.abs_n_x;
//   protected Real rightTrail.cylinder.e_x[2](unit = \"1\") = if noEvent(rightTrail.cylinder.abs_n_x < 0.0000000001) then 0.0 else rightTrail.cylinder.lengthDirection[2] / rightTrail.cylinder.abs_n_x;
//   protected Real rightTrail.cylinder.e_x[3](unit = \"1\") = if noEvent(rightTrail.cylinder.abs_n_x < 0.0000000001) then 0.0 else rightTrail.cylinder.lengthDirection[3] / rightTrail.cylinder.abs_n_x;
//   protected Real rightTrail.cylinder.n_z_aux[1](unit = \"1\") = rightTrail.cylinder.e_x[2] * rightTrail.cylinder.widthDirection[3] - rightTrail.cylinder.e_x[3] * rightTrail.cylinder.widthDirection[2];
//   protected Real rightTrail.cylinder.n_z_aux[2](unit = \"1\") = rightTrail.cylinder.e_x[3] * rightTrail.cylinder.widthDirection[1] - rightTrail.cylinder.e_x[1] * rightTrail.cylinder.widthDirection[3];
//   protected Real rightTrail.cylinder.n_z_aux[3](unit = \"1\") = rightTrail.cylinder.e_x[1] * rightTrail.cylinder.widthDirection[2] - rightTrail.cylinder.e_x[2] * rightTrail.cylinder.widthDirection[1];
//   protected Real rightTrail.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]},if noEvent(rightTrail.cylinder.n_z_aux[1] ^ 2.0 + (rightTrail.cylinder.n_z_aux[2] ^ 2.0 + rightTrail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {rightTrail.cylinder.widthDirection[1],rightTrail.cylinder.widthDirection[2],rightTrail.cylinder.widthDirection[3]} else if noEvent(abs(rightTrail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]})[1];
//   protected Real rightTrail.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]},if noEvent(rightTrail.cylinder.n_z_aux[1] ^ 2.0 + (rightTrail.cylinder.n_z_aux[2] ^ 2.0 + rightTrail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {rightTrail.cylinder.widthDirection[1],rightTrail.cylinder.widthDirection[2],rightTrail.cylinder.widthDirection[3]} else if noEvent(abs(rightTrail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]})[2];
//   protected Real rightTrail.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]},if noEvent(rightTrail.cylinder.n_z_aux[1] ^ 2.0 + (rightTrail.cylinder.n_z_aux[2] ^ 2.0 + rightTrail.cylinder.n_z_aux[3] ^ 2.0) > 0.000001) then {rightTrail.cylinder.widthDirection[1],rightTrail.cylinder.widthDirection[2],rightTrail.cylinder.widthDirection[3]} else if noEvent(abs(rightTrail.cylinder.e_x[1]) > 0.000001) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),0.0000000000001),{rightTrail.cylinder.e_x[1],rightTrail.cylinder.e_x[2],rightTrail.cylinder.e_x[3]})[3];
//   protected output Real rightTrail.cylinder.Form;
//   output Real rightTrail.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rightTrail.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rightTrail.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rightTrail.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rightTrail.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rightTrail.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rightTrail.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rightTrail.cylinder.Material;
//   protected output Real rightTrail.cylinder.Extra;
// initial equation
//   actuatedRevolute.phi = actuatedRevolute.phi_start;
//   actuatedRevolute.w = actuatedRevolute.w_start;
// equation
//   body.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body.sphere.shapeType);
//   body.sphere.rxvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_x[1] + body.sphere.R.T[2,1] * body.sphere.e_x[2] + body.sphere.R.T[3,1] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_x[1] + body.sphere.R.T[2,2] * body.sphere.e_x[2] + body.sphere.R.T[3,2] * body.sphere.e_x[3];
//   body.sphere.rxvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_x[1] + body.sphere.R.T[2,3] * body.sphere.e_x[2] + body.sphere.R.T[3,3] * body.sphere.e_x[3];
//   body.sphere.ryvisobj[1] = body.sphere.R.T[1,1] * body.sphere.e_y[1] + body.sphere.R.T[2,1] * body.sphere.e_y[2] + body.sphere.R.T[3,1] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[2] = body.sphere.R.T[1,2] * body.sphere.e_y[1] + body.sphere.R.T[2,2] * body.sphere.e_y[2] + body.sphere.R.T[3,2] * body.sphere.e_y[3];
//   body.sphere.ryvisobj[3] = body.sphere.R.T[1,3] * body.sphere.e_y[1] + body.sphere.R.T[2,3] * body.sphere.e_y[2] + body.sphere.R.T[3,3] * body.sphere.e_y[3];
//   body.sphere.rvisobj = body.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body.sphere.R.T[1,1],body.sphere.R.T[1,2],body.sphere.R.T[1,3]},{body.sphere.R.T[2,1],body.sphere.R.T[2,2],body.sphere.R.T[2,3]},{body.sphere.R.T[3,1],body.sphere.R.T[3,2],body.sphere.R.T[3,3]}},{body.sphere.r_shape[1],body.sphere.r_shape[2],body.sphere.r_shape[3]});
//   body.sphere.size[1] = body.sphere.length;
//   body.sphere.size[2] = body.sphere.width;
//   body.sphere.size[3] = body.sphere.height;
//   body.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body.sphere.color[1] / 255.0,body.sphere.color[2] / 255.0,body.sphere.color[3] / 255.0,body.sphere.specularCoefficient);
//   body.sphere.Extra = body.sphere.extra;
//   body.r[1] = body.frame_a.x;
//   body.r[2] = body.frame_a.y;
//   body.v[1] = der(body.r[1]);
//   body.v[2] = der(body.r[2]);
//   body.w = der(body.frame_a.phi);
//   body.a[1] = der(body.v[1]);
//   body.a[2] = der(body.v[2]);
//   body.z = der(body.w);
//   body.f[1] = body.frame_a.fx;
//   body.f[2] = body.frame_a.fy;
//   body.f[1] + body.g[1] * body.m = body.a[1] * body.m;
//   body.f[2] + body.g[2] * body.m = body.a[2] * body.m;
//   body.frame_a.t = body.I * body.z;
//   WheelJoint1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint1.cylinder.shapeType);
//   WheelJoint1.cylinder.rxvisobj[1] = WheelJoint1.cylinder.R.T[1,1] * WheelJoint1.cylinder.e_x[1] + WheelJoint1.cylinder.R.T[2,1] * WheelJoint1.cylinder.e_x[2] + WheelJoint1.cylinder.R.T[3,1] * WheelJoint1.cylinder.e_x[3];
//   WheelJoint1.cylinder.rxvisobj[2] = WheelJoint1.cylinder.R.T[1,2] * WheelJoint1.cylinder.e_x[1] + WheelJoint1.cylinder.R.T[2,2] * WheelJoint1.cylinder.e_x[2] + WheelJoint1.cylinder.R.T[3,2] * WheelJoint1.cylinder.e_x[3];
//   WheelJoint1.cylinder.rxvisobj[3] = WheelJoint1.cylinder.R.T[1,3] * WheelJoint1.cylinder.e_x[1] + WheelJoint1.cylinder.R.T[2,3] * WheelJoint1.cylinder.e_x[2] + WheelJoint1.cylinder.R.T[3,3] * WheelJoint1.cylinder.e_x[3];
//   WheelJoint1.cylinder.ryvisobj[1] = WheelJoint1.cylinder.R.T[1,1] * WheelJoint1.cylinder.e_y[1] + WheelJoint1.cylinder.R.T[2,1] * WheelJoint1.cylinder.e_y[2] + WheelJoint1.cylinder.R.T[3,1] * WheelJoint1.cylinder.e_y[3];
//   WheelJoint1.cylinder.ryvisobj[2] = WheelJoint1.cylinder.R.T[1,2] * WheelJoint1.cylinder.e_y[1] + WheelJoint1.cylinder.R.T[2,2] * WheelJoint1.cylinder.e_y[2] + WheelJoint1.cylinder.R.T[3,2] * WheelJoint1.cylinder.e_y[3];
//   WheelJoint1.cylinder.ryvisobj[3] = WheelJoint1.cylinder.R.T[1,3] * WheelJoint1.cylinder.e_y[1] + WheelJoint1.cylinder.R.T[2,3] * WheelJoint1.cylinder.e_y[2] + WheelJoint1.cylinder.R.T[3,3] * WheelJoint1.cylinder.e_y[3];
//   WheelJoint1.cylinder.rvisobj = WheelJoint1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint1.cylinder.R.T[1,1],WheelJoint1.cylinder.R.T[1,2],WheelJoint1.cylinder.R.T[1,3]},{WheelJoint1.cylinder.R.T[2,1],WheelJoint1.cylinder.R.T[2,2],WheelJoint1.cylinder.R.T[2,3]},{WheelJoint1.cylinder.R.T[3,1],WheelJoint1.cylinder.R.T[3,2],WheelJoint1.cylinder.R.T[3,3]}},{WheelJoint1.cylinder.r_shape[1],WheelJoint1.cylinder.r_shape[2],WheelJoint1.cylinder.r_shape[3]});
//   WheelJoint1.cylinder.size[1] = WheelJoint1.cylinder.length;
//   WheelJoint1.cylinder.size[2] = WheelJoint1.cylinder.width;
//   WheelJoint1.cylinder.size[3] = WheelJoint1.cylinder.height;
//   WheelJoint1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint1.cylinder.color[1] / 255.0,WheelJoint1.cylinder.color[2] / 255.0,WheelJoint1.cylinder.color[3] / 255.0,WheelJoint1.cylinder.specularCoefficient);
//   WheelJoint1.cylinder.Extra = WheelJoint1.cylinder.extra;
//   WheelJoint1.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint1.e0[2],WheelJoint1.e0[1],0.0},WheelJoint1.flange_a.phi,0.0);
//   WheelJoint1.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint1.rim1.shapeType);
//   WheelJoint1.rim1.rxvisobj[1] = WheelJoint1.rim1.R.T[1,1] * WheelJoint1.rim1.e_x[1] + WheelJoint1.rim1.R.T[2,1] * WheelJoint1.rim1.e_x[2] + WheelJoint1.rim1.R.T[3,1] * WheelJoint1.rim1.e_x[3];
//   WheelJoint1.rim1.rxvisobj[2] = WheelJoint1.rim1.R.T[1,2] * WheelJoint1.rim1.e_x[1] + WheelJoint1.rim1.R.T[2,2] * WheelJoint1.rim1.e_x[2] + WheelJoint1.rim1.R.T[3,2] * WheelJoint1.rim1.e_x[3];
//   WheelJoint1.rim1.rxvisobj[3] = WheelJoint1.rim1.R.T[1,3] * WheelJoint1.rim1.e_x[1] + WheelJoint1.rim1.R.T[2,3] * WheelJoint1.rim1.e_x[2] + WheelJoint1.rim1.R.T[3,3] * WheelJoint1.rim1.e_x[3];
//   WheelJoint1.rim1.ryvisobj[1] = WheelJoint1.rim1.R.T[1,1] * WheelJoint1.rim1.e_y[1] + WheelJoint1.rim1.R.T[2,1] * WheelJoint1.rim1.e_y[2] + WheelJoint1.rim1.R.T[3,1] * WheelJoint1.rim1.e_y[3];
//   WheelJoint1.rim1.ryvisobj[2] = WheelJoint1.rim1.R.T[1,2] * WheelJoint1.rim1.e_y[1] + WheelJoint1.rim1.R.T[2,2] * WheelJoint1.rim1.e_y[2] + WheelJoint1.rim1.R.T[3,2] * WheelJoint1.rim1.e_y[3];
//   WheelJoint1.rim1.ryvisobj[3] = WheelJoint1.rim1.R.T[1,3] * WheelJoint1.rim1.e_y[1] + WheelJoint1.rim1.R.T[2,3] * WheelJoint1.rim1.e_y[2] + WheelJoint1.rim1.R.T[3,3] * WheelJoint1.rim1.e_y[3];
//   WheelJoint1.rim1.rvisobj = WheelJoint1.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint1.rim1.R.T[1,1],WheelJoint1.rim1.R.T[1,2],WheelJoint1.rim1.R.T[1,3]},{WheelJoint1.rim1.R.T[2,1],WheelJoint1.rim1.R.T[2,2],WheelJoint1.rim1.R.T[2,3]},{WheelJoint1.rim1.R.T[3,1],WheelJoint1.rim1.R.T[3,2],WheelJoint1.rim1.R.T[3,3]}},{WheelJoint1.rim1.r_shape[1],WheelJoint1.rim1.r_shape[2],WheelJoint1.rim1.r_shape[3]});
//   WheelJoint1.rim1.size[1] = WheelJoint1.rim1.length;
//   WheelJoint1.rim1.size[2] = WheelJoint1.rim1.width;
//   WheelJoint1.rim1.size[3] = WheelJoint1.rim1.height;
//   WheelJoint1.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint1.rim1.color[1] / 255.0,WheelJoint1.rim1.color[2] / 255.0,WheelJoint1.rim1.color[3] / 255.0,WheelJoint1.rim1.specularCoefficient);
//   WheelJoint1.rim1.Extra = WheelJoint1.rim1.extra;
//   WheelJoint1.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint1.e0[2],WheelJoint1.e0[1],0.0},1.5707963267948966 + WheelJoint1.flange_a.phi,0.0);
//   WheelJoint1.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint1.rim2.shapeType);
//   WheelJoint1.rim2.rxvisobj[1] = WheelJoint1.rim2.R.T[1,1] * WheelJoint1.rim2.e_x[1] + WheelJoint1.rim2.R.T[2,1] * WheelJoint1.rim2.e_x[2] + WheelJoint1.rim2.R.T[3,1] * WheelJoint1.rim2.e_x[3];
//   WheelJoint1.rim2.rxvisobj[2] = WheelJoint1.rim2.R.T[1,2] * WheelJoint1.rim2.e_x[1] + WheelJoint1.rim2.R.T[2,2] * WheelJoint1.rim2.e_x[2] + WheelJoint1.rim2.R.T[3,2] * WheelJoint1.rim2.e_x[3];
//   WheelJoint1.rim2.rxvisobj[3] = WheelJoint1.rim2.R.T[1,3] * WheelJoint1.rim2.e_x[1] + WheelJoint1.rim2.R.T[2,3] * WheelJoint1.rim2.e_x[2] + WheelJoint1.rim2.R.T[3,3] * WheelJoint1.rim2.e_x[3];
//   WheelJoint1.rim2.ryvisobj[1] = WheelJoint1.rim2.R.T[1,1] * WheelJoint1.rim2.e_y[1] + WheelJoint1.rim2.R.T[2,1] * WheelJoint1.rim2.e_y[2] + WheelJoint1.rim2.R.T[3,1] * WheelJoint1.rim2.e_y[3];
//   WheelJoint1.rim2.ryvisobj[2] = WheelJoint1.rim2.R.T[1,2] * WheelJoint1.rim2.e_y[1] + WheelJoint1.rim2.R.T[2,2] * WheelJoint1.rim2.e_y[2] + WheelJoint1.rim2.R.T[3,2] * WheelJoint1.rim2.e_y[3];
//   WheelJoint1.rim2.ryvisobj[3] = WheelJoint1.rim2.R.T[1,3] * WheelJoint1.rim2.e_y[1] + WheelJoint1.rim2.R.T[2,3] * WheelJoint1.rim2.e_y[2] + WheelJoint1.rim2.R.T[3,3] * WheelJoint1.rim2.e_y[3];
//   WheelJoint1.rim2.rvisobj = WheelJoint1.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint1.rim2.R.T[1,1],WheelJoint1.rim2.R.T[1,2],WheelJoint1.rim2.R.T[1,3]},{WheelJoint1.rim2.R.T[2,1],WheelJoint1.rim2.R.T[2,2],WheelJoint1.rim2.R.T[2,3]},{WheelJoint1.rim2.R.T[3,1],WheelJoint1.rim2.R.T[3,2],WheelJoint1.rim2.R.T[3,3]}},{WheelJoint1.rim2.r_shape[1],WheelJoint1.rim2.r_shape[2],WheelJoint1.rim2.r_shape[3]});
//   WheelJoint1.rim2.size[1] = WheelJoint1.rim2.length;
//   WheelJoint1.rim2.size[2] = WheelJoint1.rim2.width;
//   WheelJoint1.rim2.size[3] = WheelJoint1.rim2.height;
//   WheelJoint1.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint1.rim2.color[1] / 255.0,WheelJoint1.rim2.color[2] / 255.0,WheelJoint1.rim2.color[3] / 255.0,WheelJoint1.rim2.specularCoefficient);
//   WheelJoint1.rim2.Extra = WheelJoint1.rim2.extra;
//   WheelJoint1.R[1,1] = cos(WheelJoint1.frame_a.phi);
//   WheelJoint1.R[1,2] = sin(WheelJoint1.frame_a.phi);
//   WheelJoint1.R[2,1] = -sin(WheelJoint1.frame_a.phi);
//   WheelJoint1.R[2,2] = cos(WheelJoint1.frame_a.phi);
//   WheelJoint1.e0[1] = WheelJoint1.R[1,1] * WheelJoint1.e[1] + WheelJoint1.R[1,2] * WheelJoint1.e[2];
//   WheelJoint1.e0[2] = WheelJoint1.R[2,1] * WheelJoint1.e[1] + WheelJoint1.R[2,2] * WheelJoint1.e[2];
//   WheelJoint1.v[1] = der(WheelJoint1.frame_a.x);
//   WheelJoint1.v[2] = der(WheelJoint1.frame_a.y);
//   WheelJoint1.w_roll = der(WheelJoint1.flange_a.phi);
//   WheelJoint1.v_long = WheelJoint1.v[1] * WheelJoint1.e0[1] + WheelJoint1.v[2] * WheelJoint1.e0[2];
//   WheelJoint1.v_lat = (-WheelJoint1.v[1]) * WheelJoint1.e0[2] + WheelJoint1.v[2] * WheelJoint1.e0[1];
//   WheelJoint1.v_slip_lat = WheelJoint1.v_lat;
//   WheelJoint1.v_slip_long = WheelJoint1.v_long - WheelJoint1.radius * WheelJoint1.w_roll;
//   WheelJoint1.v_slip = 0.0001 + sqrt(WheelJoint1.v_slip_long ^ 2.0 + WheelJoint1.v_slip_lat ^ 2.0);
//   (-WheelJoint1.f_long) * WheelJoint1.radius = WheelJoint1.flange_a.tau;
//   WheelJoint1.frame_a.t = 0.0;
//   WheelJoint1.f = WheelJoint1.N * PlanarMechanicsForTesting.Utilities.TripleS_Func(WheelJoint1.vAdhesion,WheelJoint1.vSlide,WheelJoint1.mu_A,WheelJoint1.mu_S,WheelJoint1.v_slip);
//   WheelJoint1.f_long = (WheelJoint1.f * WheelJoint1.v_slip_long) / WheelJoint1.v_slip;
//   WheelJoint1.f_lat = (WheelJoint1.f * WheelJoint1.v_slip_lat) / WheelJoint1.v_slip;
//   WheelJoint1.f_long = WheelJoint1.frame_a.fx * WheelJoint1.e0[1] + WheelJoint1.frame_a.fy * WheelJoint1.e0[2];
//   WheelJoint1.f_lat = WheelJoint1.frame_a.fy * WheelJoint1.e0[1] + (-WheelJoint1.frame_a.fx) * WheelJoint1.e0[2];
//   fixedTranslation1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.cylinder.shapeType);
//   fixedTranslation1.cylinder.rxvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.rxvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_x[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_x[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_x[3];
//   fixedTranslation1.cylinder.ryvisobj[1] = fixedTranslation1.cylinder.R.T[1,1] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,1] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,1] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[2] = fixedTranslation1.cylinder.R.T[1,2] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,2] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,2] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.ryvisobj[3] = fixedTranslation1.cylinder.R.T[1,3] * fixedTranslation1.cylinder.e_y[1] + fixedTranslation1.cylinder.R.T[2,3] * fixedTranslation1.cylinder.e_y[2] + fixedTranslation1.cylinder.R.T[3,3] * fixedTranslation1.cylinder.e_y[3];
//   fixedTranslation1.cylinder.rvisobj = fixedTranslation1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.cylinder.R.T[1,1],fixedTranslation1.cylinder.R.T[1,2],fixedTranslation1.cylinder.R.T[1,3]},{fixedTranslation1.cylinder.R.T[2,1],fixedTranslation1.cylinder.R.T[2,2],fixedTranslation1.cylinder.R.T[2,3]},{fixedTranslation1.cylinder.R.T[3,1],fixedTranslation1.cylinder.R.T[3,2],fixedTranslation1.cylinder.R.T[3,3]}},{fixedTranslation1.cylinder.r_shape[1],fixedTranslation1.cylinder.r_shape[2],fixedTranslation1.cylinder.r_shape[3]});
//   fixedTranslation1.cylinder.size[1] = fixedTranslation1.cylinder.length;
//   fixedTranslation1.cylinder.size[2] = fixedTranslation1.cylinder.width;
//   fixedTranslation1.cylinder.size[3] = fixedTranslation1.cylinder.height;
//   fixedTranslation1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.cylinder.color[1] / 255.0,fixedTranslation1.cylinder.color[2] / 255.0,fixedTranslation1.cylinder.color[3] / 255.0,fixedTranslation1.cylinder.specularCoefficient);
//   fixedTranslation1.cylinder.Extra = fixedTranslation1.cylinder.extra;
//   fixedTranslation1.R[1,1] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[1,2] = sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,1] = -sin(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.R[2,2] = cos(fixedTranslation1.frame_a.phi);
//   fixedTranslation1.r0[1] = fixedTranslation1.R[1,1] * fixedTranslation1.r[1] + fixedTranslation1.R[1,2] * fixedTranslation1.r[2];
//   fixedTranslation1.r0[2] = fixedTranslation1.R[2,1] * fixedTranslation1.r[1] + fixedTranslation1.R[2,2] * fixedTranslation1.r[2];
//   fixedTranslation1.frame_a.x + fixedTranslation1.r0[1] = fixedTranslation1.frame_b.x;
//   fixedTranslation1.frame_a.y + fixedTranslation1.r0[2] = fixedTranslation1.frame_b.y;
//   fixedTranslation1.frame_a.phi = fixedTranslation1.frame_b.phi;
//   fixedTranslation1.frame_a.fx + fixedTranslation1.frame_b.fx = 0.0;
//   fixedTranslation1.frame_a.fy + fixedTranslation1.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.t + (fixedTranslation1.frame_b.t + ((-fixedTranslation1.r0[1]) * fixedTranslation1.frame_b.fy + fixedTranslation1.r0[2] * fixedTranslation1.frame_b.fx)) = 0.0;
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3];
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3];
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3];
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3];
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r[1] = body1.frame_a.x;
//   body1.r[2] = body1.frame_a.y;
//   body1.v[1] = der(body1.r[1]);
//   body1.v[2] = der(body1.r[2]);
//   body1.w = der(body1.frame_a.phi);
//   body1.a[1] = der(body1.v[1]);
//   body1.a[2] = der(body1.v[2]);
//   body1.z = der(body1.w);
//   body1.f[1] = body1.frame_a.fx;
//   body1.f[2] = body1.frame_a.fy;
//   body1.f[1] + body1.g[1] * body1.m = body1.a[1] * body1.m;
//   body1.f[2] + body1.g[2] * body1.m = body1.a[2] * body1.m;
//   body1.frame_a.t = body1.I * body1.z;
//   WheelJoint2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint2.cylinder.shapeType);
//   WheelJoint2.cylinder.rxvisobj[1] = WheelJoint2.cylinder.R.T[1,1] * WheelJoint2.cylinder.e_x[1] + WheelJoint2.cylinder.R.T[2,1] * WheelJoint2.cylinder.e_x[2] + WheelJoint2.cylinder.R.T[3,1] * WheelJoint2.cylinder.e_x[3];
//   WheelJoint2.cylinder.rxvisobj[2] = WheelJoint2.cylinder.R.T[1,2] * WheelJoint2.cylinder.e_x[1] + WheelJoint2.cylinder.R.T[2,2] * WheelJoint2.cylinder.e_x[2] + WheelJoint2.cylinder.R.T[3,2] * WheelJoint2.cylinder.e_x[3];
//   WheelJoint2.cylinder.rxvisobj[3] = WheelJoint2.cylinder.R.T[1,3] * WheelJoint2.cylinder.e_x[1] + WheelJoint2.cylinder.R.T[2,3] * WheelJoint2.cylinder.e_x[2] + WheelJoint2.cylinder.R.T[3,3] * WheelJoint2.cylinder.e_x[3];
//   WheelJoint2.cylinder.ryvisobj[1] = WheelJoint2.cylinder.R.T[1,1] * WheelJoint2.cylinder.e_y[1] + WheelJoint2.cylinder.R.T[2,1] * WheelJoint2.cylinder.e_y[2] + WheelJoint2.cylinder.R.T[3,1] * WheelJoint2.cylinder.e_y[3];
//   WheelJoint2.cylinder.ryvisobj[2] = WheelJoint2.cylinder.R.T[1,2] * WheelJoint2.cylinder.e_y[1] + WheelJoint2.cylinder.R.T[2,2] * WheelJoint2.cylinder.e_y[2] + WheelJoint2.cylinder.R.T[3,2] * WheelJoint2.cylinder.e_y[3];
//   WheelJoint2.cylinder.ryvisobj[3] = WheelJoint2.cylinder.R.T[1,3] * WheelJoint2.cylinder.e_y[1] + WheelJoint2.cylinder.R.T[2,3] * WheelJoint2.cylinder.e_y[2] + WheelJoint2.cylinder.R.T[3,3] * WheelJoint2.cylinder.e_y[3];
//   WheelJoint2.cylinder.rvisobj = WheelJoint2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint2.cylinder.R.T[1,1],WheelJoint2.cylinder.R.T[1,2],WheelJoint2.cylinder.R.T[1,3]},{WheelJoint2.cylinder.R.T[2,1],WheelJoint2.cylinder.R.T[2,2],WheelJoint2.cylinder.R.T[2,3]},{WheelJoint2.cylinder.R.T[3,1],WheelJoint2.cylinder.R.T[3,2],WheelJoint2.cylinder.R.T[3,3]}},{WheelJoint2.cylinder.r_shape[1],WheelJoint2.cylinder.r_shape[2],WheelJoint2.cylinder.r_shape[3]});
//   WheelJoint2.cylinder.size[1] = WheelJoint2.cylinder.length;
//   WheelJoint2.cylinder.size[2] = WheelJoint2.cylinder.width;
//   WheelJoint2.cylinder.size[3] = WheelJoint2.cylinder.height;
//   WheelJoint2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint2.cylinder.color[1] / 255.0,WheelJoint2.cylinder.color[2] / 255.0,WheelJoint2.cylinder.color[3] / 255.0,WheelJoint2.cylinder.specularCoefficient);
//   WheelJoint2.cylinder.Extra = WheelJoint2.cylinder.extra;
//   WheelJoint2.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint2.e0[2],WheelJoint2.e0[1],0.0},WheelJoint2.flange_a.phi,0.0);
//   WheelJoint2.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint2.rim1.shapeType);
//   WheelJoint2.rim1.rxvisobj[1] = WheelJoint2.rim1.R.T[1,1] * WheelJoint2.rim1.e_x[1] + WheelJoint2.rim1.R.T[2,1] * WheelJoint2.rim1.e_x[2] + WheelJoint2.rim1.R.T[3,1] * WheelJoint2.rim1.e_x[3];
//   WheelJoint2.rim1.rxvisobj[2] = WheelJoint2.rim1.R.T[1,2] * WheelJoint2.rim1.e_x[1] + WheelJoint2.rim1.R.T[2,2] * WheelJoint2.rim1.e_x[2] + WheelJoint2.rim1.R.T[3,2] * WheelJoint2.rim1.e_x[3];
//   WheelJoint2.rim1.rxvisobj[3] = WheelJoint2.rim1.R.T[1,3] * WheelJoint2.rim1.e_x[1] + WheelJoint2.rim1.R.T[2,3] * WheelJoint2.rim1.e_x[2] + WheelJoint2.rim1.R.T[3,3] * WheelJoint2.rim1.e_x[3];
//   WheelJoint2.rim1.ryvisobj[1] = WheelJoint2.rim1.R.T[1,1] * WheelJoint2.rim1.e_y[1] + WheelJoint2.rim1.R.T[2,1] * WheelJoint2.rim1.e_y[2] + WheelJoint2.rim1.R.T[3,1] * WheelJoint2.rim1.e_y[3];
//   WheelJoint2.rim1.ryvisobj[2] = WheelJoint2.rim1.R.T[1,2] * WheelJoint2.rim1.e_y[1] + WheelJoint2.rim1.R.T[2,2] * WheelJoint2.rim1.e_y[2] + WheelJoint2.rim1.R.T[3,2] * WheelJoint2.rim1.e_y[3];
//   WheelJoint2.rim1.ryvisobj[3] = WheelJoint2.rim1.R.T[1,3] * WheelJoint2.rim1.e_y[1] + WheelJoint2.rim1.R.T[2,3] * WheelJoint2.rim1.e_y[2] + WheelJoint2.rim1.R.T[3,3] * WheelJoint2.rim1.e_y[3];
//   WheelJoint2.rim1.rvisobj = WheelJoint2.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint2.rim1.R.T[1,1],WheelJoint2.rim1.R.T[1,2],WheelJoint2.rim1.R.T[1,3]},{WheelJoint2.rim1.R.T[2,1],WheelJoint2.rim1.R.T[2,2],WheelJoint2.rim1.R.T[2,3]},{WheelJoint2.rim1.R.T[3,1],WheelJoint2.rim1.R.T[3,2],WheelJoint2.rim1.R.T[3,3]}},{WheelJoint2.rim1.r_shape[1],WheelJoint2.rim1.r_shape[2],WheelJoint2.rim1.r_shape[3]});
//   WheelJoint2.rim1.size[1] = WheelJoint2.rim1.length;
//   WheelJoint2.rim1.size[2] = WheelJoint2.rim1.width;
//   WheelJoint2.rim1.size[3] = WheelJoint2.rim1.height;
//   WheelJoint2.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint2.rim1.color[1] / 255.0,WheelJoint2.rim1.color[2] / 255.0,WheelJoint2.rim1.color[3] / 255.0,WheelJoint2.rim1.specularCoefficient);
//   WheelJoint2.rim1.Extra = WheelJoint2.rim1.extra;
//   WheelJoint2.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint2.e0[2],WheelJoint2.e0[1],0.0},1.5707963267948966 + WheelJoint2.flange_a.phi,0.0);
//   WheelJoint2.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint2.rim2.shapeType);
//   WheelJoint2.rim2.rxvisobj[1] = WheelJoint2.rim2.R.T[1,1] * WheelJoint2.rim2.e_x[1] + WheelJoint2.rim2.R.T[2,1] * WheelJoint2.rim2.e_x[2] + WheelJoint2.rim2.R.T[3,1] * WheelJoint2.rim2.e_x[3];
//   WheelJoint2.rim2.rxvisobj[2] = WheelJoint2.rim2.R.T[1,2] * WheelJoint2.rim2.e_x[1] + WheelJoint2.rim2.R.T[2,2] * WheelJoint2.rim2.e_x[2] + WheelJoint2.rim2.R.T[3,2] * WheelJoint2.rim2.e_x[3];
//   WheelJoint2.rim2.rxvisobj[3] = WheelJoint2.rim2.R.T[1,3] * WheelJoint2.rim2.e_x[1] + WheelJoint2.rim2.R.T[2,3] * WheelJoint2.rim2.e_x[2] + WheelJoint2.rim2.R.T[3,3] * WheelJoint2.rim2.e_x[3];
//   WheelJoint2.rim2.ryvisobj[1] = WheelJoint2.rim2.R.T[1,1] * WheelJoint2.rim2.e_y[1] + WheelJoint2.rim2.R.T[2,1] * WheelJoint2.rim2.e_y[2] + WheelJoint2.rim2.R.T[3,1] * WheelJoint2.rim2.e_y[3];
//   WheelJoint2.rim2.ryvisobj[2] = WheelJoint2.rim2.R.T[1,2] * WheelJoint2.rim2.e_y[1] + WheelJoint2.rim2.R.T[2,2] * WheelJoint2.rim2.e_y[2] + WheelJoint2.rim2.R.T[3,2] * WheelJoint2.rim2.e_y[3];
//   WheelJoint2.rim2.ryvisobj[3] = WheelJoint2.rim2.R.T[1,3] * WheelJoint2.rim2.e_y[1] + WheelJoint2.rim2.R.T[2,3] * WheelJoint2.rim2.e_y[2] + WheelJoint2.rim2.R.T[3,3] * WheelJoint2.rim2.e_y[3];
//   WheelJoint2.rim2.rvisobj = WheelJoint2.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint2.rim2.R.T[1,1],WheelJoint2.rim2.R.T[1,2],WheelJoint2.rim2.R.T[1,3]},{WheelJoint2.rim2.R.T[2,1],WheelJoint2.rim2.R.T[2,2],WheelJoint2.rim2.R.T[2,3]},{WheelJoint2.rim2.R.T[3,1],WheelJoint2.rim2.R.T[3,2],WheelJoint2.rim2.R.T[3,3]}},{WheelJoint2.rim2.r_shape[1],WheelJoint2.rim2.r_shape[2],WheelJoint2.rim2.r_shape[3]});
//   WheelJoint2.rim2.size[1] = WheelJoint2.rim2.length;
//   WheelJoint2.rim2.size[2] = WheelJoint2.rim2.width;
//   WheelJoint2.rim2.size[3] = WheelJoint2.rim2.height;
//   WheelJoint2.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint2.rim2.color[1] / 255.0,WheelJoint2.rim2.color[2] / 255.0,WheelJoint2.rim2.color[3] / 255.0,WheelJoint2.rim2.specularCoefficient);
//   WheelJoint2.rim2.Extra = WheelJoint2.rim2.extra;
//   WheelJoint2.R[1,1] = cos(WheelJoint2.frame_a.phi);
//   WheelJoint2.R[1,2] = sin(WheelJoint2.frame_a.phi);
//   WheelJoint2.R[2,1] = -sin(WheelJoint2.frame_a.phi);
//   WheelJoint2.R[2,2] = cos(WheelJoint2.frame_a.phi);
//   WheelJoint2.e0[1] = WheelJoint2.R[1,1] * WheelJoint2.e[1] + WheelJoint2.R[1,2] * WheelJoint2.e[2];
//   WheelJoint2.e0[2] = WheelJoint2.R[2,1] * WheelJoint2.e[1] + WheelJoint2.R[2,2] * WheelJoint2.e[2];
//   WheelJoint2.v[1] = der(WheelJoint2.frame_a.x);
//   WheelJoint2.v[2] = der(WheelJoint2.frame_a.y);
//   WheelJoint2.w_roll = der(WheelJoint2.flange_a.phi);
//   WheelJoint2.v_long = WheelJoint2.v[1] * WheelJoint2.e0[1] + WheelJoint2.v[2] * WheelJoint2.e0[2];
//   WheelJoint2.v_lat = (-WheelJoint2.v[1]) * WheelJoint2.e0[2] + WheelJoint2.v[2] * WheelJoint2.e0[1];
//   WheelJoint2.v_slip_lat = WheelJoint2.v_lat;
//   WheelJoint2.v_slip_long = WheelJoint2.v_long - WheelJoint2.radius * WheelJoint2.w_roll;
//   WheelJoint2.v_slip = 0.0001 + sqrt(WheelJoint2.v_slip_long ^ 2.0 + WheelJoint2.v_slip_lat ^ 2.0);
//   (-WheelJoint2.f_long) * WheelJoint2.radius = WheelJoint2.flange_a.tau;
//   WheelJoint2.frame_a.t = 0.0;
//   WheelJoint2.f = WheelJoint2.N * PlanarMechanicsForTesting.Utilities.TripleS_Func(WheelJoint2.vAdhesion,WheelJoint2.vSlide,WheelJoint2.mu_A,WheelJoint2.mu_S,WheelJoint2.v_slip);
//   WheelJoint2.f_long = (WheelJoint2.f * WheelJoint2.v_slip_long) / WheelJoint2.v_slip;
//   WheelJoint2.f_lat = (WheelJoint2.f * WheelJoint2.v_slip_lat) / WheelJoint2.v_slip;
//   WheelJoint2.f_long = WheelJoint2.frame_a.fx * WheelJoint2.e0[1] + WheelJoint2.frame_a.fy * WheelJoint2.e0[2];
//   WheelJoint2.f_lat = WheelJoint2.frame_a.fy * WheelJoint2.e0[1] + (-WheelJoint2.frame_a.fx) * WheelJoint2.e0[2];
//   constantTorque1.tau = -constantTorque1.flange.tau;
//   constantTorque1.tau = constantTorque1.tau_constant;
//   constantTorque1.phi = constantTorque1.flange.phi - constantTorque1.phi_support;
//   constantTorque1.phi_support = 0.0;
//   inertia.phi = inertia.flange_a.phi;
//   inertia.phi = inertia.flange_b.phi;
//   inertia.w = der(inertia.phi);
//   inertia.a = der(inertia.w);
//   inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
//   inertia1.phi = inertia1.flange_a.phi;
//   inertia1.phi = inertia1.flange_b.phi;
//   inertia1.w = der(inertia1.phi);
//   inertia1.a = der(inertia1.w);
//   inertia1.J * inertia1.a = inertia1.flange_a.tau + inertia1.flange_b.tau;
//   fixedTranslation2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.cylinder.shapeType);
//   fixedTranslation2.cylinder.rxvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.rxvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_x[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_x[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_x[3];
//   fixedTranslation2.cylinder.ryvisobj[1] = fixedTranslation2.cylinder.R.T[1,1] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,1] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,1] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[2] = fixedTranslation2.cylinder.R.T[1,2] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,2] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,2] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.ryvisobj[3] = fixedTranslation2.cylinder.R.T[1,3] * fixedTranslation2.cylinder.e_y[1] + fixedTranslation2.cylinder.R.T[2,3] * fixedTranslation2.cylinder.e_y[2] + fixedTranslation2.cylinder.R.T[3,3] * fixedTranslation2.cylinder.e_y[3];
//   fixedTranslation2.cylinder.rvisobj = fixedTranslation2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.cylinder.R.T[1,1],fixedTranslation2.cylinder.R.T[1,2],fixedTranslation2.cylinder.R.T[1,3]},{fixedTranslation2.cylinder.R.T[2,1],fixedTranslation2.cylinder.R.T[2,2],fixedTranslation2.cylinder.R.T[2,3]},{fixedTranslation2.cylinder.R.T[3,1],fixedTranslation2.cylinder.R.T[3,2],fixedTranslation2.cylinder.R.T[3,3]}},{fixedTranslation2.cylinder.r_shape[1],fixedTranslation2.cylinder.r_shape[2],fixedTranslation2.cylinder.r_shape[3]});
//   fixedTranslation2.cylinder.size[1] = fixedTranslation2.cylinder.length;
//   fixedTranslation2.cylinder.size[2] = fixedTranslation2.cylinder.width;
//   fixedTranslation2.cylinder.size[3] = fixedTranslation2.cylinder.height;
//   fixedTranslation2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.cylinder.color[1] / 255.0,fixedTranslation2.cylinder.color[2] / 255.0,fixedTranslation2.cylinder.color[3] / 255.0,fixedTranslation2.cylinder.specularCoefficient);
//   fixedTranslation2.cylinder.Extra = fixedTranslation2.cylinder.extra;
//   fixedTranslation2.R[1,1] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[1,2] = sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,1] = -sin(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.R[2,2] = cos(fixedTranslation2.frame_a.phi);
//   fixedTranslation2.r0[1] = fixedTranslation2.R[1,1] * fixedTranslation2.r[1] + fixedTranslation2.R[1,2] * fixedTranslation2.r[2];
//   fixedTranslation2.r0[2] = fixedTranslation2.R[2,1] * fixedTranslation2.r[1] + fixedTranslation2.R[2,2] * fixedTranslation2.r[2];
//   fixedTranslation2.frame_a.x + fixedTranslation2.r0[1] = fixedTranslation2.frame_b.x;
//   fixedTranslation2.frame_a.y + fixedTranslation2.r0[2] = fixedTranslation2.frame_b.y;
//   fixedTranslation2.frame_a.phi = fixedTranslation2.frame_b.phi;
//   fixedTranslation2.frame_a.fx + fixedTranslation2.frame_b.fx = 0.0;
//   fixedTranslation2.frame_a.fy + fixedTranslation2.frame_b.fy = 0.0;
//   fixedTranslation2.frame_a.t + (fixedTranslation2.frame_b.t + ((-fixedTranslation2.r0[1]) * fixedTranslation2.frame_b.fy + fixedTranslation2.r0[2] * fixedTranslation2.frame_b.fx)) = 0.0;
//   fixedTranslation3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.cylinder.shapeType);
//   fixedTranslation3.cylinder.rxvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.rxvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_x[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_x[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_x[3];
//   fixedTranslation3.cylinder.ryvisobj[1] = fixedTranslation3.cylinder.R.T[1,1] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,1] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,1] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[2] = fixedTranslation3.cylinder.R.T[1,2] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,2] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,2] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.ryvisobj[3] = fixedTranslation3.cylinder.R.T[1,3] * fixedTranslation3.cylinder.e_y[1] + fixedTranslation3.cylinder.R.T[2,3] * fixedTranslation3.cylinder.e_y[2] + fixedTranslation3.cylinder.R.T[3,3] * fixedTranslation3.cylinder.e_y[3];
//   fixedTranslation3.cylinder.rvisobj = fixedTranslation3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.cylinder.R.T[1,1],fixedTranslation3.cylinder.R.T[1,2],fixedTranslation3.cylinder.R.T[1,3]},{fixedTranslation3.cylinder.R.T[2,1],fixedTranslation3.cylinder.R.T[2,2],fixedTranslation3.cylinder.R.T[2,3]},{fixedTranslation3.cylinder.R.T[3,1],fixedTranslation3.cylinder.R.T[3,2],fixedTranslation3.cylinder.R.T[3,3]}},{fixedTranslation3.cylinder.r_shape[1],fixedTranslation3.cylinder.r_shape[2],fixedTranslation3.cylinder.r_shape[3]});
//   fixedTranslation3.cylinder.size[1] = fixedTranslation3.cylinder.length;
//   fixedTranslation3.cylinder.size[2] = fixedTranslation3.cylinder.width;
//   fixedTranslation3.cylinder.size[3] = fixedTranslation3.cylinder.height;
//   fixedTranslation3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.cylinder.color[1] / 255.0,fixedTranslation3.cylinder.color[2] / 255.0,fixedTranslation3.cylinder.color[3] / 255.0,fixedTranslation3.cylinder.specularCoefficient);
//   fixedTranslation3.cylinder.Extra = fixedTranslation3.cylinder.extra;
//   fixedTranslation3.R[1,1] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[1,2] = sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,1] = -sin(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.R[2,2] = cos(fixedTranslation3.frame_a.phi);
//   fixedTranslation3.r0[1] = fixedTranslation3.R[1,1] * fixedTranslation3.r[1] + fixedTranslation3.R[1,2] * fixedTranslation3.r[2];
//   fixedTranslation3.r0[2] = fixedTranslation3.R[2,1] * fixedTranslation3.r[1] + fixedTranslation3.R[2,2] * fixedTranslation3.r[2];
//   fixedTranslation3.frame_a.x + fixedTranslation3.r0[1] = fixedTranslation3.frame_b.x;
//   fixedTranslation3.frame_a.y + fixedTranslation3.r0[2] = fixedTranslation3.frame_b.y;
//   fixedTranslation3.frame_a.phi = fixedTranslation3.frame_b.phi;
//   fixedTranslation3.frame_a.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation3.frame_a.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation3.frame_a.t + (fixedTranslation3.frame_b.t + ((-fixedTranslation3.r0[1]) * fixedTranslation3.frame_b.fy + fixedTranslation3.r0[2] * fixedTranslation3.frame_b.fx)) = 0.0;
//   WheelJoint3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint3.cylinder.shapeType);
//   WheelJoint3.cylinder.rxvisobj[1] = WheelJoint3.cylinder.R.T[1,1] * WheelJoint3.cylinder.e_x[1] + WheelJoint3.cylinder.R.T[2,1] * WheelJoint3.cylinder.e_x[2] + WheelJoint3.cylinder.R.T[3,1] * WheelJoint3.cylinder.e_x[3];
//   WheelJoint3.cylinder.rxvisobj[2] = WheelJoint3.cylinder.R.T[1,2] * WheelJoint3.cylinder.e_x[1] + WheelJoint3.cylinder.R.T[2,2] * WheelJoint3.cylinder.e_x[2] + WheelJoint3.cylinder.R.T[3,2] * WheelJoint3.cylinder.e_x[3];
//   WheelJoint3.cylinder.rxvisobj[3] = WheelJoint3.cylinder.R.T[1,3] * WheelJoint3.cylinder.e_x[1] + WheelJoint3.cylinder.R.T[2,3] * WheelJoint3.cylinder.e_x[2] + WheelJoint3.cylinder.R.T[3,3] * WheelJoint3.cylinder.e_x[3];
//   WheelJoint3.cylinder.ryvisobj[1] = WheelJoint3.cylinder.R.T[1,1] * WheelJoint3.cylinder.e_y[1] + WheelJoint3.cylinder.R.T[2,1] * WheelJoint3.cylinder.e_y[2] + WheelJoint3.cylinder.R.T[3,1] * WheelJoint3.cylinder.e_y[3];
//   WheelJoint3.cylinder.ryvisobj[2] = WheelJoint3.cylinder.R.T[1,2] * WheelJoint3.cylinder.e_y[1] + WheelJoint3.cylinder.R.T[2,2] * WheelJoint3.cylinder.e_y[2] + WheelJoint3.cylinder.R.T[3,2] * WheelJoint3.cylinder.e_y[3];
//   WheelJoint3.cylinder.ryvisobj[3] = WheelJoint3.cylinder.R.T[1,3] * WheelJoint3.cylinder.e_y[1] + WheelJoint3.cylinder.R.T[2,3] * WheelJoint3.cylinder.e_y[2] + WheelJoint3.cylinder.R.T[3,3] * WheelJoint3.cylinder.e_y[3];
//   WheelJoint3.cylinder.rvisobj = WheelJoint3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint3.cylinder.R.T[1,1],WheelJoint3.cylinder.R.T[1,2],WheelJoint3.cylinder.R.T[1,3]},{WheelJoint3.cylinder.R.T[2,1],WheelJoint3.cylinder.R.T[2,2],WheelJoint3.cylinder.R.T[2,3]},{WheelJoint3.cylinder.R.T[3,1],WheelJoint3.cylinder.R.T[3,2],WheelJoint3.cylinder.R.T[3,3]}},{WheelJoint3.cylinder.r_shape[1],WheelJoint3.cylinder.r_shape[2],WheelJoint3.cylinder.r_shape[3]});
//   WheelJoint3.cylinder.size[1] = WheelJoint3.cylinder.length;
//   WheelJoint3.cylinder.size[2] = WheelJoint3.cylinder.width;
//   WheelJoint3.cylinder.size[3] = WheelJoint3.cylinder.height;
//   WheelJoint3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint3.cylinder.color[1] / 255.0,WheelJoint3.cylinder.color[2] / 255.0,WheelJoint3.cylinder.color[3] / 255.0,WheelJoint3.cylinder.specularCoefficient);
//   WheelJoint3.cylinder.Extra = WheelJoint3.cylinder.extra;
//   WheelJoint3.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint3.e0[2],WheelJoint3.e0[1],0.0},WheelJoint3.flange_a.phi,0.0);
//   WheelJoint3.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint3.rim1.shapeType);
//   WheelJoint3.rim1.rxvisobj[1] = WheelJoint3.rim1.R.T[1,1] * WheelJoint3.rim1.e_x[1] + WheelJoint3.rim1.R.T[2,1] * WheelJoint3.rim1.e_x[2] + WheelJoint3.rim1.R.T[3,1] * WheelJoint3.rim1.e_x[3];
//   WheelJoint3.rim1.rxvisobj[2] = WheelJoint3.rim1.R.T[1,2] * WheelJoint3.rim1.e_x[1] + WheelJoint3.rim1.R.T[2,2] * WheelJoint3.rim1.e_x[2] + WheelJoint3.rim1.R.T[3,2] * WheelJoint3.rim1.e_x[3];
//   WheelJoint3.rim1.rxvisobj[3] = WheelJoint3.rim1.R.T[1,3] * WheelJoint3.rim1.e_x[1] + WheelJoint3.rim1.R.T[2,3] * WheelJoint3.rim1.e_x[2] + WheelJoint3.rim1.R.T[3,3] * WheelJoint3.rim1.e_x[3];
//   WheelJoint3.rim1.ryvisobj[1] = WheelJoint3.rim1.R.T[1,1] * WheelJoint3.rim1.e_y[1] + WheelJoint3.rim1.R.T[2,1] * WheelJoint3.rim1.e_y[2] + WheelJoint3.rim1.R.T[3,1] * WheelJoint3.rim1.e_y[3];
//   WheelJoint3.rim1.ryvisobj[2] = WheelJoint3.rim1.R.T[1,2] * WheelJoint3.rim1.e_y[1] + WheelJoint3.rim1.R.T[2,2] * WheelJoint3.rim1.e_y[2] + WheelJoint3.rim1.R.T[3,2] * WheelJoint3.rim1.e_y[3];
//   WheelJoint3.rim1.ryvisobj[3] = WheelJoint3.rim1.R.T[1,3] * WheelJoint3.rim1.e_y[1] + WheelJoint3.rim1.R.T[2,3] * WheelJoint3.rim1.e_y[2] + WheelJoint3.rim1.R.T[3,3] * WheelJoint3.rim1.e_y[3];
//   WheelJoint3.rim1.rvisobj = WheelJoint3.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint3.rim1.R.T[1,1],WheelJoint3.rim1.R.T[1,2],WheelJoint3.rim1.R.T[1,3]},{WheelJoint3.rim1.R.T[2,1],WheelJoint3.rim1.R.T[2,2],WheelJoint3.rim1.R.T[2,3]},{WheelJoint3.rim1.R.T[3,1],WheelJoint3.rim1.R.T[3,2],WheelJoint3.rim1.R.T[3,3]}},{WheelJoint3.rim1.r_shape[1],WheelJoint3.rim1.r_shape[2],WheelJoint3.rim1.r_shape[3]});
//   WheelJoint3.rim1.size[1] = WheelJoint3.rim1.length;
//   WheelJoint3.rim1.size[2] = WheelJoint3.rim1.width;
//   WheelJoint3.rim1.size[3] = WheelJoint3.rim1.height;
//   WheelJoint3.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint3.rim1.color[1] / 255.0,WheelJoint3.rim1.color[2] / 255.0,WheelJoint3.rim1.color[3] / 255.0,WheelJoint3.rim1.specularCoefficient);
//   WheelJoint3.rim1.Extra = WheelJoint3.rim1.extra;
//   WheelJoint3.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint3.e0[2],WheelJoint3.e0[1],0.0},1.5707963267948966 + WheelJoint3.flange_a.phi,0.0);
//   WheelJoint3.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint3.rim2.shapeType);
//   WheelJoint3.rim2.rxvisobj[1] = WheelJoint3.rim2.R.T[1,1] * WheelJoint3.rim2.e_x[1] + WheelJoint3.rim2.R.T[2,1] * WheelJoint3.rim2.e_x[2] + WheelJoint3.rim2.R.T[3,1] * WheelJoint3.rim2.e_x[3];
//   WheelJoint3.rim2.rxvisobj[2] = WheelJoint3.rim2.R.T[1,2] * WheelJoint3.rim2.e_x[1] + WheelJoint3.rim2.R.T[2,2] * WheelJoint3.rim2.e_x[2] + WheelJoint3.rim2.R.T[3,2] * WheelJoint3.rim2.e_x[3];
//   WheelJoint3.rim2.rxvisobj[3] = WheelJoint3.rim2.R.T[1,3] * WheelJoint3.rim2.e_x[1] + WheelJoint3.rim2.R.T[2,3] * WheelJoint3.rim2.e_x[2] + WheelJoint3.rim2.R.T[3,3] * WheelJoint3.rim2.e_x[3];
//   WheelJoint3.rim2.ryvisobj[1] = WheelJoint3.rim2.R.T[1,1] * WheelJoint3.rim2.e_y[1] + WheelJoint3.rim2.R.T[2,1] * WheelJoint3.rim2.e_y[2] + WheelJoint3.rim2.R.T[3,1] * WheelJoint3.rim2.e_y[3];
//   WheelJoint3.rim2.ryvisobj[2] = WheelJoint3.rim2.R.T[1,2] * WheelJoint3.rim2.e_y[1] + WheelJoint3.rim2.R.T[2,2] * WheelJoint3.rim2.e_y[2] + WheelJoint3.rim2.R.T[3,2] * WheelJoint3.rim2.e_y[3];
//   WheelJoint3.rim2.ryvisobj[3] = WheelJoint3.rim2.R.T[1,3] * WheelJoint3.rim2.e_y[1] + WheelJoint3.rim2.R.T[2,3] * WheelJoint3.rim2.e_y[2] + WheelJoint3.rim2.R.T[3,3] * WheelJoint3.rim2.e_y[3];
//   WheelJoint3.rim2.rvisobj = WheelJoint3.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint3.rim2.R.T[1,1],WheelJoint3.rim2.R.T[1,2],WheelJoint3.rim2.R.T[1,3]},{WheelJoint3.rim2.R.T[2,1],WheelJoint3.rim2.R.T[2,2],WheelJoint3.rim2.R.T[2,3]},{WheelJoint3.rim2.R.T[3,1],WheelJoint3.rim2.R.T[3,2],WheelJoint3.rim2.R.T[3,3]}},{WheelJoint3.rim2.r_shape[1],WheelJoint3.rim2.r_shape[2],WheelJoint3.rim2.r_shape[3]});
//   WheelJoint3.rim2.size[1] = WheelJoint3.rim2.length;
//   WheelJoint3.rim2.size[2] = WheelJoint3.rim2.width;
//   WheelJoint3.rim2.size[3] = WheelJoint3.rim2.height;
//   WheelJoint3.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint3.rim2.color[1] / 255.0,WheelJoint3.rim2.color[2] / 255.0,WheelJoint3.rim2.color[3] / 255.0,WheelJoint3.rim2.specularCoefficient);
//   WheelJoint3.rim2.Extra = WheelJoint3.rim2.extra;
//   WheelJoint3.R[1,1] = cos(WheelJoint3.frame_a.phi);
//   WheelJoint3.R[1,2] = sin(WheelJoint3.frame_a.phi);
//   WheelJoint3.R[2,1] = -sin(WheelJoint3.frame_a.phi);
//   WheelJoint3.R[2,2] = cos(WheelJoint3.frame_a.phi);
//   WheelJoint3.e0[1] = WheelJoint3.R[1,1] * WheelJoint3.e[1] + WheelJoint3.R[1,2] * WheelJoint3.e[2];
//   WheelJoint3.e0[2] = WheelJoint3.R[2,1] * WheelJoint3.e[1] + WheelJoint3.R[2,2] * WheelJoint3.e[2];
//   WheelJoint3.v[1] = der(WheelJoint3.frame_a.x);
//   WheelJoint3.v[2] = der(WheelJoint3.frame_a.y);
//   WheelJoint3.w_roll = der(WheelJoint3.flange_a.phi);
//   WheelJoint3.v_long = WheelJoint3.v[1] * WheelJoint3.e0[1] + WheelJoint3.v[2] * WheelJoint3.e0[2];
//   WheelJoint3.v_lat = (-WheelJoint3.v[1]) * WheelJoint3.e0[2] + WheelJoint3.v[2] * WheelJoint3.e0[1];
//   WheelJoint3.v_slip_lat = WheelJoint3.v_lat;
//   WheelJoint3.v_slip_long = WheelJoint3.v_long - WheelJoint3.radius * WheelJoint3.w_roll;
//   WheelJoint3.v_slip = 0.0001 + sqrt(WheelJoint3.v_slip_long ^ 2.0 + WheelJoint3.v_slip_lat ^ 2.0);
//   (-WheelJoint3.f_long) * WheelJoint3.radius = WheelJoint3.flange_a.tau;
//   WheelJoint3.frame_a.t = 0.0;
//   WheelJoint3.f = WheelJoint3.N * PlanarMechanicsForTesting.Utilities.TripleS_Func(WheelJoint3.vAdhesion,WheelJoint3.vSlide,WheelJoint3.mu_A,WheelJoint3.mu_S,WheelJoint3.v_slip);
//   WheelJoint3.f_long = (WheelJoint3.f * WheelJoint3.v_slip_long) / WheelJoint3.v_slip;
//   WheelJoint3.f_lat = (WheelJoint3.f * WheelJoint3.v_slip_lat) / WheelJoint3.v_slip;
//   WheelJoint3.f_long = WheelJoint3.frame_a.fx * WheelJoint3.e0[1] + WheelJoint3.frame_a.fy * WheelJoint3.e0[2];
//   WheelJoint3.f_lat = WheelJoint3.frame_a.fy * WheelJoint3.e0[1] + (-WheelJoint3.frame_a.fx) * WheelJoint3.e0[2];
//   inertia2.phi = inertia2.flange_a.phi;
//   inertia2.phi = inertia2.flange_b.phi;
//   inertia2.w = der(inertia2.phi);
//   inertia2.a = der(inertia2.w);
//   inertia2.J * inertia2.a = inertia2.flange_a.tau + inertia2.flange_b.tau;
//   fixedTranslation4.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation4.cylinder.shapeType);
//   fixedTranslation4.cylinder.rxvisobj[1] = fixedTranslation4.cylinder.R.T[1,1] * fixedTranslation4.cylinder.e_x[1] + fixedTranslation4.cylinder.R.T[2,1] * fixedTranslation4.cylinder.e_x[2] + fixedTranslation4.cylinder.R.T[3,1] * fixedTranslation4.cylinder.e_x[3];
//   fixedTranslation4.cylinder.rxvisobj[2] = fixedTranslation4.cylinder.R.T[1,2] * fixedTranslation4.cylinder.e_x[1] + fixedTranslation4.cylinder.R.T[2,2] * fixedTranslation4.cylinder.e_x[2] + fixedTranslation4.cylinder.R.T[3,2] * fixedTranslation4.cylinder.e_x[3];
//   fixedTranslation4.cylinder.rxvisobj[3] = fixedTranslation4.cylinder.R.T[1,3] * fixedTranslation4.cylinder.e_x[1] + fixedTranslation4.cylinder.R.T[2,3] * fixedTranslation4.cylinder.e_x[2] + fixedTranslation4.cylinder.R.T[3,3] * fixedTranslation4.cylinder.e_x[3];
//   fixedTranslation4.cylinder.ryvisobj[1] = fixedTranslation4.cylinder.R.T[1,1] * fixedTranslation4.cylinder.e_y[1] + fixedTranslation4.cylinder.R.T[2,1] * fixedTranslation4.cylinder.e_y[2] + fixedTranslation4.cylinder.R.T[3,1] * fixedTranslation4.cylinder.e_y[3];
//   fixedTranslation4.cylinder.ryvisobj[2] = fixedTranslation4.cylinder.R.T[1,2] * fixedTranslation4.cylinder.e_y[1] + fixedTranslation4.cylinder.R.T[2,2] * fixedTranslation4.cylinder.e_y[2] + fixedTranslation4.cylinder.R.T[3,2] * fixedTranslation4.cylinder.e_y[3];
//   fixedTranslation4.cylinder.ryvisobj[3] = fixedTranslation4.cylinder.R.T[1,3] * fixedTranslation4.cylinder.e_y[1] + fixedTranslation4.cylinder.R.T[2,3] * fixedTranslation4.cylinder.e_y[2] + fixedTranslation4.cylinder.R.T[3,3] * fixedTranslation4.cylinder.e_y[3];
//   fixedTranslation4.cylinder.rvisobj = fixedTranslation4.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation4.cylinder.R.T[1,1],fixedTranslation4.cylinder.R.T[1,2],fixedTranslation4.cylinder.R.T[1,3]},{fixedTranslation4.cylinder.R.T[2,1],fixedTranslation4.cylinder.R.T[2,2],fixedTranslation4.cylinder.R.T[2,3]},{fixedTranslation4.cylinder.R.T[3,1],fixedTranslation4.cylinder.R.T[3,2],fixedTranslation4.cylinder.R.T[3,3]}},{fixedTranslation4.cylinder.r_shape[1],fixedTranslation4.cylinder.r_shape[2],fixedTranslation4.cylinder.r_shape[3]});
//   fixedTranslation4.cylinder.size[1] = fixedTranslation4.cylinder.length;
//   fixedTranslation4.cylinder.size[2] = fixedTranslation4.cylinder.width;
//   fixedTranslation4.cylinder.size[3] = fixedTranslation4.cylinder.height;
//   fixedTranslation4.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation4.cylinder.color[1] / 255.0,fixedTranslation4.cylinder.color[2] / 255.0,fixedTranslation4.cylinder.color[3] / 255.0,fixedTranslation4.cylinder.specularCoefficient);
//   fixedTranslation4.cylinder.Extra = fixedTranslation4.cylinder.extra;
//   fixedTranslation4.R[1,1] = cos(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.R[1,2] = sin(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.R[2,1] = -sin(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.R[2,2] = cos(fixedTranslation4.frame_a.phi);
//   fixedTranslation4.r0[1] = fixedTranslation4.R[1,1] * fixedTranslation4.r[1] + fixedTranslation4.R[1,2] * fixedTranslation4.r[2];
//   fixedTranslation4.r0[2] = fixedTranslation4.R[2,1] * fixedTranslation4.r[1] + fixedTranslation4.R[2,2] * fixedTranslation4.r[2];
//   fixedTranslation4.frame_a.x + fixedTranslation4.r0[1] = fixedTranslation4.frame_b.x;
//   fixedTranslation4.frame_a.y + fixedTranslation4.r0[2] = fixedTranslation4.frame_b.y;
//   fixedTranslation4.frame_a.phi = fixedTranslation4.frame_b.phi;
//   fixedTranslation4.frame_a.fx + fixedTranslation4.frame_b.fx = 0.0;
//   fixedTranslation4.frame_a.fy + fixedTranslation4.frame_b.fy = 0.0;
//   fixedTranslation4.frame_a.t + (fixedTranslation4.frame_b.t + ((-fixedTranslation4.r0[1]) * fixedTranslation4.frame_b.fy + fixedTranslation4.r0[2] * fixedTranslation4.frame_b.fx)) = 0.0;
//   fixedTranslation5.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation5.cylinder.shapeType);
//   fixedTranslation5.cylinder.rxvisobj[1] = fixedTranslation5.cylinder.R.T[1,1] * fixedTranslation5.cylinder.e_x[1] + fixedTranslation5.cylinder.R.T[2,1] * fixedTranslation5.cylinder.e_x[2] + fixedTranslation5.cylinder.R.T[3,1] * fixedTranslation5.cylinder.e_x[3];
//   fixedTranslation5.cylinder.rxvisobj[2] = fixedTranslation5.cylinder.R.T[1,2] * fixedTranslation5.cylinder.e_x[1] + fixedTranslation5.cylinder.R.T[2,2] * fixedTranslation5.cylinder.e_x[2] + fixedTranslation5.cylinder.R.T[3,2] * fixedTranslation5.cylinder.e_x[3];
//   fixedTranslation5.cylinder.rxvisobj[3] = fixedTranslation5.cylinder.R.T[1,3] * fixedTranslation5.cylinder.e_x[1] + fixedTranslation5.cylinder.R.T[2,3] * fixedTranslation5.cylinder.e_x[2] + fixedTranslation5.cylinder.R.T[3,3] * fixedTranslation5.cylinder.e_x[3];
//   fixedTranslation5.cylinder.ryvisobj[1] = fixedTranslation5.cylinder.R.T[1,1] * fixedTranslation5.cylinder.e_y[1] + fixedTranslation5.cylinder.R.T[2,1] * fixedTranslation5.cylinder.e_y[2] + fixedTranslation5.cylinder.R.T[3,1] * fixedTranslation5.cylinder.e_y[3];
//   fixedTranslation5.cylinder.ryvisobj[2] = fixedTranslation5.cylinder.R.T[1,2] * fixedTranslation5.cylinder.e_y[1] + fixedTranslation5.cylinder.R.T[2,2] * fixedTranslation5.cylinder.e_y[2] + fixedTranslation5.cylinder.R.T[3,2] * fixedTranslation5.cylinder.e_y[3];
//   fixedTranslation5.cylinder.ryvisobj[3] = fixedTranslation5.cylinder.R.T[1,3] * fixedTranslation5.cylinder.e_y[1] + fixedTranslation5.cylinder.R.T[2,3] * fixedTranslation5.cylinder.e_y[2] + fixedTranslation5.cylinder.R.T[3,3] * fixedTranslation5.cylinder.e_y[3];
//   fixedTranslation5.cylinder.rvisobj = fixedTranslation5.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation5.cylinder.R.T[1,1],fixedTranslation5.cylinder.R.T[1,2],fixedTranslation5.cylinder.R.T[1,3]},{fixedTranslation5.cylinder.R.T[2,1],fixedTranslation5.cylinder.R.T[2,2],fixedTranslation5.cylinder.R.T[2,3]},{fixedTranslation5.cylinder.R.T[3,1],fixedTranslation5.cylinder.R.T[3,2],fixedTranslation5.cylinder.R.T[3,3]}},{fixedTranslation5.cylinder.r_shape[1],fixedTranslation5.cylinder.r_shape[2],fixedTranslation5.cylinder.r_shape[3]});
//   fixedTranslation5.cylinder.size[1] = fixedTranslation5.cylinder.length;
//   fixedTranslation5.cylinder.size[2] = fixedTranslation5.cylinder.width;
//   fixedTranslation5.cylinder.size[3] = fixedTranslation5.cylinder.height;
//   fixedTranslation5.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation5.cylinder.color[1] / 255.0,fixedTranslation5.cylinder.color[2] / 255.0,fixedTranslation5.cylinder.color[3] / 255.0,fixedTranslation5.cylinder.specularCoefficient);
//   fixedTranslation5.cylinder.Extra = fixedTranslation5.cylinder.extra;
//   fixedTranslation5.R[1,1] = cos(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.R[1,2] = sin(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.R[2,1] = -sin(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.R[2,2] = cos(fixedTranslation5.frame_a.phi);
//   fixedTranslation5.r0[1] = fixedTranslation5.R[1,1] * fixedTranslation5.r[1] + fixedTranslation5.R[1,2] * fixedTranslation5.r[2];
//   fixedTranslation5.r0[2] = fixedTranslation5.R[2,1] * fixedTranslation5.r[1] + fixedTranslation5.R[2,2] * fixedTranslation5.r[2];
//   fixedTranslation5.frame_a.x + fixedTranslation5.r0[1] = fixedTranslation5.frame_b.x;
//   fixedTranslation5.frame_a.y + fixedTranslation5.r0[2] = fixedTranslation5.frame_b.y;
//   fixedTranslation5.frame_a.phi = fixedTranslation5.frame_b.phi;
//   fixedTranslation5.frame_a.fx + fixedTranslation5.frame_b.fx = 0.0;
//   fixedTranslation5.frame_a.fy + fixedTranslation5.frame_b.fy = 0.0;
//   fixedTranslation5.frame_a.t + (fixedTranslation5.frame_b.t + ((-fixedTranslation5.r0[1]) * fixedTranslation5.frame_b.fy + fixedTranslation5.r0[2] * fixedTranslation5.frame_b.fx)) = 0.0;
//   WheelJoint4.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint4.cylinder.shapeType);
//   WheelJoint4.cylinder.rxvisobj[1] = WheelJoint4.cylinder.R.T[1,1] * WheelJoint4.cylinder.e_x[1] + WheelJoint4.cylinder.R.T[2,1] * WheelJoint4.cylinder.e_x[2] + WheelJoint4.cylinder.R.T[3,1] * WheelJoint4.cylinder.e_x[3];
//   WheelJoint4.cylinder.rxvisobj[2] = WheelJoint4.cylinder.R.T[1,2] * WheelJoint4.cylinder.e_x[1] + WheelJoint4.cylinder.R.T[2,2] * WheelJoint4.cylinder.e_x[2] + WheelJoint4.cylinder.R.T[3,2] * WheelJoint4.cylinder.e_x[3];
//   WheelJoint4.cylinder.rxvisobj[3] = WheelJoint4.cylinder.R.T[1,3] * WheelJoint4.cylinder.e_x[1] + WheelJoint4.cylinder.R.T[2,3] * WheelJoint4.cylinder.e_x[2] + WheelJoint4.cylinder.R.T[3,3] * WheelJoint4.cylinder.e_x[3];
//   WheelJoint4.cylinder.ryvisobj[1] = WheelJoint4.cylinder.R.T[1,1] * WheelJoint4.cylinder.e_y[1] + WheelJoint4.cylinder.R.T[2,1] * WheelJoint4.cylinder.e_y[2] + WheelJoint4.cylinder.R.T[3,1] * WheelJoint4.cylinder.e_y[3];
//   WheelJoint4.cylinder.ryvisobj[2] = WheelJoint4.cylinder.R.T[1,2] * WheelJoint4.cylinder.e_y[1] + WheelJoint4.cylinder.R.T[2,2] * WheelJoint4.cylinder.e_y[2] + WheelJoint4.cylinder.R.T[3,2] * WheelJoint4.cylinder.e_y[3];
//   WheelJoint4.cylinder.ryvisobj[3] = WheelJoint4.cylinder.R.T[1,3] * WheelJoint4.cylinder.e_y[1] + WheelJoint4.cylinder.R.T[2,3] * WheelJoint4.cylinder.e_y[2] + WheelJoint4.cylinder.R.T[3,3] * WheelJoint4.cylinder.e_y[3];
//   WheelJoint4.cylinder.rvisobj = WheelJoint4.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint4.cylinder.R.T[1,1],WheelJoint4.cylinder.R.T[1,2],WheelJoint4.cylinder.R.T[1,3]},{WheelJoint4.cylinder.R.T[2,1],WheelJoint4.cylinder.R.T[2,2],WheelJoint4.cylinder.R.T[2,3]},{WheelJoint4.cylinder.R.T[3,1],WheelJoint4.cylinder.R.T[3,2],WheelJoint4.cylinder.R.T[3,3]}},{WheelJoint4.cylinder.r_shape[1],WheelJoint4.cylinder.r_shape[2],WheelJoint4.cylinder.r_shape[3]});
//   WheelJoint4.cylinder.size[1] = WheelJoint4.cylinder.length;
//   WheelJoint4.cylinder.size[2] = WheelJoint4.cylinder.width;
//   WheelJoint4.cylinder.size[3] = WheelJoint4.cylinder.height;
//   WheelJoint4.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint4.cylinder.color[1] / 255.0,WheelJoint4.cylinder.color[2] / 255.0,WheelJoint4.cylinder.color[3] / 255.0,WheelJoint4.cylinder.specularCoefficient);
//   WheelJoint4.cylinder.Extra = WheelJoint4.cylinder.extra;
//   WheelJoint4.rim1.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint4.e0[2],WheelJoint4.e0[1],0.0},WheelJoint4.flange_a.phi,0.0);
//   WheelJoint4.rim1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint4.rim1.shapeType);
//   WheelJoint4.rim1.rxvisobj[1] = WheelJoint4.rim1.R.T[1,1] * WheelJoint4.rim1.e_x[1] + WheelJoint4.rim1.R.T[2,1] * WheelJoint4.rim1.e_x[2] + WheelJoint4.rim1.R.T[3,1] * WheelJoint4.rim1.e_x[3];
//   WheelJoint4.rim1.rxvisobj[2] = WheelJoint4.rim1.R.T[1,2] * WheelJoint4.rim1.e_x[1] + WheelJoint4.rim1.R.T[2,2] * WheelJoint4.rim1.e_x[2] + WheelJoint4.rim1.R.T[3,2] * WheelJoint4.rim1.e_x[3];
//   WheelJoint4.rim1.rxvisobj[3] = WheelJoint4.rim1.R.T[1,3] * WheelJoint4.rim1.e_x[1] + WheelJoint4.rim1.R.T[2,3] * WheelJoint4.rim1.e_x[2] + WheelJoint4.rim1.R.T[3,3] * WheelJoint4.rim1.e_x[3];
//   WheelJoint4.rim1.ryvisobj[1] = WheelJoint4.rim1.R.T[1,1] * WheelJoint4.rim1.e_y[1] + WheelJoint4.rim1.R.T[2,1] * WheelJoint4.rim1.e_y[2] + WheelJoint4.rim1.R.T[3,1] * WheelJoint4.rim1.e_y[3];
//   WheelJoint4.rim1.ryvisobj[2] = WheelJoint4.rim1.R.T[1,2] * WheelJoint4.rim1.e_y[1] + WheelJoint4.rim1.R.T[2,2] * WheelJoint4.rim1.e_y[2] + WheelJoint4.rim1.R.T[3,2] * WheelJoint4.rim1.e_y[3];
//   WheelJoint4.rim1.ryvisobj[3] = WheelJoint4.rim1.R.T[1,3] * WheelJoint4.rim1.e_y[1] + WheelJoint4.rim1.R.T[2,3] * WheelJoint4.rim1.e_y[2] + WheelJoint4.rim1.R.T[3,3] * WheelJoint4.rim1.e_y[3];
//   WheelJoint4.rim1.rvisobj = WheelJoint4.rim1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint4.rim1.R.T[1,1],WheelJoint4.rim1.R.T[1,2],WheelJoint4.rim1.R.T[1,3]},{WheelJoint4.rim1.R.T[2,1],WheelJoint4.rim1.R.T[2,2],WheelJoint4.rim1.R.T[2,3]},{WheelJoint4.rim1.R.T[3,1],WheelJoint4.rim1.R.T[3,2],WheelJoint4.rim1.R.T[3,3]}},{WheelJoint4.rim1.r_shape[1],WheelJoint4.rim1.r_shape[2],WheelJoint4.rim1.r_shape[3]});
//   WheelJoint4.rim1.size[1] = WheelJoint4.rim1.length;
//   WheelJoint4.rim1.size[2] = WheelJoint4.rim1.width;
//   WheelJoint4.rim1.size[3] = WheelJoint4.rim1.height;
//   WheelJoint4.rim1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint4.rim1.color[1] / 255.0,WheelJoint4.rim1.color[2] / 255.0,WheelJoint4.rim1.color[3] / 255.0,WheelJoint4.rim1.specularCoefficient);
//   WheelJoint4.rim1.Extra = WheelJoint4.rim1.extra;
//   WheelJoint4.rim2.R = Modelica.Mechanics.MultiBody.Frames.planarRotation({-WheelJoint4.e0[2],WheelJoint4.e0[1],0.0},1.5707963267948966 + WheelJoint4.flange_a.phi,0.0);
//   WheelJoint4.rim2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(WheelJoint4.rim2.shapeType);
//   WheelJoint4.rim2.rxvisobj[1] = WheelJoint4.rim2.R.T[1,1] * WheelJoint4.rim2.e_x[1] + WheelJoint4.rim2.R.T[2,1] * WheelJoint4.rim2.e_x[2] + WheelJoint4.rim2.R.T[3,1] * WheelJoint4.rim2.e_x[3];
//   WheelJoint4.rim2.rxvisobj[2] = WheelJoint4.rim2.R.T[1,2] * WheelJoint4.rim2.e_x[1] + WheelJoint4.rim2.R.T[2,2] * WheelJoint4.rim2.e_x[2] + WheelJoint4.rim2.R.T[3,2] * WheelJoint4.rim2.e_x[3];
//   WheelJoint4.rim2.rxvisobj[3] = WheelJoint4.rim2.R.T[1,3] * WheelJoint4.rim2.e_x[1] + WheelJoint4.rim2.R.T[2,3] * WheelJoint4.rim2.e_x[2] + WheelJoint4.rim2.R.T[3,3] * WheelJoint4.rim2.e_x[3];
//   WheelJoint4.rim2.ryvisobj[1] = WheelJoint4.rim2.R.T[1,1] * WheelJoint4.rim2.e_y[1] + WheelJoint4.rim2.R.T[2,1] * WheelJoint4.rim2.e_y[2] + WheelJoint4.rim2.R.T[3,1] * WheelJoint4.rim2.e_y[3];
//   WheelJoint4.rim2.ryvisobj[2] = WheelJoint4.rim2.R.T[1,2] * WheelJoint4.rim2.e_y[1] + WheelJoint4.rim2.R.T[2,2] * WheelJoint4.rim2.e_y[2] + WheelJoint4.rim2.R.T[3,2] * WheelJoint4.rim2.e_y[3];
//   WheelJoint4.rim2.ryvisobj[3] = WheelJoint4.rim2.R.T[1,3] * WheelJoint4.rim2.e_y[1] + WheelJoint4.rim2.R.T[2,3] * WheelJoint4.rim2.e_y[2] + WheelJoint4.rim2.R.T[3,3] * WheelJoint4.rim2.e_y[3];
//   WheelJoint4.rim2.rvisobj = WheelJoint4.rim2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{WheelJoint4.rim2.R.T[1,1],WheelJoint4.rim2.R.T[1,2],WheelJoint4.rim2.R.T[1,3]},{WheelJoint4.rim2.R.T[2,1],WheelJoint4.rim2.R.T[2,2],WheelJoint4.rim2.R.T[2,3]},{WheelJoint4.rim2.R.T[3,1],WheelJoint4.rim2.R.T[3,2],WheelJoint4.rim2.R.T[3,3]}},{WheelJoint4.rim2.r_shape[1],WheelJoint4.rim2.r_shape[2],WheelJoint4.rim2.r_shape[3]});
//   WheelJoint4.rim2.size[1] = WheelJoint4.rim2.length;
//   WheelJoint4.rim2.size[2] = WheelJoint4.rim2.width;
//   WheelJoint4.rim2.size[3] = WheelJoint4.rim2.height;
//   WheelJoint4.rim2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(WheelJoint4.rim2.color[1] / 255.0,WheelJoint4.rim2.color[2] / 255.0,WheelJoint4.rim2.color[3] / 255.0,WheelJoint4.rim2.specularCoefficient);
//   WheelJoint4.rim2.Extra = WheelJoint4.rim2.extra;
//   WheelJoint4.R[1,1] = cos(WheelJoint4.frame_a.phi);
//   WheelJoint4.R[1,2] = sin(WheelJoint4.frame_a.phi);
//   WheelJoint4.R[2,1] = -sin(WheelJoint4.frame_a.phi);
//   WheelJoint4.R[2,2] = cos(WheelJoint4.frame_a.phi);
//   WheelJoint4.e0[1] = WheelJoint4.R[1,1] * WheelJoint4.e[1] + WheelJoint4.R[1,2] * WheelJoint4.e[2];
//   WheelJoint4.e0[2] = WheelJoint4.R[2,1] * WheelJoint4.e[1] + WheelJoint4.R[2,2] * WheelJoint4.e[2];
//   WheelJoint4.v[1] = der(WheelJoint4.frame_a.x);
//   WheelJoint4.v[2] = der(WheelJoint4.frame_a.y);
//   WheelJoint4.w_roll = der(WheelJoint4.flange_a.phi);
//   WheelJoint4.v_long = WheelJoint4.v[1] * WheelJoint4.e0[1] + WheelJoint4.v[2] * WheelJoint4.e0[2];
//   WheelJoint4.v_lat = (-WheelJoint4.v[1]) * WheelJoint4.e0[2] + WheelJoint4.v[2] * WheelJoint4.e0[1];
//   WheelJoint4.v_slip_lat = WheelJoint4.v_lat;
//   WheelJoint4.v_slip_long = WheelJoint4.v_long - WheelJoint4.radius * WheelJoint4.w_roll;
//   WheelJoint4.v_slip = 0.0001 + sqrt(WheelJoint4.v_slip_long ^ 2.0 + WheelJoint4.v_slip_lat ^ 2.0);
//   (-WheelJoint4.f_long) * WheelJoint4.radius = WheelJoint4.flange_a.tau;
//   WheelJoint4.frame_a.t = 0.0;
//   WheelJoint4.f = WheelJoint4.N * PlanarMechanicsForTesting.Utilities.TripleS_Func(WheelJoint4.vAdhesion,WheelJoint4.vSlide,WheelJoint4.mu_A,WheelJoint4.mu_S,WheelJoint4.v_slip);
//   WheelJoint4.f_long = (WheelJoint4.f * WheelJoint4.v_slip_long) / WheelJoint4.v_slip;
//   WheelJoint4.f_lat = (WheelJoint4.f * WheelJoint4.v_slip_lat) / WheelJoint4.v_slip;
//   WheelJoint4.f_long = WheelJoint4.frame_a.fx * WheelJoint4.e0[1] + WheelJoint4.frame_a.fy * WheelJoint4.e0[2];
//   WheelJoint4.f_lat = WheelJoint4.frame_a.fy * WheelJoint4.e0[1] + (-WheelJoint4.frame_a.fx) * WheelJoint4.e0[2];
//   inertia3.phi = inertia3.flange_a.phi;
//   inertia3.phi = inertia3.flange_b.phi;
//   inertia3.w = der(inertia3.phi);
//   inertia3.a = der(inertia3.w);
//   inertia3.J * inertia3.a = inertia3.flange_a.tau + inertia3.flange_b.tau;
//   body2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.sphere.shapeType);
//   body2.sphere.rxvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_x[1] + body2.sphere.R.T[2,1] * body2.sphere.e_x[2] + body2.sphere.R.T[3,1] * body2.sphere.e_x[3];
//   body2.sphere.rxvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_x[1] + body2.sphere.R.T[2,2] * body2.sphere.e_x[2] + body2.sphere.R.T[3,2] * body2.sphere.e_x[3];
//   body2.sphere.rxvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_x[1] + body2.sphere.R.T[2,3] * body2.sphere.e_x[2] + body2.sphere.R.T[3,3] * body2.sphere.e_x[3];
//   body2.sphere.ryvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_y[1] + body2.sphere.R.T[2,1] * body2.sphere.e_y[2] + body2.sphere.R.T[3,1] * body2.sphere.e_y[3];
//   body2.sphere.ryvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_y[1] + body2.sphere.R.T[2,2] * body2.sphere.e_y[2] + body2.sphere.R.T[3,2] * body2.sphere.e_y[3];
//   body2.sphere.ryvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_y[1] + body2.sphere.R.T[2,3] * body2.sphere.e_y[2] + body2.sphere.R.T[3,3] * body2.sphere.e_y[3];
//   body2.sphere.rvisobj = body2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.sphere.R.T[1,1],body2.sphere.R.T[1,2],body2.sphere.R.T[1,3]},{body2.sphere.R.T[2,1],body2.sphere.R.T[2,2],body2.sphere.R.T[2,3]},{body2.sphere.R.T[3,1],body2.sphere.R.T[3,2],body2.sphere.R.T[3,3]}},{body2.sphere.r_shape[1],body2.sphere.r_shape[2],body2.sphere.r_shape[3]});
//   body2.sphere.size[1] = body2.sphere.length;
//   body2.sphere.size[2] = body2.sphere.width;
//   body2.sphere.size[3] = body2.sphere.height;
//   body2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.sphere.color[1] / 255.0,body2.sphere.color[2] / 255.0,body2.sphere.color[3] / 255.0,body2.sphere.specularCoefficient);
//   body2.sphere.Extra = body2.sphere.extra;
//   body2.r[1] = body2.frame_a.x;
//   body2.r[2] = body2.frame_a.y;
//   body2.v[1] = der(body2.r[1]);
//   body2.v[2] = der(body2.r[2]);
//   body2.w = der(body2.frame_a.phi);
//   body2.a[1] = der(body2.v[1]);
//   body2.a[2] = der(body2.v[2]);
//   body2.z = der(body2.w);
//   body2.f[1] = body2.frame_a.fx;
//   body2.f[2] = body2.frame_a.fy;
//   body2.f[1] + body2.g[1] * body2.m = body2.a[1] * body2.m;
//   body2.f[2] + body2.g[2] * body2.m = body2.a[2] * body2.m;
//   body2.frame_a.t = body2.I * body2.z;
//   actuatedRevolute.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute.cylinder.shapeType);
//   actuatedRevolute.cylinder.rxvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.rxvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_x[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_x[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_x[3];
//   actuatedRevolute.cylinder.ryvisobj[1] = actuatedRevolute.cylinder.R.T[1,1] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,1] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,1] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[2] = actuatedRevolute.cylinder.R.T[1,2] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,2] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,2] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.ryvisobj[3] = actuatedRevolute.cylinder.R.T[1,3] * actuatedRevolute.cylinder.e_y[1] + actuatedRevolute.cylinder.R.T[2,3] * actuatedRevolute.cylinder.e_y[2] + actuatedRevolute.cylinder.R.T[3,3] * actuatedRevolute.cylinder.e_y[3];
//   actuatedRevolute.cylinder.rvisobj = actuatedRevolute.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute.cylinder.R.T[1,1],actuatedRevolute.cylinder.R.T[1,2],actuatedRevolute.cylinder.R.T[1,3]},{actuatedRevolute.cylinder.R.T[2,1],actuatedRevolute.cylinder.R.T[2,2],actuatedRevolute.cylinder.R.T[2,3]},{actuatedRevolute.cylinder.R.T[3,1],actuatedRevolute.cylinder.R.T[3,2],actuatedRevolute.cylinder.R.T[3,3]}},{actuatedRevolute.cylinder.r_shape[1],actuatedRevolute.cylinder.r_shape[2],actuatedRevolute.cylinder.r_shape[3]});
//   actuatedRevolute.cylinder.size[1] = actuatedRevolute.cylinder.length;
//   actuatedRevolute.cylinder.size[2] = actuatedRevolute.cylinder.width;
//   actuatedRevolute.cylinder.size[3] = actuatedRevolute.cylinder.height;
//   actuatedRevolute.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute.cylinder.color[1] / 255.0,actuatedRevolute.cylinder.color[2] / 255.0,actuatedRevolute.cylinder.color[3] / 255.0,actuatedRevolute.cylinder.specularCoefficient);
//   actuatedRevolute.cylinder.Extra = actuatedRevolute.cylinder.extra;
//   actuatedRevolute.phi = actuatedRevolute.flange_a.phi;
//   actuatedRevolute.w = der(actuatedRevolute.phi);
//   actuatedRevolute.z = der(actuatedRevolute.w);
//   actuatedRevolute.t = actuatedRevolute.flange_a.tau;
//   actuatedRevolute.frame_a.x = actuatedRevolute.frame_b.x;
//   actuatedRevolute.frame_a.y = actuatedRevolute.frame_b.y;
//   actuatedRevolute.frame_a.phi + actuatedRevolute.phi = actuatedRevolute.frame_b.phi;
//   actuatedRevolute.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   actuatedRevolute.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   actuatedRevolute.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   actuatedRevolute.frame_a.t = actuatedRevolute.t;
//   actuatedRevolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(actuatedRevolute1.cylinder.shapeType);
//   actuatedRevolute1.cylinder.rxvisobj[1] = actuatedRevolute1.cylinder.R.T[1,1] * actuatedRevolute1.cylinder.e_x[1] + actuatedRevolute1.cylinder.R.T[2,1] * actuatedRevolute1.cylinder.e_x[2] + actuatedRevolute1.cylinder.R.T[3,1] * actuatedRevolute1.cylinder.e_x[3];
//   actuatedRevolute1.cylinder.rxvisobj[2] = actuatedRevolute1.cylinder.R.T[1,2] * actuatedRevolute1.cylinder.e_x[1] + actuatedRevolute1.cylinder.R.T[2,2] * actuatedRevolute1.cylinder.e_x[2] + actuatedRevolute1.cylinder.R.T[3,2] * actuatedRevolute1.cylinder.e_x[3];
//   actuatedRevolute1.cylinder.rxvisobj[3] = actuatedRevolute1.cylinder.R.T[1,3] * actuatedRevolute1.cylinder.e_x[1] + actuatedRevolute1.cylinder.R.T[2,3] * actuatedRevolute1.cylinder.e_x[2] + actuatedRevolute1.cylinder.R.T[3,3] * actuatedRevolute1.cylinder.e_x[3];
//   actuatedRevolute1.cylinder.ryvisobj[1] = actuatedRevolute1.cylinder.R.T[1,1] * actuatedRevolute1.cylinder.e_y[1] + actuatedRevolute1.cylinder.R.T[2,1] * actuatedRevolute1.cylinder.e_y[2] + actuatedRevolute1.cylinder.R.T[3,1] * actuatedRevolute1.cylinder.e_y[3];
//   actuatedRevolute1.cylinder.ryvisobj[2] = actuatedRevolute1.cylinder.R.T[1,2] * actuatedRevolute1.cylinder.e_y[1] + actuatedRevolute1.cylinder.R.T[2,2] * actuatedRevolute1.cylinder.e_y[2] + actuatedRevolute1.cylinder.R.T[3,2] * actuatedRevolute1.cylinder.e_y[3];
//   actuatedRevolute1.cylinder.ryvisobj[3] = actuatedRevolute1.cylinder.R.T[1,3] * actuatedRevolute1.cylinder.e_y[1] + actuatedRevolute1.cylinder.R.T[2,3] * actuatedRevolute1.cylinder.e_y[2] + actuatedRevolute1.cylinder.R.T[3,3] * actuatedRevolute1.cylinder.e_y[3];
//   actuatedRevolute1.cylinder.rvisobj = actuatedRevolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{actuatedRevolute1.cylinder.R.T[1,1],actuatedRevolute1.cylinder.R.T[1,2],actuatedRevolute1.cylinder.R.T[1,3]},{actuatedRevolute1.cylinder.R.T[2,1],actuatedRevolute1.cylinder.R.T[2,2],actuatedRevolute1.cylinder.R.T[2,3]},{actuatedRevolute1.cylinder.R.T[3,1],actuatedRevolute1.cylinder.R.T[3,2],actuatedRevolute1.cylinder.R.T[3,3]}},{actuatedRevolute1.cylinder.r_shape[1],actuatedRevolute1.cylinder.r_shape[2],actuatedRevolute1.cylinder.r_shape[3]});
//   actuatedRevolute1.cylinder.size[1] = actuatedRevolute1.cylinder.length;
//   actuatedRevolute1.cylinder.size[2] = actuatedRevolute1.cylinder.width;
//   actuatedRevolute1.cylinder.size[3] = actuatedRevolute1.cylinder.height;
//   actuatedRevolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(actuatedRevolute1.cylinder.color[1] / 255.0,actuatedRevolute1.cylinder.color[2] / 255.0,actuatedRevolute1.cylinder.color[3] / 255.0,actuatedRevolute1.cylinder.specularCoefficient);
//   actuatedRevolute1.cylinder.Extra = actuatedRevolute1.cylinder.extra;
//   actuatedRevolute1.phi = actuatedRevolute1.flange_a.phi;
//   actuatedRevolute1.w = der(actuatedRevolute1.phi);
//   actuatedRevolute1.z = der(actuatedRevolute1.w);
//   actuatedRevolute1.t = actuatedRevolute1.flange_a.tau;
//   actuatedRevolute1.frame_a.x = actuatedRevolute1.frame_b.x;
//   actuatedRevolute1.frame_a.y = actuatedRevolute1.frame_b.y;
//   actuatedRevolute1.frame_a.phi + actuatedRevolute1.phi = actuatedRevolute1.frame_b.phi;
//   actuatedRevolute1.frame_a.fx + actuatedRevolute1.frame_b.fx = 0.0;
//   actuatedRevolute1.frame_a.fy + actuatedRevolute1.frame_b.fy = 0.0;
//   actuatedRevolute1.frame_a.t + actuatedRevolute1.frame_b.t = 0.0;
//   actuatedRevolute1.frame_a.t = actuatedRevolute1.t;
//   torque.flange.tau = -torque.tau;
//   torque.phi_support = 0.0;
//   when sample(pulse.startTime,pulse.period) then
//   pulse.T0 = time;
//   end when;
//   pulse.y = pulse.offset + (if time < pulse.startTime or time >= pulse.T0 + pulse.T_width then 0.0 else pulse.amplitude);
//   (1.0 + differentialGear.idealPlanetary.ratio) * differentialGear.idealPlanetary.carrier.phi = differentialGear.idealPlanetary.sun.phi + differentialGear.idealPlanetary.ratio * differentialGear.idealPlanetary.ring.phi;
//   differentialGear.idealPlanetary.ring.tau = differentialGear.idealPlanetary.ratio * differentialGear.idealPlanetary.sun.tau;
//   differentialGear.idealPlanetary.carrier.tau = (-1.0 - differentialGear.idealPlanetary.ratio) * differentialGear.idealPlanetary.sun.tau;
//   leftTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(leftTrail.cylinder.shapeType);
//   leftTrail.cylinder.rxvisobj[1] = leftTrail.cylinder.R.T[1,1] * leftTrail.cylinder.e_x[1] + leftTrail.cylinder.R.T[2,1] * leftTrail.cylinder.e_x[2] + leftTrail.cylinder.R.T[3,1] * leftTrail.cylinder.e_x[3];
//   leftTrail.cylinder.rxvisobj[2] = leftTrail.cylinder.R.T[1,2] * leftTrail.cylinder.e_x[1] + leftTrail.cylinder.R.T[2,2] * leftTrail.cylinder.e_x[2] + leftTrail.cylinder.R.T[3,2] * leftTrail.cylinder.e_x[3];
//   leftTrail.cylinder.rxvisobj[3] = leftTrail.cylinder.R.T[1,3] * leftTrail.cylinder.e_x[1] + leftTrail.cylinder.R.T[2,3] * leftTrail.cylinder.e_x[2] + leftTrail.cylinder.R.T[3,3] * leftTrail.cylinder.e_x[3];
//   leftTrail.cylinder.ryvisobj[1] = leftTrail.cylinder.R.T[1,1] * leftTrail.cylinder.e_y[1] + leftTrail.cylinder.R.T[2,1] * leftTrail.cylinder.e_y[2] + leftTrail.cylinder.R.T[3,1] * leftTrail.cylinder.e_y[3];
//   leftTrail.cylinder.ryvisobj[2] = leftTrail.cylinder.R.T[1,2] * leftTrail.cylinder.e_y[1] + leftTrail.cylinder.R.T[2,2] * leftTrail.cylinder.e_y[2] + leftTrail.cylinder.R.T[3,2] * leftTrail.cylinder.e_y[3];
//   leftTrail.cylinder.ryvisobj[3] = leftTrail.cylinder.R.T[1,3] * leftTrail.cylinder.e_y[1] + leftTrail.cylinder.R.T[2,3] * leftTrail.cylinder.e_y[2] + leftTrail.cylinder.R.T[3,3] * leftTrail.cylinder.e_y[3];
//   leftTrail.cylinder.rvisobj = leftTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{leftTrail.cylinder.R.T[1,1],leftTrail.cylinder.R.T[1,2],leftTrail.cylinder.R.T[1,3]},{leftTrail.cylinder.R.T[2,1],leftTrail.cylinder.R.T[2,2],leftTrail.cylinder.R.T[2,3]},{leftTrail.cylinder.R.T[3,1],leftTrail.cylinder.R.T[3,2],leftTrail.cylinder.R.T[3,3]}},{leftTrail.cylinder.r_shape[1],leftTrail.cylinder.r_shape[2],leftTrail.cylinder.r_shape[3]});
//   leftTrail.cylinder.size[1] = leftTrail.cylinder.length;
//   leftTrail.cylinder.size[2] = leftTrail.cylinder.width;
//   leftTrail.cylinder.size[3] = leftTrail.cylinder.height;
//   leftTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(leftTrail.cylinder.color[1] / 255.0,leftTrail.cylinder.color[2] / 255.0,leftTrail.cylinder.color[3] / 255.0,leftTrail.cylinder.specularCoefficient);
//   leftTrail.cylinder.Extra = leftTrail.cylinder.extra;
//   leftTrail.R[1,1] = cos(leftTrail.frame_a.phi);
//   leftTrail.R[1,2] = sin(leftTrail.frame_a.phi);
//   leftTrail.R[2,1] = -sin(leftTrail.frame_a.phi);
//   leftTrail.R[2,2] = cos(leftTrail.frame_a.phi);
//   leftTrail.r0[1] = leftTrail.R[1,1] * leftTrail.r[1] + leftTrail.R[1,2] * leftTrail.r[2];
//   leftTrail.r0[2] = leftTrail.R[2,1] * leftTrail.r[1] + leftTrail.R[2,2] * leftTrail.r[2];
//   leftTrail.frame_a.x + leftTrail.r0[1] = leftTrail.frame_b.x;
//   leftTrail.frame_a.y + leftTrail.r0[2] = leftTrail.frame_b.y;
//   leftTrail.frame_a.phi = leftTrail.frame_b.phi;
//   leftTrail.frame_a.fx + leftTrail.frame_b.fx = 0.0;
//   leftTrail.frame_a.fy + leftTrail.frame_b.fy = 0.0;
//   leftTrail.frame_a.t + (leftTrail.frame_b.t + ((-leftTrail.r0[1]) * leftTrail.frame_b.fy + leftTrail.r0[2] * leftTrail.frame_b.fx)) = 0.0;
//   rightTrail.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rightTrail.cylinder.shapeType);
//   rightTrail.cylinder.rxvisobj[1] = rightTrail.cylinder.R.T[1,1] * rightTrail.cylinder.e_x[1] + rightTrail.cylinder.R.T[2,1] * rightTrail.cylinder.e_x[2] + rightTrail.cylinder.R.T[3,1] * rightTrail.cylinder.e_x[3];
//   rightTrail.cylinder.rxvisobj[2] = rightTrail.cylinder.R.T[1,2] * rightTrail.cylinder.e_x[1] + rightTrail.cylinder.R.T[2,2] * rightTrail.cylinder.e_x[2] + rightTrail.cylinder.R.T[3,2] * rightTrail.cylinder.e_x[3];
//   rightTrail.cylinder.rxvisobj[3] = rightTrail.cylinder.R.T[1,3] * rightTrail.cylinder.e_x[1] + rightTrail.cylinder.R.T[2,3] * rightTrail.cylinder.e_x[2] + rightTrail.cylinder.R.T[3,3] * rightTrail.cylinder.e_x[3];
//   rightTrail.cylinder.ryvisobj[1] = rightTrail.cylinder.R.T[1,1] * rightTrail.cylinder.e_y[1] + rightTrail.cylinder.R.T[2,1] * rightTrail.cylinder.e_y[2] + rightTrail.cylinder.R.T[3,1] * rightTrail.cylinder.e_y[3];
//   rightTrail.cylinder.ryvisobj[2] = rightTrail.cylinder.R.T[1,2] * rightTrail.cylinder.e_y[1] + rightTrail.cylinder.R.T[2,2] * rightTrail.cylinder.e_y[2] + rightTrail.cylinder.R.T[3,2] * rightTrail.cylinder.e_y[3];
//   rightTrail.cylinder.ryvisobj[3] = rightTrail.cylinder.R.T[1,3] * rightTrail.cylinder.e_y[1] + rightTrail.cylinder.R.T[2,3] * rightTrail.cylinder.e_y[2] + rightTrail.cylinder.R.T[3,3] * rightTrail.cylinder.e_y[3];
//   rightTrail.cylinder.rvisobj = rightTrail.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rightTrail.cylinder.R.T[1,1],rightTrail.cylinder.R.T[1,2],rightTrail.cylinder.R.T[1,3]},{rightTrail.cylinder.R.T[2,1],rightTrail.cylinder.R.T[2,2],rightTrail.cylinder.R.T[2,3]},{rightTrail.cylinder.R.T[3,1],rightTrail.cylinder.R.T[3,2],rightTrail.cylinder.R.T[3,3]}},{rightTrail.cylinder.r_shape[1],rightTrail.cylinder.r_shape[2],rightTrail.cylinder.r_shape[3]});
//   rightTrail.cylinder.size[1] = rightTrail.cylinder.length;
//   rightTrail.cylinder.size[2] = rightTrail.cylinder.width;
//   rightTrail.cylinder.size[3] = rightTrail.cylinder.height;
//   rightTrail.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rightTrail.cylinder.color[1] / 255.0,rightTrail.cylinder.color[2] / 255.0,rightTrail.cylinder.color[3] / 255.0,rightTrail.cylinder.specularCoefficient);
//   rightTrail.cylinder.Extra = rightTrail.cylinder.extra;
//   rightTrail.R[1,1] = cos(rightTrail.frame_a.phi);
//   rightTrail.R[1,2] = sin(rightTrail.frame_a.phi);
//   rightTrail.R[2,1] = -sin(rightTrail.frame_a.phi);
//   rightTrail.R[2,2] = cos(rightTrail.frame_a.phi);
//   rightTrail.r0[1] = rightTrail.R[1,1] * rightTrail.r[1] + rightTrail.R[1,2] * rightTrail.r[2];
//   rightTrail.r0[2] = rightTrail.R[2,1] * rightTrail.r[1] + rightTrail.R[2,2] * rightTrail.r[2];
//   rightTrail.frame_a.x + rightTrail.r0[1] = rightTrail.frame_b.x;
//   rightTrail.frame_a.y + rightTrail.r0[2] = rightTrail.frame_b.y;
//   rightTrail.frame_a.phi = rightTrail.frame_b.phi;
//   rightTrail.frame_a.fx + rightTrail.frame_b.fx = 0.0;
//   rightTrail.frame_a.fy + rightTrail.frame_b.fy = 0.0;
//   rightTrail.frame_a.t + (rightTrail.frame_b.t + ((-rightTrail.r0[1]) * rightTrail.frame_b.fy + rightTrail.r0[2] * rightTrail.frame_b.fx)) = 0.0;
//   body.frame_a.t + WheelJoint1.frame_a.t + leftTrail.frame_b.t = 0.0;
//   body.frame_a.fy + WheelJoint1.frame_a.fy + leftTrail.frame_b.fy = 0.0;
//   body.frame_a.fx + WheelJoint1.frame_a.fx + leftTrail.frame_b.fx = 0.0;
//   WheelJoint1.flange_a.tau + inertia.flange_b.tau = 0.0;
//   fixedTranslation1.frame_a.t + body1.frame_a.t + fixedTranslation2.frame_b.t + fixedTranslation3.frame_b.t = 0.0;
//   fixedTranslation1.frame_a.fy + body1.frame_a.fy + fixedTranslation2.frame_b.fy + fixedTranslation3.frame_b.fy = 0.0;
//   fixedTranslation1.frame_a.fx + body1.frame_a.fx + fixedTranslation2.frame_b.fx + fixedTranslation3.frame_b.fx = 0.0;
//   fixedTranslation1.frame_b.t + fixedTranslation4.frame_b.t + fixedTranslation5.frame_b.t = 0.0;
//   fixedTranslation1.frame_b.fy + fixedTranslation4.frame_b.fy + fixedTranslation5.frame_b.fy = 0.0;
//   fixedTranslation1.frame_b.fx + fixedTranslation4.frame_b.fx + fixedTranslation5.frame_b.fx = 0.0;
//   WheelJoint2.frame_a.t + fixedTranslation2.frame_a.t = 0.0;
//   WheelJoint2.frame_a.fy + fixedTranslation2.frame_a.fy = 0.0;
//   WheelJoint2.frame_a.fx + fixedTranslation2.frame_a.fx = 0.0;
//   WheelJoint2.flange_a.tau + inertia1.flange_b.tau + differentialGear.flange_left.tau = 0.0;
//   constantTorque1.flange.tau + differentialGear.flange_b.tau = 0.0;
//   inertia.flange_a.tau = 0.0;
//   inertia1.flange_a.tau = 0.0;
//   fixedTranslation3.frame_a.t + WheelJoint3.frame_a.t = 0.0;
//   fixedTranslation3.frame_a.fy + WheelJoint3.frame_a.fy = 0.0;
//   fixedTranslation3.frame_a.fx + WheelJoint3.frame_a.fx = 0.0;
//   WheelJoint3.flange_a.tau + inertia2.flange_b.tau + differentialGear.flange_right.tau = 0.0;
//   inertia2.flange_a.tau = 0.0;
//   fixedTranslation4.frame_a.t + actuatedRevolute.frame_b.t = 0.0;
//   fixedTranslation4.frame_a.fy + actuatedRevolute.frame_b.fy = 0.0;
//   fixedTranslation4.frame_a.fx + actuatedRevolute.frame_b.fx = 0.0;
//   fixedTranslation5.frame_a.t + actuatedRevolute1.frame_b.t = 0.0;
//   fixedTranslation5.frame_a.fy + actuatedRevolute1.frame_b.fy = 0.0;
//   fixedTranslation5.frame_a.fx + actuatedRevolute1.frame_b.fx = 0.0;
//   WheelJoint4.frame_a.t + body2.frame_a.t + rightTrail.frame_b.t = 0.0;
//   WheelJoint4.frame_a.fy + body2.frame_a.fy + rightTrail.frame_b.fy = 0.0;
//   WheelJoint4.frame_a.fx + body2.frame_a.fx + rightTrail.frame_b.fx = 0.0;
//   WheelJoint4.flange_a.tau + inertia3.flange_b.tau = 0.0;
//   inertia3.flange_a.tau = 0.0;
//   actuatedRevolute.frame_a.t + leftTrail.frame_a.t = 0.0;
//   actuatedRevolute.frame_a.fy + leftTrail.frame_a.fy = 0.0;
//   actuatedRevolute.frame_a.fx + leftTrail.frame_a.fx = 0.0;
//   actuatedRevolute.flange_a.tau + actuatedRevolute1.flange_a.tau + torque.flange.tau = 0.0;
//   actuatedRevolute1.frame_a.t + rightTrail.frame_a.t = 0.0;
//   actuatedRevolute1.frame_a.fy + rightTrail.frame_a.fy = 0.0;
//   actuatedRevolute1.frame_a.fx + rightTrail.frame_a.fx = 0.0;
//   differentialGear.idealPlanetary.sun.tau + -differentialGear.flange_left.tau = 0.0;
//   differentialGear.idealPlanetary.carrier.tau + -differentialGear.flange_right.tau = 0.0;
//   differentialGear.idealPlanetary.ring.tau + -differentialGear.flange_b.tau = 0.0;
//   differentialGear.flange_b.phi = differentialGear.idealPlanetary.ring.phi;
//   differentialGear.flange_right.phi = differentialGear.idealPlanetary.carrier.phi;
//   differentialGear.flange_left.phi = differentialGear.idealPlanetary.sun.phi;
//   WheelJoint2.flange_a.phi = differentialGear.flange_left.phi;
//   WheelJoint2.flange_a.phi = inertia1.flange_b.phi;
//   WheelJoint1.flange_a.phi = inertia.flange_b.phi;
//   body1.frame_a.x = fixedTranslation1.frame_a.x;
//   body1.frame_a.x = fixedTranslation2.frame_b.x;
//   body1.frame_a.x = fixedTranslation3.frame_b.x;
//   body1.frame_a.y = fixedTranslation1.frame_a.y;
//   body1.frame_a.y = fixedTranslation2.frame_b.y;
//   body1.frame_a.y = fixedTranslation3.frame_b.y;
//   body1.frame_a.phi = fixedTranslation1.frame_a.phi;
//   body1.frame_a.phi = fixedTranslation2.frame_b.phi;
//   body1.frame_a.phi = fixedTranslation3.frame_b.phi;
//   WheelJoint2.frame_a.x = fixedTranslation2.frame_a.x;
//   WheelJoint2.frame_a.y = fixedTranslation2.frame_a.y;
//   WheelJoint2.frame_a.phi = fixedTranslation2.frame_a.phi;
//   WheelJoint3.frame_a.x = fixedTranslation3.frame_a.x;
//   WheelJoint3.frame_a.y = fixedTranslation3.frame_a.y;
//   WheelJoint3.frame_a.phi = fixedTranslation3.frame_a.phi;
//   WheelJoint3.flange_a.phi = differentialGear.flange_right.phi;
//   WheelJoint3.flange_a.phi = inertia2.flange_b.phi;
//   fixedTranslation1.frame_b.x = fixedTranslation4.frame_b.x;
//   fixedTranslation1.frame_b.x = fixedTranslation5.frame_b.x;
//   fixedTranslation1.frame_b.y = fixedTranslation4.frame_b.y;
//   fixedTranslation1.frame_b.y = fixedTranslation5.frame_b.y;
//   fixedTranslation1.frame_b.phi = fixedTranslation4.frame_b.phi;
//   fixedTranslation1.frame_b.phi = fixedTranslation5.frame_b.phi;
//   WheelJoint4.flange_a.phi = inertia3.flange_b.phi;
//   actuatedRevolute1.frame_b.x = fixedTranslation5.frame_a.x;
//   actuatedRevolute1.frame_b.y = fixedTranslation5.frame_a.y;
//   actuatedRevolute1.frame_b.phi = fixedTranslation5.frame_a.phi;
//   actuatedRevolute.frame_b.x = fixedTranslation4.frame_a.x;
//   actuatedRevolute.frame_b.y = fixedTranslation4.frame_a.y;
//   actuatedRevolute.frame_b.phi = fixedTranslation4.frame_a.phi;
//   actuatedRevolute.flange_a.phi = actuatedRevolute1.flange_a.phi;
//   actuatedRevolute.flange_a.phi = torque.flange.phi;
//   pulse.y = torque.tau;
//   constantTorque1.flange.phi = differentialGear.flange_b.phi;
//   WheelJoint1.frame_a.x = body.frame_a.x;
//   WheelJoint1.frame_a.x = leftTrail.frame_b.x;
//   WheelJoint1.frame_a.y = body.frame_a.y;
//   WheelJoint1.frame_a.y = leftTrail.frame_b.y;
//   WheelJoint1.frame_a.phi = body.frame_a.phi;
//   WheelJoint1.frame_a.phi = leftTrail.frame_b.phi;
//   actuatedRevolute.frame_a.x = leftTrail.frame_a.x;
//   actuatedRevolute.frame_a.y = leftTrail.frame_a.y;
//   actuatedRevolute.frame_a.phi = leftTrail.frame_a.phi;
//   WheelJoint4.frame_a.x = body2.frame_a.x;
//   WheelJoint4.frame_a.x = rightTrail.frame_b.x;
//   WheelJoint4.frame_a.y = body2.frame_a.y;
//   WheelJoint4.frame_a.y = rightTrail.frame_b.y;
//   WheelJoint4.frame_a.phi = body2.frame_a.phi;
//   WheelJoint4.frame_a.phi = rightTrail.frame_b.phi;
//   actuatedRevolute1.frame_a.x = rightTrail.frame_a.x;
//   actuatedRevolute1.frame_a.y = rightTrail.frame_a.y;
//   actuatedRevolute1.frame_a.phi = rightTrail.frame_a.phi;
// end PlanarMechanicsForTesting.Examples.SimpleCarWithDifferentialGear;
// "
// ""
// endResult
